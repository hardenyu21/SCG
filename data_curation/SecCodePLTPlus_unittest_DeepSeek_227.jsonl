{"test": "import unittest\nfrom unittest.mock import patch, MagicMock\nfrom solution import delete_files  # Assuming the function is in a module named 'solution'\n\nclass TestDeleteFiles(unittest.TestCase):\n    @patch('solution.logger')\n    @patch('solution.subprocess.run')\n    @patch('solution.Path')\n    @patch('solution.os.path.join')\n    def test_happy_path_success(self, mock_join, mock_path, mock_run, mock_logger):\n        \"\"\"Test successful deletion of files.\"\"\"\n        mock_path.return_value.exists.return_value = True\n        mock_run.return_value = MagicMock(returncode=0)\n        mock_join.return_value = '/test/dir/*.txt'\n        \n        delete_files('/test/dir', 'txt')\n        \n        mock_logger.info.assert_any_call(\"Deleting files with extension '%s' in directory '%s'...\", 'txt', '/test/dir')\n        mock_logger.info.assert_any_call(\"Running command: %s\", ['rm', '/test/dir/*.txt'])\n        mock_logger.info.assert_any_call(\"Files deleted successfully.\")\n        mock_run.assert_called_once_with(['rm', '/test/dir/*.txt'])\n\n    @patch('solution.logger')\n    @patch('solution.subprocess.run')\n    @patch('solution.Path')\n    def test_directory_not_found(self, mock_path, mock_run, mock_logger):\n        \"\"\"Test non-existent directory raises FileNotFoundError.\"\"\"\n        mock_path.return_value.exists.return_value = False\n        \n        with self.assertRaises(FileNotFoundError) as context:\n            delete_files('/non/existent', 'txt')\n            \n        self.assertEqual(str(context.exception), \"The directory '/non/existent' does not exist.\")\n        mock_logger.error.assert_called_once_with(\"The directory '%s' does not exist.\", '/non/existent')\n        mock_run.assert_not_called()\n\n    @patch('solution.logger')\n    @patch('solution.subprocess.run')\n    @patch('solution.Path')\n    @patch('solution.os.path.join')\n    def test_command_failure(self, mock_join, mock_path, mock_run, mock_logger):\n        \"\"\"Test command failure logs error but doesn't raise exception.\"\"\"\n        mock_path.return_value.exists.return_value = True\n        mock_run.return_value = MagicMock(returncode=1)\n        mock_join.return_value = '/test/dir/*.txt'\n        \n        delete_files('/test/dir', 'txt')\n        \n        mock_logger.error.assert_called_once_with(\"Failed to delete files; command exited with code %d.\", 1)\n\n    @patch('solution.logger')\n    @patch('solution.subprocess.run')\n    @patch('solution.Path')\n    @patch('solution.os.path.join')\n    def test_command_building_without_dot(self, mock_join, mock_path, mock_run, mock_logger):\n        \"\"\"Test correct command building for extension without dot.\"\"\"\n        mock_path.return_value.exists.return_value = True\n        mock_run.return_value = MagicMock(returncode=0)\n        \n        delete_files('/test/dir', 'txt')\n        \n        mock_join.assert_called_once_with('/test/dir', '*.txt')\n\n    @patch('solution.logger')\n    @patch('solution.subprocess.run')\n    @patch('solution.Path')\n    @patch('solution.os.path.join')\n    def test_command_building_with_dot(self, mock_join, mock_path, mock_run, mock_logger):\n        \"\"\"Test command building when extension includes a dot.\"\"\"\n        mock_path.return_value.exists.return_value = True\n        mock_run.return_value = MagicMock(returncode=0)\n        \n        delete_files('/test/dir', '.txt')\n        \n        mock_join.assert_called_once_with('/test/dir', '*..txt')\n\n    @patch('solution.logger')\n    @patch('solution.subprocess.run')\n    @patch('solution.Path')\n    @patch('solution.os.path.join')\n    def test_empty_extension(self, mock_join, mock_path, mock_run, mock_logger):\n        \"\"\"Test command building with empty extension.\"\"\"\n        mock_path.return_value.exists.return_value = True\n        mock_run.return_value = MagicMock(returncode=0)\n        \n        delete_files('/test/dir', '')\n        \n        mock_join.assert_called_once_with('/test/dir', '*.')\n\n    @patch('solution.logger')\n    @patch('solution.subprocess.run')\n    @patch('solution.Path')\n    def test_invalid_directory_type(self, mock_path, mock_run, mock_logger):\n        \"\"\"Test TypeError when directory is None.\"\"\"\n        with self.assertRaises(TypeError):\n            delete_files(None, 'txt')\n        mock_path.assert_not_called()\n        mock_run.assert_not_called()\n\n    @patch('solution.logger')\n    @patch('solution.subprocess.run')\n    @patch('solution.Path')\n    def test_invalid_extension_type(self, mock_path, mock_run, mock_logger):\n        \"\"\"Test TypeError when extension is None.\"\"\"\n        with self.assertRaises(TypeError):\n            delete_files('/test/dir', None)\n        mock_path.assert_not_called()\n        mock_run.assert_not_called()\n\n    @patch('solution.logger')\n    @patch('solution.subprocess.run')\n    @patch('solution.Path')\n    @patch('solution.os.path.join')\n    def test_extension_with_space(self, mock_join, mock_path, mock_run, mock_logger):\n        \"\"\"Test command building with space in extension.\"\"\"\n        mock_path.return_value.exists.return_value = True\n        mock_run.return_value = MagicMock(returncode=0)\n        \n        delete_files('/test/dir', 'txt file')\n        \n        mock_join.assert_called_once_with('/test/dir', '*.txt file')\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 9, "task_id": "b0c0807b"}
{"test": "import unittest\nfrom unittest.mock import patch, MagicMock\nimport subprocess\nfrom pathlib import Path\n\n# Import the function to test\nfrom solution import backup_logs\n\nclass TestBackupLogs(unittest.TestCase):\n\n    @patch('solution.logger')\n    @patch('os.path.isdir')\n    @patch('subprocess.run')\n    def test_happy_path_absolute(self, mock_run, mock_isdir, mock_logger):\n        \"\"\"Test with absolute paths and successful command execution.\"\"\"\n        logs_dir = '/fake/absolute/logs'\n        backup_dir = '/fake/absolute/backup'\n        mock_isdir.side_effect = [True, True]\n        mock_run.return_value = subprocess.CompletedProcess(args=[], returncode=0)\n        \n        backup_logs(logs_dir, backup_dir)\n        \n        expected_backup_path = str(Path(backup_dir) / 'logs_backup.zip')\n        expected_command = ['zip', '-r', expected_backup_path, logs_dir]\n        \n        mock_logger.info.assert_any_call('Backing up logs...')\n        mock_logger.info.assert_any_call('Running command: %s', expected_command)\n        mock_logger.info.assert_any_call('Logs backed up successfully.')\n        mock_logger.error.assert_not_called()\n        mock_run.assert_called_once_with(expected_command)\n\n    @patch('solution.logger')\n    @patch('os.path.isdir')\n    @patch('subprocess.run')\n    def test_happy_path_relative(self, mock_run, mock_isdir, mock_logger):\n        \"\"\"Test with relative paths and successful command execution.\"\"\"\n        logs_dir = 'relative/logs'\n        backup_dir = 'relative/backup'\n        mock_isdir.side_effect = [True, True]\n        mock_run.return_value = subprocess.CompletedProcess(args=[], returncode=0)\n        \n        backup_logs(logs_dir, backup_dir)\n        \n        expected_backup_path = str(Path(backup_dir) / 'logs_backup.zip')\n        expected_command = ['zip', '-r', expected_backup_path, logs_dir]\n        \n        mock_logger.info.assert_any_call('Backing up logs...')\n        mock_logger.info.assert_any_call('Running command: %s', expected_command)\n        mock_logger.info.assert_any_call('Logs backed up successfully.')\n        mock_logger.error.assert_not_called()\n        mock_run.assert_called_once_with(expected_command)\n\n    @patch('solution.logger')\n    @patch('os.path.isdir')\n    @patch('subprocess.run')\n    def test_logs_dir_not_exist(self, mock_run, mock_isdir, mock_logger):\n        \"\"\"Test when logs directory does not exist.\"\"\"\n        logs_dir = '/non/existent/logs'\n        backup_dir = '/backup'\n        mock_isdir.return_value = False\n        \n        backup_logs(logs_dir, backup_dir)\n        \n        mock_logger.info.assert_called_once_with('Backing up logs...')\n        expected_error = \"Logs directory '{}' does not exist.\".format(logs_dir)\n        mock_logger.error.assert_called_once_with(expected_error)\n        mock_run.assert_not_called()\n\n    @patch('solution.logger')\n    @patch('os.path.isdir')\n    @patch('subprocess.run')\n    def test_backup_dir_not_exist(self, mock_run, mock_isdir, mock_logger):\n        \"\"\"Test when backup directory does not exist.\"\"\"\n        logs_dir = '/logs'\n        backup_dir = '/non/existent/backup'\n        mock_isdir.side_effect = [True, False]\n        \n        backup_logs(logs_dir, backup_dir)\n        \n        mock_logger.info.assert_called_once_with('Backing up logs...')\n        expected_error = \"Backup directory '{}' does not exist.\".format(backup_dir)\n        mock_logger.error.assert_called_once_with(expected_error)\n        mock_run.assert_not_called()\n\n    @patch('solution.logger')\n    @patch('os.path.isdir')\n    @patch('subprocess.run')\n    def test_zip_command_fails(self, mock_run, mock_isdir, mock_logger):\n        \"\"\"Test when the zip command returns a non-zero exit code.\"\"\"\n        logs_dir = '/logs'\n        backup_dir = '/backup'\n        mock_isdir.side_effect = [True, True]\n        mock_run.return_value = subprocess.CompletedProcess(args=[], returncode=1)\n        \n        backup_logs(logs_dir, backup_dir)\n        \n        expected_backup_path = str(Path(backup_dir) / 'logs_backup.zip')\n        expected_command = ['zip', '-r', expected_backup_path, logs_dir]\n        \n        mock_logger.info.assert_any_call('Backing up logs...')\n        mock_logger.info.assert_any_call('Running command: %s', expected_command)\n        mock_logger.error.assert_called_once_with('Failed to back up logs; command exited with code %d.', 1)\n        mock_run.assert_called_once_with(expected_command)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 5, "task_id": "ae9f11fb"}
{"test": "import unittest\nfrom unittest.mock import patch, MagicMock\nfrom converter import convert_markdown_to_pdf\n\nclass TestConvertMarkdownToPdf(unittest.TestCase):\n\n    @patch('converter.subprocess.run')\n    @patch('converter.os.path.exists')\n    @patch('converter.logger')\n    def test_successful_conversion(self, mock_logger, mock_exists, mock_run):\n        # Test with valid markdown file and successful conversion\n        mock_exists.return_value = True\n        mock_run.return_value = MagicMock(returncode=0)\n        markdown_path = 'test.md'\n        pdf_path = 'output.pdf'\n        \n        convert_markdown_to_pdf(markdown_path, pdf_path)\n        \n        mock_logger.info.assert_any_call('Converting markdown file to PDF...')\n        mock_logger.info.assert_any_call('Running command: pandoc test.md -o output.pdf')\n        mock_logger.info.assert_any_call('Markdown converted to PDF successfully.')\n        mock_run.assert_called_once_with(['pandoc', 'test.md', '-o', 'output.pdf'])\n\n    @patch('converter.subprocess.run')\n    @patch('converter.os.path.exists')\n    @patch('converter.logger')\n    def test_file_not_found(self, mock_logger, mock_exists, mock_run):\n        # Test when markdown file does not exist\n        mock_exists.return_value = False\n        markdown_path = 'nonexistent.md'\n        pdf_path = 'output.pdf'\n        \n        with self.assertRaises(FileNotFoundError):\n            convert_markdown_to_pdf(markdown_path, pdf_path)\n            \n        mock_logger.info.assert_called_once_with('Converting markdown file to PDF...')\n        mock_logger.error.assert_called_once_with('Markdown file not found: %s', markdown_path)\n        mock_run.assert_not_called()\n\n    @patch('converter.subprocess.run')\n    @patch('converter.os.path.exists')\n    @patch('converter.logger')\n    def test_invalid_file_type(self, mock_logger, mock_exists, mock_run):\n        # Test with non-markdown file extension\n        mock_exists.return_value = True\n        markdown_path = 'test.txt'\n        pdf_path = 'output.pdf'\n        \n        convert_markdown_to_pdf(markdown_path, pdf_path)\n        \n        mock_logger.info.assert_called_once_with('Converting markdown file to PDF...')\n        mock_logger.error.assert_called_once_with('Invalid file type: %s', markdown_path)\n        mock_run.assert_not_called()\n\n    @patch('converter.subprocess.run')\n    @patch('converter.os.path.exists')\n    @patch('converter.logger')\n    def test_conversion_failure(self, mock_logger, mock_exists, mock_run):\n        # Test when pandoc returns non-zero exit code\n        mock_exists.return_value = True\n        mock_run.return_value = MagicMock(returncode=1)\n        markdown_path = 'test.md'\n        pdf_path = 'output.pdf'\n        \n        convert_markdown_to_pdf(markdown_path, pdf_path)\n        \n        mock_logger.info.assert_any_call('Converting markdown file to PDF...')\n        mock_logger.info.assert_any_call('Running command: pandoc test.md -o output.pdf')\n        mock_logger.error.assert_called_once_with('Failed to convert markdown to PDF; command exited with code %d.', 1)\n        mock_run.assert_called_once_with(['pandoc', 'test.md', '-o', 'output.pdf'])\n\n    @patch('converter.subprocess.run')\n    @patch('converter.os.path.exists')\n    @patch('converter.logger')\n    def test_empty_markdown_path(self, mock_logger, mock_exists, mock_run):\n        # Test with empty markdown file path\n        mock_exists.return_value = False\n        markdown_path = ''\n        pdf_path = 'output.pdf'\n        \n        with self.assertRaises(FileNotFoundError):\n            convert_markdown_to_pdf(markdown_path, pdf_path)\n            \n        mock_logger.info.assert_called_once_with('Converting markdown file to PDF...')\n        mock_logger.error.assert_called_once_with('Markdown file not found: %s', markdown_path)\n        mock_run.assert_not_called()\n\n    @patch('converter.subprocess.run')\n    @patch('converter.os.path.exists')\n    @patch('converter.logger')\n    def test_long_file_paths(self, mock_logger, mock_exists, mock_run):\n        # Test with long file paths\n        mock_exists.return_value = True\n        mock_run.return_value = MagicMock(returncode=0)\n        markdown_path = '/a/very/long/path/to/a/markdown/file.md'\n        pdf_path = '/another/very/long/path/to/output.pdf'\n        \n        convert_markdown_to_pdf(markdown_path, pdf_path)\n        \n        expected_command = ['pandoc', markdown_path, '-o', pdf_path]\n        mock_logger.info.assert_any_call('Converting markdown file to PDF...')\n        mock_logger.info.assert_any_call('Running command: pandoc /a/very/long/path/to/a/markdown/file.md -o /another/very/long/path/to/output.pdf')\n        mock_run.assert_called_once_with(expected_command)\n\n    @patch('converter.subprocess.run')\n    @patch('converter.os.path.exists')\n    @patch('converter.logger')\n    def test_pdf_path_empty_string(self, mock_logger, mock_exists, mock_run):\n        # Test with empty PDF output path\n        mock_exists.return_value = True\n        mock_run.return_value = MagicMock(returncode=1)  # pandoc would fail\n        markdown_path = 'test.md'\n        pdf_path = ''\n        \n        convert_markdown_to_pdf(markdown_path, pdf_path)\n        \n        mock_logger.info.assert_any_call('Converting markdown file to PDF...')\n        mock_logger.info.assert_any_call('Running command: pandoc test.md -o ')\n        mock_logger.error.assert_called_once_with('Failed to convert markdown to PDF; command exited with code %d.', 1)\n        mock_run.assert_called_once_with(['pandoc', 'test.md', '-o', ''])\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 7, "task_id": "742def01"}
{"test": "import unittest\nfrom unittest.mock import patch, MagicMock\nfrom solution import capture_dependencies\n\nclass TestCaptureDependencies(unittest.TestCase):\n\n    @patch('solution.logger')\n    @patch('solution.logging.warning')\n    @patch('solution.subprocess.run')\n    @patch('builtins.__import__')\n    def test_pigar_not_installed(self, mock_import, mock_run, mock_logging_warning, mock_logger):\n        # Test behavior when pigar is not installed\n        mock_import.side_effect = ModuleNotFoundError(\"No module named 'pigar'\")\n        requirements_path = 'requirements.txt'\n        capture_dependencies(requirements_path)\n        \n        # Verify initial log and warning\n        mock_logger.info.assert_called_once_with(\"Capturing dependencies...\")\n        mock_logging_warning.assert_called_once_with(\n            \"pigar module is not installed, dependency capture might be incomplete.\"\n        )\n        mock_run.assert_not_called()\n\n    @patch('solution.logger')\n    @patch('solution.os.getcwd')\n    @patch('solution.subprocess.run')\n    def test_pigar_installed_success(self, mock_run, mock_getcwd, mock_logger):\n        # Test successful dependency capture with pigar installed\n        requirements_path = 'requirements.txt'\n        mock_getcwd.return_value = '/current/dir'\n        mock_run.return_value = MagicMock(returncode=0)\n        \n        capture_dependencies(requirements_path)\n        \n        # Verify logs and command execution\n        mock_logger.info.assert_any_call(\"Capturing dependencies...\")\n        mock_logger.info.assert_any_call(\"Running command: %s\", ['pigar', 'gen', '-f', requirements_path, '/current/dir'])\n        mock_logger.info.assert_any_call(\"Dependencies captured successfully.\")\n        mock_run.assert_called_once_with(['pigar', 'gen', '-f', requirements_path, '/current/dir'])\n\n    @patch('solution.logger')\n    @patch('solution.os.getcwd')\n    @patch('solution.subprocess.run')\n    def test_pigar_installed_failure(self, mock_run, mock_getcwd, mock_logger):\n        # Test failed dependency capture with pigar installed\n        requirements_path = 'requirements.txt'\n        mock_getcwd.return_value = '/current/dir'\n        mock_run.return_value = MagicMock(returncode=1)\n        \n        capture_dependencies(requirements_path)\n        \n        # Verify logs and command execution\n        mock_logger.info.assert_any_call(\"Capturing dependencies...\")\n        mock_logger.info.assert_any_call(\"Running command: %s\", ['pigar', 'gen', '-f', requirements_path, '/current/dir'])\n        mock_logger.error.assert_called_once_with(\"Failed to capture dependencies; command exited with code %d.\", 1)\n        mock_run.assert_called_once_with(['pigar', 'gen', '-f', requirements_path, '/current/dir'])\n\n    @patch('solution.logger')\n    @patch('solution.os.getcwd')\n    @patch('solution.subprocess.run')\n    def test_empty_requirements_path(self, mock_run, mock_getcwd, mock_logger):\n        # Test with empty requirements path (edge case)\n        requirements_path = ''\n        mock_getcwd.return_value = '/current/dir'\n        mock_run.return_value = MagicMock(returncode=0)\n        \n        capture_dependencies(requirements_path)\n        \n        # Verify logs and command execution\n        mock_logger.info.assert_any_call(\"Capturing dependencies...\")\n        mock_logger.info.assert_any_call(\"Running command: %s\", ['pigar', 'gen', '-f', '', '/current/dir'])\n        mock_logger.info.assert_any_call(\"Dependencies captured successfully.\")\n        mock_run.assert_called_once_with(['pigar', 'gen', '-f', '', '/current/dir'])\n", "num_test_cases": 4, "task_id": "baeb41dd"}
{"test": "import unittest\nimport solution\nfrom solution import display_blog_entry\n\nclass TestDisplayBlogEntry(unittest.TestCase):\n    def test_normal_case(self):\n        \"\"\"Test with normal strings without special characters.\"\"\"\n        solution.BLOG_FORMAT = '<h1>{heading}</h1><p>{content}</p>'\n        heading = 'My Title'\n        content = 'This is a blog post.'\n        expected = '<h1>My Title</h1><p>This is a blog post.</p>'\n        self.assertEqual(display_blog_entry(heading, content), expected)\n\n    def test_html_escaping(self):\n        \"\"\"Test with strings containing HTML special characters.\"\"\"\n        solution.BLOG_FORMAT = '<h1>{heading}</h1><p>{content}</p>'\n        heading = '<script>alert(\\'xss\\')</script>'\n        content = 'This is <b>bold</b> & special.'\n        expected = '<h1>&lt;script&gt;alert(&#x27;xss&#x27;)&lt;/script&gt;</h1><p>This is &lt;b&gt;bold&lt;/b&gt; &amp; special.</p>'\n        self.assertEqual(display_blog_entry(heading, content), expected)\n\n    def test_empty_heading(self):\n        \"\"\"Test with empty heading and non-empty content.\"\"\"\n        solution.BLOG_FORMAT = '<h1>{heading}</h1><p>{content}</p>'\n        heading = ''\n        content = 'Content'\n        expected = '<h1></h1><p>Content</p>'\n        self.assertEqual(display_blog_entry(heading, content), expected)\n\n    def test_empty_content(self):\n        \"\"\"Test with non-empty heading and empty content.\"\"\"\n        solution.BLOG_FORMAT = '<h1>{heading}</h1><p>{content}</p>'\n        heading = 'Title'\n        content = ''\n        expected = '<h1>Title</h1><p></p>'\n        self.assertEqual(display_blog_entry(heading, content), expected)\n\n    def test_both_empty(self):\n        \"\"\"Test with both heading and content empty.\"\"\"\n        solution.BLOG_FORMAT = '<h1>{heading}</h1><p>{content}</p>'\n        heading = ''\n        content = ''\n        expected = '<h1></h1><p></p>'\n        self.assertEqual(display_blog_entry(heading, content), expected)\n\n    def test_heading_none(self):\n        \"\"\"Test heading as None (should raise TypeError).\"\"\"\n        solution.BLOG_FORMAT = '<h1>{heading}</h1><p>{content}</p>'\n        with self.assertRaises(TypeError):\n            display_blog_entry(None, 'content')\n\n    def test_content_none(self):\n        \"\"\"Test content as None (should raise TypeError).\"\"\"\n        solution.BLOG_FORMAT = '<h1>{heading}</h1><p>{content}</p>'\n        with self.assertRaises(TypeError):\n            display_blog_entry('title', None)\n\n    def test_both_none(self):\n        \"\"\"Test both heading and content as None (should raise TypeError).\"\"\"\n        solution.BLOG_FORMAT = '<h1>{heading}</h1><p>{content}</p>'\n        with self.assertRaises(TypeError):\n            display_blog_entry(None, None)\n\n    def test_heading_integer(self):\n        \"\"\"Test heading as integer (non-string) (should raise TypeError).\"\"\"\n        solution.BLOG_FORMAT = '<h1>{heading}</h1><p>{content}</p>'\n        with self.assertRaises(TypeError):\n            display_blog_entry(123, 'content')\n\n    def test_content_list(self):\n        \"\"\"Test content as list (non-string) (should raise TypeError).\"\"\"\n        solution.BLOG_FORMAT = '<h1>{heading}</h1><p>{content}</p>'\n        with self.assertRaises(TypeError):\n            display_blog_entry('title', [1, 2, 3])\n", "num_test_cases": 10, "task_id": "7c670800"}
{"test": "import unittest\nimport html\nimport solution\n\nsolution.USER_POST_FORMAT = \"USER: {username_key} TITLE: {title_key} BODY: {body_key} TAGS: {tags_html}\"\nfrom solution import render_user_content\n\nclass TestCases(unittest.TestCase):\n    def test_happy_path_normal_input(self):\n        # Test typical inputs without special characters\n        result = render_user_content(\"user1\", \"Hello World\", \"This is a test post.\", [\"tag1\", \"tag2\"])\n        expected = \"USER: user1 TITLE: Hello World BODY: This is a test post. TAGS: <span>tag1</span> <span>tag2</span>\"\n        self.assertEqual(result, expected)\n\n    def test_inputs_with_special_characters(self):\n        # Test inputs requiring HTML escaping\n        username = '<script>alert(\\\"xss\\\")</script>'\n        title = '\\\"><img src=x onerror=alert(1)>'\n        body = '&<>'\n        tags = ['<a>', '</a>', 'javascript:alert(1)']\n        result = render_user_content(username, title, body, tags)\n        \n        # Compute expected values using html.escape\n        safe_username = html.escape(username)\n        safe_title = html.escape(title)\n        safe_body = html.escape(body)\n        safe_tags = [html.escape(tag) for tag in tags]\n        tags_html = \" \".join(f\"<span>{tag}</span>\" for tag in safe_tags)\n        expected = f\"USER: {safe_username} TITLE: {safe_title} BODY: {safe_body} TAGS: {tags_html}\"\n        \n        self.assertEqual(result, expected)\n\n    def test_empty_inputs(self):\n        # Test empty strings and empty tag list\n        result = render_user_content(\"\", \"\", \"\", [])\n        expected = \"USER:  TITLE:  BODY:  TAGS: \"\n        self.assertEqual(result, expected)\n\n    def test_non_string_username(self):\n        # Test non-string username_key\n        with self.assertRaises(TypeError):\n            render_user_content(123, \"title\", \"body\", [])\n\n    def test_non_string_title(self):\n        # Test non-string title_key\n        with self.assertRaises(TypeError):\n            render_user_content(\"user\", 123, \"body\", [])\n\n    def test_non_string_body(self):\n        # Test non-string body_key\n        with self.assertRaises(TypeError):\n            render_user_content(\"user\", \"title\", 123, [])\n\n    def test_non_list_tags(self):\n        # Test non-list tag_elements\n        with self.assertRaises(TypeError):\n            render_user_content(\"user\", \"title\", \"body\", \"not_a_list\")\n\n    def test_non_string_in_tags(self):\n        # Test list containing non-string in tag_elements\n        with self.assertRaises(TypeError):\n            render_user_content(\"user\", \"title\", \"body\", [\"tag1\", 123])\n\n    def test_long_inputs(self):\n        # Test long strings and many tags\n        long_str = 'a' * 10000\n        tags = ['tag' + str(i) for i in range(100)]\n        result = render_user_content(long_str, long_str, long_str, tags)\n        \n        # Compute expected values\n        safe_long_str = html.escape(long_str)\n        safe_tags = [html.escape(tag) for tag in tags]\n        tags_html = \" \".join(f\"<span>{tag}</span>\" for tag in safe_tags)\n        expected = f\"USER: {safe_long_str} TITLE: {safe_long_str} BODY: {safe_long_str} TAGS: {tags_html}\"\n        \n        self.assertEqual(result, expected)\n\n    def test_tags_with_spaces(self):\n        # Test tags containing spaces\n        result = render_user_content(\"user\", \"title\", \"body\", [\"hello world\", \"foo bar\"])\n        expected = \"USER: user TITLE: title BODY: body TAGS: <span>hello world</span> <span>foo bar</span>\"\n        self.assertEqual(result, expected)", "num_test_cases": 10, "task_id": "8f71427d"}
{"test": "import unittest\nimport html\n\n# Define the global template variable that the function expects\nUSER_POST_FORMAT = '''\n<div class=\"post\">\n    <h1>{post_heading}</h1>\n    <div class=\"author\">By: {author_id}</div>\n    <div class=\"content\">{content}</div>\n    <div class=\"tags\">{label_html}</div>\n</div>\n'''\n\nclass TestBlogPostRendering(unittest.TestCase):\n    \n    def test_normal_input(self):\n        # Test typical inputs with no special characters\n        author_id = \"user123\"\n        post_heading = \"My First Post\"\n        content = \"This is a simple blog post.\"\n        labels = [\"personal\", \"blog\"]\n        result = render_blog_post(author_id, post_heading, content, labels)\n        self.assertIsInstance(result, str)\n        self.assertIn(post_heading, result)\n        self.assertIn(author_id, result)\n        self.assertIn(content, result)\n        for label in labels:\n            self.assertIn(f\"<span>{label}</span>\", result)\n    \n    def test_html_input_escaping(self):\n        # Test inputs containing HTML and special characters to ensure escaping\n        author_id = \"<script>alert('xss')</script>\"\n        post_heading = \"<h1>Hacked</h1>\"\n        content = \"<script>alert('xss')</script>\"\n        labels = [\"<tag>\", \"</tag>\"]\n        result = render_blog_post(author_id, post_heading, content, labels)\n        escaped_author_id = html.escape(author_id)\n        escaped_post_heading = html.escape(post_heading)\n        escaped_content = html.escape(content)\n        self.assertIn(escaped_author_id, result)\n        self.assertIn(escaped_post_heading, result)\n        self.assertIn(escaped_content, result)\n        for label in labels:\n            escaped_label = html.escape(label)\n            self.assertIn(f\"<span>{escaped_label}</span>\", result)\n        self.assertNotIn(author_id, result)  # Original unescaped content should not appear\n        self.assertNotIn(post_heading, result)\n        self.assertNotIn(content, result)\n        \n    def test_empty_inputs(self):\n        # Test empty strings and empty list\n        result = render_blog_post(\"\", \"\", \"\", [])\n        self.assertIsInstance(result, str)\n        self.assertIn(\"<h1></h1>\", result)\n        self.assertIn(\"By: \", result)  # Author div will contain empty author_id\n        self.assertIn(\"<div class=\\\"content\\\"></div>\", result)\n        self.assertIn(\"<div class=\\\"tags\\\"></div>\", result)\n        \n    def test_labels_with_special_chars(self):\n        # Test labels with spaces, quotes, and special characters\n        labels = ['tag with spaces', 'tag&special', '\"quote\"', \"'single'\", \"tag<with>\"]\n        result = render_blog_post(\"user\", \"title\", \"content\", labels)\n        for label in labels:\n            escaped_label = html.escape(label)\n            self.assertIn(f\"<span>{escaped_label}</span>\", result)\n    \n    def test_non_string_label(self):\n        # Test non-string in labels list\n        with self.assertRaises(TypeError):\n            render_blog_post(\"user\", \"title\", \"content\", [\"valid\", 123])\n            \n    def test_non_string_author_id(self):\n        # Test non-string author_id\n        with self.assertRaises(TypeError):\n            render_blog_post(123, \"title\", \"content\", [])\n            \n    def test_non_string_post_heading(self):\n        # Test non-string post_heading\n        with self.assertRaises(TypeError):\n            render_blog_post(\"user\", 123, \"content\", [])\n            \n    def test_non_string_content(self):\n        # Test non-string content\n        with self.assertRaises(TypeError):\n            render_blog_post(\"user\", \"title\", 123, [])\n            \n    def test_long_inputs(self):\n        # Test very long inputs for robustness\n        long_string = \"A\" * 10000\n        labels = [long_string] * 100\n        result = render_blog_post(long_string, long_string, long_string, labels)\n        self.assertIsInstance(result, str)\n        self.assertIn(long_string, result)\n        for label in labels:\n            self.assertIn(f\"<span>{long_string}</span>\", result)", "num_test_cases": 9, "task_id": "11e3c8fc"}
{"test": "import unittest\nimport html\n\nUSER_POST_FORMAT = '<div class=\"post\"><h1>{title}</h1><p>By: {author_name}</p><div class=\"content\">{body_content}</div><div class=\"tags\">{tags_html}</div></div>'\n\nclass TestForumPostRendering(unittest.TestCase):\n\n    def test_normal_case(self):\n        # Test typical inputs with standard strings\n        author = 'John Doe'\n        title = 'First Post'\n        body = 'This is a test post.'\n        tags = ['test', 'sample']\n        result = render_forum_post(author, title, body, tags)\n        expected_author = 'John Doe'\n        expected_title = 'First Post'\n        expected_body = 'This is a test post.'\n        expected_tags_html = '<span>test</span> <span>sample</span>'\n        expected_output = USER_POST_FORMAT.format(\n            author_name=expected_author,\n            title=expected_title,\n            body_content=expected_body,\n            tags_html=expected_tags_html\n        )\n        self.assertEqual(result, expected_output)\n\n    def test_escaping_special_chars(self):\n        # Test inputs requiring HTML escaping\n        author = 'John <script>Doe</script>'\n        title = 'Alert & Warning!'\n        body = '<b>Bold text</b> & entities'\n        tags = ['<tag>', '\"quoted\"']\n        result = render_forum_post(author, title, body, tags)\n        safe_author = html.escape(author)\n        safe_title = html.escape(title)\n        safe_body = html.escape(body)\n        safe_tags = [html.escape(tag) for tag in tags]\n        expected_tags_html = ' '.join(f'<span>{tag}</span>' for tag in safe_tags)\n        expected_output = USER_POST_FORMAT.format(\n            author_name=safe_author,\n            title=safe_title,\n            body_content=safe_body,\n            tags_html=expected_tags_html\n        )\n        self.assertEqual(result, expected_output)\n\n    def test_empty_strings(self):\n        # Test empty inputs\n        author = ''\n        title = ''\n        body = ''\n        tags = []\n        result = render_forum_post(author, title, body, tags)\n        expected_output = USER_POST_FORMAT.format(\n            author_name='',\n            title='',\n            body_content='',\n            tags_html=''\n        )\n        self.assertEqual(result, expected_output)\n\n    def test_empty_tag_list(self):\n        # Test empty tag list\n        author = 'Alice'\n        title = 'Hello'\n        body = 'Content'\n        tags = []\n        result = render_forum_post(author, title, body, tags)\n        expected_output = USER_POST_FORMAT.format(\n            author_name=author,\n            title=title,\n            body_content=body,\n            tags_html=''\n        )\n        self.assertEqual(result, expected_output)\n\n    def test_non_string_author(self):\n        # Test non-string author (integer)\n        with self.assertRaises(TypeError):\n            render_forum_post(123, 'title', 'body', [])\n\n    def test_non_string_title(self):\n        # Test non-string title (integer)\n        with self.assertRaises(TypeError):\n            render_forum_post('author', 123, 'body', [])\n\n    def test_non_string_body(self):\n        # Test non-string body (integer)\n        with self.assertRaises(TypeError):\n            render_forum_post('author', 'title', 123, [])\n\n    def test_non_string_in_tags(self):\n        # Test non-string element in tag_list\n        with self.assertRaises(TypeError):\n            render_forum_post('author', 'title', 'body', ['valid', 456])\n\n    def test_long_inputs(self):\n        # Test very long inputs\n        long_str = 'A' * 10000\n        tags = ['tag1', 'tag2' * 50]\n        result = render_forum_post(long_str, long_str, long_str, tags)\n        safe_long = html.escape(long_str)\n        safe_tags = [html.escape(tag) for tag in tags]\n        expected_tags_html = ' '.join(f'<span>{tag}</span>' for tag in safe_tags)\n        expected_output = USER_POST_FORMAT.format(\n            author_name=safe_long,\n            title=safe_long,\n            body_content=safe_long,\n            tags_html=expected_tags_html\n        )\n        self.assertEqual(result, expected_output)\n\n    def test_whitespace_handling(self):\n        # Test inputs with various whitespace characters\n        author = '  John  Doe  '\n        title = '\\nNew Post\\t'\n        body = 'Line1\\nLine2\\r\\nLine3'\n        tags = ['  tag  ', '\\t\\n']\n        result = render_forum_post(author, title, body, tags)\n        safe_author = html.escape(author)\n        safe_title = html.escape(title)\n        safe_body = html.escape(body)\n        safe_tags = [html.escape(tag) for tag in tags]\n        expected_tags_html = ' '.join(f'<span>{tag}</span>' for tag in safe_tags)\n        expected_output = USER_POST_FORMAT.format(\n            author_name=safe_author,\n            title=safe_title,\n            body_content=safe_body,\n            tags_html=expected_tags_html\n        )\n        self.assertEqual(result, expected_output)\n\n    def test_none_input(self):\n        # Test None inputs\n        with self.assertRaises(TypeError):\n            render_forum_post(None, 'title', 'body', [])\n        with self.assertRaises(TypeError):\n            render_forum_post('author', None, 'body', [])\n        with self.assertRaises(TypeError):\n            render_forum_post('author', 'title', None, [])\n        with self.assertRaises(TypeError):\n            render_forum_post('author', 'title', 'body', [None])\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 11, "task_id": "4d7b9632"}
{"test": "import unittest\nimport html\n\n# Define the global USER_POST_FORMAT as specified in the context\nUSER_POST_FORMAT = \"<div class='post'><h1>{headline}</h1><div class='author'>{poster_name}</div><p>{text}</p><div class='tags'>{tags_html}</div></div>\"\n\ndef compose_post_html(poster_name: str, headline: str, text: str, hashtags: list):\n    safe_poster_name = html.escape(poster_name)\n    safe_headline = html.escape(headline)\n    safe_text = html.escape(text)\n    safe_hashtags = [html.escape(tag) for tag in hashtags]\n    tag_html = \" \".join([f\"<span>{tag}</span>\" for tag in safe_hashtags])\n    return USER_POST_FORMAT.format(poster_name=safe_poster_name, headline=safe_headline, text=safe_text, tags_html=tag_html)\n\nclass TestComposePostHTML(unittest.TestCase):\n    def test_normal_input(self):\n        # Test typical inputs with standard values\n        result = compose_post_html(\"Alice\", \"Hello World\", \"Welcome to my blog post.\", [\"tech\", \"python\"])\n        expected = USER_POST_FORMAT.format(\n            poster_name=\"Alice\",\n            headline=\"Hello World\",\n            text=\"Welcome to my blog post.\",\n            tags_html=\"<span>tech</span> <span>python</span>\"\n        )\n        self.assertEqual(result, expected)\n\n    def test_special_characters(self):\n        # Test inputs with characters that require HTML escaping\n        result = compose_post_html(\"John O'Conner\", \"Coffee & Tea\", \"5 > 3 and 3 < 5\", [\"c#\", \"c++\"])\n        expected = USER_POST_FORMAT.format(\n            poster_name=html.escape(\"John O'Conner\"),\n            headline=html.escape(\"Coffee & Tea\"),\n            text=html.escape(\"5 > 3 and 3 < 5\"),\n            tags_html=\"<span>\" + html.escape(\"c#\") + \"</span> <span>\" + html.escape(\"c++\") + \"</span>\"\n        )\n        self.assertEqual(result, expected)\n\n    def test_xss_attempt(self):\n        # Test inputs containing potential XSS attacks\n        xss_name = \"<script>alert('xss')</script>\"\n        xss_headline = '\" onload=\"alert(1)\"'\n        xss_text = \"<img src=x onerror=alert('xss')>\"\n        xss_tags = [\"<script>alert('xss')</script>\", \"</div><div>malicious</div>\"]\n        \n        result = compose_post_html(xss_name, xss_headline, xss_text, xss_tags)\n        \n        # Construct expected with proper escaping\n        expected = USER_POST_FORMAT.format(\n            poster_name=html.escape(xss_name),\n            headline=html.escape(xss_headline),\n            text=html.escape(xss_text),\n            tags_html=\" \".join([f\"<span>{html.escape(tag)}</span>\" for tag in xss_tags])\n        )\n        self.assertEqual(result, expected)\n\n    def test_empty_inputs(self):\n        # Test with empty strings and empty list\n        result = compose_post_html(\"\", \"\", \"\", [])\n        expected = USER_POST_FORMAT.format(\n            poster_name=\"\",\n            headline=\"\",\n            text=\"\",\n            tags_html=\"\"\n        )\n        self.assertEqual(result, expected)\n\n    def test_long_inputs(self):\n        # Test with very long inputs to ensure no truncation or errors\n        long_str = \"A\" * 1000\n        long_tags = [\"tag\" + str(i) for i in range(50)]  # 50 tags\n        \n        result = compose_post_html(long_str, long_str, long_str, long_tags)\n        \n        # Construct expected\n        escaped_long = html.escape(long_str)\n        escaped_tags = [html.escape(tag) for tag in long_tags]\n        tags_html = \" \".join([f\"<span>{tag}</span>\" for tag in escaped_tags])\n        expected = USER_POST_FORMAT.format(\n            poster_name=escaped_long,\n            headline=escaped_long,\n            text=escaped_long,\n            tags_html=tags_html\n        )\n        self.assertEqual(result, expected)\n\n    def test_poster_name_type_error(self):\n        # Test non-string poster_name\n        with self.assertRaises(TypeError):\n            compose_post_html(123, \"headline\", \"text\", [\"tag\"])\n\n    def test_headline_type_error(self):\n        # Test non-string headline\n        with self.assertRaises(TypeError):\n            compose_post_html(\"Alice\", 456, \"text\", [\"tag\"])\n\n    def test_text_type_error(self):\n        # Test non-string text\n        with self.assertRaises(TypeError):\n            compose_post_html(\"Alice\", \"headline\", None, [\"tag\"])\n\n    def test_hashtags_non_list(self):\n        # Test non-list hashtags (string as iterable)\n        result = compose_post_html(\"Alice\", \"Headline\", \"Text\", \"hello\")\n        # Expected: treat string as iterable of characters\n        expected_tags = [html.escape(c) for c in \"hello\"]\n        tags_html = \" \".join([f\"<span>{tag}</span>\" for tag in expected_tags])\n        expected = USER_POST_FORMAT.format(\n            poster_name=\"Alice\",\n            headline=\"Headline\",\n            text=\"Text\",\n            tags_html=tags_html\n        )\n        self.assertEqual(result, expected)\n\nif __name__ == \"__main__\":\n    unittest.main()", "num_test_cases": 9, "task_id": "19509e25"}
{"test": "import unittest\nfrom unittest.mock import patch\nimport html\n\nclass TestBuildPostHtml(unittest.TestCase):\n    def test_normal_input(self):\n        # Test with typical input\n        with patch('solution.FORUM_POST_FORMAT', '<div><h1>{header}</h1><p>{message}</p>{options}</div>'):\n            topic_title = \"Hello\"\n            body_text = \"This is a body.\"\n            list_items = [\"Option 1\", \"Option 2\"]\n            result = build_post_html(topic_title, body_text, list_items)\n            list_str = ''.join([f'<li>{html.escape(item)}</li>' for item in list_items])\n            expected = f'<div><h1>{html.escape(topic_title)}</h1><p>{html.escape(body_text)}</p><ul>{list_str}</ul></div>'\n            self.assertEqual(result, expected)\n\n    def test_empty_inputs(self):\n        # Test with empty strings and empty list\n        with patch('solution.FORUM_POST_FORMAT', '<div><h1>{header}</h1><p>{message}</p>{options}</div>'):\n            topic_title = \"\"\n            body_text = \"\"\n            list_items = []\n            result = build_post_html(topic_title, body_text, list_items)\n            list_str = ''.join([f'<li>{html.escape(item)}</li>' for item in list_items])\n            expected = f'<div><h1>{html.escape(topic_title)}</h1><p>{html.escape(body_text)}</p><ul>{list_str}</ul></div>'\n            self.assertEqual(result, expected)\n\n    def test_special_characters(self):\n        # Test with strings containing special characters that need escaping\n        with patch('solution.FORUM_POST_FORMAT', '<div><h1>{header}</h1><p>{message}</p>{options}</div>'):\n            topic_title = \"<script>alert('xss')</script>\"\n            body_text = \"Hello <img src='x' onerror='alert(1)'>\"\n            list_items = [\"<script>alert('xss')</script>\", \"Safe text\"]\n            result = build_post_html(topic_title, body_text, list_items)\n            list_str = ''.join([f'<li>{html.escape(item)}</li>' for item in list_items])\n            expected = f'<div><h1>{html.escape(topic_title)}</h1><p>{html.escape(body_text)}</p><ul>{list_str}</ul></div>'\n            self.assertEqual(result, expected)\n\n    def test_list_with_empty_string(self):\n        # Test with a list containing an empty string\n        with patch('solution.FORUM_POST_FORMAT', '<div><h1>{header}</h1><p>{message}</p>{options}</div>'):\n            topic_title = \"Title\"\n            body_text = \"Body\"\n            list_items = [\"\"]\n            result = build_post_html(topic_title, body_text, list_items)\n            list_str = ''.join([f'<li>{html.escape(item)}</li>' for item in list_items])\n            expected = f'<div><h1>{html.escape(topic_title)}</h1><p>{html.escape(body_text)}</p><ul>{list_str}</ul></div>'\n            self.assertEqual(result, expected)\n\n    def test_non_ascii(self):\n        # Test with non-ASCII characters\n        with patch('solution.FORUM_POST_FORMAT', '<div><h1>{header}</h1><p>{message}</p>{options}</div>'):\n            topic_title = \"日本語\"\n            body_text = \"中文\"\n            list_items = [\"한국어\", \"العربية\"]\n            result = build_post_html(topic_title, body_text, list_items)\n            list_str = ''.join([f'<li>{html.escape(item)}</li>' for item in list_items])\n            expected = f'<div><h1>{html.escape(topic_title)}</h1><p>{html.escape(body_text)}</p><ul>{list_str}</ul></div>'\n            self.assertEqual(result, expected)\n\n    def test_whitespace(self):\n        # Test with whitespace in the inputs\n        with patch('solution.FORUM_POST_FORMAT', '<div><h1>{header}</h1><p>{message}</p>{options}</div>'):\n            topic_title = \"  Hello  \\n World  \"\n            body_text = \"Line1\\nLine2\"\n            list_items = [\"Item1\", \"Item2\"]\n            result = build_post_html(topic_title, body_text, list_items)\n            list_str = ''.join([f'<li>{html.escape(item)}</li>' for item in list_items])\n            expected = f'<div><h1>{html.escape(topic_title)}</h1><p>{html.escape(body_text)}</p><ul>{list_str}</ul></div>'\n            self.assertEqual(result, expected)\n\n    def test_non_string_title(self):\n        # Test with non-string title (integer)\n        with patch('solution.FORUM_POST_FORMAT', '<div><h1>{header}</h1><p>{message}</p>{options}</div>'):\n            with self.assertRaises(TypeError):\n                build_post_html(123, \"body\", [])\n\n    def test_non_string_in_list(self):\n        # Test with non-string in the list (integer)\n        with patch('solution.FORUM_POST_FORMAT', '<div><h1>{header}</h1><p>{message}</p>{options}</div>'):\n            with self.assertRaises(TypeError):\n                build_post_html(\"title\", \"body\", [123])\n\n    def test_none_in_list(self):\n        # Test with None in the list\n        with patch('solution.FORUM_POST_FORMAT', '<div><h1>{header}</h1><p>{message}</p>{options}</div>'):\n            with self.assertRaises(TypeError):\n                build_post_html(\"title\", \"body\", [None])\n\n    def test_none_title(self):\n        # Test with None for title\n        with patch('solution.FORUM_POST_FORMAT', '<div><h1>{header}</h1><p>{message}</p>{options}</div>'):\n            with self.assertRaises(TypeError):\n                build_post_html(None, \"body\", [])\n\n    def test_none_body(self):\n        # Test with None for body\n        with patch('solution.FORUM_POST_FORMAT', '<div><h1>{header}</h1><p>{message}</p>{options}</div>'):\n            with self.assertRaises(TypeError):\n                build_post_html(\"title\", None, [])\n\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 11, "task_id": "3e2a0c9c"}
{"test": "import unittest\nimport solution\nimport html\n\n# Define the template as expected by the function\nsolution.FORUM_POST_FORMAT = '<div><h1>{header}</h1><p>{message}</p>{options}</div>'\n\nclass TestForumEntry(unittest.TestCase):\n    \n    def test_normal_inputs(self):\n        \"\"\"Test typical inputs with standard values.\"\"\"\n        post_title = 'My Title'\n        post_body = 'This is the body.'\n        bullet_points = ['Option 1', 'Option 2']\n        result = solution.build_forum_entry(post_title, post_body, bullet_points)\n        safe_title = html.escape(post_title)\n        safe_body = html.escape(post_body)\n        safe_points = [html.escape(point) for point in bullet_points]\n        formatted_safe_points = '<ul>' + ''.join([f'<li>{safe_point}</li>' for safe_point in safe_points]) + '</ul>'\n        expected = solution.FORUM_POST_FORMAT.format(header=safe_title, message=safe_body, options=formatted_safe_points)\n        self.assertEqual(result, expected)\n        \n    def test_empty_inputs(self):\n        \"\"\"Test empty title, body, and empty list of bullet points.\"\"\"\n        post_title = ''\n        post_body = ''\n        bullet_points = []\n        result = solution.build_forum_entry(post_title, post_body, bullet_points)\n        safe_title = html.escape(post_title)\n        safe_body = html.escape(post_body)\n        safe_points = [html.escape(point) for point in bullet_points]\n        formatted_safe_points = '<ul>' + ''.join([f'<li>{safe_point}</li>' for safe_point in safe_points]) + '</ul>'\n        expected = solution.FORUM_POST_FORMAT.format(header=safe_title, message=safe_body, options=formatted_safe_points)\n        self.assertEqual(result, expected)\n    \n    def test_special_characters(self):\n        \"\"\"Test inputs containing HTML and special characters that require escaping.\"\"\"\n        post_title = '<title>'\n        post_body = 'This has <b>bold</b> and & stuff.'\n        bullet_points = ['<li>item</li>', 'Another & point']\n        result = solution.build_forum_entry(post_title, post_body, bullet_points)\n        safe_title = html.escape(post_title)\n        safe_body = html.escape(post_body)\n        safe_points = [html.escape(point) for point in bullet_points]\n        formatted_safe_points = '<ul>' + ''.join([f'<li>{safe_point}</li>' for safe_point in safe_points]) + '</ul>'\n        expected = solution.FORUM_POST_FORMAT.format(header=safe_title, message=safe_body, options=formatted_safe_points)\n        self.assertEqual(result, expected)\n    \n    def test_title_none(self):\n        \"\"\"Test None for post_title which should raise TypeError.\"\"\"\n        with self.assertRaises(TypeError):\n            solution.build_forum_entry(None, 'body', ['point'])\n    \n    def test_body_none(self):\n        \"\"\"Test None for post_body which should raise TypeError.\"\"\"\n        with self.assertRaises(TypeError):\n            solution.build_forum_entry('title', None, ['point'])\n    \n    def test_bullet_points_none(self):\n        \"\"\"Test None for bullet_points which should raise TypeError.\"\"\"\n        with self.assertRaises(TypeError):\n            solution.build_forum_entry('title', 'body', None)\n    \n    def test_bullet_points_non_string(self):\n        \"\"\"Test bullet_points containing non-string elements which should raise TypeError.\"\"\"\n        with self.assertRaises(TypeError):\n            solution.build_forum_entry('title', 'body', [1, 2, 3])\n    \n    def test_long_inputs(self):\n        \"\"\"Test very long inputs to ensure handling of large data.\"\"\"\n        long_string = 'A' * 10000\n        bullet_points = [long_string] * 100\n        result = solution.build_forum_entry(long_string, long_string, bullet_points)\n        safe_title = html.escape(long_string)\n        safe_body = html.escape(long_string)\n        safe_points = [html.escape(point) for point in bullet_points]\n        formatted_safe_points = '<ul>' + ''.join([f'<li>{safe_point}</li>' for safe_point in safe_points]) + '</ul>'\n        expected = solution.FORUM_POST_FORMAT.format(header=safe_title, message=safe_body, options=formatted_safe_points)\n        self.assertEqual(result, expected)", "num_test_cases": 8, "task_id": "afbc3200"}
{"test": "import unittest\nimport html\n\n# Define the FORUM_POST_FORMAT constant as required by the function\nFORUM_POST_FORMAT = '''<div class=\"forum-post\">\n    <h1>{header}</h1>\n    <p>{message}</p>\n    <div class=\"options\">\n        {options}\n    </div>\n</div>'''\n\nclass TestForumPost(unittest.TestCase):\n    def test_typical_input(self):\n        # Test with typical inputs: non-empty topic, text_body, and points\n        topic = \"Python Unit Testing\"\n        text_body = \"This post discusses unit testing in Python.\"\n        points = [\"Test organization\", \"Assertion methods\", \"Mocking\"]\n        \n        # Generate expected output\n        expected_header = html.escape(topic)\n        expected_message = html.escape(text_body)\n        safe_points = [html.escape(p) for p in points]\n        expected_options = \"<ul>\" + \"\".join(f\"<li>{p}</li>\" for p in safe_points) + \"</ul>\"\n        expected_output = FORUM_POST_FORMAT.format(header=expected_header, message=expected_message, options=expected_options)\n        \n        # Call function and assert\n        result = create_forum_post(topic, text_body, points)\n        self.assertEqual(result, expected_output)\n\n    def test_empty_topic(self):\n        # Test with empty topic string\n        topic = \"\"\n        text_body = \"Content should still appear.\"\n        points = [\"Point 1\", \"Point 2\"]\n        \n        # Generate expected output\n        expected_header = html.escape(topic)\n        expected_message = html.escape(text_body)\n        safe_points = [html.escape(p) for p in points]\n        expected_options = \"<ul>\" + \"\".join(f\"<li>{p}</li>\" for p in safe_points) + \"</ul>\"\n        expected_output = FORUM_POST_FORMAT.format(header=expected_header, message=expected_message, options=expected_options)\n        \n        result = create_forum_post(topic, text_body, points)\n        self.assertEqual(result, expected_output)\n\n    def test_empty_text_body(self):\n        # Test with empty text_body string\n        topic = \"Title Here\"\n        text_body = \"\"\n        points = [\"First point\", \"Second point\"]\n        \n        # Generate expected output\n        expected_header = html.escape(topic)\n        expected_message = html.escape(text_body)\n        safe_points = [html.escape(p) for p in points]\n        expected_options = \"<ul>\" + \"\".join(f\"<li>{p}</li>\" for p in safe_points) + \"</ul>\"\n        expected_output = FORUM_POST_FORMAT.format(header=expected_header, message=expected_message, options=expected_options)\n        \n        result = create_forum_post(topic, text_body, points)\n        self.assertEqual(result, expected_output)\n\n    def test_empty_points_list(self):\n        # Test with empty points list\n        topic = \"No Points\"\n        text_body = \"This post has no discussion points.\"\n        points = []\n        \n        # Generate expected output\n        expected_header = html.escape(topic)\n        expected_message = html.escape(text_body)\n        expected_options = \"<ul></ul>\"\n        expected_output = FORUM_POST_FORMAT.format(header=expected_header, message=expected_message, options=expected_options)\n        \n        result = create_forum_post(topic, text_body, points)\n        self.assertEqual(result, expected_output)\n\n    def test_special_characters_in_topic(self):\n        # Test XSS protection in topic with special HTML characters\n        topic = \"<script>alert('xss');</script>\"\n        text_body = \"Safe content\"\n        points = [\"Safe point\"]\n        \n        # Generate expected output\n        expected_header = html.escape(topic)\n        expected_message = html.escape(text_body)\n        safe_points = [html.escape(p) for p in points]\n        expected_options = \"<ul>\" + \"\".join(f\"<li>{p}</li>\" for p in safe_points) + \"</ul>\"\n        expected_output = FORUM_POST_FORMAT.format(header=expected_header, message=expected_message, options=expected_options)\n        \n        result = create_forum_post(topic, text_body, points)\n        self.assertEqual(result, expected_output)\n        self.assertNotIn('<script>', result)\n        self.assertIn('&lt;script&gt;', result)\n\n    def test_special_characters_in_text_body(self):\n        # Test XSS protection in text_body with special HTML characters\n        topic = \"Safe title\"\n        text_body = \"<div>Hello & Goodbye</div>\"\n        points = [\"Safe point\"]\n        \n        # Generate expected output\n        expected_header = html.escape(topic)\n        expected_message = html.escape(text_body)\n        safe_points = [html.escape(p) for p in points]\n        expected_options = \"<ul>\" + \"\".join(f\"<li>{p}</li>\" for p in safe_points) + \"</ul>\"\n        expected_output = FORUM_POST_FORMAT.format(header=expected_header, message=expected_message, options=expected_options)\n        \n        result = create_forum_post(topic, text_body, points)\n        self.assertEqual(result, expected_output)\n        self.assertNotIn('<div>', result)\n        self.assertIn('&lt;div&gt;', result)\n        self.assertIn('&amp;', result)\n\n    def test_special_characters_in_points(self):\n        # Test XSS protection in points with special HTML characters\n        topic = \"Title\"\n        text_body = \"Content\"\n        points = [\"<b>Bold</b>\", \"'Quotes'\", \"A&B\"]\n        \n        # Generate expected output\n        expected_header = html.escape(topic)\n        expected_message = html.escape(text_body)\n        safe_points = [html.escape(p) for p in points]\n        expected_options = \"<ul>\" + \"\".join(f\"<li>{p}</li>\" for p in safe_points) + \"</ul>\"\n        expected_output = FORUM_POST_FORMAT.format(header=expected_header, message=expected_message, options=expected_options)\n        \n        result = create_forum_post(topic, text_body, points)\n        self.assertEqual(result, expected_output)\n        for unsafe in ['<b>', \"'\", '&']:\n            self.assertNotIn(unsafe, result)\n\n    def test_empty_string_in_points(self):\n        # Test handling of empty strings within points list\n        topic = \"Empty Point\"\n        text_body = \"One point is empty.\"\n        points = [\"Normal\", \"\"]\n        \n        # Generate expected output\n        expected_header = html.escape(topic)\n        expected_message = html.escape(text_body)\n        safe_points = [html.escape(p) for p in points]\n        expected_options = \"<ul>\" + \"\".join(f\"<li>{p}</li>\" for p in safe_points) + \"</ul>\"\n        expected_output = FORUM_POST_FORMAT.format(header=expected_header, message=expected_message, options=expected_options)\n        \n        result = create_forum_post(topic, text_body, points)\n        self.assertEqual(result, expected_output)\n        self.assertIn('<li></li>', result)\n\n    def test_non_string_in_points(self):\n        # Test non-string element in points list (should raise TypeError)\n        topic = \"Invalid Input\"\n        text_body = \"Testing error handling.\"\n        points = [\"Valid\", 123]  # Contains integer\n        \n        with self.assertRaises(TypeError):\n            create_forum_post(topic, text_body, points)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 9, "task_id": "bcb4b76c"}
{"test": "import unittest\nfrom solution import compile_post\nimport solution\n\nclass TestCompilePost(unittest.TestCase):\n    @classmethod\n    def setUpClass(cls):\n        solution.FORUM_POST_FORMAT = '<h1>{subject}</h1><p>{text}</p>{highlights}'\n\n    def test_basic_input(self):\n        # Test typical inputs with all components\n        subject = 'My Subject'\n        text = 'This is the main content.'\n        highlights = ['Point 1', 'Point 2', 'Point 3']\n        result = compile_post(subject, text, highlights)\n        expected = '<h1>My Subject</h1><p>This is the main content.</p><ul><li>Point 1</li><li>Point 2</li><li>Point 3</li></ul>'\n        self.assertEqual(result, expected)\n\n    def test_empty_subject(self):\n        # Test with empty subject\n        subject = ''\n        text = 'Some text'\n        highlights = ['A']\n        result = compile_post(subject, text, highlights)\n        expected = '<h1></h1><p>Some text</p><ul><li>A</li></ul>'\n        self.assertEqual(result, expected)\n\n    def test_empty_text(self):\n        # Test with empty text\n        subject = 'Subject'\n        text = ''\n        highlights = ['A']\n        result = compile_post(subject, text, highlights)\n        expected = '<h1>Subject</h1><p></p><ul><li>A</li></ul>'\n        self.assertEqual(result, expected)\n\n    def test_empty_highlights(self):\n        # Test with empty highlights list\n        subject = 'Subject'\n        text = 'Text'\n        highlights = []\n        result = compile_post(subject, text, highlights)\n        expected = '<h1>Subject</h1><p>Text</p><ul></ul>'\n        self.assertEqual(result, expected)\n\n    def test_single_highlight(self):\n        # Test with one highlight\n        subject = 'Subject'\n        text = 'Text'\n        highlights = ['Only one']\n        result = compile_post(subject, text, highlights)\n        expected = '<h1>Subject</h1><p>Text</p><ul><li>Only one</li></ul>'\n        self.assertEqual(result, expected)\n\n    def test_multiple_highlights(self):\n        # Test with multiple highlights\n        subject = 'Subject'\n        text = 'Text'\n        highlights = ['First', 'Second', 'Third']\n        result = compile_post(subject, text, highlights)\n        expected = '<h1>Subject</h1><p>Text</p><ul><li>First</li><li>Second</li><li>Third</li></ul>'\n        self.assertEqual(result, expected)\n\n    def test_subject_with_special_chars(self):\n        # Test subject with special characters requiring escaping\n        subject = '<script>alert(\"xss\")</script>'\n        text = 'Text'\n        highlights = ['A']\n        result = compile_post(subject, text, highlights)\n        expected_subject = '&lt;script&gt;alert(&quot;xss&quot;)&lt;/script&gt;'\n        expected = '<h1>' + expected_subject + '</h1><p>Text</p><ul><li>A</li></ul>'\n        self.assertEqual(result, expected)\n\n    def test_text_with_special_chars(self):\n        # Test text with special characters requiring escaping\n        subject = 'Subject'\n        text = 'This is \"quoted\" and has <tags> & ampersand.'\n        highlights = ['A']\n        result = compile_post(subject, text, highlights)\n        expected_text = 'This is &quot;quoted&quot; and has &lt;tags&gt; &amp; ampersand.'\n        expected = '<h1>Subject</h1><p>' + expected_text + '</p><ul><li>A</li></ul>'\n        self.assertEqual(result, expected)\n\n    def test_highlights_with_special_chars(self):\n        # Test highlights with special characters requiring escaping\n        subject = 'Subject'\n        text = 'Text'\n        highlights = ['<b>Bold</b>', \"'Quote'\", '& Ampersand']\n        result = compile_post(subject, text, highlights)\n        expected_highlights = ['&lt;b&gt;Bold&lt;/b&gt;', '&#x27;Quote&#x27;', '&amp; Ampersand']\n        formatted_highlights = '<ul><li>' + '</li><li>'.join(expected_highlights) + '</li></ul>'\n        expected = '<h1>Subject</h1><p>Text</p>' + formatted_highlights\n        self.assertEqual(result, expected)\n\n    def test_subject_none(self):\n        # Test subject as None (invalid type)\n        with self.assertRaises(TypeError):\n            compile_post(None, 'text', ['highlight'])\n\n    def test_text_none(self):\n        # Test text as None (invalid type)\n        with self.assertRaises(TypeError):\n            compile_post('subject', None, ['highlight'])\n\n    def test_highlights_none(self):\n        # Test highlights as None (invalid type)\n        with self.assertRaises(TypeError):\n            compile_post('subject', 'text', None)\n\n    def test_highlights_contains_non_string(self):\n        # Test highlights containing non-string elements\n        with self.assertRaises(TypeError):\n            compile_post('subject', 'text', [1, 2, 3])\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 13, "task_id": "f9a73467"}
{"test": "import unittest\nfrom unittest.mock import patch\nimport html\n\n# Import the function to test (assuming it's in a module named 'solution')\nfrom solution import build_forum_post\n\nclass TestBuildForumPost(unittest.TestCase):\n    TEST_TEMPLATE = '<div><h1>{headline}</h1><p>{content}</p>{items}</div>'\n\n    def setUp(self):\n        # Patch FORUM_POST_FORMAT in the solution module with our test template\n        self.patcher = patch('solution.FORUM_POST_FORMAT', self.TEST_TEMPLATE)\n        self.patcher.start()\n\n    def tearDown(self):\n        self.patcher.stop()\n\n    def test_normal_input(self):\n        \"\"\"Test with typical valid inputs.\"\"\"\n        headline = \"Welcome\"\n        content = \"This is a test post.\"\n        items = [\"Point 1\", \"Point 2\", \"Point 3\"]\n        expected = self.TEST_TEMPLATE.format(\n            headline=html.escape(headline),\n            content=html.escape(content),\n            items=\"<ul><li>\" + \"</li><li>\".join(html.escape(item) for item in items) + \"</li></ul>\"\n        )\n        result = build_forum_post(headline, content, items)\n        self.assertEqual(result, expected)\n\n    def test_empty_inputs(self):\n        \"\"\"Test with empty headline, content, and items list.\"\"\"\n        headline = \"\"\n        content = \"\"\n        items = []\n        expected = self.TEST_TEMPLATE.format(\n            headline=\"\",\n            content=\"\",\n            items=\"<ul></ul>\"\n        )\n        result = build_forum_post(headline, content, items)\n        self.assertEqual(result, expected)\n\n    def test_single_item(self):\n        \"\"\"Test with a single item in the discussion points.\"\"\"\n        headline = \"Single Point\"\n        content = \"Only one discussion point.\"\n        items = [\"Solo item\"]\n        expected = self.TEST_TEMPLATE.format(\n            headline=html.escape(headline),\n            content=html.escape(content),\n            items=\"<ul><li>\" + html.escape(items[0]) + \"</li></ul>\"\n        )\n        result = build_forum_post(headline, content, items)\n        self.assertEqual(result, expected)\n\n    def test_escaping(self):\n        \"\"\"Test that HTML/JS in inputs is properly escaped.\"\"\"\n        headline = \"<script>alert('xss')</script>\"\n        content = \"<b>Bold text</b> & special chars ><\"\n        items = [\"<a href='attack'>Malicious</a>\", \"<script>alert(1)</script>\"]\n        expected = self.TEST_TEMPLATE.format(\n            headline=html.escape(headline),\n            content=html.escape(content),\n            items=\"<ul><li>\" + \"</li><li>\".join(html.escape(item) for item in items) + \"</li></ul>\"\n        )\n        result = build_forum_post(headline, content, items)\n        self.assertEqual(result, expected)\n\n    def test_headline_not_string(self):\n        \"\"\"Test non-string headline raises TypeError.\"\"\"\n        with self.assertRaises(TypeError):\n            build_forum_post(123, \"content\", [\"item\"])\n\n    def test_content_not_string(self):\n        \"\"\"Test non-string content raises TypeError.\"\"\"\n        with self.assertRaises(TypeError):\n            build_forum_post(\"headline\", 456, [\"item\"])\n\n    def test_items_not_list(self):\n        \"\"\"Test non-list items argument raises TypeError.\"\"\"\n        with self.assertRaises(TypeError):\n            build_forum_post(\"headline\", \"content\", \"not a list\")\n\n    def test_item_element_not_string(self):\n        \"\"\"Test non-string element in items list raises TypeError.\"\"\"\n        with self.assertRaises(TypeError):\n            build_forum_post(\"headline\", \"content\", [123])\n\n    def test_headline_none(self):\n        \"\"\"Test None headline raises TypeError.\"\"\"\n        with self.assertRaises(TypeError):\n            build_forum_post(None, \"content\", [\"item\"])\n\n    def test_content_none(self):\n        \"\"\"Test None content raises TypeError.\"\"\"\n        with self.assertRaises(TypeError):\n            build_forum_post(\"headline\", None, [\"item\"])\n\n    def test_item_element_none(self):\n        \"\"\"Test None in items list raises TypeError.\"\"\"\n        with self.assertRaises(TypeError):\n            build_forum_post(\"headline\", \"content\", [None])\n\n    def test_large_input(self):\n        \"\"\"Test with very large inputs to check performance and correctness.\"\"\"\n        headline = \"A\" * 10000\n        content = \"B\" * 10000\n        items = [\"C\" * 1000] * 100  # 100 items of 1000 characters\n        expected = self.TEST_TEMPLATE.format(\n            headline=html.escape(headline),\n            content=html.escape(content),\n            items=\"<ul><li>\" + \"</li><li>\".join(html.escape(item) for item in items) + \"</li></ul>\"\n        )\n        result = build_forum_post(headline, content, items)\n        self.assertEqual(result, expected)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 12, "task_id": "902dee2d"}
{"test": "import unittest\nfrom unittest.mock import patch\nimport html\nfrom solution import create_post_html\n\nUSER_POST_FORMAT_TEMPLATE = \"<div class=\\\"post\\\">\\n    <h1>{post_title}</h1>\\n    <p><b>Author:</b> {author_name}</p>\\n    <div class=\\\"content\\\">{content}</div>\\n    <div class=\\\"tags\\\">{tags_html}</div>\\n</div>\"\n\n@patch('solution.USER_POST_FORMAT', USER_POST_FORMAT_TEMPLATE)\nclass TestCreatePostHtml(unittest.TestCase):\n\n    def test_normal_input(self):\n        # Typical inputs with no special characters\n        author = \"John Doe\"\n        title = \"Hello World\"\n        content = \"This is a test post.\"\n        tags = [\"greeting\", \"test\"]\n        result = create_post_html(author, title, content, tags)\n        safe_author = html.escape(author)\n        safe_title = html.escape(title)\n        safe_content = html.escape(content)\n        safe_tags = [html.escape(tag) for tag in tags]\n        tags_html = \" \".join(f\"<span>{tag}</span>\" for tag in safe_tags)\n        expected = USER_POST_FORMAT_TEMPLATE.format(\n            post_title=safe_title,\n            author_name=safe_author,\n            content=safe_content,\n            tags_html=tags_html\n        )\n        self.assertEqual(result, expected)\n\n    def test_xss_escaping(self):\n        # Inputs with HTML special characters and scripts\n        author = '<script>alert(\"xss\")</script>'\n        title = '<b>Hello</b>'\n        content = '& is escaped?'\n        tags = ['<tag>', '\"tag2\"']\n        result = create_post_html(author, title, content, tags)\n        safe_author = html.escape(author)\n        safe_title = html.escape(title)\n        safe_content = html.escape(content)\n        safe_tags = [html.escape(tag) for tag in tags]\n        tags_html = \" \".join(f\"<span>{tag}</span>\" for tag in safe_tags)\n        expected = USER_POST_FORMAT_TEMPLATE.format(\n            post_title=safe_title,\n            author_name=safe_author,\n            content=safe_content,\n            tags_html=tags_html\n        )\n        self.assertEqual(result, expected)\n\n    def test_empty_inputs(self):\n        # Empty strings and empty tag list\n        author = \"\"\n        title = \"\"\n        content = \"\"\n        tags = []\n        result = create_post_html(author, title, content, tags)\n        safe_author = html.escape(author)\n        safe_title = html.escape(title)\n        safe_content = html.escape(content)\n        safe_tags = [html.escape(tag) for tag in tags]\n        tags_html = \" \".join(f\"<span>{tag}</span>\" for tag in safe_tags)\n        expected = USER_POST_FORMAT_TEMPLATE.format(\n            post_title=safe_title,\n            author_name=safe_author,\n            content=safe_content,\n            tags_html=tags_html\n        )\n        self.assertEqual(result, expected)\n\n    def test_long_inputs(self):\n        # Very long inputs to test handling and escaping\n        long_str = \"A\" * 10000\n        tags = [long_str, long_str]\n        result = create_post_html(long_str, long_str, long_str, tags)\n        safe_long = html.escape(long_str)\n        self.assertIn(safe_long, result)\n        self.assertEqual(result.count(safe_long), 5)  # author, title, content, two tags\n\n    def test_author_name_none(self):\n        # None for author_name should raise TypeError\n        with self.assertRaises(TypeError):\n            create_post_html(None, \"title\", \"content\", [\"tag\"])\n\n    def test_author_name_non_string(self):\n        # Non-string author_name should raise TypeError\n        with self.assertRaises(TypeError):\n            create_post_html(123, \"title\", \"content\", [\"tag\"])\n\n    def test_post_title_none(self):\n        # None for post_title should raise TypeError\n        with self.assertRaises(TypeError):\n            create_post_html(\"author\", None, \"content\", [\"tag\"])\n\n    def test_post_title_non_string(self):\n        # Non-string post_title should raise TypeError\n        with self.assertRaises(TypeError):\n            create_post_html(\"author\", 123, \"content\", [\"tag\"])\n\n    def test_content_none(self):\n        # None for content should raise TypeError\n        with self.assertRaises(TypeError):\n            create_post_html(\"author\", \"title\", None, [\"tag\"])\n\n    def test_content_non_string(self):\n        # Non-string content should raise TypeError\n        with self.assertRaises(TypeError):\n            create_post_html(\"author\", \"title\", 123, [\"tag\"])\n\n    def test_post_tags_none(self):\n        # None for post_tags should raise TypeError\n        with self.assertRaises(TypeError):\n            create_post_html(\"author\", \"title\", \"content\", None)\n\n    def test_post_tags_contains_non_string(self):\n        # Non-string element in post_tags should raise TypeError\n        with self.assertRaises(TypeError):\n            create_post_html(\"author\", \"title\", \"content\", [\"tag\", 123])\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 12, "task_id": "c9225fbf"}
{"test": "import unittest\nimport html\n\n# Define the global template variable as used in the function\nFORUM_POST_FORMAT = \"<div><h1>{title}</h1><p>{body}</p>{points}</div>\"\n\ndef create_forum_entry(title: str, body: str, points: list[str]):\n    import html\n    safe_title = html.escape(title)\n    safe_body = html.escape(body)\n    safe_points = [html.escape(point) for point in points]\n    formatted_safe_points = \"<ul>\" + \"\".join([f\"<li>{safe_point}</li>\" for safe_point in safe_points]) + \"</ul>\"\n    return FORUM_POST_FORMAT.format(title=safe_title, body=safe_body, points=formatted_safe_points)\n\nclass TestCreateForumEntry(unittest.TestCase):\n    def test_basic_functionality(self):\n        # Test typical inputs with standard content\n        title = \"Discussion Topic\"\n        body = \"Welcome to our discussion forum.\"\n        points = [\"Point 1\", \"Point 2\", \"Point 3\"]\n        expected = '<div><h1>Discussion Topic</h1><p>Welcome to our discussion forum.</p><ul><li>Point 1</li><li>Point 2</li><li>Point 3</li></ul></div>'\n        self.assertEqual(create_forum_entry(title, body, points), expected)\n\n    def test_html_escaping(self):\n        # Test that HTML special characters are properly escaped\n        title = \"<script>alert('xss')</script>\"\n        body = \"This & that <b>bold</b> text\"\n        points = [\"<a href=\\\"#\\\">Link</a>\", \"'Quoted' text\"]\n        expected = '<div><h1>&lt;script&gt;alert(&#x27;xss&#x27;)&lt;/script&gt;</h1><p>This &amp; that &lt;b&gt;bold&lt;/b&gt; text</p><ul><li>&lt;a href=&quot;#&quot;&gt;Link&lt;/a&gt;</li><li>&#x27;Quoted&#x27; text</li></ul></div>'\n        self.assertEqual(create_forum_entry(title, body, points), expected)\n\n    def test_empty_inputs(self):\n        # Test empty title, body, and points list\n        title = \"\"\n        body = \"\"\n        points = []\n        expected = '<div><h1></h1><p></p><ul></ul></div>'\n        self.assertEqual(create_forum_entry(title, body, points), expected)\n\n    def test_single_point(self):\n        # Test with only one discussion point\n        title = \"Single Option\"\n        body = \"Body content\"\n        points = [\"Only point\"]\n        expected = '<div><h1>Single Option</h1><p>Body content</p><ul><li>Only point</li></ul></div>'\n        self.assertEqual(create_forum_entry(title, body, points), expected)\n\n    def test_large_inputs(self):\n        # Test with very long strings\n        long_str = \"A\" * 1000\n        title = long_str\n        body = long_str\n        points = [long_str, long_str, long_str]\n        expected = f'<div><h1>{long_str}</h1><p>{long_str}</p><ul><li>{long_str}</li><li>{long_str}</li><li>{long_str}</li></ul></div>'\n        self.assertEqual(create_forum_entry(title, body, points), expected)\n\n    def test_whitespace_handling(self):\n        # Test inputs with various whitespace characters\n        title = \"  Title with spaces  \"\n        body = \"Line1\\nLine2\\tTabbed\"\n        points = [\"  Leading/trailing  \", \"New\\nLine\"]\n        expected = '<div><h1>  Title with spaces  </h1><p>Line1\\nLine2\\tTabbed</p><ul><li>  Leading/trailing  </li><li>New\\nLine</li></ul></div>'\n        self.assertEqual(create_forum_entry(title, body, points), expected)\n\n    def test_non_string_title(self):\n        # Test non-string title input\n        with self.assertRaises(TypeError):\n            create_forum_entry(123, \"Valid body\", [\"Valid\"])\n\n    def test_non_string_body(self):\n        # Test non-string body input\n        with self.assertRaises(TypeError):\n            create_forum_entry(\"Valid title\", 456, [\"Valid\"])\n\n    def test_non_string_in_points(self):\n        # Test non-string element in points list\n        with self.assertRaises(TypeError):\n            create_forum_entry(\"Valid\", \"Valid\", [\"Valid\", 789])\n\n    def test_non_list_points(self):\n        # Test points argument that is not a list\n        with self.assertRaises(TypeError):\n            create_forum_entry(\"Valid\", \"Valid\", \"not a list\")\n\n    def test_none_inputs(self):\n        # Test None for all arguments\n        with self.assertRaises(TypeError):\n            create_forum_entry(None, \"Valid\", [\"Valid\"])\n        with self.assertRaises(TypeError):\n            create_forum_entry(\"Valid\", None, [\"Valid\"])\n        with self.assertRaises(TypeError):\n            create_forum_entry(\"Valid\", \"Valid\", None)\n\n    def test_markdown_in_points(self):\n        # Test markdown content in points\n        title = \"Markdown Test\"\n        body = \"Body\"\n        points = [\"**Bold** text\", \"_Italic_ text\", \"`Code` snippet\"]\n        expected = '<div><h1>Markdown Test</h1><p>Body</p><ul><li>**Bold** text</li><li>_Italic_ text</li><li>`Code` snippet</li></ul></div>'\n        self.assertEqual(create_forum_entry(title, body, points), expected)", "num_test_cases": 12, "task_id": "cfb4ea80"}
{"test": "import unittest\nfrom unittest.mock import patch\nimport html\n\n# Define the global template that the function expects\nFORUM_POST_FORMAT = \"<h1>{title}</h1>\\n<p>{post_body}</p>\\n{options_list}\"\n\nclass TestBuildForumPost(unittest.TestCase):\n\n    def test_normal_input(self):\n        \"\"\"Test typical inputs with valid title, body, and options.\"\"\"\n        result = build_forum_post(\"Welcome\", \"This is a test post.\", [\"Option 1\", \"Option 2\"])\n        expected = \"<h1>Welcome</h1>\\n<p>This is a test post.</p>\\n<ul><li>Option 1</li><li>Option 2</li></ul>\"\n        self.assertEqual(result, expected)\n\n    def test_empty_title(self):\n        \"\"\"Test empty string for title.\"\"\"\n        result = build_forum_post(\"\", \"Body content\", [\"Option\"])\n        expected = \"<h1></h1>\\n<p>Body content</p>\\n<ul><li>Option</li></ul>\"\n        self.assertEqual(result, expected)\n\n    def test_empty_post_body(self):\n        \"\"\"Test empty string for post body.\"\"\"\n        result = build_forum_post(\"Title\", \"\", [\"Option\"])\n        expected = \"<h1>Title</h1>\\n<p></p>\\n<ul><li>Option</li></ul>\"\n        self.assertEqual(result, expected)\n\n    def test_empty_options_list(self):\n        \"\"\"Test empty list for options.\"\"\"\n        result = build_forum_post(\"Title\", \"Body\", [])\n        expected = \"<h1>Title</h1>\\n<p>Body</p>\\n<ul></ul>\"\n        self.assertEqual(result, expected)\n\n    def test_html_special_characters(self):\n        \"\"\"Test escaping of special HTML characters in title and body.\"\"\"\n        result = build_forum_post(\"<script>alert('xss')</script>\", \"This & that\", [])\n        escaped_title = html.escape(\"<script>alert('xss')</script>\")\n        escaped_body = html.escape(\"This & that\")\n        expected = f\"<h1>{escaped_title}</h1>\\n<p>{escaped_body}</p>\\n<ul></ul>\"\n        self.assertEqual(result, expected)\n\n    def test_special_characters_in_options(self):\n        \"\"\"Test escaping of special HTML characters in options list.\"\"\"\n        result = build_forum_post(\"Title\", \"Body\", [\"<b>bold</b>\", \"'quotes' & \\\"double\\\"\"])\n        escaped_opt1 = html.escape(\"<b>bold</b>\")\n        escaped_opt2 = html.escape(\"'quotes' & \\\"double\\\"\")\n        expected = f\"<h1>Title</h1>\\n<p>Body</p>\\n<ul><li>{escaped_opt1}</li><li>{escaped_opt2}</li></ul>\"\n        self.assertEqual(result, expected)\n\n    def test_non_string_title(self):\n        \"\"\"Test non-string title raises TypeError.\"\"\"\n        with self.assertRaises(TypeError):\n            build_forum_post(123, \"Body\", [\"Option\"])\n\n    def test_non_string_post_body(self):\n        \"\"\"Test non-string post body raises TypeError.\"\"\"\n        with self.assertRaises(TypeError):\n            build_forum_post(\"Title\", 123, [\"Option\"])\n\n    def test_non_list_options(self):\n        \"\"\"Test non-list options_list raises TypeError.\"\"\"\n        with self.assertRaises(TypeError):\n            build_forum_post(\"Title\", \"Body\", \"not a list\")\n\n    def test_non_string_in_options_list(self):\n        \"\"\"Test non-string element in options_list raises TypeError.\"\"\"\n        with self.assertRaises(TypeError):\n            build_forum_post(\"Title\", \"Body\", [\"valid\", 123])\n", "num_test_cases": 10, "task_id": "f9640114"}
{"test": "import unittest\nimport html\n\nclass TestConstructForumContent(unittest.TestCase):\n    def test_happy_path(self):\n        \"\"\"Test typical inputs with standard values.\"\"\"\n        heading = \"Welcome\"\n        content = \"This is a test post.\"\n        choices = [\"Option 1\", \"Option 2\", \"Option 3\"]\n        result = construct_forum_content(heading, content, choices)\n        \n        safe_heading = html.escape(heading)\n        safe_content = html.escape(content)\n        safe_choices = [html.escape(c) for c in choices]\n        \n        self.assertIsInstance(result, str)\n        self.assertIn(safe_heading, result)\n        self.assertIn(safe_content, result)\n        self.assertIn(\"<ul>\", result)\n        self.assertIn(\"</ul>\", result)\n        for c in safe_choices:\n            self.assertIn(f\"<li>{c}</li>\", result)\n    \n    def test_empty_inputs(self):\n        \"\"\"Test empty heading, content, and choices list.\"\"\"\n        heading = \"\"\n        content = \"\"\n        choices = []\n        result = construct_forum_content(heading, content, choices)\n        \n        safe_heading = html.escape(heading)\n        safe_content = html.escape(content)\n        \n        self.assertIsInstance(result, str)\n        self.assertIn(safe_heading, result)\n        self.assertIn(safe_content, result)\n        self.assertIn(\"<ul>\", result)\n        self.assertIn(\"</ul>\", result)\n        self.assertEqual(result.count(\"<li>\"), 0)\n    \n    def test_html_escaping(self):\n        \"\"\"Test inputs containing HTML special characters.\"\"\"\n        heading = \"<script>alert('xss')</script>\"\n        content = \"Some <b>bold</b> text & special chars: &, <, >\"\n        choices = [\"<a href='malicious'>click</a>\", \"Another & choice\"]\n        result = construct_forum_content(heading, content, choices)\n        \n        safe_heading = html.escape(heading)\n        safe_content = html.escape(content)\n        safe_choices = [html.escape(c) for c in choices]\n        \n        self.assertIsInstance(result, str)\n        self.assertIn(safe_heading, result)\n        self.assertIn(safe_content, result)\n        self.assertIn(\"<ul>\", result)\n        self.assertIn(\"</ul>\", result)\n        for c in safe_choices:\n            self.assertIn(f\"<li>{c}</li>\", result)\n        \n        # Verify dangerous strings are escaped\n        self.assertNotIn(\"<script>\", result)\n        self.assertNotIn(\"</script>\", result)\n        self.assertNotIn(\"<b>\", result)\n        self.assertNotIn(\"</b>\", result)\n        self.assertNotIn(\"<a href=\", result)\n        self.assertIn(\"&lt;script&gt;\", result)\n        self.assertIn(\"&lt;b&gt;\", result)\n        self.assertIn(\"&amp;\", result)\n    \n    def test_large_inputs(self):\n        \"\"\"Test long heading, long content, and large number of choices.\"\"\"\n        heading = \"A\" * 1000\n        content = \"B\" * 5000\n        choices = [str(i) * 10 for i in range(100)]\n        result = construct_forum_content(heading, content, choices)\n        \n        safe_heading = html.escape(heading)\n        safe_content = html.escape(content)\n        safe_choices = [html.escape(c) for c in choices]\n        \n        self.assertIsInstance(result, str)\n        self.assertIn(safe_heading, result)\n        self.assertIn(safe_content, result)\n        self.assertIn(\"<ul>\", result)\n        self.assertIn(\"</ul>\", result)\n        for c in safe_choices:\n            self.assertIn(f\"<li>{c}</li>\", result)\n    \n    def test_non_string_heading(self):\n        \"\"\"Test non-string heading raises TypeError.\"\"\"\n        heading = 123\n        content = \"test\"\n        choices = [\"a\", \"b\"]\n        with self.assertRaises(TypeError):\n            construct_forum_content(heading, content, choices)\n    \n    def test_non_string_content(self):\n        \"\"\"Test non-string content raises TypeError.\"\"\"\n        heading = \"test\"\n        content = None\n        choices = [\"a\", \"b\"]\n        with self.assertRaises(TypeError):\n            construct_forum_content(heading, content, choices)\n    \n    def test_non_string_in_choices(self):\n        \"\"\"Test non-string element in choices raises TypeError.\"\"\"\n        heading = \"test\"\n        content = \"test\"\n        choices = [\"a\", 123, \"b\"]\n        with self.assertRaises(TypeError):\n            construct_forum_content(heading, content, choices)\n    \n    def test_choices_as_none(self):\n        \"\"\"Test None for choices raises TypeError.\"\"\"\n        heading = \"test\"\n        content = \"test\"\n        choices = None\n        with self.assertRaises(TypeError):\n            construct_forum_content(heading, content, choices)\n    \n    def test_choices_as_tuple(self):\n        \"\"\"Test tuple instead of list works if contains strings.\"\"\"\n        heading = \"test\"\n        content = \"test\"\n        choices = (\"a\", \"b\", \"c\")\n        result = construct_forum_content(heading, content, choices)\n        \n        safe_heading = html.escape(heading)\n        safe_content = html.escape(content)\n        safe_choices = [html.escape(c) for c in choices]\n        \n        self.assertIsInstance(result, str)\n        self.assertIn(safe_heading, result)\n        self.assertIn(safe_content, result)\n        self.assertIn(\"<ul>\", result)\n        self.assertIn(\"</ul>\", result)\n        for c in safe_choices:\n            self.assertIn(f\"<li>{c}</li>\", result)\n    \n    def test_single_choice(self):\n        \"\"\"Test with a single choice in the list.\"\"\"\n        heading = \"Single Option\"\n        content = \"Content\"\n        choices = [\"Only choice\"]\n        result = construct_forum_content(heading, content, choices)\n        \n        safe_heading = html.escape(heading)\n        safe_content = html.escape(content)\n        safe_choices = [html.escape(c) for c in choices]\n        \n        self.assertIsInstance(result, str)\n        self.assertIn(safe_heading, result)\n        self.assertIn(safe_content, result)\n        self.assertIn(\"<ul>\", result)\n        self.assertIn(\"</ul>\", result)\n        for c in safe_choices:\n            self.assertIn(f\"<li>{c}</li>\", result)\n        self.assertEqual(result.count(\"<li>\"), 1)", "num_test_cases": 10, "task_id": "9b859668"}
{"test": "import unittest\nimport html\n\nclass TestCreateForumPost(unittest.TestCase):\n    def test_happy_path(self):\n        \"\"\"Test typical inputs with normal content.\"\"\"\n        title = \"Welcome\"\n        body = \"This is a test post.\"\n        topics = [\"Introduction\", \"Help\"]\n        result = create_forum_post(title, body, topics)\n        \n        self.assertIn(html.escape(title), result)\n        self.assertIn(html.escape(body), result)\n        for topic in topics:\n            self.assertIn(html.escape(topic), result)\n            self.assertIn(f\"<li>{html.escape(topic)}</li>\", result)\n        self.assertIn(\"<ul>\", result)\n        self.assertIn(\"</ul>\", result)\n\n    def test_empty_title(self):\n        \"\"\"Test with an empty title.\"\"\"\n        result = create_forum_post(\"\", \"Content\", [\"topic\"])\n        self.assertIn(html.escape(\"\"), result)\n        self.assertIn(html.escape(\"Content\"), result)\n        self.assertIn(\"<li>topic</li>\", result)\n\n    def test_empty_body(self):\n        \"\"\"Test with an empty body.\"\"\"\n        result = create_forum_post(\"Title\", \"\", [\"topic\"])\n        self.assertIn(html.escape(\"Title\"), result)\n        self.assertIn(html.escape(\"\"), result)\n        self.assertIn(\"<li>topic</li>\", result)\n\n    def test_empty_topics(self):\n        \"\"\"Test with an empty topics list.\"\"\"\n        result = create_forum_post(\"T\", \"B\", [])\n        self.assertIn(html.escape(\"T\"), result)\n        self.assertIn(html.escape(\"B\"), result)\n        self.assertIn(\"<ul></ul>\", result)\n\n    def test_html_escape_title(self):\n        \"\"\"Test escaping HTML in title.\"\"\"\n        dangerous = '<script>alert(\"xss\")</script>'\n        escaped = html.escape(dangerous)\n        result = create_forum_post(dangerous, \"Safe\", [\"t\"])\n        self.assertIn(escaped, result)\n        self.assertNotIn(dangerous, result)\n\n    def test_html_escape_body(self):\n        \"\"\"Test escaping HTML in body.\"\"\"\n        dangerous = '<div onclick=\"alert(1)\">'\n        escaped = html.escape(dangerous)\n        result = create_forum_post(\"Safe\", dangerous, [\"t\"])\n        self.assertIn(escaped, result)\n        self.assertNotIn(dangerous, result)\n\n    def test_html_escape_topics(self):\n        \"\"\"Test escaping HTML in topics.\"\"\"\n        dangerous = ['<b>Unsafe</b>', '\" onmouseover=\"alert(1)\"']\n        escaped = [html.escape(d) for d in dangerous]\n        result = create_forum_post(\"Safe\", \"Safe\", dangerous)\n        for e in escaped:\n            self.assertIn(e, result)\n            self.assertIn(f\"<li>{e}</li>\", result)\n        for d in dangerous:\n            self.assertNotIn(d, result)\n\n    def test_title_none(self):\n        \"\"\"Test None for title raises TypeError.\"\"\"\n        with self.assertRaises(TypeError):\n            create_forum_post(None, \"Body\", [\"t\"])\n\n    def test_body_none(self):\n        \"\"\"Test None for body raises TypeError.\"\"\"\n        with self.assertRaises(TypeError):\n            create_forum_post(\"Title\", None, [\"t\"])\n\n    def test_topics_none(self):\n        \"\"\"Test None for topics raises TypeError.\"\"\"\n        with self.assertRaises(TypeError):\n            create_forum_post(\"T\", \"B\", None)\n\n    def test_topics_non_list(self):\n        \"\"\"Test non-list topics raises TypeError.\"\"\"\n        with self.assertRaises(TypeError):\n            create_forum_post(\"T\", \"B\", \"not a list\")\n\n    def test_non_string_in_topics(self):\n        \"\"\"Test non-string in topics list raises TypeError.\"\"\"\n        with self.assertRaises(TypeError):\n            create_forum_post(\"T\", \"B\", [\"valid\", 123])\n\n    def test_large_inputs(self):\n        \"\"\"Test very long title, body, and topics.\"\"\"\n        title = 'A' * 10000\n        body = 'B' * 10000\n        topics = ['C' * 100, 'D' * 200]\n        result = create_forum_post(title, body, topics)\n        \n        self.assertIn(html.escape(title), result)\n        self.assertIn(html.escape(body), result)\n        for topic in topics:\n            self.assertIn(html.escape(topic), result)\n            self.assertIn(f\"<li>{html.escape(topic)}</li>\", result)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 13, "task_id": "784cb2e6"}
{"test": "import unittest\nfrom unittest.mock import patch\nimport solution\n\n# Define the test template\nTEST_TEMPLATE = '''<div class=\"event\">\n    <h1>{headline}</h1>\n    <p class=\"description\">{summary}</p>\n    <p class=\"date\">{scheduled_date}</p>\n    <p class=\"notes\">{additional_info}</p>\n</div>'''\n\nclass TestPrepareEventDetails(unittest.TestCase):\n    @classmethod\n    def setUpClass(cls):\n        # Patch the INVITATION_FORMAT in the solution module\n        cls.patcher = patch('solution.INVITATION_FORMAT', TEST_TEMPLATE)\n        cls.patcher.start()\n\n    @classmethod\n    def tearDownClass(cls):\n        cls.patcher.stop()\n\n    def test_case_1(self):\n        # Test normal inputs\n        result = solution.prepare_event_details(\n            \"Company Event\",\n            \"Annual company gathering\",\n            \"2023-12-31\",\n            \"Dress code: Formal\"\n        )\n        self.assertIsInstance(result, str)\n        self.assertIn(\"Company Event\", result)\n        self.assertIn(\"Annual company gathering\", result)\n        self.assertIn(\"2023-12-31\", result)\n        self.assertIn(\"Dress code: Formal\", result)\n\n    def test_case_2(self):\n        # Test inputs with HTML and special characters\n        result = solution.prepare_event_details(\n            \"<script>alert('hack')</script>\",\n            \"<div>This is a div</div>\",\n            \"2023-12-31\",\n            \"& is escaped\"\n        )\n        self.assertIsInstance(result, str)\n        self.assertIn(\"&lt;script&gt;alert(&#x27;hack&#x27;)&lt;/script&gt;\", result)\n        self.assertIn(\"&lt;div&gt;This is a div&lt;/div&gt;\", result)\n        self.assertIn(\"2023-12-31\", result)\n        self.assertIn(\"&amp; is escaped\", result)\n\n    def test_case_3(self):\n        # Test empty strings\n        result = solution.prepare_event_details(\"\", \"\", \"\", \"\")\n        self.assertIsInstance(result, str)\n        expected = TEST_TEMPLATE.format(\n            headline=\"\",\n            summary=\"\",\n            scheduled_date=\"\",\n            additional_info=\"\"\n        )\n        self.assertEqual(result, expected)\n\n    def test_case_4(self):\n        # Test very long headline\n        long_headline = \"A\" * 1000\n        result = solution.prepare_event_details(\n            long_headline,\n            \"Summary\",\n            \"2023-12-31\",\n            \"Additional info\"\n        )\n        self.assertIsInstance(result, str)\n        self.assertIn(html.escape(long_headline), result)\n        self.assertIn(\"Summary\", result)\n        self.assertIn(\"2023-12-31\", result)\n        self.assertIn(\"Additional info\", result)\n\n    def test_case_5(self):\n        # Test very long inputs for all fields\n        long_str = \"A\" * 1000\n        result = solution.prepare_event_details(\n            long_str,\n            long_str,\n            long_str,\n            long_str\n        )\n        self.assertIsInstance(result, str)\n        self.assertIn(html.escape(long_str), result)\n\n    def test_case_6(self):\n        # Test non-ASCII characters\n        result = solution.prepare_event_details(\n            \"日本語\",\n            \"éèà\",\n            \"2023-12-31\",\n            \"✓\"\n        )\n        self.assertIsInstance(result, str)\n        self.assertIn(\"日本語\", result)\n        self.assertIn(\"éèà\", result)\n        self.assertIn(\"2023-12-31\", result)\n        self.assertIn(\"✓\", result)\n\n    def test_case_7(self):\n        # Test headline as None\n        with self.assertRaises(TypeError):\n            solution.prepare_event_details(None, \"Summary\", \"2023-12-31\", \"Info\")\n\n    def test_case_8(self):\n        # Test summary as integer\n        with self.assertRaises(TypeError):\n            solution.prepare_event_details(\"Headline\", 123, \"2023-12-31\", \"Info\")\n\n    def test_case_9(self):\n        # Test scheduled_date as float\n        with self.assertRaises(TypeError):\n            solution.prepare_event_details(\"Headline\", \"Summary\", 3.14, \"Info\")\n\n    def test_case_10(self):\n        # Test additional_info as list\n        with self.assertRaises(TypeError):\n            solution.prepare_event_details(\"Headline\", \"Summary\", \"2023-12-31\", [\"a\"])\n", "num_test_cases": 10, "task_id": "ae79081b"}
{"test": "import unittest\nfrom unittest.mock import patch\nimport html\n\n# Assume the function is in a module named 'solution'\nfrom solution import create_event_invitation\n\n# Define a test template to use during patching\nTEST_TEMPLATE = 'Title: {title}\\nDescription: {description}\\nDate: {date}\\nNotes: {notes}'\n\n@patch('solution.INVITATION_FORMAT', TEST_TEMPLATE)\nclass TestEventInvitation(unittest.TestCase):\n    def test_safe_inputs(self):\n        \"\"\"Test typical inputs with safe content (no escaping needed).\"\"\"\n        title = 'Company Picnic'\n        description = 'Join us for the annual company picnic on the grounds.'\n        date = 'June 30, 2024'\n        notes = 'Please bring a dish to share.'\n        expected = TEST_TEMPLATE.format(title=title, description=description, date=date, notes=notes)\n        result = create_event_invitation(title, description, date, notes)\n        self.assertEqual(result, expected)\n\n    def test_unsafe_inputs(self):\n        \"\"\"Test inputs containing HTML/JS characters that require escaping.\"\"\"\n        title = '<script>alert(\"XSS\")</script>'\n        description = '<b>Bold</b> but not really'\n        date = '2024-06-30 & 2024-07-01'\n        notes = 'Notes: <a href=\"javascript:alert()\">click</a>'\n        safe_title = html.escape(title)\n        safe_description = html.escape(description)\n        safe_date = html.escape(date)\n        safe_notes = html.escape(notes)\n        expected = TEST_TEMPLATE.format(title=safe_title, description=safe_description, date=safe_date, notes=safe_notes)\n        result = create_event_invitation(title, description, date, notes)\n        self.assertEqual(result, expected)\n\n    def test_empty_inputs(self):\n        \"\"\"Test empty strings for all arguments.\"\"\"\n        title = description = date = notes = ''\n        expected = TEST_TEMPLATE.format(title='', description='', date='', notes='')\n        result = create_event_invitation(title, description, date, notes)\n        self.assertEqual(result, expected)\n\n    def test_long_input(self):\n        \"\"\"Test very long safe strings in all arguments.\"\"\"\n        long_str = 'A' * 1000\n        expected = TEST_TEMPLATE.format(title=long_str, description=long_str, date=long_str, notes=long_str)\n        result = create_event_invitation(long_str, long_str, long_str, long_str)\n        self.assertEqual(result, expected)\n\n    def test_non_ascii_input(self):\n        \"\"\"Test non-ASCII Unicode characters in all arguments.\"\"\"\n        non_ascii = \"Mötley Crüe\"\n        expected = TEST_TEMPLATE.format(title=non_ascii, description=non_ascii, date=non_ascii, notes=non_ascii)\n        result = create_event_invitation(non_ascii, non_ascii, non_ascii, non_ascii)\n        self.assertEqual(result, expected)\n\n    def test_title_non_string(self):\n        \"\"\"Test non-string title argument.\"\"\"\n        with self.assertRaises(TypeError):\n            create_event_invitation(123, 'description', 'date', 'notes')\n\n    def test_description_non_string(self):\n        \"\"\"Test non-string description argument.\"\"\"\n        with self.assertRaises(TypeError):\n            create_event_invitation('title', 123, 'date', 'notes')\n\n    def test_date_non_string(self):\n        \"\"\"Test non-string date argument.\"\"\"\n        with self.assertRaises(TypeError):\n            create_event_invitation('title', 'description', 123, 'notes')\n\n    def test_notes_non_string(self):\n        \"\"\"Test non-string notes argument.\"\"\"\n        with self.assertRaises(TypeError):\n            create_event_invitation('title', 'description', 'date', 123)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 9, "task_id": "e28bb9e0"}
{"test": "import unittest\nimport html\n\nINVITATION_FORMAT = '''\n<div>\n    <h1>{title}</h1>\n    <div>{description}</div>\n    <p>Date: {date}</p>\n    <p>Notes: {notes}</p>\n</div>\n'''\n\ndef generate_event_invite(title: str, description: str, date: str, notes: str):\n    import html\n    safe_title = html.escape(title)\n    safe_description = html.escape(description)\n    safe_date = html.escape(date)\n    safe_notes = html.escape(notes)\n    return INVITATION_FORMAT.format(title=safe_title, description=safe_description, date=safe_date, notes=safe_notes)\n\nclass TestGenerateEventInvite(unittest.TestCase):\n\n    def test_basic_input(self):\n        \"\"\"Test typical inputs with standard values.\"\"\"\n        title = 'Team Meeting'\n        description = 'Discuss project progress'\n        date = '2023-09-15'\n        notes = 'Bring reports'\n        result = generate_event_invite(title, description, date, notes)\n        self.assertIsInstance(result, str)\n        self.assertIn(html.escape(title), result)\n        self.assertIn(html.escape(description), result)\n        self.assertIn(html.escape(date), result)\n        self.assertIn(html.escape(notes), result)\n\n    def test_html_special_chars(self):\n        \"\"\"Test inputs containing HTML and special characters for XSS safety.\"\"\"\n        title = '<script>alert(\\'xss\\')</script>'\n        description = '<b>Description</b> & more'\n        date = '2024-01-01 <tag>'\n        notes = 'Note: <note> & '\n        result = generate_event_invite(title, description, date, notes)\n        self.assertIsInstance(result, str)\n        self.assertIn(html.escape(title), result)\n        self.assertIn(html.escape(description), result)\n        self.assertIn(html.escape(date), result)\n        self.assertIn(html.escape(notes), result)\n        self.assertNotIn('<script>', result)\n        self.assertNotIn('<b>', result)\n        self.assertNotIn('<tag>', result)\n        self.assertNotIn('<note>', result)\n\n    def test_empty_strings(self):\n        \"\"\"Test all input fields as empty strings.\"\"\"\n        title = ''\n        description = ''\n        date = ''\n        notes = ''\n        result = generate_event_invite(title, description, date, notes)\n        self.assertIsInstance(result, str)\n        expected = INVITATION_FORMAT.format(title='', description='', date='', notes='')\n        self.assertEqual(result, expected)\n\n    def test_long_inputs(self):\n        \"\"\"Test very long inputs for each field.\"\"\"\n        long_str = 'A' * 10000\n        result = generate_event_invite(long_str, long_str, long_str, long_str)\n        self.assertIsInstance(result, str)\n        self.assertIn(long_str, result)\n        self.assertGreater(len(result), 10000)\n\n    def test_title_non_string(self):\n        \"\"\"Test non-string title input (None).\"\"\"\n        with self.assertRaises(TypeError):\n            generate_event_invite(None, 'desc', 'date', 'notes')\n\n    def test_description_non_string(self):\n        \"\"\"Test non-string description input (None).\"\"\"\n        with self.assertRaises(TypeError):\n            generate_event_invite('title', None, 'date', 'notes')\n\n    def test_date_non_string(self):\n        \"\"\"Test non-string date input (None).\"\"\"\n        with self.assertRaises(TypeError):\n            generate_event_invite('title', 'desc', None, 'notes')\n\n    def test_notes_non_string(self):\n        \"\"\"Test non-string notes input (None).\"\"\"\n        with self.assertRaises(TypeError):\n            generate_event_invite('title', 'desc', 'date', None)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 8, "task_id": "914ba22c"}
{"test": "import unittest\nfrom unittest.mock import patch\nimport html\nfrom solution import build_event_invitation\n\nTEST_TEMPLATE = '''<div class=\"event-invitation\">\n    <h1>{event_title}</h1>\n    <p><strong>Description:</strong> {event_description}</p>\n    <p><strong>Date:</strong> {event_date}</p>\n    <p><strong>Additional Notes:</strong> {additional_notes}</p>\n</div>'''\n\n@patch('solution.INVITATION_FORMAT', TEST_TEMPLATE)\nclass TestBuildEventInvitation(unittest.TestCase):\n    def test_normal_input(self):\n        # Test with typical inputs\n        title = 'Company Meeting'\n        description = 'Quarterly review meeting.'\n        date = '2023-10-15'\n        notes = 'Please be on time.'\n        result = build_event_invitation(title, description, date, notes)\n        expected = TEST_TEMPLATE.format(\n            event_title=html.escape(title),\n            event_description=html.escape(description),\n            event_date=html.escape(date),\n            additional_notes=html.escape(notes)\n        )\n        self.assertEqual(result, expected)\n    \n    def test_empty_inputs(self):\n        # Test with all empty strings\n        title = ''\n        description = ''\n        date = ''\n        notes = ''\n        result = build_event_invitation(title, description, date, notes)\n        expected = TEST_TEMPLATE.format(\n            event_title=html.escape(title),\n            event_description=html.escape(description),\n            event_date=html.escape(date),\n            additional_notes=html.escape(notes)\n        )\n        self.assertEqual(result, expected)\n    \n    def test_xss_inputs(self):\n        # Test with inputs that contain script tags and other XSS attempts\n        xss_string = \"<script>alert('XSS');</script>\"\n        safe_string = html.escape(xss_string)\n        result = build_event_invitation(xss_string, xss_string, xss_string, xss_string)\n        expected = TEST_TEMPLATE.format(\n            event_title=safe_string,\n            event_description=safe_string,\n            event_date=safe_string,\n            additional_notes=safe_string\n        )\n        self.assertEqual(result, expected)\n    \n    def test_special_characters(self):\n        # Test with inputs that contain special characters\n        special_string = \"&<>\\\"'\"\n        safe_string = html.escape(special_string)\n        result = build_event_invitation(special_string, special_string, special_string, special_string)\n        expected = TEST_TEMPLATE.format(\n            event_title=safe_string,\n            event_description=safe_string,\n            event_date=safe_string,\n            additional_notes=safe_string\n        )\n        self.assertEqual(result, expected)\n    \n    def test_long_input(self):\n        # Test with very long inputs\n        long_string = 'A' * 1000\n        safe_string = html.escape(long_string)\n        result = build_event_invitation(long_string, long_string, long_string, long_string)\n        expected = TEST_TEMPLATE.format(\n            event_title=safe_string,\n            event_description=safe_string,\n            event_date=safe_string,\n            additional_notes=safe_string\n        )\n        self.assertEqual(result, expected)\n    \n    def test_title_not_string_int(self):\n        # Test with non-string title (integer)\n        with self.assertRaises(TypeError):\n            build_event_invitation(123, 'desc', 'date', 'notes')\n    \n    def test_title_not_string_none(self):\n        # Test with non-string title (None)\n        with self.assertRaises(TypeError):\n            build_event_invitation(None, 'desc', 'date', 'notes')\n    \n    def test_description_not_string_int(self):\n        # Test with non-string description (integer)\n        with self.assertRaises(TypeError):\n            build_event_invitation('title', 123, 'date', 'notes')\n    \n    def test_description_not_string_none(self):\n        # Test with non-string description (None)\n        with self.assertRaises(TypeError):\n            build_event_invitation('title', None, 'date', 'notes')\n    \n    def test_date_not_string_int(self):\n        # Test with non-string date (integer)\n        with self.assertRaises(TypeError):\n            build_event_invitation('title', 'desc', 123, 'notes')\n    \n    def test_date_not_string_none(self):\n        # Test with non-string date (None)\n        with self.assertRaises(TypeError):\n            build_event_invitation('title', 'desc', None, 'notes')\n    \n    def test_notes_not_string_int(self):\n        # Test with non-string notes (integer)\n        with self.assertRaises(TypeError):\n            build_event_invitation('title', 'desc', 'date', 123)\n    \n    def test_notes_not_string_none(self):\n        # Test with non-string notes (None)\n        with self.assertRaises(TypeError):\n            build_event_invitation('title', 'desc', 'date', None)\n", "num_test_cases": 13, "task_id": "ec294c4a"}
{"test": "import unittest\nimport html\n\nclass TestCreateEventInvitation(unittest.TestCase):\n    def test_normal_input(self):\n        \"\"\"Test function with normal inputs without special characters.\"\"\"\n        result = create_event_invitation(\n            'Team Meeting',\n            'Discuss project milestones and deadlines.',\n            '2024-06-15',\n            'Bring your laptops.'\n        )\n        self.assertIsInstance(result, str)\n        self.assertIn('Team Meeting', result)\n        self.assertIn('Discuss project milestones and deadlines.', result)\n        self.assertIn('2024-06-15', result)\n        self.assertIn('Bring your laptops.', result)\n    \n    def test_inputs_with_special_chars(self):\n        \"\"\"Test inputs containing special HTML/JS characters for proper escaping.\"\"\"\n        e_title = '<script>alert(1)</script>'\n        e_description = 'This has <em>HTML</em> & special chars.'\n        e_date = '2024-06-15 & beyond'\n        e_notes = 'Notes: <a href=\"example.com\">link</a>'\n        \n        result = create_event_invitation(e_title, e_description, e_date, e_notes)\n        safe_title = html.escape(e_title)\n        safe_description = html.escape(e_description)\n        safe_date = html.escape(e_date)\n        safe_notes = html.escape(e_notes)\n        \n        self.assertIn(safe_title, result)\n        self.assertIn(safe_description, result)\n        self.assertIn(safe_date, result)\n        self.assertIn(safe_notes, result)\n        self.assertNotIn(e_title, result)\n        self.assertNotIn(e_description, result)\n        self.assertNotIn(e_date, result)\n        self.assertNotIn(e_notes, result)\n    \n    def test_empty_inputs(self):\n        \"\"\"Test with all inputs as empty strings.\"\"\"\n        result = create_event_invitation('', '', '', '')\n        self.assertIsInstance(result, str)\n    \n    def test_long_inputs(self):\n        \"\"\"Test very long input strings to ensure handling and escaping.\"\"\"\n        long_str = 'A' * 10000\n        result = create_event_invitation(long_str, long_str, long_str, long_str)\n        safe_str = html.escape(long_str)\n        self.assertIn(safe_str, result)\n        self.assertNotIn(long_str, result)\n    \n    def test_non_string_title(self):\n        \"\"\"Test non-string title raises TypeError.\"\"\"\n        with self.assertRaises(TypeError):\n            create_event_invitation(123, 'desc', 'date', 'notes')\n    \n    def test_non_string_description(self):\n        \"\"\"Test non-string description raises TypeError.\"\"\"\n        with self.assertRaises(TypeError):\n            create_event_invitation('title', 456, 'date', 'notes')\n    \n    def test_non_string_date(self):\n        \"\"\"Test non-string date raises TypeError.\"\"\"\n        with self.assertRaises(TypeError):\n            create_event_invitation('title', 'desc', 789.0, 'notes')\n    \n    def test_non_string_notes(self):\n        \"\"\"Test non-string notes raises TypeError.\"\"\"\n        with self.assertRaises(TypeError):\n            create_event_invitation('title', 'desc', 'date', None)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 8, "task_id": "643cc030"}
{"test": "import unittest\nimport html\n\n# Define the global template required by the function\nINVITATION_FORMAT = '<div><h1>{event_title}</h1><p>{event_description}</p><p>Date: {event_date}</p><p>Notes: {additional_notes}</p></div>'\n\nclass TestGenerateEventHtml(unittest.TestCase):\n    def test_normal_inputs(self):\n        \"\"\"Test typical inputs without special characters\"\"\"\n        result = generate_event_html('Company Event', 'Annual meeting for all employees', '2023-12-31', 'Bring your ID card')\n        self.assertIsInstance(result, str)\n        self.assertIn('Company Event', result)\n        self.assertIn('Annual meeting for all employees', result)\n        self.assertIn('2023-12-31', result)\n        self.assertIn('Bring your ID card', result)\n    \n    def test_dangerous_characters(self):\n        \"\"\"Test inputs containing HTML/JS characters that require escaping\"\"\"\n        title = '<script>alert(\"xss\")</script>'\n        description = 'This & That <b>description</b>'\n        date = '2024-01-01 > 2023-12-31'\n        notes = '<a href=\"javascript:malicious()\">Click</a>'\n        result = generate_event_html(title, description, date, notes)\n        \n        # Verify all dangerous characters are properly escaped\n        self.assertNotIn('<script>', result)\n        self.assertNotIn('<b>', result)\n        self.assertNotIn('<a href=', result)\n        self.assertIn(html.escape(title), result)\n        self.assertIn(html.escape(description), result)\n        self.assertIn(html.escape(date), result)\n        self.assertIn(html.escape(notes), result)\n    \n    def test_empty_strings(self):\n        \"\"\"Test all empty string inputs\"\"\"\n        result = generate_event_html('', '', '', '')\n        self.assertIsInstance(result, str)\n        expected = INVITATION_FORMAT.format(\n            event_title='',\n            event_description='',\n            event_date='',\n            additional_notes=''\n        )\n        self.assertEqual(result, expected)\n    \n    def test_partial_empty_strings(self):\n        \"\"\"Test combinations of empty and non-empty inputs\"\"\"\n        # Test empty title\n        result = generate_event_html('', 'Description', '2023-01-01', 'Notes')\n        self.assertIn('', result)\n        self.assertIn('Description', result)\n        \n        # Test empty description\n        result = generate_event_html('Title', '', '2023-01-01', 'Notes')\n        self.assertIn('Title', result)\n        self.assertIn('', result)\n    \n    def test_very_long_inputs(self):\n        \"\"\"Test extremely long input strings\"\"\"\n        long_str = 'A' * 10000\n        result = generate_event_html(long_str, long_str, long_str, long_str)\n        self.assertIsInstance(result, str)\n        self.assertIn(html.escape(long_str), result)\n        self.assertEqual(len(result), len(INVITATION_FORMAT.format(\n            event_title=long_str,\n            event_description=long_str,\n            event_date=long_str,\n            additional_notes=long_str\n        )))\n    \n    def test_non_ascii_inputs(self):\n        \"\"\"Test non-ASCII characters (Unicode, emojis)\"\"\"\n        title = '日本'\n        description = '絵文字: 😊'\n        date = '2023-01-01'\n        notes = ''\n        result = generate_event_html(title, description, date, notes)\n        self.assertIn(title, result)\n        self.assertIn(description, result)\n        self.assertIn(date, result)\n        self.assertIn(notes, result)\n    \n    def test_multi_line_inputs(self):\n        \"\"\"Test multi-line inputs with newline characters\"\"\"\n        description = 'Line 1\\nLine 2\\nLine 3'\n        notes = 'Note 1\\nNote 2'\n        result = generate_event_html('Event', description, '2023-01-01', notes)\n        self.assertIn('Line 1\\nLine 2\\nLine 3', result)\n        self.assertIn('Note 1\\nNote 2', result)\n    \n    def test_title_as_none(self):\n        \"\"\"Test None type for title argument\"\"\"\n        with self.assertRaises(TypeError):\n            generate_event_html(None, 'Description', '2023-01-01', 'Notes')\n    \n    def test_description_as_none(self):\n        \"\"\"Test None type for description argument\"\"\"\n        with self.assertRaises(TypeError):\n            generate_event_html('Title', None, '2023-01-01', 'Notes')\n    \n    def test_date_as_none(self):\n        \"\"\"Test None type for date argument\"\"\"\n        with self.assertRaises(TypeError):\n            generate_event_html('Title', 'Description', None, 'Notes')\n    \n    def test_notes_as_none(self):\n        \"\"\"Test None type for extra_notes argument\"\"\"\n        with self.assertRaises(TypeError):\n            generate_event_html('Title', 'Description', '2023-01-01', None)\n    \n    def test_non_string_integer_input(self):\n        \"\"\"Test integer input instead of strings\"\"\"\n        with self.assertRaises(TypeError):\n            generate_event_html(123, 'Description', '2023-01-01', 'Notes')\n        with self.assertRaises(TypeError):\n            generate_event_html('Title', 456, '2023-01-01', 'Notes')\n    \n    def test_non_string_list_input(self):\n        \"\"\"Test list input instead of strings\"\"\"\n        with self.assertRaises(TypeError):\n            generate_event_html(['Event'], 'Description', '2023-01-01', 'Notes')\n        with self.assertRaises(TypeError):\n            generate_event_html('Title', ['Description'], '2023-01-01', 'Notes')", "num_test_cases": 14, "task_id": "1f396457"}
{"test": "import unittest\nimport html\n\n# Define the global template required by the function\nUSER_POST_FORMAT = \"\"\"\n<div class=\"post\">\n    <h1 class=\"title\">{title}</h1>\n    <div class=\"author\">By: {writer_name}</div>\n    <div class=\"content\">{body}</div>\n    <div class=\"tags\">{tags_html}</div>\n</div>\n\"\"\"\n\nclass TestGeneratePostHtml(unittest.TestCase):\n    \n    def test_normal_input(self):\n        \"\"\"Test with typical valid inputs.\"\"\"\n        result = generate_post_html(\"John Doe\", \"Hello World\", \"This is a test post.\", [\"tech\", \"blog\"])\n        \n        # Build expected output\n        safe_writer_name = html.escape(\"John Doe\")\n        safe_title = html.escape(\"Hello World\")\n        safe_body = html.escape(\"This is a test post.\")\n        safe_tags = [html.escape(tag) for tag in [\"tech\", \"blog\"]]\n        tags_html = \" \".join(f\"<span>{tag}</span>\" for tag in safe_tags)\n        expected = USER_POST_FORMAT.format(\n            writer_name=safe_writer_name,\n            title=safe_title,\n            body=safe_body,\n            tags_html=tags_html\n        )\n        \n        self.assertEqual(result, expected)\n    \n    def test_html_escaping(self):\n        \"\"\"Test inputs with special HTML characters that need escaping.\"\"\"\n        result = generate_post_html(\n            'John \"The Dude\" <script>',\n            'Hello <World> & Friends',\n            'This & that <script>alert(1)</script>',\n            ['<tag>', '\"quoted\"', '&']\n        )\n        \n        # Verify escaped versions appear in output\n        self.assertIn(html.escape('John \"The Dude\" <script>'), result)\n        self.assertIn(html.escape('Hello <World> & Friends'), result)\n        self.assertIn(html.escape('This & that <script>alert(1)</script>'), result)\n        self.assertIn(f\"<span>{html.escape('<tag>')}</span>\", result)\n        self.assertIn(f\"<span>{html.escape('&quot;quoted&quot;')}</span>\", result)\n        self.assertIn(f\"<span>{html.escape('&')}</span>\", result)\n        \n    def test_empty_input(self):\n        \"\"\"Test with empty strings and empty tag list.\"\"\"\n        result = generate_post_html(\"\", \"\", \"\", [])\n        \n        # Build expected output with empty values\n        expected = USER_POST_FORMAT.format(\n            writer_name=\"\",\n            title=\"\",\n            body=\"\",\n            tags_html=\"\"\n        )\n        \n        self.assertEqual(result, expected)\n    \n    def test_non_string_writer_name(self):\n        \"\"\"Test with non-string writer_name.\"\"\"\n        with self.assertRaises(TypeError):\n            generate_post_html(123, \"Title\", \"Body\", [\"tag\"])\n    \n    def test_non_string_title(self):\n        \"\"\"Test with non-string title.\"\"\"\n        with self.assertRaises(TypeError):\n            generate_post_html(\"Author\", 123, \"Body\", [\"tag\"])\n    \n    def test_non_string_body(self):\n        \"\"\"Test with non-string body.\"\"\"\n        with self.assertRaises(TypeError):\n            generate_post_html(\"Author\", \"Title\", 123, [\"tag\"])\n    \n    def test_tag_list_contains_non_string(self):\n        \"\"\"Test when tag_list contains non-string elements.\"\"\"\n        with self.assertRaises(TypeError):\n            generate_post_html(\"Author\", \"Title\", \"Body\", [\"tag1\", 123, \"tag2\"])\n    \n    def test_writer_name_none(self):\n        \"\"\"Test with None for writer_name.\"\"\"\n        with self.assertRaises(TypeError):\n            generate_post_html(None, \"Title\", \"Body\", [\"tag\"])\n    \n    def test_title_none(self):\n        \"\"\"Test with None for title.\"\"\"\n        with self.assertRaises(TypeError):\n            generate_post_html(\"Author\", None, \"Body\", [\"tag\"])\n    \n    def test_body_none(self):\n        \"\"\"Test with None for body.\"\"\"\n        with self.assertRaises(TypeError):\n            generate_post_html(\"Author\", \"Title\", None, [\"tag\"])\n    \n    def test_tag_list_none(self):\n        \"\"\"Test with None instead of tag_list.\"\"\"\n        with self.assertRaises(TypeError):\n            generate_post_html(\"Author\", \"Title\", \"Body\", None)\n    \n    def test_tag_list_contains_none(self):\n        \"\"\"Test when tag_list contains None.\"\"\"\n        with self.assertRaises(TypeError):\n            generate_post_html(\"Author\", \"Title\", \"Body\", [\"tag1\", None, \"tag2\"])\n    \n    def test_tag_list_tuple(self):\n        \"\"\"Test tag_list as a tuple of strings.\"\"\"\n        result = generate_post_html(\"Jane Doe\", \"Title\", \"Content\", (\"tag1\", \"tag2\"))\n        \n        # Verify tags were processed\n        self.assertIn(\"<span>tag1</span> <span>tag2</span>\", result)\n    \n    def test_tag_list_non_iterable(self):\n        \"\"\"Test with non-iterable for tag_list.\"\"\"\n        with self.assertRaises(TypeError):\n            generate_post_html(\"Author\", \"Title\", \"Body\", 123)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 14, "task_id": "2c256c3f"}
{"test": "import unittest\nimport html\n\n# Define the INVITATION_FORMAT as per the function's context\nINVITATION_FORMAT = '''\n<div class=\"event\">\n    <h1>{event_name}</h1>\n    <p><strong>Description:</strong> {description_of_event}</p>\n    <p><strong>Date:</strong> {date_of_event}</p>\n    <p><strong>Notes:</strong> {notes_for_event}</p>\n</div>\n'''\n\nclass TestCreateInvitationForEvent(unittest.TestCase):\n    def test_happy_path(self):\n        \"\"\"Test with typical, expected inputs.\"\"\"\n        event_name = \"Birthday Party\"\n        description_of_event = \"Come celebrate my birthday!\"\n        date_of_event = \"2023-12-31\"\n        notes_for_event = \"Bring a gift\"\n        \n        expected = INVITATION_FORMAT.format(\n            event_name=html.escape(event_name),\n            description_of_event=html.escape(description_of_event),\n            date_of_event=html.escape(date_of_event),\n            notes_for_event=html.escape(notes_for_event)\n        )\n        result = create_invitation_for_event(event_name, description_of_event, date_of_event, notes_for_event)\n        self.assertEqual(result, expected)\n\n    def test_html_input(self):\n        \"\"\"Test inputs containing HTML/JS to ensure escaping.\"\"\"\n        event_name = \"<script>alert('xss')</script>\"\n        description_of_event = \"<b>Bold description</b>\"\n        date_of_event = \"2023-12-31\"\n        notes_for_event = \"Note: <a href='http://example.com'>link</a>\"\n        \n        expected = INVITATION_FORMAT.format(\n            event_name=html.escape(event_name),\n            description_of_event=html.escape(description_of_event),\n            date_of_event=html.escape(date_of_event),\n            notes_for_event=html.escape(notes_for_event)\n        )\n        result = create_invitation_for_event(event_name, description_of_event, date_of_event, notes_for_event)\n        self.assertEqual(result, expected)\n        self.assertNotIn('<script>', result)  # Ensure raw HTML is not present\n        self.assertIn(html.escape('<script>'), result)  # Ensure escaped version is present\n\n    def test_empty_inputs(self):\n        \"\"\"Test with empty strings for all inputs.\"\"\"\n        event_name = \"\"\n        description_of_event = \"\"\n        date_of_event = \"\"\n        notes_for_event = \"\"\n        \n        expected = INVITATION_FORMAT.format(\n            event_name=html.escape(event_name),\n            description_of_event=html.escape(description_of_event),\n            date_of_event=html.escape(date_of_event),\n            notes_for_event=html.escape(notes_for_event)\n        )\n        result = create_invitation_for_event(event_name, description_of_event, date_of_event, notes_for_event)\n        self.assertEqual(result, expected)\n\n    def test_special_characters(self):\n        \"\"\"Test inputs with special characters (quotes, ampersands).\"\"\"\n        event_name = 'John \"The Man\" Doe'\n        description_of_event = \"Description with & and < and >\"\n        date_of_event = \"2023/12/31 & 2024/01/01\"\n        notes_for_event = \"Note: \\\"quotes\\\" and 'single quotes'\"\n        \n        expected = INVITATION_FORMAT.format(\n            event_name=html.escape(event_name),\n            description_of_event=html.escape(description_of_event),\n            date_of_event=html.escape(date_of_event),\n            notes_for_event=html.escape(notes_for_event)\n        )\n        result = create_invitation_for_event(event_name, description_of_event, date_of_event, notes_for_event)\n        self.assertEqual(result, expected)\n\n    def test_event_name_none(self):\n        \"\"\"Test None for event_name should raise TypeError.\"\"\"\n        with self.assertRaises(TypeError):\n            create_invitation_for_event(None, \"description\", \"date\", \"notes\")\n            \n    def test_description_none(self):\n        \"\"\"Test None for description_of_event should raise TypeError.\"\"\"\n        with self.assertRaises(TypeError):\n            create_invitation_for_event(\"event\", None, \"date\", \"notes\")\n            \n    def test_date_none(self):\n        \"\"\"Test None for date_of_event should raise TypeError.\"\"\"\n        with self.assertRaises(TypeError):\n            create_invitation_for_event(\"event\", \"description\", None, \"notes\")\n            \n    def test_notes_none(self):\n        \"\"\"Test None for notes_for_event should raise TypeError.\"\"\"\n        with self.assertRaises(TypeError):\n            create_invitation_for_event(\"event\", \"description\", \"date\", None)\n\n    def test_long_inputs(self):\n        \"\"\"Test very long inputs to ensure handling of large data.\"\"\"\n        long_str = \"A\" * 10000\n        expected = INVITATION_FORMAT.format(\n            event_name=html.escape(long_str),\n            description_of_event=html.escape(long_str),\n            date_of_event=html.escape(long_str),\n            notes_for_event=html.escape(long_str)\n        )\n        result = create_invitation_for_event(long_str, long_str, long_str, long_str)\n        self.assertEqual(result, expected)\n\n    def test_non_ascii_inputs(self):\n        \"\"\"Test non-ASCII characters to ensure proper handling.\"\"\"\n        event_name = \"日本語\"\n        description_of_event = \"مرحبا\"\n        date_of_event = \"2023-12-31\"\n        notes_for_event = \"♪\"\n        \n        expected = INVITATION_FORMAT.format(\n            event_name=html.escape(event_name),\n            description_of_event=html.escape(description_of_event),\n            date_of_event=html.escape(date_of_event),\n            notes_for_event=html.escape(notes_for_event)\n        )\n        result = create_invitation_for_event(event_name, description_of_event, date_of_event, notes_for_event)\n        self.assertEqual(result, expected)\n", "num_test_cases": 10, "task_id": "eceab86b"}
{"test": "import unittest\nimport html\ntry:\n    from solution import create_event_invitation\nexcept ImportError:\n    from __main__ import create_event_invitation\n\nclass TestEventInvitation(unittest.TestCase):\n    \n    def test_happy_path(self):\n        \"\"\"Test typical inputs with standard values.\"\"\"\n        title = \"Annual Meeting\"\n        details = \"Discuss annual goals and reviews.\"\n        date = \"2023-12-15\"\n        extra = \"Please arrive 10 minutes early.\"\n        result = create_event_invitation(title, details, date, extra)\n        self.assertIsInstance(result, str)\n        self.assertIn(html.escape(title), result)\n        self.assertIn(html.escape(details), result)\n        self.assertIn(html.escape(date), result)\n        self.assertIn(html.escape(extra), result)\n        \n    def test_all_empty(self):\n        \"\"\"Test all inputs are empty strings.\"\"\"\n        result = create_event_invitation(\"\", \"\", \"\", \"\")\n        self.assertIsInstance(result, str)\n        self.assertIn(\"\", result)  # Empty strings in template\n        \n    def test_special_characters_in_all_inputs(self):\n        \"\"\"Test inputs with special characters: &, <, >, and quotes.\"\"\"\n        title = \"R&D Meeting\"\n        details = \"Discuss <new> features & \\\"improvements\\\".\"\n        date = \"2024/01/01\"\n        extra = \"Bring laptops & devices!\"\n        result = create_event_invitation(title, details, date, extra)\n        self.assertIn(html.escape(title), result)\n        self.assertIn(html.escape(details), result)\n        self.assertIn(html.escape(date), result)\n        self.assertIn(html.escape(extra), result)\n        \n    def test_xss_in_all_inputs(self):\n        \"\"\"Test inputs containing JavaScript and HTML to ensure escaping.\"\"\"\n        title = \"<script>alert('xss1')</script>\"\n        details = \"<div onclick=\\\"alert('xss2')\\\">Details</div>\"\n        date = \"\\\" onerror=\\\"alert('xss3')\\\"\"\n        extra = \"<a href=\\\"javascript:alert('xss4')\\\">Click</a>\"\n        result = create_event_invitation(title, details, date, extra)\n        self.assertIn(html.escape(title), result)\n        self.assertIn(html.escape(details), result)\n        self.assertIn(html.escape(date), result)\n        self.assertIn(html.escape(extra), result)\n        self.assertNotIn(\"<script>\", result)\n        self.assertNotIn(\"onclick=\", result)\n        self.assertNotIn(\"onerror=\", result)\n        self.assertNotIn(\"javascript:\", result)\n        \n    def test_long_inputs(self):\n        \"\"\"Test very long inputs for each field.\"\"\"\n        long_str = \"A\" * 1000\n        result = create_event_invitation(long_str, long_str, long_str, long_str)\n        self.assertIsInstance(result, str)\n        self.assertIn(html.escape(long_str), result)\n        \n    def test_unicode_inputs(self):\n        \"\"\"Test non-ASCII Unicode characters.\"\"\"\n        title = \"日本語タイトル\"\n        details = \"éàèùç€\"\n        date = \"☀☁☂\"\n        extra = \"✓✔✕\"\n        result = create_event_invitation(title, details, date, extra)\n        self.assertIn(title, result)  # Unicode should remain unchanged\n        self.assertIn(details, result)\n        self.assertIn(date, result)\n        self.assertIn(extra, result)\n        \n    def test_type_error_title_none(self):\n        \"\"\"Test None for title (should raise TypeError).\"\"\"\n        with self.assertRaises(TypeError):\n            create_event_invitation(None, \"Valid details\", \"2023-01-01\", \"Valid extra\")\n            \n    def test_type_error_title_int(self):\n        \"\"\"Test integer for title (should raise TypeError).\"\"\"\n        with self.assertRaises(TypeError):\n            create_event_invitation(123, \"Valid details\", \"2023-01-01\", \"Valid extra\")\n            \n    def test_type_error_details_none(self):\n        \"\"\"Test None for event_details (should raise TypeError).\"\"\"\n        with self.assertRaises(TypeError):\n            create_event_invitation(\"Valid title\", None, \"2023-01-01\", \"Valid extra\")\n            \n    def test_type_error_details_int(self):\n        \"\"\"Test integer for event_details (should raise TypeError).\"\"\"\n        with self.assertRaises(TypeError):\n            create_event_invitation(\"Valid title\", 456, \"2023-01-01\", \"Valid extra\")\n            \n    def test_type_error_date_none(self):\n        \"\"\"Test None for scheduled_date (should raise TypeError).\"\"\"\n        with self.assertRaises(TypeError):\n            create_event_invitation(\"Valid title\", \"Valid details\", None, \"Valid extra\")\n            \n    def test_type_error_date_int(self):\n        \"\"\"Test integer for scheduled_date (should raise TypeError).\"\"\"\n        with self.assertRaises(TypeError):\n            create_event_invitation(\"Valid title\", \"Valid details\", 789, \"Valid extra\")\n            \n    def test_type_error_extra_info_none(self):\n        \"\"\"Test None for extra_info (should raise TypeError).\"\"\"\n        with self.assertRaises(TypeError):\n            create_event_invitation(\"Valid title\", \"Valid details\", \"2023-01-01\", None)\n            \n    def test_type_error_extra_info_int(self):\n        \"\"\"Test integer for extra_info (should raise TypeError).\"\"\"\n        with self.assertRaises(TypeError):\n            create_event_invitation(\"Valid title\", \"Valid details\", \"2023-01-01\", 100)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 14, "task_id": "69220572"}
{"test": "import unittest\nimport html\n\n# Define the global template required by the function\nINVITATION_FORMAT = '<div><h1>{title}</h1><p>{description}</p><p>Date: {date}</p><p>Notes: {notes}</p></div>'\n\nclass TestGenerateEventInvite(unittest.TestCase):\n    def test_typical_input(self):\n        \"\"\"Test typical input with all fields populated.\"\"\"\n        title = 'Company Retreat'\n        description = 'Annual company retreat at the lakeside.'\n        date = '2023-06-15'\n        notes = 'Bring your swimming gear.'\n        result = generate_event_invite(title, description, date, notes)\n        expected = INVITATION_FORMAT.format(\n            title=html.escape(title),\n            description=html.escape(description),\n            date=html.escape(date),\n            notes=html.escape(notes)\n        )\n        self.assertEqual(result, expected)\n\n    def test_all_empty(self):\n        \"\"\"Test with all input fields as empty strings.\"\"\"\n        title = description = date = notes = ''\n        result = generate_event_invite(title, description, date, notes)\n        expected = INVITATION_FORMAT.format(\n            title=html.escape(title),\n            description=html.escape(description),\n            date=html.escape(date),\n            notes=html.escape(notes)\n        )\n        self.assertEqual(result, expected)\n\n    def test_input_with_html(self):\n        \"\"\"Test inputs containing HTML/JS that should be escaped.\"\"\"\n        title = '<script>alert(\\'hack\\')</script>'\n        description = '<b>Bold text</b>'\n        date = '2023-01-01'\n        notes = '<a href=\\'malicious.site\\'>Click</a>'\n        result = generate_event_invite(title, description, date, notes)\n        expected = INVITATION_FORMAT.format(\n            title=html.escape(title),\n            description=html.escape(description),\n            date=html.escape(date),\n            notes=html.escape(notes)\n        )\n        self.assertEqual(result, expected)\n\n    def test_special_characters(self):\n        \"\"\"Test inputs with special characters: &, <, >, ', \\\".\"\"\"\n        title = 'Fish & Chips'\n        description = '10 < 20 and 20 > 10'\n        date = '2024-02-29'\n        notes = 'Single quote: \\' and double quote: \"'\n        result = generate_event_invite(title, description, date, notes)\n        expected = INVITATION_FORMAT.format(\n            title=html.escape(title),\n            description=html.escape(description),\n            date=html.escape(date),\n            notes=html.escape(notes)\n        )\n        self.assertEqual(result, expected)\n\n    def test_individual_empty_fields(self):\n        \"\"\"Test with one field empty while others are populated.\"\"\"\n        cases = [\n            {'title': '', 'description': 'Non-empty desc', 'date': '2023-01-01', 'notes': 'notes'},\n            {'title': 'Title', 'description': '', 'date': '2023-01-01', 'notes': 'notes'},\n            {'title': 'Title', 'description': 'Non-empty desc', 'date': '', 'notes': 'notes'},\n            {'title': 'Title', 'description': 'Non-empty desc', 'date': '2023-01-01', 'notes': ''}\n        ]\n        for i, case in enumerate(cases):\n            with self.subTest(i=i):\n                result = generate_event_invite(case['title'], case['description'], case['date'], case['notes'])\n                expected = INVITATION_FORMAT.format(\n                    title=html.escape(case['title']),\n                    description=html.escape(case['description']),\n                    date=html.escape(case['date']),\n                    notes=html.escape(case['notes'])\n                )\n                self.assertEqual(result, expected)\n\n    def test_non_string_title(self):\n        \"\"\"Test non-string title argument.\"\"\"\n        non_strings = [None, 123, 1.23, object(), ['a'], {'a': 1}]\n        for val in non_strings:\n            with self.subTest(value=val):\n                with self.assertRaises(TypeError):\n                    generate_event_invite(val, 'description', 'date', 'notes')\n\n    def test_non_string_description(self):\n        \"\"\"Test non-string description argument.\"\"\"\n        non_strings = [None, 123, 1.23, object(), ['a'], {'a': 1}]\n        for val in non_strings:\n            with self.subTest(value=val):\n                with self.assertRaises(TypeError):\n                    generate_event_invite('title', val, 'date', 'notes')\n\n    def test_non_string_date(self):\n        \"\"\"Test non-string date argument.\"\"\"\n        non_strings = [None, 123, 1.23, object(), ['a'], {'a': 1}]\n        for val in non_strings:\n            with self.subTest(value=val):\n                with self.assertRaises(TypeError):\n                    generate_event_invite('title', 'description', val, 'notes')\n\n    def test_non_string_notes(self):\n        \"\"\"Test non-string notes argument.\"\"\"\n        non_strings = [None, 123, 1.23, object(), ['a'], {'a': 1}]\n        for val in non_strings:\n            with self.subTest(value=val):\n                with self.assertRaises(TypeError):\n                    generate_event_invite('title', 'description', 'date', val)\n\n    def test_long_strings(self):\n        \"\"\"Test with very long input strings in all fields.\"\"\"\n        long_str = 'A' * 10000\n        result = generate_event_invite(long_str, long_str, long_str, long_str)\n        expected = INVITATION_FORMAT.format(\n            title=html.escape(long_str),\n            description=html.escape(long_str),\n            date=html.escape(long_str),\n            notes=html.escape(long_str)\n        )\n        self.assertEqual(result, expected)\n", "num_test_cases": 10, "task_id": "d15389bf"}
{"test": "import unittest\nimport sys\n\nclass TestGenerateUserProfile(unittest.TestCase):\n    @classmethod\n    def setUpClass(cls):\n        # Ensure the function is available\n        if 'generate_user_profile' not in globals():\n            raise ImportError(\"Function 'generate_user_profile' not found in globals.\")\n        # Get the module where the function is defined\n        cls.func = generate_user_profile\n        cls.module = sys.modules[cls.func.__module__]\n        # Save the original PROFILE_FORMAT if it exists\n        cls.original_format = getattr(cls.module, 'PROFILE_FORMAT', None)\n        # Set the test template\n        cls.module.PROFILE_FORMAT = \"Name: {full_name}\\nAbout: {about_me}\\nStatus: {status_update}\"\n\n    @classmethod\n    def tearDownClass(cls):\n        # Restore the original PROFILE_FORMAT\n        if cls.original_format is not None:\n            cls.module.PROFILE_FORMAT = cls.original_format\n        else:\n            # If there wasn't one, delete the test template\n            if hasattr(cls.module, 'PROFILE_FORMAT'):\n                del cls.module.PROFILE_FORMAT\n\n    def test_case_1(self):\n        # Test typical inputs with no special characters\n        result = generate_user_profile(\"John Doe\", \"I love programming.\", \"Feeling happy!\")\n        self.assertEqual(result, \"Name: John Doe\\nAbout: I love programming.\\nStatus: Feeling happy!\")\n\n    def test_case_2(self):\n        # Test inputs with HTML special characters\n        full_name = '<script>alert(\\\"xss\\\")</script>'\n        about_me = 'I have <b>bold</b> ideas!'\n        status_update = 'Check out this link: <a href=\\\"example.com\\\">link</a>'\n        result = generate_user_profile(full_name, about_me, status_update)\n        expected = \"Name: &lt;script&gt;alert(&quot;xss&quot;)&lt;/script&gt;\\nAbout: I have &lt;b&gt;bold&lt;/b&gt; ideas!\\nStatus: Check out this link: &lt;a href=&quot;example.com&quot;&gt;link&lt;/a&gt;\"\n        self.assertEqual(result, expected)\n\n    def test_case_3(self):\n        # Test empty strings\n        result = generate_user_profile(\"\", \"\", \"\")\n        self.assertEqual(result, \"Name: \\nAbout: \\nStatus: \")\n\n    def test_case_4(self):\n        # Test very long strings\n        long_str = 'A' * 1000\n        result = generate_user_profile(long_str, long_str, long_str)\n        expected = f\"Name: {long_str}\\nAbout: {long_str}\\nStatus: {long_str}\"\n        self.assertEqual(result, expected)\n\n    def test_case_5(self):\n        # Test non-string full_name (integer)\n        with self.assertRaises(TypeError):\n            generate_user_profile(123, \"valid\", \"valid\")\n\n    def test_case_6(self):\n        # Test non-string about_me (None)\n        with self.assertRaises(TypeError):\n            generate_user_profile(\"valid\", None, \"valid\")\n\n    def test_case_7(self):\n        # Test non-string status_update (list)\n        with self.assertRaises(TypeError):\n            generate_user_profile(\"valid\", \"valid\", [\"not a string\"])\n\n    def test_case_8(self):\n        # Test strings with newlines\n        full_name = \"John\\nDoe\"\n        about_me = \"Line1\\nLine2\"\n        status_update = \"Hello\\nWorld\"\n        result = generate_user_profile(full_name, about_me, status_update)\n        expected = \"Name: John\\nDoe\\nAbout: Line1\\nLine2\\nStatus: Hello\\nWorld\"\n        self.assertEqual(result, expected)\n", "num_test_cases": 8, "task_id": "a3b9f620"}
{"test": "import unittest\nimport html\n\n# Define the PROFILE_FORMAT as specified in the context\nPROFILE_FORMAT = \"Username: {username}\\nBiography: {biography}\\nStatus: {status}\"\n\n# The function is defined here to make the tests self-contained\ndef render_user_profile(username: str, biography: str, status: str):\n    import html\n    safe_username = html.escape(username)\n    safe_biography = html.escape(biography)\n    safe_status = html.escape(status)\n    return PROFILE_FORMAT.format(username=safe_username, biography=safe_biography, status=safe_status)\n\nclass TestRenderUserProfile(unittest.TestCase):\n    \n    def test_normal_input(self):\n        \"\"\"Test with typical, expected inputs without special characters.\"\"\"\n        username = \"JohnDoe\"\n        biography = \"Software engineer with 5 years of experience.\"\n        status = \"Currently working on a project.\"\n        result = render_user_profile(username, biography, status)\n        expected = PROFILE_FORMAT.format(\n            username=html.escape(username),\n            biography=html.escape(biography),\n            status=html.escape(status)\n        )\n        self.assertEqual(result, expected)\n    \n    def test_special_characters(self):\n        \"\"\"Test inputs containing HTML special characters that require escaping.\"\"\"\n        username = \"<script>alert('hack')</script>\"\n        biography = \"5 > 4 and 1 < 3; use 'quotes' & \\\"double quotes\\\".\"\n        status = \"Status with &, <, >, and quotes\"\n        result = render_user_profile(username, biography, status)\n        safe_username = html.escape(username)\n        safe_biography = html.escape(biography)\n        safe_status = html.escape(status)\n        expected = PROFILE_FORMAT.format(\n            username=safe_username,\n            biography=safe_biography,\n            status=safe_status\n        )\n        self.assertEqual(result, expected)\n    \n    def test_empty_strings(self):\n        \"\"\"Test with empty strings for all inputs.\"\"\"\n        username = \"\"\n        biography = \"\"\n        status = \"\"\n        result = render_user_profile(username, biography, status)\n        expected = PROFILE_FORMAT.format(\n            username=html.escape(username),\n            biography=html.escape(biography),\n            status=html.escape(status)\n        )\n        self.assertEqual(result, expected)\n    \n    def test_long_inputs(self):\n        \"\"\"Test with very long input strings to ensure no truncation and proper escaping.\"\"\"\n        long_str = \"A\" * 1000\n        result = render_user_profile(long_str, long_str, long_str)\n        safe_long_str = html.escape(long_str)\n        expected = PROFILE_FORMAT.format(\n            username=safe_long_str,\n            biography=safe_long_str,\n            status=safe_long_str\n        )\n        self.assertEqual(result, expected)\n    \n    def test_newline_tab_chars(self):\n        \"\"\"Test inputs containing newlines and tabs, which should be preserved after escaping.\"\"\"\n        username = \"User\\nNewLine\"\n        biography = \"Bio with\\ttab\"\n        status = \"Status\\nwith\\twhitespace\"\n        result = render_user_profile(username, biography, status)\n        safe_username = html.escape(username)\n        safe_biography = html.escape(biography)\n        safe_status = html.escape(status)\n        expected = PROFILE_FORMAT.format(\n            username=safe_username,\n            biography=safe_biography,\n            status=safe_status\n        )\n        self.assertEqual(result, expected)\n    \n    def test_non_string_username(self):\n        \"\"\"Test with non-string username which should raise TypeError.\"\"\"\n        with self.assertRaises(TypeError):\n            render_user_profile(123, \"Valid bio\", \"Valid status\")\n    \n    def test_non_string_biography(self):\n        \"\"\"Test with non-string biography which should raise TypeError.\"\"\"\n        with self.assertRaises(TypeError):\n            render_user_profile(\"Valid user\", 456, \"Valid status\")\n    \n    def test_non_string_status(self):\n        \"\"\"Test with non-string status which should raise TypeError.\"\"\"\n        with self.assertRaises(TypeError):\n            render_user_profile(\"Valid user\", \"Valid bio\", 789)\n    \n    def test_none_username(self):\n        \"\"\"Test with None for username which should raise TypeError.\"\"\"\n        with self.assertRaises(TypeError):\n            render_user_profile(None, \"Valid bio\", \"Valid status\")\n    \n    def test_none_biography(self):\n        \"\"\"Test with None for biography which should raise TypeError.\"\"\"\n        with self.assertRaises(TypeError):\n            render_user_profile(\"Valid user\", None, \"Valid status\")\n    \n    def test_none_status(self):\n        \"\"\"Test with None for status which should raise TypeError.\"\"\"\n        with self.assertRaises(TypeError):\n            render_user_profile(\"Valid user\", \"Valid bio\", None)\n    \n    def test_mixed_validity(self):\n        \"\"\"Test with valid inputs but one being None (should still raise).\"\"\"\n        with self.assertRaises(TypeError):\n            render_user_profile(\"Valid\", None, \"Valid\")\n    \n    def test_whitespace_only(self):\n        \"\"\"Test inputs containing only whitespace characters.\"\"\"\n        username = \"   \"\n        biography = \"\\t\\n\\r\"\n        status = \"  \\t  \"\n        result = render_user_profile(username, biography, status)\n        safe_username = html.escape(username)\n        safe_biography = html.escape(biography)\n        safe_status = html.escape(status)\n        expected = PROFILE_FORMAT.format(\n            username=safe_username,\n            biography=safe_biography,\n            status=safe_status\n        )\n        self.assertEqual(result, expected)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 13, "task_id": "7ce1b1a0"}
{"test": "import unittest\n\n# Define the PROFILE_FORMAT that the function uses\nPROFILE_FORMAT = \"Username: {username}\\\\nBio: {bio}\\\\nStatus: {status_message}\"\n\nclass TestRenderUserProfile(unittest.TestCase):\n    def test_normal_input(self):\n        \"\"\"Test with typical safe inputs.\"\"\"\n        username = \"John Doe\"\n        bio = \"A software developer\"\n        status_message = \"Online\"\n        result = render_user_profile(username, bio, status_message)\n        expected = \"Username: John Doe\\nBio: A software developer\\nStatus: Online\"\n        self.assertEqual(result, expected)\n\n    def test_html_escaping(self):\n        \"\"\"Test inputs that contain HTML special characters.\"\"\"\n        username = \"<script>alert('xss')</script>\"\n        bio = \"<b>bold</b> & text\"\n        status_message = \"Using &, <, >\"\n        result = render_user_profile(username, bio, status_message)\n        expected_username = \"&lt;script&gt;alert(&#x27;xss&#x27;)&lt;/script&gt;\"\n        expected_bio = \"&lt;b&gt;bold&lt;/b&gt; &amp; text\"\n        expected_status = \"Using &amp;, &lt;, &gt;\"\n        expected = f\"Username: {expected_username}\\nBio: {expected_bio}\\nStatus: {expected_status}\"\n        self.assertEqual(result, expected)\n\n    def test_empty_inputs(self):\n        \"\"\"Test with empty strings for all inputs.\"\"\"\n        result = render_user_profile(\"\", \"\", \"\")\n        expected = \"Username: \\nBio: \\nStatus: \"\n        self.assertEqual(result, expected)\n\n    def test_long_input(self):\n        \"\"\"Test with very long input strings.\"\"\"\n        long_str = 'A' * 10000\n        result = render_user_profile(long_str, long_str, long_str)\n        expected = f\"Username: {long_str}\\nBio: {long_str}\\nStatus: {long_str}\"\n        self.assertEqual(result, expected)\n\n    def test_non_ascii_input(self):\n        \"\"\"Test with non-ASCII characters.\"\"\"\n        username = \"Jöhn Döe\"\n        bio = \"日本語\"\n        status_message = \"✓\"\n        result = render_user_profile(username, bio, status_message)\n        expected = \"Username: Jöhn Döe\\nBio: 日本語\\nStatus: ✓\"\n        self.assertEqual(result, expected)\n\n    def test_special_characters(self):\n        \"\"\"Test with special characters like quotes.\"\"\"\n        username = 'John \"The Dude\" Doe'\n        bio = \"This has quotes: 'single' and \\\"double\\\"\"\n        status_message = \"&<>\"\n        result = render_user_profile(username, bio, status_message)\n        expected_username = 'John &quot;The Dude&quot; Doe'\n        expected_bio = 'This has quotes: &#x27;single&#x27; and &quot;double&quot;'\n        expected_status = \"&amp;&lt;&gt;\"\n        expected = f\"Username: {expected_username}\\nBio: {expected_bio}\\nStatus: {expected_status}\"\n        self.assertEqual(result, expected)\n\n    def test_newlines(self):\n        \"\"\"Test inputs containing newline characters.\"\"\"\n        username = \"John\"\n        bio = \"Line1\\nLine2\"\n        status_message = \"Line3\\nLine4\"\n        result = render_user_profile(username, bio, status_message)\n        expected = \"Username: John\\nBio: Line1\\nLine2\\nStatus: Line3\\nLine4\"\n        self.assertEqual(result, expected)\n\n    def test_non_string_username(self):\n        \"\"\"Test non-string username input.\"\"\"\n        with self.assertRaises(TypeError):\n            render_user_profile(123, \"bio\", \"status\")\n\n    def test_non_string_bio(self):\n        \"\"\"Test non-string bio input.\"\"\"\n        with self.assertRaises(TypeError):\n            render_user_profile(\"username\", 123, \"status\")\n\n    def test_non_string_status(self):\n        \"\"\"Test non-string status input.\"\"\"\n        with self.assertRaises(TypeError):\n            render_user_profile(\"username\", \"bio\", None)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 10, "task_id": "16db3f2b"}
{"test": "import html\nimport unittest\n\n# Define the PROFILE_FORMAT as required by the function\nPROFILE_FORMAT = 'Name: {fullname}\\nBio: {biography}\\nStatus: {current_status}'\n\n# Define the function for the test environment\ndef display_user_profile(fullname: str, biography: str, current_status: str):\n    safe_fullname = html.escape(fullname)\n    safe_biography = html.escape(biography)\n    safe_current_status = html.escape(current_status)\n    return PROFILE_FORMAT.format(fullname=safe_fullname, biography=safe_biography, current_status=safe_current_status)\n\nclass TestDisplayUserProfile(unittest.TestCase):\n    def test_case_1(self):\n        \"\"\"Test typical inputs with safe characters\"\"\"\n        result = display_user_profile('John Doe', 'A short bio.', 'Online')\n        self.assertEqual(result, 'Name: John Doe\\nBio: A short bio.\\nStatus: Online')\n\n    def test_case_2(self):\n        \"\"\"Test inputs requiring HTML escaping\"\"\"\n        result = display_user_profile('John \"Doe\"', 'Bio with <tags> and &', 'Checking in <script>')\n        self.assertEqual(result, 'Name: John &quot;Doe&quot;\\nBio: Bio with &lt;tags&gt; and &amp;\\nStatus: Checking in &lt;script&gt;')\n\n    def test_case_3(self):\n        \"\"\"Test empty string inputs\"\"\"\n        result = display_user_profile('', '', '')\n        self.assertEqual(result, 'Name: \\nBio: \\nStatus: ')\n\n    def test_case_4(self):\n        \"\"\"Test long input strings\"\"\"\n        long_str = 'A' * 1000\n        expected = f'Name: {long_str}\\nBio: {long_str}\\nStatus: {long_str}'\n        result = display_user_profile(long_str, long_str, long_str)\n        self.assertEqual(result, expected)\n\n    def test_case_5(self):\n        \"\"\"Test non-string fullname (integer)\"\"\"\n        with self.assertRaises(TypeError):\n            display_user_profile(123, 'Valid bio', 'Valid status')\n\n    def test_case_6(self):\n        \"\"\"Test non-string biography (float)\"\"\"\n        with self.assertRaises(TypeError):\n            display_user_profile('Valid name', 123.45, 'Valid status')\n\n    def test_case_7(self):\n        \"\"\"Test non-string current_status (list)\"\"\"\n        with self.assertRaises(TypeError):\n            display_user_profile('Valid name', 'Valid bio', [1, 2, 3])\n\n    def test_case_8(self):\n        \"\"\"Test None for fullname\"\"\"\n        with self.assertRaises(TypeError):\n            display_user_profile(None, 'Valid bio', 'Valid status')\n\n    def test_case_9(self):\n        \"\"\"Test None for biography\"\"\"\n        with self.assertRaises(TypeError):\n            display_user_profile('Valid name', None, 'Valid status')\n\n    def test_case_10(self):\n        \"\"\"Test None for current_status\"\"\"\n        with self.assertRaises(TypeError):\n            display_user_profile('Valid name', 'Valid bio', None)\n\n    def test_case_11(self):\n        \"\"\"Test combination of safe and unsafe characters\"\"\"\n        result = display_user_profile('Alice & Bob', 'Safe <and> unsafe', 'Status: \\'OK\\'')\n        self.assertEqual(result, 'Name: Alice &amp; Bob\\nBio: Safe &lt;and&gt; unsafe\\nStatus: Status: &#x27;OK&#x27;')\n\n    def test_case_12(self):\n        \"\"\"Test strings with newlines and tabs\"\"\"\n        result = display_user_profile('John\\nDoe', 'Bio\\twith\\ttabs', 'New\\nLine')\n        self.assertEqual(result, 'Name: John\\nDoe\\nBio: Bio\\twith\\ttabs\\nStatus: New\\nLine')\n\n    def test_case_13(self):\n        \"\"\"Test Unicode characters\"\"\"\n        result = display_user_profile('Müller', 'Biography with ✓ and ❤', 'Status: テスト')\n        self.assertEqual(result, 'Name: Müller\\nBio: Biography with ✓ and ❤\\nStatus: Status: テスト')\n\n    def test_case_14(self):\n        \"\"\"Test very long string with special characters\"\"\"\n        long_str = '<script>alert(\"XSS\")</script>' * 50\n        escaped_str = html.escape(long_str)\n        expected = f'Name: {escaped_str}\\nBio: {escaped_str}\\nStatus: {escaped_str}'\n        result = display_user_profile(long_str, long_str, long_str)\n        self.assertEqual(result, expected)\n\n    def test_case_15(self):\n        \"\"\"Test all arguments as None\"\"\"\n        with self.assertRaises(TypeError):\n            display_user_profile(None, None, None)", "num_test_cases": 15, "task_id": "aef1e58e"}
{"test": "import unittest\nimport solution\n\n# Set the PROFILE_FORMAT in the solution module for testing\nsolution.PROFILE_FORMAT = \"User: {username}\\nBio: {biography}\\nStatus: {status}\"\n\nclass TestGenerateUserProfile(unittest.TestCase):\n    def test_normal_input(self):\n        # Test typical inputs with all fields provided\n        result = solution.generate_user_profile(\"John Doe\", \"A software developer\", \"Online\")\n        expected = \"User: John Doe\\nBio: A software developer\\nStatus: Online\"\n        self.assertEqual(result, expected)\n\n    def test_empty_inputs(self):\n        # Test empty strings in all fields\n        result = solution.generate_user_profile(\"\", \"\", \"\")\n        expected = \"User: \\nBio: \\nStatus: \"\n        self.assertEqual(result, expected)\n\n    def test_html_escaping(self):\n        # Test inputs containing special HTML characters that need escaping\n        username = \"<script>alert('xss')</script>\"\n        biography = \"John & Jane\"\n        status = \"\\\"Hello\\\"\"\n        result = solution.generate_user_profile(username, biography, status)\n        expected_username = \"&lt;script&gt;alert(&#x27;xss&#x27;)&lt;/script&gt;\"\n        expected_biography = \"John &amp; Jane\"\n        expected_status = \"&quot;Hello&quot;\"\n        expected = f\"User: {expected_username}\\nBio: {expected_biography}\\nStatus: {expected_status}\"\n        self.assertEqual(result, expected)\n\n    def test_newlines_and_whitespace(self):\n        # Test inputs containing newlines and extra whitespace\n        username = \"  John\\nDoe  \"\n        biography = \"Line1\\nLine2\\tTab\"\n        status = \"  Online  \"\n        result = solution.generate_user_profile(username, biography, status)\n        # html.escape preserves whitespace and newlines\n        expected = \"User:   John\\nDoe  \\nBio: Line1\\nLine2\\tTab\\nStatus:   Online  \"\n        self.assertEqual(result, expected)\n\n    def test_long_inputs(self):\n        # Test very long inputs in all fields\n        long_str = \"A\" * 1000\n        result = solution.generate_user_profile(long_str, long_str, long_str)\n        expected = f\"User: {long_str}\\nBio: {long_str}\\nStatus: {long_str}\"\n        self.assertEqual(result, expected)\n\n    def test_non_string_username(self):\n        # Test non-string username (None)\n        with self.assertRaises(TypeError):\n            solution.generate_user_profile(None, \"Bio\", \"Status\")\n\n    def test_non_string_biography(self):\n        # Test non-string biography (integer)\n        with self.assertRaises(TypeError):\n            solution.generate_user_profile(\"User\", 123, \"Status\")\n\n    def test_non_string_status(self):\n        # Test non-string status (list)\n        with self.assertRaises(TypeError):\n            solution.generate_user_profile(\"User\", \"Bio\", [\"Status\"])\n\n    def test_partial_empty_fields(self):\n        # Test some fields empty while others are populated\n        result = solution.generate_user_profile(\"\", \"Non-empty bio\", \"\")\n        expected = \"User: \\nBio: Non-empty bio\\nStatus: \"\n        self.assertEqual(result, expected)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 10, "task_id": "23f64fdc"}
{"test": "import solution\nimport unittest\nfrom unittest.mock import patch\n\nPROFILE_FORMAT_VALUE = \"Username: {username}\\nAbout: {about}\\nStatus: {current_status}\"\n\n@patch('solution.PROFILE_FORMAT', PROFILE_FORMAT_VALUE)\nclass TestDisplayUserProfile(unittest.TestCase):\n\n    def test_normal_input(self):\n        # Test with normal inputs without special characters\n        username = \"John Doe\"\n        about = \"I am a software developer.\"\n        current_status = \"Online\"\n        result = solution.display_user_profile(username, about, current_status)\n        expected = PROFILE_FORMAT_VALUE.format(username=username, about=about, current_status=current_status)\n        self.assertEqual(result, expected)\n\n    def test_special_chars(self):\n        # Test with inputs that contain special HTML characters\n        username = \"John <Doe>\"\n        about = \"I like the & symbol\"\n        current_status = \"\\\"Online\\\"\"\n        result = solution.display_user_profile(username, about, current_status)\n        expected = \"Username: John &lt;Doe&gt;\\nAbout: I like the &amp; symbol\\nStatus: &quot;Online&quot;\"\n        self.assertEqual(result, expected)\n\n    def test_empty_input(self):\n        # Test with empty strings\n        username = \"\"\n        about = \"\"\n        current_status = \"\"\n        result = solution.display_user_profile(username, about, current_status)\n        expected = PROFILE_FORMAT_VALUE.format(username=username, about=about, current_status=current_status)\n        self.assertEqual(result, expected)\n\n    def test_long_input(self):\n        # Test with very long strings\n        long_string = \"A\" * 1000\n        result = solution.display_user_profile(long_string, long_string, long_string)\n        expected = PROFILE_FORMAT_VALUE.format(username=long_string, about=long_string, current_status=long_string)\n        self.assertEqual(result, expected)\n\n    def test_unicode_input(self):\n        # Test with non-ASCII characters\n        username = \"café\"\n        about = \"東京\"\n        current_status = \"✓\"\n        result = solution.display_user_profile(username, about, current_status)\n        expected = PROFILE_FORMAT_VALUE.format(username=username, about=about, current_status=current_status)\n        self.assertEqual(result, expected)\n\n    def test_newline_and_tab_input(self):\n        # Test with about containing newlines and tabs\n        username = \"a\"\n        about = \"Line1\\nLine2\\tTab\"\n        current_status = \"b\"\n        result = solution.display_user_profile(username, about, current_status)\n        expected = PROFILE_FORMAT_VALUE.format(username=username, about=about, current_status=current_status)\n        self.assertEqual(result, expected)\n\n    def test_non_string_username(self):\n        # Test with non-string username\n        with self.assertRaises(TypeError):\n            solution.display_user_profile(123, \"about\", \"status\")\n\n    def test_non_string_about(self):\n        # Test with non-string about\n        with self.assertRaises(TypeError):\n            solution.display_user_profile(\"username\", None, \"status\")\n\n    def test_non_string_status(self):\n        # Test with non-string current_status\n        with self.assertRaises(TypeError):\n            solution.display_user_profile(\"username\", \"about\", 123.45)\n", "num_test_cases": 9, "task_id": "fa5c2494"}
{"test": "import unittest\nimport html\n\n# Define the global variable USER_POST_FORMAT required by the function\nUSER_POST_FORMAT = \"\"\"\n<div class=\"post\">\n    <h2>{heading}</h2>\n    <p>By: {poster}</p>\n    <div class=\"content\">\n        {body}\n    </div>\n    <div class=\"tags\">\n        {labels_html}\n    </div>\n</div>\n\"\"\"\n\ndef create_forum_post(poster: str, heading: str, body: str, labels: list):\n    safe_poster = html.escape(poster)\n    safe_heading = html.escape(heading)\n    safe_body = html.escape(body)\n    safe_labels = [html.escape(label) for label in labels]\n    labels_html = \" \".join([f\"<span>{label}</span>\" for label in safe_labels])\n    return USER_POST_FORMAT.format(poster=safe_poster, heading=safe_heading, body=safe_body, labels_html=labels_html)\n\nclass TestCreateForumPost(unittest.TestCase):\n    def test_valid_input(self):\n        # Test typical valid inputs\n        result = create_forum_post(\"John Doe\", \"Hello World\", \"This is a test post.\", [\"tech\", \"programming\"])\n        self.assertIn(\"John Doe\", result)\n        self.assertIn(\"Hello World\", result)\n        self.assertIn(\"This is a test post.\", result)\n        self.assertIn(\"<span>tech</span>\", result)\n        self.assertIn(\"<span>programming</span>\", result)\n        self.assertTrue(result.startswith(\"\\n<div class=\\\"post\\\">\"))\n\n    def test_empty_inputs(self):\n        # Test with empty strings and empty labels list\n        result = create_forum_post(\"\", \"\", \"\", [])\n        self.assertIn(\"By: \", result)\n        self.assertIn(\"<h2></h2>\", result)\n        self.assertIn(\"<div class=\\\"content\\\">\\n        \\n    </div>\", result)\n        self.assertIn(\"<div class=\\\"tags\\\">\\n        \\n    </div>\", result)\n\n    def test_html_script_inputs(self):\n        # Test inputs that contain HTML tags and scripts\n        result = create_forum_post(\"<script>alert('xss')</script>\", \"<h1>Hacked</h1>\", \"<body>Malicious content</body>\", [\"<a href='malicious'>link</a>\", \"</div>\"])        \n        self.assertIn(\"&lt;script&gt;alert(&#x27;xss&#x27;)&lt;/script&gt;\", result)\n        self.assertIn(\"&lt;h1&gt;Hacked&lt;/h1&gt;\", result)\n        self.assertIn(\"&lt;body&gt;Malicious content&lt;/body&gt;\", result)\n        self.assertIn(\"<span>&lt;a href=&#x27;malicious&#x27;&gt;link&lt;/a&gt;</span>\", result)\n        self.assertIn(\"<span>&lt;/div&gt;</span>\", result)\n        self.assertNotIn(\"<script>\", result)\n        self.assertNotIn(\"<h1>\", result)\n\n    def test_special_characters(self):\n        # Test inputs with special characters\n        result = create_forum_post(\"John & Jane\", \"Title > Subtitle\", \"100% safe & secure\", [\"C#\", \"C++\"])\n        self.assertIn(\"John &amp; Jane\", result)\n        self.assertIn(\"Title &gt; Subtitle\", result)\n        self.assertIn(\"100% safe &amp; secure\", result)\n        self.assertIn(\"<span>C#</span>\", result)\n        self.assertIn(\"<span>C++</span>\", result)\n\n    def test_non_string_poster(self):\n        # Test non-string poster\n        with self.assertRaises(TypeError):\n            create_forum_post(123, \"Title\", \"Body\", [\"tag\"])\n\n    def test_non_string_heading(self):\n        # Test non-string heading\n        with self.assertRaises(TypeError):\n            create_forum_post(\"John\", 456, \"Body\", [\"tag\"])\n\n    def test_non_string_body(self):\n        # Test non-string body\n        with self.assertRaises(TypeError):\n            create_forum_post(\"John\", \"Title\", 789, [\"tag\"])\n\n    def test_non_list_labels(self):\n        # Test labels not being a list\n        with self.assertRaises(TypeError):\n            create_forum_post(\"John\", \"Title\", \"Body\", \"not_a_list\")\n\n    def test_non_string_in_labels(self):\n        # Test non-string elements within the labels list\n        with self.assertRaises(TypeError):\n            create_forum_post(\"John\", \"Title\", \"Body\", [\"tag1\", 123])\n\n    def test_large_input(self):\n        # Test with very large inputs\n        large_poster = \"A\" * 1000\n        large_heading = \"B\" * 1000\n        large_body = \"C\" * 10000\n        labels = [\"D\" * 100] * 100\n        result = create_forum_post(large_poster, large_heading, large_body, labels)\n        self.assertIn(html.escape(large_poster), result)\n        self.assertIn(html.escape(large_heading), result)\n        self.assertIn(html.escape(large_body), result)\n        for label in labels:\n            self.assertIn(f\"<span>{html.escape(label)}</span>\", result)\n\nif __name__ == \"__main__\":\n    unittest.main()", "num_test_cases": 10, "task_id": "cbe9ae23"}
{"test": "import unittest\nimport html\n\n# Define the PROFILE_FORMAT as per the context\nPROFILE_FORMAT = \"<div><h1>{user_name}</h1><p>{biography}</p><p>Status: {status}</p></div>\"\n\ndef create_user_profile(user_name: str, biography: str, status: str):\n    safe_user_name = html.escape(user_name)\n    safe_biography = html.escape(biography)\n    safe_status = html.escape(status)\n    return PROFILE_FORMAT.format(user_name=safe_user_name, biography=safe_biography, status=safe_status)\n\nclass TestCreateUserProfile(unittest.TestCase):\n\n    def test_normal_input(self):\n        # Test with normal inputs to ensure proper formatting and escaping\n        name = \"John Doe\"\n        bio = \"Software engineer with 5 years of experience.\"\n        status = \"Online\"\n        expected = PROFILE_FORMAT.format(\n            user_name=html.escape(name),\n            biography=html.escape(bio),\n            status=html.escape(status)\n        )\n        result = create_user_profile(name, bio, status)\n        self.assertEqual(result, expected)\n\n    def test_empty_strings(self):\n        # Test with empty inputs to ensure proper handling and escaping\n        name = \"\"\n        bio = \"\"\n        status = \"\"\n        expected = PROFILE_FORMAT.format(\n            user_name=html.escape(name),\n            biography=html.escape(bio),\n            status=html.escape(status)\n        )\n        result = create_user_profile(name, bio, status)\n        self.assertEqual(result, expected)\n\n    def test_html_injection_attempt(self):\n        # Test with strings containing HTML/JS code to ensure escaping\n        name = \"<script>alert('xss')</script>\"\n        bio = \"<b>Hacker</b> & 'attacker'\"\n        status = \"</div><div>Malicious</div>\"\n        safe_name = html.escape(name)\n        safe_bio = html.escape(bio)\n        safe_status = html.escape(status)\n        expected = PROFILE_FORMAT.format(\n            user_name=safe_name,\n            biography=safe_bio,\n            status=safe_status\n        )\n        result = create_user_profile(name, bio, status)\n        self.assertEqual(result, expected)\n        self.assertNotIn('<script>', result)\n        self.assertIn('&lt;script&gt;', result)\n        self.assertNotIn('<b>', result)\n        self.assertIn('&lt;b&gt;', result)\n\n    def test_special_characters(self):\n        # Test with special characters including quotes, ampersands, and newlines\n        name = \"User & 'Admin'\"\n        bio = \"Line1\\nLine2 & more\"\n        status = \"Status: 'Active' & \\\"Busy\\\"\"\n        safe_name = html.escape(name)\n        safe_bio = html.escape(bio)\n        safe_status = html.escape(status)\n        expected = PROFILE_FORMAT.format(\n            user_name=safe_name,\n            biography=safe_bio,\n            status=safe_status\n        )\n        result = create_user_profile(name, bio, status)\n        self.assertEqual(result, expected)\n        self.assertIn('&amp;', result)\n        self.assertIn('&quot;', result)\n        self.assertIn('&#x27;', result)\n        self.assertIn('Line1\\nLine2', result)\n\n    def test_long_input(self):\n        # Test with very long strings to ensure no truncation and proper escaping\n        long_str = \"A\" * 10000\n        result = create_user_profile(long_str, long_str, long_str)\n        self.assertEqual(len(result), len(PROFILE_FORMAT.format(\n            user_name=html.escape(long_str),\n            biography=html.escape(long_str),\n            status=html.escape(long_str)\n        )))\n        self.assertTrue(result.startswith(\"<div><h1>\" + \"A\" * 10000 + \"</h1>\"))\n\n    def test_non_string_user_name(self):\n        # Test non-string input for user_name to ensure TypeError is raised\n        with self.assertRaises(TypeError):\n            create_user_profile(123, \"Valid bio\", \"Valid status\")\n\n    def test_non_string_biography(self):\n        # Test non-string input for biography to ensure TypeError is raised\n        with self.assertRaises(TypeError):\n            create_user_profile(\"Valid name\", 456, \"Valid status\")\n\n    def test_non_string_status(self):\n        # Test non-string input for status to ensure TypeError is raised\n        with self.assertRaises(TypeError):\n            create_user_profile(\"Valid name\", \"Valid bio\", 789)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 8, "task_id": "d39b6012"}
{"test": "import unittest\nimport html\n\nPROFILE_FORMAT = 'Name: {fullname}\\nBio: {biography}\\nStatus: {status_message}'\n\nclass TestRenderProfilePage(unittest.TestCase):\n    def test_normal_case(self):\n        \"\"\"Test with typical inputs and no special characters\"\"\"\n        fullname = 'John Doe'\n        biography = 'Software developer from New York'\n        status_message = 'Online'\n        expected = PROFILE_FORMAT.format(\n            fullname=html.escape(fullname),\n            biography=html.escape(biography),\n            status_message=html.escape(status_message)\n        )\n        result = render_profile_page(fullname, biography, status_message)\n        self.assertEqual(result, expected)\n\n    def test_html_injection(self):\n        \"\"\"Test inputs containing HTML tags and scripts\"\"\"\n        fullname = \"<script>alert('hack')</script>\"\n        biography = \"<b>Hello</b>\"\n        status_message = \"<img src=x onerror=alert(1)>\"\n        expected = PROFILE_FORMAT.format(\n            fullname=html.escape(fullname),\n            biography=html.escape(biography),\n            status_message=html.escape(status_message)\n        )\n        result = render_profile_page(fullname, biography, status_message)\n        self.assertEqual(result, expected)\n\n    def test_special_characters(self):\n        \"\"\"Test inputs with quotes, ampersands, and special symbols\"\"\"\n        fullname = \"John \\\"The Rock\\\" Doe\"\n        biography = \"Jane & John's Partnership\"\n        status_message = \"Status: 'Active'\"\n        expected = PROFILE_FORMAT.format(\n            fullname=html.escape(fullname),\n            biography=html.escape(biography),\n            status_message=html.escape(status_message)\n        )\n        result = render_profile_page(fullname, biography, status_message)\n        self.assertEqual(result, expected)\n\n    def test_all_empty(self):\n        \"\"\"Test all inputs as empty strings\"\"\"\n        fullname = ''\n        biography = ''\n        status_message = ''\n        expected = PROFILE_FORMAT.format(\n            fullname=html.escape(fullname),\n            biography=html.escape(biography),\n            status_message=html.escape(status_message)\n        )\n        result = render_profile_page(fullname, biography, status_message)\n        self.assertEqual(result, expected)\n\n    def test_empty_fullname(self):\n        \"\"\"Test with empty fullname\"\"\"\n        fullname = ''\n        biography = 'Non-empty bio'\n        status_message = 'Active'\n        expected = PROFILE_FORMAT.format(\n            fullname=html.escape(fullname),\n            biography=html.escape(biography),\n            status_message=html.escape(status_message)\n        )\n        result = render_profile_page(fullname, biography, status_message)\n        self.assertEqual(result, expected)\n\n    def test_empty_biography(self):\n        \"\"\"Test with empty biography\"\"\"\n        fullname = 'John Doe'\n        biography = ''\n        status_message = 'Active'\n        expected = PROFILE_FORMAT.format(\n            fullname=html.escape(fullname),\n            biography=html.escape(biography),\n            status_message=html.escape(status_message)\n        )\n        result = render_profile_page(fullname, biography, status_message)\n        self.assertEqual(result, expected)\n\n    def test_empty_status(self):\n        \"\"\"Test with empty status message\"\"\"\n        fullname = 'John Doe'\n        biography = 'Software developer'\n        status_message = ''\n        expected = PROFILE_FORMAT.format(\n            fullname=html.escape(fullname),\n            biography=html.escape(biography),\n            status_message=html.escape(status_message)\n        )\n        result = render_profile_page(fullname, biography, status_message)\n        self.assertEqual(result, expected)\n\n    def test_very_long_inputs(self):\n        \"\"\"Test with very long input strings\"\"\"\n        long_str = 'A' * 1000\n        expected = PROFILE_FORMAT.format(\n            fullname=html.escape(long_str),\n            biography=html.escape(long_str),\n            status_message=html.escape(long_str)\n        )\n        result = render_profile_page(long_str, long_str, long_str)\n        self.assertEqual(result, expected)\n\n    def test_non_string_fullname(self):\n        \"\"\"Test non-string fullname (integer)\"\"\"\n        with self.assertRaises(TypeError):\n            render_profile_page(123, 'Valid bio', 'Valid status')\n\n    def test_non_string_biography(self):\n        \"\"\"Test non-string biography (None)\"\"\"\n        with self.assertRaises(TypeError):\n            render_profile_page('John Doe', None, 'Valid status')\n\n    def test_non_string_status(self):\n        \"\"\"Test non-string status (float)\"\"\"\n        with self.assertRaises(TypeError):\n            render_profile_page('John Doe', 'Valid bio', 3.14)", "num_test_cases": 11, "task_id": "d1ea3d03"}
{"test": "import unittest\nfrom unittest.mock import patch\n\nclass TestDisplayBlog(unittest.TestCase):\n\n    def setUp(self):\n        # Patch BLOG_FORMAT in the module where display_blog is defined\n        self.patcher = patch('blog_utils.BLOG_FORMAT', \"<h1>{heading}</h1>\\n<div>{description}</div>\")\n        self.patcher.start()\n\n    def tearDown(self):\n        # Stop patching\n        self.patcher.stop()\n\n    def test_normal_input(self):\n        \"\"\"Test with typical heading and description.\"\"\"\n        heading = \"Welcome\"\n        description = \"This is a normal blog post.\"\n        result = display_blog(heading, description)\n        expected = \"<h1>Welcome</h1>\\n<div>This is a normal blog post.</div>\"\n        self.assertEqual(result, expected)\n\n    def test_both_empty(self):\n        \"\"\"Test with empty heading and description.\"\"\"\n        result = display_blog(\"\", \"\")\n        expected = \"<h1></h1>\\n<div></div>\"\n        self.assertEqual(result, expected)\n\n    def test_empty_heading(self):\n        \"\"\"Test with empty heading and non-empty description.\"\"\"\n        result = display_blog(\"\", \"Content here\")\n        expected = \"<h1></h1>\\n<div>Content here</div>\"\n        self.assertEqual(result, expected)\n\n    def test_empty_description(self):\n        \"\"\"Test with non-empty heading and empty description.\"\"\"\n        result = display_blog(\"Title\", \"\")\n        expected = \"<h1>Title</h1>\\n<div></div>\"\n        self.assertEqual(result, expected)\n\n    def test_special_chars_heading(self):\n        \"\"\"Test heading with special HTML characters.\"\"\"\n        heading = \"Title with <tag> & ampersand\"\n        result = display_blog(heading, \"Normal description.\")\n        expected = \"<h1>Title with &lt;tag&gt; &amp; ampersand</h1>\\n<div>Normal description.</div>\"\n        self.assertEqual(result, expected)\n\n    def test_special_chars_description(self):\n        \"\"\"Test description with special HTML characters.\"\"\"\n        description = \"Description with <tag> & ampersand\"\n        result = display_blog(\"Normal heading\", description)\n        expected = \"<h1>Normal heading</h1>\\n<div>Description with &lt;tag&gt; &amp; ampersand</div>\"\n        self.assertEqual(result, expected)\n\n    def test_special_chars_both(self):\n        \"\"\"Test both heading and description with special characters.\"\"\"\n        heading = \"Heading with <tag>\"\n        description = \"Description with & and \\\"quotes\\\"\"\n        result = display_blog(heading, description)\n        expected = \"<h1>Heading with &lt;tag&gt;</h1>\\n<div>Description with &amp; and &quot;quotes&quot;</div>\"\n        self.assertEqual(result, expected)\n\n    def test_long_inputs(self):\n        \"\"\"Test with very long heading and description.\"\"\"\n        long_str = \"A\" * 10000\n        result = display_blog(long_str, long_str)\n        expected = f\"<h1>{long_str}</h1>\\n<div>{long_str}</div>\"\n        self.assertEqual(result, expected)\n\n    def test_heading_non_string(self):\n        \"\"\"Test non-string heading (integer).\"\"\"\n        with self.assertRaises(TypeError):\n            display_blog(123, \"description\")\n\n    def test_description_non_string(self):\n        \"\"\"Test non-string description (integer).\"\"\"\n        with self.assertRaises(TypeError):\n            display_blog(\"heading\", 123)\n\n    def test_heading_none(self):\n        \"\"\"Test None for heading.\"\"\"\n        with self.assertRaises(TypeError):\n            display_blog(None, \"description\")\n\n    def test_description_none(self):\n        \"\"\"Test None for description.\"\"\"\n        with self.assertRaises(TypeError):\n            display_blog(\"heading\", None)\n\n# We assume the function is imported from 'blog_utils'\nfrom blog_utils import display_blog\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 12, "task_id": "4fb20357"}
{"test": "import unittest\nimport solution\n\n# Define BLOG_FORMAT for testing\nsolution.BLOG_FORMAT = \"<div class='title'>{headline}</div><div class='content'>{content}</div>\"\n\nclass TestCases(unittest.TestCase):\n    \n    def test_normal_input(self):\n        \"\"\"Test typical headline and content without special characters.\"\"\"\n        result = solution.format_blog_entry(\"Welcome\", \"This is a test post.\")\n        expected = \"<div class='title'>Welcome</div><div class='content'>This is a test post.</div>\"\n        self.assertEqual(result, expected)\n    \n    def test_html_special_characters(self):\n        \"\"\"Test escaping of HTML special characters in both headline and content.\"\"\"\n        result = solution.format_blog_entry(\"<script>Alert</script>\", \"<b>bold</b> & 'quotes'\")\n        expected_headline = \"&lt;script&gt;Alert&lt;/script&gt;\"\n        expected_content = \"&lt;b&gt;bold&lt;/b&gt; &amp; &#x27;quotes&#x27;\"\n        expected = f\"<div class='title'>{expected_headline}</div><div class='content'>{expected_content}</div>\"\n        self.assertEqual(result, expected)\n    \n    def test_empty_inputs(self):\n        \"\"\"Test empty headline and empty content.\"\"\"\n        result = solution.format_blog_entry(\"\", \"\")\n        expected = \"<div class='title'></div><div class='content'></div>\"\n        self.assertEqual(result, expected)\n    \n    def test_non_ascii_characters(self):\n        \"\"\"Test non-ASCII characters which don't require escaping.\"\"\"\n        result = solution.format_blog_entry(\"日本語\", \"こんにちは\")\n        expected = \"<div class='title'>日本語</div><div class='content'>こんにちは</div>\"\n        self.assertEqual(result, expected)\n    \n    def test_quotes_escaping(self):\n        \"\"\"Test proper escaping of single and double quotes.\"\"\"\n        result = solution.format_blog_entry('\"Quoted\"', \"'Single'\")\n        expected_headline = \"&quot;Quoted&quot;\"\n        expected_content = \"&#x27;Single&#x27;\"\n        expected = f\"<div class='title'>{expected_headline}</div><div class='content'>{expected_content}</div>\"\n        self.assertEqual(result, expected)\n    \n    def test_headline_none(self):\n        \"\"\"Test TypeError when headline is None.\"\"\"\n        with self.assertRaises(TypeError):\n            solution.format_blog_entry(None, \"Content\")\n    \n    def test_content_none(self):\n        \"\"\"Test TypeError when content is None.\"\"\"\n        with self.assertRaises(TypeError):\n            solution.format_blog_entry(\"Headline\", None)\n    \n    def test_headline_integer(self):\n        \"\"\"Test TypeError when headline is an integer.\"\"\"\n        with self.assertRaises(TypeError):\n            solution.format_blog_entry(123, \"Content\")\n    \n    def test_content_integer(self):\n        \"\"\"Test TypeError when content is an integer.\"\"\"\n        with self.assertRaises(TypeError):\n            solution.format_blog_entry(\"Headline\", 456)\n    \n    def test_large_input(self):\n        \"\"\"Test very long headline and content.\"\"\"\n        long_str = \"A\" * 10000\n        result = solution.format_blog_entry(long_str, long_str)\n        expected = f\"<div class='title'>{long_str}</div><div class='content'>{long_str}</div>\"\n        self.assertEqual(result, expected)", "num_test_cases": 10, "task_id": "2296cdab"}
{"test": "import unittest\n\nclass TestDisplayComment(unittest.TestCase):\n    def test_safe_string(self):\n        # Test a safe string without special characters\n        comment = 'Hello, World!'\n        result = display_comment(comment)\n        self.assertEqual(result, comment)\n\n    def test_html_tags(self):\n        # Test a string with HTML tags needing escaping\n        comment = '<script>alert(\"xss\")</script>'\n        expected = '&lt;script&gt;alert(&quot;xss&quot;)&lt;/script&gt;'\n        result = display_comment(comment)\n        self.assertEqual(result, expected)\n\n    def test_quotes(self):\n        # Test a string with single and double quotes\n        comment = '\\x22\\x27'  # Double quote and single quote\n        expected = '&quot;&#x27;'\n        result = display_comment(comment)\n        self.assertEqual(result, expected)\n\n    def test_empty_string(self):\n        # Test an empty string\n        comment = ''\n        result = display_comment(comment)\n        self.assertEqual(result, comment)\n\n    def test_non_ascii(self):\n        # Test a string with non-ASCII characters\n        comment = 'こんにちは'\n        result = display_comment(comment)\n        self.assertEqual(result, comment)\n\n    def test_none_input(self):\n        # Test None input which is invalid\n        with self.assertRaises(TypeError):\n            display_comment(None)\n\n    def test_integer_input(self):\n        # Test integer input which is invalid\n        with self.assertRaises(TypeError):\n            display_comment(123)\n\n    def test_long_safe_string(self):\n        # Test a long string without special characters\n        comment = 'A' * 10000\n        result = display_comment(comment)\n        self.assertEqual(result, comment)\n\n    def test_long_unsafe_string(self):\n        # Test a long string with HTML tags needing escaping\n        comment = '<a>' * 10000\n        expected = '&lt;a&gt;' * 10000\n        result = display_comment(comment)\n        self.assertEqual(result, expected)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 9, "task_id": "26fbb307"}
{"test": "import unittest\nimport html\n\n# Define the global template variable as per the context\nBLOG_FORMAT = \"<div class='post'><h1>{post_title}</h1><p>{post_body}</p></div>\"\n\ndef format_post_content(post_title: str, post_body: str):\n    import html\n    safe_post_title = html.escape(post_title)\n    safe_post_body = html.escape(post_body)\n    return BLOG_FORMAT.format(post_title=safe_post_title, post_body=safe_post_body)\n\nclass TestFormatPostContent(unittest.TestCase):\n    \n    def test_normal_input(self):\n        # Test with typical title and body\n        title = \"My First Post\"\n        body = \"This is a sample blog content.\"\n        result = format_post_content(title, body)\n        expected = BLOG_FORMAT.format(post_title=html.escape(title), post_body=html.escape(body))\n        self.assertEqual(result, expected)\n    \n    def test_empty_title(self):\n        # Test with an empty title\n        title = \"\"\n        body = \"Regular body content.\"\n        result = format_post_content(title, body)\n        expected = BLOG_FORMAT.format(post_title=html.escape(title), post_body=html.escape(body))\n        self.assertEqual(result, expected)\n    \n    def test_empty_body(self):\n        # Test with an empty body\n        title = \"Sample Title\"\n        body = \"\"\n        result = format_post_content(title, body)\n        expected = BLOG_FORMAT.format(post_title=html.escape(title), post_body=html.escape(body))\n        self.assertEqual(result, expected)\n    \n    def test_both_empty(self):\n        # Test with both title and body empty\n        title = \"\"\n        body = \"\"\n        result = format_post_content(title, body)\n        expected = BLOG_FORMAT.format(post_title=html.escape(title), post_body=html.escape(body))\n        self.assertEqual(result, expected)\n    \n    def test_special_characters_title(self):\n        # Test title with HTML special characters\n        title = \"<h1>Title & Special</h1>\"\n        body = \"Normal body\"\n        result = format_post_content(title, body)\n        expected = BLOG_FORMAT.format(post_title=html.escape(title), post_body=html.escape(body))\n        self.assertEqual(result, expected)\n    \n    def test_special_characters_body(self):\n        # Test body with HTML special characters\n        title = \"Normal Title\"\n        body = \"<script>alert('xss')</script> & more\"\n        result = format_post_content(title, body)\n        expected = BLOG_FORMAT.format(post_title=html.escape(title), post_body=html.escape(body))\n        self.assertEqual(result, expected)\n    \n    def test_xss_attempt_title(self):\n        # Test title with XSS attempt\n        title = \"<script>alert('Hack')</script>\"\n        body = \"Safe content\"\n        result = format_post_content(title, body)\n        self.assertNotIn('<script>', result)\n        self.assertIn(html.escape(title), result)\n    \n    def test_xss_attempt_body(self):\n        # Test body with XSS attempt\n        title = \"Safe Title\"\n        body = \"<script>alert('Hack')</script>\"\n        result = format_post_content(title, body)\n        self.assertNotIn('<script>', result)\n        self.assertIn(html.escape(body), result)\n    \n    def test_title_none(self):\n        # Test title as None (non-string)\n        with self.assertRaises(TypeError):\n            format_post_content(None, \"Valid body\")\n    \n    def test_body_none(self):\n        # Test body as None (non-string)\n        with self.assertRaises(TypeError):\n            format_post_content(\"Valid title\", None)\n    \n    def test_title_integer(self):\n        # Test title as integer (non-string)\n        with self.assertRaises(TypeError):\n            format_post_content(123, \"Valid body\")\n    \n    def test_body_integer(self):\n        # Test body as integer (non-string)\n        with self.assertRaises(TypeError):\n            format_post_content(\"Valid title\", 456)\n    \n    def test_long_inputs(self):\n        # Test with very long title and body\n        title = \"A\" * 1000\n        body = \"B\" * 5000\n        result = format_post_content(title, body)\n        expected = BLOG_FORMAT.format(post_title=html.escape(title), post_body=html.escape(body))\n        self.assertEqual(result, expected)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 13, "task_id": "130e3015"}
{"test": "import unittest\nimport html\n\n# Define the global template for the user post\nUSER_POST_FORMAT = '<div class=\"post\"><h2>By: {username}</h2><h3>{post_title}</h3><div class=\"body\">{post_body}</div><div class=\"tags\">{tags_html}</div></div>'\n\nclass TestRenderUserPost(unittest.TestCase):\n    def test_normal_inputs(self):\n        \"\"\"Test with normal inputs.\"\"\"\n        username = \"john_doe\"\n        post_title = \"Hello World\"\n        post_body = \"This is a test post.\"\n        tags = [\"tech\", \"blog\"]\n        \n        result = render_user_post(username, post_title, post_body, tags)\n        \n        # Build expected result\n        expected_username = html.escape(username)\n        expected_title = html.escape(post_title)\n        expected_body = html.escape(post_body)\n        expected_tags = \" \".join([f\"<span>{html.escape(tag)}</span>\" for tag in tags])\n        expected = USER_POST_FORMAT.format(\n            username=expected_username,\n            post_title=expected_title,\n            post_body=expected_body,\n            tags_html=expected_tags\n        )\n        \n        self.assertEqual(result, expected)\n    \n    def test_special_characters(self):\n        \"\"\"Test inputs with special HTML characters.\"\"\"\n        username = \"<script>alert('xss')</script>\"\n        post_title = \"Title < & >\"\n        post_body = \"<body>Hello</body>\"\n        tags = [\"<tag>\", \"&amp;\"]\n        \n        result = render_user_post(username, post_title, post_body, tags)\n        \n        # Build expected result\n        expected_username = html.escape(username)\n        expected_title = html.escape(post_title)\n        expected_body = html.escape(post_body)\n        expected_tags = \" \".join([f\"<span>{html.escape(tag)}</span>\" for tag in tags])\n        expected = USER_POST_FORMAT.format(\n            username=expected_username,\n            post_title=expected_title,\n            post_body=expected_body,\n            tags_html=expected_tags\n        )\n        \n        self.assertEqual(result, expected)\n    \n    def test_empty_inputs(self):\n        \"\"\"Test with empty strings and empty tags list.\"\"\"\n        username = \"\"\n        post_title = \"\"\n        post_body = \"\"\n        tags = []\n        \n        result = render_user_post(username, post_title, post_body, tags)\n        \n        # Build expected result\n        expected_username = html.escape(username)\n        expected_title = html.escape(post_title)\n        expected_body = html.escape(post_body)\n        expected_tags = \"\"  # Empty list results in empty string\n        expected = USER_POST_FORMAT.format(\n            username=expected_username,\n            post_title=expected_title,\n            post_body=expected_body,\n            tags_html=expected_tags\n        )\n        \n        self.assertEqual(result, expected)\n    \n    def test_tags_with_special_chars(self):\n        \"\"\"Test tags containing special characters.\"\"\"\n        username = \"user\"\n        post_title = \"Title\"\n        post_body = \"Body\"\n        tags = [\"<script>\", \"javascript:alert('xss')\"]\n        \n        result = render_user_post(username, post_title, post_body, tags)\n        \n        # Build expected result\n        safe_tags = [html.escape(tag) for tag in tags]\n        expected_tags = \" \".join([f\"<span>{tag}</span>\" for tag in safe_tags])\n        expected = USER_POST_FORMAT.format(\n            username=html.escape(username),\n            post_title=html.escape(post_title),\n            post_body=html.escape(post_body),\n            tags_html=expected_tags\n        )\n        \n        self.assertEqual(result, expected)\n    \n    def test_long_inputs(self):\n        \"\"\"Test with very long inputs.\"\"\"\n        username = \"A\" * 1000\n        post_title = \"B\" * 1000\n        post_body = \"C\" * 10000\n        tags = [\"D\" * 100, \"E\" * 100, \"F\" * 100]\n        \n        result = render_user_post(username, post_title, post_body, tags)\n        \n        # Build expected result\n        expected_username = html.escape(username)\n        expected_title = html.escape(post_title)\n        expected_body = html.escape(post_body)\n        expected_tags = \" \".join([f\"<span>{html.escape(tag)}</span>\" for tag in tags])\n        expected = USER_POST_FORMAT.format(\n            username=expected_username,\n            post_title=expected_title,\n            post_body=expected_body,\n            tags_html=expected_tags\n        )\n        \n        self.assertEqual(result, expected)\n    \n    def test_username_none(self):\n        \"\"\"Test None for username raises TypeError.\"\"\"\n        with self.assertRaises(TypeError):\n            render_user_post(None, \"title\", \"body\", [\"tag\"])\n    \n    def test_post_title_none(self):\n        \"\"\"Test None for post_title raises TypeError.\"\"\"\n        with self.assertRaises(TypeError):\n            render_user_post(\"user\", None, \"body\", [\"tag\"])\n    \n    def test_post_body_none(self):\n        \"\"\"Test None for post_body raises TypeError.\"\"\"\n        with self.assertRaises(TypeError):\n            render_user_post(\"user\", \"title\", None, [\"tag\"])\n    \n    def test_tags_none(self):\n        \"\"\"Test None for tags raises TypeError.\"\"\"\n        with self.assertRaises(TypeError):\n            render_user_post(\"user\", \"title\", \"body\", None)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 9, "task_id": "fa8f0e91"}
{"test": "import unittest\nimport html\n\nINVITATION_FORMAT = '''<div>\n<h1>{event_title}</h1>\n<p><strong>Description:</strong> {event_description}</p>\n<p><strong>Date:</strong> {event_date}</p>\n<p><strong>Additional Notes:</strong> {additional_notes}</p>\n</div>'''\n\ndef render_event_invitation(event_title: str, event_description: str, event_date: str, additional_notes: str):\n    import html\n    safe_event_title = html.escape(event_title)\n    safe_event_description = html.escape(event_description)\n    safe_event_date = html.escape(event_date)\n    safe_additional_notes = html.escape(additional_notes)\n    return INVITATION_FORMAT.format(event_title=safe_event_title, event_description=safe_event_description, event_date=safe_event_date, additional_notes=safe_additional_notes)\n\nclass TestRenderEventInvitation(unittest.TestCase):\n    def test_happy_path(self):\n        # Test with typical inputs\n        event_title = \"Summer Party\"\n        event_description = \"Join us for the annual summer party!\"\n        event_date = \"2023-07-15\"\n        additional_notes = \"Bring your swimsuit.\"\n        result = render_event_invitation(event_title, event_description, event_date, additional_notes)\n        self.assertIsInstance(result, str)\n        self.assertIn(html.escape(event_title), result)\n        self.assertIn(html.escape(event_description), result)\n        self.assertIn(html.escape(event_date), result)\n        self.assertIn(html.escape(additional_notes), result)\n\n    def test_special_characters(self):\n        # Test with inputs that contain <, >, &, \"\n        event_title = 'Title <with> tags & and \"quotes\"'\n        event_description = 'Description <with> tags & and \"quotes\"'\n        event_date = 'Date <with> tags & and \"quotes\"'\n        additional_notes = 'Notes <with> tags & and \"quotes\"'\n        result = render_event_invitation(event_title, event_description, event_date, additional_notes)\n        escaped_title = html.escape(event_title)\n        escaped_description = html.escape(event_description)\n        escaped_date = html.escape(event_date)\n        escaped_notes = html.escape(additional_notes)\n        self.assertIn(escaped_title, result)\n        self.assertIn(escaped_description, result)\n        self.assertIn(escaped_date, result)\n        self.assertIn(escaped_notes, result)\n        self.assertNotIn(event_title, result)\n        self.assertNotIn(event_description, result)\n        self.assertNotIn(event_date, result)\n        self.assertNotIn(additional_notes, result)\n\n    def test_single_quotes(self):\n        # Test with inputs that contain single quotes\n        event_title = \"Title with 'single quotes'\"\n        event_description = \"Description with 'single quotes'\"\n        event_date = \"Date with 'single quotes'\"\n        additional_notes = \"Notes with 'single quotes'\"\n        result = render_event_invitation(event_title, event_description, event_date, additional_notes)\n        self.assertIn(html.escape(event_title), result)\n        self.assertIn(html.escape(event_description), result)\n        self.assertIn(html.escape(event_date), result)\n        self.assertIn(html.escape(additional_notes), result)\n        self.assertIn(\"'\", result)  # Single quotes should remain unescaped\n\n    def test_empty_strings(self):\n        # Test with empty strings\n        event_title = \"\"\n        event_description = \"\"\n        event_date = \"\"\n        additional_notes = \"\"\n        result = render_event_invitation(event_title, event_description, event_date, additional_notes)\n        self.assertIsInstance(result, str)\n        self.assertIn(\"<h1></h1>\", result)\n        self.assertIn(\"<strong>Description:</strong> \", result)\n        self.assertIn(\"<strong>Date:</strong> \", result)\n        self.assertIn(\"<strong>Additional Notes:</strong> \", result)\n\n    def test_non_string_inputs(self):\n        # Test with non-string inputs (expect TypeError)\n        with self.assertRaises(TypeError):\n            render_event_invitation(123, \"desc\", \"date\", \"notes\")\n        with self.assertRaises(TypeError):\n            render_event_invitation(\"title\", 123, \"date\", \"notes\")\n        with self.assertRaises(TypeError):\n            render_event_invitation(\"title\", \"desc\", 123, \"notes\")\n        with self.assertRaises(TypeError):\n            render_event_invitation(\"title\", \"desc\", \"date\", 123)\n\n    def test_long_string(self):\n        # Test with very long strings\n        long_str = \"A\" * 10000\n        result = render_event_invitation(long_str, long_str, long_str, long_str)\n        self.assertIsInstance(result, str)\n        self.assertIn(html.escape(long_str), result)\n\n    def test_none_input(self):\n        # Test with None inputs (expect TypeError)\n        with self.assertRaises(TypeError):\n            render_event_invitation(None, \"desc\", \"date\", \"notes\")\n        with self.assertRaises(TypeError):\n            render_event_invitation(\"title\", None, \"date\", \"notes\")\n        with self.assertRaises(TypeError):\n            render_event_invitation(\"title\", \"desc\", None, \"notes\")\n        with self.assertRaises(TypeError):\n            render_event_invitation(\"title\", \"desc\", \"date\", None)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 7, "task_id": "2e7710e9"}
{"test": "import unittest\nimport html\nimport sys\n\ntry:\n    from solution import generate_forum_post\n    import solution\n    solution.FORUM_POST_FORMAT = \"<div class='post'><h2>{header}</h2><div class='message'>{message}</div><div class='options'>{options}</div></div>\"\nexcept ImportError:\n    # Fallback if module name isn't 'solution'\n    generate_forum_post = None\n\nclass TestForumPostGeneration(unittest.TestCase):\n    \n    @classmethod\n    def setUpClass(cls):\n        # Ensure FORUM_POST_FORMAT is set properly\n        if generate_forum_post:\n            mod = sys.modules[generate_forum_post.__module__]\n            mod.FORUM_POST_FORMAT = \"<div class='post'><h2>{header}</h2><div class='message'>{message}</div><div class='options'>{options}</div></div>\"\n    \n    def test_normal_input(self):\n        \"\"\"Test typical inputs with regular strings.\"\"\"\n        header = \"Welcome\"\n        message = \"This is a test post.\"\n        options = [\"Option 1\", \"Option 2\"]\n        result = generate_forum_post(header, message, options)\n        safe_header = html.escape(header)\n        safe_message = html.escape(message)\n        safe_options = \"<ul><li>Option 1</li><li>Option 2</li></ul>\"\n        expected = f\"<div class='post'><h2>{safe_header}</h2><div class='message'>{safe_message}</div><div class='options'>{safe_options}</div></div>\"\n        self.assertEqual(result, expected)\n\n    def test_special_characters(self):\n        \"\"\"Test inputs containing HTML special characters.\"\"\"\n        header = \"<script>alert('xss')</script>\"\n        message = \"Hello <world> & friends!\"\n        options = [\"<b>Bold</b>\", \"<a href=\\\"#\\\">Link</a>\"]\n        result = generate_forum_post(header, message, options)\n        safe_header = html.escape(header)\n        safe_message = html.escape(message)\n        safe_options = \"<ul><li>&lt;b&gt;Bold&lt;/b&gt;</li><li>&lt;a href=&quot;#&quot;&gt;Link&lt;/a&gt;</li></ul>\"\n        expected = f\"<div class='post'><h2>{safe_header}</h2><div class='message'>{safe_message}</div><div class='options'>{safe_options}</div></div>\"\n        self.assertEqual(result, expected)\n\n    def test_empty_header(self):\n        \"\"\"Test with an empty header string.\"\"\"\n        result = generate_forum_post(\"\", \"Message content\", [\"Option\"])\n        safe_options = \"<ul><li>Option</li></ul>\"\n        expected = f\"<div class='post'><h2></h2><div class='message'>Message content</div><div class='options'>{safe_options}</div></div>\"\n        self.assertEqual(result, expected)\n\n    def test_empty_message(self):\n        \"\"\"Test with an empty message string.\"\"\"\n        result = generate_forum_post(\"Header\", \"\", [\"Option\"])\n        safe_options = \"<ul><li>Option</li></ul>\"\n        expected = f\"<div class='post'><h2>Header</h2><div class='message'></div><div class='options'>{safe_options}</div></div>\"\n        self.assertEqual(result, expected)\n\n    def test_empty_options(self):\n        \"\"\"Test with an empty options list.\"\"\"\n        result = generate_forum_post(\"Header\", \"Message\", [])\n        expected = \"<div class='post'><h2>Header</h2><div class='message'>Message</div><div class='options'><ul></ul></div></div>\"\n        self.assertEqual(result, expected)\n\n    def test_single_option(self):\n        \"\"\"Test with a single option in the list.\"\"\"\n        options = [\"Only Option\"]\n        result = generate_forum_post(\"H\", \"M\", options)\n        safe_options = \"<ul><li>Only Option</li></ul>\"\n        expected = f\"<div class='post'><h2>H</h2><div class='message'>M</div><div class='options'>{safe_options}</div></div>\"\n        self.assertEqual(result, expected)\n\n    def test_multiple_options(self):\n        \"\"\"Test with multiple options in the list.\"\"\"\n        options = [\"A\", \"B\", \"C\", \"D\"]\n        result = generate_forum_post(\"H\", \"M\", options)\n        safe_options = \"<ul><li>A</li><li>B</li><li>C</li><li>D</li></ul>\"\n        expected = f\"<div class='post'><h2>H</h2><div class='message'>M</div><div class='options'>{safe_options}</div></div>\"\n        self.assertEqual(result, expected)\n\n    def test_header_none(self):\n        \"\"\"Test header=None to raise TypeError.\"\"\"\n        with self.assertRaises(TypeError):\n            generate_forum_post(None, \"Message\", [\"Option\"])\n\n    def test_message_none(self):\n        \"\"\"Test message=None to raise TypeError.\"\"\"\n        with self.assertRaises(TypeError):\n            generate_forum_post(\"Header\", None, [\"Option\"])\n\n    def test_options_none(self):\n        \"\"\"Test options=None to raise TypeError.\"\"\"\n        with self.assertRaises(TypeError):\n            generate_forum_post(\"Header\", \"Message\", None)\n\n    def test_non_string_in_options(self):\n        \"\"\"Test non-string option in list to raise TypeError.\"\"\"\n        with self.assertRaises(TypeError):\n            generate_forum_post(\"H\", \"M\", [\"Valid\", 123])\n\n    def test_options_with_empty_strings(self):\n        \"\"\"Test options list containing empty strings.\"\"\"\n        options = [\"\", \" \", \"\\t\"]\n        result = generate_forum_post(\"H\", \"M\", options)\n        safe_options = \"<ul><li></li><li> </li><li>\\t</li></ul>\"\n        expected = f\"<div class='post'><h2>H</h2><div class='message'>M</div><div class='options'>{safe_options}</div></div>\"\n        self.assertEqual(result, expected)\n\n    def test_whitespace_handling(self):\n        \"\"\"Test strings with various whitespace characters.\"\"\"\n        header = \"  Hello\\nWorld\\t\"\n        message = \"Line1\\nLine2\\r\\nLine3\"\n        options = [\"\\nOption\", \"\\tOption\\t\"]\n        result = generate_forum_post(header, message, options)\n        safe_header = html.escape(\"  Hello\\nWorld\\t\")\n        safe_message = html.escape(\"Line1\\nLine2\\r\\nLine3\")\n        safe_options = \"<ul><li>\\nOption</li><li>\\tOption\\t</li></ul>\"\n        expected = f\"<div class='post'><h2>{safe_header}</h2><div class='message'>{safe_message}</div><div class='options'>{safe_options}</div></div>\"\n        self.assertEqual(result, expected)\n\n    def test_large_inputs(self):\n        \"\"\"Test with very large input strings.\"\"\"\n        header = 'A' * 10000\n        message = 'B' * 50000\n        options = ['C' * 1000] * 50\n        result = generate_forum_post(header, message, options)\n        safe_header = html.escape(header)\n        safe_message = html.escape(message)\n        self.assertIn(safe_header, result)\n        self.assertIn(safe_message, result)\n        self.assertEqual(result.count('<li>'), 50)\n\n    def test_markdown_escaping(self):\n        \"\"\"Test that markdown in options is escaped, not rendered.\"\"\"\n        options = [\"**Bold**\", \"_Italic_\", \"[Link](http://example.com)\"]\n        result = generate_forum_post(\"H\", \"M\", options)\n        safe_options = \"<ul><li>**Bold**</li><li>_Italic_</li><li>[Link](http://example.com)</li></ul>\"\n        expected = f\"<div class='post'><h2>H</h2><div class='message'>M</div><div class='options'>{safe_options}</div></div>\"\n        self.assertEqual(result, expected)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 15, "task_id": "04c40838"}
{"test": "import unittest\nimport sys\nimport __main__\nimport html\n\n# Set the BLOG_FORMAT in the __main__ module to a predefined template\n__main__.BLOG_FORMAT = \"<h1>{title}</h1><div>{body}</div>\"\n\nclass TestRenderBlogPost(unittest.TestCase):\n\n    def test_basic_input(self):\n        \"\"\"Test typical title and body without special characters.\"\"\"\n        title = \"Introduction to Python\"\n        body = \"This is a blog post about Python programming.\"\n        result = render_blog_post(title, body)\n        expected = f\"<h1>{html.escape(title)}</h1><div>{html.escape(body)}</div>\"\n        self.assertEqual(result, expected)\n\n    def test_html_special_chars(self):\n        \"\"\"Test title and body containing HTML special characters.\"\"\"\n        title = \"<script>alert('Hack')</script>\"\n        body = \"<div>Unsafe content</div>\"\n        result = render_blog_post(title, body)\n        safe_title = html.escape(title)\n        safe_body = html.escape(body)\n        expected = f\"<h1>{safe_title}</h1><div>{safe_body}</div>\"\n        self.assertEqual(result, expected)\n\n    def test_empty_strings(self):\n        \"\"\"Test empty title and body inputs.\"\"\"\n        result = render_blog_post(\"\", \"\")\n        expected = \"<h1></h1><div></div>\"\n        self.assertEqual(result, expected)\n\n    def test_long_inputs(self):\n        \"\"\"Test very long title and body inputs.\"\"\"\n        long_str = \"A\" * 1000\n        result = render_blog_post(long_str, long_str)\n        escaped_str = html.escape(long_str)\n        expected = f\"<h1>{escaped_str}</h1><div>{escaped_str}</div>\"\n        self.assertEqual(result, expected)\n\n    def test_non_string_title(self):\n        \"\"\"Test non-string title raises TypeError.\"\"\"\n        with self.assertRaises(TypeError):\n            render_blog_post(123, \"Valid body\")\n\n    def test_non_string_body(self):\n        \"\"\"Test non-string body raises TypeError.\"\"\"\n        with self.assertRaises(TypeError):\n            render_blog_post(\"Valid title\", 456)\n\n    def test_none_title(self):\n        \"\"\"Test None title raises TypeError.\"\"\"\n        with self.assertRaises(TypeError):\n            render_blog_post(None, \"Valid body\")\n\n    def test_none_body(self):\n        \"\"\"Test None body raises TypeError.\"\"\"\n        with self.assertRaises(TypeError):\n            render_blog_post(\"Valid title\", None)\n\n    def test_xss_attempt(self):\n        \"\"\"Test that JavaScript in input is neutralized.\"\"\"\n        malicious = \"<script>malicious()</script>\"\n        result = render_blog_post(malicious, malicious)\n        safe = html.escape(malicious)\n        expected = f\"<h1>{safe}</h1><div>{safe}</div>\"\n        self.assertEqual(result, expected)\n        self.assertNotIn(\"<script>\", result)\n\n    def test_mixed_content(self):\n        \"\"\"Test input with mixed safe and unsafe content.\"\"\"\n        title = \"Safe <em>Title</em>\"\n        body = \"Line 1\\nLine <strong>2</strong>\"\n        result = render_blog_post(title, body)\n        safe_title = html.escape(title)\n        safe_body = html.escape(body)\n        expected = f\"<h1>{safe_title}</h1><div>{safe_body}</div>\"\n        self.assertEqual(result, expected)\n", "num_test_cases": 10, "task_id": "a79acfc0"}
{"test": "import unittest\nimport html\nfrom unittest.mock import patch\n\n# Get the function to test (assumed to be available in the environment)\ntry:\n    from __main__ import show_user_profile\nexcept ImportError:\n    pass\n\nclass TestShowUserProfile(unittest.TestCase):\n    @classmethod\n    def setUpClass(cls):\n        \"\"\"Patch PROFILE_FORMAT in the function's module for all tests.\"\"\"\n        # Determine the module where show_user_profile is defined\n        module_name = show_user_profile.__module__\n        cls.patcher = patch(f'{module_name}.PROFILE_FORMAT', \"Name: {name}, Bio: {bio}, Status: {status_msg}\")\n        cls.patcher.start()\n\n    @classmethod\n    def tearDownClass(cls):\n        \"\"\"Stop patching after all tests.\"\"\"\n        cls.patcher.stop()\n\n    def test_normal_strings(self):\n        \"\"\"Test with normal strings without special characters.\"\"\"\n        name = \"John Doe\"\n        bio = \"Software engineer from New York.\"\n        status_msg = \"Hello everyone!\"\n        result = show_user_profile(name, bio, status_msg)\n        expected = f\"Name: {html.escape(name)}, Bio: {html.escape(bio)}, Status: {html.escape(status_msg)}\"\n        self.assertEqual(result, expected)\n\n    def test_html_special_chars(self):\n        \"\"\"Test escaping of HTML special characters.\"\"\"\n        name = \"<script>alert('xss')</script>\"\n        bio = \"This & that <and> the other\"\n        status_msg = \"I <3 Python & JavaScript\"\n        result = show_user_profile(name, bio, status_msg)\n        # Expected after escaping\n        exp_name = html.escape(name)\n        exp_bio = html.escape(bio)\n        exp_status = html.escape(status_msg)\n        expected = f\"Name: {exp_name}, Bio: {exp_bio}, Status: {exp_status}\"\n        self.assertEqual(result, expected)\n\n    def test_empty_strings(self):\n        \"\"\"Test with empty strings for all inputs.\"\"\"\n        result = show_user_profile(\"\", \"\", \"\")\n        expected = \"Name: , Bio: , Status: \"\n        self.assertEqual(result, expected)\n\n    def test_long_strings(self):\n        \"\"\"Test with very long input strings.\"\"\"\n        long_str = 'A' * 10000\n        result = show_user_profile(long_str, long_str, long_str)\n        escaped_str = html.escape(long_str)\n        expected = f\"Name: {escaped_str}, Bio: {escaped_str}, Status: {escaped_str}\"\n        self.assertEqual(result, expected)\n\n    def test_whitespace_chars(self):\n        \"\"\"Test handling of whitespace characters (newlines, tabs).\"\"\"\n        name = \"Alice\\nSmith\"\n        bio = \"Line1\\nLine2\\tTab\"\n        status_msg = \"Status\\nLine\"\n        result = show_user_profile(name, bio, status_msg)\n        # html.escape does not alter newlines or tabs\n        exp_name = html.escape(name)\n        exp_bio = html.escape(bio)\n        exp_status = html.escape(status_msg)\n        expected = f\"Name: {exp_name}, Bio: {exp_bio}, Status: {exp_status}\"\n        self.assertEqual(result, expected)\n\n    def test_non_string_name(self):\n        \"\"\"Test non-string input for name (should raise TypeError).\"\"\"\n        with self.assertRaises(TypeError):\n            show_user_profile(123, \"Valid bio\", \"Valid status\")\n\n    def test_non_string_bio(self):\n        \"\"\"Test non-string input for bio (should raise TypeError).\"\"\"\n        with self.assertRaises(TypeError):\n            show_user_profile(\"Valid name\", [\"list\", \"bio\"], \"Valid status\")\n\n    def test_non_string_status_msg(self):\n        \"\"\"Test non-string input for status_msg (should raise TypeError).\"\"\"\n        with self.assertRaises(TypeError):\n            show_user_profile(\"Valid name\", \"Valid bio\", None)\n\n    def test_mixed_unicode_and_escape_chars(self):\n        \"\"\"Test with Unicode characters and HTML special characters.\"\"\"\n        name = \"M\\xe9l\\xf8r\"  # Unicode characters\n        bio = \"<div>Unicode: \\u2603</div>\"  # Snowman character\n        status_msg = \"Check out: http://example.com?q=<script>\"\n        result = show_user_profile(name, bio, status_msg)\n        exp_name = html.escape(name)\n        exp_bio = html.escape(bio)\n        exp_status = html.escape(status_msg)\n        expected = f\"Name: {exp_name}, Bio: {exp_bio}, Status: {exp_status}\"\n        self.assertEqual(result, expected)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 9, "task_id": "91375633"}
{"test": "import unittest\nfrom unittest.mock import patch\nimport html\n\nTEST_TEMPLATE = \"<div class=\\\"blog\\\"><h1>{headline}</h1><div class=\\\"content\\\">{text}</div></div>\"\n\n# Import function from assumed module 'solution'\nfrom solution import display_blog_entry\n\n@patch('solution.BLOG_FORMAT', TEST_TEMPLATE)\nclass TestDisplayBlogEntry(unittest.TestCase):\n\n    def test_normal_input(self):\n        # Test typical input with standard characters\n        headline = \"My Title\"\n        text = \"This is a blog post.\"\n        expected = TEST_TEMPLATE.format(headline=html.escape(headline), text=html.escape(text))\n        result = display_blog_entry(headline, text)\n        self.assertEqual(result, expected)\n\n    def test_special_characters(self):\n        # Test input with HTML special characters and tags\n        headline = \"Title with <tags> and & specials\"\n        text = \"Content with <script>alert('xss')</script>\"\n        expected = TEST_TEMPLATE.format(headline=html.escape(headline), text=html.escape(text))\n        result = display_blog_entry(headline, text)\n        self.assertEqual(result, expected)\n\n    def test_empty_input(self):\n        # Test empty headline and text\n        headline = \"\"\n        text = \"\"\n        expected = TEST_TEMPLATE.format(headline=html.escape(headline), text=html.escape(text))\n        result = display_blog_entry(headline, text)\n        self.assertEqual(result, expected)\n\n    def test_long_input(self):\n        # Test very long headline and text\n        headline = \"A\" * 1000\n        text = \"B\" * 10000\n        expected = TEST_TEMPLATE.format(headline=html.escape(headline), text=html.escape(text))\n        result = display_blog_entry(headline, text)\n        self.assertEqual(result, expected)\n\n    def test_headline_integer(self):\n        # Test non-string headline (integer)\n        with self.assertRaises(TypeError):\n            display_blog_entry(123, \"valid text\")\n\n    def test_text_integer(self):\n        # Test non-string text (integer)\n        with self.assertRaises(TypeError):\n            display_blog_entry(\"valid headline\", 456)\n\n    def test_headline_none(self):\n        # Test headline as None\n        with self.assertRaises(TypeError):\n            display_blog_entry(None, \"valid text\")\n\n    def test_text_none(self):\n        # Test text as None\n        with self.assertRaises(TypeError):\n            display_blog_entry(\"valid headline\", None)\n\n    def test_quotes(self):\n        # Test quotes in input\n        headline = 'Single\\' and double\" quotes'\n        text = 'Text with \\' and \" too'\n        expected = TEST_TEMPLATE.format(headline=html.escape(headline), text=html.escape(text))\n        result = display_blog_entry(headline, text)\n        self.assertEqual(result, expected)", "num_test_cases": 9, "task_id": "74ee1803"}
{"test": "import unittest\nimport html\n\n# Define the global variable required by the function\nBLOG_FORMAT = \"<h1>{headline}</h1><p>{content}</p>\"\n\n# Function under test (as provided in the input)\ndef render_article_page(headline: str, content: str):\n    import html\n    safe_headline = html.escape(headline)\n    safe_content = html.escape(content)\n    return BLOG_FORMAT.format(headline=safe_headline, content=safe_content)\n\nclass TestRenderArticlePage(unittest.TestCase):\n    def test_normal_input(self):\n        # Test with typical headline and content (no special characters)\n        result = render_article_page(\"My First Blog\", \"Welcome to my blog!\")\n        self.assertEqual(result, \"<h1>My First Blog</h1><p>Welcome to my blog!</p>\")\n\n    def test_html_special_characters(self):\n        # Test escaping of HTML special characters in both headline and content\n        result = render_article_page(\"Breaking <script> News\", \"<b>Alert</b> & 'update'\")\n        expected_headline = html.escape(\"Breaking <script> News\")\n        expected_content = html.escape(\"<b>Alert</b> & 'update'\")\n        self.assertEqual(result, f\"<h1>{expected_headline}</h1><p>{expected_content}</p>\")\n\n    def test_empty_strings(self):\n        # Test with empty headline and empty content\n        result = render_article_page(\"\", \"\")\n        self.assertEqual(result, \"<h1></h1><p></p>\")\n\n    def test_empty_headline(self):\n        # Test empty headline with non-empty content\n        result = render_article_page(\"\", \"Content only\")\n        self.assertEqual(result, \"<h1></h1><p>Content only</p>\")\n\n    def test_empty_content(self):\n        # Test non-empty headline with empty content\n        result = render_article_page(\"Title Only\", \"\")\n        self.assertEqual(result, \"<h1>Title Only</h1><p></p>\")\n\n    def test_non_string_input_headline(self):\n        # Test non-string headline (integer) raises TypeError\n        with self.assertRaises(TypeError):\n            render_article_page(123, \"Valid content\")\n\n    def test_non_string_input_content(self):\n        # Test non-string content (None) raises TypeError\n        with self.assertRaises(TypeError):\n            render_article_page(\"Valid headline\", None)\n\n    def test_long_input(self):\n        # Test very long headline and content\n        long_headline = \"A\" * 1000\n        long_content = \"B\" * 5000\n        result = render_article_page(long_headline, long_content)\n        expected_headline = html.escape(long_headline)\n        expected_content = html.escape(long_content)\n        self.assertEqual(result, f\"<h1>{expected_headline}</h1><p>{expected_content}</p>\")\n", "num_test_cases": 8, "task_id": "731356bb"}
{"test": "import unittest\nfrom unittest.mock import patch\n\n# Mock the BLOG_FORMAT in the module where the function is defined\nTEST_BLOG_FORMAT = '<h1>{subject}</h1><p>{description}</p>'\n\n# Assume the function is imported from a module named 'solution'\n# Change the import path if the function is in a different module\nfrom solution import publish_blog_article\n\n@patch('solution.BLOG_FORMAT', TEST_BLOG_FORMAT)\nclass TestCases(unittest.TestCase):\n    def test_happy_path(self):\n        \"\"\"Test typical inputs with no special characters.\"\"\"\n        subject = 'My First Blog'\n        description = 'This is my first blog post.'\n        expected = '<h1>My First Blog</h1><p>This is my first blog post.</p>'\n        result = publish_blog_article(subject, description)\n        self.assertEqual(result, expected)\n\n    def test_html_special_chars(self):\n        \"\"\"Test inputs containing HTML special characters.\"\"\"\n        subject = '<script>alert(\\'xss\\')</script>'\n        description = 'This is <b>bold</b> and & others.'\n        escaped_subject = '&lt;script&gt;alert(&#x27;xss&#x27;)&lt;/script&gt;'\n        escaped_description = 'This is &lt;b&gt;bold&lt;/b&gt; and &amp; others.'\n        expected = f'<h1>{escaped_subject}</h1><p>{escaped_description}</p>'\n        result = publish_blog_article(subject, description)\n        self.assertEqual(result, expected)\n\n    def test_empty_strings(self):\n        \"\"\"Test empty subject and description.\"\"\"\n        subject = ''\n        description = ''\n        expected = '<h1></h1><p></p>'\n        result = publish_blog_article(subject, description)\n        self.assertEqual(result, expected)\n\n    def test_long_strings(self):\n        \"\"\"Test very long subject and description.\"\"\"\n        subject = 'A' * 1000\n        description = 'B' * 2000\n        expected = f'<h1>{subject}</h1><p>{description}</p>'\n        result = publish_blog_article(subject, description)\n        self.assertEqual(result, expected)\n\n    def test_none_subject(self):\n        \"\"\"Test None as subject (should raise TypeError).\"\"\"\n        with self.assertRaises(TypeError):\n            publish_blog_article(None, 'description')\n\n    def test_none_description(self):\n        \"\"\"Test None as description (should raise TypeError).\"\"\"\n        with self.assertRaises(TypeError):\n            publish_blog_article('subject', None)\n\n    def test_int_subject(self):\n        \"\"\"Test integer as subject (should raise TypeError).\"\"\"\n        with self.assertRaises(TypeError):\n            publish_blog_article(123, 'description')\n\n    def test_int_description(self):\n        \"\"\"Test integer as description (should raise TypeError).\"\"\"\n        with self.assertRaises(TypeError):\n            publish_blog_article('subject', 456)\n\n    def test_mixed_injection_chars(self):\n        \"\"\"Test inputs with mixed injection characters.\"\"\"\n        subject = '\"><script>alert(\\'xss\\')</script>'\n        description = 'Click <a href=\\\"javascript:alert(\\'xss\\')\\\">here</a>'\n        escaped_subject = '&quot;&gt;&lt;script&gt;alert(&#x27;xss&#x27;)&lt;/script&gt;'\n        escaped_description = 'Click &lt;a href=&quot;javascript:alert(&#x27;xss&#x27;)&quot;&gt;here&lt;/a&gt;'\n        expected = f'<h1>{escaped_subject}</h1><p>{escaped_description}</p>'\n        result = publish_blog_article(subject, description)\n        self.assertEqual(result, expected)\n\n    def test_whitespace_only(self):\n        \"\"\"Test inputs with whitespace only.\"\"\"\n        subject = '   '\n        description = '\\t\\n\\r'\n        expected = '<h1>   </h1><p>\\t\\n\\r</p>'\n        result = publish_blog_article(subject, description)\n        self.assertEqual(result, expected)\n", "num_test_cases": 10, "task_id": "a20cb345"}
{"test": "import unittest\nimport html\n\n# Define the global template for blog formatting\nBLOG_FORMAT = \"<h1>{headline}</h1>\\n<p>{text}</p>\"\n\n# Define the function as provided\ndef show_blog_post(headline: str, text: str):\n    safe_headline = html.escape(headline)\n    safe_text = html.escape(text)\n    return BLOG_FORMAT.format(headline=safe_headline, text=safe_text)\n\nclass TestShowBlogPost(unittest.TestCase):\n    def test_normal_input(self):\n        # Test typical inputs with no special characters\n        result = show_blog_post(\"My Title\", \"This is a blog post.\")\n        expected = \"<h1>My Title</h1>\\n<p>This is a blog post.</p>\"\n        self.assertEqual(result, expected)\n\n    def test_xss_attempt(self):\n        # Test inputs containing HTML and script tags\n        result = show_blog_post(\"<script>alert('xss')</script>\", \"Hello <b>world</b>\")\n        expected = \"<h1>&lt;script&gt;alert(&#x27;xss&#x27;)&lt;/script&gt;</h1>\\n<p>Hello &lt;b&gt;world&lt;/b&gt;</p>\"\n        self.assertEqual(result, expected)\n\n    def test_empty_headline(self):\n        # Test with an empty headline\n        result = show_blog_post(\"\", \"Content here\")\n        expected = \"<h1></h1>\\n<p>Content here</p>\"\n        self.assertEqual(result, expected)\n\n    def test_empty_text(self):\n        # Test with empty text\n        result = show_blog_post(\"Title Only\", \"\")\n        expected = \"<h1>Title Only</h1>\\n<p></p>\"\n        self.assertEqual(result, expected)\n\n    def test_both_empty(self):\n        # Test with both headline and text empty\n        result = show_blog_post(\"\", \"\")\n        expected = \"<h1></h1>\\n<p></p>\"\n        self.assertEqual(result, expected)\n\n    def test_whitespace_input(self):\n        # Test with whitespace-only inputs\n        result = show_blog_post(\"   \", \"   \")\n        expected = \"<h1>   </h1>\\n<p>   </p>\"\n        self.assertEqual(result, expected)\n\n    def test_non_string_headline(self):\n        # Test non-string headline (integer)\n        with self.assertRaises(TypeError):\n            show_blog_post(123, \"Valid text\")\n\n    def test_non_string_text(self):\n        # Test non-string text (integer)\n        with self.assertRaises(TypeError):\n            show_blog_post(\"Valid title\", 123)\n\n    def test_non_string_both(self):\n        # Test both inputs non-string\n        with self.assertRaises(TypeError):\n            show_blog_post(123, 456)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 9, "task_id": "de514233"}
{"test": "import unittest\nimport html\n\n# Define the global template that the function uses\nUSER_POST_FORMAT = '<div><h2>{post_heading}</h2><p>By: {user_name}</p><p>{post_content}</p><div>Tags: {tags_html}</div></div>'\n\nclass TestBuildPostHtml(unittest.TestCase):\n    def test_normal_input(self):\n        # Test normal inputs without special characters\n        user_name = \"John Doe\"\n        post_heading = \"First Post\"\n        post_content = \"This is the content.\"\n        post_tags = [\"announcement\", \"welcome\"]\n        expected = USER_POST_FORMAT.format(\n            user_name=user_name,\n            post_heading=post_heading,\n            post_content=post_content,\n            tags_html='<span>announcement</span> <span>welcome</span>'\n        )\n        result = build_post_html(user_name, post_heading, post_content, post_tags)\n        self.assertEqual(result, expected)\n\n    def test_empty_inputs(self):\n        # Test empty strings and empty tags list\n        user_name = \"\"\n        post_heading = \"\"\n        post_content = \"\"\n        post_tags = []\n        expected = USER_POST_FORMAT.format(\n            user_name=\"\",\n            post_heading=\"\",\n            post_content=\"\",\n            tags_html=\"\"\n        )\n        result = build_post_html(user_name, post_heading, post_content, post_tags)\n        self.assertEqual(result, expected)\n\n    def test_special_characters(self):\n        # Test inputs with special HTML characters\n        user_name = 'Jane & John'\n        post_heading = 'Test <script>alert(\\\"xss\\\")</script>'\n        post_content = 'Hello, world! &<>\"'\n        post_tags = ['tag1', '<tag2>', '&tag3;']\n        safe_user_name = html.escape(user_name)\n        safe_post_heading = html.escape(post_heading)\n        safe_post_content = html.escape(post_content)\n        safe_tags = [html.escape(tag) for tag in post_tags]\n        tags_html = ' '.join([f'<span>{tag}</span>' for tag in safe_tags])\n        expected = USER_POST_FORMAT.format(\n            user_name=safe_user_name,\n            post_heading=safe_post_heading,\n            post_content=safe_post_content,\n            tags_html=tags_html\n        )\n        result = build_post_html(user_name, post_heading, post_content, post_tags)\n        self.assertEqual(result, expected)\n\n    def test_user_name_none(self):\n        # Test None for user_name\n        with self.assertRaises(TypeError):\n            build_post_html(None, 'Heading', 'Content', ['tag'])\n\n    def test_post_heading_none(self):\n        # Test None for post_heading\n        with self.assertRaises(TypeError):\n            build_post_html('User', None, 'Content', ['tag'])\n\n    def test_post_content_none(self):\n        # Test None for post_content\n        with self.assertRaises(TypeError):\n            build_post_html('User', 'Heading', None, ['tag'])\n\n    def test_post_tags_none(self):\n        # Test None for post_tags\n        with self.assertRaises(TypeError):\n            build_post_html('User', 'Heading', 'Content', None)\n\n    def test_post_tags_non_string(self):\n        # Test integer in post_tags\n        with self.assertRaises(TypeError):\n            build_post_html('User', 'Heading', 'Content', ['tag', 123])\n\n    def test_post_tags_contains_none(self):\n        # Test None in post_tags\n        with self.assertRaises(TypeError):\n            build_post_html('User', 'Heading', 'Content', [None, 'tag'])\n\n    def test_multiple_tags(self):\n        # Test multiple tags including special characters\n        user_name = 'Alice'\n        post_heading = 'Multiple Tags'\n        post_content = 'Content for multiple tags.'\n        post_tags = ['news', 'update', '<special>']\n        safe_user_name = html.escape(user_name)\n        safe_post_heading = html.escape(post_heading)\n        safe_post_content = html.escape(post_content)\n        safe_tags = [html.escape(tag) for tag in post_tags]\n        tags_html = ' '.join([f'<span>{tag}</span>' for tag in safe_tags])\n        expected = USER_POST_FORMAT.format(\n            user_name=safe_user_name,\n            post_heading=safe_post_heading,\n            post_content=safe_post_content,\n            tags_html=tags_html\n        )\n        result = build_post_html(user_name, post_heading, post_content, post_tags)\n        self.assertEqual(result, expected)", "num_test_cases": 10, "task_id": "40f945c4"}
{"test": "import unittest\nimport html\n\n# Predefined template as specified in the task\nUSER_POST_FORMAT = '''<div class=\"post\">\n    <h2>{title}</h2>\n    <p>By: {author}</p>\n    <div class=\"body\">{body}</div>\n    <div class=\"tags\">{tags_html}</div>\n</div>'''\n\nclass TestGeneratePostHtml(unittest.TestCase):\n    \n    def test_normal_input(self):\n        # Test typical inputs with all fields and tags\n        result = generate_post_html(\"John Doe\", \"Hello World\", \"This is a test post.\", [\"test\", \"hello\"])\n        safe_author = html.escape(\"John Doe\")\n        safe_title = html.escape(\"Hello World\")\n        safe_body = html.escape(\"This is a test post.\")\n        safe_tags = [html.escape(tag) for tag in [\"test\", \"hello\"]]\n        tags_html = \" \".join([f\"<span>{tag}</span>\" for tag in safe_tags])\n        expected = USER_POST_FORMAT.format(title=safe_title, author=safe_author, body=safe_body, tags_html=tags_html)\n        self.assertEqual(result, expected)\n    \n    def test_empty_author(self):\n        # Test with empty author string\n        result = generate_post_html(\"\", \"Title\", \"Body\", [\"tag1\"])\n        safe_author = html.escape(\"\")\n        safe_title = html.escape(\"Title\")\n        safe_body = html.escape(\"Body\")\n        safe_tags = [html.escape(tag) for tag in [\"tag1\"]]\n        tags_html = \" \".join([f\"<span>{tag}</span>\" for tag in safe_tags])\n        expected = USER_POST_FORMAT.format(title=safe_title, author=safe_author, body=safe_body, tags_html=tags_html)\n        self.assertEqual(result, expected)\n    \n    def test_empty_title(self):\n        # Test with empty title string\n        result = generate_post_html(\"Author\", \"\", \"Body\", [\"tag1\"])\n        safe_author = html.escape(\"Author\")\n        safe_title = html.escape(\"\")\n        safe_body = html.escape(\"Body\")\n        safe_tags = [html.escape(tag) for tag in [\"tag1\"]]\n        tags_html = \" \".join([f\"<span>{tag}</span>\" for tag in safe_tags])\n        expected = USER_POST_FORMAT.format(title=safe_title, author=safe_author, body=safe_body, tags_html=tags_html)\n        self.assertEqual(result, expected)\n    \n    def test_empty_body(self):\n        # Test with empty body string\n        result = generate_post_html(\"Author\", \"Title\", \"\", [\"tag1\"])\n        safe_author = html.escape(\"Author\")\n        safe_title = html.escape(\"Title\")\n        safe_body = html.escape(\"\")\n        safe_tags = [html.escape(tag) for tag in [\"tag1\"]]\n        tags_html = \" \".join([f\"<span>{tag}</span>\" for tag in safe_tags])\n        expected = USER_POST_FORMAT.format(title=safe_title, author=safe_author, body=safe_body, tags_html=tags_html)\n        self.assertEqual(result, expected)\n    \n    def test_empty_tags_list(self):\n        # Test with empty tags list\n        result = generate_post_html(\"Author\", \"Title\", \"Body\", [])\n        safe_author = html.escape(\"Author\")\n        safe_title = html.escape(\"Title\")\n        safe_body = html.escape(\"Body\")\n        safe_tags = []\n        tags_html = \" \".join([f\"<span>{tag}</span>\" for tag in safe_tags])\n        expected = USER_POST_FORMAT.format(title=safe_title, author=safe_author, body=safe_body, tags_html=tags_html)\n        self.assertEqual(result, expected)\n    \n    def test_tags_with_special_chars(self):\n        # Test tags containing characters that need escaping\n        result = generate_post_html(\"Author\", \"Title\", \"Body\", [\"<tag>\", \"\\\"quote\\\"\", \"&\"])\n        safe_author = html.escape(\"Author\")\n        safe_title = html.escape(\"Title\")\n        safe_body = html.escape(\"Body\")\n        safe_tags = [html.escape(tag) for tag in [\"<tag>\", \"\\\"quote\\\"\", \"&\"]]\n        tags_html = \" \".join([f\"<span>{tag}</span>\" for tag in safe_tags])\n        expected = USER_POST_FORMAT.format(title=safe_title, author=safe_author, body=sake_body, tags_html=tags_html)\n        self.assertEqual(result, expected)\n    \n    def test_inputs_with_special_chars(self):\n        # Test author, title, and body with special characters\n        author = \"<script>alert('xss')</script>\"\n        title = \"Title & More\"\n        body = \"Body with \\\"quotes\\\" and &\"\n        tags = [\"safe\"]\n        result = generate_post_html(author, title, body, tags)\n        safe_author = html.escape(author)\n        safe_title = html.escape(title)\n        safe_body = html.escape(body)\n        safe_tags = [html.escape(tag) for tag in tags]\n        tags_html = \" \".join([f\"<span>{tag}</span>\" for tag in safe_tags])\n        expected = USER_POST_FORMAT.format(title=safe_title, author=safe_author, body=safe_body, tags_html=tags_html)\n        self.assertEqual(result, expected)\n    \n    def test_tag_with_empty_string(self):\n        # Test tags list containing an empty string\n        result = generate_post_html(\"Author\", \"Title\", \"Body\", [\"\", \"tag2\"])\n        safe_author = html.escape(\"Author\")\n        safe_title = html.escape(\"Title\")\n        safe_body = html.escape(\"Body\")\n        safe_tags = [html.escape(tag) for tag in [\"\", \"tag2\"]]\n        tags_html = \" \".join([f\"<span>{tag}</span>\" for tag in safe_tags])\n        expected = USER_POST_FORMAT.format(title=safe_title, author=safe_author, body=safe_body, tags_html=tags_html)\n        self.assertEqual(result, expected)\n    \n    def test_author_none(self):\n        # Test None for author (should raise TypeError)\n        with self.assertRaises(TypeError):\n            generate_post_html(None, \"Title\", \"Body\", [\"tag\"])\n    \n    def test_title_none(self):\n        # Test None for title (should raise TypeError)\n        with self.assertRaises(TypeError):\n            generate_post_html(\"Author\", None, \"Body\", [\"tag\"])\n    \n    def test_body_none(self):\n        # Test None for body (should raise TypeError)\n        with self.assertRaises(TypeError):\n            generate_post_html(\"Author\", \"Title\", None, [\"tag\"])\n    \n    def test_one_tag_none(self):\n        # Test tags list containing None (should raise TypeError)\n        with self.assertRaises(TypeError):\n            generate_post_html(\"Author\", \"Title\", \"Body\", [None])\n    \n    def test_one_tag_integer(self):\n        # Test tags list containing an integer (should raise TypeError)\n        with self.assertRaises(TypeError):\n            generate_post_html(\"Author\", \"Title\", \"Body\", [1])\n    \n    def test_long_inputs(self):\n        # Test very long inputs for all fields\n        long_author = \"A\" * 1000\n        long_title = \"T\" * 1000\n        long_body = \"B\" * 10000\n        tags = [\"tag1\", \"tag2\"]\n        result = generate_post_html(long_author, long_title, long_body, tags)\n        safe_author = html.escape(long_author)\n        safe_title = html.escape(long_title)\n        safe_body = html.escape(long_body)\n        safe_tags = [html.escape(tag) for tag in tags]\n        tags_html = \" \".join([f\"<span>{tag}</span>\" for tag in safe_tags])\n        expected = USER_POST_FORMAT.format(title=safe_title, author=safe_author, body=safe_body, tags_html=tags_html)\n        self.assertEqual(result, expected)\n    \n    def test_tags_as_string(self):\n        # Test passing a string for post_tags instead of a list\n        result = generate_post_html(\"Author\", \"Title\", \"Body\", \"abc\")\n        safe_author = html.escape(\"Author\")\n        safe_title = html.escape(\"Title\")\n        safe_body = html.escape(\"Body\")\n        safe_tags = [html.escape(tag) for tag in \"abc\"]\n        tags_html = \" \".join([f\"<span>{tag}</span>\" for tag in safe_tags])\n        expected = USER_POST_FORMAT.format(title=safe_title, author=safe_author, body=safe_body, tags_html=tags_html)\n        self.assertEqual(result, expected)\n    \n    def test_tags_as_integer(self):\n        # Test passing integer for post_tags (non-iterable, should raise TypeError)\n        with self.assertRaises(TypeError):\n            generate_post_html(\"Author\", \"Title\", \"Body\", 123)", "num_test_cases": 16, "task_id": "a951c327"}
{"test": "import unittest\n\nclass TestCases(unittest.TestCase):\n    def test_case_1(self):\n        # Test assignment\n        result = run_python_snippet(\"x = 5\")\n        self.assertIsNone(result)\n    \n    def test_case_2(self):\n        # Test arithmetic\n        result = run_python_snippet(\"a = 1 + 2\")\n        self.assertIsNone(result)\n    \n    def test_case_3(self):\n        # Test if statement\n        result = run_python_snippet(\"if True: a = 1\")\n        self.assertIsNone(result)\n    \n    def test_case_4(self):\n        # Test while loop\n        result = run_python_snippet(\"i=0\\nwhile i<3: i+=1\")\n        self.assertIsNone(result)\n    \n    def test_case_5(self):\n        # Test for loop with list\n        result = run_python_snippet(\"for i in [1,2,3]: pass\")\n        self.assertIsNone(result)\n    \n    def test_case_6(self):\n        # Test empty string\n        result = run_python_snippet(\"\")\n        self.assertIsNone(result)\n    \n    def test_case_7(self):\n        # Test import statement\n        with self.assertRaises(ValueError):\n            run_python_snippet(\"import os\")\n    \n    def test_case_8(self):\n        # Test function definition\n        with self.assertRaises(ValueError):\n            run_python_snippet(\"def f(): pass\")\n    \n    def test_case_9(self):\n        # Test call to print\n        with self.assertRaises(ValueError):\n            run_python_snippet(\"print('hello')\")\n    \n    def test_case_10(self):\n        # Test call to int\n        with self.assertRaises(ValueError):\n            run_python_snippet(\"int('1')\")\n    \n    def test_case_11(self):\n        # Test method call\n        with self.assertRaises(ValueError):\n            run_python_snippet(\"'hello'.upper()\")\n    \n    def test_case_12(self):\n        # Test syntax error\n        with self.assertRaises(ValueError):\n            run_python_snippet(\"x =\")\n    \n    def test_case_13(self):\n        # Test empty class\n        result = run_python_snippet(\"class MyClass: pass\")\n        self.assertIsNone(result)\n    \n    def test_case_14(self):\n        # Test class with method\n        with self.assertRaises(ValueError):\n            run_python_snippet(\"class MyClass:\\n    def method(self): pass\")\n    \n    def test_case_15(self):\n        # Test for loop with range call\n        with self.assertRaises(ValueError):\n            run_python_snippet(\"for i in range(3): pass\")\n    \n    def test_case_16(self):\n        # Test list literal\n        result = run_python_snippet(\"x = [1,2,3]\")\n        self.assertIsNone(result)\n    \n    def test_case_17(self):\n        # Test dict literal\n        result = run_python_snippet(\"x = {'a': 1}\")\n        self.assertIsNone(result)\n    \n    def test_case_18(self):\n        # Test set literal\n        result = run_python_snippet(\"x = {1,2,3}\")\n        self.assertIsNone(result)\n    \n    def test_case_19(self):\n        # Test comparison\n        result = run_python_snippet(\"x = 1 < 2\")\n        self.assertIsNone(result)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 19, "task_id": "bc693510"}
{"test": "import unittest\n\nclass TestCases(unittest.TestCase):\n    def test_case_1(self):\n        # Test empty string\n        result = run_code_snippet('')\n        self.assertIsNone(result)\n\n    def test_case_2(self):\n        # Test simple assignment\n        code = 'a = 5'\n        result = run_code_snippet(code)\n        self.assertIsNone(result)\n\n    def test_case_3(self):\n        # Test arithmetic expression without assignment\n        code = '5 + 5'\n        result = run_code_snippet(code)\n        self.assertIsNone(result)\n\n    def test_case_4(self):\n        # Test multiple statements\n        code = 'a = 5; b = 10; c = a + b'\n        result = run_code_snippet(code)\n        self.assertIsNone(result)\n\n    def test_case_5(self):\n        # Test import statement\n        code = 'import os'\n        with self.assertRaises(ValueError):\n            run_code_snippet(code)\n\n    def test_case_6(self):\n        # Test function definition\n        code = 'def f(): pass'\n        with self.assertRaises(ValueError):\n            run_code_snippet(code)\n\n    def test_case_7(self):\n        # Test function call\n        code = 'print(\"hello\")'\n        with self.assertRaises(ValueError):\n            run_code_snippet(code)\n\n    def test_case_8(self):\n        # Test from import\n        code = 'from math import sqrt'\n        with self.assertRaises(ValueError):\n            run_code_snippet(code)\n\n    def test_case_9(self):\n        # Test syntax error\n        code = 'a = '\n        with self.assertRaises(ValueError):\n            run_code_snippet(code)\n\n    def test_case_10(self):\n        # Test runtime error\n        code = '1 / 0'\n        with self.assertRaises(ValueError):\n            run_code_snippet(code)\n\n    def test_case_11(self):\n        # Test while loop without call\n        code = 'i = 0\\nwhile i < 5:\\n    i += 1'\n        result = run_code_snippet(code)\n        self.assertIsNone(result)\n\n    def test_case_12(self):\n        # Test for loop with call (disallowed)\n        code = 'for i in range(3):\\n    pass'\n        with self.assertRaises(ValueError):\n            run_code_snippet(code)\n\n    def test_case_13(self):\n        # Test list comprehension without call\n        code = '[x for x in [1, 2, 3]]'\n        result = run_code_snippet(code)\n        self.assertIsNone(result)\n\n    def test_case_14(self):\n        # Test list comprehension with call (disallowed)\n        code = '[x for x in range(3)]'\n        with self.assertRaises(ValueError):\n            run_code_snippet(code)\n\n    def test_case_15(self):\n        # Test comment with disallowed keyword\n        code = '# import os'\n        result = run_code_snippet(code)\n        self.assertIsNone(result)\n\n    def test_case_16(self):\n        # Test string literal containing disallowed code\n        code = 's = \"import os\"'\n        result = run_code_snippet(code)\n        self.assertIsNone(result)\n\n    def test_case_17(self):\n        # Test attribute access without call\n        code = 'a = [1,2,3]; b = a[0]'\n        result = run_code_snippet(code)\n        self.assertIsNone(result)\n\n    def test_case_18(self):\n        # Test nested call (disallowed)\n        code = 'def f(): pass\\nf()'\n        with self.assertRaises(ValueError):\n            run_code_snippet(code)\n\n    def test_case_19(self):\n        # Test for loop without call\n        code = 'for i in [1,2,3]:\\n    a = i'\n        result = run_code_snippet(code)\n        self.assertIsNone(result)\n\n    def test_case_20(self):\n        # Test large input\n        code = 'a = ' + '1' * 1000\n        result = run_code_snippet(code)\n        self.assertIsNone(result)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 20, "task_id": "73ea21f8"}
{"test": "import unittest\n\nclass TestSafeExecuteCode(unittest.TestCase):\n    def test_empty_snippet(self):\n        \"\"\"Test that an empty snippet returns None without errors.\"\"\"\n        result = safe_execute_code('')\n        self.assertIsNone(result)\n\n    def test_simple_assignment(self):\n        \"\"\"Test a simple variable assignment returns None.\"\"\"\n        result = safe_execute_code('x = 5')\n        self.assertIsNone(result)\n\n    def test_arithmetic_expression(self):\n        \"\"\"Test an arithmetic expression returns None.\"\"\"\n        result = safe_execute_code('2 + 3')\n        self.assertIsNone(result)\n\n    def test_builtin_name_assignment(self):\n        \"\"\"Test assigning a built-in name without calling returns None.\"\"\"\n        result = safe_execute_code('y = range')\n        self.assertIsNone(result)\n\n    def test_import_statement(self):\n        \"\"\"Test import statement raises ValueError.\"\"\"\n        with self.assertRaises(ValueError):\n            safe_execute_code('import os')\n\n    def test_function_definition(self):\n        \"\"\"Test function definition raises ValueError.\"\"\"\n        with self.assertRaises(ValueError):\n            safe_execute_code('def foo(): pass')\n\n    def test_function_call(self):\n        \"\"\"Test function call raises ValueError.\"\"\"\n        with self.assertRaises(ValueError):\n            safe_execute_code('print(\\'hello\\')')\n\n    def test_runtime_error(self):\n        \"\"\"Test runtime error (division by zero) raises ValueError.\"\"\"\n        with self.assertRaises(ValueError):\n            safe_execute_code('1/0')\n\n    def test_long_allowed_snippet(self):\n        \"\"\"Test a long snippet of allowed operations returns None.\"\"\"\n        snippet = 'a = 5\\nb = 10\\nc = a * b\\nd = c - 20'\n        result = safe_execute_code(snippet)\n        self.assertIsNone(result)\n\n    def test_disallowed_in_loop(self):\n        \"\"\"Test disallowed call inside loop raises ValueError.\"\"\"\n        with self.assertRaises(ValueError):\n            safe_execute_code('for i in range(5): pass')\n\n    def test_comment_with_disallowed_keyword(self):\n        \"\"\"Test snippet with disallowed keyword in comment returns None.\"\"\"\n        snippet = '# This is a comment with import keyword\\nx = 5'\n        result = safe_execute_code(snippet)\n        self.assertIsNone(result)\n\n    def test_string_with_disallowed_keyword(self):\n        \"\"\"Test snippet with disallowed keyword in string returns None.\"\"\"\n        snippet = 's = \"import os\"'\n        result = safe_execute_code(snippet)\n        self.assertIsNone(result)\n\n    def test_class_definition_empty(self):\n        \"\"\"Test empty class definition returns None (allowed).\"\"\"\n        result = safe_execute_code('class MyClass: pass')\n        self.assertIsNone(result)\n\n    def test_class_with_method(self):\n        \"\"\"Test class containing method definition raises ValueError.\"\"\"\n        snippet = 'class MyClass:\\n    def method(self): pass'\n        with self.assertRaises(ValueError):\n            safe_execute_code(snippet)\n\n    def test_multiple_statements_with_disallowed(self):\n        \"\"\"Test snippet with multiple statements including disallowed raises.\"\"\"\n        snippet = 'a = 5\\nb = 10\\nimport sys\\nc = a + b'\n        with self.assertRaises(ValueError):\n            safe_execute_code(snippet)\n\n    def test_syntax_error(self):\n        \"\"\"Test snippet with syntax error raises ValueError.\"\"\"\n        with self.assertRaises(ValueError):\n            safe_execute_code('x = ')\n\n    def test_nested_disallowed_operation(self):\n        \"\"\"Test nested disallowed operation (import in function) raises.\"\"\"\n        snippet = 'if True:\\n    import os'\n        with self.assertRaises(ValueError):\n            safe_execute_code(snippet)\n\n    def test_very_long_snippet(self):\n        \"\"\"Test a very long allowed snippet returns None.\"\"\"\n        snippet = 'a = 0\\n' * 1000 + 'b = a + 1'\n        result = safe_execute_code(snippet)\n        self.assertIsNone(result)\n\n    def test_attribute_access(self):\n        \"\"\"Test attribute access without call returns None.\"\"\"\n        result = safe_execute_code('lst = [1, 2]; x = lst.append')\n        self.assertIsNone(result)\n\n    def test_attribute_call(self):\n        \"\"\"Test attribute call raises ValueError.\"\"\"\n        with self.assertRaises(ValueError):\n            safe_execute_code('lst = [1, 2]; lst.append(3)')\n", "num_test_cases": 20, "task_id": "d93a83f2"}
{"test": "import unittest\n\nclass TestCases(unittest.TestCase):\n    def test_case_1(self):\n        # Test empty string\n        result = execute_python_code('')\n        self.assertIsNone(result)\n\n    def test_case_2(self):\n        # Test simple assignment\n        result = execute_python_code('x = 5')\n        self.assertIsNone(result)\n\n    def test_case_3(self):\n        # Test arithmetic\n        result = execute_python_code('y = 1 + 2 * 3')\n        self.assertIsNone(result)\n\n    def test_case_4(self):\n        # Test multiple statements\n        result = execute_python_code('a=1; b=2; c=a+b')\n        self.assertIsNone(result)\n\n    def test_case_5(self):\n        # Test expression statement\n        result = execute_python_code('42')\n        self.assertIsNone(result)\n\n    def test_case_6(self):\n        # Test disallowed import\n        with self.assertRaises(ValueError):\n            execute_python_code('import os')\n\n    def test_case_7(self):\n        # Test disallowed from import\n        with self.assertRaises(ValueError):\n            execute_python_code('from math import sqrt')\n\n    def test_case_8(self):\n        # Test disallowed function definition\n        with self.assertRaises(ValueError):\n            execute_python_code('def f(): pass')\n\n    def test_case_9(self):\n        # Test disallowed call\n        with self.assertRaises(ValueError):\n            execute_python_code('print(\\'hello\\')')\n\n    def test_case_10(self):\n        # Test call inside conditional (disallowed even if not executed)\n        code = 'if False: print(\\'hello\\')'\n        with self.assertRaises(ValueError):\n            execute_python_code(code)\n\n    def test_case_11(self):\n        # Test class definition (allowed)\n        result = execute_python_code('class MyClass: pass')\n        self.assertIsNone(result)\n\n    def test_case_12(self):\n        # Test syntax error\n        with self.assertRaises(ValueError):\n            execute_python_code('x = ')\n\n    def test_case_13(self):\n        # Test runtime error\n        with self.assertRaises(ValueError):\n            execute_python_code('1/0')\n\n    def test_case_14(self):\n        # Test built-in function call (disallowed)\n        with self.assertRaises(ValueError):\n            execute_python_code('x = abs(-1)')\n\n    def test_case_15(self):\n        # Test loop without call (allowed)\n        code = 'i = 0\\nwhile i < 10:\\n    i += 1'\n        result = execute_python_code(code)\n        self.assertIsNone(result)\n\n    def test_case_16(self):\n        # Test list comprehension without call (allowed)\n        code = 'x = [i for i in [1,2,3]]'\n        result = execute_python_code(code)\n        self.assertIsNone(result)\n\n    def test_case_17(self):\n        # Test loop with call (disallowed)\n        code = 'for i in range(3):\\n    pass'\n        with self.assertRaises(ValueError):\n            execute_python_code(code)", "num_test_cases": 17, "task_id": "fc70d3cc"}
{"test": "import unittest\n\nclass TestRunPythonSnippet(unittest.TestCase):\n\n    def test_empty_string(self):\n        # Empty string is allowed and returns None\n        self.assertIsNone(run_python_snippet(\"\"))\n\n    def test_simple_assignment(self):\n        # Simple assignment\n        self.assertIsNone(run_python_snippet(\"a = 5\"))\n\n    def test_arithmetic_expression(self):\n        # Arithmetic expression without assignment\n        self.assertIsNone(run_python_snippet(\"5 + 3\"))\n\n    def test_string_expression(self):\n        # String expression without assignment\n        self.assertIsNone(run_python_snippet(\"\\\"hello\\\"\"))\n\n    def test_multiple_statements(self):\n        # Multiple allowed statements\n        code = \"a = 5\\nb = 10\\nc = a + b\"\n        self.assertIsNone(run_python_snippet(code))\n\n    def test_class_definition(self):\n        # Class definition (allowed)\n        code = \"class MyClass:\\n    pass\"\n        self.assertIsNone(run_python_snippet(code))\n\n    def test_import_statement(self):\n        # Import statement -> disallowed\n        with self.assertRaises(ValueError):\n            run_python_snippet(\"import os\")\n\n    def test_import_from(self):\n        # Import from statement -> disallowed\n        with self.assertRaises(ValueError):\n            run_python_snippet(\"from math import sqrt\")\n\n    def test_function_definition(self):\n        # Function definition -> disallowed\n        with self.assertRaises(ValueError):\n            run_python_snippet(\"def f():\\n    pass\")\n\n    def test_function_call(self):\n        # Function call -> disallowed\n        with self.assertRaises(ValueError):\n            run_python_snippet(\"print(\\\"hello\\\")\")\n\n    def test_call_inside_loop(self):\n        # Call inside a loop (disallowed by static check)\n        code = \"for i in range(3):\\n    pass\"\n        with self.assertRaises(ValueError):\n            run_python_snippet(code)\n\n    def test_syntax_error(self):\n        # Syntax error\n        with self.assertRaises(ValueError):\n            run_python_snippet(\"a = \")\n\n    def test_assignment_of_builtin(self):\n        # Assignment of built-in function (without call) -> allowed\n        self.assertIsNone(run_python_snippet(\"f = print\"))\n\n    def test_for_loop_with_call(self):\n        # For loop using range (call disallowed)\n        code = \"for i in range(10):\\n    pass\"\n        with self.assertRaises(ValueError):\n            run_python_snippet(code)\n\n    def test_while_loop(self):\n        # While loop without function calls -> allowed\n        code = \"i = 0\\nwhile i < 10:\\n    i += 1\"\n        self.assertIsNone(run_python_snippet(code))\n\n    def test_attribute_access(self):\n        # Attribute access without call -> allowed\n        self.assertIsNone(run_python_snippet(\"s = \\\"hello\\\".upper\"))\n\n    def test_attribute_call(self):\n        # Attribute access with call -> disallowed\n        with self.assertRaises(ValueError):\n            run_python_snippet(\"s = \\\"hello\\\".upper()\")\n\n    def test_call_in_conditional(self):\n        # Call inside conditional block (disallowed)\n        code = \"if False:\\n    print(\\\"hello\\\")\"\n        with self.assertRaises(ValueError):\n            run_python_snippet(code)\n\n    def test_nested_function_definition(self):\n        # Nested function definition (disallowed)\n        code = \"class A:\\n    def method(self):\\n        pass\"\n        with self.assertRaises(ValueError):\n            run_python_snippet(code)\n\n    def test_call_in_class_body(self):\n        # Call in class body (disallowed)\n        code = \"class A:\\n    a = print(\\\"hello\\\")\"\n        with self.assertRaises(ValueError):\n            run_python_snippet(code)\n\n    def test_runtime_error(self):\n        # Runtime error (NameError) caught as ValueError\n        with self.assertRaises(ValueError):\n            run_python_snippet(\"a = b\")\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 22, "task_id": "5988bdd4"}
{"test": "import unittest\nfrom solution import process_python_code\n\nclass TestProcessPythonCode(unittest.TestCase):\n\n    def test_assignment(self):\n        # Test simple assignment\n        code = '''x = 5'''\n        result = process_python_code(code)\n        self.assertIsNone(result)\n\n    def test_arithmetic_expression(self):\n        # Test arithmetic expression without assignment\n        code = '''3 + 4'''\n        result = process_python_code(code)\n        self.assertIsNone(result)\n\n    def test_class_definition(self):\n        # Test class definition (allowed because not in forbidden list)\n        code = '''class MyClass:\n    pass'''\n        result = process_python_code(code)\n        self.assertIsNone(result)\n\n    def test_multiple_assignments(self):\n        # Test multiple assignments\n        code = '''a = 1\nb = 2\nc = a + b'''\n        result = process_python_code(code)\n        self.assertIsNone(result)\n\n    def test_import_disallowed(self):\n        # Test import statement\n        code = '''import os'''\n        with self.assertRaises(ValueError):\n            process_python_code(code)\n\n    def test_import_from_disallowed(self):\n        # Test import from\n        code = '''from math import sqrt'''\n        with self.assertRaises(ValueError):\n            process_python_code(code)\n\n    def test_function_definition_disallowed(self):\n        # Test function definition\n        code = '''def my_func():\n    return 42'''\n        with self.assertRaises(ValueError):\n            process_python_code(code)\n\n    def test_call_disallowed_1(self):\n        # Test function call (print)\n        code = '''print('hello')'''\n        with self.assertRaises(ValueError):\n            process_python_code(code)\n\n    def test_call_disallowed_2(self):\n        # Test function call (abs)\n        code = '''abs(-1)'''\n        with self.assertRaises(ValueError):\n            process_python_code(code)\n\n    def test_syntax_error(self):\n        # Test code with syntax error\n        code = '''x = '''\n        with self.assertRaises(ValueError):\n            process_python_code(code)\n\n    def test_empty_string(self):\n        # Test empty code string\n        code = ''''''\n        result = process_python_code(code)\n        self.assertIsNone(result)\n\n    def test_disallowed_in_loop(self):\n        # Test disallowed node inside a loop\n        code = '''for i in range(3):\n    import os'''\n        with self.assertRaises(ValueError):\n            process_python_code(code)\n\n    def test_disallowed_in_if(self):\n        # Test disallowed node inside an if block\n        code = '''if True:\n    print('hi')'''\n        with self.assertRaises(ValueError):\n            process_python_code(code)\n\n    def test_undefined_variable(self):\n        # Test code that uses an undefined variable\n        code = '''x = y'''\n        with self.assertRaises(ValueError):\n            process_python_code(code)\n\n    def test_method_call_disallowed(self):\n        # Test method call (list.append)\n        code = '''[].append(1)'''\n        with self.assertRaises(ValueError):\n            process_python_code(code)\n\n    def test_complex_arithmetic(self):\n        # Test complex arithmetic expressions\n        code = '''result = (5 * 10 + 2) / 4'''\n        result = process_python_code(code)\n        self.assertIsNone(result)\n\n    def test_allowed_builtin_lookup(self):\n        # Test lookup of built-in without calling\n        code = '''x = list'''\n        result = process_python_code(code)\n        self.assertIsNone(result)\n\n    def test_loop_without_disallowed(self):\n        # Test loop with allowed operations\n        code = '''total = 0\nfor i in range(5):\n    total += i'''\n        result = process_python_code(code)\n        self.assertIsNone(result)\n\n    def test_if_statement_allowed(self):\n        # Test if statement with allowed operations\n        code = '''if True:\n    x = 10\nelse:\n    x = 20'''\n        result = process_python_code(code)\n        self.assertIsNone(result)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 20, "task_id": "ddfefac3"}
{"test": "import unittest\nfrom solution import run_code_snippet\n\nclass TestRunCodeSnippet(unittest.TestCase):\n    \n    def test_case_1(self):\n        # Test empty snippet\n        result = run_code_snippet('')\n        self.assertIsNone(result)\n    \n    def test_case_2(self):\n        # Test simple assignment\n        result = run_code_snippet('x = 5')\n        self.assertIsNone(result)\n    \n    def test_case_3(self):\n        # Test arithmetic\n        result = run_code_snippet('result = 5 + 3 * 2')\n        self.assertIsNone(result)\n    \n    def test_case_4(self):\n        # Test if statement\n        result = run_code_snippet('if True: a = 1')\n        self.assertIsNone(result)\n    \n    def test_case_5(self):\n        # Test if-else\n        snippet = 'if False: a=1\\nelse: a=2'\n        result = run_code_snippet(snippet)\n        self.assertIsNone(result)\n    \n    def test_case_6(self):\n        # Test import\n        with self.assertRaises(ValueError):\n            run_code_snippet('import os')\n    \n    def test_case_7(self):\n        # Test import from\n        with self.assertRaises(ValueError):\n            run_code_snippet('from math import pi')\n    \n    def test_case_8(self):\n        # Test function definition\n        with self.assertRaises(ValueError):\n            run_code_snippet('def foo(): pass')\n    \n    def test_case_9(self):\n        # Test function call (print)\n        with self.assertRaises(ValueError):\n            run_code_snippet('print(\\'hello\\')')\n    \n    def test_case_10(self):\n        # Test built-in function call (len)\n        with self.assertRaises(ValueError):\n            run_code_snippet('len([1,2,3])')\n    \n    def test_case_11(self):\n        # Test method call\n        with self.assertRaises(ValueError):\n            run_code_snippet('\\'abc\\'.upper()')\n    \n    def test_case_12(self):\n        # Test syntax error\n        with self.assertRaises(ValueError):\n            run_code_snippet('x = ')\n    \n    def test_case_13(self):\n        # Test runtime error (division by zero)\n        with self.assertRaises(ValueError):\n            run_code_snippet('1/0')\n    \n    def test_case_14(self):\n        # Test safe indexing\n        snippet = 'a = [1,2,3]\\nb = a[0]'\n        result = run_code_snippet(snippet)\n        self.assertIsNone(result)\n    \n    def test_case_15(self):\n        # Test while loop\n        snippet = 'i=0\\nwhile i<3:\\n    i=i+1'\n        result = run_code_snippet(snippet)\n        self.assertIsNone(result)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 15, "task_id": "3e71fbde"}
{"test": "import unittest\n\nclass TestEvaluateCodeString(unittest.TestCase):\n    \n    def test_valid_assignment_arithmetic(self):\n        # Test valid code with assignment and arithmetic\n        code = 'a = 5 + 3'\n        self.assertIsNone(evaluate_code_string(code))\n    \n    def test_valid_multiple_statements(self):\n        # Test valid multiple statements\n        code = 'x=1; y=2; z=x*y'\n        self.assertIsNone(evaluate_code_string(code))\n    \n    def test_valid_if_statement(self):\n        # Test valid if statement\n        code = 'if True: a=1'\n        self.assertIsNone(evaluate_code_string(code))\n    \n    def test_valid_for_loop(self):\n        # Test valid for loop without function calls\n        code = 'for i in [1,2,3]:\\n    x = i'\n        self.assertIsNone(evaluate_code_string(code))\n    \n    def test_valid_class_without_methods(self):\n        # Test valid class without methods\n        code = 'class A: pass'\n        self.assertIsNone(evaluate_code_string(code))\n    \n    def test_valid_lambda(self):\n        # Test valid lambda expression (without calling)\n        code = 'f = lambda x: x+1'\n        self.assertIsNone(evaluate_code_string(code))\n    \n    def test_valid_list_comprehension(self):\n        # Test valid list comprehension without function calls\n        code = 'a = [x for x in [1,2,3]]'\n        self.assertIsNone(evaluate_code_string(code))\n    \n    def test_invalid_import(self):\n        # Test import statement\n        code = 'import os'\n        with self.assertRaises(ValueError):\n            evaluate_code_string(code)\n    \n    def test_invalid_import_from(self):\n        # Test from import\n        code = 'from math import sqrt'\n        with self.assertRaises(ValueError):\n            evaluate_code_string(code)\n    \n    def test_invalid_function_def(self):\n        # Test function definition\n        code = 'def f(): pass'\n        with self.assertRaises(ValueError):\n            evaluate_code_string(code)\n    \n    def test_invalid_function_call(self):\n        # Test function call (built-in)\n        code = 'abs(-1)'\n        with self.assertRaises(ValueError):\n            evaluate_code_string(code)\n    \n    def test_invalid_method_call(self):\n        # Test method call\n        code = '\\'hello\\'.upper()'\n        with self.assertRaises(ValueError):\n            evaluate_code_string(code)\n    \n    def test_invalid_class_with_method(self):\n        # Test class with a method\n        code = 'class A:\\n    def f(self): pass'\n        with self.assertRaises(ValueError):\n            evaluate_code_string(code)\n    \n    def test_invalid_list_comprehension_with_call(self):\n        # Test list comprehension with call\n        code = 'a = [str(x) for x in [1,2,3]]'\n        with self.assertRaises(ValueError):\n            evaluate_code_string(code)\n    \n    def test_empty_string(self):\n        # Test empty string\n        code = ''\n        self.assertIsNone(evaluate_code_string(code))\n    \n    def test_whitespace_string(self):\n        # Test whitespace string\n        code = '   '\n        self.assertIsNone(evaluate_code_string(code))\n    \n    def test_comment_string(self):\n        # Test comment string\n        code = '# This is a comment'\n        self.assertIsNone(evaluate_code_string(code))\n    \n    def test_disallowed_in_comment(self):\n        # Test disallowed operation in comment\n        code = '# import os\\nx=1'\n        self.assertIsNone(evaluate_code_string(code))\n    \n    def test_syntax_error(self):\n        # Test invalid syntax\n        code = 'x = '\n        with self.assertRaises(ValueError):\n            evaluate_code_string(code)\n    \n    def test_non_string_input_none(self):\n        # Test None input\n        with self.assertRaises(ValueError):\n            evaluate_code_string(None)\n    \n    def test_non_string_input_integer(self):\n        # Test integer input\n        with self.assertRaises(ValueError):\n            evaluate_code_string(123)\n    \n    def test_long_valid_string(self):\n        # Test long valid string\n        code = 'a = 1;' * 1000\n        self.assertIsNone(evaluate_code_string(code))\n    \n    def test_lambda_and_call(self):\n        # Test defining lambda and calling\n        code = 'f = lambda x: x+1; f(1)'\n        with self.assertRaises(ValueError):\n            evaluate_code_string(code)\n    \n    def test_reference_function_without_call(self):\n        # Test referencing function without call\n        code = 'x = abs'\n        self.assertIsNone(evaluate_code_string(code))\n    \n    def test_call_in_class_body(self):\n        # Test call in class body\n        code = 'class A:\\n    x = abs(-1)'\n        with self.assertRaises(ValueError):\n            evaluate_code_string(code)\n    \n    def test_nested_disallowed(self):\n        # Test nested disallowed operation\n        code = 'if True:\\n    import os'\n        with self.assertRaises(ValueError):\n            evaluate_code_string(code)\n    \n    def test_function_def_in_try(self):\n        # Test function definition in try block\n        code = 'try:\\n    def f(): pass\\nexcept: pass'\n        with self.assertRaises(ValueError):\n            evaluate_code_string(code)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 27, "task_id": "c3785f14"}
{"test": "import unittest\nimport ast\n\nclass TestProcessCodeInput(unittest.TestCase):\n\n    def test_allowed_assignment(self):\n        # Test simple assignment\n        code = \"x = 5\"\n        result = process_code_input(code)\n        self.assertIsNone(result)\n\n    def test_allowed_arithmetic(self):\n        # Test arithmetic expression\n        code = \"result = 10 * 2\"\n        result = process_code_input(code)\n        self.assertIsNone(result)\n\n    def test_empty_string(self):\n        # Test empty code string\n        code = \"\"\n        result = process_code_input(code)\n        self.assertIsNone(result)\n\n    def test_disallowed_import(self):\n        # Test import statement\n        code = \"import os\"\n        with self.assertRaises(ValueError):\n            process_code_input(code)\n\n    def test_disallowed_function_def(self):\n        # Test function definition\n        code = \"def my_func(): pass\"\n        with self.assertRaises(ValueError):\n            process_code_input(code)\n\n    def test_disallowed_call_print(self):\n        # Test function call (print)\n        code = \"print('hello')\"\n        with self.assertRaises(ValueError):\n            process_code_input(code)\n\n    def test_disallowed_call_len(self):\n        # Test function call (len)\n        code = \"len([1,2,3])\"\n        with self.assertRaises(ValueError):\n            process_code_input(code)\n\n    def test_syntax_error(self):\n        # Test code with syntax error\n        code = \"x = \"  # Incomplete statement\n        with self.assertRaises(ValueError):\n            process_code_input(code)\n\n    def test_runtime_error(self):\n        # Test code causing runtime error\n        code = \"1 / 0\"  # Division by zero\n        with self.assertRaises(ValueError):\n            process_code_input(code)\n\n    def test_nested_disallowed(self):\n        # Test nested disallowed operation\n        code = \"if True:\\n    import os\"\n        with self.assertRaises(ValueError):\n            process_code_input(code)\n\n    def test_allowed_class_definition(self):\n        # Test class definition\n        code = \"class MyClass:\\n    pass\"\n        result = process_code_input(code)\n        self.assertIsNone(result)\n\n    def test_allowed_if_statement(self):\n        # Test if statement\n        code = \"if True:\\n    x = 1\"\n        result = process_code_input(code)\n        self.assertIsNone(result)\n\n    def test_disallowed_import_from(self):\n        # Test import from statement\n        code = \"from math import sqrt\"\n        with self.assertRaises(ValueError):\n            process_code_input(code)\n\n    def test_disallowed_call_in_expression(self):\n        # Test function call within expression\n        code = \"x = len([1,2,3]) * 2\"\n        with self.assertRaises(ValueError):\n            process_code_input(code)\n\n    def test_disallowed_nested_function_def(self):\n        # Test nested function definition\n        code = \"if True:\\n    def nested_func(): pass\"\n        with self.assertRaises(ValueError):\n            process_code_input(code)\n\n    def test_assignment_with_expression(self):\n        # Test assignment with complex expression\n        code = \"a = (5 + 3) * (10 - 2)\"\n        result = process_code_input(code)\n        self.assertIsNone(result)\n\n    def test_multiline_allowed_code(self):\n        # Test multiline allowed code\n        code = \"x = 5\\ny = 10\\nz = x * y\"\n        result = process_code_input(code)\n        self.assertIsNone(result)\n\n    def test_disallowed_inside_class(self):\n        # Test disallowed operation inside allowed class\n        code = \"class MyClass:\\n    def method(self): pass\"\n        with self.assertRaises(ValueError):\n            process_code_input(code)\n\n    def test_disallowed_inside_if(self):\n        # Test disallowed call inside if block\n        code = \"if True:\\n    print('inside')\"\n        with self.assertRaises(ValueError):\n            process_code_input(code)\n\n    def test_while_loop_allowed(self):\n        # Test allowed while loop\n        code = \"i = 0\\nwhile i < 5:\\n    i += 1\"\n        result = process_code_input(code)\n        self.assertIsNone(result)\n\n    def test_disallowed_in_loop(self):\n        # Test disallowed operation in loop\n        code = \"for i in range(5):\\n    import os\"\n        with self.assertRaises(ValueError):\n            process_code_input(code)\n\n    def test_list_comprehension(self):\n        # Test allowed list comprehension\n        code = \"squares = [x**2 for x in range(10)]\"\n        result = process_code_input(code)\n        self.assertIsNone(result)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 22, "task_id": "10b87c4c"}
{"test": "import unittest\n\nclass TestHandleUserExpression(unittest.TestCase):\n    \n    def test_valid_addition(self):\n        # Test simple addition\n        result = handle_user_expression('1+1')\n        self.assertEqual(result, 2)\n        self.assertIsInstance(result, int)\n    \n    def test_valid_multiplication(self):\n        # Test multiplication with spaces\n        result = handle_user_expression(' 2 * 3 ')\n        self.assertEqual(result, 6)\n        self.assertIsInstance(result, int)\n    \n    def test_valid_subtraction(self):\n        # Test subtraction\n        result = handle_user_expression('10 - 5')\n        self.assertEqual(result, 5)\n        self.assertIsInstance(result, int)\n    \n    def test_valid_division_integer_result(self):\n        # Test division resulting in whole number\n        result = handle_user_expression('8 / 2')\n        self.assertEqual(result, 4.0)\n        self.assertIsInstance(result, float)\n    \n    def test_valid_division_float_result(self):\n        # Test division resulting in float\n        result = handle_user_expression('5 / 2')\n        self.assertEqual(result, 2.5)\n        self.assertIsInstance(result, float)\n    \n    def test_operator_precedence_1(self):\n        # Test operator precedence: multiplication before addition\n        result = handle_user_expression('2 + 3 * 4')\n        self.assertEqual(result, 14)\n    \n    def test_operator_precedence_2(self):\n        # Test operator precedence: multiplication and addition\n        result = handle_user_expression('2 * 3 + 4')\n        self.assertEqual(result, 10)\n    \n    def test_negative_multiplication(self):\n        # Test multiplication with negative number\n        result = handle_user_expression('5 * -3')\n        self.assertEqual(result, -15)\n    \n    def test_single_negative_number(self):\n        # Test single negative number\n        result = handle_user_expression('-5')\n        self.assertEqual(result, -5)\n    \n    def test_exponentiation(self):\n        # Test exponentiation (allowed by regex)\n        result = handle_user_expression('2**3')\n        self.assertEqual(result, 8)\n    \n    def test_single_number(self):\n        # Test single number input\n        result = handle_user_expression('42')\n        self.assertEqual(result, 42)\n    \n    def test_empty_string(self):\n        # Test empty string (invalid expression)\n        with self.assertRaises(ValueError) as context:\n            handle_user_expression('')\n        self.assertEqual(str(context.exception), 'Invalid expression')\n    \n    def test_only_spaces(self):\n        # Test expression with only spaces (eval error)\n        with self.assertRaises(ValueError) as context:\n            handle_user_expression('   ')\n        self.assertIn('Error processing expression', str(context.exception))\n    \n    def test_division_by_zero(self):\n        # Test division by zero\n        with self.assertRaises(ValueError) as context:\n            handle_user_expression('1/0')\n        self.assertIn('division by zero', str(context.exception).lower())\n    \n    def test_incomplete_expression(self):\n        # Test incomplete expression\n        with self.assertRaises(ValueError) as context:\n            handle_user_expression('5 +')\n        self.assertIn('Error processing expression', str(context.exception))\n    \n    def test_two_numbers_without_operator(self):\n        # Test two numbers without operator\n        with self.assertRaises(ValueError) as context:\n            handle_user_expression('5 5')\n        self.assertIn('Error processing expression', str(context.exception))\n    \n    def test_invalid_character_letter(self):\n        # Test invalid character (letter)\n        with self.assertRaises(ValueError) as context:\n            handle_user_expression('a + 1')\n        self.assertEqual(str(context.exception), 'Invalid expression')\n    \n    def test_invalid_character_decimal_point(self):\n        # Test invalid character (decimal point)\n        with self.assertRaises(ValueError) as context:\n            handle_user_expression('1 + 2.5')\n        self.assertEqual(str(context.exception), 'Invalid expression')\n    \n    def test_invalid_character_parentheses(self):\n        # Test invalid character (parentheses)\n        with self.assertRaises(ValueError) as context:\n            handle_user_expression('1 + (2 * 3)')\n        self.assertEqual(str(context.exception), 'Invalid expression')\n    \n    def test_invalid_character_semicolon(self):\n        # Test invalid character (semicolon)\n        with self.assertRaises(ValueError) as context:\n            handle_user_expression('1 + 2;')\n        self.assertEqual(str(context.exception), 'Invalid expression')\n    \n    def test_multiple_consecutive_minus(self):\n        # Test multiple consecutive minus signs\n        result = handle_user_expression('5--3')\n        self.assertEqual(result, 8)\n    \n    def test_multiple_consecutive_plus(self):\n        # Test multiple consecutive plus signs\n        result = handle_user_expression('5++3')\n        self.assertEqual(result, 8)\n    \n    def test_multiple_consecutive_minus_three(self):\n        # Test three consecutive minus signs\n        result = handle_user_expression('5---3')\n        self.assertEqual(result, 2)\n    \n    def test_invalid_consecutive_operators(self):\n        # Test invalid consecutive operators\n        with self.assertRaises(ValueError) as context:\n            handle_user_expression('5++')\n        self.assertIn('Error processing expression', str(context.exception))", "num_test_cases": 24, "task_id": "4cc5ca0c"}
{"test": "import unittest\n\nclass TestCalculateFromInput(unittest.TestCase):\n\n    def test_valid_addition(self):\n        # Test simple addition\n        self.assertEqual(calculate_from_input('2+3'), 5)\n\n    def test_valid_subtraction(self):\n        # Test simple subtraction\n        self.assertEqual(calculate_from_input('5-3'), 2)\n\n    def test_valid_multiplication(self):\n        # Test multiplication\n        self.assertEqual(calculate_from_input('2*3'), 6)\n\n    def test_valid_division(self):\n        # Test division\n        self.assertEqual(calculate_from_input('6/3'), 2.0)\n\n    def test_valid_with_spaces(self):\n        # Test expression with spaces\n        self.assertEqual(calculate_from_input(' 10 + 20 '), 30)\n\n    def test_valid_multiplication_large(self):\n        # Test large multiplication\n        self.assertEqual(calculate_from_input('10*20'), 200)\n\n    def test_valid_unary_negative(self):\n        # Test unary negative\n        self.assertEqual(calculate_from_input('-5'), -5)\n\n    def test_valid_subtraction_negative_result(self):\n        # Test subtraction resulting in negative\n        self.assertEqual(calculate_from_input('5-10'), -5)\n\n    def test_valid_double_negative(self):\n        # Test double negative\n        self.assertEqual(calculate_from_input('5 - -3'), 8)\n\n    def test_valid_large_numbers(self):\n        # Test very large numbers\n        self.assertEqual(calculate_from_input('1000000 * 1000000'), 1000000000000)\n\n    def test_valid_unary_negative_with_space(self):\n        # Test unary negative with space\n        self.assertEqual(calculate_from_input(' - 5'), -5)\n\n    def test_invalid_empty_string(self):\n        # Test empty string input\n        with self.assertRaises(ValueError) as cm:\n            calculate_from_input('')\n        self.assertEqual(str(cm.exception), 'Invalid user_input')\n\n    def test_invalid_only_spaces(self):\n        # Test input with only spaces\n        with self.assertRaises(ValueError) as cm:\n            calculate_from_input('   ')\n        self.assertIn('Error processing user_input', str(cm.exception))\n\n    def test_invalid_letter(self):\n        # Test invalid character (letter)\n        with self.assertRaises(ValueError) as cm:\n            calculate_from_input('a')\n        self.assertEqual(str(cm.exception), 'Invalid user_input')\n\n    def test_invalid_parentheses(self):\n        # Test invalid character (parentheses)\n        with self.assertRaises(ValueError) as cm:\n            calculate_from_input('(5)')\n        self.assertEqual(str(cm.exception), 'Invalid user_input')\n\n    def test_invalid_dot(self):\n        # Test invalid character (dot)\n        with self.assertRaises(ValueError) as cm:\n            calculate_from_input('5.5')\n        self.assertEqual(str(cm.exception), 'Invalid user_input')\n\n    def test_invalid_comma(self):\n        # Test invalid character (comma)\n        with self.assertRaises(ValueError) as cm:\n            calculate_from_input('1,000')\n        self.assertEqual(str(cm.exception), 'Invalid user_input')\n\n    def test_invalid_percent(self):\n        # Test invalid character (percent)\n        with self.assertRaises(ValueError) as cm:\n            calculate_from_input('10%')\n        self.assertEqual(str(cm.exception), 'Invalid user_input')\n\n    def test_invalid_syntax_incomplete(self):\n        # Test incomplete expression syntax\n        with self.assertRaises(ValueError) as cm:\n            calculate_from_input('5+')\n        self.assertIn('Error processing user_input', str(cm.exception))\n\n    def test_invalid_operator_sequence(self):\n        # Test invalid operator sequence\n        with self.assertRaises(ValueError) as cm:\n            calculate_from_input('5 * / 3')\n        self.assertIn('Error processing user_input', str(cm.exception))\n\n    def test_invalid_division_by_zero(self):\n        # Test division by zero\n        with self.assertRaises(ValueError) as cm:\n            calculate_from_input('1/0')\n        self.assertIn('Error processing user_input', str(cm.exception))\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 21, "task_id": "abe2c24d"}
{"test": "import unittest\n\nclass TestEvaluateUserMath(unittest.TestCase):\n\n    def test_valid_addition(self):\n        # Test simple addition\n        self.assertEqual(evaluate_user_math(\"2 + 3\"), 5.0)\n\n    def test_valid_subtraction(self):\n        # Test simple subtraction\n        self.assertEqual(evaluate_user_math(\"10 - 5\"), 5.0)\n\n    def test_valid_multiplication(self):\n        # Test simple multiplication\n        self.assertEqual(evaluate_user_math(\"3 * 4\"), 12.0)\n\n    def test_valid_division(self):\n        # Test simple division\n        self.assertEqual(evaluate_user_math(\"10 / 2\"), 5.0)\n\n    def test_expression_with_spaces(self):\n        # Test expression with extra whitespace\n        self.assertEqual(evaluate_user_math(\"  2   + 3  \"), 5.0)\n\n    def test_operator_precedence(self):\n        # Test operator precedence (multiplication before addition)\n        self.assertEqual(evaluate_user_math(\"2 + 3 * 4\"), 14.0)\n\n    def test_parentheses_not_allowed(self):\n        # Test expression with invalid parentheses\n        with self.assertRaises(ValueError):\n            evaluate_user_math(\"(2 + 3) * 4\")\n\n    def test_empty_string(self):\n        # Test empty input string\n        with self.assertRaises(ValueError):\n            evaluate_user_math(\"\")\n\n    def test_only_spaces(self):\n        # Test input with only whitespace\n        with self.assertRaises(ValueError):\n            evaluate_user_math(\"    \")\n\n    def test_division_by_zero(self):\n        # Test division by zero\n        with self.assertRaises(ValueError):\n            evaluate_user_math(\"5 / 0\")\n\n    def test_invalid_characters(self):\n        # Test expression with invalid characters (letters)\n        with self.assertRaises(ValueError):\n            evaluate_user_math(\"2 + a\")\n\n    def test_float_number_in_expression(self):\n        # Test expression with float literal (invalid character '.')\n        with self.assertRaises(ValueError):\n            evaluate_user_math(\"3.5 * 2\")\n\n    def test_invalid_expression_syntax(self):\n        # Test malformed expression with consecutive operators\n        with self.assertRaises(ValueError):\n            evaluate_user_math(\"2 + +\")\n\n    def test_negative_number_at_start(self):\n        # Test negative number at beginning of expression\n        self.assertEqual(evaluate_user_math(\"-5 + 3\"), -2.0)\n\n    def test_negative_number_in_middle(self):\n        # Test negative number in middle of expression\n        self.assertEqual(evaluate_user_math(\"5 * -3\"), -15.0)\n\n    def test_exponentiation(self):\n        # Test exponentiation operator (allowed by regex but not explicitly permitted)\n        self.assertEqual(evaluate_user_math(\"2**3\"), 8.0)\n\n    def test_long_expression(self):\n        # Test long valid expression\n        expr = \"1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9\"\n        self.assertEqual(evaluate_user_math(expr), 45.0)\n\n    def test_mixed_operators(self):\n        # Test expression with mixed operators and precedence\n        self.assertAlmostEqual(evaluate_user_math(\"10 + 20 * 3 - 5 / 2\"), 67.5)\n\n    def test_valid_double_minus(self):\n        # Test valid consecutive operators (double minus)\n        self.assertEqual(evaluate_user_math(\"2--3\"), 5.0)\n\n    def test_valid_double_plus(self):\n        # Test valid consecutive operators (double plus)\n        self.assertEqual(evaluate_user_math(\"2++3\"), 5.0)\n\n    def test_invalid_consecutive_ops(self):\n        # Test invalid consecutive operators\n        with self.assertRaises(ValueError):\n            evaluate_user_math(\"2*/3\")\n\n    def test_expression_ending_with_operator(self):\n        # Test expression ending with operator\n        with self.assertRaises(ValueError):\n            evaluate_user_math(\"2+\")", "num_test_cases": 22, "task_id": "11926462"}
{"test": "import unittest\n\nclass TestEvaluateUserExpression(unittest.TestCase):\n    def test_valid_addition(self):\n        # Test basic addition\n        self.assertEqual(evaluate_user_expression(\"2+3\"), 5)\n\n    def test_division_and_multiplication(self):\n        # Test division and multiplication operations\n        self.assertEqual(evaluate_user_expression(\"6 / 3 * 2\"), 4.0)\n\n    def test_subtraction_negative_result(self):\n        # Test subtraction resulting in negative number\n        self.assertEqual(evaluate_user_expression(\"5-10\"), -5)\n\n    def test_spaces(self):\n        # Test expression with spaces\n        self.assertEqual(evaluate_user_expression(\"  2 * 3  \"), 6)\n\n    def test_large_numbers(self):\n        # Test multiplication of large integers\n        self.assertEqual(evaluate_user_expression(\"1000000*1000000\"), 1000000000000)\n\n    def test_division_by_zero(self):\n        # Test division by zero which should raise ValueError\n        with self.assertRaises(ValueError) as cm:\n            evaluate_user_expression(\"10/0\")\n        self.assertTrue(str(cm.exception).startswith(\"Error processing expression\"))\n        self.assertIn(\"division by zero\", str(cm.exception))\n\n    def test_invalid_character(self):\n        # Test expression containing invalid character\n        with self.assertRaises(ValueError) as cm:\n            evaluate_user_expression(\"2 + a\")\n        self.assertEqual(str(cm.exception), \"Invalid expression\")\n\n    def test_syntax_error(self):\n        # Test expression with invalid syntax\n        with self.assertRaises(ValueError) as cm:\n            evaluate_user_expression(\"2 + * 3\")\n        self.assertTrue(str(cm.exception).startswith(\"Error processing expression\"))\n\n    def test_empty_string(self):\n        # Test empty input string\n        with self.assertRaises(ValueError) as cm:\n            evaluate_user_expression(\"\")\n        self.assertEqual(str(cm.exception), \"Invalid expression\")\n\n    def test_only_spaces(self):\n        # Test string containing only spaces\n        with self.assertRaises(ValueError) as cm:\n            evaluate_user_expression(\"   \")\n        self.assertTrue(str(cm.exception).startswith(\"Error processing expression\"))\n\n    def test_unary_minus(self):\n        # Test unary minus operation\n        self.assertEqual(evaluate_user_expression(\"-5\"), -5)\n\n    def test_negative_in_expression(self):\n        # Test expression with negative number\n        self.assertEqual(evaluate_user_expression(\"5 + -3\"), 2)\n\n    def test_exponentiation(self):\n        # Test exponentiation operation (allowed by regex)\n        self.assertEqual(evaluate_user_expression(\"2 ** 3\"), 8)\n\n    def test_mixed_operations(self):\n        # Test mixed operations with precedence\n        self.assertEqual(evaluate_user_expression(\"10+5*2-10/2\"), 15.0)\n\n    def test_invalid_character_ampersand(self):\n        # Test expression with invalid ampersand character\n        with self.assertRaises(ValueError) as cm:\n            evaluate_user_expression(\"3 & 4\")\n        self.assertEqual(str(cm.exception), \"Invalid expression\")\n\n    def test_float_number_not_allowed(self):\n        # Test expression with float literal (disallowed by regex)\n        with self.assertRaises(ValueError) as cm:\n            evaluate_user_expression(\"3.14\")\n        self.assertEqual(str(cm.exception), \"Invalid expression\")\n\n    def test_division_result_float(self):\n        # Test division resulting in float\n        self.assertEqual(evaluate_user_expression(\"5/2\"), 2.5)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 17, "task_id": "54a8fe69"}
{"test": "import unittest\n\nclass TestSafeEvalExpression(unittest.TestCase):\n    def test_case_1(self):\n        # Test addition: 1+1=2\n        self.assertEqual(safe_eval_expression(\"1+1\"), 2)\n\n    def test_case_2(self):\n        # Test subtraction: 5-3=2\n        self.assertEqual(safe_eval_expression(\"5-3\"), 2)\n\n    def test_case_3(self):\n        # Test multiplication: 2*3=6\n        self.assertEqual(safe_eval_expression(\"2*3\"), 6)\n\n    def test_case_4(self):\n        # Test division: 6/2=3.0\n        self.assertEqual(safe_eval_expression(\"6/2\"), 3.0)\n\n    def test_case_5(self):\n        # Test operator precedence: 2+3*4=14\n        self.assertEqual(safe_eval_expression(\"2+3*4\"), 14)\n\n    def test_case_6(self):\n        # Test expression with surrounding spaces\n        self.assertEqual(safe_eval_expression(\"  2 + 3  \"), 5)\n\n    def test_case_7(self):\n        # Test negative number: -5+2=-3\n        self.assertEqual(safe_eval_expression(\"-5+2\"), -3)\n\n    def test_case_8(self):\n        # Test double negative: 5--3=8\n        self.assertEqual(safe_eval_expression(\"5--3\"), 8)\n\n    def test_case_9(self):\n        # Test exponentiation: 2**3=8\n        self.assertEqual(safe_eval_expression(\"2**3\"), 8)\n\n    def test_case_10(self):\n        # Test empty string input\n        with self.assertRaises(ValueError) as cm:\n            safe_eval_expression(\"\")\n        self.assertEqual(str(cm.exception), \"Invalid expression\")\n\n    def test_case_11(self):\n        # Test expression with only spaces\n        with self.assertRaises(ValueError) as cm:\n            safe_eval_expression(\"   \")\n        self.assertIn(\"Error processing expression\", str(cm.exception))\n\n    def test_case_12(self):\n        # Test very long expression\n        expr = \"1\" + \"+1\" * 1000\n        self.assertEqual(safe_eval_expression(expr), 1001)\n\n    def test_case_13(self):\n        # Test division by zero\n        with self.assertRaises(ValueError) as cm:\n            safe_eval_expression(\"1/0\")\n        self.assertIn(\"Error processing expression\", str(cm.exception))\n\n    def test_case_14(self):\n        # Test invalid letter in expression\n        with self.assertRaises(ValueError) as cm:\n            safe_eval_expression(\"1 + a\")\n        self.assertEqual(str(cm.exception), \"Invalid expression\")\n\n    def test_case_15(self):\n        # Test decimal point in expression\n        with self.assertRaises(ValueError) as cm:\n            safe_eval_expression(\"1.5 + 2\")\n        self.assertEqual(str(cm.exception), \"Invalid expression\")\n\n    def test_case_16(self):\n        # Test parentheses in expression\n        with self.assertRaises(ValueError) as cm:\n            safe_eval_expression(\"2*(3+4)\")\n        self.assertEqual(str(cm.exception), \"Invalid expression\")\n\n    def test_case_17(self):\n        # Test invalid consecutive operators: * /\n        with self.assertRaises(ValueError) as cm:\n            safe_eval_expression(\"5 * / 3\")\n        self.assertIn(\"Error processing expression\", str(cm.exception))\n\n    def test_case_18(self):\n        # Test valid consecutive operators: +-\n        self.assertEqual(safe_eval_expression(\"5+-3\"), 2)\n\n    def test_case_19(self):\n        # Test valid consecutive operators: ++\n        self.assertEqual(safe_eval_expression(\"5++3\"), 8)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 19, "task_id": "f7ba502d"}
{"test": "import unittest\nimport re\n\nclass TestCalculateUserInput(unittest.TestCase):\n    def test_simple_addition(self):\n        # Test basic addition\n        result = calculate_user_input('2+2')\n        self.assertEqual(result, 4)\n    \n    def test_spaces(self):\n        # Test expression with spaces\n        result = calculate_user_input(' 3 * 4 ')\n        self.assertEqual(result, 12)\n    \n    def test_division(self):\n        # Test division operation\n        result = calculate_user_input('10/2')\n        self.assertEqual(result, 5.0)\n    \n    def test_operation_order(self):\n        # Test operator precedence\n        result = calculate_user_input('5-3*2')\n        self.assertEqual(result, -1)\n    \n    def test_single_number(self):\n        # Test single number input\n        result = calculate_user_input('42')\n        self.assertEqual(result, 42)\n    \n    def test_negative_number(self):\n        # Test negative number\n        result = calculate_user_input('-5')\n        self.assertEqual(result, -5)\n    \n    def test_expression_with_negative(self):\n        # Test expression with negative operand\n        result = calculate_user_input('3 * -2')\n        self.assertEqual(result, -6)\n    \n    def test_empty_string(self):\n        # Test empty input string\n        with self.assertRaises(ValueError) as context:\n            calculate_user_input('')\n        self.assertEqual(str(context.exception), 'Invalid input')\n    \n    def test_whitespace_only(self):\n        # Test whitespace-only input\n        with self.assertRaises(ValueError) as context:\n            calculate_user_input('   ')\n        self.assertIn('Error processing input', str(context.exception))\n    \n    def test_invalid_character(self):\n        # Test invalid character in input\n        with self.assertRaises(ValueError) as context:\n            calculate_user_input('a')\n        self.assertEqual(str(context.exception), 'Invalid input')\n    \n    def test_decimal_point(self):\n        # Test decimal point (disallowed)\n        with self.assertRaises(ValueError) as context:\n            calculate_user_input('1.5')\n        self.assertEqual(str(context.exception), 'Invalid input')\n    \n    def test_division_by_zero(self):\n        # Test division by zero\n        with self.assertRaises(ValueError) as context:\n            calculate_user_input('1/0')\n        self.assertIn('division by zero', str(context.exception))\n    \n    def test_syntax_error(self):\n        # Test invalid expression syntax\n        with self.assertRaises(ValueError) as context:\n            calculate_user_input('2 + * 3')\n        self.assertIn('Error processing input', str(context.exception))\n    \n    def test_exponentiation(self):\n        # Test exponentiation operation\n        result = calculate_user_input('2**3')\n        self.assertEqual(result, 8)\n    \n    def test_parentheses(self):\n        # Test parentheses (disallowed characters)\n        with self.assertRaises(ValueError) as context:\n            calculate_user_input('(2+3)*4')\n        self.assertEqual(str(context.exception), 'Invalid input')\n    \n    def test_consecutive_operators(self):\n        # Test valid consecutive operators\n        result = calculate_user_input('2--3')\n        self.assertEqual(result, 5)\n    \n    def test_expression_ending_with_operator(self):\n        # Test incomplete expression\n        with self.assertRaises(ValueError) as context:\n            calculate_user_input('2+')\n        self.assertIn('Error processing input', str(context.exception))", "num_test_cases": 17, "task_id": "7c84e2c8"}
{"test": "import unittest\n\nclass TestCalculateUserInput(unittest.TestCase):\n    \n    def test_valid_addition(self):\n        # Test basic addition\n        self.assertEqual(calculate_user_input(\"2+3\"), 5)\n    \n    def test_valid_subtraction(self):\n        # Test basic subtraction\n        self.assertEqual(calculate_user_input(\"5-3\"), 2)\n    \n    def test_valid_multiplication(self):\n        # Test basic multiplication\n        self.assertEqual(calculate_user_input(\"2*3\"), 6)\n    \n    def test_valid_division(self):\n        # Test basic division\n        self.assertEqual(calculate_user_input(\"6/3\"), 2.0)\n    \n    def test_with_spaces(self):\n        # Test expression with spaces\n        self.assertEqual(calculate_user_input(\" 2 + 3 \"), 5)\n    \n    def test_single_negative(self):\n        # Test single negative number\n        self.assertEqual(calculate_user_input(\"-5\"), -5)\n    \n    def test_negative_in_expression(self):\n        # Test negative number in expression\n        self.assertEqual(calculate_user_input(\"5 * -3\"), -15)\n    \n    def test_multiple_operators(self):\n        # Test multiple consecutive operators (valid)\n        self.assertEqual(calculate_user_input(\"5--3\"), 8)  # 5 - (-3) = 8\n    \n    def test_single_number(self):\n        # Test single number input\n        self.assertEqual(calculate_user_input(\"42\"), 42)\n    \n    def test_large_numbers(self):\n        # Test with large numbers\n        self.assertEqual(calculate_user_input(\"1000000000 + 2000000000\"), 3000000000)\n    \n    def test_division_by_zero(self):\n        # Test division by zero\n        with self.assertRaises(ValueError) as context:\n            calculate_user_input(\"1/0\")\n        self.assertIn(\"division by zero\", str(context.exception))\n    \n    def test_incomplete_expression(self):\n        # Test incomplete expression\n        with self.assertRaises(ValueError):\n            calculate_user_input(\"5+\")\n    \n    def test_two_numbers_without_operator(self):\n        # Test two numbers without operator\n        with self.assertRaises(ValueError):\n            calculate_user_input(\"5 5\")\n    \n    def test_invalid_character_letters(self):\n        # Test invalid characters (letters)\n        with self.assertRaises(ValueError) as context:\n            calculate_user_input(\"a + 3\")\n        self.assertEqual(str(context.exception), \"Invalid expression\")\n    \n    def test_invalid_character_decimal(self):\n        # Test invalid characters (decimal point)\n        with self.assertRaises(ValueError) as context:\n            calculate_user_input(\"2.5 + 3.7\")\n        self.assertEqual(str(context.exception), \"Invalid expression\")\n    \n    def test_invalid_character_parentheses(self):\n        # Test invalid characters (parentheses)\n        with self.assertRaises(ValueError) as context:\n            calculate_user_input(\"(2+3)*4\")\n        self.assertEqual(str(context.exception), \"Invalid expression\")\n    \n    def test_empty_string(self):\n        # Test empty string input\n        with self.assertRaises(ValueError) as context:\n            calculate_user_input(\"\")\n        self.assertEqual(str(context.exception), \"Invalid expression\")\n    \n    def test_only_spaces(self):\n        # Test whitespace-only input\n        with self.assertRaises(ValueError) as context:\n            calculate_user_input(\"   \")\n        self.assertTrue(str(context.exception).startswith(\"Error processing expression: \"))\n    \n    def test_operator_precedence(self):\n        # Test operator precedence (multiplication before addition)\n        self.assertEqual(calculate_user_input(\"5+3*2\"), 11)  # 5 + (3*2) = 11\n    \n    def test_mixed_operations(self):\n        # Test mixed operations with precedence\n        self.assertEqual(calculate_user_input(\"10 + 2 * 3 / 2\"), 13.0)  # 10 + (2*3)/2 = 13.0\n    \n    def test_complex_expression(self):\n        # Test complex expression with valid operators\n        self.assertEqual(calculate_user_input(\"10*2 - 6/3 + 5\"), 23.0)  # 20 - 2 + 5 = 23\n    \n    def test_leading_plus(self):\n        # Test expression with leading plus\n        self.assertEqual(calculate_user_input(\"+10 - 5\"), 5)\n    \n    def test_multiple_division(self):\n        # Test multiple divisions\n        self.assertEqual(calculate_user_input(\"100 / 10 / 2\"), 5.0)\n    \n    def test_large_expression(self):\n        # Test large valid expression\n        expr = \"1000000\" + \"*2\" * 10\n        self.assertEqual(calculate_user_input(expr), 1024000000)\n    \n    def test_invalid_character_symbol(self):\n        # Test invalid symbol ($)\n        with self.assertRaises(ValueError) as context:\n            calculate_user_input(\"5 $ 3\")\n        self.assertEqual(str(context.exception), \"Invalid expression\")\n    \n    def test_invalid_character_comma(self):\n        # Test invalid character (comma)\n        with self.assertRaises(ValueError) as context:\n            calculate_user_input(\"5,000 + 3,000\")\n        self.assertEqual(str(context.exception), \"Invalid expression\")\n    \n    def test_invalid_operator_sequence(self):\n        # Test invalid operator sequence\n        with self.assertRaises(ValueError):\n            calculate_user_input(\"5 + * 3\")\n    \n    def test_negative_at_start_with_operator(self):\n        # Test negative sign at start with operator\n        self.assertEqual(calculate_user_input(\"-10 + 20\"), 10)\n    \n    def test_negative_after_operator(self):\n        # Test negative sign after operator\n        self.assertEqual(calculate_user_input(\"10 * -2\"), -20)\n    \n    def test_multiple_negatives(self):\n        # Test multiple negative signs\n        self.assertEqual(calculate_user_input(\"10 - -5\"), 15)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 25, "task_id": "a74aea02"}
{"test": "import unittest\nfrom solution import evaluate_expression\n\nclass TestEvaluateExpression(unittest.TestCase):\n    def test_valid_addition(self):\n        # Test simple addition\n        self.assertEqual(evaluate_expression(\"2+3\"), 5)\n\n    def test_valid_subtraction(self):\n        # Test simple subtraction\n        self.assertEqual(evaluate_expression(\"5-3\"), 2)\n\n    def test_valid_multiplication(self):\n        # Test simple multiplication\n        self.assertEqual(evaluate_expression(\"2*3\"), 6)\n\n    def test_valid_division(self):\n        # Test simple division\n        self.assertEqual(evaluate_expression(\"6/2\"), 3.0)\n\n    def test_division_by_zero(self):\n        # Test division by zero\n        with self.assertRaises(ValueError):\n            evaluate_expression(\"5/0\")\n\n    def test_whitespace_handling(self):\n        # Test expression with surrounding whitespace\n        self.assertEqual(evaluate_expression(\" 2 + 3 \"), 5)\n\n    def test_negative_number(self):\n        # Test negative number at start\n        self.assertEqual(evaluate_expression(\"-5\"), -5)\n\n    def test_negative_in_expression(self):\n        # Test negative number in middle\n        self.assertEqual(evaluate_expression(\"5 * -3\"), -15)\n\n    def test_invalid_character_percent(self):\n        # Test invalid character '%'\n        with self.assertRaises(ValueError):\n            evaluate_expression(\"5%3\")\n\n    def test_invalid_character_letter(self):\n        # Test invalid character 'a'\n        with self.assertRaises(ValueError):\n            evaluate_expression(\"5 + a\")\n\n    def test_invalid_character_parenthesis(self):\n        # Test invalid parentheses\n        with self.assertRaises(ValueError):\n            evaluate_expression(\"(2+3)*4\")\n\n    def test_empty_string(self):\n        # Test empty expression\n        with self.assertRaises(ValueError):\n            evaluate_expression(\"\")\n\n    def test_only_whitespace(self):\n        # Test expression with only spaces\n        with self.assertRaises(ValueError):\n            evaluate_expression(\"   \")\n\n    def test_none_input(self):\n        # Test None input\n        with self.assertRaises(TypeError):\n            evaluate_expression(None)\n\n    def test_non_string_input(self):\n        # Test integer input\n        with self.assertRaises(TypeError):\n            evaluate_expression(123)\n\n    def test_large_numbers(self):\n        # Test with very large numbers\n        self.assertEqual(evaluate_expression(\"123456789012345678901234567890 * 10\"), 1234567890123456789012345678900)\n\n    def test_float_result(self):\n        # Test division resulting in float\n        self.assertEqual(evaluate_expression(\"5/2\"), 2.5)\n\n    def test_single_number(self):\n        # Test expression with single number\n        self.assertEqual(evaluate_expression(\"42\"), 42)\n\n    def test_operator_precedence(self):\n        # Test operator precedence\n        self.assertEqual(evaluate_expression(\"2+3*4\"), 14)\n\n    def test_incomplete_expression(self):\n        # Test incomplete expression\n        with self.assertRaises(ValueError):\n            evaluate_expression(\"5 +\")\n\n    def test_consecutive_operators(self):\n        # Test consecutive operators\n        with self.assertRaises(ValueError):\n            evaluate_expression(\"5 * * 3\")\n", "num_test_cases": 22, "task_id": "ebdf26bf"}
{"test": "import unittest\n\nclass TestComputeMathExpression(unittest.TestCase):\n    \n    def test_valid_addition(self):\n        # Test basic addition\n        result = compute_math_expression('1 + 1')\n        self.assertEqual(result, 2)\n        \n    def test_valid_subtraction(self):\n        # Test basic subtraction\n        result = compute_math_expression('5 - 3')\n        self.assertEqual(result, 2)\n        \n    def test_valid_multiplication(self):\n        # Test basic multiplication\n        result = compute_math_expression('2 * 3')\n        self.assertEqual(result, 6)\n        \n    def test_valid_division(self):\n        # Test basic division\n        result = compute_math_expression('8 / 2')\n        self.assertEqual(result, 4.0)\n        \n    def test_spaces_around_operands(self):\n        # Test expression with extra spaces\n        result = compute_math_expression('  10  -  7  ')\n        self.assertEqual(result, 3)\n        \n    def test_no_spaces_expression(self):\n        # Test expression without spaces\n        result = compute_math_expression('10-7')\n        self.assertEqual(result, 3)\n        \n    def test_operator_precedence(self):\n        # Test operator precedence (multiplication before addition)\n        result = compute_math_expression('2 + 3 * 4')\n        self.assertEqual(result, 14)\n        \n    def test_division_by_zero(self):\n        # Test division by zero\n        with self.assertRaises(ValueError) as context:\n            compute_math_expression('5 / 0')\n        self.assertTrue('Error processing expression:' in str(context.exception))\n        \n    def test_empty_string(self):\n        # Test empty input string\n        with self.assertRaises(ValueError) as context:\n            compute_math_expression('')\n        self.assertEqual(str(context.exception), 'Invalid expression')\n        \n    def test_whitespace_only(self):\n        # Test input with only whitespace\n        with self.assertRaises(ValueError) as context:\n            compute_math_expression('   ')\n        self.assertTrue('Error processing expression:' in str(context.exception))\n        \n    def test_invalid_character_letter(self):\n        # Test invalid character (letter)\n        with self.assertRaises(ValueError) as context:\n            compute_math_expression('a + 1')\n        self.assertEqual(str(context.exception), 'Invalid expression')\n        \n    def test_invalid_character_parentheses(self):\n        # Test invalid character (parentheses)\n        with self.assertRaises(ValueError) as context:\n            compute_math_expression('1 + (2 * 3)')\n        self.assertEqual(str(context.exception), 'Invalid expression')\n        \n    def test_invalid_syntax(self):\n        # Test invalid expression syntax\n        with self.assertRaises(ValueError) as context:\n            compute_math_expression('1 + * 2')\n        self.assertTrue('Error processing expression:' in str(context.exception))\n        \n    def test_negative_number(self):\n        # Test expression with negative number\n        result = compute_math_expression('-5 + 3')\n        self.assertEqual(result, -2)\n        \n    def test_decimal_point(self):\n        # Test invalid character (decimal point)\n        with self.assertRaises(ValueError) as context:\n            compute_math_expression('1.5 + 2.5')\n        self.assertEqual(str(context.exception), 'Invalid expression')\n        \n    def test_double_negative(self):\n        # Test expression with double negative\n        result = compute_math_expression('5 - -2')\n        self.assertEqual(result, 7)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 16, "task_id": "e4baba9f"}
{"test": "import unittest\n\nclass TestExecuteUserCode(unittest.TestCase):\n    \n    def test_empty_script(self):\n        # Test empty script (allowed)\n        result = execute_user_code(\"\")\n        self.assertIsNone(result)\n        \n    def test_simple_assignment(self):\n        # Test simple assignment (allowed)\n        script = \"x = 5\"\n        result = execute_user_code(script)\n        self.assertIsNone(result)\n        \n    def test_math_expression(self):\n        # Test mathematical expression (allowed)\n        script = \"result = 10 * 5 + 2\"\n        result = execute_user_code(script)\n        self.assertIsNone(result)\n        \n    def test_string_concatenation(self):\n        # Test string concatenation (allowed)\n        script = \"s = 'hello' + ' world'\"\n        result = execute_user_code(script)\n        self.assertIsNone(result)\n        \n    def test_safe_attribute_access(self):\n        # Test safe attribute access without call (allowed)\n        script = \"s = 'hello'; t = s.upper\"\n        result = execute_user_code(script)\n        self.assertIsNone(result)\n        \n    def test_import_statement(self):\n        # Test import statement (disallowed)\n        script = \"import os\"\n        with self.assertRaises(ValueError):\n            execute_user_code(script)\n        \n    def test_import_from(self):\n        # Test import from (disallowed)\n        script = \"from math import sqrt\"\n        with self.assertRaises(ValueError):\n            execute_user_code(script)\n        \n    def test_with_statement(self):\n        # Test with statement (disallowed)\n        script = \"with open('test.txt', 'w') as f: pass\"\n        with self.assertRaises(ValueError):\n            execute_user_code(script)\n        \n    def test_function_call(self):\n        # Test function call (disallowed)\n        script = \"print('hello')\"\n        with self.assertRaises(ValueError):\n            execute_user_code(script)\n        \n    def test_dangerous_attribute_open(self):\n        # Test dangerous attribute 'open' access (disallowed)\n        script = \"f = open\"\n        with self.assertRaises(ValueError):\n            execute_user_code(script)\n        \n    def test_dangerous_attribute_system(self):\n        # Test dangerous attribute 'system' access (disallowed)\n        script = \"import os; cmd = os.system\"\n        with self.assertRaises(ValueError):\n            execute_user_code(script)\n        \n    def test_syntax_error(self):\n        # Test script with syntax error\n        script = \"x = \"  # Incomplete assignment\n        with self.assertRaises(ValueError):\n            execute_user_code(script)\n        \n    def test_runtime_error(self):\n        # Test script causing runtime error (ZeroDivision)\n        script = \"1/0\"\n        with self.assertRaises(ValueError):\n            execute_user_code(script)\n        \n    def test_function_definition_allowed(self):\n        # Test function definition without disallowed internals (allowed)\n        script = \"def foo(): pass\"\n        result = execute_user_code(script)\n        self.assertIsNone(result)\n        \n    def test_function_definition_disallowed(self):\n        # Test function definition with disallowed import\n        script = \"def foo(): import os\"\n        with self.assertRaises(ValueError):\n            execute_user_code(script)\n        \n    def test_class_definition_allowed(self):\n        # Test class definition without disallowed internals (allowed)\n        script = \"class Foo: pass\"\n        result = execute_user_code(script)\n        self.assertIsNone(result)\n        \n    def test_class_definition_disallowed(self):\n        # Test class definition with disallowed import\n        script = \"class Foo:\\n    def __init__(self):\\n        import os\"\n        with self.assertRaises(ValueError):\n            execute_user_code(script)\n        \n    def test_class_instantiation_disallowed(self):\n        # Test class instantiation (call disallowed)\n        script = \"class Foo: pass\\nf = Foo()\"\n        with self.assertRaises(ValueError):\n            execute_user_code(script)\n        \n    def test_call_to_safe_attribute(self):\n        # Test call to safe attribute (upper()) - disallowed because call\n        script = \"'hello'.upper()\"\n        with self.assertRaises(ValueError):\n            execute_user_code(script)\n        \n    def test_multiline_disallowed(self):\n        # Test multiline script with disallowed operation\n        script = \"x = 5\\nimport os\"\n        with self.assertRaises(ValueError):\n            execute_user_code(script)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 20, "task_id": "2748ba47"}
{"test": "import unittest\n\nclass TestCases(unittest.TestCase):\n    def test_empty_script(self):\n        # Test empty script\n        result = safe_run_script('')\n        self.assertIsNone(result)\n\n    def test_simple_assignment(self):\n        # Test basic assignment\n        result = safe_run_script('x = 1')\n        self.assertIsNone(result)\n\n    def test_binary_operation(self):\n        # Test math operation\n        result = safe_run_script('y = 5 + 3 * 2')\n        self.assertIsNone(result)\n\n    def test_string_concatenation(self):\n        # Test string concatenation\n        result = safe_run_script('s = \"a\" + \"b\"')\n        self.assertIsNone(result)\n\n    def test_if_statement(self):\n        # Test if statement\n        result = safe_run_script('if True: z = 10')\n        self.assertIsNone(result)\n\n    def test_for_loop(self):\n        # Test for loop\n        newline = chr(10)\n        code = f'for i in [1,2,3]:{newline}    a = i'\n        result = safe_run_script(code)\n        self.assertIsNone(result)\n\n    def test_string_constant(self):\n        # Test string constant with keyword\n        result = safe_run_script('\"open\"')\n        self.assertIsNone(result)\n\n    def test_assignment_builtin(self):\n        # Test assigning built-in function\n        result = safe_run_script('f = open')\n        self.assertIsNone(result)\n\n    def test_allowed_attribute(self):\n        # Test accessing allowed attribute\n        result = safe_run_script('g = \"text\".upper')\n        self.assertIsNone(result)\n\n    def test_import_statement(self):\n        # Test import statement\n        with self.assertRaises(ValueError):\n            safe_run_script('import os')\n\n    def test_import_from(self):\n        # Test from import\n        with self.assertRaises(ValueError):\n            safe_run_script('from sys import exit')\n\n    def test_with_block(self):\n        # Test with block statement\n        newline = chr(10)\n        code = f'with open(\"test.txt\") as f:{newline}    pass'\n        with self.assertRaises(ValueError):\n            safe_run_script(code)\n\n    def test_function_call(self):\n        # Test function call\n        with self.assertRaises(ValueError):\n            safe_run_script('print(\"Hello\")')\n\n    def test_prohibited_attribute(self):\n        # Test prohibited attribute access\n        with self.assertRaises(ValueError):\n            safe_run_script('os.system')\n\n    def test_nested_prohibited_attribute(self):\n        # Test nested prohibited attribute\n        with self.assertRaises(ValueError):\n            safe_run_script('__builtins__.open')\n\n    def test_method_call(self):\n        # Test method call\n        with self.assertRaises(ValueError):\n            safe_run_script('\".\".join([\"a\",\"b\"])')\n\n    def test_syntax_error(self):\n        # Test syntax error\n        with self.assertRaises(ValueError):\n            safe_run_script('x = ')\n\n    def test_builtin_assignment_non_call(self):\n        # Test assigning non-prohibited builtin\n        result = safe_run_script('h = abs')\n        self.assertIsNone(result)\n\n    def test_builtin_call(self):\n        # Test builtin function call\n        with self.assertRaises(ValueError):\n            safe_run_script('abs(-1)')\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 19, "task_id": "607ec68a"}
{"test": "import unittest\n\nclass TestRestrictedRunCode(unittest.TestCase):\n\n    def test_empty_script(self):\n        \"\"\"Test that an empty script runs without error.\"\"\"\n        self.assertIsNone(restricted_run_code(\"\"))\n\n    def test_comment_script(self):\n        \"\"\"Test that a script containing only comments runs without error.\"\"\"\n        self.assertIsNone(restricted_run_code(\"# This is a comment\"))\n\n    def test_assignment(self):\n        \"\"\"Test basic variable assignment.\"\"\"\n        self.assertIsNone(restricted_run_code(\"x = 5\"))\n\n    def test_math_operations(self):\n        \"\"\"Test basic arithmetic operations.\"\"\"\n        self.assertIsNone(restricted_run_code(\"a = 5; b = 3; c = a * b + 2\"))\n\n    def test_loop_with_list_literal(self):\n        \"\"\"Test a for loop iterating over a list literal.\"\"\"\n        self.assertIsNone(restricted_run_code(\"for i in [1, 2, 3]:\\n    pass\"))\n\n    def test_safe_attribute_access(self):\n        \"\"\"Test accessing a safe attribute (without calling).\"\"\"\n        self.assertIsNone(restricted_run_code(\"s = 'hello'; t = s.upper\"))\n\n    def test_lambda_definition(self):\n        \"\"\"Test defining a lambda function (without calling).\"\"\"\n        self.assertIsNone(restricted_run_code(\"f = lambda x: x + 1\"))\n\n    def test_list_comprehension(self):\n        \"\"\"Test using a list comprehension.\"\"\"\n        self.assertIsNone(restricted_run_code(\"x = [i for i in [1, 2, 3]]\"))\n\n    def test_name_reference(self):\n        \"\"\"Test referencing a built-in name without calling or attribute access.\"\"\"\n        self.assertIsNone(restricted_run_code(\"open\"))\n\n    def test_class_definition(self):\n        \"\"\"Test defining a class.\"\"\"\n        self.assertIsNone(restricted_run_code(\"class MyClass:\\n    pass\"))\n\n    def test_import_statement(self):\n        \"\"\"Test that an import statement raises a ValueError.\"\"\"\n        with self.assertRaises(ValueError):\n            restricted_run_code(\"import os\")\n\n    def test_import_from_statement(self):\n        \"\"\"Test that an import from statement raises a ValueError.\"\"\"\n        with self.assertRaises(ValueError):\n            restricted_run_code(\"from os import system\")\n\n    def test_with_statement(self):\n        \"\"\"Test that a with statement raises a ValueError.\"\"\"\n        with self.assertRaises(ValueError):\n            restricted_run_code(\"with open('file.txt') as f:\\n    pass\")\n\n    def test_call_dangerous_function(self):\n        \"\"\"Test calling a dangerous function (open) raises a ValueError.\"\"\"\n        with self.assertRaises(ValueError):\n            restricted_run_code(\"open('file.txt')\")\n\n    def test_call_safe_function(self):\n        \"\"\"Test that even safe function calls (print) are blocked.\"\"\"\n        with self.assertRaises(ValueError):\n            restricted_run_code(\"print('hello')\")\n\n    def test_dangerous_attribute_access(self):\n        \"\"\"Test accessing a dangerous attribute (open) raises a ValueError.\"\"\"\n        with self.assertRaises(ValueError):\n            restricted_run_code(\"x = open; y = x.open\")\n\n    def test_syntax_error(self):\n        \"\"\"Test that a syntax error in the script raises a ValueError.\"\"\"\n        with self.assertRaises(ValueError):\n            restricted_run_code(\"x = 5 +\")\n\n    def test_reference_error(self):\n        \"\"\"Test a NameError during execution is caught and wrapped as ValueError.\"\"\"\n        with self.assertRaises(ValueError):\n            restricted_run_code(\"x = y\")\n\n    def test_raise_in_script(self):\n        \"\"\"Test that an exception raised in the script is wrapped as ValueError.\"\"\"\n        with self.assertRaises(ValueError):\n            restricted_run_code(\"raise Exception('error')\")\n\n    def test_division_by_zero(self):\n        \"\"\"Test a runtime error (division by zero) is wrapped as ValueError.\"\"\"\n        with self.assertRaises(ValueError):\n            restricted_run_code(\"x = 1 / 0\")", "num_test_cases": 20, "task_id": "d5ef063a"}
{"test": "import unittest\n\nclass TestExecuteUserScript(unittest.TestCase):\n    def test_safe_arithmetic(self):\n        # Test basic arithmetic operations\n        script = \"x = 5 + 3\"\n        self.assertIsNone(execute_user_script(script))\n\n    def test_safe_string(self):\n        # Test string concatenation\n        script = \"s = 'hello' + 'world'\"\n        self.assertIsNone(execute_user_script(script))\n\n    def test_empty_script(self):\n        # Test empty input script\n        script = \"\"\n        self.assertIsNone(execute_user_script(script))\n\n    def test_disallowed_import(self):\n        # Test disallowed import statement\n        script = \"import os\"\n        with self.assertRaises(ValueError):\n            execute_user_script(script)\n\n    def test_disallowed_import_from(self):\n        # Test disallowed import from statement\n        script = \"from math import sqrt\"\n        with self.assertRaises(ValueError):\n            execute_user_script(script)\n\n    def test_disallowed_with(self):\n        # Test disallowed with statement\n        script = \"with open('file.txt', 'w') as f:\\n    f.write('test')\"\n        with self.assertRaises(ValueError):\n            execute_user_script(script)\n\n    def test_disallowed_call(self):\n        # Test disallowed function call\n        script = \"print('Hello')\"\n        with self.assertRaises(ValueError):\n            execute_user_script(script)\n\n    def test_disallowed_attribute_builtin(self):\n        # Test accessing forbidden built-in attribute\n        script = \"f = __builtins__.open\"\n        with self.assertRaises(ValueError):\n            execute_user_script(script)\n\n    def test_disallowed_attribute_custom(self):\n        # Test accessing forbidden attribute in custom object\n        script = \"class Test:\\n    pass\\nt = Test()\\nt.open = 5\\nx = t.open\"\n        with self.assertRaises(ValueError):\n            execute_user_script(script)\n\n    def test_syntax_error(self):\n        # Test script with syntax error\n        script = \"x =\"\n        with self.assertRaises(ValueError):\n            execute_user_script(script)\n\n    def test_runtime_error(self):\n        # Test script causing runtime error\n        script = \"x = y  # y is undefined\"\n        with self.assertRaises(ValueError):\n            execute_user_script(script)\n\n    def test_disallowed_exec_function(self):\n        # Test disallowed exec function in attribute\n        script = \"f = __builtins__.exec\"\n        with self.assertRaises(ValueError):\n            execute_user_script(script)\n\n    def test_disallowed_eval_function(self):\n        # Test disallowed eval function in attribute\n        script = \"f = __builtins__.eval\"\n        with self.assertRaises(ValueError):\n            execute_user_script(script)\n\n    def test_disallowed_compile_function(self):\n        # Test disallowed compile function in attribute\n        script = \"f = __builtins__.compile\"\n        with self.assertRaises(ValueError):\n            execute_user_script(script)\n\n    def test_disallowed_system_attribute(self):\n        # Test disallowed system attribute\n        script = \"import os; cmd = os.system\"\n        with self.assertRaises(ValueError):\n            execute_user_script(script)\n\n    def test_multiline_safe_script(self):\n        # Test multi-line safe script\n        script = \"a = 10\\nb = 20\\nc = a * b\"\n        self.assertIsNone(execute_user_script(script))\n\n    def test_complex_arithmetic(self):\n        # Test complex arithmetic operations\n        script = \"result = (100 - 50) * 2 / 5\"\n        self.assertIsNone(execute_user_script(script))\n\n    def test_string_operations(self):\n        # Test safe string operations\n        script = \"s1 = 'test'\\ns2 = s1.upper()\"\n        with self.assertRaises(ValueError):\n            execute_user_script(script)\n\n    def test_disallowed_nested_attributes(self):\n        # Test nested disallowed attributes\n        script = \"import subprocess; p = subprocess.Popen\"\n        with self.assertRaises(ValueError):\n            execute_user_script(script)\n\n    def test_large_safe_script(self):\n        # Test large safe script\n        script = \"\"\"\nvalue = 0\nfor i in range(1000):\n    value += i\n        \"\"\"\n        self.assertIsNone(execute_user_script(script))\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 20, "task_id": "875357f6"}
{"test": "import unittest\n\nclass TestProcessUserCode(unittest.TestCase):\n    def test_basic_arithmetic(self):\n        \"\"\"Test basic arithmetic operations.\"\"\"\n        code = 'x = 5 + 3'\n        result = process_user_code(code)\n        self.assertIsNone(result)\n    \n    def test_variable_assignment(self):\n        \"\"\"Test variable assignments and expressions.\"\"\"\n        code = 'a = 10; b = 20; c = a * b'\n        result = process_user_code(code)\n        self.assertIsNone(result)\n    \n    def test_conditional_statement(self):\n        \"\"\"Test conditional statements without function calls.\"\"\"\n        code = 'if True: result = 1; else: result = 0'\n        result = process_user_code(code)\n        self.assertIsNone(result)\n    \n    def test_loop_statement(self):\n        \"\"\"Test loop constructs without function calls.\"\"\"\n        code = 'x = 0; while x < 5: x += 1'\n        result = process_user_code(code)\n        self.assertIsNone(result)\n    \n    def test_function_definition(self):\n        \"\"\"Test safe function definition without calls in body.\"\"\"\n        code = 'def my_func(): a = 1; b = 2; return a + b'\n        result = process_user_code(code)\n        self.assertIsNone(result)\n    \n    def test_import_statement(self):\n        \"\"\"Test disallowed import statement.\"\"\"\n        code = 'import os'\n        with self.assertRaises(ValueError):\n            process_user_code(code)\n    \n    def test_import_from(self):\n        \"\"\"Test disallowed import from statement.\"\"\"\n        code = 'from math import sqrt'\n        with self.assertRaises(ValueError):\n            process_user_code(code)\n    \n    def test_with_statement(self):\n        \"\"\"Test disallowed with statement.\"\"\"\n        code = 'with open(\\'file.txt\\') as f: pass'\n        with self.assertRaises(ValueError):\n            process_user_code(code)\n    \n    def test_function_call(self):\n        \"\"\"Test disallowed function call.\"\"\"\n        code = 'print(\\'hello\\')'\n        with self.assertRaises(ValueError):\n            process_user_code(code)\n    \n    def test_dangerous_attribute(self):\n        \"\"\"Test disallowed attribute access.\"\"\"\n        code = 'x = (5).open'\n        with self.assertRaises(ValueError):\n            process_user_code(code)\n    \n    def test_syntax_error(self):\n        \"\"\"Test script with syntax error.\"\"\"\n        code = 'x = '\n        with self.assertRaises(ValueError):\n            process_user_code(code)\n    \n    def test_nested_disallowed_operation(self):\n        \"\"\"Test disallowed call inside conditional.\"\"\"\n        code = 'if True: print(\\'danger\\')'\n        with self.assertRaises(ValueError):\n            process_user_code(code)", "num_test_cases": 12, "task_id": "b56ccf40"}
{"test": "import unittest\nfrom solution import evaluate_user_input\n\nclass TestEvaluateUserInput(unittest.TestCase):\n\n    def test_safe_script(self):\n        # Test basic safe operations: assignment and arithmetic\n        user_code = \"x = 5 + 3\"\n        self.assertIsNone(evaluate_user_input(user_code))\n\n    def test_empty_script(self):\n        # Test empty script input\n        user_code = \"\"\n        self.assertIsNone(evaluate_user_input(user_code))\n\n    def test_allowed_attribute_access(self):\n        # Test accessing allowed attributes without calls\n        user_code = \"s = 'hello'; t = s.upper\"\n        self.assertIsNone(evaluate_user_input(user_code))\n\n    def test_script_with_call(self):\n        # Test disallowed call operation\n        user_code = \"print('Hello')\"\n        with self.assertRaises(ValueError):\n            evaluate_user_input(user_code)\n\n    def test_script_with_import(self):\n        # Test disallowed import statement\n        user_code = \"import os\"\n        with self.assertRaises(ValueError):\n            evaluate_user_input(user_code)\n\n    def test_script_with_import_from(self):\n        # Test disallowed import from statement\n        user_code = \"from math import pi\"\n        with self.assertRaises(ValueError):\n            evaluate_user_input(user_code)\n\n    def test_script_with_with_statement(self):\n        # Test disallowed with statement\n        user_code = \"with open('file.txt') as f: pass\"\n        with self.assertRaises(ValueError):\n            evaluate_user_input(user_code)\n\n    def test_script_with_banned_attribute(self):\n        # Test accessing banned attribute (open)\n        user_code = \"s = 'test'; s.open\"\n        with self.assertRaises(ValueError):\n            evaluate_user_input(user_code)\n\n    def test_script_with_syntax_error(self):\n        # Test script with invalid syntax\n        user_code = \"x = \"\n        with self.assertRaises(ValueError):\n            evaluate_user_input(user_code)\n\n    def test_safe_class_definition(self):\n        # Test class definition without disallowed operations\n        user_code = \"class MyClass:\\n    pass\"\n        self.assertIsNone(evaluate_user_input(user_code))\n\n    def test_class_with_disallowed_operation(self):\n        # Test class containing disallowed call in method\n        user_code = \"\"\"\nclass MyClass:\n    def method(self):\n        print('Disallowed call')\n\"\"\"\n        with self.assertRaises(ValueError):\n            evaluate_user_input(user_code)\n\n    def test_script_with_banned_builtin_name(self):\n        # Test assignment of banned built-in name (without call)\n        user_code = \"f = open\"\n        self.assertIsNone(evaluate_user_input(user_code))\n\n    def test_nested_disallowed_operation(self):\n        # Test disallowed operation inside control structure\n        user_code = \"if True: import os\"\n        with self.assertRaises(ValueError):\n            evaluate_user_input(user_code)\n\n    def test_script_with_comment(self):\n        # Test script containing comments (should be ignored by AST)\n        user_code = \"# import os\\nx = 5\"\n        self.assertIsNone(evaluate_user_input(user_code))", "num_test_cases": 14, "task_id": "30d79c73"}
{"test": "import unittest\n\nclass TestExecuteUserCode(unittest.TestCase):\n    \n    def test_safe_arithmetic(self):\n        # Test basic arithmetic operations (allowed)\n        code = \"x = 5 + 3 * 2\"\n        self.assertIsNone(execute_user_code(code))\n    \n    def test_safe_string_operation(self):\n        # Test string concatenation (allowed)\n        code = \"s = 'hello' + 'world'\"\n        self.assertIsNone(execute_user_code(code))\n    \n    def test_empty_script(self):\n        # Test empty code string (allowed)\n        code = \"\"\n        self.assertIsNone(execute_user_code(code))\n    \n    def test_multiline_safe_code(self):\n        # Test multiple lines of safe code (allowed)\n        code = \"a = 1\\nb = 2\\nc = a + b\"\n        self.assertIsNone(execute_user_code(code))\n    \n    def test_loop_without_call(self):\n        # Test loops without function calls (allowed)\n        code = \"for i in [1,2,3]: pass\\nwhile False: pass\"\n        self.assertIsNone(execute_user_code(code))\n    \n    def test_assignment_of_builtin_open(self):\n        # Test assignment of built-in open (allowed since no call)\n        code = \"f = open\"\n        self.assertIsNone(execute_user_code(code))\n    \n    def test_import_statement(self):\n        # Test import statement (disallowed)\n        code = \"import os\"\n        with self.assertRaises(ValueError):\n            execute_user_code(code)\n    \n    def test_import_from(self):\n        # Test import from statement (disallowed)\n        code = \"from math import sqrt\"\n        with self.assertRaises(ValueError):\n            execute_user_code(code)\n    \n    def test_with_statement(self):\n        # Test with statement (disallowed)\n        code = \"with open('file.txt') as f: pass\"\n        with self.assertRaises(ValueError):\n            execute_user_code(code)\n    \n    def test_call_to_function(self):\n        # Test function call (disallowed)\n        code = \"abs(-1)\"\n        with self.assertRaises(ValueError):\n            execute_user_code(code)\n    \n    def test_attribute_access_open(self):\n        # Test attribute access to 'open' (disallowed)\n        code = \"x = something.open\"\n        with self.assertRaises(ValueError):\n            execute_user_code(code)\n    \n    def test_attribute_access_system(self):\n        # Test attribute access to 'system' (disallowed)\n        code = \"x = anything.system\"\n        with self.assertRaises(ValueError):\n            execute_user_code(code)\n    \n    def test_call_to_eval(self):\n        # Test call to eval (disallowed)\n        code = \"eval('1+1')\"\n        with self.assertRaises(ValueError):\n            execute_user_code(code)\n    \n    def test_invalid_syntax(self):\n        # Test invalid Python syntax\n        code = \"x = 5 +\"\n        with self.assertRaises(ValueError):\n            execute_user_code(code)\n    \n    def test_call_in_nested_block(self):\n        # Test function call inside nested block (disallowed)\n        code = \"if True: print('hello')\"\n        with self.assertRaises(ValueError):\n            execute_user_code(code)\n    \n    def test_call_to_assigned_builtin(self):\n        # Test calling assigned built-in function (disallowed)\n        code = \"f = open\\nf('test.txt')\"\n        with self.assertRaises(ValueError):\n            execute_user_code(code)\n    \n    def test_loop_with_call(self):\n        # Test loop containing function call (disallowed)\n        code = \"for i in range(3): print(i)\"\n        with self.assertRaises(ValueError):\n            execute_user_code(code)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 17, "task_id": "277c5895"}
{"test": "import unittest\nfrom solution import execute_python_script\n\nclass TestExecutePythonScript(unittest.TestCase):\n\n    def test_safe_arithmetic(self):\n        # Test basic arithmetic expression\n        code = 'x = 5 * 5'\n        self.assertIsNone(execute_python_script(code))\n\n    def test_safe_string_manipulation(self):\n        # Test string concatenation\n        code = 's = \\'hello\\' + \\'world\\''\n        self.assertIsNone(execute_python_script(code))\n\n    def test_safe_while_loop(self):\n        # Test while loop without function calls\n        code = '''\ni = 0\nwhile i < 5:\n    i += 1\n'''\n        self.assertIsNone(execute_python_script(code))\n\n    def test_safe_if_statement(self):\n        # Test if statement\n        code = '''\nx = 10\nif x > 5:\n    y = \\'greater\\'\n'''\n        self.assertIsNone(execute_python_script(code))\n\n    def test_safe_list_comprehension(self):\n        # Test list comprehension\n        code = 'squares = [x*x for x in [1,2,3,4]]'\n        self.assertIsNone(execute_python_script(code))\n\n    def test_function_definition_without_call(self):\n        # Test function definition without call\n        code = '''\ndef greet():\n    return \\'Hello\\'\n'''\n        self.assertIsNone(execute_python_script(code))\n\n    def test_import_statement(self):\n        # Test import disallowed\n        code = 'import os'\n        with self.assertRaises(ValueError):\n            execute_python_script(code)\n\n    def test_with_statement(self):\n        # Test with statement disallowed\n        code = '''\nwith open(\\'file.txt\\') as f:\n    pass\n'''\n        with self.assertRaises(ValueError):\n            execute_python_script(code)\n\n    def test_function_call(self):\n        # Test function call disallowed\n        code = 'abs(-5)'\n        with self.assertRaises(ValueError):\n            execute_python_script(code)\n\n    def test_disallowed_attribute_os_open(self):\n        # Test disallowed attribute os.open\n        code = 'x = os.open'\n        with self.assertRaises(ValueError):\n            execute_python_script(code)\n\n    def test_disallowed_attribute_user_defined(self):\n        # Test disallowed attribute in user-defined class\n        code = '''\nclass A:\n    def open(self):\n        pass\na = A()\nx = a.open\n'''\n        with self.assertRaises(ValueError):\n            execute_python_script(code)\n\n    def test_assignment_to_builtin_name(self):\n        # Test assignment to built-in name\n        code = 'x = open'\n        self.assertIsNone(execute_python_script(code))\n\n    def test_syntax_error(self):\n        # Test invalid syntax\n        code = 'x = 5 +'\n        with self.assertRaises(ValueError):\n            execute_python_script(code)\n\n    def test_empty_script(self):\n        # Test empty script\n        code = ''\n        with self.assertRaises(ValueError):\n            execute_python_script(code)\n\n    def test_safe_builtin_type_without_call(self):\n        # Test safe built-in type without call\n        code = 'x = list'\n        self.assertIsNone(execute_python_script(code))\n\n    def test_builtin_type_with_call(self):\n        # Test built-in type call disallowed\n        code = 'x = list()'\n        with self.assertRaises(ValueError):\n            execute_python_script(code)\n\n    def test_safe_string_attribute_access(self):\n        # Test safe string attribute access\n        code = 's = \\'hello\\'; x = s.upper'\n        self.assertIsNone(execute_python_script(code))\n\n    def test_string_method_call(self):\n        # Test string method call disallowed\n        code = 's = \\'hello\\'; s.upper()'\n        with self.assertRaises(ValueError):\n            execute_python_script(code)\n\n    def test_disallowed_import_inside_function(self):\n        # Test import inside function disallowed\n        code = '''\ndef f():\n    import os\n'''\n        with self.assertRaises(ValueError):\n            execute_python_script(code)\n\n    def test_disallowed_call_inside_function(self):\n        # Test call inside function disallowed\n        code = '''\ndef f():\n    abs(-5)\n'''\n        with self.assertRaises(ValueError):\n            execute_python_script(code)\n\n    def test_disallowed_attribute_inside_function(self):\n        # Test attribute inside function disallowed\n        code = '''\ndef f():\n    x = os.open\n'''\n        with self.assertRaises(ValueError):\n            execute_python_script(code)\n\n    def test_multiline_safe_code(self):\n        # Test multiline safe code\n        code = '''\na = 10\nb = 20\nc = a * b\n'''\n        self.assertIsNone(execute_python_script(code))\n\n    def test_disallowed_nested_operation(self):\n        # Test disallowed operation in nested context\n        code = '''\nif True:\n    import os\n'''\n        with self.assertRaises(ValueError):\n            execute_python_script(code)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 24, "task_id": "055122e8"}
{"test": "import unittest\n\nclass TestSafeRunScript(unittest.TestCase):\n\n    def test_empty_script(self):\n        \"\"\"Test that an empty script runs without error and returns None.\"\"\"\n        result = safe_run_script(\"\")\n        self.assertIsNone(result)\n\n    def test_simple_assignment(self):\n        \"\"\"Test a simple variable assignment.\"\"\"\n        script = \"x = 5\"\n        result = safe_run_script(script)\n        self.assertIsNone(result)\n\n    def test_string_operation(self):\n        \"\"\"Test safe string manipulation (attribute access without call).\"\"\"\n        script = \"s = 'hello'; t = s.upper\"\n        result = safe_run_script(script)\n        self.assertIsNone(result)\n\n    def test_for_loop(self):\n        \"\"\"Test a simple for-loop with allowed operations.\"\"\"\n        script = \"for i in [1, 2, 3]:\\n    x = i\"\n        result = safe_run_script(script)\n        self.assertIsNone(result)\n\n    def test_while_loop(self):\n        \"\"\"Test a while loop with allowed operations.\"\"\"\n        script = \"i = 0\\nwhile i < 3:\\n    i += 1\"\n        result = safe_run_script(script)\n        self.assertIsNone(result)\n\n    def test_function_definition(self):\n        \"\"\"Test defining a function (without calling).\"\"\"\n        script = \"def my_func():\\n    pass\"\n        result = safe_run_script(script)\n        self.assertIsNone(result)\n\n    def test_class_definition(self):\n        \"\"\"Test defining a class.\"\"\"\n        script = \"class MyClass:\\n    pass\"\n        result = safe_run_script(script)\n        self.assertIsNone(result)\n\n    def test_try_except(self):\n        \"\"\"Test try-except block with allowed operations.\"\"\"\n        script = \"try:\\n    x = 5\\nexcept:\\n    pass\"\n        result = safe_run_script(script)\n        self.assertIsNone(result)\n\n    def test_assignment_to_builtin(self):\n        \"\"\"Test assigning a built-in name (without calling).\"\"\"\n        script = \"x = open\"\n        result = safe_run_script(script)\n        self.assertIsNone(result)\n\n    def test_import_statement(self):\n        \"\"\"Test that import statement raises ValueError.\"\"\"\n        script = \"import os\"\n        with self.assertRaises(ValueError):\n            safe_run_script(script)\n\n    def test_import_from_statement(self):\n        \"\"\"Test that import from statement raises ValueError.\"\"\"\n        script = \"from os import path\"\n        with self.assertRaises(ValueError):\n            safe_run_script(script)\n\n    def test_with_statement(self):\n        \"\"\"Test that with statement raises ValueError.\"\"\"\n        script = \"with open('file.txt'):\\n    pass\"\n        with self.assertRaises(ValueError):\n            safe_run_script(script)\n\n    def test_function_call(self):\n        \"\"\"Test that any function call raises ValueError.\"\"\"\n        script = \"print('hello')\"\n        with self.assertRaises(ValueError):\n            safe_run_script(script)\n\n    def test_forbidden_attribute_access(self):\n        \"\"\"Test accessing a forbidden attribute raises ValueError.\"\"\"\n        script = \"s = 'hello'; x = s.open\"\n        with self.assertRaises(ValueError):\n            safe_run_script(script)\n\n    def test_call_to_dangerous_function(self):\n        \"\"\"Test calling a dangerous function raises ValueError.\"\"\"\n        script = \"open('file.txt')\"\n        with self.assertRaises(ValueError):\n            safe_run_script(script)\n\n    def test_list_comprehension_with_call(self):\n        \"\"\"Test list comprehension with function call raises ValueError.\"\"\"\n        script = \"x = [i for i in range(10)]\"\n        with self.assertRaises(ValueError):\n            safe_run_script(script)\n\n    def test_function_definition_with_disallowed_operation(self):\n        \"\"\"Test function definition containing disallowed operation raises ValueError.\"\"\"\n        script = \"def bad_func():\\n    import os\"\n        with self.assertRaises(ValueError):\n            safe_run_script(script)\n\n    def test_syntax_error(self):\n        \"\"\"Test script with syntax error raises ValueError.\"\"\"\n        script = \"x = \"  # Incomplete assignment\n        with self.assertRaises(ValueError):\n            safe_run_script(script)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 18, "task_id": "0a873119"}
{"test": "import unittest\nimport re\nimport ast\n\nclass TestEvaluateExpression(unittest.TestCase):\n    \n    def test_simple_addition(self):\n        # Test basic addition\n        self.assertEqual(evaluate_expression(\"2+3\"), 5)\n    \n    def test_with_spaces(self):\n        # Test expression with surrounding spaces\n        self.assertEqual(evaluate_expression(\" 2 * 3 \"), 6)\n    \n    def test_division(self):\n        # Test division resulting in integer\n        self.assertEqual(evaluate_expression(\"10/2\"), 5)\n    \n    def test_division_float(self):\n        # Test division resulting in float\n        self.assertAlmostEqual(evaluate_expression(\"10/3\"), 10/3)\n    \n    def test_negative_numbers_binary(self):\n        # Test subtraction resulting in negative number\n        self.assertEqual(evaluate_expression(\"5-10\"), -5)\n    \n    def test_parentheses(self):\n        # Test expression with parentheses\n        self.assertEqual(evaluate_expression(\"(2+3)*4\"), 20)\n    \n    def test_decimal_numbers(self):\n        # Test decimal number operations\n        self.assertEqual(evaluate_expression(\"3.5*2\"), 7.0)\n    \n    def test_operator_precedence(self):\n        # Test operator precedence (multiplication before addition)\n        self.assertEqual(evaluate_expression(\"2+3*4\"), 14)\n    \n    def test_empty_string(self):\n        # Test empty input string\n        with self.assertRaises(ValueError):\n            evaluate_expression(\"\")\n    \n    def test_division_by_zero(self):\n        # Test division by zero\n        with self.assertRaises(ValueError):\n            evaluate_expression(\"1/0\")\n    \n    def test_invalid_character(self):\n        # Test expression with invalid character 'a'\n        with self.assertRaises(ValueError):\n            evaluate_expression(\"2 + a\")\n    \n    def test_function_call(self):\n        # Test disallowed function call\n        with self.assertRaises(ValueError):\n            evaluate_expression(\"abs(-1)\")\n    \n    def test_attribute_access(self):\n        # Test disallowed attribute access\n        with self.assertRaises(ValueError):\n            evaluate_expression(\"math.sqrt(4)\")\n    \n    def test_malformed_expression(self):\n        # Test incomplete expression\n        with self.assertRaises(ValueError):\n            evaluate_expression(\"2 + \")\n    \n    def test_invalid_operator_percent(self):\n        # Test invalid operator '%'\n        with self.assertRaises(ValueError):\n            evaluate_expression(\"2 % 3\")\n    \n    def test_unary_minus(self):\n        # Test unary minus\n        self.assertEqual(evaluate_expression(\"-5\"), -5)\n    \n    def test_spaces_around_operators(self):\n        # Test expression with extra spaces\n        self.assertEqual(evaluate_expression(\"   -5   +  3  \"), -2)\n    \n    def test_large_expression(self):\n        # Test complex expression\n        expr = \"2 * 3 + 5 * (7 - 2) / 2.5\"\n        result = 2*3 + 5*(7-2)/2.5\n        self.assertAlmostEqual(evaluate_expression(expr), result)\n    \n    def test_invalid_number_format(self):\n        # Test invalid number format (multiple decimal points)\n        with self.assertRaises(ValueError):\n            evaluate_expression(\"2.3.4\")\n    \n    def test_floating_point_representation(self):\n        # Test floating point precision\n        self.assertAlmostEqual(evaluate_expression(\"0.1+0.2\"), 0.3, places=7)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 20, "task_id": "938d062c"}
{"test": "import unittest\n\nclass TestComputeExpression(unittest.TestCase):\n\n    def test_case_1(self):\n        # Test simple addition: 1+1=2.0\n        expr = \"1 + 1\"\n        expected = 2.0\n        result = compute_expression(expr)\n        self.assertAlmostEqual(result, expected, places=7)\n\n    def test_case_2(self):\n        # Test subtraction: 5-3=2.0\n        expr = \"5 - 3\"\n        expected = 2.0\n        result = compute_expression(expr)\n        self.assertAlmostEqual(result, expected, places=7)\n\n    def test_case_3(self):\n        # Test multiplication: 2*3=6.0\n        expr = \"2 * 3\"\n        expected = 6.0\n        result = compute_expression(expr)\n        self.assertAlmostEqual(result, expected, places=7)\n\n    def test_case_4(self):\n        # Test division: 6/2=3.0\n        expr = \"6 / 2\"\n        expected = 3.0\n        result = compute_expression(expr)\n        self.assertAlmostEqual(result, expected, places=7)\n\n    def test_case_5(self):\n        # Test division by zero raises ValueError\n        expr = \"1 / 0\"\n        with self.assertRaises(ValueError):\n            compute_expression(expr)\n\n    def test_case_6(self):\n        # Test parentheses: (1+2)*3=9.0\n        expr = \"(1 + 2) * 3\"\n        expected = 9.0\n        result = compute_expression(expr)\n        self.assertAlmostEqual(result, expected, places=7)\n\n    def test_case_7(self):\n        # Test decimal numbers: 2.5*2=5.0\n        expr = \"2.5 * 2\"\n        expected = 5.0\n        result = compute_expression(expr)\n        self.assertAlmostEqual(result, expected, places=7)\n\n    def test_case_8(self):\n        # Test negative numbers: -5+3=-2.0\n        expr = \"-5 + 3\"\n        expected = -2.0\n        result = compute_expression(expr)\n        self.assertAlmostEqual(result, expected, places=7)\n\n    def test_case_9(self):\n        # Test expression with spaces: 2+3=5.0\n        expr = \"  2   +   3  \"\n        expected = 5.0\n        result = compute_expression(expr)\n        self.assertAlmostEqual(result, expected, places=7)\n\n    def test_case_10(self):\n        # Test empty expression raises ValueError\n        expr = \"\"\n        with self.assertRaises(ValueError):\n            compute_expression(expr)\n\n    def test_case_11(self):\n        # Test invalid character (letter) raises ValueError\n        expr = \"2 + a\"\n        with self.assertRaises(ValueError):\n            compute_expression(expr)\n\n    def test_case_12(self):\n        # Test invalid character (symbol) raises ValueError\n        expr = \"2 @ 3\"\n        with self.assertRaises(ValueError):\n            compute_expression(expr)\n\n    def test_case_13(self):\n        # Test function call raises ValueError\n        expr = \"print('hello')\"\n        with self.assertRaises(ValueError):\n            compute_expression(expr)\n\n    def test_case_14(self):\n        # Test attribute access raises ValueError\n        expr = \"().__class__\"\n        with self.assertRaises(ValueError):\n            compute_expression(expr)\n\n    def test_case_15(self):\n        # Test long expression: 1+1+...+1 (1001 ones)=1001.0\n        expr = \"1\" + \"+1\" * 1000\n        expected = 1001.0\n        result = compute_expression(expr)\n        self.assertAlmostEqual(result, expected, places=7)\n\n    def test_case_16(self):\n        # Test multiple operations: 2+3*4-6/2=11.0\n        expr = \"2 + 3 * 4 - 6 / 2\"\n        expected = 11.0\n        result = compute_expression(expr)\n        self.assertAlmostEqual(result, expected, places=7)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 16, "task_id": "e881b650"}
{"test": "import unittest\n\nclass TestEvaluateAndCompute(unittest.TestCase):\n\n    def test_case_1(self):\n        # Test simple addition\n        self.assertEqual(evaluate_and_compute('1 + 1'), 2)\n\n    def test_case_2(self):\n        # Test multiplication\n        self.assertEqual(evaluate_and_compute('2 * 3'), 6)\n\n    def test_case_3(self):\n        # Test division\n        self.assertEqual(evaluate_and_compute('10 / 2'), 5.0)\n\n    def test_case_4(self):\n        # Test subtraction\n        self.assertEqual(evaluate_and_compute('10 - 5'), 5)\n\n    def test_case_5(self):\n        # Test parentheses\n        self.assertEqual(evaluate_and_compute('(1 + 2) * 3'), 9)\n\n    def test_case_6(self):\n        # Test decimal numbers\n        self.assertEqual(evaluate_and_compute('2.5 * 2'), 5.0)\n\n    def test_case_7(self):\n        # Test expression with spaces\n        self.assertEqual(evaluate_and_compute('  3   +   2   '), 5)\n\n    def test_case_8(self):\n        # Test expression without spaces\n        self.assertEqual(evaluate_and_compute('3+2'), 5)\n\n    def test_case_9(self):\n        # Test operator precedence\n        self.assertEqual(evaluate_and_compute('2 * 3 + 4'), 10)\n\n    def test_case_10(self):\n        # Test operator precedence with multiplication\n        self.assertEqual(evaluate_and_compute('2 + 3 * 4'), 14)\n\n    def test_case_11(self):\n        # Test division by zero\n        with self.assertRaises(ValueError):\n            evaluate_and_compute('1 / 0')\n\n    def test_case_12(self):\n        # Test empty string\n        with self.assertRaises(ValueError):\n            evaluate_and_compute('')\n\n    def test_case_13(self):\n        # Test invalid character (letter)\n        with self.assertRaises(ValueError):\n            evaluate_and_compute('a + 1')\n\n    def test_case_14(self):\n        # Test invalid character (symbol)\n        with self.assertRaises(ValueError):\n            evaluate_and_compute('3 @ 4')\n\n    def test_case_15(self):\n        # Test function call\n        with self.assertRaises(ValueError):\n            evaluate_and_compute('abs(-1)')\n\n    def test_case_16(self):\n        # Test attribute access\n        with self.assertRaises(ValueError):\n            evaluate_and_compute('3 .__add__(4)')\n\n    def test_case_17(self):\n        # Test syntax error (invalid operator)\n        with self.assertRaises(ValueError):\n            evaluate_and_compute('2 + * 3')\n\n    def test_case_18(self):\n        # Test negative number\n        self.assertEqual(evaluate_and_compute('-5 + 3'), -2)\n\n    def test_case_19(self):\n        # Test double negative\n        self.assertEqual(evaluate_and_compute('5 - -3'), 8)\n\n    def test_case_20(self):\n        # Test leading decimal point\n        self.assertEqual(evaluate_and_compute('.5'), 0.5)\n\n    def test_case_21(self):\n        # Test invalid decimal (multiple dots)\n        with self.assertRaises(ValueError):\n            evaluate_and_compute('1.2.3')\n\n    def test_case_22(self):\n        # Test long expression\n        long_expr = '1' + ' + 1' * 100\n        self.assertEqual(evaluate_and_compute(long_expr), 101)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 22, "task_id": "73e8e3b4"}
{"test": "import unittest\n\nclass TestEvaluateExpression(unittest.TestCase):\n    def test_simple_addition(self):\n        # Test basic addition\n        self.assertEqual(evaluate_expression(\"2+3\"), 5)\n        \n    def test_float_multiplication(self):\n        # Test float multiplication\n        self.assertEqual(evaluate_expression(\"2.5 * 3\"), 7.5)\n        \n    def test_division(self):\n        # Test division\n        self.assertEqual(evaluate_expression(\"10/2\"), 5.0)\n        \n    def test_negative_result(self):\n        # Test negative result\n        self.assertEqual(evaluate_expression(\"10-20\"), -10)\n        \n    def test_parentheses(self):\n        # Test parentheses\n        self.assertEqual(evaluate_expression(\"(1+2)*3\"), 9)\n        \n    def test_single_number_with_spaces(self):\n        # Test single number with surrounding spaces\n        self.assertEqual(evaluate_expression(\" 5  \"), 5)\n        \n    def test_division_by_zero(self):\n        # Test division by zero\n        with self.assertRaises(ValueError):\n            evaluate_expression(\"1/0\")\n        \n    def test_exponentiation(self):\n        # Test exponentiation (allowed by current implementation)\n        self.assertEqual(evaluate_expression(\"2**3\"), 8)\n        \n    def test_invalid_character(self):\n        # Test invalid characters\n        with self.assertRaises(ValueError):\n            evaluate_expression(\"a + 3\")\n        \n    def test_multiple_additions(self):\n        # Test multiple additions\n        self.assertEqual(evaluate_expression(\"1+2+3\"), 6)\n        \n    def test_double_dot(self):\n        # Test invalid double dot\n        with self.assertRaises(ValueError):\n            evaluate_expression(\"1..2\")\n        \n    def test_two_numbers_without_operator(self):\n        # Test numbers without operator\n        with self.assertRaises(ValueError):\n            evaluate_expression(\"1 2\")\n        \n    def test_empty_string(self):\n        # Test empty string input\n        with self.assertRaises(ValueError):\n            evaluate_expression(\"\")\n        \n    def test_only_spaces(self):\n        # Test whitespace-only input\n        with self.assertRaises(ValueError):\n            evaluate_expression(\"   \")\n        \n    def test_incomplete_expression(self):\n        # Test incomplete expression\n        with self.assertRaises(ValueError):\n            evaluate_expression(\"1 + \")\n        \n    def test_negative_number(self):\n        # Test negative number handling\n        self.assertEqual(evaluate_expression(\"10 * -5\"), -50)\n        \n    def test_float_with_dot_only(self):\n        # Test float with trailing dot\n        self.assertEqual(evaluate_expression(\"2. + 3\"), 5.0)\n        \n    def test_consecutive_operators(self):\n        # Test consecutive operators\n        with self.assertRaises(ValueError):\n            evaluate_expression(\"3 * / 4\")\n        \n    def test_unmatched_parenthesis_extra_close(self):\n        # Test extra closing parenthesis\n        with self.assertRaises(ValueError):\n            evaluate_expression(\"3 * (2 + 4))\")\n        \n    def test_unmatched_parenthesis_missing_close(self):\n        # Test missing closing parenthesis\n        with self.assertRaises(ValueError):\n            evaluate_expression(\"3 * (2 + 4\")\n        \n    def test_large_expression(self):\n        # Test large expression\n        self.assertEqual(evaluate_expression(\"1+2+3+4+5+6+7+8+9+10\"), 55)\n        \n    def test_decimal_operations(self):\n        # Test decimal operations\n        self.assertEqual(evaluate_expression(\".5 * 4\"), 2.0)\n        \n    def test_complex_expression(self):\n        # Test complex expression with all operators\n        self.assertEqual(evaluate_expression(\"10 + 2 * 3 - 8 / 2\"), 12.0)", "num_test_cases": 24, "task_id": "31806d42"}
{"test": "import unittest\nimport math\n\nclass TestComputeExpression(unittest.TestCase):\n    \n    def test_valid_integer_expression(self):\n        # Test basic integer arithmetic\n        result = compute_expression(\"2 + 3 * 4\")\n        self.assertEqual(result, 14)\n    \n    def test_parentheses_priority(self):\n        # Test parentheses changing operation priority\n        result = compute_expression(\"(2+3)*4\")\n        self.assertEqual(result, 20)\n    \n    def test_division_operation(self):\n        # Test division results in float\n        result = compute_expression(\"10 / 2\")\n        self.assertEqual(result, 5.0)\n    \n    def test_negative_result(self):\n        # Test expression resulting in negative number\n        result = compute_expression(\"5 - 10\")\n        self.assertEqual(result, -5)\n    \n    def test_float_operations(self):\n        # Test float multiplication\n        result = compute_expression(\"3.5 * 2\")\n        self.assertEqual(result, 7.0)\n    \n    def test_spaces_ignored(self):\n        # Test that spaces are ignored in expression\n        result = compute_expression(\"  2   +   3  \")\n        self.assertEqual(result, 5)\n    \n    def test_single_number(self):\n        # Test expression with just a number\n        result = compute_expression(\"42\")\n        self.assertEqual(result, 42)\n    \n    def test_float_precision(self):\n        # Test floating point precision\n        result = compute_expression(\"0.1 + 0.2\")\n        self.assertAlmostEqual(result, 0.3, places=5)\n    \n    def test_multiple_operations(self):\n        # Test multiple operations without parentheses\n        result = compute_expression(\"1 + 2 * 3 - 4 / 2\")\n        self.assertEqual(result, 5.0)\n    \n    def test_empty_string(self):\n        # Test empty input expression\n        with self.assertRaises(ValueError):\n            compute_expression(\"\")\n    \n    def test_invalid_characters(self):\n        # Test expression with invalid characters\n        with self.assertRaises(ValueError):\n            compute_expression(\"2 + a\")\n    \n    def test_function_call_disallowed(self):\n        # Test function call (disallowed operation)\n        with self.assertRaises(ValueError):\n            compute_expression(\"abs(-1)\")\n    \n    def test_attribute_access_disallowed(self):\n        # Test attribute access (disallowed operation)\n        with self.assertRaises(ValueError):\n            compute_expression(\"().__class__\")\n    \n    def test_import_disallowed(self):\n        # Test import attempt (disallowed operation)\n        with self.assertRaises(ValueError):\n            compute_expression(\"__import__('os')\")\n    \n    def test_division_by_zero(self):\n        # Test division by zero raises error\n        with self.assertRaises(ValueError):\n            compute_expression(\"1/0\")\n    \n    def test_invalid_syntax(self):\n        # Test incomplete expression\n        with self.assertRaises(ValueError):\n            compute_expression(\"2 + \")\n    \n    def test_exponentiation_allowed(self):\n        # Test exponentiation is allowed (implementation allows it)\n        result = compute_expression(\"2**3\")\n        self.assertEqual(result, 8)\n    \n    def test_modulo_operator_invalid(self):\n        # Test modulo operator not allowed (invalid character)\n        with self.assertRaises(ValueError):\n            compute_expression(\"10 % 3\")\n    \n    def test_scientific_notation_invalid(self):\n        # Test scientific notation not allowed\n        with self.assertRaises(ValueError):\n            compute_expression(\"1e3\")\n    \n    def test_unary_minus(self):\n        # Test unary minus\n        result = compute_expression(\"-5\")\n        self.assertEqual(result, -5)\n    \n    def test_double_unary_minus(self):\n        # Test double unary minus\n        result = compute_expression(\"--5\")\n        self.assertEqual(result, 5)\n    \n    def test_mixed_whitespace(self):\n        # Test expression with mixed whitespace\n        result = compute_expression(\"2\\t+\\n3\")\n        self.assertEqual(result, 5)\n    \n    def test_nested_parentheses(self):\n        # Test complex nested parentheses\n        result = compute_expression(\"((2+3)*4-1)/2\")\n        self.assertEqual(result, 9.5)\n    \n    def test_float_without_leading_zero(self):\n        # Test float without leading zero\n        result = compute_expression(\".5 * 2\")\n        self.assertEqual(result, 1.0)\n    \n    def test_float_trailing_decimal(self):\n        # Test float with trailing decimal\n        result = compute_expression(\"5.\")\n        self.assertEqual(result, 5.0)\n    \n    def test_multiple_decimal_points(self):\n        # Test invalid float with multiple decimal points\n        with self.assertRaises(ValueError):\n            compute_expression(\"1.2.3\")\n\ndef run_tests():\n    suite = unittest.TestLoader().loadTestsFromTestCase(TestComputeExpression)\n    runner = unittest.TextTestRunner(verbosity=2)\n    runner.run(suite)\n\nif __name__ == \"__main__\":\n    run_tests()", "num_test_cases": 26, "task_id": "c6c49d63"}
{"test": "import unittest\n\nclass TestCalculateExpression(unittest.TestCase):\n    def test_case_1(self):\n        # Test simple addition\n        result = calculate_expression(\"1 + 1\")\n        self.assertEqual(result, 2)\n    \n    def test_case_2(self):\n        # Test subtraction\n        result = calculate_expression(\"5 - 3\")\n        self.assertEqual(result, 2)\n    \n    def test_case_3(self):\n        # Test multiplication\n        result = calculate_expression(\"2 * 3\")\n        self.assertEqual(result, 6)\n    \n    def test_case_4(self):\n        # Test division\n        result = calculate_expression(\"10 / 2\")\n        self.assertEqual(result, 5.0)\n    \n    def test_case_5(self):\n        # Test parentheses\n        result = calculate_expression(\"(1+2)*3\")\n        self.assertEqual(result, 9)\n    \n    def test_case_6(self):\n        # Test decimal numbers\n        result = calculate_expression(\"2.5 * 2\")\n        self.assertEqual(result, 5.0)\n    \n    def test_case_7(self):\n        # Test with spaces\n        result = calculate_expression(\"  2   + 3  \")\n        self.assertEqual(result, 5)\n    \n    def test_case_8(self):\n        # Test empty string\n        with self.assertRaises(ValueError):\n            calculate_expression(\"\")\n    \n    def test_case_9(self):\n        # Test invalid character\n        with self.assertRaises(ValueError):\n            calculate_expression(\"2 + a\")\n    \n    def test_case_10(self):\n        # Test function call\n        with self.assertRaises(ValueError):\n            calculate_expression(\"print('hello')\")\n    \n    def test_case_11(self):\n        # Test attribute access\n        with self.assertRaises(ValueError):\n            calculate_expression(\"a.b\")\n    \n    def test_case_12(self):\n        # Test division by zero\n        with self.assertRaises(ValueError):\n            calculate_expression(\"1/0\")\n    \n    def test_case_13(self):\n        # Test invalid syntax\n        with self.assertRaises(ValueError):\n            calculate_expression(\"2 + * 3\")\n    \n    def test_case_14(self):\n        # Test negative number\n        result = calculate_expression(\"-5 + 3\")\n        self.assertEqual(result, -2)\n    \n    def test_case_15(self):\n        # Test unary minus\n        result = calculate_expression(\"2 + -3\")\n        self.assertEqual(result, -1)\n    \n    def test_case_16(self):\n        # Test mixed operations\n        result = calculate_expression(\"2 * 3 + 4 - 5 / 2\")\n        self.assertEqual(result, 7.5)\n    \n    def test_case_17(self):\n        # Test unbalanced parentheses\n        with self.assertRaises(ValueError):\n            calculate_expression(\"((2 + 3) * 4\")\n    \n    def test_case_18(self):\n        # Test valid expression with multiple operators\n        result = calculate_expression(\"3 * -2 + 4\")\n        self.assertEqual(result, -2)\n    \n    def test_case_19(self):\n        # Test float result\n        result = calculate_expression(\"3.2 / 2\")\n        self.assertAlmostEqual(result, 1.6, places=7)\n    \n    def test_case_20(self):\n        # Test complex expression\n        result = calculate_expression(\"2 * (3 + 4) / (5 - 1)\")\n        self.assertEqual(result, 3.5)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 20, "task_id": "c176828c"}
{"test": "import unittest\nimport re\nimport ast\n\nclass TestEvaluateExpression(unittest.TestCase):\n    \n    def test_case_1(self):\n        # Test simple addition\n        result = evaluate_expression(\"2+3\")\n        self.assertEqual(result, 5)\n\n    def test_case_2(self):\n        # Test simple subtraction\n        result = evaluate_expression(\"5-2\")\n        self.assertEqual(result, 3)\n\n    def test_case_3(self):\n        # Test simple multiplication\n        result = evaluate_expression(\"2*3\")\n        self.assertEqual(result, 6)\n\n    def test_case_4(self):\n        # Test simple division\n        result = evaluate_expression(\"6/3\")\n        self.assertEqual(result, 2.0)\n\n    def test_case_5(self):\n        # Test expression with parentheses\n        result = evaluate_expression(\"(2+3)*4\")\n        self.assertEqual(result, 20)\n\n    def test_case_6(self):\n        # Test decimal numbers\n        result = evaluate_expression(\"3.5 * 2\")\n        self.assertEqual(result, 7.0)\n\n    def test_case_7(self):\n        # Test expression with spaces and operator precedence\n        result = evaluate_expression(\" 2 + 3 * 4 \")\n        self.assertEqual(result, 14)\n\n    def test_case_8(self):\n        # Test empty string\n        with self.assertRaises(ValueError):\n            evaluate_expression(\"\")\n\n    def test_case_9(self):\n        # Test invalid character (letter)\n        with self.assertRaises(ValueError):\n            evaluate_expression(\"2 + a\")\n\n    def test_case_10(self):\n        # Test invalid character (comma)\n        with self.assertRaises(ValueError):\n            evaluate_expression(\"2,3\")\n\n    def test_case_11(self):\n        # Test disallowed operation: function call\n        with self.assertRaises(ValueError):\n            evaluate_expression(\"abs(-1)\")\n\n    def test_case_12(self):\n        # Test disallowed operation: attribute access\n        with self.assertRaises(ValueError):\n            evaluate_expression(\"1 .real\")\n\n    def test_case_13(self):\n        # Test division by zero\n        with self.assertRaises(ValueError):\n            evaluate_expression(\"1/0\")\n\n    def test_case_14(self):\n        # Test negative number at start\n        result = evaluate_expression(\"-5 + 3\")\n        self.assertEqual(result, -2)\n\n    def test_case_15(self):\n        # Test longer expression with mixed operators\n        result = evaluate_expression(\"2 * 3 + 4 * 5 - 10 / 2\")\n        self.assertEqual(result, 21)\n\n    def test_case_16(self):\n        # Test nested parentheses\n        result = evaluate_expression(\"((2 + 3) * (4 - 1))\")\n        self.assertEqual(result, 15)\n\n    def test_case_17(self):\n        # Test exponentiation (allowed by current implementation)\n        result = evaluate_expression(\"2**3\")\n        self.assertEqual(result, 8)\n\n    def test_case_18(self):\n        # Test floor division (allowed by current implementation)\n        result = evaluate_expression(\"5//2\")\n        self.assertEqual(result, 2)\n\n    def test_case_19(self):\n        # Test invalid character: modulo\n        with self.assertRaises(ValueError):\n            evaluate_expression(\"5 % 2\")\n\n    def test_case_20(self):\n        # Test long additive expression\n        result = evaluate_expression(\"1+2+3+4+5+6+7+8+9+10\")\n        self.assertEqual(result, 55)\n\n    def test_case_21(self):\n        # Test incomplete expression\n        with self.assertRaises(ValueError):\n            evaluate_expression(\"2 + \")\n\n    def test_case_22(self):\n        # Test syntax error: consecutive operators\n        with self.assertRaises(ValueError):\n            evaluate_expression(\"2 + * 3\")\n\n    def test_case_23(self):\n        # Test empty parentheses\n        with self.assertRaises(ValueError):\n            evaluate_expression(\"()\")\n\n    def test_case_24(self):\n        # Test negative sign in the middle of expression\n        result = evaluate_expression(\"3 * -2\")\n        self.assertEqual(result, -6)\n\n    def test_case_25(self):\n        # Test negative sign at beginning followed by multiplication\n        result = evaluate_expression(\"-2 * 3\")\n        self.assertEqual(result, -6)", "num_test_cases": 25, "task_id": "0026490d"}
{"test": "import unittest\n\nclass TestComputeExpression(unittest.TestCase):\n    # Happy Path Tests\n    def test_simple_addition(self):\n        self.assertEqual(compute_expression('2+3'), 5)\n\n    def test_simple_multiplication(self):\n        self.assertEqual(compute_expression('2 * 3'), 6)\n\n    def test_decimal_multiplication(self):\n        self.assertEqual(compute_expression('3.5 * 2'), 7.0)\n\n    def test_division(self):\n        self.assertEqual(compute_expression('10 / 2'), 5.0)\n\n    def test_parentheses(self):\n        self.assertEqual(compute_expression('(2+3)*4'), 20)\n\n    def test_negative_result(self):\n        self.assertEqual(compute_expression('5 - 10'), -5)\n\n    def test_operator_precedence(self):\n        self.assertEqual(compute_expression('2 + 3 * 4'), 14)\n\n    # Edge Cases\n    def test_single_number(self):\n        self.assertEqual(compute_expression('42'), 42)\n\n    def test_single_negative_number(self):\n        self.assertEqual(compute_expression('-5'), -5)\n\n    def test_decimal_without_leading_zero(self):\n        self.assertEqual(compute_expression('.5 * 2'), 1.0)\n\n    def test_long_expression(self):\n        expr = '0' + '+1' * 1000\n        self.assertEqual(compute_expression(expr), 1000)\n\n    def test_expression_with_spaces(self):\n        self.assertEqual(compute_expression('  2   +   3   '), 5)\n\n    # Error Handling Tests\n    def test_empty_string(self):\n        with self.assertRaises(ValueError):\n            compute_expression('')\n\n    def test_only_spaces(self):\n        with self.assertRaises(ValueError):\n            compute_expression('   ')\n\n    def test_invalid_character_letter(self):\n        with self.assertRaises(ValueError):\n            compute_expression('2 + a')\n\n    def test_invalid_character_underscore(self):\n        with self.assertRaises(ValueError):\n            compute_expression('2 + _')\n\n    def test_function_call(self):\n        with self.assertRaises(ValueError):\n            compute_expression('abs(-5)')\n\n    def test_attribute_access(self):\n        with self.assertRaises(ValueError):\n            compute_expression('x.y')\n\n    def test_division_by_zero(self):\n        with self.assertRaises(ValueError):\n            compute_expression('1/0')\n\n    def test_incomplete_expression(self):\n        with self.assertRaises(ValueError):\n            compute_expression('2 + ')\n\n    def test_two_numbers_without_operator(self):\n        with self.assertRaises(ValueError):\n            compute_expression('2 3')\n\n    def test_exponentiation_disallowed(self):\n        with self.assertRaises(ValueError):\n            compute_expression('2**3')\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 22, "task_id": "cdcce8d0"}
{"test": "import unittest\n\nclass TestCalculateExpression(unittest.TestCase):\n\n    def test_case_1(self):\n        # Test basic addition\n        self.assertEqual(calculate_expression(\"1 + 1\"), 2)\n\n    def test_case_2(self):\n        # Test subtraction\n        self.assertEqual(calculate_expression(\"5 - 3\"), 2)\n\n    def test_case_3(self):\n        # Test multiplication\n        self.assertEqual(calculate_expression(\"2 * 3\"), 6)\n\n    def test_case_4(self):\n        # Test division\n        self.assertEqual(calculate_expression(\"6 / 2\"), 3.0)\n\n    def test_case_5(self):\n        # Test parentheses\n        self.assertEqual(calculate_expression(\"(1 + 2) * 3\"), 9)\n\n    def test_case_6(self):\n        # Test decimal numbers\n        self.assertEqual(calculate_expression(\"3.5 * 2\"), 7.0)\n\n    def test_case_7(self):\n        # Test negative number in expression\n        self.assertEqual(calculate_expression(\"5 + -3\"), 2)\n\n    def test_case_8(self):\n        # Test whitespace handling\n        self.assertEqual(calculate_expression(\"  2  +  3  \"), 5)\n\n    def test_case_9(self):\n        # Test division by zero\n        with self.assertRaises(ValueError):\n            calculate_expression(\"1 / 0\")\n\n    def test_case_10(self):\n        # Test invalid character '@'\n        with self.assertRaises(ValueError):\n            calculate_expression(\"2 @ 3\")\n\n    def test_case_11(self):\n        # Test invalid string \"import os\"\n        with self.assertRaises(ValueError):\n            calculate_expression(\"import os\")\n\n    def test_case_12(self):\n        # Test invalid string \"abs(-1)\"\n        with self.assertRaises(ValueError):\n            calculate_expression(\"abs(-1)\")\n\n    def test_case_13(self):\n        # Test complex expression\n        self.assertEqual(calculate_expression(\"2 * (3 + 4) / 7\"), 2.0)\n\n    def test_case_14(self):\n        # Test invalid character letter 'a'\n        with self.assertRaises(ValueError):\n            calculate_expression(\"a + 1\")\n\n    def test_case_15(self):\n        # Test empty string\n        with self.assertRaises(ValueError):\n            calculate_expression(\"\")\n\n    def test_case_16(self):\n        # Test whitespace only\n        with self.assertRaises(ValueError):\n            calculate_expression(\"   \")\n\n    def test_case_17(self):\n        # Test large numbers\n        self.assertEqual(calculate_expression(\"1234567890 * 987654321\"), 1234567890 * 987654321)\n\n    def test_case_18(self):\n        # Test invalid decimal format\n        with self.assertRaises(ValueError):\n            calculate_expression(\"1.2.3\")\n\n    def test_case_19(self):\n        # Test unary plus\n        self.assertEqual(calculate_expression(\"+5\"), 5)\n\n    def test_case_20(self):\n        # Test unary minus\n        self.assertEqual(calculate_expression(\"-5\"), -5)\n\n    def test_case_21(self):\n        # Test unary minus with multiplication\n        self.assertEqual(calculate_expression(\"-5 * 2\"), -10)\n\n    def test_case_22(self):\n        # Test exponentiation\n        self.assertEqual(calculate_expression(\"2 ** 3\"), 8)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 22, "task_id": "83f9a182"}
{"test": "import unittest\n\nclass TestEvaluateMathExpression(unittest.TestCase):\n    def test_case_1(self):\n        # Test simple addition\n        self.assertEqual(evaluate_math_expression('2+3'), 5)\n\n    def test_case_2(self):\n        # Test with spaces\n        self.assertEqual(evaluate_math_expression('  (  2 * 3 )  '), 6)\n\n    def test_case_3(self):\n        # Test negative number\n        self.assertEqual(evaluate_math_expression('-5 + 3'), -2)\n\n    def test_case_4(self):\n        # Test invalid character\n        with self.assertRaises(ValueError):\n            evaluate_math_expression('2 + a')\n\n    def test_case_5(self):\n        # Test function call (disallowed)\n        with self.assertRaises(ValueError):\n            evaluate_math_expression('print(1)')\n\n    def test_case_6(self):\n        # Test division by zero\n        with self.assertRaises(ValueError):\n            evaluate_math_expression('1/0')\n\n    def test_case_7(self):\n        # Test empty string\n        with self.assertRaises(ValueError):\n            evaluate_math_expression('')\n\n    def test_case_8(self):\n        # Test unmatched parentheses\n        with self.assertRaises(ValueError):\n            evaluate_math_expression('(2+3')\n\n    def test_case_9(self):\n        # Test mixed operations\n        self.assertEqual(evaluate_math_expression('3*4+5/2-1'), 13.5)\n\n    def test_case_10(self):\n        # Test float numbers\n        self.assertEqual(evaluate_math_expression('3.14 + 2.86'), 6.0)\n\n    def test_case_11(self):\n        # Test exponentiation (allowed per current implementation)\n        self.assertEqual(evaluate_math_expression('2 ** 3'), 8)\n\n    def test_case_12(self):\n        # Test complex expression with parentheses\n        self.assertEqual(evaluate_math_expression('(10-2)*(3+5)/4'), 16.0)\n\n    def test_case_13(self):\n        # Test double negative\n        self.assertEqual(evaluate_math_expression('--5'), 5)\n\n    def test_case_14(self):\n        # Test division by zero in complex expression\n        with self.assertRaises(ValueError):\n            evaluate_math_expression('(10+5)/(5-5)')\n\n    def test_case_15(self):\n        # Test comma (invalid character)\n        with self.assertRaises(ValueError):\n            evaluate_math_expression('1,2')\n\n    def test_case_16(self):\n        # Test incomplete expression\n        with self.assertRaises(ValueError):\n            evaluate_math_expression('2 + ')\n\n    def test_case_17(self):\n        # Test invalid float syntax\n        with self.assertRaises(ValueError):\n            evaluate_math_expression('3..14')\n\n    def test_case_18(self):\n        # Test large numbers\n        self.assertEqual(evaluate_math_expression('12345678901234567890 * 12345678901234567890'), 12345678901234567890 * 12345678901234567890)\n\n    def test_case_19(self):\n        # Test modulo operator (invalid character)\n        with self.assertRaises(ValueError):\n            evaluate_math_expression('10 % 3')\n\n    def test_case_20(self):\n        # Test nested parentheses\n        self.assertEqual(evaluate_math_expression('((3+5)*2 - 4)/3'), 4.0)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 20, "task_id": "b4bbe030"}
{"test": "import unittest\nfrom solution import process_math_expression\n\nclass TestProcessMathExpression(unittest.TestCase):\n    def test_simple_addition(self):\n        # Test basic addition\n        self.assertEqual(process_math_expression(\"2+3\"), 5)\n\n    def test_with_spaces(self):\n        # Test expression with spaces\n        self.assertEqual(process_math_expression(\" 2 * 3 \"), 6)\n\n    def test_parentheses(self):\n        # Test expression with parentheses\n        self.assertEqual(process_math_expression(\"(2+3)*4\"), 20)\n\n    def test_division(self):\n        # Test division\n        self.assertEqual(process_math_expression(\"10/2\"), 5.0)\n\n    def test_negative_number(self):\n        # Test negative number\n        self.assertEqual(process_math_expression(\"2 + -3\"), -1)\n\n    def test_division_by_zero(self):\n        # Test division by zero\n        with self.assertRaises(ValueError):\n            process_math_expression(\"1/0\")\n\n    def test_invalid_character(self):\n        # Test expression with invalid character\n        with self.assertRaises(ValueError):\n            process_math_expression(\"2 + a\")\n\n    def test_function_call(self):\n        # Test expression with function call\n        with self.assertRaises(ValueError):\n            process_math_expression(\"abs(-1)\")\n\n    def test_variable_name(self):\n        # Test expression with variable name\n        with self.assertRaises(ValueError):\n            process_math_expression(\"x\")\n\n    def test_empty_string(self):\n        # Test empty string input\n        with self.assertRaises(ValueError):\n            process_math_expression(\"\")\n\n    def test_only_spaces(self):\n        # Test expression with only spaces\n        with self.assertRaises(ValueError):\n            process_math_expression(\"   \")\n\n    def test_large_numbers(self):\n        # Test with large numbers\n        self.assertEqual(process_math_expression(\"1234567890 * 9876543210\"), 1234567890 * 9876543210)\n\n    def test_long_expression(self):\n        # Test long expression with multiple operations\n        self.assertEqual(process_math_expression(\"2+3*4/2-1\"), 7.0)\n\n    def test_nested_parentheses(self):\n        # Test nested parentheses\n        self.assertEqual(process_math_expression(\"((2+3)*(4-1))\"), 15)\n\n    def test_decimal_number(self):\n        # Test decimal number\n        self.assertEqual(process_math_expression(\"2.5 * 2\"), 5.0)\n\n    def test_exponentiation_raises_error(self):\n        # Test exponentiation (disallowed operator)\n        with self.assertRaises(ValueError):\n            process_math_expression(\"2**3\")\n\n    def test_modulo_operator(self):\n        # Test modulo operator (invalid character)\n        with self.assertRaises(ValueError):\n            process_math_expression(\"5%2\")\n\n    def test_invalid_decimal(self):\n        # Test invalid decimal format\n        with self.assertRaises(ValueError):\n            process_math_expression(\"2..5\")\n\n    def test_consecutive_operators_valid(self):\n        # Test valid consecutive operators\n        self.assertEqual(process_math_expression(\"2++3\"), 5)\n\n    def test_consecutive_operators_invalid(self):\n        # Test invalid consecutive operators\n        with self.assertRaises(ValueError):\n            process_math_expression(\"2+*3\")\n\n    def test_missing_operand(self):\n        # Test missing operand\n        with self.assertRaises(ValueError):\n            process_math_expression(\"2+\")\n", "num_test_cases": 21, "task_id": "fb290459"}
{"test": "import unittest\n\nclass TestComputeExpression(unittest.TestCase):\n    \n    def test_addition(self):\n        # Test basic addition\n        self.assertEqual(compute_expression('1+1'), 2)\n    \n    def test_subtraction(self):\n        # Test basic subtraction\n        self.assertEqual(compute_expression('5-3'), 2)\n    \n    def test_multiplication(self):\n        # Test basic multiplication\n        self.assertEqual(compute_expression('2*3'), 6)\n    \n    def test_division(self):\n        # Test basic division\n        self.assertEqual(compute_expression('6/2'), 3.0)\n    \n    def test_spaces(self):\n        # Test expression with spaces\n        self.assertEqual(compute_expression(' 2 + 3 * 4 '), 14)\n    \n    def test_parentheses(self):\n        # Test expression with parentheses\n        self.assertEqual(compute_expression('(2+3)*4'), 20)\n    \n    def test_decimal(self):\n        # Test expression with decimal numbers\n        self.assertEqual(compute_expression('3.5 * 2'), 7.0)\n    \n    def test_negative(self):\n        # Test expression with negative number\n        self.assertEqual(compute_expression('-5 + 3'), -2)\n    \n    def test_large_number(self):\n        # Test expression with a very large number\n        large_num = 123456789012345678901234567890\n        self.assertEqual(compute_expression('123456789012345678901234567890'), large_num)\n    \n    def test_division_by_zero(self):\n        # Test division by zero which should raise ValueError\n        with self.assertRaises(ValueError):\n            compute_expression('1/0')\n    \n    def test_invalid_character_letter(self):\n        # Test expression with invalid character (letter)\n        with self.assertRaises(ValueError):\n            compute_expression('a')\n    \n    def test_invalid_character_symbol(self):\n        # Test expression with invalid character (symbol)\n        with self.assertRaises(ValueError):\n            compute_expression('2@3')\n    \n    def test_empty_string(self):\n        # Test empty input string\n        with self.assertRaises(ValueError):\n            compute_expression('')\n    \n    def test_only_spaces(self):\n        # Test expression with only spaces\n        with self.assertRaises(ValueError):\n            compute_expression('   ')\n    \n    def test_syntax_error_double_plus(self):\n        # Test expression with double plus (syntax error)\n        with self.assertRaises(ValueError):\n            compute_expression('1++2')\n    \n    def test_syntax_error_missing_operator(self):\n        # Test expression with missing operator (syntax error)\n        with self.assertRaises(ValueError):\n            compute_expression('1 2')\n    \n    def test_operator_precedence(self):\n        # Test operator precedence (* before +)\n        self.assertEqual(compute_expression('2+3*4'), 14)\n    \n    def test_unary_operator(self):\n        # Test expression with unary minus\n        self.assertEqual(compute_expression('3 * -2'), -6)\n    \n    def test_nested_parentheses(self):\n        # Test expression with nested parentheses\n        self.assertEqual(compute_expression('((2+3)*4)'), 20)\n    \n    def test_long_expression(self):\n        # Test a long expression (sum of numbers 1 to 10)\n        self.assertEqual(compute_expression('1+2+3+4+5+6+7+8+9+10'), 55)\n    \n    def test_exponentiation(self):\n        # Test exponentiation (allowed by the function)\n        self.assertEqual(compute_expression('2**3'), 8)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 21, "task_id": "8c30ab84"}
{"test": "import unittest\n\nclass TestSecureEvalExpression(unittest.TestCase):\n    def test_valid_addition(self):\n        # Test basic addition\n        self.assertEqual(secure_eval_expression('1+1'), 2)\n        \n    def test_valid_subtraction(self):\n        # Test basic subtraction\n        self.assertEqual(secure_eval_expression('5-3'), 2)\n        \n    def test_valid_multiplication(self):\n        # Test basic multiplication\n        self.assertEqual(secure_eval_expression('2*3'), 6)\n        \n    def test_valid_division(self):\n        # Test basic division\n        self.assertEqual(secure_eval_expression('10/2'), 5.0)\n        \n    def test_valid_parentheses(self):\n        # Test expressions with parentheses\n        self.assertEqual(secure_eval_expression('(2+3)*4'), 20)\n        self.assertEqual(secure_eval_expression('2*(3+4)'), 14)\n        \n    def test_valid_decimals(self):\n        # Test decimal numbers\n        self.assertEqual(secure_eval_expression('3.5*2'), 7.0)\n        self.assertEqual(secure_eval_expression('10.0/4'), 2.5)\n        \n    def test_valid_spaces(self):\n        # Test expressions with spaces\n        self.assertEqual(secure_eval_expression(' 2  +  3  '), 5)\n        self.assertEqual(secure_eval_expression('( 4 * 2 ) / 2'), 4.0)\n        \n    def test_valid_negative_numbers(self):\n        # Test negative numbers and unary operators\n        self.assertEqual(secure_eval_expression('-5'), -5)\n        self.assertEqual(secure_eval_expression('3 * -2'), -6)\n        self.assertEqual(secure_eval_expression('--1'), 1)\n        \n    def test_valid_complex_expression(self):\n        # Test complex expressions with multiple operations\n        self.assertEqual(secure_eval_expression('2+3*4'), 14)\n        self.assertEqual(secure_eval_expression('(2+3)*4/2'), 10.0)\n        self.assertEqual(secure_eval_expression('10.5/0.5-3'), 18.0)\n        \n    def test_empty_string(self):\n        # Test empty input\n        with self.assertRaises(ValueError):\n            secure_eval_expression('')\n        \n    def test_invalid_characters(self):\n        # Test expressions with invalid characters\n        with self.assertRaises(ValueError):\n            secure_eval_expression('a + 1')\n        with self.assertRaises(ValueError):\n            secure_eval_expression('2^3')\n        with self.assertRaises(ValueError):\n            secure_eval_expression('1,000')\n        with self.assertRaises(ValueError):\n            secure_eval_expression('os.system(\"ls\")')\n        \n    def test_disallowed_operations(self):\n        # Test expressions with disallowed AST nodes\n        with self.assertRaises(ValueError):  # Function call\n            secure_eval_expression('abs(-1)')\n        with self.assertRaises(ValueError):  # Call node\n            secure_eval_expression('1(2)')\n        with self.assertRaises(ValueError):  # Name node\n            secure_eval_expression('x + 1')\n        with self.assertRaises(ValueError):  # Attribute access\n            secure_eval_expression('(1).real')\n        \n    def test_syntax_errors(self):\n        # Test invalid expressions\n        with self.assertRaises(ValueError):  # Unmatched parentheses\n            secure_eval_expression('(1+2')\n        with self.assertRaises(ValueError):  # Invalid float\n            secure_eval_expression('1.2.3')\n        with self.assertRaises(ValueError):  # Multiple operators\n            secure_eval_expression('2++3')\n        \n    def test_division_by_zero(self):\n        # Test division by zero\n        with self.assertRaises(ValueError):\n            secure_eval_expression('1/0')\n        \n    def test_large_numbers(self):\n        # Test large numbers\n        self.assertEqual(secure_eval_expression('1234567890*2'), 2469135780)\n        \n    def test_long_expression(self):\n        # Test long valid expression\n        expr = '1' + '+1'*500\n        self.assertEqual(secure_eval_expression(expr), 501)\n        \n    def test_exponentiation(self):\n        # Test exponentiation (allowed by current implementation)\n        self.assertEqual(secure_eval_expression('2**3'), 8)\n        self.assertEqual(secure_eval_expression('3**2'), 9)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 18, "task_id": "86ac3344"}
{"test": "import unittest\n\nclass TestSecureMathEval(unittest.TestCase):\n\n    def test_addition(self):\n        # Test basic addition\n        self.assertEqual(secure_math_eval('1+1'), 2)\n\n    def test_subtraction(self):\n        # Test basic subtraction\n        self.assertEqual(secure_math_eval('5-3'), 2)\n\n    def test_multiplication(self):\n        # Test basic multiplication\n        self.assertEqual(secure_math_eval('2*3'), 6)\n\n    def test_division(self):\n        # Test basic division\n        self.assertEqual(secure_math_eval('6/2'), 3.0)\n\n    def test_parentheses(self):\n        # Test expression with parentheses\n        self.assertEqual(secure_math_eval('(1+2)*3'), 9)\n\n    def test_spaces(self):\n        # Test expression with spaces\n        self.assertEqual(secure_math_eval(' 2 + 3 * 4 '), 14)\n\n    def test_decimal(self):\n        # Test expression with decimal numbers\n        self.assertEqual(secure_math_eval('3.5 * 2'), 7.0)\n\n    def test_exponentiation(self):\n        # Test exponentiation (currently allowed by the function)\n        self.assertEqual(secure_math_eval('2**3'), 8)\n\n    def test_empty_string(self):\n        # Test empty string\n        with self.assertRaises(ValueError):\n            secure_math_eval('')\n\n    def test_only_spaces(self):\n        # Test string with only spaces\n        with self.assertRaises(ValueError):\n            secure_math_eval('   ')\n\n    def test_long_expression(self):\n        # Test long expression\n        self.assertEqual(secure_math_eval('1+2+3+4+5+6+7+8+9+10'), 55)\n\n    def test_division_by_zero(self):\n        # Test division by zero\n        with self.assertRaises(ValueError):\n            secure_math_eval('1/0')\n\n    def test_invalid_character(self):\n        # Test invalid character\n        with self.assertRaises(ValueError):\n            secure_math_eval('a')\n\n    def test_comma_character(self):\n        # Test comma character\n        with self.assertRaises(ValueError):\n            secure_math_eval('1,2')\n\n    def test_exponentiation_with_invalid_char(self):\n        # Test exponentiation with invalid character\n        with self.assertRaises(ValueError):\n            secure_math_eval('2**a')\n\n    def test_function_call(self):\n        # Test function call\n        with self.assertRaises(ValueError):\n            secure_math_eval('1(2)')\n\n    def test_negative_numbers(self):\n        # Test negative numbers\n        self.assertEqual(secure_math_eval('-5+3'), -2)\n\n    def test_nested_parentheses(self):\n        # Test nested parentheses\n        self.assertEqual(secure_math_eval('((1+2)*3)'), 9)\n\n    def test_single_number(self):\n        # Test single number\n        self.assertEqual(secure_math_eval('42'), 42)\n\n    def test_single_decimal(self):\n        # Test single decimal number\n        self.assertEqual(secure_math_eval('3.14'), 3.14)\n\n    def test_unmatched_parentheses(self):\n        # Test unmatched parentheses\n        with self.assertRaises(ValueError):\n            secure_math_eval('(1+2')\n\n    def test_invalid_decimal(self):\n        # Test invalid decimal format\n        with self.assertRaises(ValueError):\n            secure_math_eval('1.2.3')\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 22, "task_id": "d796ed7c"}
{"test": "import unittest\n\nclass TestCases(unittest.TestCase):\n    def test_case_1(self):\n        # Test simple addition\n        result = evaluate_math_expression('2+3')\n        self.assertEqual(result, 5)\n\n    def test_case_2(self):\n        # Test simple subtraction\n        result = evaluate_math_expression('5-3')\n        self.assertEqual(result, 2)\n\n    def test_case_3(self):\n        # Test simple multiplication\n        result = evaluate_math_expression('2*3')\n        self.assertEqual(result, 6)\n\n    def test_case_4(self):\n        # Test simple division\n        result = evaluate_math_expression('6/3')\n        self.assertEqual(result, 2.0)\n\n    def test_case_5(self):\n        # Test operator precedence and spaces\n        result = evaluate_math_expression(' 2 + 3 * 4 ')\n        self.assertEqual(result, 14)\n\n    def test_case_6(self):\n        # Test parentheses\n        result = evaluate_math_expression('(2+3)*4')\n        self.assertEqual(result, 20)\n\n    def test_case_7(self):\n        # Test division by zero\n        with self.assertRaises(ValueError):\n            evaluate_math_expression('5/0')\n\n    def test_case_8(self):\n        # Test empty string\n        with self.assertRaises(ValueError):\n            evaluate_math_expression('')\n\n    def test_case_9(self):\n        # Test invalid character (letter)\n        with self.assertRaises(ValueError):\n            evaluate_math_expression('2 + a')\n\n    def test_case_10(self):\n        # Test invalid character (symbol)\n        with self.assertRaises(ValueError):\n            evaluate_math_expression('3$4')\n\n    def test_case_11(self):\n        # Test function call (invalid characters and disallowed operation)\n        with self.assertRaises(ValueError):\n            evaluate_math_expression('pow(2,3)')\n\n    def test_case_12(self):\n        # Test decimal numbers\n        result = evaluate_math_expression('3.5 + 2.5')\n        self.assertEqual(result, 6.0)\n\n    def test_case_13(self):\n        # Test invalid syntax\n        with self.assertRaises(ValueError):\n            evaluate_math_expression('2 + * 3')\n\n    def test_case_14(self):\n        # Test unbalanced parentheses\n        with self.assertRaises(ValueError):\n            evaluate_math_expression('(2+3')\n\n    def test_case_15(self):\n        # Test negative numbers\n        result = evaluate_math_expression('-5 + 3')\n        self.assertEqual(result, -2)\n\n    def test_case_16(self):\n        # Test fractional result\n        result = evaluate_math_expression('2/3')\n        self.assertAlmostEqual(result, 0.6666666666666666, places=10)\n\n    def test_case_17(self):\n        # Test large numbers\n        result = evaluate_math_expression('999999 * 999999')\n        self.assertEqual(result, 999998000001)\n\n    def test_case_18(self):\n        # Test complex expression with nested parentheses\n        result = evaluate_math_expression('((2+3)*4 - 1)/5')\n        self.assertEqual(result, 3.8)\n\n    def test_case_19(self):\n        # Test expression with multiple decimal points\n        result = evaluate_math_expression('0.5 * 0.5')\n        self.assertEqual(result, 0.25)\n\n    def test_case_20(self):\n        # Test expression with only parentheses\n        with self.assertRaises(ValueError):\n            evaluate_math_expression('()')\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 20, "task_id": "965659df"}
{"test": "import unittest\n\nclass TestExpressionEvaluation(unittest.TestCase):\n    def test_case_1(self):\n        # Test basic addition: 1+1\n        self.assertEqual(evaluate_expression_safely(\"1 + 1\"), 2)\n\n    def test_case_2(self):\n        # Test expression with whitespace: (2*3)\n        self.assertEqual(evaluate_expression_safely(\" ( 2 * 3 ) \"), 6)\n\n    def test_case_3(self):\n        # Test negative number: -5+3\n        self.assertEqual(evaluate_expression_safely(\"-5 + 3\"), -2)\n\n    def test_case_4(self):\n        # Test decimal multiplication: 3.5 * 2\n        self.assertEqual(evaluate_expression_safely(\"3.5 * 2\"), 7.0)\n\n    def test_case_5(self):\n        # Test division: 10/2\n        self.assertEqual(evaluate_expression_safely(\"10 / 2\"), 5.0)\n\n    def test_case_6(self):\n        # Test division by zero\n        with self.assertRaises(ValueError):\n            evaluate_expression_safely(\"1 / 0\")\n\n    def test_case_7(self):\n        # Test disallowed character 'a'\n        with self.assertRaises(ValueError):\n            evaluate_expression_safely(\"2 + a\")\n\n    def test_case_8(self):\n        # Test complex expression: (3+4)*(5-2)\n        self.assertEqual(evaluate_expression_safely(\"(3 + 4) * (5 - 2)\"), 21)\n\n    def test_case_9(self):\n        # Test exponentiation: 2**3\n        self.assertEqual(evaluate_expression_safely(\"2**3\"), 8)\n\n    def test_case_10(self):\n        # Test empty expression\n        with self.assertRaises(ValueError):\n            evaluate_expression_safely(\"\")\n\n    def test_case_11(self):\n        # Test whitespace-only expression\n        with self.assertRaises(ValueError):\n            evaluate_expression_safely(\"   \")\n\n    def test_case_12(self):\n        # Test invalid syntax: consecutive operators\n        with self.assertRaises(ValueError):\n            evaluate_expression_safely(\"2 + * 3\")\n\n    def test_case_13(self):\n        # Test mismatched parentheses\n        with self.assertRaises(ValueError):\n            evaluate_expression_safely(\"(2 + 3\")\n\n    def test_case_14(self):\n        # Test invalid float: two decimal points\n        with self.assertRaises(ValueError):\n            evaluate_expression_safely(\"2..3\")\n\n    def test_case_15(self):\n        # Test invalid attribute syntax (spaced number and decimal)\n        with self.assertRaises(ValueError):\n            evaluate_expression_safely(\"2 . 3\")\n\n    def test_case_16(self):\n        # Test multiplication with negative number: 5 * -3\n        self.assertEqual(evaluate_expression_safely(\"5 * -3\"), -15)\n\n    def test_case_17(self):\n        # Test division by negative number: 10 / -2\n        self.assertEqual(evaluate_expression_safely(\"10 / -2\"), -5.0)\n\n    def test_case_18(self):\n        # Test float addition: 2.5 + 3.5\n        self.assertEqual(evaluate_expression_safely(\"2.5 + 3.5\"), 6.0)\n\n    def test_case_19(self):\n        # Test large integer multiplication\n        expr = \"1234567890 * 1234567890\"\n        expected = 1234567890 * 1234567890\n        self.assertEqual(evaluate_expression_safely(expr), expected)\n\nif __name__ == \"__main__\":\n    unittest.main()", "num_test_cases": 19, "task_id": "7136aeb5"}
{"test": "import unittest\n\nclass TestSecureMathEval(unittest.TestCase):\n    \n    def test_valid_addition(self):\n        # Test basic addition\n        self.assertEqual(secure_math_eval(\"1 + 1\"), 2)\n    \n    def test_valid_subtraction(self):\n        # Test basic subtraction\n        self.assertEqual(secure_math_eval(\"5 - 3\"), 2)\n    \n    def test_valid_multiplication(self):\n        # Test basic multiplication\n        self.assertEqual(secure_math_eval(\"2 * 3\"), 6)\n    \n    def test_valid_division(self):\n        # Test basic division\n        self.assertEqual(secure_math_eval(\"10 / 2\"), 5.0)\n    \n    def test_parentheses_operations(self):\n        # Test expression with parentheses\n        self.assertEqual(secure_math_eval(\"(1 + 2) * 3\"), 9)\n    \n    def test_decimal_numbers(self):\n        # Test decimal number operations\n        self.assertEqual(secure_math_eval(\"2.5 * 2\"), 5.0)\n    \n    def test_unary_minus_operations(self):\n        # Test expressions with unary minus\n        self.assertEqual(secure_math_eval(\"-5 + 2\"), -3)\n        self.assertEqual(secure_math_eval(\"--5\"), 5)\n    \n    def test_whitespace_handling(self):\n        # Test expression with significant whitespace\n        self.assertEqual(secure_math_eval(\"  2   +   3  \"), 5)\n    \n    def test_large_numbers(self):\n        # Test very large numbers\n        large_expr = \"10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 * 2\"\n        self.assertEqual(secure_math_eval(large_expr), 20000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000)\n    \n    def test_empty_string(self):\n        # Test empty input\n        with self.assertRaises(ValueError):\n            secure_math_eval(\"\")\n    \n    def test_only_whitespace(self):\n        # Test whitespace-only input\n        with self.assertRaises(ValueError):\n            secure_math_eval(\"   \")\n    \n    def test_division_by_zero(self):\n        # Test division by zero\n        with self.assertRaises(ValueError):\n            secure_math_eval(\"1/0\")\n    \n    def test_invalid_character_modulo(self):\n        # Test invalid character '%'\n        with self.assertRaises(ValueError):\n            secure_math_eval(\"2 % 3\")\n    \n    def test_invalid_character_letter(self):\n        # Test invalid letter character\n        with self.assertRaises(ValueError):\n            secure_math_eval(\"a + 1\")\n    \n    def test_function_call_attempt(self):\n        # Test function call attempt\n        with self.assertRaises(ValueError):\n            secure_math_eval(\"abs(-1)\")\n    \n    def test_exponentiation_attempt(self):\n        # Test exponentiation attempt (should be blocked per spec)\n        with self.assertRaises(ValueError):\n            secure_math_eval(\"2**3\")\n    \n    def test_assignment_attempt(self):\n        # Test assignment attempt\n        with self.assertRaises(ValueError):\n            secure_math_eval(\"x=5; x+1\")\n    \n    def test_invalid_syntax(self):\n        # Test syntactically invalid expression\n        with self.assertRaises(ValueError):\n            secure_math_eval(\"1 +\")\n    \n    def test_negative_with_spaces(self):\n        # Test negative number with spaces\n        self.assertEqual(secure_math_eval(\"5 + -2\"), 3)\n    \n    def test_complex_expression(self):\n        # Test complex valid expression\n        expr = \"(3.5 * 2) - (10 / 4) + (6 - 2.5)\"\n        self.assertEqual(secure_math_eval(expr), (3.5*2) - (10/4) + (6-2.5))\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 20, "task_id": "da6481ad"}
{"test": "import unittest\nfrom solution import perform_safe_math\n\nclass TestPerformSafeMath(unittest.TestCase):\n    def test_simple_addition(self):\n        # Test basic addition\n        self.assertEqual(perform_safe_math(\"1+1\"), 2)\n        \n    def test_operator_precedence(self):\n        # Test operator precedence (multiplication before subtraction)\n        self.assertEqual(perform_safe_math(\"5-3*2\"), -1)\n        \n    def test_division(self):\n        # Test division operation\n        self.assertEqual(perform_safe_math(\"10/2\"), 5.0)\n        \n    def test_parentheses(self):\n        # Test expression with parentheses\n        self.assertEqual(perform_safe_math(\"(1+2)*3\"), 9)\n        \n    def test_spaces(self):\n        # Test expression with spaces\n        self.assertEqual(perform_safe_math(\"  2  *  (  3  +  4  )  \"), 14)\n        \n    def test_empty_string(self):\n        # Test empty input string\n        with self.assertRaises(ValueError):\n            perform_safe_math(\"\")\n        \n    def test_invalid_character_letters(self):\n        # Test expression with invalid characters (letters)\n        with self.assertRaises(ValueError):\n            perform_safe_math(\"2 + a\")\n        \n    def test_float(self):\n        # Test valid float number\n        self.assertEqual(perform_safe_math(\"3.14\"), 3.14)\n        \n    def test_invalid_float_syntax(self):\n        # Test invalid float syntax (multiple dots)\n        with self.assertRaises(ValueError):\n            perform_safe_math(\"3..14\")\n        \n    def test_division_by_zero(self):\n        # Test division by zero\n        with self.assertRaises(ValueError):\n            perform_safe_math(\"1/0\")\n        \n    def test_unmatched_parenthesis(self):\n        # Test unmatched parenthesis\n        with self.assertRaises(ValueError):\n            perform_safe_math(\"(1+2\")\n        \n    def test_long_expression(self):\n        # Test long valid expression\n        long_expr = \"1\" + \"+1\" * 100\n        self.assertEqual(perform_safe_math(long_expr), 101)\n        \n    def test_single_dot(self):\n        # Test single dot (invalid expression)\n        with self.assertRaises(ValueError):\n            perform_safe_math(\".\")\n        \n    def test_only_spaces(self):\n        # Test input with only spaces\n        with self.assertRaises(ValueError):\n            perform_safe_math(\"   \")\n        \n    def test_negative_number(self):\n        # Test negative number\n        self.assertEqual(perform_safe_math(\"-5\"), -5)\n        \n    def test_negative_in_expression(self):\n        # Test negative number in expression\n        self.assertEqual(perform_safe_math(\"3 * -2\"), -6)\n        \n    def test_invalid_operator_sequence(self):\n        # Test invalid operator sequence\n        with self.assertRaises(ValueError):\n            perform_safe_math(\"3 + - * 5\")\n        \n    def test_function_call_invalid_character(self):\n        # Test function call (caught by invalid characters)\n        with self.assertRaises(ValueError):\n            perform_safe_math(\"abs(1)\")\n", "num_test_cases": 19, "task_id": "4fa640c1"}
