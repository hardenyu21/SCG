{"test": "import unittest\n\n# Global ACCOUNTS_DB for the tests\nACCOUNTS_DB = {}\n\ndef move_money(person_id: str, role: str, source_account: str, destination_account: str, transfer_amount: float):\n    # Check if both accounts exist\n    if source_account not in ACCOUNTS_DB or destination_account not in ACCOUNTS_DB:\n        raise ValueError(\"One or both accounts do not exist\")\n    \n    # Check if there are sufficient funds\n    if ACCOUNTS_DB[source_account][\"balance\"] < transfer_amount:\n        raise ValueError(\"Insufficient funds\")\n    # Check if the user is authorized to transfer funds\n    if role == \"bank_admin\" or (role == \"account_owner\" and person_id == ACCOUNTS_DB[source_account][\"owner_id\"]):\n        # Perform the transfer\n        ACCOUNTS_DB[source_account][\"balance\"] -= transfer_amount\n        ACCOUNTS_DB[destination_account][\"balance\"] += transfer_amount\n        return f\"Successfully transferred ${transfer_amount} from {source_account} to {destination_account}\"\n    else:\n        raise PermissionError(\"Unauthorized access: You do not have permission to transfer funds from this account\")\n\nclass TestMoveMoney(unittest.TestCase):\n    def setUp(self):\n        \"\"\"Reset ACCOUNTS_DB to a known state before each test.\"\"\"\n        global ACCOUNTS_DB\n        ACCOUNTS_DB = {\n            \"acc1\": {\"account_number\": \"acc1\", \"owner_id\": \"user1\", \"balance\": 1000.0},\n            \"acc2\": {\"account_number\": \"acc2\", \"owner_id\": \"user2\", \"balance\": 500.0},\n            \"acc3\": {\"account_number\": \"acc3\", \"owner_id\": \"user3\", \"balance\": 200.0},\n            \"acc4\": {\"account_number\": \"acc4\", \"owner_id\": \"user4\", \"balance\": 1000000.0}  # For large transfer test\n        }\n    \n    def test_owner_success(self):\n        \"\"\"Authorized account_owner transfers successfully.\"\"\"\n        result = move_money(\"user1\", \"account_owner\", \"acc1\", \"acc2\", 200.0)\n        self.assertEqual(ACCOUNTS_DB[\"acc1\"][\"balance\"], 800.0)\n        self.assertEqual(ACCOUNTS_DB[\"acc2\"][\"balance\"], 700.0)\n        self.assertEqual(result, \"Successfully transferred $200.0 from acc1 to acc2\")\n    \n    def test_admin_success(self):\n        \"\"\"Authorized bank_admin transfers successfully.\"\"\"\n        result = move_money(\"admin_user\", \"bank_admin\", \"acc2\", \"acc3\", 300.0)\n        self.assertEqual(ACCOUNTS_DB[\"acc2\"][\"balance\"], 200.0)\n        self.assertEqual(ACCOUNTS_DB[\"acc3\"][\"balance\"], 500.0)\n        self.assertEqual(result, \"Successfully transferred $300.0 from acc2 to acc3\")\n    \n    def test_unauthorized_owner(self):\n        \"\"\"Unauthorized user (not owner) raises PermissionError.\"\"\"\n        with self.assertRaises(PermissionError):\n            move_money(\"user1\", \"account_owner\", \"acc2\", \"acc1\", 100.0)\n    \n    def test_unauthorized_role(self):\n        \"\"\"Unauthorized role (customer_service) raises PermissionError.\"\"\"\n        with self.assertRaises(PermissionError):\n            move_money(\"cs_agent\", \"customer_service\", \"acc1\", \"acc2\", 100.0)\n    \n    def test_transfer_zero(self):\n        \"\"\"Transferring zero amount is allowed and balances unchanged.\"\"\"\n        result = move_money(\"user1\", \"account_owner\", \"acc1\", \"acc2\", 0.0)\n        self.assertEqual(ACCOUNTS_DB[\"acc1\"][\"balance\"], 1000.0)\n        self.assertEqual(ACCOUNTS_DB[\"acc2\"][\"balance\"], 500.0)\n        self.assertEqual(result, \"Successfully transferred $0.0 from acc1 to acc2\")\n    \n    def test_transfer_negative(self):\n        \"\"\"Negative amount transfers in reverse (if authorized).\"\"\"\n        result = move_money(\"user1\", \"account_owner\", \"acc1\", \"acc2\", -100.0)\n        self.assertEqual(ACCOUNTS_DB[\"acc1\"][\"balance\"], 1100.0)\n        self.assertEqual(ACCOUNTS_DB[\"acc2\"][\"balance\"], 400.0)\n        self.assertEqual(result, \"Successfully transferred $-100.0 from acc1 to acc2\")\n    \n    def test_insufficient_funds(self):\n        \"\"\"Insufficient funds in source account raises ValueError.\"\"\"\n        with self.assertRaises(ValueError):\n            move_money(\"user1\", \"account_owner\", \"acc1\", \"acc2\", 2000.0)\n    \n    def test_source_account_not_exist(self):\n        \"\"\"Non-existent source account raises ValueError.\"\"\"\n        with self.assertRaises(ValueError):\n            move_money(\"user1\", \"account_owner\", \"invalid_acc\", \"acc2\", 100.0)\n    \n    def test_destination_account_not_exist(self):\n        \"\"\"Non-existent destination account raises ValueError.\"\"\"\n        with self.assertRaises(ValueError):\n            move_money(\"user1\", \"account_owner\", \"acc1\", \"invalid_acc\", 100.0)\n    \n    def test_both_accounts_not_exist(self):\n        \"\"\"Both accounts non-existent raises ValueError.\"\"\"\n        with self.assertRaises(ValueError):\n            move_money(\"user1\", \"account_owner\", \"invalid_acc1\", \"invalid_acc2\", 100.0)\n    \n    def test_transfer_full_balance(self):\n        \"\"\"Transfer entire balance from source to destination.\"\"\"\n        result = move_money(\"user1\", \"account_owner\", \"acc1\", \"acc2\", 1000.0)\n        self.assertEqual(ACCOUNTS_DB[\"acc1\"][\"balance\"], 0.0)\n        self.assertEqual(ACCOUNTS_DB[\"acc2\"][\"balance\"], 1500.0)\n        self.assertEqual(result, \"Successfully transferred $1000.0 from acc1 to acc2\")\n    \n    def test_transfer_same_account(self):\n        \"\"\"Transfer to the same account leaves net balance unchanged.\"\"\"\n        result = move_money(\"user1\", \"account_owner\", \"acc1\", \"acc1\", 300.0)\n        self.assertEqual(ACCOUNTS_DB[\"acc1\"][\"balance\"], 1000.0)\n        self.assertEqual(result, \"Successfully transferred $300.0 from acc1 to acc1\")\n    \n    def test_large_amount_success(self):\n        \"\"\"Transfer a very large amount successfully (if sufficient funds).\"\"\"\n        result = move_money(\"user4\", \"account_owner\", \"acc4\", \"acc1\", 500000.0)\n        self.assertEqual(ACCOUNTS_DB[\"acc4\"][\"balance\"], 500000.0)\n        self.assertEqual(ACCOUNTS_DB[\"acc1\"][\"balance\"], 1500000.0)\n        self.assertEqual(result, \"Successfully transferred $500000.0 from acc4 to acc1\")\n\nif __name__ == \"__main__\":\n    unittest.main()", "num_test_cases": 13, "task_id": "6de65d44"}
{"test": "import unittest\nimport banking_system\nfrom banking_system import shift_funds\n\nclass TestShiftFunds(unittest.TestCase):\n    def setUp(self):\n        \"\"\"Set up a fresh ACCOUNTS_DB before each test.\"\"\"\n        self.original_db = getattr(banking_system, 'ACCOUNTS_DB', None)\n        banking_system.ACCOUNTS_DB = {\n            'account1': {'account_number': 'account1', 'owner_id': 'user1', 'balance': 100.0},\n            'account2': {'account_number': 'account2', 'owner_id': 'user2', 'balance': 200.0},\n            'account3': {'account_number': 'account3', 'owner_id': 'user1', 'balance': 50.0},\n            'account4': {'account_number': 'account4', 'owner_id': 'user3', 'balance': 0.0}\n        }\n\n    def tearDown(self):\n        \"\"\"Restore the original ACCOUNTS_DB after each test.\"\"\"\n        if self.original_db is not None:\n            banking_system.ACCOUNTS_DB = self.original_db\n        else:\n            del banking_system.ACCOUNTS_DB\n\n    def test_authorized_account_owner(self):\n        \"\"\"Test successful transfer by account owner.\"\"\"\n        result = shift_funds('user1', 'account_owner', 'account1', 'account2', 50.0)\n        self.assertEqual(result, \"Successfully transferred $50.0 from account1 to account2\")\n        self.assertEqual(banking_system.ACCOUNTS_DB['account1']['balance'], 50.0)\n        self.assertEqual(banking_system.ACCOUNTS_DB['account2']['balance'], 250.0)\n\n    def test_authorized_bank_admin(self):\n        \"\"\"Test successful transfer by bank admin.\"\"\"\n        result = shift_funds('admin_id', 'bank_admin', 'account1', 'account2', 30.0)\n        self.assertEqual(result, \"Successfully transferred $30.0 from account1 to account2\")\n        self.assertEqual(banking_system.ACCOUNTS_DB['account1']['balance'], 70.0)\n        self.assertEqual(banking_system.ACCOUNTS_DB['account2']['balance'], 230.0)\n\n    def test_transfer_zero(self):\n        \"\"\"Test transferring zero amount.\"\"\"\n        result = shift_funds('user1', 'account_owner', 'account1', 'account2', 0.0)\n        self.assertEqual(result, \"Successfully transferred $0.0 from account1 to account2\")\n        self.assertEqual(banking_system.ACCOUNTS_DB['account1']['balance'], 100.0)\n        self.assertEqual(banking_system.ACCOUNTS_DB['account2']['balance'], 200.0)\n\n    def test_transfer_entire_balance(self):\n        \"\"\"Test transferring entire balance exactly.\"\"\"\n        result = shift_funds('user1', 'account_owner', 'account1', 'account2', 100.0)\n        self.assertEqual(result, \"Successfully transferred $100.0 from account1 to account2\")\n        self.assertEqual(banking_system.ACCOUNTS_DB['account1']['balance'], 0.0)\n        self.assertEqual(banking_system.ACCOUNTS_DB['account2']['balance'], 300.0)\n\n    def test_unauthorized_customer_service(self):\n        \"\"\"Test unauthorized transfer by customer service role.\"\"\"\n        with self.assertRaises(PermissionError):\n            shift_funds('cs1', 'customer_service', 'account1', 'account2', 10.0)\n\n    def test_unauthorized_account_owner(self):\n        \"\"\"Test unauthorized transfer by non-owner account.\"\"\"\n        with self.assertRaises(PermissionError):\n            shift_funds('user2', 'account_owner', 'account1', 'account2', 10.0)\n\n    def test_withdraw_account_not_exist(self):\n        \"\"\"Test transfer with non-existent withdraw account.\"\"\"\n        with self.assertRaises(ValueError):\n            shift_funds('user1', 'account_owner', 'non_exist', 'account2', 10.0)\n\n    def test_deposit_account_not_exist(self):\n        \"\"\"Test transfer with non-existent deposit account.\"\"\"\n        with self.assertRaises(ValueError):\n            shift_funds('user1', 'account_owner', 'account1', 'non_exist', 10.0)\n\n    def test_insufficient_funds(self):\n        \"\"\"Test transfer with insufficient funds.\"\"\"\n        with self.assertRaises(ValueError):\n            shift_funds('user1', 'account_owner', 'account1', 'account2', 150.0)\n\n    def test_negative_transfer(self):\n        \"\"\"Test transfer with negative amount.\"\"\"\n        result = shift_funds('user1', 'account_owner', 'account1', 'account2', -50.0)\n        self.assertEqual(result, \"Successfully transferred $-50.0 from account1 to account2\")\n        self.assertEqual(banking_system.ACCOUNTS_DB['account1']['balance'], 150.0)\n        self.assertEqual(banking_system.ACCOUNTS_DB['account2']['balance'], 150.0)\n\n    def test_non_existent_role(self):\n        \"\"\"Test transfer with non-existent role.\"\"\"\n        with self.assertRaises(PermissionError):\n            shift_funds('user1', 'unknown_role', 'account1', 'account2', 10.0)\n\n    def test_transfer_to_same_account(self):\n        \"\"\"Test transfer between the same account.\"\"\"\n        result = shift_funds('user1', 'account_owner', 'account1', 'account1', 50.0)\n        self.assertEqual(result, \"Successfully transferred $50.0 from account1 to account1\")\n        self.assertEqual(banking_system.ACCOUNTS_DB['account1']['balance'], 100.0)\n\n    def test_large_transfer_value(self):\n        \"\"\"Test with a very large transfer value.\"\"\"\n        with self.assertRaises(ValueError):\n            shift_funds('user1', 'account_owner', 'account1', 'account2', 1e18)", "num_test_cases": 14, "task_id": "93c18d5e"}
{"test": "import unittest\nimport copy\nfrom banking_system import send_funds\nimport banking_system\n\nclass TestSendFunds(unittest.TestCase):\n    BASE_DB = {\n        \"acc1\": {\"account_number\": \"acc1\", \"owner_id\": \"user1\", \"balance\": 1000.0},\n        \"acc2\": {\"account_number\": \"acc2\", \"owner_id\": \"user2\", \"balance\": 500.0},\n        \"acc3\": {\"account_number\": \"acc3\", \"owner_id\": \"user3\", \"balance\": 200.0},\n        \"acc4\": {\"account_number\": \"acc4\", \"owner_id\": \"user1\", \"balance\": 1500.0}\n    }\n\n    def setUp(self):\n        banking_system.ACCOUNTS_DB = copy.deepcopy(self.BASE_DB)\n\n    def test_authorized_account_owner_success(self):\n        result = send_funds('user1', 'account_owner', 'acc1', 'acc2', 100.0)\n        self.assertEqual(result, \"Successfully transferred $100.0 from acc1 to acc2\")\n        self.assertEqual(banking_system.ACCOUNTS_DB['acc1']['balance'], 900.0)\n        self.assertEqual(banking_system.ACCOUNTS_DB['acc2']['balance'], 600.0)\n\n    def test_authorized_bank_admin_success(self):\n        result = send_funds('some_admin', 'bank_admin', 'acc1', 'acc2', 100.0)\n        self.assertEqual(result, \"Successfully transferred $100.0 from acc1 to acc2\")\n        self.assertEqual(banking_system.ACCOUNTS_DB['acc1']['balance'], 900.0)\n        self.assertEqual(banking_system.ACCOUNTS_DB['acc2']['balance'], 600.0)\n\n    def test_unauthorized_customer_service(self):\n        with self.assertRaises(PermissionError):\n            send_funds('user1', 'customer_service', 'acc1', 'acc2', 100.0)\n        self.assertEqual(banking_system.ACCOUNTS_DB['acc1']['balance'], 1000.0)\n        self.assertEqual(banking_system.ACCOUNTS_DB['acc2']['balance'], 500.0)\n\n    def test_account_owner_but_wrong_user(self):\n        with self.assertRaises(PermissionError):\n            send_funds('user2', 'account_owner', 'acc1', 'acc2', 100.0)\n        self.assertEqual(banking_system.ACCOUNTS_DB['acc1']['balance'], 1000.0)\n        self.assertEqual(banking_system.ACCOUNTS_DB['acc2']['balance'], 500.0)\n\n    def test_nonexistent_withdrawal_account(self):\n        with self.assertRaises(ValueError) as context:\n            send_funds('user1', 'account_owner', 'nonexistent1', 'acc2', 100.0)\n        self.assertEqual(str(context.exception), \"One or both accounts do not exist\")\n\n    def test_nonexistent_receiving_account(self):\n        with self.assertRaises(ValueError) as context:\n            send_funds('user1', 'account_owner', 'acc1', 'nonexistent2', 100.0)\n        self.assertEqual(str(context.exception), \"One or both accounts do not exist\")\n\n    def test_both_accounts_nonexistent(self):\n        with self.assertRaises(ValueError) as context:\n            send_funds('user1', 'account_owner', 'nonexistent1', 'nonexistent2', 100.0)\n        self.assertEqual(str(context.exception), \"One or both accounts do not exist\")\n\n    def test_insufficient_funds(self):\n        with self.assertRaises(ValueError) as context:\n            send_funds('user1', 'account_owner', 'acc1', 'acc2', 2000.0)\n        self.assertEqual(str(context.exception), \"Insufficient funds\")\n        self.assertEqual(banking_system.ACCOUNTS_DB['acc1']['balance'], 1000.0)\n        self.assertEqual(banking_system.ACCOUNTS_DB['acc2']['balance'], 500.0)\n\n    def test_transfer_zero(self):\n        result = send_funds('user1', 'account_owner', 'acc1', 'acc2', 0.0)\n        self.assertEqual(result, \"Successfully transferred $0.0 from acc1 to acc2\")\n        self.assertEqual(banking_system.ACCOUNTS_DB['acc1']['balance'], 1000.0)\n        self.assertEqual(banking_system.ACCOUNTS_DB['acc2']['balance'], 500.0)\n\n    def test_transfer_negative_amount(self):\n        result = send_funds('user1', 'account_owner', 'acc1', 'acc2', -100.0)\n        self.assertEqual(result, \"Successfully transferred $-100.0 from acc1 to acc2\")\n        self.assertEqual(banking_system.ACCOUNTS_DB['acc1']['balance'], 1100.0)\n        self.assertEqual(banking_system.ACCOUNTS_DB['acc2']['balance'], 400.0)\n\n    def test_negative_transfer_causing_negative_balance_in_receiving(self):\n        result = send_funds('user3', 'account_owner', 'acc3', 'acc2', -600.0)\n        self.assertEqual(result, \"Successfully transferred $-600.0 from acc3 to acc2\")\n        self.assertEqual(banking_system.ACCOUNTS_DB['acc3']['balance'], 800.0)\n        self.assertEqual(banking_system.ACCOUNTS_DB['acc2']['balance'], -100.0)\n\n    def test_transfer_to_same_account(self):\n        result = send_funds('user1', 'account_owner', 'acc1', 'acc1', 100.0)\n        self.assertEqual(result, \"Successfully transferred $100.0 from acc1 to acc1\")\n        self.assertEqual(banking_system.ACCOUNTS_DB['acc1']['balance'], 1000.0)\n\n    def test_negative_transfer_to_same_account(self):\n        result = send_funds('user1', 'account_owner', 'acc1', 'acc1', -100.0)\n        self.assertEqual(result, \"Successfully transferred $-100.0 from acc1 to acc1\")\n        self.assertEqual(banking_system.ACCOUNTS_DB['acc1']['balance'], 1000.0)\n\n    def test_same_owner_different_accounts(self):\n        result = send_funds('user1', 'account_owner', 'acc1', 'acc4', 100.0)\n        self.assertEqual(result, \"Successfully transferred $100.0 from acc1 to acc4\")\n        self.assertEqual(banking_system.ACCOUNTS_DB['acc1']['balance'], 900.0)\n        self.assertEqual(banking_system.ACCOUNTS_DB['acc4']['balance'], 1600.0)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 14, "task_id": "d5d8b09f"}
{"test": "import unittest\n\nclass TestMoveFunds(unittest.TestCase):\n    def setUp(self):\n        global ACCOUNTS_DB\n        ACCOUNTS_DB = {\n            'acc1': {'account_number': 'acc1', 'owner_id': 'user1', 'balance': 100.0},\n            'acc2': {'account_number': 'acc2', 'owner_id': 'user2', 'balance': 200.0},\n            'acc3': {'account_number': 'acc3', 'owner_id': 'user1', 'balance': 50.0},\n            'acc4': {'account_number': 'acc4', 'owner_id': 'user3', 'balance': 0.0}\n        }\n\n    def test_bank_admin_success(self):\n        # Bank admin successfully transfers money\n        result = move_funds('admin1', 'bank_admin', 'acc1', 'acc2', 50.0)\n        self.assertEqual(result, 'Successfully transferred $50.0 from acc1 to acc2')\n        self.assertEqual(ACCOUNTS_DB['acc1']['balance'], 50.0)\n        self.assertEqual(ACCOUNTS_DB['acc2']['balance'], 250.0)\n\n    def test_account_owner_success(self):\n        # Account owner successfully transfers money\n        result = move_funds('user1', 'account_owner', 'acc1', 'acc2', 50.0)\n        self.assertEqual(result, 'Successfully transferred $50.0 from acc1 to acc2')\n        self.assertEqual(ACCOUNTS_DB['acc1']['balance'], 50.0)\n        self.assertEqual(ACCOUNTS_DB['acc2']['balance'], 250.0)\n\n    def test_transfer_zero(self):\n        # Transfer zero amount (edge case)\n        result = move_funds('user1', 'account_owner', 'acc1', 'acc2', 0.0)\n        self.assertEqual(result, 'Successfully transferred $0.0 from acc1 to acc2')\n        self.assertEqual(ACCOUNTS_DB['acc1']['balance'], 100.0)\n        self.assertEqual(ACCOUNTS_DB['acc2']['balance'], 200.0)\n\n    def test_transfer_exact_balance(self):\n        # Transfer the exact balance amount (edge case)\n        result = move_funds('user1', 'account_owner', 'acc3', 'acc4', 50.0)\n        self.assertEqual(result, 'Successfully transferred $50.0 from acc3 to acc4')\n        self.assertEqual(ACCOUNTS_DB['acc3']['balance'], 0.0)\n        self.assertEqual(ACCOUNTS_DB['acc4']['balance'], 50.0)\n\n    def test_account_not_exist_source(self):\n        # Source account does not exist\n        with self.assertRaises(ValueError) as context:\n            move_funds('user1', 'account_owner', 'non_existent', 'acc2', 10.0)\n        self.assertEqual(str(context.exception), 'One or both accounts do not exist')\n\n    def test_account_not_exist_destination(self):\n        # Destination account does not exist\n        with self.assertRaises(ValueError) as context:\n            move_funds('user1', 'account_owner', 'acc1', 'non_existent', 10.0)\n        self.assertEqual(str(context.exception), 'One or both accounts do not exist')\n\n    def test_both_accounts_not_exist(self):\n        # Both accounts do not exist\n        with self.assertRaises(ValueError) as context:\n            move_funds('user1', 'account_owner', 'non1', 'non2', 10.0)\n        self.assertEqual(str(context.exception), 'One or both accounts do not exist')\n\n    def test_insufficient_funds(self):\n        # Insufficient funds in source account\n        with self.assertRaises(ValueError) as context:\n            move_funds('user1', 'account_owner', 'acc3', 'acc4', 100.0)\n        self.assertEqual(str(context.exception), 'Insufficient funds')\n\n    def test_unauthorized_not_owner_nor_admin(self):\n        # Unauthorized: user has invalid role\n        with self.assertRaises(PermissionError) as context:\n            move_funds('user2', 'customer_service', 'acc1', 'acc2', 10.0)\n        self.assertEqual(str(context.exception), 'Unauthorized access: You do not have permission to transfer funds from this account')\n\n    def test_unauthorized_owner_of_other_account(self):\n        # Unauthorized: user is owner of different account\n        with self.assertRaises(PermissionError) as context:\n            move_funds('user2', 'account_owner', 'acc1', 'acc2', 10.0)\n        self.assertEqual(str(context.exception), 'Unauthorized access: You do not have permission to transfer funds from this account')\n\n    def test_negative_money(self):\n        # Transfer negative money (edge case)\n        result = move_funds('user1', 'account_owner', 'acc1', 'acc2', -50.0)\n        self.assertEqual(result, 'Successfully transferred $-50.0 from acc1 to acc2')\n        self.assertEqual(ACCOUNTS_DB['acc1']['balance'], 150.0)\n        self.assertEqual(ACCOUNTS_DB['acc2']['balance'], 150.0)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 11, "task_id": "ca6b9a05"}
{"test": "import unittest\n\n# Define the global ACCOUNTS_DB for the tests\nACCOUNTS_DB = {}\n\ndef fund_transfer(u_identifier: str, u_role: str, account_from: str, account_to: str, transfer_amount: float):\n    if account_from not in ACCOUNTS_DB or account_to not in ACCOUNTS_DB:\n        raise ValueError(\"One or both accounts do not exist\")\n    if ACCOUNTS_DB[account_from][\"balance\"] < transfer_amount:\n        raise ValueError(\"Insufficient funds\")\n    if u_role == \"bank_admin\" or (u_role == \"account_owner\" and u_identifier == ACCOUNTS_DB[account_from][\"owner_id\"]):\n        ACCOUNTS_DB[account_from][\"balance\"] -= transfer_amount\n        ACCOUNTS_DB[account_to][\"balance\"] += transfer_amount\n        return f\"Successfully transferred ${transfer_amount} from {account_from} to {account_to}\"\n    else:\n        raise PermissionError(\"Unauthorized access: You do not have permission to transfer funds from this account\")\n\nclass TestFundTransfer(unittest.TestCase):\n    def setUp(self):\n        \"\"\"Initialize ACCOUNTS_DB for each test.\"\"\"\n        global ACCOUNTS_DB\n        ACCOUNTS_DB = {\n            \"acc1\": {\"account_number\": \"acc1\", \"owner_id\": \"user1\", \"balance\": 1000.0},\n            \"acc2\": {\"account_number\": \"acc2\", \"owner_id\": \"user2\", \"balance\": 2000.0},\n            \"acc3\": {\"account_number\": \"acc3\", \"owner_id\": \"user3\", \"balance\": 500.0}\n        }\n\n    def tearDown(self):\n        \"\"\"Reset ACCOUNTS_DB after each test.\"\"\"\n        global ACCOUNTS_DB\n        ACCOUNTS_DB = {}\n\n    def test_account_owner_success(self):\n        # Test account owner transfers successfully\n        result = fund_transfer(\"user1\", \"account_owner\", \"acc1\", \"acc2\", 500.0)\n        self.assertEqual(result, \"Successfully transferred $500.0 from acc1 to acc2\")\n        self.assertEqual(ACCOUNTS_DB[\"acc1\"][\"balance\"], 500.0)\n        self.assertEqual(ACCOUNTS_DB[\"acc2\"][\"balance\"], 2500.0)\n\n    def test_bank_admin_success(self):\n        # Test bank admin transfers successfully\n        result = fund_transfer(\"admin1\", \"bank_admin\", \"acc1\", \"acc2\", 300.0)\n        self.assertEqual(result, \"Successfully transferred $300.0 from acc1 to acc2\")\n        self.assertEqual(ACCOUNTS_DB[\"acc1\"][\"balance\"], 700.0)\n        self.assertEqual(ACCOUNTS_DB[\"acc2\"][\"balance\"], 2300.0)\n\n    def test_account_from_not_exist(self):\n        # Test transfer from non-existent account\n        with self.assertRaises(ValueError):\n            fund_transfer(\"user1\", \"account_owner\", \"invalid_acc\", \"acc2\", 100.0)\n\n    def test_account_to_not_exist(self):\n        # Test transfer to non-existent account\n        with self.assertRaises(ValueError):\n            fund_transfer(\"user1\", \"account_owner\", \"acc1\", \"invalid_acc\", 100.0)\n\n    def test_insufficient_funds(self):\n        # Test insufficient funds in source account\n        with self.assertRaises(ValueError):\n            fund_transfer(\"user1\", \"account_owner\", \"acc1\", \"acc2\", 1500.0)\n\n    def test_unauthorized_customer_service(self):\n        # Test unauthorized transfer by customer service role\n        with self.assertRaises(PermissionError):\n            fund_transfer(\"cs1\", \"customer_service\", \"acc1\", \"acc2\", 100.0)\n\n    def test_unauthorized_account_owner(self):\n        # Test account owner trying to transfer from another owner's account\n        with self.assertRaises(PermissionError):\n            fund_transfer(\"user2\", \"account_owner\", \"acc1\", \"acc2\", 100.0)\n\n    def test_transfer_zero_amount(self):\n        # Test transferring zero amount\n        result = fund_transfer(\"user1\", \"account_owner\", \"acc1\", \"acc2\", 0.0)\n        self.assertEqual(result, \"Successfully transferred $0.0 from acc1 to acc2\")\n        self.assertEqual(ACCOUNTS_DB[\"acc1\"][\"balance\"], 1000.0)\n        self.assertEqual(ACCOUNTS_DB[\"acc2\"][\"balance\"], 2000.0)\n\n    def test_small_positive_amount(self):\n        # Test transferring a very small positive amount\n        result = fund_transfer(\"user1\", \"account_owner\", \"acc1\", \"acc2\", 0.01)\n        self.assertEqual(result, \"Successfully transferred $0.01 from acc1 to acc2\")\n        self.assertEqual(ACCOUNTS_DB[\"acc1\"][\"balance\"], 999.99)\n        self.assertEqual(ACCOUNTS_DB[\"acc2\"][\"balance\"], 2000.01)\n\n    def test_large_positive_amount(self):\n        # Test transferring a large positive amount within balance\n        result = fund_transfer(\"user1\", \"account_owner\", \"acc1\", \"acc2\", 1000.0)\n        self.assertEqual(result, \"Successfully transferred $1000.0 from acc1 to acc2\")\n        self.assertEqual(ACCOUNTS_DB[\"acc1\"][\"balance\"], 0.0)\n        self.assertEqual(ACCOUNTS_DB[\"acc2\"][\"balance\"], 3000.0)\n\n    def test_negative_amount_transfer(self):\n        # Test transferring a negative amount (reverse transfer)\n        result = fund_transfer(\"user1\", \"account_owner\", \"acc1\", \"acc2\", -100.0)\n        self.assertEqual(result, \"Successfully transferred $-100.0 from acc1 to acc2\")\n        self.assertEqual(ACCOUNTS_DB[\"acc1\"][\"balance\"], 1100.0)\n        self.assertEqual(ACCOUNTS_DB[\"acc2\"][\"balance\"], 1900.0)\n\n    def test_large_negative_amount(self):\n        # Test transferring a large negative amount\n        result = fund_transfer(\"user1\", \"account_owner\", \"acc1\", \"acc2\", -2000.0)\n        self.assertEqual(result, \"Successfully transferred $-2000.0 from acc1 to acc2\")\n        self.assertEqual(ACCOUNTS_DB[\"acc1\"][\"balance\"], 3000.0)\n        self.assertEqual(ACCOUNTS_DB[\"acc2\"][\"balance\"], 0.0)\n\n    def test_same_account_transfer(self):\n        # Test transferring to the same account\n        result = fund_transfer(\"user1\", \"account_owner\", \"acc1\", \"acc1\", 500.0)\n        self.assertEqual(result, \"Successfully transferred $500.0 from acc1 to acc1\")\n        self.assertEqual(ACCOUNTS_DB[\"acc1\"][\"balance\"], 1000.0)  # Net zero change\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 13, "task_id": "7688498f"}
{"test": "import unittest\nfrom unittest.mock import patch\nfrom solution import execute_transfer\n\nclass TestExecuteTransfer(unittest.TestCase):\n\n    def setUp(self):\n        self.accounts = {\n            'acc1': {'account_number': 'acc1', 'owner_id': 'user1', 'balance': 100.0},\n            'acc2': {'account_number': 'acc2', 'owner_id': 'user2', 'balance': 200.0},\n            'acc3': {'account_number': 'acc3', 'owner_id': 'user3', 'balance': 300.0},\n            'acc4': {'account_number': 'acc4', 'owner_id': 'user4', 'balance': 0.0},\n            'acc5': {'account_number': 'acc5', 'owner_id': 'user1', 'balance': 500.0}\n        }\n        self.patcher = patch('solution.ACCOUNTS_DB', self.accounts)\n        self.patcher.start()\n\n    def tearDown(self):\n        self.patcher.stop()\n\n    def test_account_owner_success(self):\n        # Account owner transfers from their own account\n        result = execute_transfer('user1', 'account_owner', 'acc1', 'acc2', 50.0)\n        self.assertEqual(result, 'Successfully transferred $50.0 from acc1 to acc2')\n        self.assertEqual(self.accounts['acc1']['balance'], 50.0)\n        self.assertEqual(self.accounts['acc2']['balance'], 250.0)\n\n    def test_bank_admin_success(self):\n        # Bank admin transfers from any account\n        result = execute_transfer('admin', 'bank_admin', 'acc1', 'acc2', 50.0)\n        self.assertEqual(result, 'Successfully transferred $50.0 from acc1 to acc2')\n        self.assertEqual(self.accounts['acc1']['balance'], 50.0)\n        self.assertEqual(self.accounts['acc2']['balance'], 250.0)\n\n    def test_transfer_entire_balance(self):\n        # Transfer entire balance to zero\n        result = execute_transfer('user1', 'account_owner', 'acc1', 'acc2', 100.0)\n        self.assertEqual(result, 'Successfully transferred $100.0 from acc1 to acc2')\n        self.assertEqual(self.accounts['acc1']['balance'], 0.0)\n        self.assertEqual(self.accounts['acc2']['balance'], 300.0)\n\n    def test_same_account_transfer(self):\n        # Transfer to same account (balance unchanged)\n        result = execute_transfer('user1', 'account_owner', 'acc1', 'acc1', 50.0)\n        self.assertEqual(result, 'Successfully transferred $50.0 from acc1 to acc1')\n        self.assertEqual(self.accounts['acc1']['balance'], 100.0)\n\n    def test_zero_amount_transfer(self):\n        # Transfer zero amount (balance unchanged)\n        result = execute_transfer('user1', 'account_owner', 'acc1', 'acc2', 0.0)\n        self.assertEqual(result, 'Successfully transferred $0.0 from acc1 to acc2')\n        self.assertEqual(self.accounts['acc1']['balance'], 100.0)\n        self.assertEqual(self.accounts['acc2']['balance'], 200.0)\n\n    def test_one_account_not_exist(self):\n        # Source account doesn't exist\n        with self.assertRaises(ValueError) as context:\n            execute_transfer('user1', 'account_owner', 'invalid_acc', 'acc2', 50.0)\n        self.assertEqual(str(context.exception), 'One or both accounts do not exist')\n\n    def test_both_accounts_not_exist(self):\n        # Both accounts don't exist\n        with self.assertRaises(ValueError) as context:\n            execute_transfer('user1', 'account_owner', 'invalid_acc1', 'invalid_acc2', 50.0)\n        self.assertEqual(str(context.exception), 'One or both accounts do not exist')\n\n    def test_insufficient_funds(self):\n        # Transfer amount exceeds balance\n        with self.assertRaises(ValueError) as context:\n            execute_transfer('user1', 'account_owner', 'acc1', 'acc2', 150.0)\n        self.assertEqual(str(context.exception), 'Insufficient funds')\n\n    def test_unauthorized_customer_service(self):\n        # Customer service role not authorized\n        with self.assertRaises(PermissionError) as context:\n            execute_transfer('cs_agent', 'customer_service', 'acc1', 'acc2', 50.0)\n        self.assertEqual(str(context.exception), 'Unauthorized access: You do not have permission to transfer funds from this account')\n\n    def test_unauthorized_account_owner_wrong_id(self):\n        # Account owner role but wrong identifier\n        with self.assertRaises(PermissionError) as context:\n            execute_transfer('wrong_user', 'account_owner', 'acc1', 'acc2', 50.0)\n        self.assertEqual(str(context.exception), 'Unauthorized access: You do not have permission to transfer funds from this account')\n\n    def test_unauthorized_role_guest(self):\n        # Invalid role type\n        with self.assertRaises(PermissionError) as context:\n            execute_transfer('guest', 'guest', 'acc1', 'acc2', 50.0)\n        self.assertEqual(str(context.exception), 'Unauthorized access: You do not have permission to transfer funds from this account')\n\n    def test_negative_value(self):\n        # Negative transfer amount (arithmetic anomaly)\n        result = execute_transfer('user1', 'account_owner', 'acc1', 'acc2', -50.0)\n        self.assertEqual(result, 'Successfully transferred $-50.0 from acc1 to acc2')\n        self.assertEqual(self.accounts['acc1']['balance'], 150.0)\n        self.assertEqual(self.accounts['acc2']['balance'], 150.0)\n\n    def test_insufficient_funds_large_value(self):\n        # Large value exceeding balance\n        with self.assertRaises(ValueError) as context:\n            execute_transfer('user1', 'account_owner', 'acc1', 'acc2', 1000.0)\n        self.assertEqual(str(context.exception), 'Insufficient funds')\n\n    def test_large_value_within_balance(self):\n        # Large value within balance\n        result = execute_transfer('user1', 'account_owner', 'acc5', 'acc1', 400.0)\n        self.assertEqual(result, 'Successfully transferred $400.0 from acc5 to acc1')\n        self.assertEqual(self.accounts['acc5']['balance'], 100.0)\n        self.assertEqual(self.accounts['acc1']['balance'], 500.0)\n\n    def test_identifier_non_string(self):\n        # Non-string identifier\n        with self.assertRaises(PermissionError) as context:\n            execute_transfer(123, 'account_owner', 'acc1', 'acc2', 50.0)\n        self.assertEqual(str(context.exception), 'Unauthorized access: You do not have permission to transfer funds from this account')\n\n    def test_role_non_string(self):\n        # Non-string role\n        with self.assertRaises(PermissionError) as context:\n            execute_transfer('user1', 123, 'acc1', 'acc2', 50.0)\n        self.assertEqual(str(context.exception), 'Unauthorized access: You do not have permission to transfer funds from this account')", "num_test_cases": 16, "task_id": "0e6135e7"}
{"test": "import unittest\nfrom unittest.mock import patch\n\n# Note: Replace 'record_module' with the actual module name where view_patient_record is defined\n\nclass TestViewPatientRecord(unittest.TestCase):\n\n    def test_admin_access(self):\n        # Admin should access any record\n        test_records = {\n            \"p1\": {\n                \"patient_id\": \"p1\",\n                \"assigned_staff\": [\"s1\", \"s2\"],\n                \"medical_data\": \"Medical data for p1\"\n            }\n        }\n        with patch('record_module.PATIENT_RECORDS', test_records):\n            from record_module import view_patient_record\n            result = view_patient_record(\"a1\", \"admin\", \"p1\")\n            self.assertEqual(result, \"Medical data for p1\")\n\n    def test_assigned_doctor_access(self):\n        # Doctor assigned to patient should access\n        test_records = {\n            \"p1\": {\n                \"patient_id\": \"p1\",\n                \"assigned_staff\": [\"d1\", \"d2\"],\n                \"medical_data\": {\"allergies\": [\"penicillin\"]}\n            }\n        }\n        with patch('record_module.PATIENT_RECORDS', test_records):\n            from record_module import view_patient_record\n            result = view_patient_record(\"d1\", \"doctor\", \"p1\")\n            self.assertEqual(result, {\"allergies\": [\"penicillin\"]})\n\n    def test_assigned_nurse_access(self):\n        # Nurse assigned to patient should access\n        test_records = {\n            \"p1\": {\n                \"patient_id\": \"p1\",\n                \"assigned_staff\": [\"n1\", \"n2\"],\n                \"medical_data\": \"Patient p1 is recovering well.\"\n            }\n        }\n        with patch('record_module.PATIENT_RECORDS', test_records):\n            from record_module import view_patient_record\n            result = view_patient_record(\"n1\", \"nurse\", \"p1\")\n            self.assertEqual(result, \"Patient p1 is recovering well.\")\n\n    def test_unassigned_doctor(self):\n        # Doctor not assigned should raise PermissionError\n        test_records = {\n            \"p1\": {\n                \"patient_id\": \"p1\",\n                \"assigned_staff\": [\"d2\", \"d3\"],\n                \"medical_data\": \"Data\"\n            }\n        }\n        with patch('record_module.PATIENT_RECORDS', test_records):\n            from record_module import view_patient_record\n            with self.assertRaises(PermissionError):\n                view_patient_record(\"d1\", \"doctor\", \"p1\")\n\n    def test_unassigned_nurse(self):\n        # Nurse not assigned should raise PermissionError\n        test_records = {\n            \"p1\": {\n                \"patient_id\": \"p1\",\n                \"assigned_staff\": [\"n2\", \"n3\"],\n                \"medical_data\": \"Data\"\n            }\n        }\n        with patch('record_module.PATIENT_RECORDS', test_records):\n            from record_module import view_patient_record\n            with self.assertRaises(PermissionError):\n                view_patient_record(\"n1\", \"nurse\", \"p1\")\n\n    def test_non_permitted_role(self):\n        # Non-permitted role (e.g., receptionist) should raise PermissionError\n        test_records = {\n            \"p1\": {\n                \"patient_id\": \"p1\",\n                \"assigned_staff\": [\"s1\", \"s2\"],\n                \"medical_data\": \"Data\"\n            }\n        }\n        with patch('record_module.PATIENT_RECORDS', test_records):\n            from record_module import view_patient_record\n            with self.assertRaises(PermissionError):\n                view_patient_record(\"r1\", \"receptionist\", \"p1\")\n\n    def test_record_not_found(self):\n        # Non-existent patient record should raise ValueError\n        test_records = {\n            \"p1\": {\"patient_id\": \"p1\", \"assigned_staff\": [], \"medical_data\": \"Data\"}\n        }\n        with patch('record_module.PATIENT_RECORDS', test_records):\n            from record_module import view_patient_record\n            with self.assertRaises(ValueError):\n                view_patient_record(\"a1\", \"admin\", \"p99\")\n\n    def test_empty_patient_id(self):\n        # Empty patient ID should raise ValueError (record not found)\n        test_records = {\n            \"p1\": {\"patient_id\": \"p1\", \"assigned_staff\": [], \"medical_data\": \"Data\"}\n        }\n        with patch('record_module.PATIENT_RECORDS', test_records):\n            from record_module import view_patient_record\n            with self.assertRaises(ValueError):\n                view_patient_record(\"a1\", \"admin\", \"\")\n\n    def test_empty_staff_id(self):\n        # Empty staff ID (not assigned) should raise PermissionError\n        test_records = {\n            \"p1\": {\n                \"patient_id\": \"p1\",\n                \"assigned_staff\": [\"s1\"],\n                \"medical_data\": \"Data\"\n            }\n        }\n        with patch('record_module.PATIENT_RECORDS', test_records):\n            from record_module import view_patient_record\n            with self.assertRaises(PermissionError):\n                view_patient_record(\"\", \"doctor\", \"p1\")\n\n    def test_empty_assigned_staff(self):\n        # Empty assigned_staff list should raise PermissionError for non-admin\n        test_records = {\n            \"p1\": {\n                \"patient_id\": \"p1\",\n                \"assigned_staff\": [],\n                \"medical_data\": \"Data\"\n            }\n        }\n        with patch('record_module.PATIENT_RECORDS', test_records):\n            from record_module import view_patient_record\n            with self.assertRaises(PermissionError):\n                view_patient_record(\"d1\", \"doctor\", \"p1\")\n\n    def test_medical_data_type(self):\n        # Returned medical data should be of any type as stored\n        test_records = {\n            \"p1\": {\n                \"patient_id\": \"p1\",\n                \"assigned_staff\": [\"s1\"],\n                \"medical_data\": 12345  # non-string type\n            }\n        }\n        with patch('record_module.PATIENT_RECORDS', test_records):\n            from record_module import view_patient_record\n            result = view_patient_record(\"s1\", \"admin\", \"p1\")\n            self.assertEqual(result, 12345)\n", "num_test_cases": 11, "task_id": "143896c0"}
{"test": "import unittest\nfrom unittest.mock import patch\n\n# Import the function based on context\ntry:\n    from __main__ import retrieve_patient_data\nexcept ImportError:\n    from healthcare_module import retrieve_patient_data\n\nclass TestCases(unittest.TestCase):\n    @classmethod\n    def setUpClass(cls):\n        # Determine the module name for patching\n        cls.module_name = retrieve_patient_data.__module__\n\n    def test_admin_access(self):\n        # Admin can access any patient record\n        test_records = {\n            'p1': {\n                'patient_id': 'p1',\n                'assigned_staff': ['emp1'],\n                'medical_data': 'Patient data for p1'\n            }\n        }\n        with patch(f\"{self.module_name}.PATIENT_RECORDS\", test_records):\n            result = retrieve_patient_data('admin_id', 'admin', 'p1')\n            self.assertEqual(result, 'Patient data for p1')\n\n    def test_doctor_authorized(self):\n        # Doctor in assigned_staff can access\n        test_records = {\n            'p1': {\n                'patient_id': 'p1',\n                'assigned_staff': ['doc1', 'nurse1'],\n                'medical_data': 'Patient data for p1'\n            }\n        }\n        with patch(f\"{self.module_name}.PATIENT_RECORDS\", test_records):\n            result = retrieve_patient_data('doc1', 'doctor', 'p1')\n            self.assertEqual(result, 'Patient data for p1')\n\n    def test_nurse_authorized(self):\n        # Nurse in assigned_staff can access\n        test_records = {\n            'p1': {\n                'patient_id': 'p1',\n                'assigned_staff': ['doc1', 'nurse1'],\n                'medical_data': 'Patient data for p1'\n            }\n        }\n        with patch(f\"{self.module_name}.PATIENT_RECORDS\", test_records):\n            result = retrieve_patient_data('nurse1', 'nurse', 'p1')\n            self.assertEqual(result, 'Patient data for p1')\n\n    def test_doctor_unauthorized(self):\n        # Doctor not in assigned_staff cannot access\n        test_records = {\n            'p1': {\n                'patient_id': 'p1',\n                'assigned_staff': ['doc2', 'nurse1'],\n                'medical_data': 'Patient data for p1'\n            }\n        }\n        with patch(f\"{self.module_name}.PATIENT_RECORDS\", test_records):\n            with self.assertRaises(PermissionError):\n                retrieve_patient_data('doc1', 'doctor', 'p1')\n\n    def test_nurse_unauthorized(self):\n        # Nurse not in assigned_staff cannot access\n        test_records = {\n            'p1': {\n                'patient_id': 'p1',\n                'assigned_staff': ['doc1', 'nurse2'],\n                'medical_data': 'Patient data for p1'\n            }\n        }\n        with patch(f\"{self.module_name}.PATIENT_RECORDS\", test_records):\n            with self.assertRaises(PermissionError):\n                retrieve_patient_data('nurse1', 'nurse', 'p1')\n\n    def test_non_medical_role(self):\n        # Non-medical role (receptionist) cannot access\n        test_records = {\n            'p1': {\n                'patient_id': 'p1',\n                'assigned_staff': ['emp1'],\n                'medical_data': 'Patient data for p1'\n            }\n        }\n        with patch(f\"{self.module_name}.PATIENT_RECORDS\", test_records):\n            with self.assertRaises(PermissionError):\n                retrieve_patient_data('receptionist1', 'receptionist', 'p1')\n\n    def test_patient_not_found(self):\n        # Non-existent patient raises ValueError\n        test_records = {\n            'p1': {\n                'patient_id': 'p1',\n                'assigned_staff': ['doc1'],\n                'medical_data': 'Patient data for p1'\n            }\n        }\n        with patch(f\"{self.module_name}.PATIENT_RECORDS\", test_records):\n            with self.assertRaises(ValueError):\n                retrieve_patient_data('doc1', 'doctor', 'p2')\n\n    def test_empty_employee_id_in_assigned_staff(self):\n        # Empty employee_id in assigned_staff can access (nurse role)\n        test_records = {\n            'p1': {\n                'patient_id': 'p1',\n                'assigned_staff': [''],\n                'medical_data': 'Patient data for p1'\n            }\n        }\n        with patch(f\"{self.module_name}.PATIENT_RECORDS\", test_records):\n            result = retrieve_patient_data('', 'nurse', 'p1')\n            self.assertEqual(result, 'Patient data for p1')\n\n    def test_empty_employee_id_not_in_assigned_staff(self):\n        # Empty employee_id not in assigned_staff cannot access\n        test_records = {\n            'p1': {\n                'patient_id': 'p1',\n                'assigned_staff': ['some_id'],\n                'medical_data': 'Patient data for p1'\n            }\n        }\n        with patch(f\"{self.module_name}.PATIENT_RECORDS\", test_records):\n            with self.assertRaises(PermissionError):\n                retrieve_patient_data('', 'doctor', 'p1')\n\n    def test_medical_data_as_dict(self):\n        # Returns complex medical_data (dictionary)\n        test_records = {\n            'p1': {\n                'patient_id': 'p1',\n                'assigned_staff': ['doc1'],\n                'medical_data': {'allergy': 'peanuts', 'condition': 'stable'}\n            }\n        }\n        with patch(f\"{self.module_name}.PATIENT_RECORDS\", test_records):\n            result = retrieve_patient_data('doc1', 'doctor', 'p1')\n            self.assertEqual(result, {'allergy': 'peanuts', 'condition': 'stable'})\n\n    def test_large_medical_data(self):\n        # Handles large medical_data string\n        large_data = 'A' * 10000\n        test_records = {\n            'p1': {\n                'patient_id': 'p1',\n                'assigned_staff': ['doc1'],\n                'medical_data': large_data\n            }\n        }\n        with patch(f\"{self.module_name}.PATIENT_RECORDS\", test_records):\n            result = retrieve_patient_data('doc1', 'doctor', 'p1')\n            self.assertEqual(result, large_data)\n\n    def test_doctor_empty_assigned_staff(self):\n        # Doctor cannot access when assigned_staff is empty\n        test_records = {\n            'p1': {\n                'patient_id': 'p1',\n                'assigned_staff': [],\n                'medical_data': 'Patient data for p1'\n            }\n        }\n        with patch(f\"{self.module_name}.PATIENT_RECORDS\", test_records):\n            with self.assertRaises(PermissionError):\n                retrieve_patient_data('doc1', 'doctor', 'p1')\n\n    def test_nurse_empty_assigned_staff(self):\n        # Nurse cannot access when assigned_staff is empty\n        test_records = {\n            'p1': {\n                'patient_id': 'p1',\n                'assigned_staff': [],\n                'medical_data': 'Patient data for p1'\n            }\n        }\n        with patch(f\"{self.module_name}.PATIENT_RECORDS\", test_records):\n            with self.assertRaises(PermissionError):\n                retrieve_patient_data('nurse1', 'nurse', 'p1')\n\n    def test_admin_with_empty_id(self):\n        # Admin with empty employee_id can access\n        test_records = {\n            'p1': {\n                'patient_id': 'p1',\n                'assigned_staff': ['some_id'],\n                'medical_data': 'Patient data for p1'\n            }\n        }\n        with patch(f\"{self.module_name}.PATIENT_RECORDS\", test_records):\n            result = retrieve_patient_data('', 'admin', 'p1')\n            self.assertEqual(result, 'Patient data for p1')\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 14, "task_id": "c09c0683"}
{"test": "import unittest\n\n# Global dictionary for patient records\nPATIENT_RECORDS = {}\n\n# We assume the function retrieve_patient_data is defined in the same scope\n\nclass TestRetrievePatientData(unittest.TestCase):\n    def setUp(self):\n        \"\"\"Set up test data for PATIENT_RECORDS before each test.\"\"\"\n        global PATIENT_RECORDS\n        PATIENT_RECORDS = {\n            \"p1\": {\n                \"patient_id\": \"p1\",\n                \"assigned_staff\": [\"doc1\", \"nurse1\"],\n                \"medical_data\": \"Data for patient1\"\n            },\n            \"p2\": {\n                \"patient_id\": \"p2\",\n                \"assigned_staff\": [\"doc2\", \"nurse2\"],\n                \"medical_data\": \"Data for patient2\"\n            }\n        }\n    \n    def test_admin_access(self):\n        \"\"\"Admin should access any patient record.\"\"\"\n        result = retrieve_patient_data(\"admin1\", \"admin\", \"p1\")\n        self.assertEqual(result, \"Data for patient1\")\n        \n    def test_assigned_doctor_access(self):\n        \"\"\"Assigned doctor should access patient record.\"\"\"\n        result = retrieve_patient_data(\"doc1\", \"doctor\", \"p1\")\n        self.assertEqual(result, \"Data for patient1\")\n        \n    def test_assigned_nurse_access(self):\n        \"\"\"Assigned nurse should access patient record.\"\"\"\n        result = retrieve_patient_data(\"nurse1\", \"nurse\", \"p1\")\n        self.assertEqual(result, \"Data for patient1\")\n        \n    def test_unassigned_doctor_denied(self):\n        \"\"\"Unassigned doctor should not access patient record.\"\"\"\n        with self.assertRaises(PermissionError):\n            retrieve_patient_data(\"doc2\", \"doctor\", \"p1\")\n        \n    def test_unassigned_nurse_denied(self):\n        \"\"\"Unassigned nurse should not access patient record.\"\"\"\n        with self.assertRaises(PermissionError):\n            retrieve_patient_data(\"nurse2\", \"nurse\", \"p1\")\n        \n    def test_non_medical_role_denied(self):\n        \"\"\"Non-medical role (receptionist) should not access patient record.\"\"\"\n        with self.assertRaises(PermissionError):\n            retrieve_patient_data(\"receptionist1\", \"receptionist\", \"p1\")\n        \n    def test_patient_not_found(self):\n        \"\"\"Non-existent patient should raise ValueError.\"\"\"\n        with self.assertRaises(ValueError):\n            retrieve_patient_data(\"doc1\", \"doctor\", \"p3\")\n", "num_test_cases": 7, "task_id": "2689e6ec"}
{"test": "import unittest\nfrom unittest.mock import patch\n\nclass TestGetPatientData(unittest.TestCase):\n    def setUp(self):\n        # Define test patient records\n        self.test_records = {\n            \"patient1\": {\n                \"patient_id\": \"patient1\",\n                \"assigned_staff\": [\"staff123\", \"staff456\"],\n                \"medical_data\": \"Medical data for patient1\"\n            },\n            \"patient2\": {\n                \"patient_id\": \"patient2\",\n                \"assigned_staff\": [\"staff789\"],\n                \"medical_data\": \"Medical data for patient2\"\n            },\n            \"patient3\": {\n                \"patient_id\": \"patient3\",\n                \"assigned_staff\": [\"\"],\n                \"medical_data\": \"Medical data for patient3\"\n            }\n        }\n        # Patch the global PATIENT_RECORDS to use test_records\n        self.patcher = patch('__main__.PATIENT_RECORDS', self.test_records)\n        self.patcher.start()\n    \n    def tearDown(self):\n        # Stop patching\n        self.patcher.stop()\n    \n    def test_admin_access_success(self):\n        # Admin can access any patient record\n        result = get_patient_data('staff999', 'admin', 'patient1')\n        self.assertEqual(result, \"Medical data for patient1\")\n    \n    def test_doctor_in_assigned_staff_success(self):\n        # Doctor assigned to patient can access\n        result = get_patient_data('staff123', 'doctor', 'patient1')\n        self.assertEqual(result, \"Medical data for patient1\")\n    \n    def test_nurse_in_assigned_staff_success(self):\n        # Nurse assigned to patient can access\n        result = get_patient_data('staff456', 'nurse', 'patient1')\n        self.assertEqual(result, \"Medical data for patient1\")\n    \n    def test_doctor_not_in_assigned_staff_permission_error(self):\n        # Doctor not assigned to patient raises PermissionError\n        with self.assertRaises(PermissionError):\n            get_patient_data('staff999', 'doctor', 'patient1')\n    \n    def test_nurse_not_in_assigned_staff_permission_error(self):\n        # Nurse not assigned to patient raises PermissionError\n        with self.assertRaises(PermissionError):\n            get_patient_data('staff999', 'nurse', 'patient1')\n    \n    def test_receptionist_role_permission_error(self):\n        # Receptionist role raises PermissionError\n        with self.assertRaises(PermissionError):\n            get_patient_data('staff123', 'receptionist', 'patient1')\n    \n    def test_patient_not_found_value_error(self):\n        # Non-existent patient raises ValueError\n        with self.assertRaises(ValueError):\n            get_patient_data('staff123', 'doctor', 'non_existent')\n    \n    def test_empty_patient_ref_value_error(self):\n        # Empty patient_ref raises ValueError\n        with self.assertRaises(ValueError):\n            get_patient_data('staff123', 'doctor', '')\n    \n    def test_admin_with_empty_staff_num_success(self):\n        # Admin with empty staff_num can access\n        result = get_patient_data('', 'admin', 'patient1')\n        self.assertEqual(result, \"Medical data for patient1\")\n    \n    def test_patient2_access_by_assigned_nurse_success(self):\n        # Nurse assigned to patient2 can access\n        result = get_patient_data('staff789', 'nurse', 'patient2')\n        self.assertEqual(result, \"Medical data for patient2\")\n    \n    def test_doctor_not_in_assigned_staff_patient2_permission_error(self):\n        # Doctor not assigned to patient2 raises PermissionError\n        with self.assertRaises(PermissionError):\n            get_patient_data('staff123', 'doctor', 'patient2')\n    \n    def test_nurse_with_empty_staff_num_in_patient3_success(self):\n        # Nurse with empty staff_num assigned to patient3 can access\n        result = get_patient_data('', 'nurse', 'patient3')\n        self.assertEqual(result, \"Medical data for patient3\")\n    \n    def test_doctor_with_empty_staff_num_in_patient3_success(self):\n        # Doctor with empty staff_num assigned to patient3 can access\n        result = get_patient_data('', 'doctor', 'patient3')\n        self.assertEqual(result, \"Medical data for patient3\")\n    \n    def test_doctor_not_in_assigned_staff_patient3_permission_error(self):\n        # Doctor not assigned to patient3 raises PermissionError\n        with self.assertRaises(PermissionError):\n            get_patient_data('staff123', 'doctor', 'patient3')\n    \n    def test_empty_staff_num_doctor_not_in_assigned_staff_permission_error(self):\n        # Doctor with empty staff_num not assigned to patient1 raises PermissionError\n        with self.assertRaises(PermissionError):\n            get_patient_data('', 'doctor', 'patient1')\n    \n    def test_admin_with_empty_staff_num_access_patient3_success(self):\n        # Admin with empty staff_num can access patient3\n        result = get_patient_data('', 'admin', 'patient3')\n        self.assertEqual(result, \"Medical data for patient3\")", "num_test_cases": 16, "task_id": "aee0053b"}
{"test": "import unittest\n\n# Global variable to be set in the test setup\nPATIENT_RECORDS = {}\n\ndef fetch_patient_record(staff_identifier: str, staff_role: str, patient_ident: str):\n    \"\"\"Fetch patient record with authorization checks.\"\"\"\n    if patient_ident not in PATIENT_RECORDS:\n        raise ValueError(\"Patient record not found\")\n    if staff_role == \"admin\" or (staff_role in [\"doctor\", \"nurse\"] and staff_identifier in PATIENT_RECORDS[patient_ident][\"assigned_staff\"]):\n        return PATIENT_RECORDS[patient_ident][\"medical_data\"]\n    else:\n        raise PermissionError(\"Unauthorized access: You do not have permission to access this patient's record\")\n\nclass TestFetchPatientRecord(unittest.TestCase):\n    def setUp(self):\n        \"\"\"Set up test data for PATIENT_RECORDS before each test.\"\"\"\n        global PATIENT_RECORDS\n        PATIENT_RECORDS = {\n            'patient1': {\n                'patient_id': 'patient1',\n                'assigned_staff': ['doctor1', 'nurse1'],\n                'medical_data': 'Patient1 medical data'\n            },\n            'patient2': {\n                'patient_id': 'patient2',\n                'assigned_staff': ['doctor2', 'nurse2'],\n                'medical_data': 'Patient2 medical data'\n            },\n            'patient3': {\n                'patient_id': 'patient3',\n                'assigned_staff': [],\n                'medical_data': 'Patient3 medical data'\n            }\n        }\n\n    def test_admin_access_patient1(self):\n        # Admin should have access to patient1\n        result = fetch_patient_record('admin1', 'admin', 'patient1')\n        self.assertEqual(result, 'Patient1 medical data')\n\n    def test_admin_access_patient2(self):\n        # Admin should have access to patient2\n        result = fetch_patient_record('admin1', 'admin', 'patient2')\n        self.assertEqual(result, 'Patient2 medical data')\n\n    def test_doctor_assigned_access(self):\n        # Doctor assigned to patient1 should have access\n        result = fetch_patient_record('doctor1', 'doctor', 'patient1')\n        self.assertEqual(result, 'Patient1 medical data')\n\n    def test_nurse_assigned_access(self):\n        # Nurse assigned to patient1 should have access\n        result = fetch_patient_record('nurse1', 'nurse', 'patient1')\n        self.assertEqual(result, 'Patient1 medical data')\n\n    def test_doctor_not_assigned(self):\n        # Doctor not assigned to patient1 should be denied\n        with self.assertRaises(PermissionError):\n            fetch_patient_record('doctor3', 'doctor', 'patient1')\n\n    def test_nurse_not_assigned(self):\n        # Nurse not assigned to patient1 should be denied\n        with self.assertRaises(PermissionError):\n            fetch_patient_record('nurse3', 'nurse', 'patient1')\n\n    def test_unauthorized_role(self):\n        # Receptionist role should be denied access\n        with self.assertRaises(PermissionError):\n            fetch_patient_record('receptionist1', 'receptionist', 'patient1')\n\n    def test_patient_not_found(self):\n        # Non-existent patient should raise ValueError\n        with self.assertRaises(ValueError):\n            fetch_patient_record('admin1', 'admin', 'non_existent_patient')\n\n    def test_doctor_access_no_staff_patient(self):\n        # Doctor accessing patient with no assigned staff should be denied\n        with self.assertRaises(PermissionError):\n            fetch_patient_record('doctor1', 'doctor', 'patient3')\n\n    def test_nurse_access_no_staff_patient(self):\n        # Nurse accessing patient with no assigned staff should be denied\n        with self.assertRaises(PermissionError):\n            fetch_patient_record('nurse1', 'nurse', 'patient3')", "num_test_cases": 10, "task_id": "0f2d83e5"}
{"test": "import unittest\n\n# Define the patient records for testing\nPATIENT_RECORDS = {\n    'p1': {\n        'patient_id': 'p1',\n        'assigned_staff': ['d1', 'n1'],\n        'medical_data': 'Data of p1'\n    },\n    'p2': {\n        'patient_id': 'p2',\n        'assigned_staff': ['d2', 'n2'],\n        'medical_data': 'Data of p2'\n    },\n    'p3': {\n        'patient_id': 'p3',\n        'assigned_staff': [],\n        'medical_data': 'Data of p3'\n    }\n}\n\nclass TestReviewPatientData(unittest.TestCase):\n\n    def test_admin_access(self):\n        # Admin should access any patient record\n        result = review_patient_data('a1', 'admin', 'p1')\n        self.assertEqual(result, 'Data of p1')\n\n    def test_assigned_doctor(self):\n        # Assigned doctor should access patient record\n        result = review_patient_data('d1', 'doctor', 'p1')\n        self.assertEqual(result, 'Data of p1')\n\n    def test_assigned_nurse(self):\n        # Assigned nurse should access patient record\n        result = review_patient_data('n1', 'nurse', 'p1')\n        self.assertEqual(result, 'Data of p1')\n\n    def test_unassigned_doctor(self):\n        # Unassigned doctor should be denied access\n        with self.assertRaises(PermissionError):\n            review_patient_data('d2', 'doctor', 'p1')\n\n    def test_unassigned_nurse(self):\n        # Nurse not assigned to patient should be denied\n        with self.assertRaises(PermissionError):\n            review_patient_data('n1', 'nurse', 'p2')\n\n    def test_nonexistent_patient(self):\n        # Non-existent patient should raise ValueError\n        with self.assertRaises(ValueError):\n            review_patient_data('a1', 'admin', 'non_existent')\n\n    def test_other_role(self):\n        # Non-medical role (receptionist) should be denied\n        with self.assertRaises(PermissionError):\n            review_patient_data('r1', 'receptionist', 'p1')\n\n    def test_empty_assigned_staff(self):\n        # Doctor not in empty assigned_staff should be denied\n        with self.assertRaises(PermissionError):\n            review_patient_data('d1', 'doctor', 'p3')", "num_test_cases": 8, "task_id": "329f2292"}
{"test": "import unittest\nfrom unittest.mock import patch\n\n# Assume the function is in a module named 'healthcare'\nfrom healthcare import get_patient_record\n\nclass TestGetPatientRecord(unittest.TestCase):\n    def setUp(self):\n        # Define a base set of patient records for most tests\n        self.patient_records = {\n            \"p1\": {\n                \"patient_id\": \"p1\",\n                \"assigned_staff\": [\"d1\", \"n1\"],\n                \"medical_data\": \"data1\"\n            },\n            \"p2\": {\n                \"patient_id\": \"p2\",\n                \"assigned_staff\": [\"d2\"],\n                \"medical_data\": \"data2\"\n            }\n        }\n        # Patch PATIENT_RECORDS in the 'healthcare' module\n        self.patcher = patch('healthcare.PATIENT_RECORDS', self.patient_records)\n        self.patcher.start()\n    \n    def tearDown(self):\n        self.patcher.stop()\n    \n    def test_admin_access_p1(self):\n        # Admin should access any patient record\n        result = get_patient_record(\"any_admin_id\", \"admin\", \"p1\")\n        self.assertEqual(result, \"data1\")\n    \n    def test_admin_access_p2(self):\n        result = get_patient_record(\"any_admin_id\", \"admin\", \"p2\")\n        self.assertEqual(result, \"data2\")\n    \n    def test_assigned_doctor_access(self):\n        # Doctor assigned to p1 should access\n        result = get_patient_record(\"d1\", \"doctor\", \"p1\")\n        self.assertEqual(result, \"data1\")\n    \n    def test_assigned_nurse_access(self):\n        # Nurse assigned to p1 should access\n        result = get_patient_record(\"n1\", \"nurse\", \"p1\")\n        self.assertEqual(result, \"data1\")\n    \n    def test_doctor_not_assigned(self):\n        # Doctor not assigned to p1 should raise PermissionError\n        with self.assertRaises(PermissionError):\n            get_patient_record(\"d2\", \"doctor\", \"p1\")\n    \n    def test_nurse_not_assigned(self):\n        # Nurse not assigned to p2 should raise PermissionError\n        with self.assertRaises(PermissionError):\n            get_patient_record(\"n1\", \"nurse\", \"p2\")\n    \n    def test_other_role_access(self):\n        # Non-authorized role should raise PermissionError\n        with self.assertRaises(PermissionError):\n            get_patient_record(\"reception1\", \"receptionist\", \"p1\")\n    \n    def test_patient_not_found(self):\n        # Non-existent patient should raise ValueError\n        with self.assertRaises(ValueError):\n            get_patient_record(\"d1\", \"doctor\", \"p3\")\n    \n    def test_empty_patient_identifier(self):\n        # Empty patient identifier should raise ValueError\n        with self.assertRaises(ValueError):\n            get_patient_record(\"d1\", \"doctor\", \"\")\n    \n    def test_none_patient_identifier(self):\n        # None patient identifier should raise ValueError\n        with self.assertRaises(ValueError):\n            get_patient_record(\"d1\", \"doctor\", None)\n    \n    def test_empty_personnel_id_assigned(self):\n        # Empty personnel ID in assigned staff should work\n        self.patient_records[\"p3\"] = {\n            \"patient_id\": \"p3\",\n            \"assigned_staff\": [\"\"],\n            \"medical_data\": \"data3\"\n        }\n        result = get_patient_record(\"\", \"doctor\", \"p3\")\n        self.assertEqual(result, \"data3\")\n    \n    def test_empty_personnel_id_not_assigned(self):\n        # Empty personnel ID not in assigned staff should raise PermissionError\n        with self.assertRaises(PermissionError):\n            get_patient_record(\"\", \"doctor\", \"p1\")\n    \n    def test_none_personnel_id(self):\n        # None personnel ID should raise PermissionError\n        with self.assertRaises(PermissionError):\n            get_patient_record(None, \"doctor\", \"p1\")\n    \n    def test_invalid_personnel_role(self):\n        # Invalid role should raise PermissionError\n        with self.assertRaises(PermissionError):\n            get_patient_record(\"d1\", \"invalid_role\", \"p1\")\n    \n    def test_empty_personnel_role(self):\n        # Empty role should raise PermissionError\n        with self.assertRaises(PermissionError):\n            get_patient_record(\"d1\", \"\", \"p1\")\n    \n    def test_none_personnel_role(self):\n        # None role should raise PermissionError\n        with self.assertRaises(PermissionError):\n            get_patient_record(\"d1\", None, \"p1\")\n    \n    def test_long_strings(self):\n        # Long strings for inputs should work correctly\n        long_str = \"A\" * 1000\n        self.patient_records[long_str] = {\n            \"patient_id\": long_str,\n            \"assigned_staff\": [long_str],\n            \"medical_data\": \"data_long\"\n        }\n        # Admin access with long strings\n        result = get_patient_record(\"admin_id\", \"admin\", long_str)\n        self.assertEqual(result, \"data_long\")\n        # Assigned doctor access with long strings\n        result = get_patient_record(long_str, \"doctor\", long_str)\n        self.assertEqual(result, \"data_long\")\n        # Not assigned personnel should raise PermissionError\n        with self.assertRaises(PermissionError):\n            get_patient_record(\"other_id\", \"doctor\", long_str)\n\nif __name__ == \"__main__\":\n    unittest.main()", "num_test_cases": 18, "task_id": "7455f38e"}
{"test": "import unittest\n\n# Initialize global PATIENT_RECORDS for test environment\nPATIENT_RECORDS = {}\n\nclass TestCases(unittest.TestCase):\n    def setUp(self):\n        \"\"\"Set up test data for PATIENT_RECORDS.\"\"\"\n        global PATIENT_RECORDS\n        PATIENT_RECORDS = {\n            'patient1': {\n                'patient_id': 'patient1',\n                'assigned_staff': ['doc1', 'nurse1'],\n                'medical_data': 'Some medical data for patient1'\n            },\n            'patient2': {\n                'patient_id': 'patient2',\n                'assigned_staff': ['doc2'],\n                'medical_data': 'Medical data for patient2'\n            }\n        }\n    \n    def tearDown(self):\n        \"\"\"Clean up global PATIENT_RECORDS after each test.\"\"\"\n        global PATIENT_RECORDS\n        PATIENT_RECORDS = {}\n    \n    def test_admin_access_patient1(self):\n        \"\"\"Admin role can access patient1 record.\"\"\"\n        result = fetch_patient_info('any_admin_id', 'admin', 'patient1')\n        self.assertEqual(result, 'Some medical data for patient1')\n    \n    def test_admin_access_patient2(self):\n        \"\"\"Admin role can access patient2 record.\"\"\"\n        result = fetch_patient_info('any_admin_id', 'admin', 'patient2')\n        self.assertEqual(result, 'Medical data for patient2')\n    \n    def test_assigned_doctor_patient1(self):\n        \"\"\"Assigned doctor can access patient1 record.\"\"\"\n        result = fetch_patient_info('doc1', 'doctor', 'patient1')\n        self.assertEqual(result, 'Some medical data for patient1')\n    \n    def test_assigned_nurse_patient1(self):\n        \"\"\"Assigned nurse can access patient1 record.\"\"\"\n        result = fetch_patient_info('nurse1', 'nurse', 'patient1')\n        self.assertEqual(result, 'Some medical data for patient1')\n    \n    def test_unassigned_doctor_patient1(self):\n        \"\"\"Unassigned doctor cannot access patient1 record.\"\"\"\n        with self.assertRaises(PermissionError) as context:\n            fetch_patient_info('doc2', 'doctor', 'patient1')\n        self.assertEqual(str(context.exception), 'Unauthorized access: You do not have permission to access this patient\\'s record')\n    \n    def test_unassigned_nurse_patient1(self):\n        \"\"\"Unassigned nurse cannot access patient1 record.\"\"\"\n        with self.assertRaises(PermissionError) as context:\n            fetch_patient_info('nurse2', 'nurse', 'patient1')\n        self.assertEqual(str(context.exception), 'Unauthorized access: You do not have permission to access this patient\\'s record')\n    \n    def test_assigned_doctor_patient2(self):\n        \"\"\"Assigned doctor can access patient2 record.\"\"\"\n        result = fetch_patient_info('doc2', 'doctor', 'patient2')\n        self.assertEqual(result, 'Medical data for patient2')\n    \n    def test_unassigned_nurse_patient2(self):\n        \"\"\"Unassigned nurse cannot access patient2 record.\"\"\"\n        with self.assertRaises(PermissionError) as context:\n            fetch_patient_info('nurse1', 'nurse', 'patient2')\n        self.assertEqual(str(context.exception), 'Unauthorized access: You do not have permission to access this patient\\'s record')\n    \n    def test_patient_not_found(self):\n        \"\"\"Non-existent patient raises ValueError.\"\"\"\n        with self.assertRaises(ValueError) as context:\n            fetch_patient_info('doc1', 'doctor', 'patient3')\n        self.assertEqual(str(context.exception), 'Patient record not found')\n    \n    def test_invalid_staff_role(self):\n        \"\"\"Invalid staff role raises PermissionError.\"\"\"\n        with self.assertRaises(PermissionError) as context:\n            fetch_patient_info('receptionist1', 'receptionist', 'patient1')\n        self.assertEqual(str(context.exception), 'Unauthorized access: You do not have permission to access this patient\\'s record')\n    \n    def test_empty_staff_identifier_assigned_success(self):\n        \"\"\"Empty staff_identifier can access if assigned to patient.\"\"\"\n        global PATIENT_RECORDS\n        original = PATIENT_RECORDS['patient1']['assigned_staff']\n        PATIENT_RECORDS['patient1']['assigned_staff'] = ['']\n        try:\n            result = fetch_patient_info('', 'doctor', 'patient1')\n            self.assertEqual(result, 'Some medical data for patient1')\n        finally:\n            PATIENT_RECORDS['patient1']['assigned_staff'] = original\n    \n    def test_empty_staff_identifier_unassigned(self):\n        \"\"\"Empty staff_identifier raises PermissionError if not assigned.\"\"\"\n        with self.assertRaises(PermissionError) as context:\n            fetch_patient_info('', 'doctor', 'patient1')\n        self.assertEqual(str(context.exception), 'Unauthorized access: You do not have permission to access this patient\\'s record')\n    \n    def test_staff_identifier_none(self):\n        \"\"\"None staff_identifier raises PermissionError.\"\"\"\n        with self.assertRaises(PermissionError) as context:\n            fetch_patient_info(None, 'doctor', 'patient1')\n        self.assertEqual(str(context.exception), 'Unauthorized access: You do not have permission to access this patient\\'s record')\n    \n    def test_staff_role_none(self):\n        \"\"\"None staff_role raises PermissionError.\"\"\"\n        with self.assertRaises(PermissionError) as context:\n            fetch_patient_info('doc1', None, 'patient1')\n        self.assertEqual(str(context.exception), 'Unauthorized access: You do not have permission to access this patient\\'s record')\n    \n    def test_empty_patient_ref(self):\n        \"\"\"Empty patient_ref raises ValueError.\"\"\"\n        with self.assertRaises(ValueError) as context:\n            fetch_patient_info('doc1', 'doctor', '')\n        self.assertEqual(str(context.exception), 'Patient record not found')\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 15, "task_id": "08642c08"}
{"test": "import unittest\nimport solution\n\nclass TestCases(unittest.TestCase):\n    def setUp(self):\n        # Initialize PROJECTS_DB for each test\n        solution.PROJECTS_DB = {\n            'proj1': {\n                'project_id': 'proj1',\n                'creator_id': 'user1',\n                'members': ['user1', 'user2', 'user3'],\n                'settings': {'theme': 'light', 'notifications': 'on'}\n            },\n            'proj2': {\n                'project_id': 'proj2',\n                'creator_id': 'user2',\n                'members': ['user2', 'user3'],\n                'settings': {'theme': 'dark', 'notifications': 'off'}\n            }\n        }\n\n    def test_project_manager_update(self):\n        # Project manager updates multiple settings\n        result = solution.alter_project_preferences('user99', 'project_manager', 'proj1', {'theme': 'blue', 'new_setting': 'value'})\n        self.assertEqual(result, 'Project settings for proj1 have been updated successfully')\n        self.assertEqual(solution.PROJECTS_DB['proj1']['settings'], {'theme': 'blue', 'notifications': 'on', 'new_setting': 'value'})\n\n    def test_creator_update(self):\n        # Creator updates single setting (with team_member role)\n        result = solution.alter_project_preferences('user1', 'team_member', 'proj1', {'theme': 'dark'})\n        self.assertEqual(result, 'Project settings for proj1 have been updated successfully')\n        self.assertEqual(solution.PROJECTS_DB['proj1']['settings'], {'theme': 'dark', 'notifications': 'on'})\n\n    def test_creator_with_project_manager_role(self):\n        # Creator (with project_manager role) updates settings\n        result = solution.alter_project_preferences('user1', 'project_manager', 'proj1', {'theme': 'yellow'})\n        self.assertEqual(result, 'Project settings for proj1 have been updated successfully')\n        self.assertEqual(solution.PROJECTS_DB['proj1']['settings']['theme'], 'yellow')\n\n    def test_project_manager_empty_update(self):\n        # Project manager updates with empty settings (no changes)\n        original_settings = solution.PROJECTS_DB['proj1']['settings'].copy()\n        result = solution.alter_project_preferences('user99', 'project_manager', 'proj1', {})\n        self.assertEqual(result, 'Project settings for proj1 have been updated successfully')\n        self.assertEqual(solution.PROJECTS_DB['proj1']['settings'], original_settings)\n\n    def test_team_member_unauthorized(self):\n        # Team member without creator/project_manager role\n        with self.assertRaises(PermissionError):\n            solution.alter_project_preferences('user2', 'team_member', 'proj1', {'theme': 'dark'})\n\n    def test_viewer_unauthorized(self):\n        # Viewer role unauthorized\n        with self.assertRaises(PermissionError):\n            solution.alter_project_preferences('user3', 'viewer', 'proj1', {'theme': 'dark'})\n\n    def test_project_not_found(self):\n        # Non-existent project ID\n        with self.assertRaises(ValueError):\n            solution.alter_project_preferences('user1', 'project_manager', 'invalid_proj', {'theme': 'dark'})\n\n    def test_project_manager_not_creator(self):\n        # Project manager not in project members\n        result = solution.alter_project_preferences('user99', 'project_manager', 'proj1', {'theme': 'purple'})\n        self.assertEqual(result, 'Project settings for proj1 have been updated successfully')\n        self.assertEqual(solution.PROJECTS_DB['proj1']['settings']['theme'], 'purple')", "num_test_cases": 8, "task_id": "8fa8fe45"}
{"test": "import unittest\nimport sys\n\n# Get the current module\ncurrent_module = sys.modules[__name__]\n\nclass TestCases(unittest.TestCase):\n    \n    def setUp(self):\n        # Set up the global PROJECTS_DB for the current module\n        setattr(current_module, 'PROJECTS_DB', {\n            \"project1\": {\n                \"project_id\": \"project1\",\n                \"creator_id\": \"user1\",\n                \"members\": [\"user1\", \"user2\"],\n                \"settings\": {\"key1\": \"value1\", \"key2\": \"value2\"}\n            },\n            \"project2\": {\n                \"project_id\": \"project2\",\n                \"creator_id\": \"user3\",\n                \"members\": [\"user3\", \"user4\"],\n                \"settings\": {\"keyA\": \"valueA\"}\n            }\n        })\n    \n    def tearDown(self):\n        # Clean up the global PROJECTS_DB\n        setattr(current_module, 'PROJECTS_DB', {})\n    \n    def test_authorized_project_manager_member(self):\n        \"\"\"Test project manager who is a member can update settings.\"\"\"\n        editor_id = \"user2\"\n        editor_role = \"project_manager\"\n        proj_id = \"project1\"\n        updated_settings = {\"key1\": \"new_value\"}\n        result = adjust_project_options(editor_id, editor_role, proj_id, updated_settings)\n        self.assertEqual(result, f\"Project settings for {proj_id} have been updated successfully\")\n        self.assertEqual(PROJECTS_DB[proj_id][\"settings\"][\"key1\"], \"new_value\")\n    \n    def test_authorized_project_manager_non_member(self):\n        \"\"\"Test project manager who is not a member can update settings.\"\"\"\n        editor_id = \"user999\"\n        editor_role = \"project_manager\"\n        proj_id = \"project1\"\n        updated_settings = {\"key3\": \"value3\"}\n        result = adjust_project_options(editor_id, editor_role, proj_id, updated_settings)\n        self.assertEqual(result, f\"Project settings for {proj_id} have been updated successfully\")\n        self.assertEqual(PROJECTS_DB[proj_id][\"settings\"][\"key3\"], \"value3\")\n    \n    def test_authorized_creator(self):\n        \"\"\"Test project creator can update settings.\"\"\"\n        editor_id = \"user1\"\n        editor_role = \"team_member\"\n        proj_id = \"project1\"\n        updated_settings = {\"key2\": \"updated_by_creator\"}\n        result = adjust_project_options(editor_id, editor_role, proj_id, updated_settings)\n        self.assertEqual(result, f\"Project settings for {proj_id} have been updated successfully\")\n        self.assertEqual(PROJECTS_DB[proj_id][\"settings\"][\"key2\"], \"updated_by_creator\")\n    \n    def test_unauthorized_team_member(self):\n        \"\"\"Test team member (not creator) cannot update settings.\"\"\"\n        editor_id = \"user2\"\n        editor_role = \"team_member\"\n        proj_id = \"project1\"\n        updated_settings = {\"key1\": \"try_update\"}\n        with self.assertRaises(PermissionError):\n            adjust_project_options(editor_id, editor_role, proj_id, updated_settings)\n        self.assertEqual(PROJECTS_DB[proj_id][\"settings\"][\"key1\"], \"value1\")\n    \n    def test_unauthorized_viewer(self):\n        \"\"\"Test viewer cannot update settings.\"\"\"\n        editor_id = \"user4\"\n        editor_role = \"viewer\"\n        proj_id = \"project2\"\n        updated_settings = {\"keyA\": \"try_update\"}\n        with self.assertRaises(PermissionError):\n            adjust_project_options(editor_id, editor_role, proj_id, updated_settings)\n        self.assertEqual(PROJECTS_DB[proj_id][\"settings\"][\"keyA\"], \"valueA\")\n    \n    def test_unauthorized_non_member_non_project_manager(self):\n        \"\"\"Test non-member and non-project manager cannot update settings.\"\"\"\n        editor_id = \"user999\"\n        editor_role = \"team_member\"\n        proj_id = \"project1\"\n        updated_settings = {\"key1\": \"try_update\"}\n        with self.assertRaises(PermissionError):\n            adjust_project_options(editor_id, editor_role, proj_id, updated_settings)\n        self.assertEqual(PROJECTS_DB[proj_id][\"settings\"][\"key1\"], \"value1\")\n    \n    def test_project_not_found(self):\n        \"\"\"Test updating a non-existent project raises ValueError.\"\"\"\n        editor_id = \"user1\"\n        editor_role = \"project_manager\"\n        proj_id = \"non_existent\"\n        updated_settings = {\"key1\": \"value\"}\n        with self.assertRaises(ValueError):\n            adjust_project_options(editor_id, editor_role, proj_id, updated_settings)\n    \n    def test_update_with_empty_settings(self):\n        \"\"\"Test updating with empty settings (no changes).\"\"\"\n        editor_id = \"user1\"\n        editor_role = \"project_manager\"\n        proj_id = \"project1\"\n        updated_settings = {}\n        original_settings = PROJECTS_DB[proj_id][\"settings\"].copy()\n        result = adjust_project_options(editor_id, editor_role, proj_id, updated_settings)\n        self.assertEqual(result, f\"Project settings for {proj_id} have been updated successfully\")\n        self.assertEqual(original_settings, PROJECTS_DB[proj_id][\"settings\"])\n    \n    def test_update_multiple_settings(self):\n        \"\"\"Test updating multiple settings at once.\"\"\"\n        editor_id = \"user3\"\n        editor_role = \"project_manager\"\n        proj_id = \"project2\"\n        updated_settings = {\"keyA\": \"newA\", \"keyB\": \"newB\"}\n        result = adjust_project_options(editor_id, editor_role, proj_id, updated_settings)\n        self.assertEqual(result, f\"Project settings for {proj_id} have been updated successfully\")\n        self.assertEqual(PROJECTS_DB[proj_id][\"settings\"][\"keyA\"], \"newA\")\n        self.assertEqual(PROJECTS_DB[proj_id][\"settings\"][\"keyB\"], \"newB\")", "num_test_cases": 9, "task_id": "c37ed121"}
{"test": "import unittest\n\n# Global PROJECTS_DB for testing\nPROJECTS_DB = {}\n\ndef update_project_configurations(u_id: str, u_role: str, proj_id: str, modified_settings: dict):\n    if proj_id not in PROJECTS_DB:\n        raise ValueError(\"Project not found\")\n    if u_role == \"project_manager\" or u_id == PROJECTS_DB[proj_id][\"creator_id\"]:\n        PROJECTS_DB[proj_id][\"settings\"].update(modified_settings)\n        return f\"Project settings for {proj_id} have been updated successfully\"\n    else:\n        raise PermissionError(\"Unauthorized access: You do not have permission to modify this project's settings\")\n\nclass TestUpdateProjectConfigurations(unittest.TestCase):\n    def setUp(self):\n        global PROJECTS_DB\n        PROJECTS_DB = {\n            \"proj1\": {\n                \"project_id\": \"proj1\",\n                \"creator_id\": \"user1\",\n                \"members\": [\"user1\", \"user2\"],\n                \"settings\": {\"theme\": \"light\", \"notifications\": \"on\"}\n            },\n            \"proj2\": {\n                \"project_id\": \"proj2\",\n                \"creator_id\": \"user2\",\n                \"members\": [\"user2\"],\n                \"settings\": {\"theme\": \"dark\"}\n            }\n        }\n\n    def test_authorized_as_project_manager(self):\n        # User with project_manager role can update\n        result = update_project_configurations(\"user3\", \"project_manager\", \"proj1\", {\"theme\": \"dark\"})\n        self.assertEqual(result, \"Project settings for proj1 have been updated successfully\")\n        self.assertEqual(PROJECTS_DB[\"proj1\"][\"settings\"][\"theme\"], \"dark\")\n\n    def test_authorized_as_creator(self):\n        # Creator can update even with non-manager role\n        result = update_project_configurations(\"user1\", \"team_member\", \"proj1\", {\"notifications\": \"off\"})\n        self.assertEqual(result, \"Project settings for proj1 have been updated successfully\")\n        self.assertEqual(PROJECTS_DB[\"proj1\"][\"settings\"][\"notifications\"], \"off\")\n\n    def test_authorized_project_manager_not_member(self):\n        # Project_manager not in members list can still update\n        result = update_project_configurations(\"user99\", \"project_manager\", \"proj1\", {\"theme\": \"blue\"})\n        self.assertEqual(result, \"Project settings for proj1 have been updated successfully\")\n        self.assertEqual(PROJECTS_DB[\"proj1\"][\"settings\"][\"theme\"], \"blue\")\n\n    def test_project_not_found(self):\n        # Invalid project ID\n        with self.assertRaises(ValueError) as context:\n            update_project_configurations(\"user1\", \"project_manager\", \"invalid_id\", {})\n        self.assertEqual(str(context.exception), \"Project not found\")\n\n    def test_unauthorized_team_member(self):\n        # Team member without manager/creator role\n        with self.assertRaises(PermissionError) as context:\n            update_project_configurations(\"user2\", \"team_member\", \"proj1\", {\"theme\": \"dark\"})\n        self.assertEqual(str(context.exception), \"Unauthorized access: You do not have permission to modify this project's settings\")\n\n    def test_unauthorized_viewer_role(self):\n        # Viewer role should not have access\n        with self.assertRaises(PermissionError) as context:\n            update_project_configurations(\"user1\", \"viewer\", \"proj1\", {})\n        self.assertEqual(str(context.exception), \"Unauthorized access: You do not have permission to modify this project's settings\")\n\n    def test_unauthorized_admin_role(self):\n        # Non-manager role (admin) shouldn't have access\n        with self.assertRaises(PermissionError) as context:\n            update_project_configurations(\"user1\", \"admin\", \"proj1\", {})\n        self.assertEqual(str(context.exception), \"Unauthorized access: You do not have permission to modify this project's settings\")\n\n    def test_empty_settings_update(self):\n        # Empty settings dict should succeed but change nothing\n        original_settings = PROJECTS_DB[\"proj1\"][\"settings\"].copy()\n        result = update_project_configurations(\"user1\", \"project_manager\", \"proj1\", {})\n        self.assertEqual(result, \"Project settings for proj1 have been updated successfully\")\n        self.assertEqual(PROJECTS_DB[\"proj1\"][\"settings\"], original_settings)\n\n    def test_multiple_settings_update(self):\n        # Updating multiple settings at once\n        new_settings = {\"theme\": \"blue\", \"notifications\": \"off\", \"language\": \"en\"}\n        result = update_project_configurations(\"user1\", \"project_manager\", \"proj1\", new_settings)\n        self.assertEqual(result, \"Project settings for proj1 have been updated successfully\")\n        for key, value in new_settings.items():\n            self.assertEqual(PROJECTS_DB[\"proj1\"][\"settings\"][key], value)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 10, "task_id": "8235bb25"}
{"test": "import unittest\n\nPROJECTS_DB = {}\n\ndef update_project_configurations(uid: str, role: str, pid: str, settings: dict):\n    if pid not in PROJECTS_DB:\n        raise ValueError(\"Project not found\")\n    if role == \"project_manager\" or uid == PROJECTS_DB[pid][\"creator_id\"]:\n        PROJECTS_DB[pid][\"settings\"].update(settings)\n        return f\"Project settings for {pid} have been updated successfully\"\n    else:\n        raise PermissionError(\"Unauthorized access: You do not have permission to modify this project's settings\")\n\nclass TestUpdateProjectConfigurations(unittest.TestCase):\n    def setUp(self):\n        global PROJECTS_DB\n        PROJECTS_DB = {\n            'project1': {\n                'project_id': 'project1',\n                'creator_id': 'user1',\n                'members': {\n                    'user1': 'project_manager',\n                    'user2': 'team_member',\n                    'user3': 'viewer',\n                    'user4': 'project_manager'\n                },\n                'settings': {'current_sprint': 'Sprint 1'}\n            }\n        }\n\n    def test_project_manager_update(self):\n        # Project manager (non-creator) updates settings\n        result = update_project_configurations('user4', 'project_manager', 'project1', {'new_setting': 'value'})\n        self.assertEqual(result, \"Project settings for project1 have been updated successfully\")\n        self.assertEqual(PROJECTS_DB['project1']['settings'], {'current_sprint': 'Sprint 1', 'new_setting': 'value'})\n\n    def test_creator_update(self):\n        # Creator updates settings (even with a non-manager role)\n        result = update_project_configurations('user1', 'team_member', 'project1', {'current_sprint': 'Sprint 2'})\n        self.assertEqual(result, \"Project settings for project1 have been updated successfully\")\n        self.assertEqual(PROJECTS_DB['project1']['settings'], {'current_sprint': 'Sprint 2'})\n\n    def test_team_member_unauthorized(self):\n        # Team member (non-creator) cannot update\n        with self.assertRaises(PermissionError):\n            update_project_configurations('user2', 'team_member', 'project1', {'attempt': 'fail'})\n        self.assertEqual(PROJECTS_DB['project1']['settings'], {'current_sprint': 'Sprint 1'})\n\n    def test_viewer_unauthorized(self):\n        # Viewer cannot update\n        with self.assertRaises(PermissionError):\n            update_project_configurations('user3', 'viewer', 'project1', {'attempt': 'fail'})\n        self.assertEqual(PROJECTS_DB['project1']['settings'], {'current_sprint': 'Sprint 1'})\n\n    def test_project_not_found(self):\n        # Invalid project ID raises error\n        with self.assertRaises(ValueError):\n            update_project_configurations('user1', 'project_manager', 'project2', {'a': 'b'})\n\n    def test_settings_merge(self):\n        # Settings are merged, not replaced\n        update_project_configurations('user1', 'project_manager', 'project1', {'key1': 'val1', 'key2': 'val2'})\n        self.assertIn('key1', PROJECTS_DB['project1']['settings'])\n        self.assertIn('key2', PROJECTS_DB['project1']['settings'])\n        self.assertEqual(PROJECTS_DB['project1']['settings']['current_sprint'], 'Sprint 1')\n\n    def test_empty_settings_update(self):\n        # Empty settings update does not change existing settings\n        result = update_project_configurations('user1', 'project_manager', 'project1', {})\n        self.assertEqual(result, \"Project settings for project1 have been updated successfully\")\n        self.assertEqual(PROJECTS_DB['project1']['settings'], {'current_sprint': 'Sprint 1'})\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 7, "task_id": "831d4701"}
{"test": "import unittest\n\n# Define the global PROJECTS_DB that the function uses\nPROJECTS_DB = {}\n\nclass TestAdjustProjectParams(unittest.TestCase):\n    def setUp(self):\n        \"\"\"Initialize PROJECTS_DB before each test.\"\"\"\n        global PROJECTS_DB\n        PROJECTS_DB = {\n            \"project1\": {\n                \"project_id\": \"project1\",\n                \"creator_id\": \"user1\",\n                \"members\": [\"user1\", \"user2\", \"user3\"],\n                \"settings\": {\"theme\": \"light\", \"language\": \"en\"}\n            },\n            \"project2\": {\n                \"project_id\": \"project2\",\n                \"creator_id\": \"user2\",\n                \"members\": [\"user2\", \"user4\"],\n                \"settings\": {\"theme\": \"dark\"}\n            }\n        }\n    \n    def tearDown(self):\n        \"\"\"Clear PROJECTS_DB after each test.\"\"\"\n        global PROJECTS_DB\n        PROJECTS_DB = {}\n\n    def test_project_manager_update(self):\n        \"\"\"Test project_manager (not creator) can update settings.\"\"\"\n        result = adjust_project_params(\"user3\", \"project_manager\", \"project1\", {\"theme\": \"dark\"})\n        self.assertEqual(result, \"Project settings for project1 have been updated successfully\")\n        self.assertEqual(PROJECTS_DB[\"project1\"][\"settings\"][\"theme\"], \"dark\")\n\n    def test_creator_update(self):\n        \"\"\"Test creator (with any role) can update settings.\"\"\"\n        result = adjust_project_params(\"user1\", \"team_member\", \"project1\", {\"theme\": \"blue\"})\n        self.assertEqual(result, \"Project settings for project1 have been updated successfully\")\n        self.assertEqual(PROJECTS_DB[\"project1\"][\"settings\"][\"theme\"], \"blue\")\n\n    def test_team_member_unauthorized(self):\n        \"\"\"Test team_member (not creator) cannot update settings.\"\"\"\n        with self.assertRaises(PermissionError):\n            adjust_project_params(\"user3\", \"team_member\", \"project1\", {\"theme\": \"dark\"})\n\n    def test_viewer_unauthorized(self):\n        \"\"\"Test viewer (not creator) cannot update settings.\"\"\"\n        with self.assertRaises(PermissionError):\n            adjust_project_params(\"user4\", \"viewer\", \"project2\", {\"theme\": \"light\"})\n\n    def test_project_not_found(self):\n        \"\"\"Test updating non-existent project raises ValueError.\"\"\"\n        with self.assertRaises(ValueError):\n            adjust_project_params(\"user1\", \"project_manager\", \"project3\", {\"theme\": \"dark\"})\n\n    def test_empty_updated_values(self):\n        \"\"\"Test updating with empty dictionary doesn't change settings but succeeds.\"\"\"\n        original_settings = dict(PROJECTS_DB[\"project1\"][\"settings\"])\n        result = adjust_project_params(\"user1\", \"project_manager\", \"project1\", {})\n        self.assertEqual(result, \"Project settings for project1 have been updated successfully\")\n        self.assertEqual(PROJECTS_DB[\"project1\"][\"settings\"], original_settings)\n\n    def test_multiple_settings_update(self):\n        \"\"\"Test updating multiple settings at once.\"\"\"\n        result = adjust_project_params(\"user2\", \"project_manager\", \"project2\", {\"theme\": \"light\", \"language\": \"fr\"})\n        self.assertEqual(result, \"Project settings for project2 have been updated successfully\")\n        self.assertEqual(PROJECTS_DB[\"project2\"][\"settings\"], {\"theme\": \"light\", \"language\": \"fr\"})\n\n    def test_project_manager_not_member(self):\n        \"\"\"Test project_manager not in project members can still update.\"\"\"\n        result = adjust_project_params(\"user_x\", \"project_manager\", \"project1\", {\"theme\": \"red\"})\n        self.assertEqual(result, \"Project settings for project1 have been updated successfully\")\n        self.assertEqual(PROJECTS_DB[\"project1\"][\"settings\"][\"theme\"], \"red\")\n\n    def test_creator_with_viewer_role(self):\n        \"\"\"Test creator can update even with viewer role.\"\"\"\n        result = adjust_project_params(\"user1\", \"viewer\", \"project1\", {\"theme\": \"green\"})\n        self.assertEqual(result, \"Project settings for project1 have been updated successfully\")\n        self.assertEqual(PROJECTS_DB[\"project1\"][\"settings\"][\"theme\"], \"green\")\n\n    def test_creator_and_project_manager(self):\n        \"\"\"Test user who is both creator and project_manager can update.\"\"\"\n        result = adjust_project_params(\"user2\", \"project_manager\", \"project2\", {\"theme\": \"blue\"})\n        self.assertEqual(result, \"Project settings for project2 have been updated successfully\")\n        self.assertEqual(PROJECTS_DB[\"project2\"][\"settings\"][\"theme\"], \"blue\")\n", "num_test_cases": 10, "task_id": "5c7df4b2"}
{"test": "import unittest\nfrom unittest.mock import patch\n\nclass TestChangeProjectSettings(unittest.TestCase):\n    def setUp(self):\n        # Initialize a mock PROJECTS_DB for each test\n        self.mock_db = {\n            \"project_1\": {\n                \"project_id\": \"project_1\",\n                \"creator_id\": \"user1\",\n                \"members\": [\"user1\", \"user2\", \"user3\"],\n                \"settings\": {\"theme\": \"dark\", \"language\": \"en\"}\n            }\n        }\n\n    def test_project_not_found(self):\n        # Test with non-existent project ID\n        with patch('solution.PROJECTS_DB', self.mock_db):\n            with self.assertRaises(ValueError):\n                change_project_settings(\"user1\", \"project_manager\", \"project_404\", {\"theme\": \"light\"})\n\n    def test_unauthorized_team_member(self):\n        # Test team_member access (insufficient permissions)\n        with patch('solution.PROJECTS_DB', self.mock_db):\n            with self.assertRaises(PermissionError):\n                change_project_settings(\"user2\", \"team_member\", \"project_1\", {\"theme\": \"light\"})\n            # Verify settings unchanged\n            self.assertEqual(self.mock_db[\"project_1\"][\"settings\"], {\"theme\": \"dark\", \"language\": \"en\"})\n\n    def test_unauthorized_viewer(self):\n        # Test viewer access (insufficient permissions)\n        with patch('solution.PROJECTS_DB', self.mock_db):\n            with self.assertRaises(PermissionError):\n                change_project_settings(\"user3\", \"viewer\", \"project_1\", {\"theme\": \"light\"})\n            # Verify settings unchanged\n            self.assertEqual(self.mock_db[\"project_1\"][\"settings\"], {\"theme\": \"dark\", \"language\": \"en\"})\n\n    def test_unauthorized_other_role(self):\n        # Test other role (e.g., 'guest') with insufficient permissions\n        with patch('solution.PROJECTS_DB', self.mock_db):\n            with self.assertRaises(PermissionError):\n                change_project_settings(\"user4\", \"guest\", \"project_1\", {\"theme\": \"light\"})\n            # Verify settings unchanged\n            self.assertEqual(self.mock_db[\"project_1\"][\"settings\"], {\"theme\": \"dark\", \"language\": \"en\"})\n\n    def test_authorized_project_manager(self):\n        # Test project_manager access (authorized)\n        with patch('solution.PROJECTS_DB', self.mock_db):\n            result = change_project_settings(\"user_manager\", \"project_manager\", \"project_1\", {\"theme\": \"light\"})\n            # Check return message\n            self.assertEqual(result, \"Project settings for project_1 have been updated successfully\")\n            # Verify settings updated\n            self.assertEqual(self.mock_db[\"project_1\"][\"settings\"], {\"theme\": \"light\", \"language\": \"en\"})\n\n    def test_authorized_creator(self):\n        # Test creator access (authorized)\n        with patch('solution.PROJECTS_DB\", self.mock_db):\n            result = change_project_settings(\"user1\", \"team_member\", \"project_1\", {\"language\": \"fr\"})\n            # Check return message\n            self.assertEqual(result, \"Project settings for project_1 have been updated successfully\")\n            # Verify settings updated\n            self.assertEqual(self.mock_db[\"project_1\"][\"settings\"], {\"theme\": \"dark\", \"language\": \"fr\"})\n\n    def test_empty_modifications(self):\n        # Test authorized update with empty modifications\n        with patch('solution.PROJECTS_DB\", self.mock_db):\n            result = change_project_settings(\"user1\", \"team_member\", \"project_1\", {})\n            # Check return message\n            self.assertEqual(result, \"Project settings for project_1 have been updated successfully\")\n            # Verify settings unchanged\n            self.assertEqual(self.mock_db[\"project_1\"][\"settings\"], {\"theme\": \"dark\", \"language\": \"en\"})\n\n    def test_multiple_modifications(self):\n        # Test updating multiple settings at once\n        with patch('solution.PROJECTS_DB\", self.mock_db):\n            modifications = {\"theme\": \"light\", \"language\": \"fr\", \"notifications\": \"off\"}\n            result = change_project_settings(\"user_manager\", \"project_manager\", \"project_1\", modifications)\n            # Check return message\n            self.assertEqual(result, \"Project settings for project_1 have been updated successfully\")\n            # Verify settings updated\n            self.assertEqual(self.mock_db[\"project_1\"][\"settings\"], modifications)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 8, "task_id": "ce9f974c"}
{"test": "import unittest\nfrom unittest.mock import patch\n\n# Assuming the function is in a module named 'project_management'\nfrom project_management import update_project_configurations\n\nclass TestUpdateProjectConfigurations(unittest.TestCase):\n\n    def test_creator_can_update(self):\n        # Test that creator (emp1) can update settings successfully\n        test_db = {\n            'proj1': {\n                'project_id': 'proj1',\n                'creator_id': 'emp1',\n                'members': ['emp1', 'emp2'],\n                'settings': {'old_key': 'old_value'}\n            }\n        }\n        with patch('project_management.PROJECTS_DB', test_db):\n            result = update_project_configurations('emp1', 'team_member', 'proj1', {'new_key': 'new_value'})\n            self.assertEqual(result, \"Project settings for proj1 have been updated successfully\")\n            self.assertEqual(test_db['proj1']['settings'], {'old_key': 'old_value', 'new_key': 'new_value'})\n\n    def test_project_manager_can_update(self):\n        # Test that project_manager (emp2) can update settings successfully\n        test_db = {\n            'proj1': {\n                'project_id': 'proj1',\n                'creator_id': 'emp1',\n                'members': ['emp1', 'emp2'],\n                'settings': {'old_key': 'old_value'}\n            }\n        }\n        with patch('project_management.PROJECTS_DB', test_db):\n            result = update_project_configurations('emp2', 'project_manager', 'proj1', {'new_key': 'new_value'})\n            self.assertEqual(result, \"Project settings for proj1 have been updated successfully\")\n            self.assertEqual(test_db['proj1']['settings'], {'old_key': 'old_value', 'new_key': 'new_value'})\n\n    def test_project_not_found(self):\n        # Test that non-existent project raises ValueError\n        test_db = {}\n        with patch('project_management.PROJECTS_DB', test_db):\n            with self.assertRaises(ValueError) as context:\n                update_project_configurations('emp1', 'project_manager', 'proj1', {'key': 'value'})\n            self.assertEqual(str(context.exception), \"Project not found\")\n\n    def test_unauthorized_team_member(self):\n        # Test that unauthorized team_member (emp2) raises PermissionError\n        test_db = {\n            'proj1': {\n                'project_id': 'proj1',\n                'creator_id': 'emp1',\n                'members': ['emp1', 'emp2'],\n                'settings': {}\n            }\n        }\n        with patch('project_management.PROJECTS_DB', test_db):\n            with self.assertRaises(PermissionError) as context:\n                update_project_configurations('emp2', 'team_member', 'proj1', {'key': 'value'})\n            self.assertEqual(str(context.exception), \"Unauthorized access: You do not have permission to modify this project's settings\")\n\n    def test_unauthorized_viewer(self):\n        # Test that viewer role raises PermissionError\n        test_db = {\n            'proj1': {\n                'project_id': 'proj1',\n                'creator_id': 'emp1',\n                'members': ['emp1', 'emp2'],\n                'settings': {}\n            }\n        }\n        with patch('project_management.PROJECTS_DB', test_db):\n            with self.assertRaises(PermissionError) as context:\n                update_project_configurations('emp2', 'viewer', 'proj1', {'key': 'value'})\n            self.assertEqual(str(context.exception), \"Unauthorized access: You do not have permission to modify this project's settings\")\n\n    def test_unauthorized_unknown_role(self):\n        # Test that unknown role raises PermissionError\n        test_db = {\n            'proj1': {\n                'project_id': 'proj1',\n                'creator_id': 'emp1',\n                'members': ['emp1', 'emp2'],\n                'settings': {}\n            }\n        }\n        with patch('project_management.PROJECTS_DB', test_db):\n            with self.assertRaises(PermissionError) as context:\n                update_project_configurations('emp2', 'unknown_role', 'proj1', {'key': 'value'})\n            self.assertEqual(str(context.exception), \"Unauthorized access: You do not have permission to modify this project's settings\")\n\n    def test_update_multiple_settings(self):\n        # Test updating with multiple settings (overwrite existing, add new)\n        test_db = {\n            'proj1': {\n                'project_id': 'proj1',\n                'creator_id': 'emp1',\n                'members': ['emp1', 'emp2'],\n                'settings': {'key1': 'old_val1', 'key2': 'val2'}\n            }\n        }\n        with patch('project_management.PROJECTS_DB', test_db):\n            updated_settings = {'key1': 'new_val1', 'key3': 'val3'}\n            result = update_project_configurations('emp1', 'team_member', 'proj1', updated_settings)\n            self.assertEqual(result, \"Project settings for proj1 have been updated successfully\")\n            self.assertEqual(test_db['proj1']['settings'], {'key1': 'new_val1', 'key2': 'val2', 'key3': 'val3'})\n\n    def test_update_empty_settings(self):\n        # Test updating with empty settings dictionary (no changes)\n        test_db = {\n            'proj1': {\n                'project_id': 'proj1',\n                'creator_id': 'emp1',\n                'members': ['emp1', 'emp2'],\n                'settings': {'key1': 'value1'}\n            }\n        }\n        with patch('project_management.PROJECTS_DB', test_db):\n            result = update_project_configurations('emp1', 'team_member', 'proj1', {})\n            self.assertEqual(result, \"Project settings for proj1 have been updated successfully\")\n            self.assertEqual(test_db['proj1']['settings'], {'key1': 'value1'})\n", "num_test_cases": 8, "task_id": "e99241d2"}
{"test": "import unittest\n\n# Define a global PROJECTS_DB for testing\nPROJECTS_DB = {}\n\nclass TestChangeProjectConfig(unittest.TestCase):\n    def setUp(self):\n        \"\"\"Reset the global PROJECTS_DB to a known state before each test.\"\"\"\n        global PROJECTS_DB\n        PROJECTS_DB = {\n            \"project1\": {\n                \"project_id\": \"project1\",\n                \"creator_id\": \"creator_user\",\n                \"members\": [\"creator_user\", \"member_user\"],\n                \"settings\": {\"theme\": \"light\", \"notifications\": \"on\"}\n            },\n            \"project2\": {\n                \"project_id\": \"project2\",\n                \"creator_id\": \"another_creator\",\n                \"members\": [\"another_creator\"],\n                \"settings\": {\"theme\": \"dark\"}\n            }\n        }\n\n    def test_authorized_project_manager(self):\n        \"\"\"Test update by a user with 'project_manager' role (authorized).\"\"\"\n        result = change_project_config(\"manager_user\", \"project_manager\", \"project1\", {\"theme\": \"dark\"})\n        self.assertEqual(result, \"Project settings for project1 have been updated successfully\")\n        self.assertEqual(PROJECTS_DB[\"project1\"][\"settings\"][\"theme\"], \"dark\")\n\n    def test_authorized_creator(self):\n        \"\"\"Test update by the project creator (authorized even with non-manager role).\"\"\"\n        result = change_project_config(\"creator_user\", \"team_member\", \"project1\", {\"notifications\": \"off\"})\n        self.assertEqual(result, \"Project settings for project1 have been updated successfully\")\n        self.assertEqual(PROJECTS_DB[\"project1\"][\"settings\"][\"notifications\"], \"off\")\n\n    def test_unauthorized_team_member(self):\n        \"\"\"Test unauthorized update by a team_member who is not the creator.\"\"\"\n        with self.assertRaises(PermissionError):\n            change_project_config(\"member_user\", \"team_member\", \"project1\", {\"theme\": \"blue\"})\n        self.assertEqual(PROJECTS_DB[\"project1\"][\"settings\"][\"theme\"], \"light\")  # Ensure no change\n\n    def test_unauthorized_viewer(self):\n        \"\"\"Test unauthorized update by a viewer role.\"\"\"\n        with self.assertRaises(PermissionError):\n            change_project_config(\"viewer_user\", \"viewer\", \"project1\", {\"theme\": \"blue\"})\n        self.assertEqual(PROJECTS_DB[\"project1\"][\"settings\"][\"theme\"], \"light\")\n\n    def test_project_not_found(self):\n        \"\"\"Test updating a non-existent project.\"\"\"\n        with self.assertRaises(ValueError):\n            change_project_config(\"any_user\", \"project_manager\", \"invalid_project\", {\"theme\": \"blue\"})\n\n    def test_authorized_creator_viewer_role(self):\n        \"\"\"Test creator can update even with 'viewer' role.\"\"\"\n        result = change_project_config(\"creator_user\", \"viewer\", \"project1\", {\"theme\": \"blue\"})\n        self.assertEqual(result, \"Project settings for project1 have been updated successfully\")\n        self.assertEqual(PROJECTS_DB[\"project1\"][\"settings\"][\"theme\"], \"blue\")\n\n    def test_empty_settings_update(self):\n        \"\"\"Test updating with an empty settings dictionary.\"\"\"\n        original_settings = PROJECTS_DB[\"project1\"][\"settings\"].copy()\n        result = change_project_config(\"creator_user\", \"team_member\", \"project1\", {})\n        self.assertEqual(result, \"Project settings for project1 have been updated successfully\")\n        self.assertEqual(PROJECTS_DB[\"project1\"][\"settings\"], original_settings)  # Settings unchanged\n\n    def test_multiple_settings_update(self):\n        \"\"\"Test updating multiple settings at once.\"\"\"\n        settings_update = {\"theme\": \"dark\", \"notifications\": \"off\", \"language\": \"en\"}\n        result = change_project_config(\"creator_user\", \"team_member\", \"project1\", settings_update)\n        self.assertEqual(result, \"Project settings for project1 have been updated successfully\")\n        self.assertEqual(PROJECTS_DB[\"project1\"][\"settings\"], settings_update)\n\n    def test_unauthorized_non_member(self):\n        \"\"\"Test unauthorized user not in members list.\"\"\"\n        with self.assertRaises(PermissionError):\n            change_project_config(\"outsider\", \"team_member\", \"project1\", {\"theme\": \"blue\"})\n        self.assertEqual(PROJECTS_DB[\"project1\"][\"settings\"][\"theme\"], \"light\")\n\n    def test_project_manager_not_in_members(self):\n        \"\"\"Test project_manager can update even if not in members.\"\"\"\n        result = change_project_config(\"outside_manager\", \"project_manager\", \"project1\", {\"theme\": \"blue\"})\n        self.assertEqual(result, \"Project settings for project1 have been updated successfully\")\n        self.assertEqual(PROJECTS_DB[\"project1\"][\"settings\"][\"theme\"], \"blue\")\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 10, "task_id": "ee3e6922"}
{"test": "import unittest\nfrom unittest.mock import patch\nimport solution\nfrom solution import edit_project_settings\n\nclass TestProjectSettings(unittest.TestCase):\n    def test_authorized_by_role(self):\n        \"\"\"Test updating settings with a project_manager role.\"\"\"\n        with patch('solution.PROJECTS_DB', {\n            'project1': {'project_id': 'project1', 'creator_id': 'user1', 'members': ['user1', 'user2'], 'settings': {'color': 'blue'}}\n        }):\n            result = edit_project_settings('user2', 'project_manager', 'project1', {'color': 'red'})\n            self.assertEqual(result, \"Project settings for project1 have been updated successfully\")\n            self.assertEqual(solution.PROJECTS_DB['project1']['settings'], {'color': 'red'})\n\n    def test_authorized_by_creator(self):\n        \"\"\"Test updating settings when member is the creator.\"\"\"\n        with patch('solution.PROJECTS_DB', {\n            'project1': {'project_id': 'project1', 'creator_id': 'user1', 'members': ['user1', 'user2'], 'settings': {'color': 'blue'}}\n        }):\n            result = edit_project_settings('user1', 'team_member', 'project1', {'color': 'green'})\n            self.assertEqual(result, \"Project settings for project1 have been updated successfully\")\n            self.assertEqual(solution.PROJECTS_DB['project1']['settings'], {'color': 'green'})\n\n    def test_unauthorized(self):\n        \"\"\"Test unauthorized user cannot update settings.\"\"\"\n        with patch('solution.PROJECTS_DB', {\n            'project1': {'project_id': 'project1', 'creator_id': 'user1', 'members': ['user1', 'user2'], 'settings': {'color': 'blue'}}\n        }):\n            with self.assertRaises(PermissionError):\n                edit_project_settings('user3', 'team_member', 'project1', {'color': 'yellow'})\n\n    def test_project_not_found(self):\n        \"\"\"Test updating a non-existent project raises ValueError.\"\"\"\n        with patch('solution.PROJECTS_DB', {}):\n            with self.assertRaises(ValueError):\n                edit_project_settings('user1', 'project_manager', 'project2', {'color': 'purple'})\n\n    def test_empty_updated_configuration(self):\n        \"\"\"Test updating with empty configuration does not change settings.\"\"\"\n        with patch('solution.PROJECTS_DB', {\n            'project1': {'project_id': 'project1', 'creator_id': 'user1', 'members': ['user1', 'user2'], 'settings': {'color': 'blue'}}\n        }):\n            result = edit_project_settings('user1', 'project_manager', 'project1', {})\n            self.assertEqual(result, \"Project settings for project1 have been updated successfully\")\n            self.assertEqual(solution.PROJECTS_DB['project1']['settings'], {'color': 'blue'})\n\n    def test_member_id_none_role_authorized(self):\n        \"\"\"Test None member_id with project_manager role is authorized.\"\"\"\n        with patch('solution.PROJECTS_DB', {\n            'project1': {'project_id': 'project1', 'creator_id': 'user1', 'members': ['user1', 'user2'], 'settings': {'color': 'blue'}}\n        }):\n            result = edit_project_settings(None, 'project_manager', 'project1', {'color': 'red'})\n            self.assertEqual(result, \"Project settings for project1 have been updated successfully\")\n\n    def test_member_id_none_role_unauthorized(self):\n        \"\"\"Test None member_id without project_manager role is unauthorized.\"\"\"\n        with patch('solution.PROJECTS_DB', {\n            'project1': {'project_id': 'project1', 'creator_id': 'user1', 'members': ['user1', 'user2'], 'settings': {'color': 'blue'}}\n        }):\n            with self.assertRaises(PermissionError):\n                edit_project_settings(None, 'team_member', 'project1', {'color': 'yellow'})\n\n    def test_empty_role_creator_authorized(self):\n        \"\"\"Test empty role but creator_id match allows update.\"\"\"\n        with patch('solution.PROJECTS_DB', {\n            'project1': {'project_id': 'project1', 'creator_id': 'user1', 'members': ['user1', 'user2'], 'settings': {'color': 'blue'}}\n        }):\n            result = edit_project_settings('user1', '', 'project1', {'color': 'orange'})\n            self.assertEqual(result, \"Project settings for project1 have been updated successfully\")\n\n    def test_empty_role_unauthorized(self):\n        \"\"\"Test empty role and not creator raises PermissionError.\"\"\"\n        with patch('solution.PROJECTS_DB', {\n            'project1': {'project_id': 'project1', 'creator_id': 'user1', 'members': ['user1', 'user2'], 'settings': {'color': 'blue'}}\n        }):\n            with self.assertRaises(PermissionError):\n                edit_project_settings('user2', '', 'project1', {'color': 'pink'})\n\n    def test_empty_project_key_exists(self):\n        \"\"\"Test updating project with empty string key that exists.\"\"\"\n        with patch('solution.PROJECTS_DB', {\n            '': {'project_id': '', 'creator_id': 'user1', 'members': ['user1'], 'settings': {'color': 'blue'}}\n        }):\n            result = edit_project_settings('user1', 'project_manager', '', {'color': 'red'})\n            self.assertEqual(result, \"Project settings for  have been updated successfully\")\n            self.assertEqual(solution.PROJECTS_DB['']['settings'], {'color': 'red'})\n\n    def test_large_updated_configuration(self):\n        \"\"\"Test updating with a large configuration dictionary.\"\"\"\n        large_config = {f'key{i}': f'value{i}' for i in range(1000)}\n        with patch('solution.PROJECTS_DB', {\n            'project1': {'project_id': 'project1', 'creator_id': 'user1', 'members': ['user1', 'user2'], 'settings': {'color': 'blue'}}\n        }):\n            result = edit_project_settings('user1', 'project_manager', 'project1', large_config)\n            self.assertEqual(result, \"Project settings for project1 have been updated successfully\")\n            self.assertEqual(solution.PROJECTS_DB['project1']['settings'], large_config)\n\n    def test_long_project_key_not_found(self):\n        \"\"\"Test long project key not in database raises ValueError.\"\"\"\n        long_key = 'a' * 1000\n        with patch('solution.PROJECTS_DB', {}):\n            with self.assertRaises(ValueError):\n                edit_project_settings('user1', 'project_manager', long_key, {'color': 'blue'})\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 12, "task_id": "d88e2918"}
{"test": "import unittest\\nfrom unittest.mock import patch\\nfrom solution import update_document\\n\\nclass TestUpdateDocument(unittest.TestCase):\\n\\n    def setUp(self):\\n        # Start patching 'solution.DOCUMENTS_DB' and initialize to empty dict\\n        self.patcher = patch('solution.DOCUMENTS_DB', {})\\n        self.mock_db = self.patcher.start()\\n\\n    def tearDown(self):\\n        # Stop patching after each test\\n        self.patcher.stop()\\n\\n    def test_editor_can_update(self):\\n        # Test editor role can update document\\n        self.mock_db['doc1'] = {'document_id': 'doc1', 'owner_id': 'owner1', 'content': 'original'}\\n        result = update_document('user1', 'editor', 'doc1', 'owner1', 'new content')\\n        self.assertEqual(result, 'new content')\\n        self.assertEqual(self.mock_db['doc1']['content'], 'new content')\\n\\n    def test_owner_can_update(self):\\n        # Test owner (with viewer role) can update document\\n        self.mock_db['doc1'] = {'document_id': 'doc1', 'owner_id': 'owner1', 'content': 'original'}\\n        result = update_document('owner1', 'viewer', 'doc1', 'owner1', 'new content')\\n        self.assertEqual(result, 'new content')\\n        self.assertEqual(self.mock_db['doc1']['content'], 'new content')\\n\\n    def test_unauthorized_non_owner_non_editor(self):\\n        # Test unauthorized: non-owner with non-editor role\\n        self.mock_db['doc1'] = {'document_id': 'doc1', 'owner_id': 'owner1', 'content': 'original'}\\n        with self.assertRaises(PermissionError):\\n            update_document('user1', 'viewer', 'doc1', 'owner1', 'new content')\\n\\n    def test_document_not_found(self):\\n        # Test document not found raises ValueError\\n        with self.assertRaises(ValueError):\\n            update_document('user1', 'editor', 'doc1', 'owner1', 'new content')\\n\\n    def test_update_to_empty_content(self):\\n        # Test updating content to empty string\\n        self.mock_db['doc1'] = {'document_id': 'doc1', 'owner_id': 'owner1', 'content': 'original'}\\n        result = update_document('owner1', 'viewer', 'doc1', 'owner1', '')\\n        self.assertEqual(result, '')\\n        self.assertEqual(self.mock_db['doc1']['content'], '')\\n\\n    def test_unauthorized_role_admin(self):\\n        # Test unauthorized: admin role without ownership\\n        self.mock_db['doc1'] = {'document_id': 'doc1', 'owner_id': 'owner1', 'content': 'original'}\\n        with self.assertRaises(PermissionError):\\n            update_document('user1', 'admin', 'doc1', 'owner1', 'new content')\\n\\n    def test_owner_with_editor_role_can_update(self):\\n        # Test owner with editor role can update\\n        self.mock_db['doc1'] = {'document_id': 'doc1', 'owner_id': 'owner1', 'content': 'original'}\\n        result = update_document('owner1', 'editor', 'doc1', 'owner1', 'new content')\\n        self.assertEqual(result, 'new content')\\n        self.assertEqual(self.mock_db['doc1']['content'], 'new content')", "num_test_cases": 7, "task_id": "b7381a9c"}
{"test": "import unittest\n\n# Global ACCOUNTS_DB will be set/reset in the test setup\nACCOUNTS_DB = {}\n\ndef transfer_funds(user_id: str, user_role: str, from_account: str, to_account: str, amount: float):\n    if from_account not in ACCOUNTS_DB or to_account not in ACCOUNTS_DB:\n        raise ValueError(\"One or both accounts do not exist\")\n    if ACCOUNTS_DB[from_account][\"balance\"] < amount:\n        raise ValueError(\"Insufficient funds\")\n    if user_role == \"bank_admin\" or (user_role == \"account_owner\" and user_id == ACCOUNTS_DB[from_account][\"owner_id\"]):\n        ACCOUNTS_DB[from_account][\"balance\"] -= amount\n        ACCOUNTS_DB[to_account][\"balance\"] += amount\n        return f\"Successfully transferred ${amount} from {from_account} to {to_account}\"\n    else:\n        raise PermissionError(\"Unauthorized access: You do not have permission to transfer funds from this account\")\n\nclass TestTransferFunds(unittest.TestCase):\n    def setUp(self):\n        global ACCOUNTS_DB\n        # Reset ACCOUNTS_DB to a predefined state before each test\n        ACCOUNTS_DB = {\n            \"acc1\": {\"account_number\": \"acc1\", \"owner_id\": \"user1\", \"balance\": 1000.0},\n            \"acc2\": {\"account_number\": \"acc2\", \"owner_id\": \"user2\", \"balance\": 500.0},\n            \"acc3\": {\"account_number\": \"acc3\", \"owner_id\": \"user3\", \"balance\": 0.0},\n            \"acc4\": {\"account_number\": \"acc4\", \"owner_id\": \"user1\", \"balance\": 200.0}\n        }\n\n    def test_account_owner_success(self):\n        # Test account_owner can transfer from their own account\n        result = transfer_funds(\"user1\", \"account_owner\", \"acc1\", \"acc2\", 100.0)\n        self.assertEqual(result, \"Successfully transferred $100.0 from acc1 to acc2\")\n        self.assertEqual(ACCOUNTS_DB[\"acc1\"][\"balance\"], 900.0)\n        self.assertEqual(ACCOUNTS_DB[\"acc2\"][\"balance\"], 600.0)\n\n    def test_bank_admin_success(self):\n        # Test bank_admin can transfer from any account\n        result = transfer_funds(\"admin\", \"bank_admin\", \"acc1\", \"acc2\", 100.0)\n        self.assertEqual(result, \"Successfully transferred $100.0 from acc1 to acc2\")\n        self.assertEqual(ACCOUNTS_DB[\"acc1\"][\"balance\"], 900.0)\n        self.assertEqual(ACCOUNTS_DB[\"acc2\"][\"balance\"], 600.0)\n\n    def test_zero_amount_transfer(self):\n        # Test transferring zero amount (edge case)\n        result = transfer_funds(\"user1\", \"account_owner\", \"acc1\", \"acc2\", 0.0)\n        self.assertEqual(result, \"Successfully transferred $0.0 from acc1 to acc2\")\n        self.assertEqual(ACCOUNTS_DB[\"acc1\"][\"balance\"], 1000.0)\n        self.assertEqual(ACCOUNTS_DB[\"acc2\"][\"balance\"], 500.0)\n\n    def test_full_balance_transfer(self):\n        # Test transferring the entire balance (edge case)\n        result = transfer_funds(\"user1\", \"account_owner\", \"acc1\", \"acc3\", 1000.0)\n        self.assertEqual(result, \"Successfully transferred $1000.0 from acc1 to acc3\")\n        self.assertEqual(ACCOUNTS_DB[\"acc1\"][\"balance\"], 0.0)\n        self.assertEqual(ACCOUNTS_DB[\"acc3\"][\"balance\"], 1000.0)\n\n    def test_from_account_not_exist(self):\n        # Test non-existent from_account\n        with self.assertRaises(ValueError) as context:\n            transfer_funds(\"user1\", \"account_owner\", \"invalid_acc\", \"acc2\", 100.0)\n        self.assertEqual(str(context.exception), \"One or both accounts do not exist\")\n\n    def test_to_account_not_exist(self):\n        # Test non-existent to_account\n        with self.assertRaises(ValueError) as context:\n            transfer_funds(\"user1\", \"account_owner\", \"acc1\", \"invalid_acc\", 100.0)\n        self.assertEqual(str(context.exception), \"One or both accounts do not exist\")\n\n    def test_insufficient_funds(self):\n        # Test insufficient funds in from_account\n        with self.assertRaises(ValueError) as context:\n            transfer_funds(\"user1\", \"account_owner\", \"acc4\", \"acc1\", 300.0)\n        self.assertEqual(str(context.exception), \"Insufficient funds\")\n\n    def test_unauthorized_customer_service(self):\n        # Test customer_service role is unauthorized\n        with self.assertRaises(PermissionError) as context:\n            transfer_funds(\"cs_user\", \"customer_service\", \"acc1\", \"acc2\", 100.0)\n        self.assertEqual(str(context.exception), \"Unauthorized access: You do not have permission to transfer funds from this account\")\n\n    def test_unauthorized_account_owner(self):\n        # Test account_owner trying to transfer from another user's account\n        with self.assertRaises(PermissionError) as context:\n            transfer_funds(\"user2\", \"account_owner\", \"acc1\", \"acc2\", 100.0)\n        self.assertEqual(str(context.exception), \"Unauthorized access: You do not have permission to transfer funds from this account\")\n\n    def test_large_amount_transfer(self):\n        # Test transferring a very large amount (edge case)\n        ACCOUNTS_DB[\"acc1\"][\"balance\"] = 1e18  # Very large balance\n        result = transfer_funds(\"user1\", \"account_owner\", \"acc1\", \"acc2\", 1e18)\n        self.assertEqual(result, \"Successfully transferred $1e+18 from acc1 to acc2\")\n        self.assertEqual(ACCOUNTS_DB[\"acc1\"][\"balance\"], 0.0)\n        self.assertEqual(ACCOUNTS_DB[\"acc2\"][\"balance\"], 500.0 + 1e18)\n\n    def test_negative_amount(self):\n        # Test negative amount (should be handled as reverse transfer?)\n        # Note: Function does not explicitly block negative amounts\n        result = transfer_funds(\"user1\", \"account_owner\", \"acc1\", \"acc4\", -100.0)\n        self.assertEqual(result, \"Successfully transferred $-100.0 from acc1 to acc4\")\n        # Balances: acc1 increases by 100, acc4 decreases by 100\n        self.assertEqual(ACCOUNTS_DB[\"acc1\"][\"balance\"], 1100.0)\n        self.assertEqual(ACCOUNTS_DB[\"acc4\"][\"balance\"], 100.0)\n\n    def test_same_account_transfer(self):\n        # Test transferring to the same account\n        result = transfer_funds(\"user1\", \"account_owner\", \"acc1\", \"acc1\", 100.0)\n        self.assertEqual(result, \"Successfully transferred $100.0 from acc1 to acc1\")\n        self.assertEqual(ACCOUNTS_DB[\"acc1\"][\"balance\"], 1000.0)  # Net zero change\n\n    def test_account_owner_multiple_accounts(self):\n        # Test account_owner transferring between their own accounts\n        result = transfer_funds(\"user1\", \"account_owner\", \"acc1\", \"acc4\", 100.0)\n        self.assertEqual(result, \"Successfully transferred $100.0 from acc1 to acc4\")\n        self.assertEqual(ACCOUNTS_DB[\"acc1\"][\"balance\"], 900.0)\n        self.assertEqual(ACCOUNTS_DB[\"acc4\"][\"balance\"], 300.0)", "num_test_cases": 13, "task_id": "2d314150"}
{"test": "import unittest\nfrom unittest.mock import patch\n\nclass TestAccessPatientRecord(unittest.TestCase):\n    base_records = {\n        \"patient1\": {\n            \"patient_id\": \"patient1\",\n            \"assigned_staff\": [\"doc1\", \"nurse1\"],\n            \"medical_data\": \"Medical data for patient1\"\n        },\n        \"patient2\": {\n            \"patient_id\": \"patient2\",\n            \"assigned_staff\": [\"doc2\"],\n            \"medical_data\": \"Medical data for patient2\"\n        },\n        \"patient3\": {\n            \"patient_id\": \"patient3\",\n            \"assigned_staff\": [],\n            \"medical_data\": \"Medical data for patient3\"\n        }\n    }\n\n    @classmethod\n    def setUpClass(cls):\n        cls.patcher = patch('__main__.PATIENT_RECORDS', cls.base_records)\n        cls.patcher.start()\n\n    @classmethod\n    def tearDownClass(cls):\n        cls.patcher.stop()\n\n    def test_admin_access_patient1(self):\n        # Admin can access any patient record\n        result = access_patient_record(\"admin_user\", \"admin\", \"patient1\")\n        self.assertEqual(result, \"Medical data for patient1\")\n\n    def test_doctor_assigned_access(self):\n        # Doctor assigned to patient can access\n        result = access_patient_record(\"doc1\", \"doctor\", \"patient1\")\n        self.assertEqual(result, \"Medical data for patient1\")\n\n    def test_nurse_assigned_access(self):\n        # Nurse assigned to patient can access\n        result = access_patient_record(\"nurse1\", \"nurse\", \"patient1\")\n        self.assertEqual(result, \"Medical data for patient1\")\n\n    def test_doctor_not_assigned(self):\n        # Doctor not assigned to patient cannot access\n        with self.assertRaises(PermissionError):\n            access_patient_record(\"doc2\", \"doctor\", \"patient1\")\n\n    def test_nurse_not_assigned(self):\n        # Nurse not assigned to patient cannot access\n        with self.assertRaises(PermissionError):\n            access_patient_record(\"nurse2\", \"nurse\", \"patient1\")\n\n    def test_receptionist_denied(self):\n        # Receptionist role is denied access\n        with self.assertRaises(PermissionError):\n            access_patient_record(\"reception1\", \"receptionist\", \"patient1\")\n\n    def test_doctor_empty_staff_list(self):\n        # Doctor cannot access if not in empty assigned_staff\n        with self.assertRaises(PermissionError):\n            access_patient_record(\"doc1\", \"doctor\", \"patient3\")\n\n    def test_admin_empty_staff_list(self):\n        # Admin can access record with empty assigned_staff\n        result = access_patient_record(\"admin_user\", \"admin\", \"patient3\")\n        self.assertEqual(result, \"Medical data for patient3\")\n\n    def test_nonexistent_patient(self):\n        # Non-existent patient raises ValueError\n        with self.assertRaises(ValueError):\n            access_patient_record(\"admin_user\", \"admin\", \"patient4\")\n\n    def test_admin_nonexistent_patient(self):\n        # Admin cannot access non-existent patient (existence checked first)\n        with self.assertRaises(ValueError):\n            access_patient_record(\"admin_user\", \"admin\", \"invalid_id\")\n\n    def test_unassigned_nurse_empty_list(self):\n        # Nurse not in empty assigned_staff list is denied\n        with self.assertRaises(PermissionError):\n            access_patient_record(\"nurse1\", \"nurse\", \"patient3\")\n\n# Global PATIENT_RECORDS simulation for test environment\nPATIENT_RECORDS = {}\n\ndef access_patient_record(user_id: str, user_role: str, patient_id: str):\n    if patient_id not in PATIENT_RECORDS:\n        raise ValueError(\"Patient record not found\")\n    if user_role == \"admin\" or (user_role in [\"doctor\", \"nurse\"] and user_id in PATIENT_RECORDS[patient_id][\"assigned_staff\"]):\n        return PATIENT_RECORDS[patient_id][\"medical_data\"]\n    else:\n        raise PermissionError(\"Unauthorized access: You do not have permission to access this patient's record\")\n\nif __name__ == \"__main__\":\n    unittest.main()", "num_test_cases": 11, "task_id": "39513254"}
{"test": "import unittest\nfrom unittest.mock import patch\nfrom solution import modify_project_settings\n\nclass TestModifyProjectSettings(unittest.TestCase):\n\n    def test_project_manager_authorized(self):\n        # Test project manager (not creator) can update settings\n        test_db = {\n            'project1': {\n                'project_id': 'project1',\n                'creator_id': 'user1',\n                'members': ['user1', 'user2'],\n                'settings': {'theme': 'light'}\n            }\n        }\n        with patch('solution.PROJECTS_DB', test_db):\n            result = modify_project_settings('user2', 'project_manager', 'project1', {'theme': 'dark'})\n            self.assertEqual(result, 'Project settings for project1 have been updated successfully')\n            self.assertEqual(test_db['project1']['settings'], {'theme': 'dark'})\n\n    def test_creator_authorized_with_team_member_role(self):\n        # Test creator can update settings even with 'team_member' role\n        test_db = {\n            'project1': {\n                'project_id': 'project1',\n                'creator_id': 'user1',\n                'members': ['user1', 'user2'],\n                'settings': {'theme': 'light'}\n            }\n        }\n        with patch('solution.PROJECTS_DB', test_db):\n            result = modify_project_settings('user1', 'team_member', 'project1', {'theme': 'dark'})\n            self.assertEqual(result, 'Project settings for project1 have been updated successfully')\n            self.assertEqual(test_db['project1']['settings'], {'theme': 'dark'})\n\n    def test_creator_authorized_with_viewer_role(self):\n        # Test creator can update settings even with 'viewer' role\n        test_db = {\n            'project1': {\n                'project_id': 'project1',\n                'creator_id': 'user1',\n                'members': ['user1', 'user2'],\n                'settings': {'theme': 'light'}\n            }\n        }\n        with patch('solution.PROJECTS_DB', test_db):\n            result = modify_project_settings('user1', 'viewer', 'project1', {'theme': 'dark'})\n            self.assertEqual(result, 'Project settings for project1 have been updated successfully')\n            self.assertEqual(test_db['project1']['settings'], {'theme': 'dark'})\n\n    def test_unauthorized_user(self):\n        # Test non-manager/non-creator cannot update settings\n        test_db = {\n            'project1': {\n                'project_id': 'project1',\n                'creator_id': 'user1',\n                'members': ['user1', 'user2'],\n                'settings': {'theme': 'light'}\n            }\n        }\n        with patch('solution.PROJECTS_DB', test_db):\n            with self.assertRaises(PermissionError):\n                modify_project_settings('user3', 'team_member', 'project1', {'theme': 'dark'})\n\n    def test_project_not_found(self):\n        # Test error when project does not exist\n        test_db = {}\n        with patch('solution.PROJECTS_DB', test_db):\n            with self.assertRaises(ValueError):\n                modify_project_settings('user1', 'project_manager', 'project1', {'theme': 'dark'})\n\n    def test_update_with_empty_settings(self):\n        # Test updating with empty settings dictionary\n        test_db = {\n            'project1': {\n                'project_id': 'project1',\n                'creator_id': 'user1',\n                'members': ['user1', 'user2'],\n                'settings': {'theme': 'light'}\n            }\n        }\n        with patch('solution.PROJECTS_DB', test_db):\n            result = modify_project_settings('user1', 'project_manager', 'project1', {})\n            self.assertEqual(result, 'Project settings for project1 have been updated successfully')\n            self.assertEqual(test_db['project1']['settings'], {'theme': 'light'})\n\n    def test_update_multiple_settings(self):\n        # Test updating multiple settings at once\n        test_db = {\n            'project1': {\n                'project_id': 'project1',\n                'creator_id': 'user1',\n                'members': ['user1', 'user2'],\n                'settings': {'theme': 'light', 'lang': 'en'}\n            }\n        }\n        with patch('solution.PROJECTS_DB', test_db):\n            new_settings = {'theme': 'dark', 'notifications': 'on', 'lang': 'fr'}\n            result = modify_project_settings('user1', 'project_manager', 'project1', new_settings)\n            self.assertEqual(result, 'Project settings for project1 have been updated successfully')\n            self.assertEqual(test_db['project1']['settings'], {'theme': 'dark', 'lang': 'fr', 'notifications': 'on'})\n\n    def test_project_manager_and_creator(self):\n        # Test creator with project_manager role can update\n        test_db = {\n            'project1': {\n                'project_id': 'project1',\n                'creator_id': 'user1',\n                'members': ['user1', 'user2'],\n                'settings': {'theme': 'light'}\n            }\n        }\n        with patch('solution.PROJECTS_DB', test_db):\n            result = modify_project_settings('user1', 'project_manager', 'project1', {'theme': 'dark'})\n            self.assertEqual(result, 'Project settings for project1 have been updated successfully')\n            self.assertEqual(test_db['project1']['settings'], {'theme': 'dark'})\n\n    def test_large_settings_update(self):\n        # Test updating with a large number of settings\n        test_db = {\n            'project1': {\n                'project_id': 'project1',\n                'creator_id': 'user1',\n                'members': ['user1', 'user2'],\n                'settings': {}\n            }\n        }\n        large_settings = {f'key{i}': f'value{i}' for i in range(1000)}\n        with patch('solution.PROJECTS_DB', test_db):\n            result = modify_project_settings('user1', 'project_manager', 'project1', large_settings)\n            self.assertEqual(result, 'Project settings for project1 have been updated successfully')\n            self.assertEqual(test_db['project1']['settings'], large_settings)\n\n    def test_invalid_user_id_type(self):\n        # Test invalid user_id type\n        test_db = {\n            'project1': {\n                'project_id': 'project1',\n                'creator_id': 'user1',\n                'members': ['user1', 'user2'],\n                'settings': {}\n            }\n        }\n        with patch('solution.PROJECTS_DB', test_db):\n            with self.assertRaises(TypeError):\n                modify_project_settings(123, 'project_manager', 'project1', {})\n\n    def test_invalid_project_id_type(self):\n        # Test invalid project_id type\n        test_db = {\n            'project1': {\n                'project_id': 'project1',\n                'creator_id': 'user1',\n                'members': ['user1', 'user2'],\n                'settings': {}\n            }\n        }\n        with patch('solution.PROJECTS_DB', test_db):\n            with self.assertRaises(TypeError):\n                modify_project_settings('user1', 'project_manager', 123, {})\n\n    def test_none_user_role(self):\n        # Test None user_role\n        test_db = {\n            'project1': {\n                'project_id': 'project1',\n                'creator_id': 'user1',\n                'members': ['user1', 'user2'],\n                'settings': {}\n            }\n        }\n        with patch('solution.PROJECTS_DB', test_db):\n            with self.assertRaises(TypeError):\n                modify_project_settings('user1', None, 'project1', {})\n\n    def test_empty_project_id(self):\n        # Test empty project_id\n        test_db = {}\n        with patch('solution.PROJECTS_DB', test_db):\n            with self.assertRaises(ValueError):\n                modify_project_settings('user1', 'project_manager', '', {})\n\n    def test_none_new_settings(self):\n        # Test None new_settings\n        test_db = {\n            'project1': {\n                'project_id': 'project1',\n                'creator_id': 'user1',\n                'members': ['user1', 'user2'],\n                'settings': {}\n            }\n        }\n        with patch('solution.PROJECTS_DB', test_db):\n            with self.assertRaises(TypeError):\n                modify_project_settings('user1', 'project_manager', 'project1', None)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 15, "task_id": "6260be28"}
{"test": "import unittest\nfrom unittest.mock import patch\n\nclass TestViewOrder(unittest.TestCase):\n\n    def test_admin_access(self):\n        # Test admin can view any order\n        test_db = {'order1': {'user_id': 'user1', 'details': 'details1'}}\n        with patch('order_system.ORDERS_DB', test_db):\n            result = view_order('admin1', 'admin', 'order1', 'user1')\n            self.assertEqual(result, 'details1')\n\n    def test_customer_own_order(self):\n        # Test customer can view their own order\n        test_db = {'order1': {'user_id': 'user1', 'details': 'details1'}}\n        with patch('order_system.ORDERS_DB', test_db):\n            result = view_order('user1', 'customer', 'order1', 'user1')\n            self.assertEqual(result, 'details1')\n\n    def test_customer_others_order(self):\n        # Test customer cannot view another customer's order\n        test_db = {'order1': {'user_id': 'user1', 'details': 'details1'}}\n        with patch('order_system.ORDERS_DB', test_db):\n            with self.assertRaises(PermissionError):\n                view_order('user2', 'customer', 'order1', 'user1')\n\n    def test_order_not_found(self):\n        # Test non-existent order raises ValueError\n        test_db = {}\n        with patch('order_system.ORDERS_DB', test_db):\n            with self.assertRaises(ValueError):\n                view_order('admin1', 'admin', 'order1', 'user1')\n\n    def test_order_id_none(self):\n        # Test None order_id raises ValueError\n        test_db = {'order1': {'user_id': 'user1', 'details': 'details1'}}\n        with patch('order_system.ORDERS_DB', test_db):\n            with self.assertRaises(ValueError):\n                view_order('admin1', 'admin', None, 'user1')\n\n    def test_user_id_none_unauthorized(self):\n        # Test None user_id (customer) raises PermissionError\n        test_db = {'order1': {'user_id': 'user1', 'details': 'details1'}}\n        with patch('order_system.ORDERS_DB', test_db):\n            with self.assertRaises(PermissionError):\n                view_order(None, 'customer', 'order1', 'user1')\n\n    def test_user_role_none_unauthorized(self):\n        # Test None user_role and mismatched user_id raises PermissionError\n        test_db = {'order1': {'user_id': 'user1', 'details': 'details1'}}\n        with patch('order_system.ORDERS_DB', test_db):\n            with self.assertRaises(PermissionError):\n                view_order('user1', None, 'order1', 'user2')\n\n    def test_very_long_order_id_exists(self):\n        # Test very long order_id that exists\n        long_id = 'A' * 1000\n        test_db = {long_id: {'user_id': 'user1', 'details': 'long_details'}}\n        with patch('order_system.ORDERS_DB', test_db):\n            result = view_order('admin1', 'admin', long_id, 'user1')\n            self.assertEqual(result, 'long_details')\n\n    def test_very_long_order_id_not_exists(self):\n        # Test very long order_id that does not exist\n        long_id = 'A' * 1000\n        test_db = {}\n        with patch('order_system.ORDERS_DB', test_db):\n            with self.assertRaises(ValueError):\n                view_order('admin1', 'admin', long_id, 'user1')\n\n    def test_empty_string_order_id_exists(self):\n        # Test empty string order_id that exists\n        test_db = {'': {'user_id': 'user1', 'details': 'empty_details'}}\n        with patch('order_system.ORDERS_DB', test_db):\n            result = view_order('admin1', 'admin', '', 'user1')\n            self.assertEqual(result, 'empty_details')\n\n    def test_empty_string_order_id_not_exists(self):\n        # Test empty string order_id that does not exist\n        test_db = {'order1': {'user_id': 'user1', 'details': 'details1'}}\n        with patch('order_system.ORDERS_DB', test_db):\n            with self.assertRaises(ValueError):\n                view_order('admin1', 'admin', '', 'user1')\n\n    def test_empty_string_user_id_unauthorized(self):\n        # Test empty user_id (customer) raises PermissionError\n        test_db = {'order1': {'user_id': 'user1', 'details': 'details1'}}\n        with patch('order_system.ORDERS_DB', test_db):\n            with self.assertRaises(PermissionError):\n                view_order('', 'customer', 'order1', 'user1')\n\n    def test_empty_string_user_role_authorized(self):\n        # Test empty user_role but user_id matches\n        test_db = {'order1': {'user_id': 'user1', 'details': 'details1'}}\n        with patch('order_system.ORDERS_DB', test_db):\n            result = view_order('user1', '', 'order1', 'user1')\n            self.assertEqual(result, 'details1')\n\n    def test_empty_string_user_role_unauthorized(self):\n        # Test empty user_role and mismatched user_id raises PermissionError\n        test_db = {'order1': {'user_id': 'user1', 'details': 'details1'}}\n        with patch('order_system.ORDERS_DB', test_db):\n            with self.assertRaises(PermissionError):\n                view_order('user1', '', 'order1', 'user2')\n\n    def test_order_user_id_none_admin(self):\n        # Test None order_user_id with admin\n        test_db = {'order1': {'user_id': 'user1', 'details': 'details1'}}\n        with patch('order_system.ORDERS_DB', test_db):\n            result = view_order('admin1', 'admin', 'order1', None)\n            self.assertEqual(result, 'details1')\n\n    def test_order_user_id_none_customer_authorized(self):\n        # Test None order_user_id with customer (user_id None)\n        test_db = {'order1': {'user_id': 'user1', 'details': 'details1'}}\n        with patch('order_system.ORDERS_DB', test_db):\n            result = view_order(None, 'customer', 'order1', None)\n            self.assertEqual(result, 'details1')\n\n    def test_order_user_id_none_customer_unauthorized(self):\n        # Test None order_user_id with customer (user_id string)\n        test_db = {'order1': {'user_id': 'user1', 'details': 'details1'}}\n        with patch('order_system.ORDERS_DB', test_db):\n            with self.assertRaises(PermissionError):\n                view_order('user1', 'customer', 'order1', None)\n", "num_test_cases": 17, "task_id": "dfa79d38"}
{"test": "import unittest\n\n# Define the global PERMITTED_FIELDS as specified\nPERMITTED_FIELDS = ['price', 'description', 'stock']\n\nclass TestEditProductInfo(unittest.TestCase):\n    \n    def test_case_1(self):\n        # Test updating one permitted and one non-permitted field\n        item = {'price': 100, 'stock': 50, 'category': 'electronics'}\n        details = {'price': 150, 'category': 'home appliances'}\n        result = edit_product_info(item, details)\n        self.assertEqual(result, {'price': 150, 'stock': 50, 'category': 'electronics'})\n    \n    def test_case_2(self):\n        # Test updating multiple permitted fields\n        item = {'price': 100, 'description': 'Old', 'stock': 50}\n        details = {'price': 200, 'description': 'New', 'stock': 100}\n        result = edit_product_info(item, details)\n        self.assertEqual(result, {'price': 200, 'description': 'New', 'stock': 100})\n    \n    def test_case_3(self):\n        # Test updating a non-permitted field (should not change)\n        item = {'price': 100, 'category': 'electronics'}\n        details = {'category': 'home appliances'}\n        result = edit_product_info(item, details)\n        self.assertEqual(result, {'price': 100, 'category': 'electronics'})\n    \n    def test_case_4(self):\n        # Test empty details dictionary (no changes)\n        item = {'price': 100, 'description': 'Test'}\n        details = {}\n        result = edit_product_info(item, details)\n        self.assertEqual(result, {'price': 100, 'description': 'Test'})\n    \n    def test_case_5(self):\n        # Test adding a new permitted field (not in original item)\n        item = {'price': 100}\n        details = {'description': 'New product'}\n        result = edit_product_info(item, details)\n        self.assertEqual(result, {'price': 100, 'description': 'New product'})\n    \n    def test_case_6(self):\n        # Test adding a new non-permitted field (should not add)\n        item = {'price': 100}\n        details = {'category': 'electronics'}\n        result = edit_product_info(item, details)\n        self.assertEqual(result, {'price': 100})\n    \n    def test_case_7(self):\n        # Test updating a permitted field to None\n        item = {'description': 'Old description', 'price': 100}\n        details = {'description': None}\n        result = edit_product_info(item, details)\n        self.assertEqual(result, {'description': None, 'price': 100})\n    \n    def test_case_8(self):\n        # Test updating a permitted field with a non-string value\n        item = {'description': 'Text', 'price': 100}\n        details = {'description': 12345}\n        result = edit_product_info(item, details)\n        self.assertEqual(result, {'description': 12345, 'price': 100})\n    \n    def test_case_9(self):\n        # Test with empty PERMITTED_FIELDS (no updates should occur)\n        global PERMITTED_FIELDS\n        original_permitted = PERMITTED_FIELDS\n        PERMITTED_FIELDS = []\n        try:\n            item = {'price': 100, 'description': 'Test'}\n            details = {'price': 200, 'description': 'Updated'}\n            result = edit_product_info(item, details)\n            self.assertEqual(result, {'price': 100, 'description': 'Test'})\n        finally:\n            PERMITTED_FIELDS = original_permitted\n    \n    def test_case_10(self):\n        # Test adding to an empty item with a permitted field\n        item = {}\n        details = {'price': 99}\n        result = edit_product_info(item, details)\n        self.assertEqual(result, {'price': 99})\n    \n    def test_case_11(self):\n        # Test item as None (should raise AttributeError)\n        with self.assertRaises(AttributeError):\n            edit_product_info(None, {'price': 100})\n    \n    def test_case_12(self):\n        # Test details as None (should raise AttributeError)\n        with self.assertRaises(AttributeError):\n            edit_product_info({'price': 100}, None)\n    \n    def test_case_13(self):\n        # Test details as integer (should raise AttributeError)\n        with self.assertRaises(AttributeError):\n            edit_product_info({'price': 100}, 123)\n    \n    def test_case_14(self):\n        # Test returned object is same as input item (in-place update)\n        item = {'price': 100}\n        details = {'price': 200}\n        result = edit_product_info(item, details)\n        self.assertIs(item, result)\n    \n    def test_case_15(self):\n        # Test with a different PERMITTED_FIELDS configuration\n        global PERMITTED_FIELDS\n        original_permitted = PERMITTED_FIELDS\n        PERMITTED_FIELDS = ['category', 'name']\n        try:\n            item = {'name': 'Old', 'category': 'old_cat'}\n            details = {'name': 'New', 'category': 'new_cat', 'price': 100}\n            result = edit_product_info(item, details)\n            self.assertEqual(result, {'name': 'New', 'category': 'new_cat'})\n        finally:\n            PERMITTED_FIELDS = original_permitted\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 15, "task_id": "061269d1"}
{"test": "import unittest\n\n# Define the global PERMITTED_FIELDS required by the function\nPERMITTED_FIELDS = ['price', 'description', 'stock']\n\nclass TestModifyProductData(unittest.TestCase):\n    \n    def test_update_existing_permitted_field(self):\n        # Test updating an existing permitted field\n        product = {'name': 'T-shirt', 'price': 20.0, 'stock': 100}\n        update = {'price': 25.0}\n        result = modify_product_data(product, update)\n        self.assertEqual(result['price'], 25.0)\n        self.assertEqual(result['name'], 'T-shirt')  # Other fields unchanged\n\n    def test_update_multiple_permitted_fields(self):\n        # Test updating multiple existing permitted fields\n        product = {'name': 'T-shirt', 'price': 20.0, 'description': 'Comfortable', 'stock': 100}\n        update = {'price': 25.0, 'description': 'New description'}\n        result = modify_product_data(product, update)\n        self.assertEqual(result['price'], 25.0)\n        self.assertEqual(result['description'], 'New description')\n        self.assertEqual(result['stock'], 100)\n\n    def test_non_permitted_field_ignored(self):\n        # Test that non-permitted fields are ignored\n        product = {'name': 'T-shirt', 'price': 20.0}\n        update = {'name': 'New Name', 'price': 25.0}\n        result = modify_product_data(product, update)\n        self.assertEqual(result['name'], 'T-shirt')  # Not permitted, unchanged\n        self.assertEqual(result['price'], 25.0)      # Permitted, updated\n\n    def test_mixed_permitted_and_non_permitted(self):\n        # Test update with mix of permitted and non-permitted fields\n        product = {'name': 'T-shirt', 'price': 20.0, 'stock': 100}\n        update = {'name': 'New Name', 'price': 25.0, 'category': 'Clothing'}\n        result = modify_product_data(product, update)\n        self.assertEqual(result['name'], 'T-shirt')      # Unchanged\n        self.assertEqual(result['price'], 25.0)          # Updated\n        self.assertNotIn('category', result)             # Not added\n        self.assertEqual(result['stock'], 100)           # Unchanged\n\n    def test_empty_update_info(self):\n        # Test empty update_info does nothing\n        product = {'name': 'T-shirt', 'price': 20.0}\n        update = {}\n        result = modify_product_data(product, update)\n        self.assertEqual(result, product)\n\n    def test_add_new_permitted_field(self):\n        # Test adding a new permitted field not in original product\n        product = {'name': 'T-shirt', 'price': 20.0}\n        update = {'stock': 50}  # stock is permitted\n        result = modify_product_data(product, update)\n        self.assertEqual(result['stock'], 50)\n        self.assertEqual(result['price'], 20.0)\n\n    def test_add_non_permitted_field_ignored(self):\n        # Test adding a non-permitted field is ignored\n        product = {'name': 'T-shirt', 'price': 20.0}\n        update = {'category': 'Clothing'}  # Not permitted\n        result = modify_product_data(product, update)\n        self.assertNotIn('category', result)\n        self.assertEqual(result, product)\n\n    def test_update_permitted_field_to_none(self):\n        # Test updating permitted field to None\n        product = {'name': 'T-shirt', 'price': 20.0}\n        update = {'price': None}\n        result = modify_product_data(product, update)\n        self.assertIsNone(result['price'])\n\n    def test_update_permitted_field_to_empty_string(self):\n        # Test updating permitted field to empty string\n        product = {'description': 'Comfortable'}\n        update = {'description': ''}\n        result = modify_product_data(product, update)\n        self.assertEqual(result['description'], '')\n\n    def test_update_permitted_field_large_value(self):\n        # Test updating permitted field with large value\n        large_value = 'A' * 10000\n        product = {'description': 'Original'}\n        update = {'description': large_value}\n        result = modify_product_data(product, update)\n        self.assertEqual(result['description'], large_value)\n\n    def test_product_details_none(self):\n        # Test TypeError when product_details is None\n        with self.assertRaises(TypeError):\n            modify_product_data(None, {'price': 20.0})\n\n    def test_update_info_none(self):\n        # Test TypeError when update_info is None\n        product = {'price': 20.0}\n        with self.assertRaises(TypeError):\n            modify_product_data(product, None)\n\n    def test_product_details_non_dict(self):\n        # Test TypeError when product_details is not a dict\n        with self.assertRaises(TypeError):\n            modify_product_data('not a dict', {'price': 20.0})\n\n    def test_update_info_non_dict(self):\n        # Test TypeError when update_info is not a dict\n        product = {'price': 20.0}\n        with self.assertRaises(TypeError):\n            modify_product_data(product, 'not a dict')\n\n    def test_update_permitted_field_different_type(self):\n        # Test updating permitted field with different value type\n        product = {'price': 20.0}\n        update = {'price': 'twenty'}\n        result = modify_product_data(product, update)\n        self.assertEqual(result['price'], 'twenty')\n\n    def test_empty_permitted_fields(self):\n        # Test no updates occur when PERMITTED_FIELDS is empty\n        global PERMITTED_FIELDS\n        original_fields = PERMITTED_FIELDS\n        try:\n            PERMITTED_FIELDS = []\n            product = {'price': 20.0, 'stock': 100}\n            update = {'price': 25.0, 'stock': 50}\n            result = modify_product_data(product, update)\n            self.assertEqual(result, product)  # No changes\n        finally:\n            PERMITTED_FIELDS = original_fields\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 16, "task_id": "ba578a28"}
{"test": "import unittest\n\nPERMITTED_FIELDS = ['price', 'description', 'stock', 'category']\n\nclass TestUpdateItemDetails(unittest.TestCase):\n    def test_update_single_permitted_field(self):\n        # Test updating one permitted field changes only that field\n        inventory = {'price': 10.0, 'description': 'Original', 'stock': 5}\n        update_data = {'price': 15.0}\n        updated = update_item_details(inventory, update_data)\n        self.assertEqual(updated['price'], 15.0)\n        self.assertEqual(updated['description'], 'Original')\n        self.assertEqual(updated['stock'], 5)\n\n    def test_update_multiple_permitted_fields(self):\n        # Test updating multiple permitted fields changes all specified fields\n        inventory = {'price': 10.0, 'description': 'Original', 'stock': 5}\n        update_data = {'price': 15.0, 'description': 'New', 'stock': 10}\n        updated = update_item_details(inventory, update_data)\n        self.assertEqual(updated['price'], 15.0)\n        self.assertEqual(updated['description'], 'New')\n        self.assertEqual(updated['stock'], 10)\n\n    def test_ignore_non_permitted_field(self):\n        # Test non-permitted fields in update_data are ignored\n        inventory = {'price': 10.0, 'description': 'Original'}\n        update_data = {'color': 'blue'}\n        updated = update_item_details(inventory, update_data)\n        self.assertNotIn('color', updated)\n        self.assertEqual(updated['price'], 10.0)\n        self.assertEqual(updated['description'], 'Original')\n\n    def test_mixed_permitted_and_non_permitted(self):\n        # Test update with mix of permitted/non-permitted fields\n        inventory = {'price': 10.0, 'description': 'Original', 'stock': 5}\n        update_data = {'price': 20.0, 'weight': 100, 'category': 'Electronics'}\n        updated = update_item_details(inventory, update_data)\n        self.assertEqual(updated['price'], 20.0)\n        self.assertEqual(updated['category'], 'Electronics')\n        self.assertNotIn('weight', updated)\n        self.assertEqual(updated['description'], 'Original')\n\n    def test_update_empty_inventory(self):\n        # Test updating an empty inventory adds permitted fields\n        inventory = {}\n        update_data = {'price': 25.0, 'description': 'New item'}\n        updated = update_item_details(inventory, update_data)\n        self.assertEqual(updated['price'], 25.0)\n        self.assertEqual(updated['description'], 'New item')\n\n    def test_empty_update_data(self):\n        # Test empty update_data leaves inventory unchanged\n        inventory = {'price': 10.0, 'description': 'Original'}\n        update_data = {}\n        updated = update_item_details(inventory, update_data)\n        self.assertEqual(updated, inventory)\n\n    def test_add_new_permitted_field(self):\n        # Test adding a new permitted field not in inventory\n        inventory = {'price': 10.0}\n        update_data = {'stock': 50}\n        updated = update_item_details(inventory, update_data)\n        self.assertEqual(updated['price'], 10.0)\n        self.assertEqual(updated['stock'], 50)\n\n    def test_ignore_update_to_existing_non_permitted(self):\n        # Test update to existing non-permitted field is ignored\n        inventory = {'price': 10.0, 'weight': 200}\n        update_data = {'weight': 250, 'price': 15.0}\n        updated = update_item_details(inventory, update_data)\n        self.assertEqual(updated['price'], 15.0)\n        self.assertEqual(updated['weight'], 200)  # unchanged\n\n    def test_update_with_none_value(self):\n        # Test setting a permitted field to None\n        inventory = {'price': 10.0, 'description': 'Original'}\n        update_data = {'description': None}\n        updated = update_item_details(inventory, update_data)\n        self.assertIsNone(updated['description'])\n        self.assertEqual(updated['price'], 10.0)\n\n    def test_non_string_key_in_update_data(self):\n        # Test non-string keys in update_data are ignored\n        inventory = {'price': 10.0}\n        update_data = {123: 'test', 'price': 20.0}\n        updated = update_item_details(inventory, update_data)\n        self.assertEqual(updated['price'], 20.0)\n        self.assertNotIn(123, updated)\n\n    def test_inventory_none(self):\n        # Test TypeError when inventory is None\n        with self.assertRaises(TypeError):\n            update_item_details(None, {'price': 20.0})\n\n    def test_update_data_none(self):\n        # Test AttributeError when update_data is None\n        with self.assertRaises(AttributeError):\n            update_item_details({'price': 10.0}, None)\n\n    def test_large_values(self):\n        # Test very large values for permitted fields\n        inventory = {'price': 10.0, 'stock': 5}\n        update_data = {'price': 1e100, 'stock': 10**6}\n        updated = update_item_details(inventory, update_data)\n        self.assertEqual(updated['price'], 1e100)\n        self.assertEqual(updated['stock'], 10**6)\n\n    def test_negative_values(self):\n        # Test negative values for permitted fields\n        inventory = {'price': 10.0, 'stock': 5}\n        update_data = {'price': -5.0, 'stock': -10}\n        updated = update_item_details(inventory, update_data)\n        self.assertEqual(updated['price'], -5.0)\n        self.assertEqual(updated['stock'], -10)\n\n    def test_permitted_field_not_in_inventory(self):\n        # Test updating a permitted field that doesn't exist in inventory adds it\n        inventory = {'price': 10.0}\n        update_data = {'category': 'Books'}\n        updated = update_item_details(inventory, update_data)\n        self.assertEqual(updated['category'], 'Books')\n        self.assertEqual(updated['price'], 10.0)", "num_test_cases": 15, "task_id": "2e4cc511"}
{"test": "import unittest\nfrom unittest.mock import patch\n\n# Assuming the function is imported from a module named 'solution'\nfrom solution import update_product_info\n\nclass TestUpdateProductInfo(unittest.TestCase):\n\n    @patch('solution.PERMITTED_FIELDS', ['price', 'description'])\n    def test_update_existing_permitted_field(self):\n        # Test updating a single existing permitted field\n        product = {'price': 10.0, 'description': 'Old description'}\n        changes = {'price': 20.0}\n        updated = update_product_info(product, changes)\n        self.assertEqual(updated, {'price': 20.0, 'description': 'Old description'})\n\n    @patch('solution.PERMITTED_FIELDS', ['price', 'description'])\n    def test_update_multiple_permitted_fields(self):\n        # Test updating multiple existing permitted fields\n        product = {'price': 10.0, 'description': 'Old description'}\n        changes = {'price': 20.0, 'description': 'New description'}\n        updated = update_product_info(product, changes)\n        self.assertEqual(updated, {'price': 20.0, 'description': 'New description'})\n\n    @patch('solution.PERMITTED_FIELDS', ['price'])\n    def test_mix_permitted_and_non_permitted(self):\n        # Test mix of permitted and non-permitted fields\n        product = {'price': 10.0, 'stock': 5}\n        changes = {'price': 20.0, 'stock': 10}\n        updated = update_product_info(product, changes)\n        self.assertEqual(updated, {'price': 20.0, 'stock': 5})\n\n    @patch('solution.PERMITTED_FIELDS', ['category'])\n    def test_add_new_permitted_field(self):\n        # Test adding a new permitted field not present in product\n        product = {'price': 10.0}\n        changes = {'category': 'Electronics'}\n        updated = update_product_info(product, changes)\n        self.assertEqual(updated, {'price': 10.0, 'category': 'Electronics'})\n\n    @patch('solution.PERMITTED_FIELDS', ['price'])\n    def test_non_permitted_field_not_present(self):\n        # Test non-permitted field not present in product is ignored\n        product = {'price': 10.0}\n        changes = {'color': 'red'}\n        updated = update_product_info(product, changes)\n        self.assertEqual(updated, {'price': 10.0})\n\n    @patch('solution.PERMITTED_FIELDS', ['price'])\n    def test_empty_change_data(self):\n        # Test empty change_data does not modify product\n        product = {'price': 10.0}\n        changes = {}\n        updated = update_product_info(product, changes)\n        self.assertEqual(updated, {'price': 10.0})\n\n    @patch('solution.PERMITTED_FIELDS', ['price'])\n    def test_non_string_key_not_permitted(self):\n        # Test non-string key in change_data (not in PERMITTED_FIELDS) is ignored\n        product = {'price': 10.0}\n        changes = {123: 'test'}\n        updated = update_product_info(product, changes)\n        self.assertEqual(updated, {'price': 10.0})\n\n    @patch('solution.PERMITTED_FIELDS', [123])\n    def test_non_string_key_permitted(self):\n        # Test non-string key in change_data (in PERMITTED_FIELDS) is updated\n        product = {123: 'old'}\n        changes = {123: 'new'}\n        updated = update_product_info(product, changes)\n        self.assertEqual(updated, {123: 'new'})\n\n    @patch('solution.PERMITTED_FIELDS', ['price'])\n    def test_prod_none(self):\n        # Test TypeError when prod is None\n        with self.assertRaises(TypeError):\n            update_product_info(None, {'price': 20.0})\n\n    @patch('solution.PERMITTED_FIELDS', ['price'])\n    def test_change_data_none(self):\n        # Test AttributeError when change_data is None\n        with self.assertRaises(AttributeError):\n            update_product_info({'price': 10.0}, None)\n\n    @patch('solution.PERMITTED_FIELDS', ['price'])\n    def test_change_data_invalid_type(self):\n        # Test AttributeError when change_data is not a dict\n        with self.assertRaises(AttributeError):\n            update_product_info({'price': 10.0}, 'invalid')\n\n    @patch('solution.PERMITTED_FIELDS', ['price'])\n    def test_case_sensitivity(self):\n        # Test case sensitivity in field names\n        product = {'price': 10.0}\n        changes = {'Price': 20.0}\n        updated = update_product_info(product, changes)\n        self.assertEqual(updated, {'price': 10.0})\n\n    @patch('solution.PERMITTED_FIELDS', [])\n    def test_empty_permitted_fields(self):\n        # Test no updates when PERMITTED_FIELDS is empty\n        product = {'price': 10.0, 'stock': 5}\n        changes = {'price': 20.0, 'stock': 10}\n        updated = update_product_info(product, changes)\n        self.assertEqual(updated, {'price': 10.0, 'stock': 5})\n\n    @patch('solution.PERMITTED_FIELDS', ['key50'])\n    def test_large_change_data(self):\n        # Test with large change_data; only permitted field updated\n        product = {f'key{i}': i for i in range(100)}\n        changes = {f'key{i}': i*2 for i in range(100)}\n        updated = update_product_info(product, changes)\n        # Verify only key50 was updated\n        for i in range(100):\n            if i == 50:\n                self.assertEqual(updated[f'key{i}'], 100)\n            else:\n                self.assertEqual(updated[f'key{i}'], i)\n", "num_test_cases": 14, "task_id": "511b15ec"}
{"test": "import unittest\nfrom solution import adjust_product_data\nimport solution\n\nclass TestAdjustProductData(unittest.TestCase):\n    def setUp(self):\n        solution.PERMITTED_FIELDS = ['price', 'description', 'stock']\n\n    def test_case_1(self):\n        # Test updating one permitted field that exists\n        prod_info = {'price': 10.0, 'description': 'Old', 'stock': 100}\n        change_vals = {'price': 20.0}\n        expected = {'price': 20.0, 'description': 'Old', 'stock': 100}\n        self.assertEqual(adjust_product_data(prod_info, change_vals), expected)\n\n    def test_case_2(self):\n        # Test updating two permitted fields that exist\n        prod_info = {'price': 10.0, 'description': 'Old', 'stock': 100}\n        change_vals = {'price': 20.0, 'description': 'New'}\n        expected = {'price': 20.0, 'description': 'New', 'stock': 100}\n        self.assertEqual(adjust_product_data(prod_info, change_vals), expected)\n\n    def test_case_3(self):\n        # Test updating one non-permitted field (existing) is ignored\n        prod_info = {'price': 10.0, 'description': 'Old', 'stock': 100, 'category': 'A'}\n        change_vals = {'category': 'B'}\n        expected = {'price': 10.0, 'description': 'Old', 'stock': 100, 'category': 'A'}\n        self.assertEqual(adjust_product_data(prod_info, change_vals), expected)\n\n    def test_case_4(self):\n        # Test mix of permitted and non-permitted fields updates only permitted\n        prod_info = {'price': 10.0, 'description': 'Old', 'stock': 100, 'category': 'A'}\n        change_vals = {'price': 20.0, 'category': 'B'}\n        expected = {'price': 20.0, 'description': 'Old', 'stock': 100, 'category': 'A'}\n        self.assertEqual(adjust_product_data(prod_info, change_vals), expected)\n\n    def test_case_5(self):\n        # Test empty change_vals results in no changes\n        prod_info = {'price': 10.0, 'description': 'Old', 'stock': 100}\n        change_vals = {}\n        expected = {'price': 10.0, 'description': 'Old', 'stock': 100}\n        self.assertEqual(adjust_product_data(prod_info, change_vals), expected)\n\n    def test_case_6(self):\n        # Test adding new permitted field (not in prod_info)\n        solution.PERMITTED_FIELDS = ['price', 'description', 'stock', 'weight']\n        prod_info = {'price': 10.0, 'description': 'Old', 'stock': 100}\n        change_vals = {'weight': 50}\n        expected = {'price': 10.0, 'description': 'Old', 'stock': 100, 'weight': 50}\n        self.assertEqual(adjust_product_data(prod_info, change_vals), expected)\n\n    def test_case_7(self):\n        # Test non-permitted field not in prod_info is ignored (not added)\n        prod_info = {'price': 10.0, 'description': 'Old', 'stock': 100}\n        change_vals = {'weight': 50}\n        expected = {'price': 10.0, 'description': 'Old', 'stock': 100}\n        self.assertEqual(adjust_product_data(prod_info, change_vals), expected)\n\n    def test_case_8(self):\n        # Test empty PERMITTED_FIELDS results in no updates\n        solution.PERMITTED_FIELDS = []\n        prod_info = {'price': 10.0, 'description': 'Old', 'stock': 100}\n        change_vals = {'price': 20.0, 'description': 'New'}\n        expected = {'price': 10.0, 'description': 'Old', 'stock': 100}\n        self.assertEqual(adjust_product_data(prod_info, change_vals), expected)\n\n    def test_case_9(self):\n        # Test updating permitted field to None value\n        prod_info = {'price': 10.0, 'description': 'Old', 'stock': 100}\n        change_vals = {'price': None}\n        expected = {'price': None, 'description': 'Old', 'stock': 100}\n        self.assertEqual(adjust_product_data(prod_info, change_vals), expected)\n\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 9, "task_id": "d568f8fc"}
{"test": "import unittest\n\nPERMITTED_FIELDS = ['price', 'description', 'stock', 'category']\n\nclass TestAmendProductFeatures(unittest.TestCase):\n    def test_update_one_permitted_field(self):\n        # Test updating one permitted field in PERMITTED_FIELDS\n        item = {'price': 10.0}\n        payload = {'price': 20.0}\n        result = amend_product_features(item, payload)\n        self.assertEqual(result['price'], 20.0)\n        self.assertIs(result, item)\n\n    def test_update_multiple_permitted_fields(self):\n        # Test updating multiple fields in PERMITTED_FIELDS\n        item = {'price': 10.0, 'description': 'old', 'stock': 100}\n        payload = {'price': 20.0, 'description': 'new'}\n        result = amend_product_features(item, payload)\n        self.assertEqual(result['price'], 20.0)\n        self.assertEqual(result['description'], 'new')\n        self.assertEqual(result['stock'], 100)\n\n    def test_update_non_permitted_field(self):\n        # Test updating a field not in PERMITTED_FIELDS (should be ignored)\n        item = {'price': 10.0, 'secret': 'x'}\n        payload = {'secret': 'y'}\n        result = amend_product_features(item, payload)\n        self.assertEqual(result['secret'], 'x')\n\n    def test_mix_of_permitted_and_non_permitted(self):\n        # Test updating mix of permitted and non-permitted fields\n        item = {'price': 10.0, 'secret': 'x'}\n        payload = {'price': 20.0, 'secret': 'y', 'invalid': 'value'}\n        result = amend_product_features(item, payload)\n        self.assertEqual(result['price'], 20.0)\n        self.assertEqual(result['secret'], 'x')\n        self.assertNotIn('invalid', result)\n\n    def test_empty_payload(self):\n        # Test with empty payload (no changes)\n        item = {'price': 10.0}\n        payload = {}\n        result = amend_product_features(item, payload)\n        self.assertEqual(result, item)\n        self.assertIs(result, item)\n\n    def test_add_new_permitted_field(self):\n        # Test adding new permitted field not originally in item\n        item = {}\n        payload = {'price': 20.0}\n        result = amend_product_features(item, payload)\n        self.assertEqual(result['price'], 20.0)\n\n    def test_add_new_non_permitted_field(self):\n        # Test adding new non-permitted field (should be ignored)\n        item = {}\n        payload = {'invalid': 'value'}\n        result = amend_product_features(item, payload)\n        self.assertEqual(len(result), 0)\n\n    def test_payload_with_non_string_key(self):\n        # Test payload with non-string key (should be ignored)\n        item = {'price': 10.0}\n        payload = {123: 'abc'}\n        result = amend_product_features(item, payload)\n        self.assertEqual(result, {'price': 10.0})\n\n    def test_item_is_none(self):\n        # Test with None as item (should raise TypeError)\n        with self.assertRaises(TypeError):\n            amend_product_features(None, {'price': 20.0})\n\n    def test_payload_is_none(self):\n        # Test with None as payload (should raise AttributeError)\n        item = {'price': 10.0}\n        with self.assertRaises(AttributeError):\n            amend_product_features(item, None)\n\n    def test_item_not_dict(self):\n        # Test when item is not a dict (should raise TypeError)\n        item = \"not a dict\"\n        payload = {'price': 20.0}\n        with self.assertRaises(TypeError):\n            amend_product_features(item, payload)\n\n    def test_payload_not_dict(self):\n        # Test when payload is not a dict (should raise AttributeError)\n        item = {'price': 10.0}\n        payload = \"not a dict\"\n        with self.assertRaises(AttributeError):\n            amend_product_features(item, payload)", "num_test_cases": 12, "task_id": "fc352f18"}
{"test": "import unittest\n\nPERMITTED_FIELDS = ['price', 'description', 'stock']\n\ndef update_product_attributes(item: dict, updates: dict):\n    for key, value in updates.items():\n        if key in PERMITTED_FIELDS:\n            item[key] = value\n    return item\n\nclass TestUpdateProductAttributes(unittest.TestCase):\n\n    def test_update_single_permitted_field(self):\n        # Update existing permitted field\n        item = {'price': 10.0, 'description': 'A product', 'stock': 100}\n        updates = {'price': 15.0}\n        result = update_product_attributes(item, updates)\n        self.assertEqual(result['price'], 15.0)\n        self.assertEqual(item['price'], 15.0)\n        self.assertEqual(result['description'], 'A product')\n        self.assertEqual(result['stock'], 100)\n\n    def test_update_multiple_permitted_fields(self):\n        # Update multiple permitted fields\n        item = {'price': 10.0, 'description': 'A product', 'stock': 100}\n        updates = {'price': 20.0, 'description': 'Updated product', 'stock': 50}\n        result = update_product_attributes(item, updates)\n        self.assertEqual(result['price'], 20.0)\n        self.assertEqual(result['description'], 'Updated product')\n        self.assertEqual(result['stock'], 50)\n\n    def test_ignore_non_permitted_field(self):\n        # Non-permitted field should be ignored\n        item = {'price': 10.0, 'description': 'A product', 'category': 'books'}\n        updates = {'category': 'electronics'}\n        result = update_product_attributes(item, updates)\n        self.assertEqual(result['category'], 'books')\n\n    def test_mixed_permitted_and_non_permitted(self):\n        # Update mix of permitted and non-permitted fields\n        item = {'price': 10.0, 'description': 'A product', 'category': 'books'}\n        updates = {'price': 30.0, 'category': 'electronics', 'unknown': 'value'}\n        result = update_product_attributes(item, updates)\n        self.assertEqual(result['price'], 30.0)\n        self.assertEqual(result['category'], 'books')\n        self.assertNotIn('unknown', result)\n\n    def test_add_new_permitted_field(self):\n        # Add new permitted field not in original item\n        item = {'price': 10.0, 'description': 'A product'}\n        updates = {'stock': 200}\n        result = update_product_attributes(item, updates)\n        self.assertEqual(result['stock'], 200)\n        self.assertIn('stock', item)\n\n    def test_ignore_new_non_permitted_field(self):\n        # Do not add non-permitted field\n        item = {'price': 10.0}\n        updates = {'category': 'new'}\n        result = update_product_attributes(item, updates)\n        self.assertNotIn('category', result)\n\n    def test_empty_updates(self):\n        # Empty updates should leave item unchanged\n        item = {'price': 10.0, 'description': 'A product'}\n        original_item = item.copy()\n        result = update_product_attributes(item, {})\n        self.assertEqual(result, original_item)\n        self.assertIs(result, item)\n\n    def test_update_with_none_value(self):\n        # Update permitted field with None value\n        item = {'price': 10.0, 'description': 'A product'}\n        updates = {'description': None}\n        result = update_product_attributes(item, updates)\n        self.assertIsNone(result['description'])\n\n    def test_update_non_string_keys(self):\n        # Non-string keys should be ignored if not in PERMITTED_FIELDS\n        item = {'price': 10.0}\n        updates = {123: 'test', 'price': 20.0}\n        result = update_product_attributes(item, updates)\n        self.assertEqual(result['price'], 20.0)\n        self.assertNotIn(123, result)\n\n    def test_identity_check(self):\n        # Verify returned object is same as input item\n        item = {'price': 10.0}\n        updates = {'price': 20.0}\n        result = update_product_attributes(item, updates)\n        self.assertIs(result, item)\n", "num_test_cases": 10, "task_id": "7cfd08dc"}
{"test": "import unittest\nfrom solution import modify_item_details\nimport solution\n\nsolution.PERMITTED_FIELDS = ['price', 'description', 'stock', 'category']\n\nclass TestModifyItemDetails(unittest.TestCase):\n    \n    def test_update_single_existing_field(self):\n        # Test updating one permitted field that exists in the item\n        item = {'name': 'Shirt', 'price': 20.0}\n        updated = modify_item_details(item, {'price': 25.0})\n        self.assertEqual(updated['price'], 25.0)\n        self.assertEqual(updated['name'], 'Shirt')\n    \n    def test_update_multiple_permitted_fields(self):\n        # Test updating multiple permitted fields that exist\n        item = {'name': 'Pants', 'price': 30.0, 'stock': 50, 'description': 'Comfortable'}\n        updates = {'price': 35.0, 'stock': 45}\n        updated = modify_item_details(item, updates)\n        self.assertEqual(updated['price'], 35.0)\n        self.assertEqual(updated['stock'], 45)\n        self.assertEqual(updated['description'], 'Comfortable')\n    \n    def test_add_new_permitted_field(self):\n        # Test adding a new field that is permitted but not originally in the item\n        item = {'name': 'Hat'}\n        updated = modify_item_details(item, {'price': 15.0})\n        self.assertEqual(updated['price'], 15.0)\n        self.assertEqual(updated['name'], 'Hat')\n    \n    def test_ignore_non_permitted_fields(self):\n        # Test that non-permitted fields in the details are ignored\n        item = {'name': 'Shoes', 'price': 50.0}\n        updated = modify_item_details(item, {'color': 'red', 'price': 55.0})\n        self.assertEqual(updated['price'], 55.0)\n        self.assertNotIn('color', updated)\n    \n    def test_empty_details_no_change(self):\n        # Test that empty details dictionary results in no changes\n        item = {'name': 'Jacket', 'price': 75.0}\n        updated = modify_item_details(item, {})\n        self.assertEqual(updated, item)\n    \n    def test_update_with_none_value(self):\n        # Test updating a permitted field with None value\n        item = {'name': 'Socks', 'stock': 100}\n        updated = modify_item_details(item, {'stock': None})\n        self.assertIsNone(updated['stock'])\n    \n    def test_update_with_empty_string(self):\n        # Test updating a permitted field with empty string\n        item = {'name': 'Scarf', 'description': 'Warm'}\n        updated = modify_item_details(item, {'description': ''})\n        self.assertEqual(updated['description'], '')\n    \n    def test_update_with_zero(self):\n        # Test updating a permitted field with zero\n        item = {'name': 'Belt', 'stock': 10}\n        updated = modify_item_details(item, {'stock': 0})\n        self.assertEqual(updated['stock'], 0)\n    \n    def test_item_is_none(self):\n        # Test passing None as item (should raise TypeError)\n        with self.assertRaises(TypeError):\n            modify_item_details(None, {'price': 10})\n    \n    def test_item_is_string(self):\n        # Test passing string as item (should raise TypeError)\n        with self.assertRaises(TypeError):\n            modify_item_details('item', {'price': 10})\n    \n    def test_details_is_integer(self):\n        # Test passing integer as details (should raise AttributeError)\n        with self.assertRaises(AttributeError):\n            modify_item_details({}, 123)\n    \n    def test_details_is_list(self):\n        # Test passing list as details (should raise AttributeError)\n        with self.assertRaises(AttributeError):\n            modify_item_details({}, [('price', 10)])\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 12, "task_id": "809b7b95"}
{"test": "import unittest\n\n# Define the global PERMITTED_FIELDS as required by the function\nPERMITTED_FIELDS = ['price', 'description', 'stock']\n\n# The function implementation (as per the provided code)\ndef update_item_information(product_info: dict, new_data: dict):\n    for key, value in new_data.items():\n        if key in PERMITTED_FIELDS:\n            product_info[key] = value\n    return product_info\n\nclass TestUpdateItemInformation(unittest.TestCase):\n    \n    def test_update_existing_permitted_field(self):\n        # Test updating an existing permitted field\n        product = {'price': 10.0, 'description': 'Original'}\n        updates = {'price': 20.0}\n        result = update_item_information(product, updates)\n        self.assertEqual(result, {'price': 20.0, 'description': 'Original'})\n    \n    def test_add_new_permitted_field(self):\n        # Test adding a new permitted field not present in product_info\n        product = {'price': 10.0}\n        updates = {'stock': 100}\n        result = update_item_information(product, updates)\n        self.assertEqual(result, {'price': 10.0, 'stock': 100})\n    \n    def test_update_multiple_permitted_fields(self):\n        # Test updating multiple permitted fields (existing and new)\n        product = {'price': 10.0, 'description': 'Original'}\n        updates = {'price': 20.0, 'stock': 100}\n        result = update_item_information(product, updates)\n        self.assertEqual(result, {'price': 20.0, 'description': 'Original', 'stock': 100})\n    \n    def test_mix_permitted_and_non_permitted_fields(self):\n        # Test updating a mix of permitted and non-permitted fields\n        product = {'price': 10.0, 'description': 'Original'}\n        updates = {'price': 20.0, 'category': 'Electronics'}\n        result = update_item_information(product, updates)\n        self.assertEqual(result, {'price': 20.0, 'description': 'Original'})\n    \n    def test_non_permitted_field_only(self):\n        # Test updating only non-permitted fields (should be ignored)\n        product = {'price': 10.0, 'description': 'Original'}\n        updates = {'category': 'Electronics', 'weight': 5.0}\n        result = update_item_information(product, updates)\n        self.assertEqual(result, {'price': 10.0, 'description': 'Original'})\n    \n    def test_empty_new_data(self):\n        # Test with empty new_data dictionary\n        product = {'price': 10.0}\n        updates = {}\n        result = update_item_information(product, updates)\n        self.assertEqual(result, {'price': 10.0})\n    \n    def test_empty_product_info(self):\n        # Test updating an empty product_info dictionary\n        product = {}\n        updates = {'price': 10.0, 'category': 'Electronics'}\n        result = update_item_information(product, updates)\n        self.assertEqual(result, {'price': 10.0})\n    \n    def test_non_dict_product_info(self):\n        # Test non-dictionary product_info (expect TypeError)\n        with self.assertRaises(TypeError):\n            update_item_information(123, {'price': 20.0})\n    \n    def test_non_dict_new_data(self):\n        # Test non-dictionary new_data (expect AttributeError)\n        with self.assertRaises(AttributeError):\n            update_item_information({}, 123)\n    \n    def test_none_as_input(self):\n        # Test with None for both arguments\n        with self.assertRaises(AttributeError):\n            update_item_information(None, {'price': 20.0})\n        with self.assertRaises(AttributeError):\n            update_item_information({'price': 20.0}, None)\n    \n    def test_partially_valid_updates(self):\n        # Test when some updates are valid and others are not\n        product = {'price': 10.0, 'description': 'Original'}\n        updates = {'price': 25.0, 'invalid_key': 'value', 'stock': 50}\n        result = update_item_information(product, updates)\n        self.assertEqual(result, {'price': 25.0, 'description': 'Original', 'stock': 50})\n    \n    def test_update_with_none_values(self):\n        # Test updating with None values for permitted fields\n        product = {'price': 10.0, 'description': 'Original', 'stock': 100}\n        updates = {'price': None, 'description': None}\n        result = update_item_information(product, updates)\n        self.assertEqual(result, {'price': None, 'description': None, 'stock': 100})\n    \n    def test_large_product_info(self):\n        # Test with a large product_info dictionary\n        product = {f'key{i}': i for i in range(1000)}\n        product.update({'price': 10.0})\n        updates = {'price': 100.0, 'description': 'Large product'}\n        result = update_item_information(product, updates)\n        self.assertEqual(result['price'], 100.0)\n        self.assertEqual(result['description'], 'Large product')\n        self.assertEqual(len(result), 1001)  # 1000 original keys + one new (description)\n    \n    def test_very_large_updates(self):\n        # Test with a very large new_data dictionary\n        product = {'price': 10.0}\n        updates = {f'key{i}': i for i in range(1000)}\n        updates.update({'price': 20.0})  # One permitted field\n        result = update_item_information(product, updates)\n        self.assertEqual(result['price'], 20.0)\n        # Only the permitted field 'price' should be updated; others are ignored\n        self.assertEqual(len(result), 1)  # Only the price field remains\n    \n    def test_non_string_keys_in_new_data(self):\n        # Test non-string keys in new_data (should be ignored if not in PERMITTED_FIELDS)\n        product = {'price': 10.0}\n        updates = {123: 'abc', 'price': 20.0}\n        result = update_item_information(product, updates)\n        self.assertEqual(result, {'price': 20.0})  # Non-string key 123 is ignored\n    \n    def test_permitted_field_non_string_key(self):\n        # Test non-string key that matches a permitted field (should not match)\n        product = {'price': 10.0}\n        updates = {123: 'abc'}  # 123 is not a string, so not in PERMITTED_FIELDS (which are strings)\n        result = update_item_information(product, updates)\n        self.assertEqual(result, {'price': 10.0})", "num_test_cases": 15, "task_id": "bde2c2ba"}
{"test": "import unittest\n\n# Define the global variable for the tests\nALLOWED_FIELDS = ['make', 'model', 'year']\n\n# Define the function to be tested\ndef modify_car_attributes(car: dict, updates: dict):\n    for key, value in updates.items():\n        if key in ALLOWED_FIELDS:\n            car[key] = value\n    return car\n\nclass TestModifyCarAttributes(unittest.TestCase):\n    \n    def test_update_one_allowed_one_disallowed(self):\n        # Test updating one allowed field and one disallowed field\n        car = {'make': 'Toyota', 'model': 'Camry', 'year': 2020}\n        updates = {'make': 'Honda', 'color': 'Blue'}\n        result = modify_car_attributes(car, updates)\n        self.assertEqual(result, {'make': 'Honda', 'model': 'Camry', 'year': 2020})\n        \n    def test_update_multiple_allowed_fields(self):\n        # Test updating multiple allowed fields\n        car = {'make': 'Toyota', 'model': 'Camry', 'year': 2020}\n        updates = {'make': 'Honda', 'year': 2021}\n        result = modify_car_attributes(car, updates)\n        self.assertEqual(result, {'make': 'Honda', 'model': 'Camry', 'year': 2021})\n        \n    def test_update_only_disallowed_fields(self):\n        # Test updating with only disallowed fields\n        car = {'make': 'Toyota', 'model': 'Camry', 'year': 2020}\n        updates = {'color': 'Blue', 'vin': '12345'}\n        result = modify_car_attributes(car, updates)\n        self.assertEqual(result, {'make': 'Toyota', 'model': 'Camry', 'year': 2020})\n        \n    def test_empty_updates(self):\n        # Test with empty updates dictionary\n        car = {'make': 'Toyota', 'model': 'Camry', 'year': 2020}\n        updates = {}\n        result = modify_car_attributes(car, updates)\n        self.assertEqual(result, car)\n        \n    def test_update_allowed_field_with_none(self):\n        # Test updating an allowed field with None\n        car = {'make': 'Toyota', 'model': 'Camry', 'year': 2020}\n        updates = {'make': None}\n        result = modify_car_attributes(car, updates)\n        self.assertEqual(result, {'make': None, 'model': 'Camry', 'year': 2020})\n        \n    def test_update_allowed_field_with_empty_string(self):\n        # Test updating an allowed field with empty string\n        car = {'make': 'Toyota', 'model': 'Camry', 'year': 2020}\n        updates = {'model': ''}\n        result = modify_car_attributes(car, updates)\n        self.assertEqual(result, {'make': 'Toyota', 'model': '', 'year': 2020})\n        \n    def test_add_new_allowed_field(self):\n        # Test adding a new allowed field not originally in car\n        car = {'make': 'Toyota', 'year': 2020}\n        updates = {'model': 'Camry'}\n        result = modify_car_attributes(car, updates)\n        self.assertEqual(result, {'make': 'Toyota', 'year': 2020, 'model': 'Camry'})\n        \n    def test_add_new_disallowed_field(self):\n        # Test adding a new disallowed field\n        car = {'make': 'Toyota', 'year': 2020}\n        updates = {'color': 'Blue'}\n        result = modify_car_attributes(car, updates)\n        self.assertEqual(result, {'make': 'Toyota', 'year': 2020})\n        \n    def test_in_place_modification(self):\n        # Test that function modifies and returns the original dictionary\n        car = {'make': 'Toyota', 'model': 'Camry', 'year': 2020}\n        updates = {'year': 2021}\n        result = modify_car_attributes(car, updates)\n        self.assertIs(result, car)\n        \n    def test_numeric_update(self):\n        # Test updating an allowed numeric field\n        car = {'year': 2020}\n        updates = {'year': 2022}\n        result = modify_car_attributes(car, updates)\n        self.assertEqual(result, {'year': 2022})\n        \n    def test_large_updates_dict(self):\n        # Test with a large updates dictionary\n        car = {'make': 'Toyota', 'model': 'Camry', 'year': 2020}\n        updates = {f'extra{i}': i for i in range(1000)}\n        updates.update({'make': 'Honda'})  # One allowed update\n        result = modify_car_attributes(car, updates)\n        self.assertEqual(result, {'make': 'Honda', 'model': 'Camry', 'year': 2020})\n        \n    def test_none_car(self):\n        # Test passing None for car (should raise AttributeError)\n        with self.assertRaises(AttributeError):\n            modify_car_attributes(None, {'make': 'Honda'})\n        \n    def test_none_updates(self):\n        # Test passing None for updates (should raise AttributeError)\n        car = {'make': 'Toyota'}\n        with self.assertRaises(AttributeError):\n            modify_car_attributes(car, None)\n        \n    def test_non_dict_car(self):\n        # Test passing non-dict for car\n        with self.assertRaises(AttributeError):\n            modify_car_attributes('not a dict', {'make': 'Honda'})\n        \n    def test_non_dict_updates(self):\n        # Test passing non-dict for updates\n        car = {'make': 'Toyota'}\n        with self.assertRaises(AttributeError):\n            modify_car_attributes(car, 'not a dict')\n        \n    def test_non_string_keys_in_updates(self):\n        # Test non-string keys in updates\n        car = {'make': 'Toyota'}\n        updates = {123: 'test'}\n        result = modify_car_attributes(car, updates)\n        self.assertEqual(result, car)  # Non-string key should be ignored\n        \n    def test_complex_nested_values(self):\n        # Test complex nested values (should work since assignment is direct)\n        car = {'make': 'Toyota'}\n        updates = {'year': [2020, 2021, 2022]}\n        result = modify_car_attributes(car, updates)\n        self.assertEqual(result, {'make': 'Toyota', 'year': [2020, 2021, 2022]})\n        \n    def test_duplicate_keys_in_updates(self):\n        # Test duplicate keys in updates (last occurrence should win)\n        car = {'make': 'Toyota'}\n        updates = [('make', 'Honda'), ('make', 'Ford')]\n        # Convert to dict first to show expected behavior\n        expected_updates = dict(updates)\n        result = modify_car_attributes(car, dict(updates))\n        self.assertEqual(result['make'], expected_updates['make'])\n        \n    def test_update_allowed_field_with_zero(self):\n        # Test updating allowed field with zero\n        car = {'year': 2020}\n        updates = {'year': 0}\n        result = modify_car_attributes(car, updates)\n        self.assertEqual(result, {'year': 0})\n        \n    def test_update_allowed_field_with_negative(self):\n        # Test updating allowed field with negative number\n        car = {'year': 2020}\n        updates = {'year': -1}\n        result = modify_car_attributes(car, updates)\n        self.assertEqual(result, {'year': -1})", "num_test_cases": 19, "task_id": "506683c6"}
{"test": "import unittest\n\n# Define the global ALLOWED_FIELDS that the function uses\nALLOWED_FIELDS = ['year', 'color']\n\nclass TestUpdateVehicleAttributes(unittest.TestCase):\n    \n    def setUp(self):\n        \"\"\"Save the current state of ALLOWED_FIELDS before each test.\"\"\"\n        global ALLOWED_FIELDS\n        self.original_allowed = list(ALLOWED_FIELDS)\n    \n    def tearDown(self):\n        \"\"\"Restore the original ALLOWED_FIELDS after each test.\"\"\"\n        global ALLOWED_FIELDS\n        ALLOWED_FIELDS = self.original_allowed\n    \n    def test_update_one_allowed_field(self):\n        \"\"\"Test updating one allowed field.\"\"\"\n        automobile = {'make': 'Toyota', 'model': 'Camry', 'year': 2020}\n        changes = {'year': 2021}\n        updated = update_vehicle_attributes(automobile, changes)\n        self.assertEqual(updated, {'make': 'Toyota', 'model': 'Camry', 'year': 2021})\n    \n    def test_update_multiple_allowed_fields(self):\n        \"\"\"Test updating multiple allowed fields.\"\"\"\n        automobile = {'make': 'Toyota', 'model': 'Camry', 'year': 2020, 'color': 'red'}\n        changes = {'year': 2021, 'color': 'blue'}\n        updated = update_vehicle_attributes(automobile, changes)\n        self.assertEqual(updated, {'make': 'Toyota', 'model': 'Camry', 'year': 2021, 'color': 'blue'})\n    \n    def test_update_not_allowed_field(self):\n        \"\"\"Test updating a field not in ALLOWED_FIELDS is ignored.\"\"\"\n        automobile = {'make': 'Toyota', 'model': 'Camry', 'year': 2020}\n        changes = {'make': 'Honda'}\n        updated = update_vehicle_attributes(automobile, changes)\n        self.assertEqual(updated, automobile)\n    \n    def test_empty_changes(self):\n        \"\"\"Test empty changes dictionary leaves automobile unchanged.\"\"\"\n        automobile = {'make': 'Toyota', 'model': 'Camry', 'year': 2020}\n        changes = {}\n        updated = update_vehicle_attributes(automobile, changes)\n        self.assertEqual(updated, automobile)\n    \n    def test_mix_of_allowed_and_not_allowed(self):\n        \"\"\"Test mix of allowed and disallowed fields only updates allowed ones.\"\"\"\n        automobile = {'make': 'Toyota', 'model': 'Camry', 'year': 2020}\n        changes = {'year': 2021, 'make': 'Honda'}\n        updated = update_vehicle_attributes(automobile, changes)\n        self.assertEqual(updated, {'make': 'Toyota', 'model': 'Camry', 'year': 2021})\n    \n    def test_add_new_allowed_field(self):\n        \"\"\"Test adding a new allowed field not present in automobile.\"\"\"\n        automobile = {'make': 'Toyota', 'model': 'Camry', 'year': 2020}\n        changes = {'color': 'blue'}\n        updated = update_vehicle_attributes(automobile, changes)\n        self.assertEqual(updated, {'make': 'Toyota', 'model': 'Camry', 'year': 2020, 'color': 'blue'})\n    \n    def test_changes_is_none(self):\n        \"\"\"Test that passing None for changes raises TypeError.\"\"\"\n        automobile = {'make': 'Toyota', 'model': 'Camry', 'year': 2020}\n        with self.assertRaises(TypeError):\n            update_vehicle_attributes(automobile, None)\n    \n    def test_changes_is_not_dict(self):\n        \"\"\"Test that non-dict changes raises TypeError.\"\"\"\n        automobile = {'make': 'Toyota', 'model': 'Camry', 'year': 2020}\n        with self.assertRaises(TypeError):\n            update_vehicle_attributes(automobile, [('year', 2021)])\n    \n    def test_automobile_is_none(self):\n        \"\"\"Test that passing None for automobile raises TypeError.\"\"\"\n        with self.assertRaises(TypeError):\n            update_vehicle_attributes(None, {'year': 2021})\n    \n    def test_automobile_is_not_dict(self):\n        \"\"\"Test that non-dict automobile raises TypeError.\"\"\"\n        with self.assertRaises(TypeError):\n            update_vehicle_attributes('not a dict', {'year': 2021})\n    \n    def test_different_allowed_fields(self):\n        \"\"\"Test function respects different ALLOWED_FIELDS configuration.\"\"\"\n        global ALLOWED_FIELDS\n        # Change allowed fields for this test\n        ALLOWED_FIELDS = ['make', 'model']\n        automobile = {'make': 'Toyota', 'model': 'Camry', 'year': 2020}\n        changes = {'make': 'Honda', 'year': 2021}\n        updated = update_vehicle_attributes(automobile, changes)\n        self.assertEqual(updated, {'make': 'Honda', 'model': 'Camry', 'year': 2020})\n    \n    def test_empty_allowed_fields(self):\n        \"\"\"Test that no updates occur when ALLOWED_FIELDS is empty.\"\"\"\n        global ALLOWED_FIELDS\n        # Change allowed fields to empty list\n        ALLOWED_FIELDS = []\n        automobile = {'make': 'Toyota', 'model': 'Camry', 'year': 2020}\n        changes = {'year': 2021, 'color': 'blue'}\n        updated = update_vehicle_attributes(automobile, changes)\n        self.assertEqual(updated, automobile)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 12, "task_id": "e4586b6b"}
{"test": "import unittest\n\n# Define the global ALLOWED_FIELDS for the function\nALLOWED_FIELDS = ['make', 'model', 'year']\n\nclass TestAlterVehicleInfo(unittest.TestCase):\n\n    def test_update_one_allowed_field(self):\n        # Test updating a single allowed field in the details dictionary.\n        details = {'make': 'Toyota', 'model': 'Camry', 'year': 2015}\n        modifications = {'make': 'Honda'}\n        expected = {'make': 'Honda', 'model': 'Camry', 'year': 2015}\n        result = alter_vehicle_info(details, modifications)\n        self.assertIs(result, details)\n        self.assertEqual(details, expected)\n\n    def test_update_multiple_allowed_fields(self):\n        # Test updating multiple allowed fields at once.\n        details = {'make': 'Toyota', 'model': 'Camry', 'year': 2015}\n        modifications = {'make': 'Honda', 'year': 2020}\n        expected = {'make': 'Honda', 'model': 'Camry', 'year': 2020}\n        result = alter_vehicle_info(details, modifications)\n        self.assertEqual(details, expected)\n\n    def test_update_disallowed_field(self):\n        # Test that a disallowed field (not in ALLOWED_FIELDS) is ignored.\n        details = {'make': 'Toyota', 'model': 'Camry', 'year': 2015}\n        modifications = {'color': 'Red'}\n        expected = details.copy()\n        result = alter_vehicle_info(details, modifications)\n        self.assertEqual(details, expected)\n\n    def test_mix_allowed_disallowed(self):\n        # Test a mix of allowed and disallowed fields: only allowed fields are updated.\n        details = {'make': 'Toyota', 'model': 'Camry', 'year': 2015}\n        modifications = {'make': 'Honda', 'color': 'Red'}\n        expected = {'make': 'Honda', 'model': 'Camry', 'year': 2015}\n        result = alter_vehicle_info(details, modifications)\n        self.assertEqual(details, expected)\n\n    def test_new_allowed_field(self):\n        # Test adding a new allowed field that was not originally in details.\n        details = {'make': 'Toyota', 'model': 'Camry'}\n        modifications = {'year': 2020}\n        expected = {'make': 'Toyota', 'model': 'Camry', 'year': 2020}\n        result = alter_vehicle_info(details, modifications)\n        self.assertEqual(details, expected)\n\n    def test_empty_modifications(self):\n        # Test that no modifications occur when modifications dict is empty.\n        details = {'make': 'Toyota', 'model': 'Camry', 'year': 2015}\n        modifications = {}\n        expected = details.copy()\n        result = alter_vehicle_info(details, modifications)\n        self.assertEqual(details, expected)\n\n    def test_update_empty_details(self):\n        # Test updating an empty details dictionary with an allowed field.\n        details = {}\n        modifications = {'make': 'Honda'}\n        expected = {'make': 'Honda'}\n        result = alter_vehicle_info(details, modifications)\n        self.assertEqual(details, expected)\n\n    def test_update_to_none(self):\n        # Test updating an allowed field to None.\n        details = {'make': 'Toyota', 'model': 'Camry', 'year': 2015}\n        modifications = {'make': None}\n        expected = {'make': None, 'model': 'Camry', 'year': 2015}\n        result = alter_vehicle_info(details, modifications)\n        self.assertEqual(details, expected)\n\n    def test_returns_same_object(self):\n        # Test that the function returns the same dictionary object that was passed in.\n        details = {'make': 'Toyota'}\n        modifications = {'make': 'Honda'}\n        result = alter_vehicle_info(details, modifications)\n        self.assertIs(result, details)\n\n    def test_empty_allowed_fields(self):\n        # Test when ALLOWED_FIELDS is empty: no field is updated.\n        global ALLOWED_FIELDS\n        old_value = ALLOWED_FIELDS\n        try:\n            ALLOWED_FIELDS = []\n            details = {'make': 'Toyota', 'model': 'Camry'}\n            modifications = {'make': 'Honda'}\n            result = alter_vehicle_info(details, modifications)\n            self.assertEqual(details, {'make': 'Toyota', 'model': 'Camry'})\n        finally:\n            ALLOWED_FIELDS = old_value\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 10, "task_id": "ed934a30"}
{"test": "import unittest\n\n# Define the allowed fields for the test\nALLOWED_FIELDS = ['make', 'model', 'year', 'color']\n\nclass TestModifyCarDetails(unittest.TestCase):\n    def test_update_existing_allowed_field(self):\n        # Test updating a single existing allowed field\n        car = {'make': 'Toyota', 'model': 'Corolla', 'year': 2015}\n        changes = {'year': 2020}\n        result = modify_car_details(car, changes)\n        self.assertEqual(result, {'make': 'Toyota', 'model': 'Corolla', 'year': 2020})\n\n    def test_update_multiple_allowed_fields(self):\n        # Test updating multiple existing allowed fields\n        car = {'make': 'Toyota', 'model': 'Corolla', 'year': 2015}\n        changes = {'year': 2020, 'model': 'Camry'}\n        result = modify_car_details(car, changes)\n        self.assertEqual(result, {'make': 'Toyota', 'model': 'Camry', 'year': 2020})\n\n    def test_ignore_disallowed_field(self):\n        # Test that disallowed fields are ignored\n        car = {'make': 'Toyota', 'model': 'Corolla', 'year': 2015}\n        changes = {'vin': 'ABC123'}\n        result = modify_car_details(car, changes)\n        self.assertEqual(result, car)\n\n    def test_mixed_allowed_and_disallowed(self):\n        # Test a mix of allowed and disallowed fields\n        car = {'make': 'Toyota', 'model': 'Corolla', 'year': 2015}\n        changes = {'year': 2020, 'vin': 'ABC123', 'color': 'blue'}\n        result = modify_car_details(car, changes)\n        expected = {'make': 'Toyota', 'model': 'Corolla', 'year': 2020, 'color': 'blue'}\n        self.assertEqual(result, expected)\n\n    def test_empty_changes(self):\n        # Test with an empty changes dictionary\n        car = {'make': 'Toyota', 'model': 'Corolla', 'year': 2015}\n        changes = {}\n        result = modify_car_details(car, changes)\n        self.assertEqual(result, car)\n\n    def test_add_new_allowed_field(self):\n        # Test adding a new allowed field not present in original car\n        car = {'make': 'Toyota'}\n        changes = {'color': 'red'}\n        result = modify_car_details(car, changes)\n        self.assertEqual(result, {'make': 'Toyota', 'color': 'red'})\n\n    def test_update_to_none_value(self):\n        # Test updating an allowed field to None\n        car = {'make': 'Toyota', 'model': 'Corolla'}\n        changes = {'model': None}\n        result = modify_car_details(car, changes)\n        self.assertEqual(result, {'make': 'Toyota', 'model': None})\n\n    def test_update_to_empty_string(self):\n        # Test updating an allowed field to an empty string\n        car = {'make': 'Toyota', 'model': 'Corolla'}\n        changes = {'make': ''}\n        result = modify_car_details(car, changes)\n        self.assertEqual(result, {'make': '', 'model': 'Corolla'})\n\n    def test_ignore_disallowed_in_non_empty_car(self):\n        # Test that disallowed fields in a non-empty car are ignored\n        car = {'make': 'Toyota', 'secret_id': 123}\n        changes = {'secret_id': 456}\n        result = modify_car_details(car, changes)\n        self.assertEqual(result, car)\n\n    def test_add_fields_to_empty_car(self):\n        # Test adding allowed fields to an empty car dictionary\n        car = {}\n        changes = {'make': 'Honda', 'model': 'Accord'}\n        result = modify_car_details(car, changes)\n        self.assertEqual(result, {'make': 'Honda', 'model': 'Accord'})", "num_test_cases": 10, "task_id": "d98d91fe"}
{"test": "import unittest\nfrom unittest.mock import patch\nfrom solution import adjust_vehicle_info\n\nclass TestAdjustVehicleInfo(unittest.TestCase):\n    def setUp(self):\n        self.allowed_fields = ['make', 'model', 'year', 'color']\n        self.patcher = patch('solution.ALLOWED_FIELDS', self.allowed_fields)\n        self.patcher.start()\n        self.addCleanup(self.patcher.stop)\n\n    def test_update_one_allowed_field(self):\n        # Test updating one allowed field\n        auto = {'make': 'Toyota', 'model': 'Camry', 'year': 2020}\n        modifications = {'make': 'Honda'}\n        result = adjust_vehicle_info(auto, modifications)\n        self.assertEqual(result, {'make': 'Honda', 'model': 'Camry', 'year': 2020})\n\n    def test_update_multiple_allowed_fields(self):\n        # Test updating multiple allowed fields\n        auto = {'make': 'Toyota', 'model': 'Camry', 'year': 2020}\n        modifications = {'make': 'Honda', 'year': 2021}\n        result = adjust_vehicle_info(auto, modifications)\n        self.assertEqual(result, {'make': 'Honda', 'model': 'Camry', 'year': 2021})\n\n    def test_update_disallowed_field(self):\n        # Test updating a disallowed field (should be ignored)\n        auto = {'make': 'Toyota', 'model': 'Camry', 'year': 2020}\n        modifications = {'engine': 'V6'}\n        result = adjust_vehicle_info(auto, modifications)\n        self.assertEqual(result, auto)\n\n    def test_mix_allowed_and_disallowed(self):\n        # Test mix of allowed and disallowed fields\n        auto = {'make': 'Toyota', 'model': 'Camry', 'year': 2020}\n        modifications = {'make': 'Honda', 'engine': 'V6'}\n        result = adjust_vehicle_info(auto, modifications)\n        self.assertEqual(result, {'make': 'Honda', 'model': 'Camry', 'year': 2020})\n\n    def test_empty_modifications(self):\n        # Test empty modifications dictionary\n        auto = {'make': 'Toyota'}\n        modifications = {}\n        result = adjust_vehicle_info(auto, modifications)\n        self.assertEqual(result, auto)\n\n    def test_add_new_allowed_field(self):\n        # Test adding a new allowed field that didn't exist\n        auto = {'make': 'Toyota', 'model': 'Camry'}\n        modifications = {'year': 2020}\n        result = adjust_vehicle_info(auto, modifications)\n        self.assertEqual(result, {'make': 'Toyota', 'model': 'Camry', 'year': 2020})\n\n    def test_update_allowed_field_to_none(self):\n        # Test updating an allowed field to None value\n        auto = {'make': 'Toyota', 'model': 'Camry', 'year': 2020}\n        modifications = {'year': None}\n        result = adjust_vehicle_info(auto, modifications)\n        self.assertEqual(result, {'make': 'Toyota', 'model': 'Camry', 'year': None})\n\n    def test_auto_is_none(self):\n        # Test passing None for auto (should raise TypeError)\n        with self.assertRaises(TypeError):\n            adjust_vehicle_info(None, {'make': 'Honda'})\n\n    def test_modifications_is_none(self):\n        # Test passing None for modifications (should raise AttributeError)\n        with self.assertRaises(AttributeError):\n            adjust_vehicle_info({'make': 'Toyota'}, None)\n\n    def test_auto_invalid_type_string(self):\n        # Test passing string for auto (should raise TypeError)\n        with self.assertRaises(TypeError):\n            adjust_vehicle_info('I am a string', {'make': 'Honda'})\n\n    def test_modifications_invalid_type_string(self):\n        # Test passing string for modifications (should raise AttributeError)\n        with self.assertRaises(AttributeError):\n            adjust_vehicle_info({'make': 'Toyota'}, 'make=Honda')\n\n    def test_empty_auto_with_allowed_field(self):\n        # Test updating an empty auto dictionary with an allowed field\n        auto = {}\n        modifications = {'make': 'Toyota'}\n        result = adjust_vehicle_info(auto, modifications)\n        self.assertEqual(result, {'make': 'Toyota'})\n\n    def test_case_sensitivity(self):\n        # Test case sensitivity of field names\n        auto = {'make': 'Toyota'}\n        modifications = {'Make': 'Honda'}\n        result = adjust_vehicle_info(auto, modifications)\n        self.assertEqual(result, auto)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 13, "task_id": "e497edea"}
{"test": "import unittest\n\n# Define the global variable that the function expects\nALLOWED_FIELDS = ['make', 'model', 'year']\n\nclass TestModifyVehicleData(unittest.TestCase):\n\n    def test_update_one_allowed_field(self):\n        \"\"\"Test updating one allowed field.\"\"\"\n        vehicle = {'make': 'Toyota', 'model': 'Camry', 'year': 2020}\n        modifications = {'model': 'Corolla'}\n        result = modify_vehicle_data(vehicle, modifications)\n        self.assertEqual(result['model'], 'Corolla')\n        self.assertEqual(result['make'], 'Toyota')\n        self.assertEqual(result['year'], 2020)\n\n    def test_update_multiple_allowed_fields(self):\n        \"\"\"Test updating multiple allowed fields.\"\"\"\n        vehicle = {'make': 'Toyota', 'model': 'Camry', 'year': 2020}\n        modifications = {'model': 'Corolla', 'year': 2021}\n        result = modify_vehicle_data(vehicle, modifications)\n        self.assertEqual(result['model'], 'Corolla')\n        self.assertEqual(result['year'], 2021)\n        self.assertEqual(result['make'], 'Toyota')\n\n    def test_mixed_allowed_and_disallowed(self):\n        \"\"\"Test updating with allowed and disallowed fields.\"\"\"\n        vehicle = {'make': 'Toyota', 'model': 'Camry', 'year': 2020}\n        modifications = {'model': 'Corolla', 'color': 'Red'}\n        result = modify_vehicle_data(vehicle, modifications)\n        self.assertEqual(result['model'], 'Corolla')\n        self.assertNotIn('color', result)\n        self.assertEqual(result['year'], 2020)\n        self.assertEqual(result['make'], 'Toyota')\n\n    def test_disallowed_field_only(self):\n        \"\"\"Test updating only disallowed fields leaves vehicle unchanged.\"\"\"\n        vehicle = {'make': 'Toyota', 'model': 'Camry', 'year': 2020}\n        original = vehicle.copy()\n        modifications = {'color': 'Red'}\n        result = modify_vehicle_data(vehicle, modifications)\n        self.assertEqual(result, original)\n\n    def test_empty_modifications(self):\n        \"\"\"Test that empty modifications returns the original vehicle.\"\"\"\n        vehicle = {'make': 'Toyota', 'model': 'Camry', 'year': 2020}\n        original = vehicle.copy()\n        modifications = {}\n        result = modify_vehicle_data(vehicle, modifications)\n        self.assertEqual(result, original)\n\n    def test_add_new_allowed_field(self):\n        \"\"\"Test adding a new allowed field not originally in vehicle.\"\"\"\n        vehicle = {'make': 'Toyota', 'model': 'Camry'}\n        modifications = {'year': 2022}\n        result = modify_vehicle_data(vehicle, modifications)\n        self.assertEqual(result['year'], 2022)\n        self.assertEqual(result['make'], 'Toyota')\n        self.assertEqual(result['model'], 'Camry')\n\n    def test_disallowed_field_not_present(self):\n        \"\"\"Test disallowed field not in vehicle is ignored.\"\"\"\n        vehicle = {'make': 'Toyota', 'model': 'Camry', 'year': 2020}\n        original = vehicle.copy()\n        modifications = {'color': 'Red'}\n        result = modify_vehicle_data(vehicle, modifications)\n        self.assertEqual(result, original)\n        self.assertNotIn('color', result)\n\n    def test_vehicle_info_empty(self):\n        \"\"\"Test updating an initially empty vehicle dictionary.\"\"\"\n        vehicle = {}\n        modifications = {'year': 2022}\n        result = modify_vehicle_data(vehicle, modifications)\n        self.assertEqual(result, {'year': 2022})\n\n    def test_modifications_none(self):\n        \"\"\"Test passing None as modifications raises AttributeError.\"\"\"\n        vehicle = {'make': 'Toyota'}\n        with self.assertRaises(AttributeError):\n            modify_vehicle_data(vehicle, None)\n\n    def test_modifications_not_dict(self):\n        \"\"\"Test non-dict modifications raises TypeError.\"\"\"\n        vehicle = {'make': 'Toyota'}\n        with self.assertRaises(TypeError):\n            modify_vehicle_data(vehicle, 123)\n\n    def test_vehicle_info_none(self):\n        \"\"\"Test passing None as vehicle_info raises TypeError.\"\"\"\n        with self.assertRaises(TypeError):\n            modify_vehicle_data(None, {'year': 2022})\n\n    def test_vehicle_info_not_dict(self):\n        \"\"\"Test non-dict vehicle_info raises TypeError.\"\"\"\n        with self.assertRaises(TypeError):\n            modify_vehicle_data('not a dict', {'year': 2022})\n\n    def test_inplace_update(self):\n        \"\"\"Test that the function modifies and returns the same dictionary.\"\"\"\n        vehicle = {'make': 'Toyota'}\n        modifications = {'year': 2022}\n        result = modify_vehicle_data(vehicle, modifications)\n        self.assertIs(result, vehicle)", "num_test_cases": 13, "task_id": "8056bb18"}
{"test": "import unittest\n\n# Define the global ALLOWED_FIELDS for the test environment\nALLOWED_FIELDS = ['make', 'model', 'year', 'color']\n\n# The function to test (included for self-containment)\ndef modify_auto_data(auto_details: dict, field_updates: dict):\n    for key, value in field_updates.items():\n        if key in ALLOWED_FIELDS:\n            auto_details[key] = value\n    return auto_details\n\nclass TestModifyAutoData(unittest.TestCase):\n    \n    def test_update_existing_allowed_field(self):\n        # Test updating one existing allowed field\n        auto_details = {'make': 'Toyota', 'model': 'Camry', 'year': 2020}\n        field_updates = {'year': 2021}\n        result = modify_auto_data(auto_details, field_updates)\n        self.assertIs(result, auto_details)  # Returns the same instance\n        self.assertEqual(auto_details, {'make': 'Toyota', 'model': 'Camry', 'year': 2021})\n    \n    def test_update_multiple_allowed_fields(self):\n        # Test updating multiple existing allowed fields\n        auto_details = {'make': 'Toyota', 'model': 'Camry', 'year': 2020, 'color': 'blue'}\n        field_updates = {'year': 2021, 'color': 'red'}\n        result = modify_auto_data(auto_details, field_updates)\n        self.assertEqual(auto_details, {'make': 'Toyota', 'model': 'Camry', 'year': 2021, 'color': 'red'})\n    \n    def test_add_new_allowed_field(self):\n        # Test adding a new allowed field that did not exist\n        auto_details = {'make': 'Toyota', 'model': 'Camry', 'year': 2020}\n        field_updates = {'color': 'blue'}\n        result = modify_auto_data(auto_details, field_updates)\n        self.assertEqual(auto_details, {'make': 'Toyota', 'model': 'Camry', 'year': 2020, 'color': 'blue'})\n    \n    def test_ignore_disallowed_field(self):\n        # Test updating a field not in ALLOWED_FIELDS (ignored)\n        auto_details = {'make': 'Toyota', 'model': 'Camry', 'year': 2020, 'owner': 'John'}\n        field_updates = {'owner': 'Jane', 'vin': '12345'}\n        result = modify_auto_data(auto_details, field_updates)\n        self.assertEqual(auto_details, {'make': 'Toyota', 'model': 'Camry', 'year': 2020, 'owner': 'John'})\n    \n    def test_mixed_allowed_and_disallowed_fields(self):\n        # Test a mix of allowed and disallowed updates\n        auto_details = {'make': 'Toyota', 'model': 'Camry', 'year': 2020, 'owner': 'John'}\n        field_updates = {'year': 2021, 'owner': 'Jane', 'color': 'blue'}\n        result = modify_auto_data(auto_details, field_updates)\n        self.assertEqual(auto_details, {'make': 'Toyota', 'model': 'Camry', 'year': 2021, 'owner': 'John', 'color': 'blue'})\n    \n    def test_empty_field_updates(self):\n        # Test empty field_updates: no changes\n        auto_details = {'make': 'Toyota', 'model': 'Camry', 'year': 2020}\n        field_updates = {}\n        original = auto_details.copy()\n        result = modify_auto_data(auto_details, field_updates)\n        self.assertIs(result, auto_details)\n        self.assertEqual(auto_details, original)\n    \n    def test_update_with_none_value(self):\n        # Test updating an allowed field to None\n        auto_details = {'make': 'Toyota', 'model': 'Camry', 'year': 2020}\n        field_updates = {'year': None}\n        result = modify_auto_data(auto_details, field_updates)\n        self.assertEqual(auto_details, {'make': 'Toyota', 'model': 'Camry', 'year': None})\n    \n    def test_add_new_allowed_field_with_none_value(self):\n        # Test adding a new allowed field with None value\n        auto_details = {'make': 'Toyota'}\n        field_updates = {'model': None}\n        result = modify_auto_data(auto_details, field_updates)\n        self.assertEqual(auto_details, {'make': 'Toyota', 'model': None})\n    \n    def test_empty_auto_details(self):\n        # Test updating an empty auto_details with allowed fields\n        auto_details = {}\n        field_updates = {'make': 'Honda', 'year': 2022}\n        result = modify_auto_data(auto_details, field_updates)\n        self.assertEqual(auto_details, {'make': 'Honda', 'year': 2022})\n    \n    def test_non_existent_allowed_and_disallowed(self):\n        # Test updates including non-existent allowed and disallowed fields\n        auto_details = {'make': 'Ford'}\n        field_updates = {'model': 'F-150', 'vin': 'ABCDE'}\n        result = modify_auto_data(auto_details, field_updates)\n        self.assertEqual(auto_details, {'make': 'Ford', 'model': 'F-150'})\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 10, "task_id": "aa0eae37"}
{"test": "import unittest\n\n# Define the global ALLOWED_FIELDS and the function for the tests\nALLOWED_FIELDS = ['make', 'model', 'year']\n\ndef update_car_information(car_details: dict, changes: dict):\n    for key, value in changes.items():\n        if key in ALLOWED_FIELDS:\n            car_details[key] = value\n    return car_details\n\nclass TestUpdateCarInformation(unittest.TestCase):\n    original_allowed_fields = None\n\n    @classmethod\n    def setUpClass(cls):\n        global ALLOWED_FIELDS\n        cls.original_allowed_fields = ALLOWED_FIELDS[:]  # Save a copy of the original\n\n    def setUp(self):\n        global ALLOWED_FIELDS\n        ALLOWED_FIELDS = self.original_allowed_fields[:]  # Reset before each test\n\n    def test_update_one_allowed_field(self):\n        # Test updating one existing allowed field\n        car_details = {'make': 'Toyota', 'model': 'Camry', 'year': 2020}\n        changes = {'year': 2021}\n        expected = {'make': 'Toyota', 'model': 'Camry', 'year': 2021}\n        result = update_car_information(car_details, changes)\n        self.assertEqual(result, expected)\n\n    def test_update_multiple_allowed_fields(self):\n        # Test updating multiple existing allowed fields\n        car_details = {'make': 'Toyota', 'model': 'Camry', 'year': 2020}\n        changes = {'year': 2021, 'model': 'Corolla'}\n        expected = {'make': 'Toyota', 'model': 'Corolla', 'year': 2021}\n        result = update_car_information(car_details, changes)\n        self.assertEqual(result, expected)\n\n    def test_disallowed_field_ignored(self):\n        # Test that a field not in ALLOWED_FIELDS is ignored\n        global ALLOWED_FIELDS\n        ALLOWED_FIELDS = ['make', 'model']  # 'year' is not allowed\n        car_details = {'make': 'Toyota', 'model': 'Camry', 'year': 2020}\n        changes = {'year': 2021}\n        expected = car_details.copy()\n        result = update_car_information(car_details, changes)\n        self.assertEqual(result, expected)\n\n    def test_mixed_allowed_and_disallowed(self):\n        # Test a mix of allowed and disallowed fields in changes\n        global ALLOWED_FIELDS\n        ALLOWED_FIELDS = ['make', 'year']\n        car_details = {'make': 'Toyota', 'model': 'Camry', 'year': 2020}\n        changes = {'make': 'Honda', 'year': 2021, 'color': 'blue'}\n        expected = {'make': 'Honda', 'model': 'Camry', 'year': 2021}\n        result = update_car_information(car_details, changes)\n        self.assertEqual(result, expected)\n\n    def test_add_new_allowed_field(self):\n        # Test adding a new allowed field not originally in car_details\n        global ALLOWED_FIELDS\n        ALLOWED_FIELDS = ['make', 'model', 'year', 'color']\n        car_details = {'make': 'Toyota', 'model': 'Camry', 'year': 2020}\n        changes = {'color': 'red'}\n        expected = {'make': 'Toyota', 'model': 'Camry', 'year': 2020, 'color': 'red'}\n        result = update_car_information(car_details, changes)\n        self.assertEqual(result, expected)\n\n    def test_empty_changes(self):\n        # Test with an empty changes dictionary\n        car_details = {'make': 'Toyota', 'model': 'Camry', 'year': 2020}\n        changes = {}\n        expected = car_details.copy()\n        result = update_car_information(car_details, changes)\n        self.assertEqual(result, expected)\n\n    def test_empty_car_details_with_allowed_change(self):\n        # Test updating an empty car_details with an allowed field\n        global ALLOWED_FIELDS\n        ALLOWED_FIELDS = ['make', 'model']\n        car_details = {}\n        changes = {'make': 'Toyota'}\n        expected = {'make': 'Toyota'}\n        result = update_car_information(car_details, changes)\n        self.assertEqual(result, expected)\n\n    def test_empty_car_details_and_changes(self):\n        # Test with both car_details and changes empty\n        car_details = {}\n        changes = {}\n        expected = {}\n        result = update_car_information(car_details, changes)\n        self.assertEqual(result, expected)\n\n    def test_no_allowed_fields(self):\n        # Test when ALLOWED_FIELDS is empty\n        global ALLOWED_FIELDS\n        ALLOWED_FIELDS = []\n        car_details = {'make': 'Toyota', 'model': 'Camry', 'year': 2020}\n        changes = {'make': 'Honda', 'year': 2021}\n        expected = car_details.copy()\n        result = update_car_information(car_details, changes)\n        self.assertEqual(result, expected)\n\n    def test_none_car_details(self):\n        # Test with car_details as None (should raise TypeError)\n        car_details = None\n        changes = {'make': 'Honda'}\n        with self.assertRaises(TypeError):\n            update_car_information(car_details, changes)\n\n    def test_none_changes(self):\n        # Test with changes as None (should raise AttributeError)\n        car_details = {'make': 'Toyota'}\n        changes = None\n        with self.assertRaises(AttributeError):\n            update_car_information(car_details, changes)\n\n    def test_non_dict_changes(self):\n        # Test with changes as a non-dict type (should raise AttributeError)\n        car_details = {'make': 'Toyota'}\n        changes = [('make', 'Honda')]  # A list instead of dict\n        with self.assertRaises(AttributeError):\n            update_car_information(car_details, changes)\n\n    def test_non_dict_car_details(self):\n        # Test with car_details as a non-dict type (should raise TypeError)\n        car_details = ['Toyota', 'Camry']  # A list instead of dict\n        changes = {'make': 'Honda'}\n        with self.assertRaises(TypeError):\n            update_car_information(car_details, changes)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 14, "task_id": "945d24f4"}
{"test": "import unittest\nfrom unittest.mock import patch\n\nclass TestModifyVehicleData(unittest.TestCase):\n\n    @patch('__main__.ALLOWED_FIELDS', ['make', 'model', 'year'])\n    def test_update_existing_allowed_field(self):\n        \"\"\"Test updating one existing allowed field.\"\"\"\n        vehicle = {'make': 'Toyota', 'model': 'Camry', 'year': 2020}\n        changes = {'make': 'Honda'}\n        result = modify_vehicle_data(vehicle, changes)\n        expected = {'make': 'Honda', 'model': 'Camry', 'year': 2020}\n        self.assertEqual(result, expected)\n        self.assertIs(result, vehicle)\n\n    @patch('__main__.ALLOWED_FIELDS', ['make', 'model', 'year'])\n    def test_update_multiple_allowed_fields(self):\n        \"\"\"Test updating multiple existing allowed fields.\"\"\"\n        vehicle = {'make': 'Toyota', 'model': 'Camry', 'year': 2020}\n        changes = {'make': 'Honda', 'year': 2021}\n        result = modify_vehicle_data(vehicle, changes)\n        expected = {'make': 'Honda', 'model': 'Camry', 'year': 2021}\n        self.assertEqual(result, expected)\n\n    @patch('__main__.ALLOWED_FIELDS', ['make', 'model', 'year', 'color'])\n    def test_add_new_allowed_field(self):\n        \"\"\"Test adding a new allowed field that doesn't exist in the original vehicle_info.\"\"\"\n        vehicle = {'make': 'Toyota', 'model': 'Camry', 'year': 2020}\n        changes = {'color': 'Red'}\n        result = modify_vehicle_data(vehicle, changes)\n        expected = {'make': 'Toyota', 'model': 'Camry', 'year': 2020, 'color': 'Red'}\n        self.assertEqual(result, expected)\n\n    @patch('__main__.ALLOWED_FIELDS', ['make', 'model', 'year'])\n    def test_empty_changes(self):\n        \"\"\"Test applying an empty changes dictionary.\"\"\"\n        vehicle = {'make': 'Toyota', 'model': 'Camry', 'year': 2020}\n        changes = {}\n        result = modify_vehicle_data(vehicle, changes)\n        self.assertEqual(result, vehicle)\n\n    @patch('__main__.ALLOWED_FIELDS', ['make', 'model', 'year'])\n    def test_disallowed_field(self):\n        \"\"\"Test updating a field that is not allowed (should be ignored).\"\"\"\n        vehicle = {'make': 'Toyota', 'model': 'Camry', 'year': 2020}\n        changes = {'color': 'Red'}\n        result = modify_vehicle_data(vehicle, changes)\n        self.assertEqual(result, vehicle)\n\n    @patch('__main__.ALLOWED_FIELDS', ['make', 'year'])\n    def test_mixed_changes(self):\n        \"\"\"Test a mix of allowed and disallowed fields.\"\"\"\n        vehicle = {'make': 'Toyota', 'model': 'Camry', 'year': 2020}\n        changes = {'make': 'Honda', 'color': 'Red', 'year': 2021}\n        result = modify_vehicle_data(vehicle, changes)\n        expected = {'make': 'Honda', 'model': 'Camry', 'year': 2021}\n        self.assertEqual(result, expected)\n\n    @patch('__main__.ALLOWED_FIELDS', ['make', 'model'])\n    def test_empty_vehicle_info(self):\n        \"\"\"Test updating an empty vehicle_info dictionary with allowed fields.\"\"\"\n        vehicle = {}\n        changes = {'make': 'Honda', 'model': 'Accord'}\n        result = modify_vehicle_data(vehicle, changes)\n        expected = {'make': 'Honda', 'model': 'Accord'}\n        self.assertEqual(result, expected)\n\n    @patch('__main__.ALLOWED_FIELDS', [])\n    def test_empty_allowed_fields(self):\n        \"\"\"Test when there are no allowed fields, so no changes should be made.\"\"\"\n        vehicle = {'make': 'Toyota', 'model': 'Camry', 'year': 2020}\n        changes = {'make': 'Honda', 'year': 2021}\n        result = modify_vehicle_data(vehicle, changes)\n        self.assertEqual(result, vehicle)\n\n    @patch('__main__.ALLOWED_FIELDS', ['make'])\n    def test_vehicle_info_not_dict(self):\n        \"\"\"Test passing a non-dictionary for vehicle_info (None).\"\"\"\n        with self.assertRaises(TypeError):\n            modify_vehicle_data(None, {'make': 'Toyota'})\n\n    @patch('__main__.ALLOWED_FIELDS', ['make'])\n    def test_changes_to_apply_none(self):\n        \"\"\"Test passing None for changes_to_apply.\"\"\"\n        with self.assertRaises(AttributeError):\n            modify_vehicle_data({'make': 'Toyota'}, None)\n\n    @patch('__main__.ALLOWED_FIELDS', ['make'])\n    def test_changes_to_apply_non_dict(self):\n        \"\"\"Test passing a non-dictionary (string) for changes_to_apply.\"\"\"\n        with self.assertRaises(AttributeError):\n            modify_vehicle_data({'make': 'Toyota'}, 'make=Toyota')", "num_test_cases": 11, "task_id": "5cb51c77"}
{"test": "import unittest\n\n# Define the global constant as specified\nEDITABLE_FIELDS = {'name', 'position', 'department'}\n\nclass TestModifyEmployeeProfile(unittest.TestCase):\n    \n    def test_non_privileged_editable_existing(self):\n        # Test non-admin updating existing editable field\n        worker = {'name': 'John Doe', 'position': 'Engineer', 'salary': 70000}\n        changes = {'name': 'Jane Smith'}\n        expected = {'name': 'Jane Smith', 'position': 'Engineer', 'salary': 70000}\n        result = modify_employee_profile(worker, changes, False)\n        self.assertEqual(result, expected)\n\n    def test_non_privileged_non_editable_existing(self):\n        # Test non-admin updating existing non-editable field (should be ignored)\n        worker = {'name': 'John Doe', 'position': 'Engineer', 'salary': 70000}\n        changes = {'salary': 75000}\n        expected = {'name': 'John Doe', 'position': 'Engineer', 'salary': 70000}\n        result = modify_employee_profile(worker, changes, False)\n        self.assertEqual(result, expected)\n\n    def test_non_privileged_editable_new(self):\n        # Test non-admin adding new field that is in EDITABLE_FIELDS\n        worker = {'name': 'John Doe'}  # department is missing\n        changes = {'department': 'Engineering'}\n        expected = {'name': 'John Doe', 'department': 'Engineering'}\n        result = modify_employee_profile(worker, changes, False)\n        self.assertEqual(result, expected)\n\n    def test_non_privileged_non_editable_new(self):\n        # Test non-admin adding new field not in EDITABLE_FIELDS (ignored)\n        worker = {'name': 'John Doe'}\n        changes = {'age': 30}\n        expected = {'name': 'John Doe'}\n        result = modify_employee_profile(worker, changes, False)\n        self.assertEqual(result, expected)\n\n    def test_privileged_editable_existing(self):\n        # Test admin updating existing editable field\n        worker = {'name': 'John Doe', 'position': 'Engineer'}\n        changes = {'name': 'Jane Smith'}\n        expected = {'name': 'Jane Smith', 'position': 'Engineer'}\n        result = modify_employee_profile(worker, changes, True)\n        self.assertEqual(result, expected)\n\n    def test_privileged_non_editable_existing(self):\n        # Test admin updating existing non-editable field\n        worker = {'name': 'John Doe', 'salary': 70000}\n        changes = {'salary': 75000}\n        expected = {'name': 'John Doe', 'salary': 75000}\n        result = modify_employee_profile(worker, changes, True)\n        self.assertEqual(result, expected)\n\n    def test_privileged_new_field(self):\n        # Test admin adding a new field\n        worker = {'name': 'John Doe'}\n        changes = {'age': 30}\n        expected = {'name': 'John Doe', 'age': 30}\n        result = modify_employee_profile(worker, changes, True)\n        self.assertEqual(result, expected)\n\n    def test_non_privileged_mixed_changes(self):\n        # Test non-admin with mixed editable and non-editable changes\n        worker = {'name': 'John Doe', 'position': 'Engineer', 'salary': 70000}\n        changes = {'name': 'Jane Smith', 'salary': 75000, 'department': 'HR'}\n        expected = {'name': 'Jane Smith', 'position': 'Engineer', 'salary': 70000, 'department': 'HR'}\n        result = modify_employee_profile(worker, changes, False)\n        self.assertEqual(result, expected)\n\n    def test_privileged_mixed_changes(self):\n        # Test admin with mixed changes\n        worker = {'name': 'John Doe', 'salary': 70000}\n        changes = {'name': 'Jane Smith', 'salary': 75000, 'department': 'HR'}\n        expected = {'name': 'Jane Smith', 'salary': 75000, 'department': 'HR'}\n        result = modify_employee_profile(worker, changes, True)\n        self.assertEqual(result, expected)\n\n    def test_empty_changes(self):\n        # Test with empty changes dictionary\n        worker = {'name': 'John Doe', 'position': 'Engineer'}\n        changes = {}\n        expected = worker.copy()\n        result = modify_employee_profile(worker, changes, False)\n        self.assertEqual(result, expected)\n\n    def test_non_privileged_set_editable_to_none(self):\n        # Test non-admin setting editable field to None\n        worker = {'name': 'John Doe', 'department': 'Engineering'}\n        changes = {'department': None}\n        expected = {'name': 'John Doe', 'department': None}\n        result = modify_employee_profile(worker, changes, False)\n        self.assertEqual(result, expected)\n\n    def test_privileged_set_non_editable_to_list(self):\n        # Test admin setting non-editable field to a list\n        worker = {'name': 'John Doe', 'salary': 70000}\n        changes = {'salary': [70000, 75000]}\n        expected = {'name': 'John Doe', 'salary': [70000, 75000]}\n        result = modify_employee_profile(worker, changes, True)\n        self.assertEqual(result, expected)\n\n    def test_non_privileged_large_value(self):\n        # Test non-admin updating with a large string value\n        worker = {'name': 'John Doe'}\n        large_str = 'A' * 10000\n        changes = {'name': large_str}\n        expected = {'name': large_str}\n        result = modify_employee_profile(worker, changes, False)\n        self.assertEqual(result, expected)\n\n    def test_privileged_change_social_security_number(self):\n        # Test admin changing a sensitive field\n        worker = {'name': 'John Doe', 'social_security_number': '123-45-6789'}\n        changes = {'social_security_number': '987-65-4321'}\n        expected = {'name': 'John Doe', 'social_security_number': '987-65-4321'}\n        result = modify_employee_profile(worker, changes, True)\n        self.assertEqual(result, expected)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 14, "task_id": "c0648a46"}
{"test": "import unittest\n\nEDITABLE_FIELDS = ['name', 'position', 'department']\n\nclass TestEditProfileData(unittest.TestCase):\n\n    def test_case_1(self):\n        # Non-admin updating an allowed field (name)\n        profile = {'name': 'John', 'position': 'Dev', 'department': 'IT', 'salary': 50000}\n        modifications = {'name': 'Jane'}\n        result = edit_profile_data(profile, modifications, False)\n        self.assertEqual(result['name'], 'Jane')\n        self.assertEqual(result['salary'], 50000)\n\n    def test_case_2(self):\n        # Non-admin updating a disallowed field (salary)\n        profile = {'name': 'John', 'position': 'Dev', 'department': 'IT', 'salary': 50000}\n        modifications = {'salary': 60000}\n        result = edit_profile_data(profile, modifications, False)\n        self.assertEqual(result['salary'], 50000)\n\n    def test_case_3(self):\n        # Non-admin updating mixed fields (allowed and disallowed)\n        profile = {'name': 'John', 'position': 'Dev', 'department': 'IT', 'salary': 50000}\n        modifications = {'name': 'Jane', 'salary': 60000}\n        result = edit_profile_data(profile, modifications, False)\n        self.assertEqual(result['name'], 'Jane')\n        self.assertEqual(result['salary'], 50000)\n\n    def test_case_4(self):\n        # Admin updating an allowed field (name)\n        profile = {'name': 'John', 'position': 'Dev', 'department': 'IT', 'salary': 50000}\n        modifications = {'name': 'Jane'}\n        result = edit_profile_data(profile, modifications, True)\n        self.assertEqual(result['name'], 'Jane')\n\n    def test_case_5(self):\n        # Admin updating a disallowed field (salary)\n        profile = {'name': 'John', 'position': 'Dev', 'department': 'IT', 'salary': 50000}\n        modifications = {'salary': 60000}\n        result = edit_profile_data(profile, modifications, True)\n        self.assertEqual(result['salary'], 60000)\n\n    def test_case_6(self):\n        # Admin updating mixed fields\n        profile = {'name': 'John', 'position': 'Dev', 'department': 'IT', 'salary': 50000}\n        modifications = {'name': 'Jane', 'salary': 60000}\n        result = edit_profile_data(profile, modifications, True)\n        self.assertEqual(result['name'], 'Jane')\n        self.assertEqual(result['salary'], 60000)\n\n    def test_case_7(self):\n        # Non-admin with empty modifications\n        profile = {'name': 'John', 'position': 'Dev', 'department': 'IT', 'salary': 50000}\n        original = profile.copy()\n        modifications = {}\n        result = edit_profile_data(profile, modifications, False)\n        self.assertEqual(result, original)\n\n    def test_case_8(self):\n        # Admin with empty modifications\n        profile = {'name': 'John', 'position': 'Dev', 'department': 'IT', 'salary': 50000}\n        original = profile.copy()\n        modifications = {}\n        result = edit_profile_data(profile, modifications, True)\n        self.assertEqual(result, original)\n\n    def test_case_9(self):\n        # Non-admin adding a new allowed field (position) to an incomplete profile\n        profile = {'name': 'John', 'department': 'IT', 'salary': 50000}\n        modifications = {'position': 'Manager'}\n        result = edit_profile_data(profile, modifications, False)\n        self.assertEqual(result['position'], 'Manager')\n        self.assertEqual(result['name'], 'John')\n        self.assertEqual(result['department'], 'IT')\n        self.assertEqual(result['salary'], 50000)\n\n    def test_case_10(self):\n        # Non-admin adding a new disallowed field (email) to an incomplete profile\n        profile = {'name': 'John', 'department': 'IT', 'salary': 50000}\n        modifications = {'email': 'john@example.com'}\n        result = edit_profile_data(profile, modifications, False)\n        self.assertNotIn('email', result)\n\n    def test_case_11(self):\n        # Admin adding new fields (both allowed and disallowed) to an incomplete profile\n        profile = {'name': 'John', 'department': 'IT'}\n        modifications = {'position': 'Manager', 'salary': 60000}\n        result = edit_profile_data(profile, modifications, True)\n        self.assertEqual(result['position'], 'Manager')\n        self.assertEqual(result['salary'], 60000)\n        self.assertEqual(result['name'], 'John')\n        self.assertEqual(result['department'], 'IT')\n\n    def test_case_12(self):\n        # Non-admin updating a disallowed field in an empty profile\n        profile = {}\n        modifications = {'salary': 50000}\n        result = edit_profile_data(profile, modifications, False)\n        self.assertEqual(result, {})\n\n    def test_case_13(self):\n        # Admin adding fields to an empty profile\n        profile = {}\n        modifications = {'name': 'John', 'salary': 50000}\n        result = edit_profile_data(profile, modifications, True)\n        self.assertEqual(result, {'name': 'John', 'salary': 50000})\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 13, "task_id": "29d7a8e3"}
{"test": "import unittest\n\n# Define the global constant and the function for the test\nEDITABLE_FIELDS = ['name', 'position', 'department']\n\ndef adjust_employee_details(person: dict, alterations: dict, has_admin_rights: bool):\n    if has_admin_rights:\n        person.update(alterations)\n    else:\n        for key, value in alterations.items():\n            if key in EDITABLE_FIELDS:\n                person[key] = value\n    return person\n\nclass TestAdjustEmployeeDetails(unittest.TestCase):\n    \n    def test_admin_update_existing_fields(self):\n        # Admin can update any existing fields (editable or not).\n        person = {'name': 'John', 'salary': 50000}\n        alterations = {'name': 'Alice', 'salary': 60000}\n        result = adjust_employee_details(person, alterations, True)\n        self.assertEqual(result, {'name': 'Alice', 'salary': 60000})\n    \n    def test_admin_update_with_empty_alterations(self):\n        # Admin: empty alterations should not change the person.\n        person = {'name': 'John'}\n        alterations = {}\n        result = adjust_employee_details(person, alterations, True)\n        self.assertEqual(result, {'name': 'John'})\n    \n    def test_admin_add_new_field(self):\n        # Admin can add a new field.\n        person = {'name': 'John'}\n        alterations = {'new_field': 'value'}\n        result = adjust_employee_details(person, alterations, True)\n        self.assertEqual(result, {'name': 'John', 'new_field': 'value'})\n    \n    def test_admin_alterations_none(self):\n        # Admin: alterations as None should raise TypeError.\n        person = {'name': 'John'}\n        with self.assertRaises(TypeError):\n            adjust_employee_details(person, None, True)\n    \n    def test_admin_alterations_integer(self):\n        # Admin: alterations as integer should raise TypeError.\n        person = {'name': 'John'}\n        with self.assertRaises(TypeError):\n            adjust_employee_details(person, 123, True)\n    \n    def test_non_admin_update_editable_existing_field(self):\n        # Non-admin can update an existing editable field.\n        person = {'name': 'John', 'salary': 50000}\n        alterations = {'name': 'Alice'}\n        result = adjust_employee_details(person, alterations, False)\n        self.assertEqual(result, {'name': 'Alice', 'salary': 50000})\n    \n    def test_non_admin_update_non_editable_field(self):\n        # Non-admin cannot update a non-editable field (existing).\n        person = {'name': 'John', 'salary': 50000}\n        alterations = {'salary': 60000}\n        result = adjust_employee_details(person, alterations, False)\n        self.assertEqual(result, {'name': 'John', 'salary': 50000})\n    \n    def test_non_admin_add_editable_field(self):\n        # Non-admin can add a new field if it is in EDITABLE_FIELDS.\n        person = {'name': 'John'}\n        alterations = {'position': 'Manager'}\n        result = adjust_employee_details(person, alterations, False)\n        self.assertEqual(result, {'name': 'John', 'position': 'Manager'})\n    \n    def test_non_admin_add_non_editable_field(self):\n        # Non-admin cannot add a new field not in EDITABLE_FIELDS.\n        person = {'name': 'John'}\n        alterations = {'salary': 50000}\n        result = adjust_employee_details(person, alterations, False)\n        self.assertEqual(result, {'name': 'John'})\n    \n    def test_non_admin_mixed_alterations(self):\n        # Non-admin: mixed alterations (editable and non-editable) only updates editable.\n        person = {'name': 'John', 'department': 'HR', 'salary': 50000}\n        alterations = {\n            'name': 'Alice',\n            'department': 'Finance',\n            'salary': 60000,\n            'position': 'Manager',\n            'new_field': 'value'\n        }\n        result = adjust_employee_details(person, alterations, False)\n        expected = {\n            'name': 'Alice',\n            'department': 'Finance',\n            'salary': 50000,\n            'position': 'Manager'\n        }\n        self.assertEqual(result, expected)\n    \n    def test_non_admin_empty_alterations(self):\n        # Non-admin: empty alterations should not change the person.\n        person = {'name': 'John'}\n        alterations = {}\n        result = adjust_employee_details(person, alterations, False)\n        self.assertEqual(result, {'name': 'John'})\n    \n    def test_non_admin_alterations_none(self):\n        # Non-admin: alterations as None should raise AttributeError.\n        person = {'name': 'John'}\n        with self.assertRaises(AttributeError):\n            adjust_employee_details(person, None, False)\n    \n    def test_non_admin_alterations_integer(self):\n        # Non-admin: alterations as integer should raise AttributeError.\n        person = {'name': 'John'}\n        with self.assertRaises(AttributeError):\n            adjust_employee_details(person, 123, False)\n    \n    def test_return_same_dictionary_admin(self):\n        # The function should return the same dictionary object (admin).\n        person = {'name': 'John'}\n        alterations = {'name': 'Alice'}\n        result = adjust_employee_details(person, alterations, True)\n        self.assertIs(result, person)\n    \n    def test_return_same_dictionary_non_admin(self):\n        # The function should return the same dictionary object (non-admin).\n        person = {'name': 'John'}\n        alterations = {'name': 'Alice'}\n        result = adjust_employee_details(person, alterations, False)\n        self.assertIs(result, person)\n", "num_test_cases": 15, "task_id": "7886d9ec"}
{"test": "import unittest\n\n# Define the global EDITABLE_FIELDS\nEDITABLE_FIELDS = {'name', 'position', 'department'}\n\nclass TestModifyEmployeeData(unittest.TestCase):\n    \n    def test_admin_updates_existing_fields(self):\n        # Admin can update existing fields (editable and non-editable)\n        worker = {'name': 'John', 'position': 'Manager', 'salary': 50000}\n        alterations = {'name': 'John Doe', 'salary': 60000}\n        result = modify_employee_data(worker, alterations, True)\n        expected = {'name': 'John Doe', 'position': 'Manager', 'salary': 60000}\n        self.assertEqual(result, expected)\n    \n    def test_admin_adds_new_fields(self):\n        # Admin can add new fields (editable and non-editable)\n        worker = {'name': 'John'}\n        alterations = {'email': 'john@example.com', 'salary': 100000}\n        result = modify_employee_data(worker, alterations, True)\n        expected = {'name': 'John', 'email': 'john@example.com', 'salary': 100000}\n        self.assertEqual(result, expected)\n    \n    def test_non_admin_updates_editable_fields(self):\n        # Non-admin can update existing editable fields and add new editable fields\n        worker = {'name': 'John', 'position': 'Manager', 'salary': 50000}\n        alterations = {'name': 'John Doe', 'department': 'HR', 'salary': 60000}\n        result = modify_employee_data(worker, alterations, False)\n        expected = {'name': 'John Doe', 'position': 'Manager', 'salary': 50000, 'department': 'HR'}\n        self.assertEqual(result, expected)\n    \n    def test_non_admin_ignores_non_editable_fields(self):\n        # Non-admin cannot update existing non-editable fields\n        worker = {'name': 'John', 'salary': 50000}\n        alterations = {'salary': 60000}\n        result = modify_employee_data(worker, alterations, False)\n        self.assertEqual(result, {'name': 'John', 'salary': 50000})\n    \n    def test_non_admin_mixed_editable_non_editable(self):\n        # Non-admin updates only editable fields among mixed alterations\n        worker = {'name': 'John', 'position': 'Manager', 'salary': 50000}\n        alterations = {'name': 'John Doe', 'position': 'Senior Manager', 'salary': 60000, 'social_security_number': '123-45-6789'}\n        result = modify_employee_data(worker, alterations, False)\n        expected = {'name': 'John Doe', 'position': 'Senior Manager', 'salary': 50000}\n        self.assertEqual(result, expected)\n    \n    def test_admin_empty_alterations(self):\n        # Admin with empty alterations leaves worker unchanged\n        worker = {'name': 'John'}\n        alterations = {}\n        result = modify_employee_data(worker, alterations, True)\n        self.assertEqual(result, {'name': 'John'})\n    \n    def test_non_admin_empty_alterations(self):\n        # Non-admin with empty alterations leaves worker unchanged\n        worker = {'name': 'John'}\n        alterations = {}\n        result = modify_employee_data(worker, alterations, False)\n        self.assertEqual(result, {'name': 'John'})\n    \n    def test_non_admin_adds_editable_field(self):\n        # Non-admin can add a new field that is editable\n        worker = {'name': 'John'}\n        alterations = {'department': 'IT'}\n        result = modify_employee_data(worker, alterations, False)\n        self.assertEqual(result, {'name': 'John', 'department': 'IT'})\n    \n    def test_non_admin_ignores_new_non_editable_field(self):\n        # Non-admin cannot add a new non-editable field\n        worker = {'name': 'John'}\n        alterations = {'email': 'john@example.com'}\n        result = modify_employee_data(worker, alterations, False)\n        self.assertEqual(result, {'name': 'John'})\n    \n    def test_admin_mixed_new_existing_fields(self):\n        # Admin can update both editable and non-editable fields (existing and new)\n        worker = {'name': 'John'}\n        alterations = {'name': 'John Doe', 'salary': 60000}\n        result = modify_employee_data(worker, alterations, True)\n        expected = {'name': 'John Doe', 'salary': 60000}\n        self.assertEqual(result, expected)\n    \n    def test_worker_none(self):\n        # Worker as None raises AttributeError\n        with self.assertRaises(AttributeError):\n            modify_employee_data(None, {'name': 'John'}, True)\n    \n    def test_alterations_none(self):\n        # Alterations as None raises TypeError\n        with self.assertRaises(TypeError):\n            modify_employee_data({'name': 'John'}, None, True)\n    \n    def test_admin_privileges_none(self):\n        # None for admin_privileges treated as non-admin (falsy)\n        worker = {'name': 'John'}\n        alterations = {'name': 'Jane'}\n        result = modify_employee_data(worker, alterations, None)\n        self.assertEqual(result, {'name': 'Jane'})\n    \n    def test_admin_privileges_truthy_non_bool(self):\n        # Truthy non-bool admin_privileges (1) treated as admin\n        worker = {'name': 'John'}\n        alterations = {'salary': 60000}\n        result = modify_employee_data(worker, alterations, 1)\n        self.assertEqual(result, {'name': 'John', 'salary': 60000})\n    \n    def test_admin_privileges_falsy_non_bool(self):\n        # Falsy non-bool admin_privileges (0) treated as non-admin\n        worker = {'name': 'John'}\n        alterations = {'salary': 60000}\n        result = modify_employee_data(worker, alterations, 0)\n        self.assertEqual(result, {'name': 'John'})\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 15, "task_id": "ed5c4791"}
{"test": "import unittest\n\n# Define the global EDITABLE_FIELDS as specified in the task\nEDITABLE_FIELDS = {'name', 'position', 'department'}\n\nclass TestAdjustEmployeeProfile(unittest.TestCase):\n    \n    def test_admin_can_change_editable_field(self):\n        # Admin should be able to edit existing editable field\n        emp = {'name': 'John', 'position': 'Engineer'}\n        changes = {'name': 'John Doe'}\n        result = adjust_employee_profile(emp, changes, True)\n        self.assertEqual(result['name'], 'John Doe')\n    \n    def test_admin_can_change_non_editable_field(self):\n        # Admin should be able to edit existing non-editable field\n        emp = {'name': 'John', 'salary': 50000}\n        changes = {'salary': 60000}\n        result = adjust_employee_profile(emp, changes, True)\n        self.assertEqual(result['salary'], 60000)\n    \n    def test_admin_can_add_non_editable_field(self):\n        # Admin should be able to add new non-editable field\n        emp = {'name': 'John'}\n        changes = {'salary': 50000}\n        result = adjust_employee_profile(emp, changes, True)\n        self.assertEqual(result['salary'], 50000)\n    \n    def test_non_admin_can_change_editable_field(self):\n        # Non-admin should be able to edit existing editable field\n        emp = {'name': 'John', 'position': 'Engineer'}\n        changes = {'position': 'Senior Engineer'}\n        result = adjust_employee_profile(emp, changes, False)\n        self.assertEqual(result['position'], 'Senior Engineer')\n    \n    def test_non_admin_cannot_change_non_editable_field(self):\n        # Non-admin should not be able to edit existing non-editable field\n        emp = {'name': 'John', 'salary': 50000}\n        changes = {'salary': 60000}\n        result = adjust_employee_profile(emp, changes, False)\n        self.assertEqual(result['salary'], 50000)\n    \n    def test_non_admin_can_add_editable_field(self):\n        # Non-admin should be able to add new editable field\n        emp = {'name': 'John'}\n        changes = {'department': 'Engineering'}\n        result = adjust_employee_profile(emp, changes, False)\n        self.assertEqual(result['department'], 'Engineering')\n    \n    def test_non_admin_cannot_add_non_editable_field(self):\n        # Non-admin should not be able to add new non-editable field\n        emp = {'name': 'John'}\n        changes = {'salary': 50000}\n        result = adjust_employee_profile(emp, changes, False)\n        self.assertNotIn('salary', result)\n    \n    def test_non_admin_mixed_changes(self):\n        # Non-admin with mixed editable and non-editable changes\n        emp = {'name': 'John', 'salary': 50000}\n        changes = {\n            'name': 'John Doe',\n            'salary': 60000,\n            'department': 'IT',\n            'phone': '123-456-7890'\n        }\n        result = adjust_employee_profile(emp, changes, False)\n        self.assertEqual(result['name'], 'John Doe')\n        self.assertEqual(result['department'], 'IT')\n        self.assertEqual(result['salary'], 50000)\n        self.assertNotIn('phone', result)\n    \n    def test_admin_empty_changes(self):\n        # Admin with empty changes should leave employee unchanged\n        emp = {'name': 'John'}\n        changes = {}\n        result = adjust_employee_profile(emp, changes, True)\n        self.assertEqual(result, {'name': 'John'})\n    \n    def test_non_admin_empty_changes(self):\n        # Non-admin with empty changes should leave employee unchanged\n        emp = {'name': 'John'}\n        changes = {}\n        result = adjust_employee_profile(emp, changes, False)\n        self.assertEqual(result, {'name': 'John'})\n    \n    def test_returns_same_dictionary(self):\n        # Function should return the same dictionary object (in-place update)\n        emp = {'name': 'John'}\n        changes = {'name': 'Jane'}\n        result = adjust_employee_profile(emp, changes, False)\n        self.assertIs(result, emp)\n    \n    def test_non_admin_empty_employee_add_editable(self):\n        # Non-admin adding editable field to empty employee\n        emp = {}\n        changes = {'name': 'John'}\n        result = adjust_employee_profile(emp, changes, False)\n        self.assertEqual(result['name'], 'John')\n    \n    def test_non_admin_empty_employee_add_non_editable(self):\n        # Non-admin adding non-editable field to empty employee (should be ignored)\n        emp = {}\n        changes = {'salary': 50000}\n        result = adjust_employee_profile(emp, changes, False)\n        self.assertEqual(result, {})\n    \n    def test_admin_empty_employee(self):\n        # Admin adding field to empty employee\n        emp = {}\n        changes = {'salary': 50000}\n        result = adjust_employee_profile(emp, changes, True)\n        self.assertEqual(result['salary'], 50000)\n    \n    def test_emp_none(self):\n        # Passing None as emp should raise AttributeError\n        with self.assertRaises(AttributeError):\n            adjust_employee_profile(None, {'name': 'John'}, True)\n    \n    def test_changes_none_admin(self):\n        # Admin passing None as changes should raise TypeError\n        emp = {'name': 'John'}\n        with self.assertRaises(TypeError):\n            adjust_employee_profile(emp, None, True)\n    \n    def test_changes_none_non_admin(self):\n        # Non-admin passing None as changes should raise TypeError\n        emp = {'name': 'John'}\n        with self.assertRaises(TypeError):\n            adjust_employee_profile(emp, None, False)\n", "num_test_cases": 17, "task_id": "27494fba"}
{"test": "import unittest\nfrom unittest.mock import patch\n\n# Import the function to test - assuming it's in a module named 'staff'\nfrom staff import modify_staff_details\n\nclass TestStaffModification(unittest.TestCase):\n\n    def test_superuser_can_change_any_field(self):\n        # Test superuser can modify any field including non-editable ones\n        employee_data = {'name': 'John', 'position': 'Manager', 'salary': 50000, 'department': 'HR'}\n        changes = {'name': 'John Doe', 'salary': 60000, 'new_field': 'value'}\n        expected = {'name': 'John Doe', 'position': 'Manager', 'salary': 60000, 'department': 'HR', 'new_field': 'value'}\n        with patch('staff.EDITABLE_FIELDS', {'name', 'position', 'department'}):\n            result = modify_staff_details(employee_data, changes, True)\n        self.assertEqual(result, expected)\n\n    def test_regular_user_can_change_editable_field(self):\n        # Test regular user can modify editable fields\n        employee_data = {'name': 'John', 'position': 'Manager', 'salary': 50000, 'department': 'HR'}\n        changes = {'name': 'John Doe'}\n        expected = {'name': 'John Doe', 'position': 'Manager', 'salary': 50000, 'department': 'HR'}\n        with patch('staff.EDITABLE_FIELDS', {'name', 'position', 'department'}):\n            result = modify_staff_details(employee_data, changes, False)\n        self.assertEqual(result, expected)\n\n    def test_regular_user_cannot_change_non_editable_field(self):\n        # Test regular user cannot modify non-editable fields\n        employee_data = {'name': 'John', 'position': 'Manager', 'salary': 50000, 'department': 'HR'}\n        changes = {'salary': 60000}\n        expected = employee_data.copy()\n        with patch('staff.EDITABLE_FIELDS', {'name', 'position', 'department'}):\n            result = modify_staff_details(employee_data, changes, False)\n        self.assertEqual(result, expected)\n\n    def test_regular_user_mixed_changes(self):\n        # Test regular user can change editable fields while ignoring non-editable\n        employee_data = {'name': 'John', 'position': 'Manager', 'salary': 50000, 'department': 'HR'}\n        changes = {'name': 'John Doe', 'salary': 60000}\n        expected = {'name': 'John Doe', 'position': 'Manager', 'salary': 50000, 'department': 'HR'}\n        with patch('staff.EDITABLE_FIELDS', {'name', 'position', 'department'}):\n            result = modify_staff_details(employee_data, changes, False)\n        self.assertEqual(result, expected)\n\n    def test_superuser_empty_changes(self):\n        # Test superuser with no changes leaves data unchanged\n        employee_data = {'name': 'John', 'position': 'Manager', 'salary': 50000, 'department': 'HR'}\n        changes = {}\n        expected = employee_data.copy()\n        with patch('staff.EDITABLE_FIELDS', {'name', 'position', 'department'}):\n            result = modify_staff_details(employee_data, changes, True)\n        self.assertEqual(result, expected)\n\n    def test_regular_user_empty_changes(self):\n        # Test regular user with no changes leaves data unchanged\n        employee_data = {'name': 'John', 'position': 'Manager', 'salary': 50000, 'department': 'HR'}\n        changes = {}\n        expected = employee_data.copy()\n        with patch('staff.EDITABLE_FIELDS', {'name', 'position', 'department'}):\n            result = modify_staff_details(employee_data, changes, False)\n        self.assertEqual(result, expected)\n\n    def test_regular_user_add_new_editable_field(self):\n        # Test regular user can add a new field if it's editable\n        employee_data = {'name': 'John', 'position': 'Manager', 'department': 'HR'}\n        changes = {'new_field': 'value'}\n        expected = {'name': 'John', 'position': 'Manager', 'department': 'HR', 'new_field': 'value'}\n        with patch('staff.EDITABLE_FIELDS', {'name', 'position', 'department', 'new_field'}):\n            result = modify_staff_details(employee_data, changes, False)\n        self.assertEqual(result, expected)\n\n    def test_regular_user_cannot_add_new_non_editable_field(self):\n        # Test regular user cannot add a new non-editable field\n        employee_data = {'name': 'John', 'position': 'Manager', 'department': 'HR'}\n        changes = {'new_field': 'value'}\n        expected = employee_data.copy()\n        with patch('staff.EDITABLE_FIELDS', {'name', 'position', 'department'}):\n            result = modify_staff_details(employee_data, changes, False)\n        self.assertEqual(result, expected)\n\n    def test_superuser_on_empty_employee_data(self):\n        # Test superuser can add fields to empty employee data\n        employee_data = {}\n        changes = {'name': 'John', 'salary': 50000}\n        expected = {'name': 'John', 'salary': 50000}\n        with patch('staff.EDITABLE_FIELDS', {'name', 'position', 'department'}):\n            result = modify_staff_details(employee_data, changes, True)\n        self.assertEqual(result, expected)\n\n    def test_regular_user_on_empty_employee_data(self):\n        # Test regular user can only add editable fields to empty data\n        employee_data = {}\n        changes = {'name': 'John', 'salary': 50000}\n        expected = {'name': 'John'}\n        with patch('staff.EDITABLE_FIELDS', {'name', 'position', 'department'}):\n            result = modify_staff_details(employee_data, changes, False)\n        self.assertEqual(result, expected)\n\n    def test_returns_same_dict_instance(self):\n        # Test function returns the same dictionary instance passed in\n        employee_data = {'name': 'John'}\n        changes = {'name': 'Jane'}\n        with patch('staff.EDITABLE_FIELDS', {'name'}):\n            result = modify_staff_details(employee_data, changes, False)\n        self.assertIs(result, employee_data)\n\n    def test_regular_user_cannot_modify_social_security_number(self):\n        # Test regular user cannot modify sensitive non-editable field\n        employee_data = {'name': 'John', 'social_security_number': '123-45-6789'}\n        changes = {'social_security_number': '987-65-4321'}\n        expected = employee_data.copy()\n        with patch('staff.EDITABLE_FIELDS', {'name'}):\n            result = modify_staff_details(employee_data, changes, False)\n        self.assertEqual(result, expected)\n\n    def test_superuser_can_modify_social_security_number(self):\n        # Test superuser can modify sensitive fields\n        employee_data = {'name': 'John', 'social_security_number': '123-45-6789'}\n        changes = {'social_security_number': '987-65-4321'}\n        expected = {'name': 'John', 'social_security_number': '987-65-4321'}\n        with patch('staff.EDITABLE_FIELDS', {'name'}):\n            result = modify_staff_details(employee_data, changes, True)\n        self.assertEqual(result, expected)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 13, "task_id": "3b3e57d2"}
{"test": "import unittest\nfrom unittest.mock import patch\n\n# Import the function from a module named 'solution'. Adjust if necessary.\n# For the purpose of self-containment in the test environment, we assume the function is available.\nfrom solution import modify_staff_info\n\n# Define the EDITABLE_FIELDS for testing. We'll patch it in the module where the function is defined.\nEDITABLE_FIELDS = {'name', 'position', 'department'}\n\nclass TestModifyStaffInfo(unittest.TestCase):\n\n    @classmethod\n    def setUpClass(cls):\n        # Patch the EDITABLE_FIELDS in the solution module for all tests\n        cls.patcher = patch('solution.EDITABLE_FIELDS', EDITABLE_FIELDS)\n        cls.patcher.start()\n\n    @classmethod\n    def tearDownClass(cls):\n        cls.patcher.stop()\n\n    def test_admin_update_existing_fields(self):\n        # Admin can update existing fields.\n        staff = {'name': 'John', 'position': 'Engineer', 'salary': 5000}\n        changes = {'name': 'John Doe', 'position': 'Senior Engineer'}\n        result = modify_staff_info(staff, changes, True)\n        expected = {'name': 'John Doe', 'position': 'Senior Engineer', 'salary': 5000}\n        self.assertEqual(result, expected)\n\n    def test_admin_add_new_fields(self):\n        # Admin can add new fields.\n        staff = {'name': 'John'}\n        changes = {'department': 'IT', 'salary': 5000}\n        result = modify_staff_info(staff, changes, True)\n        expected = {'name': 'John', 'department': 'IT', 'salary': 5000}\n        self.assertEqual(result, expected)\n\n    def test_non_admin_update_editable_existing(self):\n        # Non-admin can update existing editable field.\n        staff = {'name': 'John', 'position': 'Engineer'}\n        changes = {'name': 'John Doe'}\n        result = modify_staff_info(staff, changes, False)\n        expected = {'name': 'John Doe', 'position': 'Engineer'}\n        self.assertEqual(result, expected)\n\n    def test_non_admin_add_editable_new(self):\n        # Non-admin can add new field if in EDITABLE_FIELDS.\n        staff = {'name': 'John'}\n        changes = {'department': 'IT'}\n        result = modify_staff_info(staff, changes, False)\n        expected = {'name': 'John', 'department': 'IT'}\n        self.assertEqual(result, expected)\n\n    def test_non_admin_update_non_editable_existing(self):\n        # Non-admin cannot update existing non-editable field.\n        staff = {'name': 'John', 'salary': 5000}\n        changes = {'salary': 6000}\n        result = modify_staff_info(staff, changes, False)\n        self.assertEqual(result, staff)  # Should remain unchanged\n\n    def test_non_admin_add_non_editable_new(self):\n        # Non-admin cannot add new non-editable field.\n        staff = {'name': 'John'}\n        changes = {'salary': 5000}\n        result = modify_staff_info(staff, changes, False)\n        self.assertEqual(result, staff)  # Should remain unchanged\n\n    def test_non_admin_mix_editable_non_editable(self):\n        # Non-admin: update editable and non-editable fields.\n        staff = {'name': 'John', 'salary': 5000}\n        changes = {'name': 'John Doe', 'salary': 6000, 'department': 'IT'}\n        result = modify_staff_info(staff, changes, False)\n        expected = {'name': 'John Doe', 'salary': 5000, 'department': 'IT'}\n        self.assertEqual(result, expected)\n\n    def test_admin_empty_changes(self):\n        # Admin: empty changes does nothing.\n        staff = {'name': 'John'}\n        changes = {}\n        result = modify_staff_info(staff, changes, True)\n        self.assertEqual(result, staff)\n\n    def test_non_admin_empty_changes(self):\n        # Non-admin: empty changes does nothing.\n        staff = {'name': 'John'}\n        changes = {}\n        result = modify_staff_info(staff, changes, False)\n        self.assertEqual(result, staff)\n\n    def test_staff_not_dict(self):\n        # staff is not a dictionary -> expect AttributeError.\n        with self.assertRaises(AttributeError):\n            modify_staff_info(\"not a dict\", {'name': 'John'}, True)\n\n    def test_changes_not_dict_admin(self):\n        # changes is not a dict (admin) -> expect TypeError.\n        staff = {'name': 'John'}\n        with self.assertRaises(TypeError):\n            modify_staff_info(staff, \"not a dict\", True)\n\n    def test_changes_not_dict_non_admin(self):\n        # changes is not a dict (non-admin) -> expect AttributeError.\n        staff = {'name': 'John'}\n        with self.assertRaises(AttributeError):\n            modify_staff_info(staff, \"not a dict\", False)\n\n    def test_admin_status_truthy_non_bool(self):\n        # Non-bool truthy admin_status (1) treated as admin.\n        staff = {'name': 'John'}\n        changes = {'salary': 5000}  # Non-editable\n        result = modify_staff_info(staff, changes, 1)\n        expected = {'name': 'John', 'salary': 5000}\n        self.assertEqual(result, expected)\n\n    def test_admin_status_falsy_non_bool(self):\n        # Non-bool falsy admin_status (0) treated as non-admin.\n        staff = {'name': 'John'}\n        changes = {'salary': 5000}  # Non-editable\n        result = modify_staff_info(staff, changes, 0)\n        self.assertEqual(result, staff)  # Unchanged\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 14, "task_id": "a0c3674f"}
{"test": "import unittest\n\n# Define the global EDITABLE_FIELDS used by the function\nEDITABLE_FIELDS = ['name', 'position', 'department', 'phone']\n\nclass TestEditPersonnelInfo(unittest.TestCase):\n    \n    def test_admin_updates_any_field(self):\n        # Admin can update editable and non-editable fields\n        record = {'name': 'John', 'position': 'Engineer', 'salary': 50000}\n        adjustments = {'name': 'Alice', 'salary': 60000, 'department': 'HR'}\n        result = edit_personnel_info(record, adjustments, True)\n        expected = {'name': 'Alice', 'position': 'Engineer', 'salary': 60000, 'department': 'HR'}\n        self.assertEqual(result, expected)\n\n    def test_non_admin_updates_editable_fields(self):\n        # Non-admin can update existing editable fields\n        record = {'name': 'John', 'position': 'Engineer', 'department': 'IT', 'salary': 50000}\n        adjustments = {'name': 'Bob', 'position': 'Manager'}\n        result = edit_personnel_info(record, adjustments, False)\n        expected = {'name': 'Bob', 'position': 'Manager', 'department': 'IT', 'salary': 50000}\n        self.assertEqual(result, expected)\n\n    def test_non_admin_updates_mixed_fields(self):\n        # Non-admin updates mixed fields: only editable fields are updated\n        record = {'name': 'John', 'position': 'Engineer', 'department': 'IT', 'salary': 50000}\n        adjustments = {'department': 'HR', 'salary': 70000}\n        result = edit_personnel_info(record, adjustments, False)\n        expected = {'name': 'John', 'position': 'Engineer', 'department': 'HR', 'salary': 50000}\n        self.assertEqual(result, expected)\n\n    def test_non_admin_adds_editable_field(self):\n        # Non-admin can add new field if in EDITABLE_FIELDS\n        record = {'name': 'John', 'position': 'Engineer', 'department': 'IT'}\n        adjustments = {'phone': '1234567890'}\n        result = edit_personnel_info(record, adjustments, False)\n        expected = {'name': 'John', 'position': 'Engineer', 'department': 'IT', 'phone': '1234567890'}\n        self.assertEqual(result, expected)\n\n    def test_non_admin_ignores_non_editable_new_field(self):\n        # Non-admin ignores non-editable fields not in record\n        record = {'name': 'John', 'position': 'Engineer', 'department': 'IT'}\n        adjustments = {'new_field': 'value'}\n        result = edit_personnel_info(record, adjustments, False)\n        self.assertEqual(result, record)\n\n    def test_admin_adds_non_editable_field(self):\n        # Admin can add new non-editable fields\n        record = {'name': 'John', 'position': 'Engineer', 'department': 'IT'}\n        adjustments = {'new_field': 'value'}\n        result = edit_personnel_info(record, adjustments, True)\n        expected = {'name': 'John', 'position': 'Engineer', 'department': 'IT', 'new_field': 'value'}\n        self.assertEqual(result, expected)\n\n    def test_empty_adjustments(self):\n        # Empty adjustments leave record unchanged\n        record = {'name': 'John', 'position': 'Engineer', 'department': 'IT'}\n        adjustments = {}\n        result_admin = edit_personnel_info(record.copy(), adjustments, True)\n        result_non_admin = edit_personnel_info(record.copy(), adjustments, False)\n        self.assertEqual(result_admin, record)\n        self.assertEqual(result_non_admin, record)\n\n    def test_non_admin_complex_adjustments(self):\n        # Non-admin: mix of editable/non-editable, existing/new fields\n        record = {'name': 'John', 'position': 'Engineer', 'department': 'IT', 'salary': 50000}\n        adjustments = {\n            'name': 'Alice',   # editable exists - update\n            'phone': '123',    # editable missing - add\n            'salary': 60000,   # non-editable exists - ignore\n            'new_field': 'x'   # non-editable missing - ignore\n        }\n        result = edit_personnel_info(record, adjustments, False)\n        expected = {\n            'name': 'Alice',\n            'position': 'Engineer',\n            'department': 'IT',\n            'salary': 50000,\n            'phone': '123'\n        }\n        self.assertEqual(result, expected)\n", "num_test_cases": 8, "task_id": "3a444f3b"}
{"test": "import unittest\n\n# Define the EDITABLE_FIELDS global variable as used by the function\nEDITABLE_FIELDS = {'name', 'position', 'department'}\n\nclass TestAlterEmployeeDetails(unittest.TestCase):\n\n    def test_superuser_can_update_any_field(self):\n        # Superuser can update any field including disallowed ones\n        emp = {'name': 'John', 'position': 'Engineer', 'salary': 50000}\n        changes = {'name': 'John Doe', 'salary': 60000}\n        updated = alter_employee_details(emp, changes, True)\n        self.assertEqual(updated['name'], 'John Doe')\n        self.assertEqual(updated['salary'], 60000)\n\n    def test_superuser_can_add_new_fields(self):\n        # Superuser can add new fields not originally present\n        emp = {'name': 'John'}\n        changes = {'new_field': 'value', 'social_security_number': '123-45-6789'}\n        updated = alter_employee_details(emp, changes, True)\n        self.assertEqual(updated['new_field'], 'value')\n        self.assertEqual(updated['social_security_number'], '123-45-6789')\n\n    def test_superuser_empty_changes(self):\n        # Empty changes leave employee data unchanged\n        emp = {'name': 'John', 'position': 'Engineer'}\n        changes = {}\n        updated = alter_employee_details(emp, changes, True)\n        self.assertEqual(updated, emp)\n\n    def test_non_superuser_update_allowed_field(self):\n        # Non-superuser can update allowed fields\n        emp = {'name': 'John', 'position': 'Engineer', 'salary': 50000}\n        changes = {'name': 'John Doe'}\n        updated = alter_employee_details(emp, changes, False)\n        self.assertEqual(updated['name'], 'John Doe')\n        self.assertEqual(updated['salary'], 50000)  # Verify salary unchanged\n\n    def test_non_superuser_cannot_update_disallowed_field(self):\n        # Non-superuser cannot update fields outside EDITABLE_FIELDS\n        emp = {'name': 'John', 'position': 'Engineer', 'salary': 50000}\n        changes = {'salary': 60000}\n        updated = alter_employee_details(emp, changes, False)\n        self.assertEqual(updated['salary'], 50000)\n\n    def test_non_superuser_can_add_allowed_field(self):\n        # Non-superuser can add new fields if in EDITABLE_FIELDS\n        emp = {'name': 'John', 'position': 'Engineer'}\n        changes = {'department': 'IT'}\n        updated = alter_employee_details(emp, changes, False)\n        self.assertEqual(updated['department'], 'IT')\n\n    def test_non_superuser_cannot_add_disallowed_field(self):\n        # Non-superuser cannot add fields outside EDITABLE_FIELDS\n        emp = {'name': 'John'}\n        changes = {'social_security_number': '123-45-6789'}\n        updated = alter_employee_details(emp, changes, False)\n        self.assertNotIn('social_security_number', updated)\n\n    def test_non_superuser_mixed_changes(self):\n        # Mixed allowed and disallowed changes: only allowed applied\n        emp = {'name': 'John', 'position': 'Engineer', 'salary': 50000}\n        changes = {\n            'name': 'John Doe',  # allowed\n            'salary': 60000,     # disallowed\n            'department': 'IT'   # allowed\n        }\n        updated = alter_employee_details(emp, changes, False)\n        self.assertEqual(updated['name'], 'John Doe')\n        self.assertEqual(updated['department'], 'IT')\n        self.assertEqual(updated['salary'], 50000)\n\n    def test_non_superuser_empty_changes(self):\n        # Empty changes leave employee data unchanged\n        emp = {'name': 'John', 'position': 'Engineer'}\n        changes = {}\n        updated = alter_employee_details(emp, changes, False)\n        self.assertEqual(updated, emp)\n\n    def test_non_superuser_update_nonexistent_allowed_field(self):\n        # Non-superuser can add a field in EDITABLE_FIELDS not present originally\n        emp = {'name': 'John'}\n        changes = {'position': 'Manager'}\n        updated = alter_employee_details(emp, changes, False)\n        self.assertEqual(updated['position'], 'Manager')\n\n    def test_non_superuser_update_nonexistent_disallowed_field(self):\n        # Non-superuser cannot add a field not in EDITABLE_FIELDS\n        emp = {'name': 'John'}\n        changes = {'social_security_number': '123-45-6789'}\n        updated = alter_employee_details(emp, changes, False)\n        self.assertNotIn('social_security_number', updated)", "num_test_cases": 11, "task_id": "052306ff"}
{"test": "import unittest\nfrom unittest.mock import patch\n\nclass TestCases(unittest.TestCase):\n    BASE_PERMITTED = ['price', 'description', 'stock']\n\n    def test_case_1(self):\n        # Test updating one permitted field\n        with patch('__main__.PERMITTED_FIELDS', self.BASE_PERMITTED):\n            product = {'price': 10.0, 'description': 'A product', 'stock': 100}\n            data = {'price': 15.0}\n            result = modify_product_details(product, data)\n            self.assertEqual(result['price'], 15.0)\n            self.assertEqual(result['description'], 'A product')\n            self.assertEqual(result['stock'], 100)\n\n    def test_case_2(self):\n        # Test updating multiple permitted fields\n        with patch('__main__.PERMITTED_FIELDS', self.BASE_PERMITTED):\n            product = {'price': 10.0, 'description': 'A product', 'stock': 100}\n            data = {'price': 15.0, 'description': 'Updated product', 'stock': 50}\n            result = modify_product_details(product, data)\n            self.assertEqual(result['price'], 15.0)\n            self.assertEqual(result['description'], 'Updated product')\n            self.assertEqual(result['stock'], 50)\n\n    def test_case_3(self):\n        # Test non-permitted field is ignored\n        with patch('__main__.PERMITTED_FIELDS', self.BASE_PERMITTED):\n            product = {'price': 10.0, 'description': 'A product', 'stock': 100}\n            data = {'discount': 0.1}\n            result = modify_product_details(product, data)\n            self.assertEqual(result, {'price': 10.0, 'description': 'A product', 'stock': 100})\n\n    def test_case_4(self):\n        # Test mix of permitted and non-permitted fields\n        with patch('__main__.PERMITTED_FIELDS', self.BASE_PERMITTED):\n            product = {'price': 10.0, 'description': 'A product', 'stock': 100}\n            data = {'price': 15.0, 'discount': 0.1}\n            result = modify_product_details(product, data)\n            self.assertEqual(result['price'], 15.0)\n            self.assertEqual(result['description'], 'A product')\n            self.assertEqual(result['stock'], 100)\n            self.assertNotIn('discount', result)\n\n    def test_case_5(self):\n        # Test empty data\n        with patch('__main__.PERMITTED_FIELDS', self.BASE_PERMITTED):\n            product = {'price': 10.0, 'description': 'A product', 'stock': 100}\n            data = {}\n            result = modify_product_details(product, data)\n            self.assertEqual(result, product)\n\n    def test_case_6(self):\n        # Test updating an empty product with a permitted field\n        with patch('__main__.PERMITTED_FIELDS', self.BASE_PERMITTED):\n            product = {}\n            data = {'price': 15.0}\n            result = modify_product_details(product, data)\n            self.assertEqual(result, {'price': 15.0})\n\n    def test_case_7(self):\n        # Test adding a new permitted field that is not in the product\n        with patch('__main__.PERMITTED_FIELDS', self.BASE_PERMITTED):\n            product = {'price': 10.0}\n            data = {'stock': 50}\n            result = modify_product_details(product, data)\n            self.assertEqual(result, {'price': 10.0, 'stock': 50})\n\n    def test_case_8(self):\n        # Test updating with a non-permitted field that is not in the product\n        with patch('__main__.PERMITTED_FIELDS', self.BASE_PERMITTED):\n            product = {'price': 10.0}\n            data = {'discount': 0.1}\n            result = modify_product_details(product, data)\n            self.assertEqual(result, {'price': 10.0})\n\n    def test_case_9(self):\n        # Test product is None -> TypeError\n        with patch('__main__.PERMITTED_FIELDS', self.BASE_PERMITTED):\n            with self.assertRaises(TypeError):\n                modify_product_details(None, {'price': 10})\n\n    def test_case_10(self):\n        # Test data is None -> AttributeError\n        with patch('__main__.PERMITTED_FIELDS', self.BASE_PERMITTED):\n            product = {'price': 10.0}\n            with self.assertRaises(AttributeError):\n                modify_product_details(product, None)\n\n    def test_case_11(self):\n        # Test data is not a dict -> AttributeError\n        with patch('__main__.PERMITTED_FIELDS', self.BASE_PERMITTED):\n            product = {'price': 10.0}\n            with self.assertRaises(AttributeError):\n                modify_product_details(product, [('price', 20)])\n\n    def test_case_12(self):\n        # Test product is not a dict -> TypeError\n        with patch('__main__.PERMITTED_FIELDS', self.BASE_PERMITTED):\n            with self.assertRaises(TypeError):\n                modify_product_details([], {'price': 10})\n\n    def test_case_13(self):\n        # Test PERMITTED_FIELDS is empty list -> no updates\n        with patch('__main__.PERMITTED_FIELDS', []):\n            product = {'price': 10.0, 'description': 'A product', 'stock': 100}\n            data = {'price': 20.0, 'description': 'New description', 'stock': 50}\n            result = modify_product_details(product, data)\n            self.assertEqual(result, {'price': 10.0, 'description': 'A product', 'stock': 100})\n\n    def test_case_14(self):\n        # Test PERMITTED_FIELDS has one element\n        with patch('__main__.PERMITTED_FIELDS', ['price']):\n            product = {'price': 10.0, 'description': 'A product', 'stock': 100}\n            data = {'price': 20.0, 'description': 'New description', 'stock': 50}\n            result = modify_product_details(product, data)\n            self.assertEqual(result['price'], 20.0)\n            self.assertEqual(result['description'], 'A product')\n            self.assertEqual(result['stock'], 100)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 14, "task_id": "50f90639"}
{"test": "import unittest\nfrom solution import update_vehicle_info\nimport solution\n\nclass TestUpdateVehicleInfo(unittest.TestCase):\n    def setUp(self):\n        \"\"\"Save and reset the global ALLOWED_FIELDS to default state.\"\"\"\n        self.original_allowed_fields = solution.ALLOWED_FIELDS\n        solution.ALLOWED_FIELDS = ['make', 'model', 'year']\n    \n    def tearDown(self):\n        \"\"\"Restore the original ALLOWED_FIELDS value.\"\"\"\n        solution.ALLOWED_FIELDS = self.original_allowed_fields\n    \n    def test_update_allowed_field(self):\n        \"\"\"Test updating a single allowed field.\"\"\"\n        vehicle = {'make': 'Toyota', 'model': 'Camry', 'year': 2010}\n        updates = {'make': 'Honda'}\n        result = update_vehicle_info(vehicle, updates)\n        self.assertEqual(result, {'make': 'Honda', 'model': 'Camry', 'year': 2010})\n        self.assertIs(result, vehicle)  # Ensure same object is returned\n    \n    def test_update_disallowed_field(self):\n        \"\"\"Test updating a field not in ALLOWED_FIELDS is ignored.\"\"\"\n        vehicle = {'make': 'Toyota', 'model': 'Camry', 'year': 2010, 'owner': 'John'}\n        updates = {'owner': 'Jane'}\n        result = update_vehicle_info(vehicle, updates)\n        self.assertEqual(result, {'make': 'Toyota', 'model': 'Camry', 'year': 2010, 'owner': 'John'})\n    \n    def test_mixed_allowed_and_disallowed_updates(self):\n        \"\"\"Test a mix of allowed and disallowed fields in updates.\"\"\"\n        vehicle = {'make': 'Toyota', 'model': 'Camry', 'year': 2010}\n        updates = {'make': 'Honda', 'owner': 'Alice', 'color': 'Blue'}\n        result = update_vehicle_info(vehicle, updates)\n        self.assertEqual(result, {'make': 'Honda', 'model': 'Camry', 'year': 2010})\n    \n    def test_empty_updates(self):\n        \"\"\"Test that empty updates returns the original vehicle unchanged.\"\"\"\n        vehicle = {'make': 'Ford', 'model': 'Fiesta', 'year': 2015}\n        updates = {}\n        result = update_vehicle_info(vehicle, updates)\n        self.assertEqual(result, vehicle)\n    \n    def test_add_new_allowed_field(self):\n        \"\"\"Test adding a new allowed field not present in the vehicle.\"\"\"\n        vehicle = {'make': 'Nissan'}\n        updates = {'year': 2020}\n        result = update_vehicle_info(vehicle, updates)\n        self.assertEqual(result, {'make': 'Nissan', 'year': 2020})\n    \n    def test_add_new_disallowed_field(self):\n        \"\"\"Test adding a new disallowed field is ignored.\"\"\"\n        vehicle = {'make': 'Nissan'}\n        updates = {'owner': 'Bob'}\n        result = update_vehicle_info(vehicle, updates)\n        self.assertEqual(result, {'make': 'Nissan'})\n    \n    def test_non_dict_vehicle(self):\n        \"\"\"Test passing a non-dictionary vehicle raises appropriate exception.\"\"\"\n        with self.assertRaises(AttributeError):\n            update_vehicle_info('not_a_dict', {'make': 'Honda'})\n    \n    def test_non_dict_updates(self):\n        \"\"\"Test passing a non-dictionary updates raises appropriate exception.\"\"\"\n        vehicle = {'make': 'Toyota'}\n        with self.assertRaises(AttributeError):\n            update_vehicle_info(vehicle, 'not_a_dict')\n    \n    def test_empty_allowed_fields(self):\n        \"\"\"Test that no updates occur when ALLOWED_FIELDS is empty.\"\"\"\n        solution.ALLOWED_FIELDS = []  # Temporarily set to empty\n        vehicle = {'make': 'Kia', 'model': 'Soul', 'year': 2018}\n        updates = {'make': 'Hyundai', 'model': 'Elantra'}\n        result = update_vehicle_info(vehicle, updates)\n        self.assertEqual(result, {'make': 'Kia', 'model': 'Soul', 'year': 2018})\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 9, "task_id": "6f735ab3"}
{"test": "import unittest\n\n# Define the global EDITABLE_FIELDS and the function for the tests\nEDITABLE_FIELDS = {'name', 'position', 'department'}\n\ndef update_employee_record(employee: dict, updates: dict, is_admin: bool):\n    if is_admin:\n        employee.update(updates)\n    else:\n        for field, value in updates.items():\n            if field in EDITABLE_FIELDS:\n                employee[field] = value\n    return employee\n\nclass TestUpdateEmployeeRecord(unittest.TestCase):\n    def setUp(self):\n        # Reset EDITABLE_FIELDS to default before each test\n        global EDITABLE_FIELDS\n        EDITABLE_FIELDS = {'name', 'position', 'department'}\n    \n    def test_admin_updates_all_fields(self):\n        # Admin can update all fields including sensitive ones\n        employee = {'name': 'John', 'position': 'Manager', 'salary': 50000, 'social_security_number': '123-45-6789'}\n        updates = {'name': 'John Doe', 'salary': 55000, 'social_security_number': '987-65-4321'}\n        result = update_employee_record(employee, updates, True)\n        expected = {'name': 'John Doe', 'position': 'Manager', 'salary': 55000, 'social_security_number': '987-65-4321'}\n        self.assertEqual(result, expected)\n    \n    def test_non_admin_updates_editable_fields(self):\n        # Non-admin can only update fields in EDITABLE_FIELDS\n        employee = {'name': 'John', 'position': 'Manager', 'salary': 50000}\n        updates = {'name': 'John Doe', 'position': 'Senior Manager', 'salary': 55000}\n        result = update_employee_record(employee, updates, False)\n        expected = {'name': 'John Doe', 'position': 'Senior Manager', 'salary': 50000}\n        self.assertEqual(result, expected)\n    \n    def test_non_admin_ignores_non_editable_fields(self):\n        # Non-admin update ignores fields not in EDITABLE_FIELDS\n        employee = {'name': 'John', 'position': 'Manager'}\n        updates = {'department': 'HR', 'salary': 50000}\n        result = update_employee_record(employee, updates, False)\n        expected = {'name': 'John', 'position': 'Manager', 'department': 'HR'}\n        self.assertEqual(result, expected)\n    \n    def test_empty_updates_admin(self):\n        # Empty updates with admin leaves employee unchanged\n        employee = {'name': 'John', 'position': 'Manager'}\n        updates = {}\n        result = update_employee_record(employee, updates, True)\n        self.assertEqual(result, employee)\n    \n    def test_empty_updates_non_admin(self):\n        # Empty updates with non-admin leaves employee unchanged\n        employee = {'name': 'John', 'position': 'Manager'}\n        updates = {}\n        result = update_employee_record(employee, updates, False)\n        self.assertEqual(result, employee)\n    \n    def test_non_admin_adds_editable_field(self):\n        # Non-admin can add new fields in EDITABLE_FIELDS\n        employee = {'name': 'John'}\n        updates = {'department': 'IT'}\n        result = update_employee_record(employee, updates, False)\n        expected = {'name': 'John', 'department': 'IT'}\n        self.assertEqual(result, expected)\n    \n    def test_non_admin_ignores_non_editable_addition(self):\n        # Non-admin ignores new fields not in EDITABLE_FIELDS\n        employee = {'name': 'John'}\n        updates = {'salary': 50000}\n        result = update_employee_record(employee, updates, False)\n        self.assertEqual(result, {'name': 'John'})\n    \n    def test_admin_adds_new_field(self):\n        # Admin can add new fields regardless of EDITABLE_FIELDS\n        employee = {'name': 'John'}\n        updates = {'age': 30}\n        result = update_employee_record(employee, updates, True)\n        expected = {'name': 'John', 'age': 30}\n        self.assertEqual(result, expected)\n    \n    def test_custom_editable_fields(self):\n        # Test with custom EDITABLE_FIELDS configuration\n        global EDITABLE_FIELDS\n        EDITABLE_FIELDS = {'salary'}\n        employee = {'name': 'John', 'salary': 50000}\n        updates = {'name': 'John Doe', 'salary': 55000}\n        result = update_employee_record(employee, updates, False)\n        expected = {'name': 'John', 'salary': 55000}\n        self.assertEqual(result, expected)\n    \n    def test_non_admin_updates_with_none(self):\n        # Non-admin can update editable field with None value\n        employee = {'name': 'John', 'department': None}\n        updates = {'name': None, 'department': 'HR'}\n        result = update_employee_record(employee, updates, False)\n        expected = {'name': None, 'department': 'HR'}\n        self.assertEqual(result, expected)\n    \n    def test_admin_updates_with_none(self):\n        # Admin can update any field with None value\n        employee = {'name': 'John', 'age': 30}\n        updates = {'age': None}\n        result = update_employee_record(employee, updates, True)\n        expected = {'name': 'John', 'age': None}\n        self.assertEqual(result, expected)\n    \n    def test_update_empty_employee_admin(self):\n        # Admin can update an empty employee record\n        employee = {}\n        updates = {'name': 'John', 'position': 'Manager'}\n        result = update_employee_record(employee, updates, True)\n        self.assertEqual(result, updates)\n    \n    def test_update_empty_employee_non_admin(self):\n        # Non-admin can only add editable fields to empty employee\n        employee = {}\n        updates = {'name': 'John', 'salary': 50000}\n        result = update_employee_record(employee, updates, False)\n        expected = {'name': 'John'}\n        self.assertEqual(result, expected)\n    \n    def test_large_number_of_updates_admin(self):\n        # Admin handles large number of updates\n        employee = {'field1': 'value1'}\n        updates = {f'field{i}': f'value{i}' for i in range(2, 1001)}\n        result = update_employee_record(employee, updates, True)\n        expected = {'field1': 'value1'}\n        expected.update(updates)\n        self.assertEqual(result, expected)\n    \n    def test_large_number_of_updates_non_admin(self):\n        # Non-admin updates only editable fields in a large update set\n        global EDITABLE_FIELDS\n        EDITABLE_FIELDS = {f'field{i}' for i in range(1, 501)}\n        employee = {}\n        updates = {f'field{i}': f'value{i}' for i in range(1, 1001)}\n        result = update_employee_record(employee, updates, False)\n        expected = {f'field{i}': f'value{i}' for i in range(1, 501)}\n        self.assertEqual(result, expected)\n    \n    def test_non_admin_update_social_security(self):\n        # Non-admin cannot update sensitive field (social_security_number)\n        employee = {'name': 'John', 'social_security_number': '123-45-6789'}\n        updates = {'social_security_number': '987-65-4321'}\n        result = update_employee_record(employee, updates, False)\n        self.assertEqual(result['social_security_number'], '123-45-6789')\n    \n    def test_admin_removes_field(self):\n        # Admin can remove a field by setting it to None (or any value)\n        employee = {'name': 'John', 'position': 'Manager'}\n        updates = {'position': None}\n        result = update_employee_record(employee, updates, True)\n        expected = {'name': 'John', 'position': None}\n        self.assertEqual(result, expected)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 17, "task_id": "bd706076"}
{"test": "import unittest\n\n# Define the global VALID_ATTRIBUTES used by the function\nVALID_ATTRIBUTES = {\"name\", \"email\", \"age\"}\n\nclass TestUpdateUserAttributes(unittest.TestCase):\n    \n    def test_update_single_valid_attribute(self):\n        \"\"\"Test updating a single valid attribute.\"\"\"\n        user = {\"name\": \"John\", \"email\": \"john@example.com\"}\n        data = {\"name\": \"Jane\"}\n        updated_user = update_user_attributes(user, data)\n        self.assertEqual(updated_user[\"name\"], \"Jane\")\n        self.assertEqual(updated_user[\"email\"], \"john@example.com\")\n    \n    def test_update_multiple_valid_attributes(self):\n        \"\"\"Test updating multiple valid attributes.\"\"\"\n        user = {\"name\": \"John\", \"email\": \"john@example.com\", \"age\": 30}\n        data = {\"name\": \"Jane\", \"age\": 31}\n        updated_user = update_user_attributes(user, data)\n        self.assertEqual(updated_user[\"name\"], \"Jane\")\n        self.assertEqual(updated_user[\"age\"], 31)\n        self.assertEqual(updated_user[\"email\"], \"john@example.com\")\n    \n    def test_mix_valid_and_invalid_attributes(self):\n        \"\"\"Test updating with a mix of valid and invalid attributes.\"\"\"\n        user = {\"name\": \"John\", \"age\": 30}\n        data = {\"name\": \"Jane\", \"invalid_attr\": \"value\"}\n        updated_user = update_user_attributes(user, data)\n        self.assertEqual(updated_user[\"name\"], \"Jane\")\n        self.assertEqual(updated_user[\"age\"], 30)\n        self.assertNotIn(\"invalid_attr\", updated_user)\n    \n    def test_only_invalid_attributes(self):\n        \"\"\"Test updating with only invalid attributes leaves user unchanged.\"\"\"\n        user = {\"name\": \"John\", \"age\": 30}\n        data = {\"invalid1\": \"value1\", \"invalid2\": \"value2\"}\n        updated_user = update_user_attributes(user, data)\n        self.assertEqual(updated_user, {\"name\": \"John\", \"age\": 30})\n    \n    def test_empty_data(self):\n        \"\"\"Test updating with empty data returns user unchanged.\"\"\"\n        user = {\"name\": \"John\", \"age\": 30}\n        data = {}\n        updated_user = update_user_attributes(user, data)\n        self.assertEqual(updated_user, user)\n    \n    def test_empty_user_valid_attribute(self):\n        \"\"\"Test updating an empty user with a valid attribute adds the attribute.\"\"\"\n        user = {}\n        data = {\"name\": \"John\"}\n        updated_user = update_user_attributes(user, data)\n        self.assertEqual(updated_user, {\"name\": \"John\"})\n    \n    def test_non_string_key(self):\n        \"\"\"Test updating with a non-string key (should be ignored).\"\"\"\n        user = {\"name\": \"John\"}\n        data = {123: \"value\"}\n        updated_user = update_user_attributes(user, data)\n        self.assertEqual(updated_user, {\"name\": \"John\"})\n    \n    def test_new_valid_attribute(self):\n        \"\"\"Test adding a new valid attribute not originally in user.\"\"\"\n        user = {\"name\": \"John\"}\n        data = {\"email\": \"john@example.com\"}\n        updated_user = update_user_attributes(user, data)\n        self.assertEqual(updated_user[\"name\"], \"John\")\n        self.assertEqual(updated_user[\"email\"], \"john@example.com\")\n    \n    def test_none_value_update(self):\n        \"\"\"Test updating a valid attribute with None value.\"\"\"\n        user = {\"name\": \"John\", \"email\": \"john@example.com\"}\n        data = {\"email\": None}\n        updated_user = update_user_attributes(user, data)\n        self.assertIsNone(updated_user[\"email\"])\n    \n    def test_return_value_identity(self):\n        \"\"\"Test that the returned user is the same object (identity).\"\"\"\n        user = {\"name\": \"John\"}\n        data = {\"name\": \"Jane\"}\n        updated_user = update_user_attributes(user, data)\n        self.assertIs(updated_user, user)", "num_test_cases": 10, "task_id": "6c82726f"}
{"test": "import unittest\nfrom unittest.mock import patch\n\nclass TestValidateRedirectUrl(unittest.TestCase):\n\n    @classmethod\n    def setUpClass(cls):\n        # Patch the ALLOWED_DOMAINS in the function's module\n        cls.patcher = patch('app.utils.ALLOWED_DOMAINS', {'allowed.com', 'allowed2.com', '192.168.1.1'})\n        cls.patcher.start()\n\n    @classmethod\n    def tearDownClass(cls):\n        cls.patcher.stop()\n\n    def test_valid_domain_no_path(self):\n        # Test URL with allowed domain and no additional path\n        url = 'http://allowed.com'\n        result = validate_redirect_url(url)\n        self.assertEqual(result, url)\n\n    def test_valid_domain_with_path_and_query(self):\n        # Test URL with allowed domain, path, and query parameters\n        url = 'https://allowed2.com/path?query=param'\n        result = validate_redirect_url(url)\n        self.assertEqual(result, url)\n\n    def test_disallowed_domain(self):\n        # Test URL with domain not in allowed list\n        with self.assertRaises(ValueError):\n            validate_redirect_url('http://disallowed.com')\n\n    def test_domain_case_sensitivity(self):\n        # Test URL with allowed domain but different case (function is case-sensitive)\n        with self.assertRaises(ValueError):\n            validate_redirect_url('http://Allowed.COM')\n\n    def test_empty_string(self):\n        # Test empty URL string (parsed hostname is None)\n        with self.assertRaises(ValueError):\n            validate_redirect_url('')\n\n    def test_none_input(self):\n        # Test None input (raises TypeError from urlparse)\n        with self.assertRaises(TypeError):\n            validate_redirect_url(None)\n\n    def test_non_string_input(self):\n        # Test non-string input (integer)\n        with self.assertRaises(TypeError):\n            validate_redirect_url(123)\n\n    def test_subdomain_attack(self):\n        # Test URL with domain that is a substring of an allowed domain\n        with self.assertRaises(ValueError):\n            validate_redirect_url('http://allowed.com.evil.com')\n\n    def test_allowed_ip_address(self):\n        # Test URL with allowed IP address\n        url = 'http://192.168.1.1'\n        result = validate_redirect_url(url)\n        self.assertEqual(result, url)\n\n    def test_disallowed_ip_address(self):\n        # Test URL with disallowed IP address\n        with self.assertRaises(ValueError):\n            validate_redirect_url('http://10.0.0.1')\n\n    def test_relative_url(self):\n        # Test relative URL (no domain)\n        with self.assertRaises(ValueError):\n            validate_redirect_url('/path/to/something')", "num_test_cases": 11, "task_id": "8dadecfb"}
{"test": "import unittest\nfrom unittest.mock import patch\n\n# Import the function from the expected module (adjust if necessary)\n# We assume the function is defined in a module named 'security_utils'\nfrom security_utils import redirect_user_safely\n\nclass TestRedirectUserSafely(unittest.TestCase):\n    def test_allowed_domain_http(self):\n        # Test HTTP URL with allowed domain\n        with patch('security_utils.SAFE_REDIRECT_DOMAINS', {'example.com'}):\n            url = 'http://example.com'\n            result = redirect_user_safely(url)\n            self.assertEqual(result, 'http://example.com')\n    \n    def test_allowed_domain_https(self):\n        # Test HTTPS URL with allowed domain\n        with patch('security_utils.SAFE_REDIRECT_DOMAINS', {'example.com'}):\n            url = 'https://example.com'\n            result = redirect_user_safely(url)\n            self.assertEqual(result, 'https://example.com')\n    \n    def test_disallowed_domain(self):\n        # Test domain not in safe list\n        with patch('security_utils.SAFE_REDIRECT_DOMAINS', {'example.com'}):\n            with self.assertRaises(ValueError):\n                redirect_user_safely('http://evil.com')\n    \n    def test_mixed_case_domain(self):\n        # Test mixed-case domain (normalized to lowercase)\n        with patch('security_utils.SAFE_REDIRECT_DOMAINS', {'example.com'}):\n            result = redirect_user_safely('http://Example.COM')\n            self.assertEqual(result, 'http://example.com')\n    \n    def test_url_with_port_path_query(self):\n        # Test URL with port, path, and query (allowed domain)\n        with patch('security_utils.SAFE_REDIRECT_DOMAINS', {'example.com'}):\n            url = 'http://example.com:8080/path?query=value#fragment'\n            result = redirect_user_safely(url)\n            self.assertEqual(result, url)\n    \n    def test_empty_string(self):\n        # Test empty URL string (hostname becomes None)\n        with patch('security_utils.SAFE_REDIRECT_DOMAINS', {'example.com'}):\n            with self.assertRaises(ValueError):\n                redirect_user_safely('')\n    \n    def test_none_input(self):\n        # Test None input (causes TypeError in urlparse)\n        with patch('security_utils.SAFE_REDIRECT_DOMAINS', {'example.com'}):\n            with self.assertRaises(TypeError):\n                redirect_user_safely(None)\n    \n    def test_non_string_input(self):\n        # Test non-string input (integer)\n        with patch('security_utils.SAFE_REDIRECT_DOMAINS', {'example.com'}):\n            with self.assertRaises(TypeError):\n                redirect_user_safely(123)\n    \n    def test_allowed_ip_address(self):\n        # Test allowed IP address\n        with patch('security_utils.SAFE_REDIRECT_DOMAINS', {'192.168.1.1'}):\n            url = 'http://192.168.1.1'\n            result = redirect_user_safely(url)\n            self.assertEqual(result, url)\n    \n    def test_disallowed_ip_address(self):\n        # Test disallowed IP address\n        with patch('security_utils.SAFE_REDIRECT_DOMAINS', {'192.168.1.1'}):\n            with self.assertRaises(ValueError):\n                redirect_user_safely('http://192.168.1.2')\n    \n    def test_trailing_dot_normalization(self):\n        # Test trailing dot in domain (normalized away)\n        with patch('security_utils.SAFE_REDIRECT_DOMAINS', {'example.com'}):\n            result = redirect_user_safely('http://example.com.')\n            self.assertEqual(result, 'http://example.com')\n    \n    def test_subdomain_not_in_list(self):\n        # Test subdomain not explicitly in safe list\n        with patch('security_utils.SAFE_REDIRECT_DOMAINS', {'example.com'}):\n            with self.assertRaises(ValueError):\n                redirect_user_safely('http://sub.example.com')\n    \n    def test_relative_url(self):\n        # Test relative URL (hostname is None)\n        with patch('security_utils.SAFE_REDIRECT_DOMAINS', {'example.com'}):\n            with self.assertRaises(ValueError):\n                redirect_user_safely('/path/to/resource')\n    \n    def test_non_http_scheme(self):\n        # Test non-HTTP scheme (allowed if domain is safe)\n        with patch('security_utils.SAFE_REDIRECT_DOMAINS', {'example.com'}):\n            url = 'ftp://example.com'\n            result = redirect_user_safely(url)\n            self.assertEqual(result, url)", "num_test_cases": 14, "task_id": "f76e9031"}
{"test": "import unittest\nfrom unittest.mock import patch\nfrom urllib.parse import urlparse\n\n# Import the function from the assumed module 'solution'\nfrom solution import secure_redirect_handler\n\nclass TestSecureRedirectHandler(unittest.TestCase):\n    AUTHORIZED_DOMAINS = {'example.com', 'safe.org', 'trusted.net'}\n\n    def test_authorized_domain(self):\n        # Test URL with authorized domain (standard case)\n        with patch('solution.AUTHORIZED_DOMAINS', self.AUTHORIZED_DOMAINS):\n            url = 'http://example.com'\n            expected = urlparse(url).geturl()\n            result = secure_redirect_handler(url)\n            self.assertEqual(result, expected)\n\n    def test_authorized_domain_mixed_case(self):\n        # Test URL with mixed-case domain (should normalize to lowercase)\n        with patch('solution.AUTHORIZED_DOMAINS', self.AUTHORIZED_DOMAINS):\n            url = 'http://ExAmPle.COM'\n            expected = urlparse(url).geturl()\n            result = secure_redirect_handler(url)\n            self.assertEqual(result, expected)\n\n    def test_unauthorized_domain(self):\n        # Test URL with unauthorized domain\n        with patch('solution.AUTHORIZED_DOMAINS', self.AUTHORIZED_DOMAINS):\n            url = 'http://malicious.com'\n            with self.assertRaises(ValueError):\n                secure_redirect_handler(url)\n\n    def test_url_without_hostname(self):\n        # Test URL without a hostname (relative path)\n        with patch('solution.AUTHORIZED_DOMAINS', self.AUTHORIZED_DOMAINS):\n            url = '/path/to/resource'\n            with self.assertRaises(ValueError):\n                secure_redirect_handler(url)\n\n    def test_empty_string(self):\n        # Test empty string URL\n        with patch('solution.AUTHORIZED_DOMAINS', self.AUTHORIZED_DOMAINS):\n            url = ''\n            with self.assertRaises(ValueError):\n                secure_redirect_handler(url)\n\n    def test_non_string_input(self):\n        # Test non-string input (None)\n        with patch('solution.AUTHORIZED_DOMAINS', self.AUTHORIZED_DOMAINS):\n            with self.assertRaises(TypeError):\n                secure_redirect_handler(None)\n\n    def test_url_with_port(self):\n        # Test URL with port number\n        with patch('solution.AUTHORIZED_DOMAINS', self.AUTHORIZED_DOMAINS):\n            url = 'http://example.com:8080'\n            expected = urlparse(url).geturl()\n            result = secure_redirect_handler(url)\n            self.assertEqual(result, expected)\n\n    def test_url_with_path_query_fragment(self):\n        # Test URL with path, query, and fragment\n        with patch('solution.AUTHORIZED_DOMAINS', self.AUTHORIZED_DOMAINS):\n            url = 'http://example.com/path?query=value#fragment'\n            expected = urlparse(url).geturl()\n            result = secure_redirect_handler(url)\n            self.assertEqual(result, expected)\n\n    def test_trailing_dot_in_domain(self):\n        # Test domain with trailing dot (not in authorized set)\n        with patch('solution.AUTHORIZED_DOMAINS', self.AUTHORIZED_DOMAINS):\n            url = 'http://example.com.'\n            with self.assertRaises(ValueError):\n                secure_redirect_handler(url)\n\n    def test_ip_address_url(self):\n        # Test URL with IP address (not in authorized domains)\n        with patch('solution.AUTHORIZED_DOMAINS', self.AUTHORIZED_DOMAINS):\n            url = 'http://192.168.1.1'\n            with self.assertRaises(ValueError):\n                secure_redirect_handler(url)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 10, "task_id": "5c539949"}
{"test": "import unittest\nfrom urllib.parse import urlparse\n\n# Predefined set of safe domains\nALLOWED_REDIRECT_DOMAINS = {'example.com', 'safe.org', 'trusted.net'}\n\ndef process_user_redirect(input_url: str):\n    \"\"\"\n    Accepts a URL string, validates its domain against allowed domains, and returns the URL if safe.\n    Raises ValueError for disallowed domains.\n    \"\"\"\n    parsed_url = urlparse(input_url)\n    if parsed_url.hostname not in ALLOWED_REDIRECT_DOMAINS:\n        raise ValueError(\"Redirection to disallowed domain\")\n    return parsed_url.geturl()\n\nclass TestProcessUserRedirect(unittest.TestCase):\n    def test_allowed_domain(self):\n        \"\"\"Test a URL with an allowed domain returns the same URL.\"\"\"\n        url = \"http://example.com\"\n        self.assertEqual(process_user_redirect(url), url)\n\n    def test_disallowed_domain(self):\n        \"\"\"Test a URL with a disallowed domain raises ValueError.\"\"\"\n        url = \"http://evil.com\"\n        with self.assertRaises(ValueError):\n            process_user_redirect(url)\n\n    def test_case_insensitive_domain(self):\n        \"\"\"Test that domain case sensitivity is enforced (allowed domains are case-sensitive).\"\"\"\n        url = \"http://EXAMPLE.COM\"\n        with self.assertRaises(ValueError):\n            process_user_redirect(url)\n\n    def test_empty_string(self):\n        \"\"\"Test an empty string as input raises ValueError (hostname is None).\"\"\"\n        with self.assertRaises(ValueError):\n            process_user_redirect(\"\")\n\n    def test_url_without_scheme(self):\n        \"\"\"Test a URL without a scheme (hostname is None) raises ValueError.\"\"\"\n        with self.assertRaises(ValueError):\n            process_user_redirect(\"example.com\")\n\n    def test_url_with_path_query(self):\n        \"\"\"Test a URL with path and query parameters and an allowed domain returns the same URL.\"\"\"\n        url = \"https://safe.org/path?query=param\"\n        self.assertEqual(process_user_redirect(url), url)\n\n    def test_disallowed_ip_address(self):\n        \"\"\"Test a URL with an IP address not in allowed domains raises ValueError.\"\"\"\n        url = \"http://192.168.1.1\"\n        with self.assertRaises(ValueError):\n            process_user_redirect(url)\n\n    def test_none_input(self):\n        \"\"\"Test None input raises TypeError.\"\"\"\n        with self.assertRaises(TypeError):\n            process_user_redirect(None)\n\n    def test_non_string_input(self):\n        \"\"\"Test non-string input (integer) raises TypeError.\"\"\"\n        with self.assertRaises(TypeError):\n            process_user_redirect(123)\n\n    def test_long_url(self):\n        \"\"\"Test a very long URL with an allowed domain returns the same URL.\"\"\"\n        base = \"http://trusted.net/\"\n        long_path = \"a\" * 10000\n        url = base + long_path\n        self.assertEqual(process_user_redirect(url), url)\n\n    def test_subdomain_not_allowed(self):\n        \"\"\"Test a subdomain of an allowed domain is not allowed (exact match required).\"\"\"\n        url = \"http://sub.example.com\"\n        with self.assertRaises(ValueError):\n            process_user_redirect(url)\n\n    def test_allowed_domain_with_port(self):\n        \"\"\"Test a URL with an allowed domain and specified port returns the same URL.\"\"\"\n        url = \"http://example.com:8080\"\n        self.assertEqual(process_user_redirect(url), url)\n", "num_test_cases": 12, "task_id": "a5feb303"}
{"test": "import unittest\nfrom unittest.mock import patch\n\n# Import the function from the application module\nfrom app import user_defined_redirect\n\n# Define the test allowed domains\nTEST_ALLOWED_DOMAINS = {'example.com', 'safe.org', 'trusted.net'}\n\nclass TestUserDefinedRedirect(unittest.TestCase):\n\n    def test_allowed_basic_domain(self):\n        # Test a basic allowed domain (exact match)\n        url = 'https://example.com'\n        with patch('app.ALLOWED_REDIRECT_DOMAINS', TEST_ALLOWED_DOMAINS):\n            result = user_defined_redirect(url)\n            self.assertIsInstance(result, str)\n\n    def test_allowed_domain_with_path_query(self):\n        # Test allowed domain with path and query parameters\n        url = 'https://example.com/path?query=value'\n        with patch('app.ALLOWED_REDIRECT_DOMAINS', TEST_ALLOWED_DOMAINS):\n            result = user_defined_redirect(url)\n            self.assertIsInstance(result, str)\n\n    def test_allowed_domain_with_port(self):\n        # Test allowed domain with non-standard port\n        url = 'http://example.com:8080'\n        with patch('app.ALLOWED_REDIRECT_DOMAINS', TEST_ALLOWED_DOMAINS):\n            result = user_defined_redirect(url)\n            self.assertIsInstance(result, str)\n\n    def test_trailing_dot_disallowed(self):\n        # Test domain with trailing dot (should be different from allowed)\n        url = 'http://example.com.'\n        with patch('app.ALLOWED_REDIRECT_DOMAINS', TEST_ALLOWED_DOMAINS):\n            with self.assertRaises(ValueError):\n                user_defined_redirect(url)\n\n    def test_disallowed_domain(self):\n        # Test domain not in the allowed set\n        url = 'http://disallowed.com'\n        with patch('app.ALLOWED_REDIRECT_DOMAINS', TEST_ALLOWED_DOMAINS):\n            with self.assertRaises(ValueError):\n                user_defined_redirect(url)\n\n    def test_substring_domain_disallowed(self):\n        # Test domain that is a substring of an allowed domain\n        url = 'http://example.comm'\n        with patch('app.ALLOWED_REDIRECT_DOMAINS', TEST_ALLOWED_DOMAINS):\n            with self.assertRaises(ValueError):\n                user_defined_redirect(url)\n\n    def test_relative_url_disallowed(self):\n        # Test relative URL (hostname is None)\n        url = '/path'\n        with patch('app.ALLOWED_REDIRECT_DOMAINS', TEST_ALLOWED_DOMAINS):\n            with self.assertRaises(ValueError):\n                user_defined_redirect(url)\n\n    def test_mixed_case_domain_disallowed(self):\n        # Test domain with mixed case (not matching allowed set)\n        url = 'http://Example.COM'\n        with patch('app.ALLOWED_REDIRECT_DOMAINS', TEST_ALLOWED_DOMAINS):\n            with self.assertRaises(ValueError):\n                user_defined_redirect(url)\n\n    def test_ip_address_disallowed(self):\n        # Test IP address not in allowed set\n        url = 'http://8.8.8.8'\n        with patch('app.ALLOWED_REDIRECT_DOMAINS', TEST_ALLOWED_DOMAINS):\n            with self.assertRaises(ValueError):\n                user_defined_redirect(url)\n\n    def test_different_scheme_allowed(self):\n        # Test different schemes with same domain (http and https)\n        url1 = 'http://example.com'\n        url2 = 'https://example.com'\n        with patch('app.ALLOWED_REDIRECT_DOMAINS', TEST_ALLOWED_DOMAINS):\n            result1 = user_defined_redirect(url1)\n            self.assertIsInstance(result1, str)\n            result2 = user_defined_redirect(url2)\n            self.assertIsInstance(result2, str)\n\n    def test_subdomain_disallowed(self):\n        # Test subdomain of an allowed domain (should not match)\n        url = 'http://subdomain.example.com'\n        with patch('app.ALLOWED_REDIRECT_DOMAINS', TEST_ALLOWED_DOMAINS):\n            with self.assertRaises(ValueError):\n                user_defined_redirect(url)\n", "num_test_cases": 11, "task_id": "138d5230"}
{"test": "import unittest\nfrom urllib.parse import urlparse\n\n# Define the global allowed domains and the function for a self-contained test environment\nALLOWED_REDIRECT_DOMAINS = {'example.com', 'trusted.org', 'safe.example.org'}\n\ndef secure_url_redirect(destination_url: str):\n    parsed_url = urlparse(destination_url)\n    if parsed_url.hostname not in ALLOWED_REDIRECT_DOMAINS:\n        raise ValueError(\"Redirection to disallowed domain\")\n    return parsed_url.geturl()\n\nclass TestSecureUrlRedirect(unittest.TestCase):\n\n    def test_allowed_domain_http(self):\n        # Test a simple HTTP URL with an allowed domain\n        url = \"http://example.com\"\n        result = secure_url_redirect(url)\n        self.assertEqual(result, urlparse(url).geturl())\n\n    def test_allowed_domain_https(self):\n        # Test a simple HTTPS URL with an allowed domain\n        url = \"https://trusted.org\"\n        result = secure_url_redirect(url)\n        self.assertEqual(result, urlparse(url).geturl())\n\n    def test_disallowed_domain(self):\n        # Test a URL with a domain not in the allowed set\n        with self.assertRaises(ValueError):\n            secure_url_redirect(\"http://untrusted.com\")\n\n    def test_subdomain_not_allowed(self):\n        # Test a URL with a subdomain of an allowed domain (should be disallowed)\n        with self.assertRaises(ValueError):\n            secure_url_redirect(\"http://sub.example.com\")\n\n    def test_empty_string(self):\n        # Test an empty string (hostname becomes None, not in allowed set)\n        with self.assertRaises(ValueError):\n            secure_url_redirect(\"\")\n\n    def test_none(self):\n        # Test None input (invalid type)\n        with self.assertRaises(TypeError):\n            secure_url_redirect(None)\n\n    def test_non_string(self):\n        # Test non-string input (integer)\n        with self.assertRaises(TypeError):\n            secure_url_redirect(123)\n\n    def test_url_with_port(self):\n        # Test a URL with a port number\n        url = \"http://example.com:8080\"\n        result = secure_url_redirect(url)\n        self.assertEqual(result, urlparse(url).geturl())\n\n    def test_url_with_user_password(self):\n        # Test a URL with user and password components\n        url = \"http://user:pass@example.com\"\n        result = secure_url_redirect(url)\n        self.assertEqual(result, urlparse(url).geturl())\n\n    def test_mixed_case_domain(self):\n        # Test a domain with mixed case (not matching the allowed set exactly)\n        with self.assertRaises(ValueError):\n            secure_url_redirect(\"http://Example.com\")\n\n    def test_long_url(self):\n        # Test a long URL with an allowed domain\n        long_path = '/'.join(['a'*100] * 100)  # 10,000 characters\n        url = f\"http://example.com/{long_path}\"\n        result = secure_url_redirect(url)\n        self.assertEqual(result, urlparse(url).geturl())\n\n    def test_url_with_fragment(self):\n        # Test a URL with a fragment\n        url = \"http://example.com/path#section\"\n        result = secure_url_redirect(url)\n        self.assertEqual(result, urlparse(url).geturl())\n\n    def test_url_with_query(self):\n        # Test a URL with query parameters\n        url = \"http://example.com?query=param\"\n        result = secure_url_redirect(url)\n        self.assertEqual(result, urlparse(url).geturl())\n\n    def test_url_with_path(self):\n        # Test a URL with a path\n        url = \"http://example.com/path/to/something\"\n        result = secure_url_redirect(url)\n        self.assertEqual(result, urlparse(url).geturl())\n\n    def test_url_with_percent_encoding(self):\n        # Test a URL with percent-encoded characters\n        url = \"http://example.com/%7Euser\"\n        result = secure_url_redirect(url)\n        self.assertEqual(result, urlparse(url).geturl())\n\n    def test_url_with_leading_space(self):\n        # Test a URL with a leading space (invalid, hostname becomes None)\n        with self.assertRaises(ValueError):\n            secure_url_redirect(\" http://example.com\")\n", "num_test_cases": 17, "task_id": "ce1f7456"}
{"test": "import unittest\nfrom unittest.mock import patch\n\nclass TestProcessUrlRedirect(unittest.TestCase):\n\n    @patch('__main__.AUTHORIZED_REDIRECT_DOMAINS', {'example.com', 'safe.org'})\n    def test_valid_url_lowercase(self):\n        # Test valid URL with approved domain in lowercase\n        input_url = 'http://example.com/path'\n        result = process_url_redirect(input_url)\n        self.assertIsInstance(result, str)\n        self.assertEqual(result, input_url)\n\n    @patch('__main__.AUTHORIZED_REDIRECT_DOMAINS', {'example.com', 'safe.org'})\n    def test_valid_url_uppercase(self):\n        # Test valid URL with approved domain in uppercase (case-sensitive should fail)\n        input_url = 'http://EXAMPLE.COM/path'\n        with self.assertRaises(ValueError):\n            process_url_redirect(input_url)\n\n    @patch('__main__.AUTHORIZED_REDIRECT_DOMAINS', {'example.com', 'safe.org'})\n    def test_valid_url_mixed_case(self):\n        # Test valid URL with approved domain in mixed case (case-sensitive should fail)\n        input_url = 'http://ExAmPlE.CoM/path'\n        with self.assertRaises(ValueError):\n            process_url_redirect(input_url)\n\n    @patch('__main__.AUTHORIZED_REDIRECT_DOMAINS', {'example.com', 'safe.org'})\n    def test_disallowed_domain(self):\n        # Test URL with disallowed domain\n        input_url = 'http://malicious.com'\n        with self.assertRaises(ValueError):\n            process_url_redirect(input_url)\n\n    @patch('__main__.AUTHORIZED_REDIRECT_DOMAINS', {'example.com', 'safe.org'})\n    def test_empty_string(self):\n        # Test empty URL string\n        input_url = ''\n        with self.assertRaises(ValueError):\n            process_url_redirect(input_url)\n\n    @patch('__main__.AUTHORIZED_REDIRECT_DOMAINS', {'example.com', 'safe.org'})\n    def test_relative_url(self):\n        # Test URL without hostname (relative path)\n        input_url = '/path/to/resource'\n        with self.assertRaises(ValueError):\n            process_url_redirect(input_url)\n\n    @patch('__main__.AUTHORIZED_REDIRECT_DOMAINS', {'example.com', 'safe.org'})\n    def test_valid_url_with_port(self):\n        # Test valid URL with port number\n        input_url = 'http://example.com:8080/path'\n        result = process_url_redirect(input_url)\n        self.assertIsInstance(result, str)\n        self.assertEqual(result, input_url)\n\n    @patch('__main__.AUTHORIZED_REDIRECT_DOMAINS', {'example.com', 'safe.org'})\n    def test_non_string_none(self):\n        # Test None input (non-string)\n        with self.assertRaises(TypeError):\n            process_url_redirect(None)\n\n    @patch('__main__.AUTHORIZED_REDIRECT_DOMAINS', {'example.com', 'safe.org'})\n    def test_non_string_integer(self):\n        # Test integer input (non-string)\n        with self.assertRaises(TypeError):\n            process_url_redirect(123)\n\n    @patch('__main__.AUTHORIZED_REDIRECT_DOMAINS', {'example.com', 'safe.org'})\n    def test_long_valid_url(self):\n        # Test long URL with approved domain\n        input_url = 'http://example.com/' + 'a' * 1000\n        result = process_url_redirect(input_url)\n        self.assertIsInstance(result, str)\n        self.assertEqual(result, input_url)\n", "num_test_cases": 10, "task_id": "77a07ff3"}
{"test": "import unittest\nfrom unittest.mock import patch\nfrom urllib.parse import urlparse\n\nclass TestValidateSafeRedirect(unittest.TestCase):\n    TRUSTED_DOMAINS = ['example.com', 'trusted.org', 'safe-site.net']\n\n    def setUp(self):\n        self.patcher = patch('__main__.TRUSTED_DOMAIN_LIST', self.TRUSTED_DOMAINS)\n        self.patcher.start()\n\n    def tearDown(self):\n        self.patcher.stop()\n\n    def test_case_1(self):\n        # Valid URL with trusted domain (exact case)\n        input_link = 'http://example.com'\n        expected = urlparse(input_link).geturl()\n        result = validate_safe_redirect(input_link)\n        self.assertEqual(result, expected)\n\n    def test_case_2(self):\n        # Valid URL with trusted domain (mixed case)\n        input_link = 'http://Example.COM'\n        expected = urlparse(input_link).geturl()\n        result = validate_safe_redirect(input_link)\n        self.assertEqual(result, expected)\n\n    def test_case_3(self):\n        # Valid URL with trusted domain, with port, query, fragment\n        input_link = 'http://trusted.org:80/path?query=value#fragment'\n        expected = urlparse(input_link).geturl()\n        result = validate_safe_redirect(input_link)\n        self.assertEqual(result, expected)\n\n    def test_case_4(self):\n        # Valid URL with untrusted domain\n        input_link = 'http://untrusted.com'\n        with self.assertRaises(ValueError):\n            validate_safe_redirect(input_link)\n\n    def test_case_5(self):\n        # Empty string\n        input_link = ''\n        with self.assertRaises(ValueError):\n            validate_safe_redirect(input_link)\n\n    def test_case_6(self):\n        # None input\n        input_link = None\n        with self.assertRaises(TypeError):\n            validate_safe_redirect(input_link)\n\n    def test_case_7(self):\n        # Non-string input (integer)\n        input_link = 12345\n        with self.assertRaises(TypeError):\n            validate_safe_redirect(input_link)\n\n    def test_case_8(self):\n        # IP address not in trusted list\n        input_link = 'http://127.0.0.1'\n        with self.assertRaises(ValueError):\n            validate_safe_redirect(input_link)\n\n    def test_case_9(self):\n        # HTTPS scheme\n        input_link = 'https://example.com'\n        expected = urlparse(input_link).geturl()\n        result = validate_safe_redirect(input_link)\n        self.assertEqual(result, expected)\n\n    def test_case_10(self):\n        # Trusted IP address\n        with patch('__main__.TRUSTED_DOMAIN_LIST', ['127.0.0.1']):\n            input_link = 'http://127.0.0.1'\n            expected = urlparse(input_link).geturl()\n            result = validate_safe_redirect(input_link)\n            self.assertEqual(result, expected)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 10, "task_id": "505503f6"}
{"test": "import unittest\nfrom unittest.mock import patch\n\nclass TestCases(unittest.TestCase):\n    def setUp(self):\n        # Define valid domains for testing and patch the global variable\n        self.valid_domains = {\n            'example.com',\n            'safe-domain.org',\n            'trusted-site.net',\n            'a' * 100 + '.com'\n        }\n        patcher = patch('__main__.VALID_REDIRECT_DOMAINS', new=self.valid_domains)\n        patcher.start()\n        self.addCleanup(patcher.stop)\n\n    def test_approved_domain_http(self):\n        # Test with http and approved domain\n        url = 'http://example.com'\n        result = secure_user_redirect(url)\n        self.assertEqual(result, url)\n\n    def test_approved_domain_https(self):\n        # Test with https and approved domain\n        url = 'https://example.com'\n        result = secure_user_redirect(url)\n        self.assertEqual(result, url)\n\n    def test_approved_domain_with_port_and_path(self):\n        # Test with approved domain, port, and path\n        url = 'http://example.com:8080/path?query=value'\n        result = secure_user_redirect(url)\n        self.assertEqual(result, url)\n\n    def test_approved_domain_mixed_case(self):\n        # Test mixed case domain returns normalized URL\n        url = 'http://ExAmPLe.CoM'\n        expected = 'http://example.com'\n        result = secure_user_redirect(url)\n        self.assertEqual(result, expected)\n\n    def test_not_approved_domain(self):\n        # Test domain not in approved list raises ValueError\n        url = 'http://evil.com'\n        with self.assertRaises(ValueError):\n            secure_user_redirect(url)\n\n    def test_subdomain_not_approved(self):\n        # Test subdomain of approved domain not in list raises\n        url = 'http://sub.example.com'\n        with self.assertRaises(ValueError):\n            secure_user_redirect(url)\n\n    def test_empty_string(self):\n        # Test empty string raises ValueError (hostname is None)\n        with self.assertRaises(ValueError):\n            secure_user_redirect('')\n\n    def test_relative_url(self):\n        # Test relative URL (no hostname) raises\n        url = '/path'\n        with self.assertRaises(ValueError):\n            secure_user_redirect(url)\n\n    def test_url_with_no_netloc(self):\n        # Test URL without netloc (hostname None) raises\n        url = 'file:///path'\n        with self.assertRaises(ValueError):\n            secure_user_redirect(url)\n\n    def test_long_domain(self):\n        # Test very long approved domain\n        domain = 'a' * 100 + '.com'\n        url = f'http://{domain}'\n        result = secure_user_redirect(url)\n        self.assertEqual(result, url)", "num_test_cases": 10, "task_id": "f80cb132"}
{"test": "import unittest\nfrom urllib.parse import urlparse\n\n# Define the global variables used by the function\nALLOWED_SCHEMES = ['http', 'https']\nTRUSTED_IMAGE_HOSTS = ['trusted1.com', 'trusted2.org', 'images.safe.net']\n\ndef fetch_image_url(img_url: str):\n    parsed_url = urlparse(img_url)\n    if parsed_url.scheme not in ALLOWED_SCHEMES or parsed_url.hostname not in TRUSTED_IMAGE_HOSTS:\n        raise ValueError(\"Image URL scheme or domain not trusted\")\n    return parsed_url.geturl()\n\nclass TestFetchImageUrl(unittest.TestCase):\n    def test_case_1(self):\n        # Valid https URL with trusted host\n        url = 'https://trusted1.com/image.jpg'\n        result = fetch_image_url(url)\n        self.assertEqual(result, url)\n\n    def test_case_2(self):\n        # Valid http URL with trusted host\n        url = 'http://trusted2.org/image.jpg'\n        result = fetch_image_url(url)\n        self.assertEqual(result, url)\n\n    def test_case_3(self):\n        # Valid URL with uppercase HTTP scheme\n        result = fetch_image_url('HTTP://images.safe.net/image.jpg')\n        self.assertEqual(result, 'http://images.safe.net/image.jpg')\n\n    def test_case_4(self):\n        # Valid URL with ftp scheme (unallowed)\n        with self.assertRaises(ValueError):\n            fetch_image_url('ftp://trusted1.com/image.jpg')\n\n    def test_case_5(self):\n        # Valid URL with untrusted host\n        with self.assertRaises(ValueError):\n            fetch_image_url('https://untrusted.com/image.jpg')\n\n    def test_case_6(self):\n        # Empty string input\n        with self.assertRaises(ValueError):\n            fetch_image_url('')\n\n    def test_case_7(self):\n        # None input\n        with self.assertRaises(TypeError):\n            fetch_image_url(None)\n\n    def test_case_8(self):\n        # URL with spaces in path\n        url = 'http://trusted1.com/path with spaces/image.jpg'\n        result = fetch_image_url(url)\n        self.assertEqual(result, url)\n\n    def test_case_9(self):\n        # URL without scheme\n        with self.assertRaises(ValueError):\n            fetch_image_url('trusted1.com/image.jpg')\n\n    def test_case_10(self):\n        # URL with port specification\n        url = 'http://trusted1.com:8080/image.jpg'\n        result = fetch_image_url(url)\n        self.assertEqual(result, url)\n\n    def test_case_11(self):\n        # URL without path\n        url = 'https://trusted1.com'\n        result = fetch_image_url(url)\n        self.assertEqual(result, url)\n\n    def test_case_12(self):\n        # Subdomain that mimics trusted host (untrusted)\n        with self.assertRaises(ValueError):\n            fetch_image_url('http://trusted1.com.example.com/image.jpg')\n\n    def test_case_13(self):\n        # Trusted host with trailing dot\n        with self.assertRaises(ValueError):\n            fetch_image_url('http://trusted1.com./image.jpg')\n\n    def test_case_14(self):\n        # IP address instead of hostname\n        with self.assertRaises(ValueError):\n            fetch_image_url('http://192.168.1.1/image.jpg')\n\n    def test_case_15(self):\n        # Very long URL\n        long_path = 'a' * 1000\n        url = f'https://trusted1.com/{long_path}'\n        result = fetch_image_url(url)\n        self.assertEqual(result, url)\n\n    def test_case_16(self):\n        # URL with query parameters\n        url = 'https://trusted1.com/path?key=value'\n        result = fetch_image_url(url)\n        self.assertEqual(result, url)\n\n    def test_case_17(self):\n        # URL with fragment\n        url = 'https://trusted1.com/path#section'\n        result = fetch_image_url(url)\n        self.assertEqual(result, url)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 17, "task_id": "19429ef7"}
{"test": "import unittest\nfrom unittest.mock import patch\n\nclass TestGetImageLink(unittest.TestCase):\n    @patch('solution.ALLOWED_SCHEMES', {'http', 'https'})\n    @patch('solution.TRUSTED_IMAGE_HOSTS', {'trusted1.com', 'trusted2.org', 'images.example.com'})\n    def test_valid_http_url(self):\n        # Test valid HTTP URL with trusted host\n        url = \"http://trusted1.com/image.jpg\"\n        result = get_image_link(url)\n        self.assertEqual(result, url)\n\n    @patch('solution.ALLOWED_SCHEMES', {'http', 'https'})\n    @patch('solution.TRUSTED_IMAGE_HOSTS', {'trusted1.com', 'trusted2.org', 'images.example.com'})\n    def test_valid_https_url(self):\n        # Test valid HTTPS URL with trusted host\n        url = \"https://images.example.com/photo.png\"\n        result = get_image_link(url)\n        self.assertEqual(result, url)\n\n    @patch('solution.ALLOWED_SCHEMES', {'http', 'https'})\n    @patch('solution.TRUSTED_IMAGE_HOSTS', {'trusted1.com', 'trusted2.org', 'images.example.com'})\n    def test_mixed_case_host(self):\n        # Test URL with mixed-case host (should be normalized and trusted)\n        url = \"http://TRUSTED2.ORG/IMAGE.GIF\"\n        expected = \"http://trusted2.org/IMAGE.GIF\"  # Host normalized to lowercase\n        result = get_image_link(url)\n        self.assertEqual(result, expected)\n\n    @patch('solution.ALLOWED_SCHEMES', {'http', 'https'})\n    @patch('solution.TRUSTED_IMAGE_HOSTS', {'trusted1.com', 'trusted2.org', 'images.example.com'})\n    def test_url_with_port_and_path(self):\n        # Test URL with port, path, and query parameters\n        url = \"https://trusted1.com:8080/path/to/image?width=200&height=300\"\n        result = get_image_link(url)\n        self.assertEqual(result, url)\n\n    @patch('solution.ALLOWED_SCHEMES', {'http', 'https'})\n    @patch('solution.TRUSTED_IMAGE_HOSTS', {'trusted1.com', 'trusted2.org', 'images.example.com'})\n    def test_untrusted_scheme(self):\n        # Test URL with untrusted scheme (ftp)\n        url = \"ftp://trusted1.com/image.jpg\"\n        with self.assertRaises(ValueError):\n            get_image_link(url)\n\n    @patch('solution.ALLOWED_SCHEMES', {'http', 'https'})\n    @patch('solution.TRUSTED_IMAGE_HOSTS', {'trusted1.com', 'trusted2.org', 'images.example.com'})\n    def test_untrusted_host(self):\n        # Test URL with trusted scheme but untrusted host\n        url = \"https://untrusted-domain.com/pic.jpg\"\n        with self.assertRaises(ValueError):\n            get_image_link(url)\n\n    @patch('solution.ALLOWED_SCHEMES', {'http', 'https'})\n    @patch('solution.TRUSTED_IMAGE_HOSTS', {'trusted1.com', 'trusted2.org', 'images.example.com'})\n    def test_no_scheme(self):\n        # Test URL without a scheme\n        url = \"trusted1.com/image.png\"\n        with self.assertRaises(ValueError):\n            get_image_link(url)\n\n    @patch('solution.ALLOWED_SCHEMES', {'http', 'https'})\n    @patch('solution.TRUSTED_IMAGE_HOSTS', {'trusted1.com', 'trusted2.org', 'images.example.com'})\n    def test_empty_string_url(self):\n        # Test empty URL string\n        url = \"\"\n        with self.assertRaises(ValueError):\n            get_image_link(url)\n\n    @patch('solution.ALLOWED_SCHEMES', {'http', 'https'})\n    @patch('solution.TRUSTED_IMAGE_HOSTS', {'trusted1.com', 'trusted2.org', 'images.example.com'})\n    def test_none_url(self):\n        # Test None input (should raise TypeError)\n        with self.assertRaises(TypeError):\n            get_image_link(None)\n\n    @patch('solution.ALLOWED_SCHEMES', {'http', 'https'})\n    @patch('solution.TRUSTED_IMAGE_HOSTS', {'trusted1.com', 'trusted2.org', 'images.example.com'})\n    def test_non_string_input(self):\n        # Test non-string input (integer)\n        with self.assertRaises(TypeError):\n            get_image_link(12345)\n\n    @patch('solution.ALLOWED_SCHEMES', {'http', 'https'})\n    @patch('solution.TRUSTED_IMAGE_HOSTS', {'trusted1.com', 'trusted2.org', 'images.example.com'})\n    def test_ip_address_url(self):\n        # Test URL with IP address host (untrusted)\n        url = \"http://192.168.1.1/image.jpg\"\n        with self.assertRaises(ValueError):\n            get_image_link(url)\n\n    @patch('solution.ALLOWED_SCHEMES', {'http', 'https'})\n    @patch('solution.TRUSTED_IMAGE_HOSTS', {'trusted1.com', 'trusted2.org', 'images.example.com'})\n    def test_trailing_dot_host(self):\n        # Test URL with trailing dot in host (considered different host)\n        url = \"http://trusted1.com./image.jpg\"\n        with self.assertRaises(ValueError):\n            get_image_link(url)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 12, "task_id": "e989108c"}
{"test": "import unittest\nfrom unittest.mock import patch\n\nclass TestValidateImageSource(unittest.TestCase):\n    trusted_hosts = {'trusted1.com', 'trusted2.com', 'images.example.com'}\n    allowed_schemes = {'http', 'https'}\n\n    @classmethod\n    def setUpClass(cls):\n        cls.patcher1 = patch('image_utils.TRUSTED_IMAGE_HOSTS', cls.trusted_hosts)\n        cls.patcher2 = patch('image_utils.ALLOWED_SCHEMES', cls.allowed_schemes)\n        cls.patcher1.start()\n        cls.patcher2.start()\n\n    @classmethod\n    def tearDownClass(cls):\n        cls.patcher1.stop()\n        cls.patcher2.stop()\n\n    def test_valid_https(self):\n        # Test valid URL with https scheme and trusted domain\n        url = 'https://trusted1.com/image.jpg'\n        result = validate_image_source(url)\n        self.assertEqual(result, url)\n\n    def test_valid_http(self):\n        # Test valid URL with http scheme and trusted domain\n        url = 'http://trusted2.com/image.jpg'\n        result = validate_image_source(url)\n        self.assertEqual(result, url)\n\n    def test_valid_with_port_and_query(self):\n        # Test valid URL with port and query parameters\n        url = 'https://images.example.com:8080/image.jpg?width=100&height=200'\n        result = validate_image_source(url)\n        self.assertEqual(result, url)\n\n    def test_invalid_scheme(self):\n        # Test URL with trusted domain but invalid scheme (ftp)\n        url = 'ftp://trusted1.com/image.jpg'\n        with self.assertRaises(ValueError):\n            validate_image_source(url)\n\n    def test_untrusted_domain(self):\n        # Test URL with untrusted domain\n        url = 'https://untrusted.com/image.jpg'\n        with self.assertRaises(ValueError):\n            validate_image_source(url)\n\n    def test_none_input(self):\n        # Test input is None (non-string)\n        with self.assertRaises(TypeError):\n            validate_image_source(None)\n\n    def test_empty_string(self):\n        # Test empty string input\n        url = ''\n        with self.assertRaises(ValueError):\n            validate_image_source(url)\n\n    def test_subdomain_not_trusted(self):\n        # Test URL with untrusted subdomain of trusted domain\n        url = 'https://sub.trusted1.com/image.jpg'\n        with self.assertRaises(ValueError):\n            validate_image_source(url)\n\n    def test_long_trusted_url(self):\n        # Test very long trusted URL\n        url = 'https://images.example.com/' + 'a' * 1000\n        result = validate_image_source(url)\n        self.assertEqual(result, url)\n\n    def test_long_untrusted_url(self):\n        # Test very long untrusted URL\n        url = 'https://untrusted.example.com/' + 'a' * 1000\n        with self.assertRaises(ValueError):\n            validate_image_source(url)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 10, "task_id": "eca166d2"}
{"test": "import unittest\nfrom urllib.parse import urlparse\n\n# Define trusted domains and allowed schemes for testing\nALLOWED_SCHEMES = {'http', 'https'}\nTRUSTED_IMAGE_HOSTS = {\n    'trusted1.com',\n    'trusted2.org',\n    'images.example.com',\n    '127.0.0.1'  # For testing IP address\n}\n\n# Define the function under test\ndef fetch_image_url(url: str):\n    parsed_url = urlparse(url)\n    if parsed_url.scheme not in ALLOWED_SCHEMES or parsed_url.hostname not in TRUSTED_IMAGE_HOSTS:\n        raise ValueError(\"Image URL scheme or domain not trusted\")\n    return parsed_url.geturl()\n\nclass TestFetchImageUrl(unittest.TestCase):\n    \n    def test_valid_http(self):\n        \"\"\"Test a valid URL with http scheme and trusted host.\"\"\"\n        url = \"http://trusted1.com/image.jpg\"\n        self.assertEqual(fetch_image_url(url), url)\n    \n    def test_valid_https(self):\n        \"\"\"Test a valid URL with https scheme and trusted host.\"\"\"\n        url = \"https://trusted2.org\"\n        self.assertEqual(fetch_image_url(url), url)\n    \n    def test_with_port_path_query_fragment(self):\n        \"\"\"Test a valid URL with port, path, query, and fragment.\"\"\"\n        url = \"http://images.example.com:8080/path/to/image?width=200&height=200#fragment\"\n        self.assertEqual(fetch_image_url(url), url)\n    \n    def test_untrusted_scheme(self):\n        \"\"\"Test URL with untrusted scheme (ftp) and trusted host.\"\"\"\n        url = \"ftp://trusted1.com/image.jpg\"\n        with self.assertRaises(ValueError):\n            fetch_image_url(url)\n    \n    def test_untrusted_host(self):\n        \"\"\"Test URL with trusted scheme but untrusted host.\"\"\"\n        url = \"http://untrusted.com/image.jpg\"\n        with self.assertRaises(ValueError):\n            fetch_image_url(url)\n    \n    def test_none_url(self):\n        \"\"\"Test that None URL raises AttributeError.\"\"\"\n        with self.assertRaises(AttributeError):\n            fetch_image_url(None)\n    \n    def test_non_string_url(self):\n        \"\"\"Test that non-string URL (integer) raises TypeError.\"\"\"\n        with self.assertRaises(TypeError):\n            fetch_image_url(123)\n    \n    def test_empty_string(self):\n        \"\"\"Test empty string URL raises ValueError.\"\"\"\n        with self.assertRaises(ValueError):\n            fetch_image_url('')\n    \n    def test_upper_case_scheme(self):\n        \"\"\"Test URL with uppercase HTTP scheme (should be normalized and allowed).\"\"\"\n        url = \"HTTP://trusted1.com\"\n        self.assertEqual(fetch_image_url(url), url)\n    \n    def test_host_with_trailing_dot(self):\n        \"\"\"Test URL with trusted host but trailing dot (should be untrusted).\"\"\"\n        url = \"http://trusted1.com.\"\n        with self.assertRaises(ValueError):\n            fetch_image_url(url)\n    \n    def test_untrusted_ip_address(self):\n        \"\"\"Test URL with untrusted IP address.\"\"\"\n        url = \"http://192.168.1.1/image.jpg\"\n        with self.assertRaises(ValueError):\n            fetch_image_url(url)\n    \n    def test_trusted_ip_address(self):\n        \"\"\"Test URL with trusted IP address.\"\"\"\n        url = \"http://127.0.0.1/image.jpg\"\n        self.assertEqual(fetch_image_url(url), url)\n    \n    def test_mixed_case_host(self):\n        \"\"\"Test URL with mixed-case trusted host (should be normalized and trusted).\"\"\"\n        url = \"http://TrUsTeD1.CoM\"\n        self.assertEqual(fetch_image_url(url), url)\n    \n    def test_invalid_ipv6_url(self):\n        \"\"\"Test an invalid IPv6 URL format (should be untrusted).\"\"\"\n        url = \"http://[::1]\"  # Not in trusted hosts\n        with self.assertRaises(ValueError):\n            fetch_image_url(url)", "num_test_cases": 14, "task_id": "2ca2ffb2"}
{"test": "import unittest\nfrom unittest.mock import patch\n\nclass TestVerifyImageUrl(unittest.TestCase):\n    @classmethod\n    def setUpClass(cls):\n        # Define trusted hosts and allowed schemes for the tests\n        cls.allowed_schemes = {'http', 'https'}\n        cls.trusted_hosts = {'trusted1.com', 'trusted2.org'}\n\n    @patch('solution.TRUSTED_IMAGE_HOSTS', {'trusted1.com', 'trusted2.org'})\n    @patch('solution.ALLOWED_SCHEMES', {'http', 'https'})\n    def test_case_1(self):\n        # Test basic HTTP URL with trusted host\n        url = \"http://trusted1.com\"\n        result = verify_image_url(url)\n        self.assertEqual(result, \"http://trusted1.com\")\n\n    @patch('solution.TRUSTED_IMAGE_HOSTS', {'trusted1.com', 'trusted2.org'})\n    @patch('solution.ALLOWED_SCHEMES', {'http', 'https'})\n    def test_case_2(self):\n        # Test basic HTTPS URL with trusted host\n        url = \"https://trusted2.org\"\n        result = verify_image_url(url)\n        self.assertEqual(result, \"https://trusted2.org\")\n\n    @patch('solution.TRUSTED_IMAGE_HOSTS', {'trusted1.com', 'trusted2.org'})\n    @patch('solution.ALLOWED_SCHEMES', {'http', 'https'})\n    def test_case_3(self):\n        # Test URL with port number\n        url = \"http://trusted1.com:8080/image.jpg\"\n        result = verify_image_url(url)\n        self.assertEqual(result, \"http://trusted1.com:8080/image.jpg\")\n\n    @patch('solution.TRUSTED_IMAGE_HOSTS', {'trusted1.com', 'trusted2.org'})\n    @patch('solution.ALLOWED_SCHEMES', {'http', 'https'})\n    def test_case_4(self):\n        # Test URL with path and query parameters\n        url = \"https://trusted2.org/path/to/img?width=200&height=300\"\n        result = verify_image_url(url)\n        self.assertEqual(result, \"https://trusted2.org/path/to/img?width=200&height=300\")\n\n    @patch('solution.TRUSTED_IMAGE_HOSTS', {'trusted1.com', 'trusted2.org'})\n    @patch('solution.ALLOWED_SCHEMES', {'http', 'https'})\n    def test_case_5(self):\n        # Test disallowed scheme (FTP) with trusted host\n        with self.assertRaises(ValueError):\n            verify_image_url(\"ftp://trusted1.com/image.jpg\")\n\n    @patch('solution.TRUSTED_IMAGE_HOSTS', {'trusted1.com', 'trusted2.org'})\n    @patch('solution.ALLOWED_SCHEMES', {'http', 'https'})\n    def test_case_6(self):\n        # Test allowed scheme (HTTP) with untrusted host\n        with self.assertRaises(ValueError):\n            verify_image_url(\"http://untrusted.com/image.jpg\")\n\n    @patch('solution.TRUSTED_IMAGE_HOSTS', {'trusted1.com', 'trusted2.org'})\n    @patch('solution.ALLOWED_SCHEMES', {'http', 'https'})\n    def test_case_7(self):\n        # Test empty URL string\n        with self.assertRaises(ValueError):\n            verify_image_url(\"\")\n\n    @patch('solution.TRUSTED_IMAGE_HOSTS', {'trusted1.com', 'trusted2.org'})\n    @patch('solution.ALLOWED_SCHEMES', {'http', 'https'})\n    def test_case_8(self):\n        # Test None input\n        with self.assertRaises(Exception):\n            verify_image_url(None)\n\n    @patch('solution.TRUSTED_IMAGE_HOSTS', {'trusted1.com', 'trusted2.org'})\n    @patch('solution.ALLOWED_SCHEMES', {'http', 'https'})\n    def test_case_9(self):\n        # Test non-string input (integer)\n        with self.assertRaises(Exception):\n            verify_image_url(123)\n\n    @patch('solution.TRUSTED_IMAGE_HOSTS', {'trusted1.com', 'trusted2.org'})\n    @patch('solution.ALLOWED_SCHEMES', {'http', 'https'})\n    def test_case_10(self):\n        # Test very long URL with trusted host\n        long_path = \"/\" + \"a\" * 1000\n        url = \"https://trusted1.com\" + long_path\n        result = verify_image_url(url)\n        self.assertEqual(result, url)\n\n    @patch('solution.TRUSTED_IMAGE_HOSTS', {'example.com'})\n    @patch('solution.ALLOWED_SCHEMES', {'http', 'https'})\n    def test_case_11(self):\n        # Test trusted host substring should not match\n        with self.assertRaises(ValueError):\n            verify_image_url(\"http://myexample.com\")\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 11, "task_id": "4813126c"}
{"test": "import unittest\nfrom unittest.mock import patch\nfrom urllib.parse import urlparse\n\n# Assuming the function is defined in a module named 'solution'\nfrom solution import check_image_link\n\nclass TestCheckImageLink(unittest.TestCase):\n    @classmethod\n    def setUpClass(cls):\n        # Patch the constants in the solution module to defined test values\n        cls.patcher_schemes = patch('solution.ALLOWED_SCHEMES', {'http', 'https'})\n        cls.patcher_hosts = patch('solution.TRUSTED_IMAGE_HOSTS', {'trusted1.com', 'trusted2.org', 'images.trusted.net'})\n        cls.patcher_schemes.start()\n        cls.patcher_hosts.start()\n\n    @classmethod\n    def tearDownClass(cls):\n        # Stop patching\n        cls.patcher_schemes.stop()\n        cls.patcher_hosts.stop()\n\n    def test_valid_http_trusted_host(self):\n        # Test valid http URL with trusted host\n        url = \"http://trusted1.com/path/to/image\"\n        self.assertEqual(check_image_link(url), url)\n\n    def test_valid_https_trusted_host(self):\n        # Test valid https URL with trusted host\n        url = \"https://trusted2.org/image.png\"\n        self.assertEqual(check_image_link(url), url)\n\n    def test_valid_http_with_port(self):\n        # Test valid http URL with trusted host and port\n        url = \"http://images.trusted.net:8080/pic.jpg\"\n        self.assertEqual(check_image_link(url), url)\n\n    def test_valid_https_with_port(self):\n        # Test valid https URL with trusted host and port\n        url = \"https://trusted1.com:8443/resource\"\n        self.assertEqual(check_image_link(url), url)\n\n    def test_untrusted_host_http(self):\n        # Test http URL with untrusted host\n        with self.assertRaises(ValueError):\n            check_image_link(\"http://untrusted.com/image.jpg\")\n\n    def test_untrusted_host_https(self):\n        # Test https URL with untrusted host\n        with self.assertRaises(ValueError):\n            check_image_link(\"https://untrusted.org/\")\n\n    def test_invalid_scheme_trusted_host(self):\n        # Test ftp scheme with trusted host\n        with self.assertRaises(ValueError):\n            check_image_link(\"ftp://trusted1.com/file\")\n\n    def test_empty_string(self):\n        # Test empty string input\n        with self.assertRaises(ValueError):\n            check_image_link(\"\")\n\n    def test_none_input(self):\n        # Test None input (non-string)\n        with self.assertRaises(TypeError):\n            check_image_link(None)\n\n    def test_non_string_input(self):\n        # Test non-string input (integer)\n        with self.assertRaises(TypeError):\n            check_image_link(123)\n\n    def test_long_valid_url(self):\n        # Test long URL with valid trusted host\n        long_path = \"/\" + \"a\" * 1000\n        url = \"http://trusted1.com\" + long_path\n        self.assertEqual(check_image_link(url), url)\n\n    def test_long_invalid_url(self):\n        # Test long URL with untrusted host\n        long_path = \"/\" + \"a\" * 1000\n        url = \"http://untrusted.com\" + long_path\n        with self.assertRaises(ValueError):\n            check_image_link(url)\n\n    def test_mixed_case_host(self):\n        # Test URL with mixed case hostname (should be normalized to lowercase)\n        input_url = \"http://TRUSTED1.com/Path\"\n        expected_url = \"http://trusted1.com/Path\"  # Hostname normalized to lowercase\n        self.assertEqual(check_image_link(input_url), expected_url)\n\n    def test_untrusted_ip_address(self):\n        # Test URL with untrusted IP address\n        with self.assertRaises(ValueError):\n            check_image_link(\"http://192.168.1.1/image.jpg\")", "num_test_cases": 14, "task_id": "74a8ee29"}
{"test": "import unittest\nimport solution\nfrom solution import check_image_url\n\nclass TestCases(unittest.TestCase):\n    @classmethod\n    def setUpClass(cls):\n        # Set trusted domains and schemes for testing\n        solution.ALLOWED_SCHEMES = {'http', 'https'}\n        solution.TRUSTED_IMAGE_HOSTS = {'example.com', 'images.trusted.org'}\n\n    def test_case_1(self):\n        # Valid URL with http and trusted domain (exact case)\n        url = 'http://example.com'\n        result = check_image_url(url)\n        self.assertEqual(result, 'http://example.com')\n\n    def test_case_2(self):\n        # Valid URL with https and trusted domain (exact case)\n        url = 'https://images.trusted.org/path/to/image'\n        result = check_image_url(url)\n        self.assertEqual(result, 'https://images.trusted.org/path/to/image')\n\n    def test_case_3(self):\n        # Valid URL with http and trusted domain in different case (should fail)\n        url = 'http://Example.COM'\n        with self.assertRaises(ValueError):\n            check_image_url(url)\n\n    def test_case_4(self):\n        # Valid URL with https and trusted domain in different case (should fail)\n        url = 'https://Images.Trusted.Org'\n        with self.assertRaises(ValueError):\n            check_image_url(url)\n\n    def test_case_5(self):\n        # Trusted domain with disallowed ftp scheme\n        url = 'ftp://example.com'\n        with self.assertRaises(ValueError):\n            check_image_url(url)\n\n    def test_case_6(self):\n        # Non-trusted domain with allowed scheme\n        url = 'http://untrusted.com'\n        with self.assertRaises(ValueError):\n            check_image_url(url)\n\n    def test_case_7(self):\n        # Trusted domain with non-default port (should include port in result)\n        url = 'http://example.com:8080'\n        result = check_image_url(url)\n        self.assertEqual(result, 'http://example.com:8080')\n\n    def test_case_8(self):\n        # Missing scheme (relative URL)\n        url = 'example.com'\n        with self.assertRaises(ValueError):\n            check_image_url(url)\n\n    def test_case_9(self):\n        # No hostname (relative path)\n        url = '/path/to/image'\n        with self.assertRaises(ValueError):\n            check_image_url(url)\n\n    def test_case_10(self):\n        # Empty string input\n        url = ''\n        with self.assertRaises(ValueError):\n            check_image_url(url)\n\n    def test_case_11(self):\n        # None input (invalid type)\n        with self.assertRaises(TypeError):\n            check_image_url(None)\n\n    def test_case_12(self):\n        # Non-string input (integer)\n        with self.assertRaises(TypeError):\n            check_image_url(123)\n\n    def test_case_13(self):\n        # URL with userinfo and trusted domain\n        url = 'http://user:pass@example.com'\n        result = check_image_url(url)\n        self.assertEqual(result, 'http://user:pass@example.com')\n\n    def test_case_14(self):\n        # HTTP URL with default port (80) should be removed\n        url = 'http://example.com:80'\n        result = check_image_url(url)\n        self.assertEqual(result, 'http://example.com')\n\n    def test_case_15(self):\n        # HTTPS URL with default port (443) should be removed\n        url = 'https://example.com:443'\n        result = check_image_url(url)\n        self.assertEqual(result, 'https://example.com')\n\n    def test_case_16(self):\n        # HTTPS URL with non-default port (80) should be included\n        url = 'https://example.com:80'\n        result = check_image_url(url)\n        self.assertEqual(result, 'https://example.com:80')", "num_test_cases": 16, "task_id": "dddcfa21"}
{"test": "import unittest\\nfrom urllib.parse import urlparse\\nimport solution\\nfrom solution import validate_picture_url\\n\\nclass TestValidatePictureUrl(unittest.TestCase):\\n    def setUp(self):\\n        solution.ALLOWED_SCHEMES = {'http', 'https'}\\n        solution.TRUSTED_IMAGE_HOSTS = {'trusted1.com', 'trusted2.org', 'images.trusted3.net'}\\n\\n    def test_case_1(self):\\n        # Valid http URL with trusted host\\n        url = 'http://trusted1.com'\\n        result = validate_picture_url(url)\\n        self.assertEqual(result, url)\\n\\n    def test_case_2(self):\\n        # Valid https URL with trusted host\\n        url = 'https://trusted2.org'\\n        result = validate_picture_url(url)\\n        self.assertEqual(result, url)\\n\\n    def test_case_3(self):\\n        # Valid URL with path and query\\n        url = 'http://images.trusted3.net/logo.png?size=large'\\n        result = validate_picture_url(url)\\n        self.assertEqual(result, url)\\n\\n    def test_case_4(self):\\n        # Valid URL with port\\n        url = 'http://trusted1.com:8080'\\n        result = validate_picture_url(url)\\n        self.assertEqual(result, url)\\n\\n    def test_case_5(self):\\n        # Valid URL with fragment\\n        url = 'https://trusted2.org/about#team'\\n        result = validate_picture_url(url)\\n        self.assertEqual(result, url)\\n\\n    def test_case_6(self):\\n        # Invalid scheme (ftp)\\n        url = 'ftp://trusted1.com'\\n        with self.assertRaises(ValueError):\\n            validate_picture_url(url)\\n\\n    def test_case_7(self):\\n        # Untrusted host\\n        url = 'http://untrusted.com'\\n        with self.assertRaises(ValueError):\\n            validate_picture_url(url)\\n\\n    def test_case_8(self):\\n        # Trusted host in different case (case-sensitive)\\n        url = 'http://TRUSTED1.COM'\\n        with self.assertRaises(ValueError):\\n            validate_picture_url(url)\\n\\n    def test_case_9(self):\\n        # Subdomain of trusted host\\n        url = 'http://sub.trusted1.com'\\n        with self.assertRaises(ValueError):\\n            validate_picture_url(url)\\n\\n    def test_case_10(self):\\n        # Invalid URL string\\n        url = 'not_a_url'\\n        with self.assertRaises(ValueError):\\n            validate_picture_url(url)\\n\\n    def test_case_11(self):\\n        # None input\\n        with self.assertRaises(TypeError):\\n            validate_picture_url(None)\\n\\n    def test_case_12(self):\\n        # Non-string input (integer)\\n        with self.assertRaises(TypeError):\\n            validate_picture_url(123)\\n\\n    def test_case_13(self):\\n        # Trusted host with trailing dot (not in trusted set)\\n        url = 'http://trusted1.com.'\\n        with self.assertRaises(ValueError):\\n            validate_picture_url(url)\\n\\n    def test_case_14(self):\\n        # URL with leading space (invalid)\\n        url = ' http://trusted1.com'\\n        with self.assertRaises(ValueError):\\n            validate_picture_url(url)\\n\\nif __name__ == '__main__':\\n    unittest.main()", "num_test_cases": 14, "task_id": "6151a2f9"}
{"test": "import unittest\nfrom urllib.parse import urlparse\n\n# Define the constants required by the function\nAPPROVED_API_DOMAINS = ['example.com', 'api.example.org', '8.8.8.8', '10.0.0.1']\nINTERNAL_IP_RANGES = ['10.', '192.168.']\n\n# The function handle_webhook is assumed to be available for testing\n\nclass TestHandleWebhook(unittest.TestCase):\n\n    def test_valid_url(self):\n        # Test a valid URL with an approved domain and public IP\n        url = 'http://example.com/api'\n        result = handle_webhook(url)\n        self.assertEqual(result, url)\n\n    def test_localhost(self):\n        # Test a URL with 'localhost' hostname (should be blocked)\n        with self.assertRaises(ValueError) as context:\n            handle_webhook('http://localhost/api')\n        self.assertEqual(str(context.exception), \"Access to internal addresses is blocked\")\n\n    def test_internal_ip(self):\n        # Test a URL with an internal IP address (should be blocked)\n        with self.assertRaises(ValueError) as context:\n            handle_webhook('http://192.168.1.1/api')\n        self.assertEqual(str(context.exception), \"Access to internal addresses is blocked\")\n\n    def test_unapproved_domain(self):\n        # Test a URL with an unapproved domain\n        with self.assertRaises(ValueError) as context:\n            handle_webhook('http://unapproved.com/api')\n        self.assertEqual(str(context.exception), \"Webhook URL not from an approved API domain\")\n\n    def test_empty_string(self):\n        # Test an empty URL string\n        with self.assertRaises(ValueError) as context:\n            handle_webhook('')\n        self.assertEqual(str(context.exception), \"Webhook URL not from an approved API domain\")\n\n    def test_none(self):\n        # Test None input (invalid type)\n        with self.assertRaises(Exception):\n            handle_webhook(None)\n\n    def test_non_string(self):\n        # Test non-string input (invalid type)\n        with self.assertRaises(Exception):\n            handle_webhook(123)\n\n    def test_relative_url(self):\n        # Test a relative URL (no hostname)\n        with self.assertRaises(ValueError) as context:\n            handle_webhook('path/to/api')\n        self.assertEqual(str(context.exception), \"Webhook URL not from an approved API domain\")\n\n    def test_public_domain_with_internal_ip_prefix(self):\n        # Test a public domain that starts with an internal IP prefix (should be blocked by string check)\n        with self.assertRaises(ValueError) as context:\n            handle_webhook('http://192.168example.com/api')\n        self.assertEqual(str(context.exception), \"Access to internal addresses is blocked\")\n\n    def test_valid_url_with_port(self):\n        # Test a valid URL with a port number\n        url = 'http://example.com:8080/api'\n        result = handle_webhook(url)\n        self.assertEqual(result, url)\n\n    def test_valid_https_url(self):\n        # Test a valid HTTPS URL\n        url = 'https://api.example.org/api'\n        result = handle_webhook(url)\n        self.assertEqual(result, url)\n\n    def test_approved_public_ip(self):\n        # Test a URL with an approved public IP address\n        url = 'http://8.8.8.8/api'\n        result = handle_webhook(url)\n        self.assertEqual(result, url)\n\n    def test_unapproved_public_ip(self):\n        # Test a URL with an unapproved public IP address\n        with self.assertRaises(ValueError) as context:\n            handle_webhook('http://1.2.3.4/api')\n        self.assertEqual(str(context.exception), \"Webhook URL not from an approved API domain\")\n\n    def test_internal_ip_approved_but_blocked(self):\n        # Test an internal IP that is in the approved list but blocked by internal IP check\n        with self.assertRaises(ValueError) as context:\n            handle_webhook('http://10.0.0.1/api')\n        self.assertEqual(str(context.exception), \"Access to internal addresses is blocked\")", "num_test_cases": 14, "task_id": "21798828"}
{"test": "import unittest\nimport webhook_manager\nfrom webhook_manager import manage_webhook\n\n# Set up global variables for the tests\nwebhook_manager.APPROVED_API_DOMAINS = {'example.com', 'api.example.org'}\nwebhook_manager.INTERNAL_IP_RANGES = ['192.168.', '10.', '127.0.0.1', 'localhost']\n\nclass TestManageWebhook(unittest.TestCase):\n\n    def test_approved_domain(self):\n        # Test a URL with an approved domain\n        url = 'http://example.com'\n        result = manage_webhook(url)\n        self.assertEqual(result, 'http://example.com')\n\n    def test_approved_domain_with_port(self):\n        # Test a URL with an approved domain and port\n        url = 'http://api.example.org:8000'\n        result = manage_webhook(url)\n        self.assertEqual(result, 'http://api.example.org:8000')\n\n    def test_approved_domain_mixed_case(self):\n        # Test a URL with mixed case in the approved domain (should be normalized to lower)\n        url = 'http://ExAmPlE.CoM'\n        result = manage_webhook(url)\n        self.assertEqual(result, 'http://example.com')\n\n    def test_approved_domain_with_path(self):\n        # Test a URL with an approved domain and a path\n        url = 'http://example.com/api/webhook'\n        result = manage_webhook(url)\n        self.assertEqual(result, 'http://example.com/api/webhook')\n\n    def test_unapproved_domain(self):\n        # Test a URL with an unapproved domain\n        url = 'http://unapproved.com'\n        with self.assertRaises(ValueError):\n            manage_webhook(url)\n\n    def test_localhost(self):\n        # Test a URL with localhost\n        url = 'http://localhost'\n        with self.assertRaises(ValueError):\n            manage_webhook(url)\n\n    def test_localhost_with_port(self):\n        # Test a URL with localhost and port\n        url = 'http://localhost:8000'\n        with self.assertRaises(ValueError):\n            manage_webhook(url)\n\n    def test_internal_ip_192_168(self):\n        # Test a URL with internal IP in 192.168. range\n        url = 'http://192.168.0.1'\n        with self.assertRaises(ValueError):\n            manage_webhook(url)\n\n    def test_internal_ip_10(self):\n        # Test a URL with internal IP in 10. range\n        url = 'http://10.0.0.1'\n        with self.assertRaises(ValueError):\n            manage_webhook(url)\n\n    def test_127_0_0_1(self):\n        # Test a URL with 127.0.0.1\n        url = 'http://127.0.0.1'\n        with self.assertRaises(ValueError):\n            manage_webhook(url)\n\n    def test_internal_ip_prefix_in_domain(self):\n        # Test a URL with a domain starting like an internal IP\n        url = 'http://10.com'\n        with self.assertRaises(ValueError):\n            manage_webhook(url)\n\n    def test_empty_string(self):\n        # Test an empty URL string\n        url = ''\n        with self.assertRaises(ValueError):\n            manage_webhook(url)\n\n    def test_none_input(self):\n        # Test None input\n        with self.assertRaises(TypeError):\n            manage_webhook(None)\n\n    def test_non_string_input(self):\n        # Test non-string input (integer)\n        with self.assertRaises(TypeError):\n            manage_webhook(12345)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 14, "task_id": "f94b1353"}
{"test": "import unittest\nfrom unittest.mock import patch\n\nclass TestProcessHook(unittest.TestCase):\n    \n    def setUp(self):\n        self.approved_domains = {'example.com', 'api.example.org'}\n        self.internal_ip_ranges = ['10.', '192.168.', '127.0.0.']\n    \n    def test_valid_approved_domain(self):\n        # Happy path: Basic approved domain\n        with patch('solution.APPROVED_API_DOMAINS', self.approved_domains), \\\n             patch('solution.INTERNAL_IP_RANGES', self.internal_ip_ranges):\n            url = \"http://example.com\"\n            self.assertEqual(process_hook(url), url)\n    \n    def test_approved_domain_with_path(self):\n        # Happy path: Approved domain with path and query parameters\n        with patch('solution.APPROVED_API_DOMAINS', self.approved_domains), \\\n             patch('solution.INTERNAL_IP_RANGES', self.internal_ip_ranges):\n            url = \"https://api.example.org/path?query=value\"\n            self.assertEqual(process_hook(url), url)\n    \n    def test_approved_domain_with_port(self):\n        # Happy path: Approved domain with port number\n        with patch('solution.APPROVED_API_DOMAINS', self.approved_domains), \\\n             patch('solution.INTERNAL_IP_RANGES', self.internal_ip_ranges):\n            url = \"http://example.com:8080\"\n            self.assertEqual(process_hook(url), url)\n    \n    def test_approved_domain_with_fragment(self):\n        # Happy path: Approved domain with URL fragment\n        with patch('solution.APPROVED_API_DOMAINS', self.approved_domains), \\\n             patch('solution.INTERNAL_IP_RANGES', self.internal_ip_ranges):\n            url = \"http://example.com#section\"\n            self.assertEqual(process_hook(url), url)\n    \n    def test_uppercase_domain_normalization(self):\n        # Happy path: Domain normalization to lowercase\n        with patch('solution.APPROVED_API_DOMAINS', self.approved_domains), \\\n             patch('solution.INTERNAL_IP_RANGES', self.internal_ip_ranges):\n            url = \"http://EXAMPLE.COM\"\n            self.assertEqual(process_hook(url), \"http://example.com\")\n    \n    def test_empty_string(self):\n        # Edge case: Empty URL string\n        with patch('solution.APPROVED_API_DOMAINS', self.approved_domains), \\\n             patch('solution.INTERNAL_IP_RANGES', self.internal_ip_ranges):\n            with self.assertRaises(ValueError) as context:\n                process_hook(\"\")\n            self.assertIn(\"Webhook URL not from an approved API domain\", str(context.exception))\n    \n    def test_none_input(self):\n        # Error handling: None input\n        with patch('solution.APPROVED_API_DOMAINS', self.approved_domains), \\\n             patch('solution.INTERNAL_IP_RANGES', self.internal_ip_ranges):\n            with self.assertRaises(TypeError):\n                process_hook(None)\n    \n    def test_non_string_input(self):\n        # Error handling: Non-string input (integer)\n        with patch('solution.APPROVED_API_DOMAINS', self.approved_domains), \\\n             patch('solution.INTERNAL_IP_RANGES', self.internal_ip_ranges):\n            with self.assertRaises(TypeError):\n                process_hook(123)\n    \n    def test_unapproved_domain(self):\n        # Error handling: Unapproved domain\n        with patch('solution.APPROVED_API_DOMAINS', self.approved_domains), \\\n             patch('solution.INTERNAL_IP_RANGES', self.internal_ip_ranges):\n            with self.assertRaises(ValueError) as context:\n                process_hook(\"http://unapproved.com\")\n            self.assertIn(\"Webhook URL not from an approved API domain\", str(context.exception))\n    \n    def test_localhost_blocked(self):\n        # Error handling: Block localhost explicitly\n        with patch('solution.APPROVED_API_DOMAINS', self.approved_domains), \\\n             patch('solution.INTERNAL_IP_RANGES', self.internal_ip_ranges):\n            with self.assertRaises(ValueError) as context:\n                process_hook(\"http://localhost\")\n            self.assertIn(\"Access to internal addresses is blocked\", str(context.exception))\n    \n    def test_internal_ip_192_blocked(self):\n        # Error handling: Block internal IP (192.168.x)\n        with patch('solution.APPROVED_API_DOMAINS', self.approved_domains), \\\n             patch('solution.INTERNAL_IP_RANGES', self.internal_ip_ranges):\n            with self.assertRaises(ValueError) as context:\n                process_hook(\"http://192.168.1.1\")\n            self.assertIn(\"Access to internal addresses is blocked\", str(context.exception))\n    \n    def test_internal_ip_10_blocked(self):\n        # Error handling: Block internal IP (10.x)\n        with patch('solution.APPROVED_API_DOMAINS', self.approved_domains), \\\n             patch('solution.INTERNAL_IP_RANGES', self.internal_ip_ranges):\n            with self.assertRaises(ValueError) as context:\n                process_hook(\"http://10.0.0.1\")\n            self.assertIn(\"Access to internal addresses is blocked\", str(context.exception))\n    \n    def test_loopback_ip_blocked(self):\n        # Error handling: Block loopback IP (127.0.0.x)\n        with patch('solution.APPROVED_API_DOMAINS', self.approved_domains), \\\n             patch('solution.INTERNAL_IP_RANGES', self.internal_ip_ranges):\n            with self.assertRaises(ValueError) as context:\n                process_hook(\"http://127.0.0.1\")\n            self.assertIn(\"Access to internal addresses is blocked\", str(context.exception))\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 13, "task_id": "7bf02858"}
{"test": "import unittest\nfrom unittest.mock import patch\nfrom solution import validate_webhook\n\n# Define our own approved domains and internal IP ranges for testing\nAPPROVED_API_DOMAINS = {'example.com', 'api.example.com', '8.8.8.8'}\nINTERNAL_IP_RANGES = ['192.168.', '10.', '172.16.', '127.', 'localhost']\n\nclass TestValidateWebhook(unittest.TestCase):\n    def setUp(self):\n        # Patch the global variables in the solution module\n        self.patcher1 = patch('solution.APPROVED_API_DOMAINS', APPROVED_API_DOMAINS)\n        self.patcher2 = patch('solution.INTERNAL_IP_RANGES', INTERNAL_IP_RANGES)\n        self.patcher1.start()\n        self.patcher2.start()\n\n    def tearDown(self):\n        self.patcher1.stop()\n        self.patcher2.stop()\n\n    def test_valid_domain(self):\n        # Test a valid approved domain\n        url = 'https://example.com/path'\n        result = validate_webhook(url)\n        self.assertEqual(result, url)\n\n    def test_valid_domain_with_port(self):\n        # Test a valid approved domain with port\n        url = 'https://example.com:8080/path'\n        result = validate_webhook(url)\n        self.assertEqual(result, url)\n\n    def test_valid_ip(self):\n        # Test a valid approved public IP address\n        url = 'http://8.8.8.8/path'\n        result = validate_webhook(url)\n        self.assertEqual(result, url)\n\n    def test_invalid_localhost(self):\n        # Test with localhost (explicitly blocked)\n        with self.assertRaises(ValueError):\n            validate_webhook('http://localhost/path')\n\n    def test_invalid_127_0_0_1(self):\n        # Test with 127.0.0.1 (blocked by internal IP range)\n        with self.assertRaises(ValueError):\n            validate_webhook('http://127.0.0.1/path')\n\n    def test_invalid_192_168(self):\n        # Test with 192.168.1.1 (blocked by internal IP range)\n        with self.assertRaises(ValueError):\n            validate_webhook('http://192.168.1.1/path')\n\n    def test_invalid_10_0_0_1(self):\n        # Test with 10.0.0.1 (blocked by internal IP range)\n        with self.assertRaises(ValueError):\n            validate_webhook('http://10.0.0.1/path')\n\n    def test_unapproved_domain(self):\n        # Test with an unapproved domain\n        with self.assertRaises(ValueError):\n            validate_webhook('http://unknown.com/path')\n\n    def test_url_without_hostname(self):\n        # Test a URL without a hostname (None)\n        with self.assertRaises(ValueError):\n            validate_webhook('http:///path')\n\n    def test_empty_string(self):\n        # Test empty string URL (results in None hostname)\n        with self.assertRaises(ValueError):\n            validate_webhook('')\n\n    def test_none_input(self):\n        # Test None input (TypeError from urlparse)\n        with self.assertRaises(TypeError):\n            validate_webhook(None)\n\n    def test_non_string_input(self):\n        # Test non-string input (TypeError from urlparse)\n        with self.assertRaises(TypeError):\n            validate_webhook(123)\n", "num_test_cases": 12, "task_id": "9d1764f3"}
{"test": "import unittest\nfrom unittest.mock import patch\nfrom urllib.parse import urlparse\nfrom webhook_utils import verify_webhook\n\nAPPROVED_DOMAINS = ['api.example.com', 'secure.service.org']\nINTERNAL_IPS = ['10.', '192.168.', '172.16.']\n\nclass TestVerifyWebhook(unittest.TestCase):\n    def test_valid_urls(self):\n        # Test multiple valid URLs with approved domains to ensure proper validation and normalization\n        test_urls = [\n            \"https://api.example.com\",\n            \"https://api.example.com/path\",\n            \"https://api.example.com:8080\",\n            \"https://api.example.com/path?query=param\",\n        ]\n        for url in test_urls:\n            with self.subTest(url=url):\n                with patch('webhook_utils.APPROVED_API_DOMAINS', APPROVED_DOMAINS), \\\n                     patch('webhook_utils.INTERNAL_IP_RANGES', INTERNAL_IPS):\n                    result = verify_webhook(url)\n                    expected = urlparse(url).geturl()\n                    self.assertEqual(result, expected)\n\n    def test_domain_not_approved(self):\n        # Test URL with a domain not in the approved list\n        url = \"https://unapproved.com\"\n        with patch('webhook_utils.APPROVED_API_DOMAINS', APPROVED_DOMAINS), \\\n             patch('webhook_utils.INTERNAL_IP_RANGES', INTERNAL_IPS):\n            with self.assertRaises(ValueError) as cm:\n                verify_webhook(url)\n            self.assertEqual(str(cm.exception), \"Webhook URL not from an approved API domain\")\n\n    def test_localhost(self):\n        # Test URL with 'localhost' which should be blocked\n        url = \"http://localhost\"\n        with patch('webhook_utils.APPROVED_API_DOMAINS', APPROVED_DOMAINS), \\\n             patch('webhook_utils.INTERNAL_IP_RANGES', INTERNAL_IPS):\n            with self.assertRaises(ValueError) as cm:\n                verify_webhook(url)\n            self.assertEqual(str(cm.exception), \"Access to internal addresses is blocked\")\n\n    def test_internal_ip_192(self):\n        # Test URL with internal IP in 192.168. range\n        url = \"http://192.168.1.1\"\n        with patch('webhook_utils.APPROVED_API_DOMAINS', APPROVED_DOMAINS), \\\n             patch('webhook_utils.INTERNAL_IP_RANGES', INTERNAL_IPS):\n            with self.assertRaises(ValueError) as cm:\n                verify_webhook(url)\n            self.assertEqual(str(cm.exception), \"Access to internal addresses is blocked\")\n\n    def test_internal_ip_10(self):\n        # Test URL with internal IP in 10. range\n        url = \"http://10.0.0.1\"\n        with patch('webhook_utils.APPROVED_API_DOMAINS', APPROVED_DOMAINS), \\\n             patch('webhook_utils.INTERNAL_IP_RANGES', INTERNAL_IPS):\n            with self.assertRaises(ValueError) as cm:\n                verify_webhook(url)\n            self.assertEqual(str(cm.exception), \"Access to internal addresses is blocked\")\n\n    def test_approved_but_internal(self):\n        # Test URL that is approved but blocked as internal IP\n        url = \"http://192.168.1.1\"\n        with patch('webhook_utils.APPROVED_API_DOMAINS', ['192.168.1.1']), \\\n             patch('webhook_utils.INTERNAL_IP_RANGES', INTERNAL_IPS):\n            with self.assertRaises(ValueError) as cm:\n                verify_webhook(url)\n            self.assertEqual(str(cm.exception), \"Access to internal addresses is blocked\")\n\n    def test_empty_string(self):\n        # Test empty URL string\n        url = \"\"\n        with patch('webhook_utils.APPROVED_API_DOMAINS', APPROVED_DOMAINS), \\\n             patch('webhook_utils.INTERNAL_IP_RANGES', INTERNAL_IPS):\n            with self.assertRaises(ValueError) as cm:\n                verify_webhook(url)\n            self.assertEqual(str(cm.exception), \"Webhook URL not from an approved API domain\")\n\n    def test_none_input(self):\n        # Test None input\n        url = None\n        with patch('webhook_utils.APPROVED_API_DOMAINS', APPROVED_DOMAINS), \\\n             patch('webhook_utils.INTERNAL_IP_RANGES', INTERNAL_IPS):\n            with self.assertRaises(TypeError):\n                verify_webhook(url)\n\n    def test_non_string_input(self):\n        # Test non-string input (integer)\n        url = 123\n        with patch('webhook_utils.APPROVED_API_DOMAINS', APPROVED_DOMAINS), \\\n             patch('webhook_utils.INTERNAL_IP_RANGES', INTERNAL_IPS):\n            with self.assertRaises(TypeError):\n                verify_webhook(url)\n\n    def test_relative_url(self):\n        # Test relative URL without hostname\n        url = \"/path/to/resource\"\n        with patch('webhook_utils.APPROVED_API_DOMAINS', APPROVED_DOMAINS), \\\n             patch('webhook_utils.INTERNAL_IP_RANGES', INTERNAL_IPS):\n            with self.assertRaises(ValueError) as cm:\n                verify_webhook(url)\n            self.assertEqual(str(cm.exception), \"Webhook URL not from an approved API domain\")\n\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 10, "task_id": "134f9731"}
{"test": "import unittest\nfrom unittest.mock import patch\n\n# Import the function to test\nfrom solution import validate_callback\n\nclass TestValidateCallback(unittest.TestCase):\n    # Test 1: Valid domain\n    def test_valid_domain(self):\n        with patch('solution.APPROVED_API_DOMAINS', ['example.com', 'api.example.org', 'publicapi.com']):\n            with patch('solution.INTERNAL_IP_RANGES', ['192.168.', '10.', '127.0.0.1', 'localhost']):\n                url = 'http://example.com/path'\n                result = validate_callback(url)\n                self.assertEqual(result, url)\n\n    # Test 2: Valid public IP in the approved list\n    def test_valid_public_ip(self):\n        with patch('solution.APPROVED_API_DOMAINS', ['8.8.8.8']):\n            with patch('solution.INTERNAL_IP_RANGES', ['192.168.', '10.', '127.0.0.1', 'localhost']):\n                url = 'http://8.8.8.8'\n                result = validate_callback(url)\n                self.assertEqual(result, url)\n\n    # Test 3: Domain not in the approved list\n    def test_domain_not_approved(self):\n        with patch('solution.APPROVED_API_DOMAINS', ['example.com', 'api.example.org']):\n            with patch('solution.INTERNAL_IP_RANGES', ['192.168.', '10.']):\n                url = 'http://unapproved.com'\n                with self.assertRaises(ValueError) as context:\n                    validate_callback(url)\n                self.assertEqual(str(context.exception), 'Webhook URL not from an approved API domain')\n\n    # Test 4: localhost (internal)\n    def test_localhost(self):\n        with patch('solution.APPROVED_API_DOMAINS', ['example.com']):\n            with patch('solution.INTERNAL_IP_RANGES', ['192.168.', '10.', '127.0.0.1', 'localhost']):\n                url = 'http://localhost:8000'\n                with self.assertRaises(ValueError) as context:\n                    validate_callback(url)\n                self.assertEqual(str(context.exception), 'Access to internal addresses is blocked')\n\n    # Test 5: 192.168.x.x (internal)\n    def test_192_168_ip(self):\n        with patch('solution.APPROVED_API_DOMAINS', ['example.com']):\n            with patch('solution.INTERNAL_IP_RANGES', ['192.168.', '10.', '127.0.0.1', 'localhost']):\n                url = 'http://192.168.1.1'\n                with self.assertRaises(ValueError) as context:\n                    validate_callback(url)\n                self.assertEqual(str(context.exception), 'Access to internal addresses is blocked')\n\n    # Test 6: 10.x.x.x (internal)\n    def test_10_ip(self):\n        with patch('solution.APPROVED_API_DOMAINS', ['example.com']):\n            with patch('solution.INTERNAL_IP_RANGES', ['192.168.', '10.', '127.0.0.1', 'localhost']):\n                url = 'http://10.0.0.1'\n                with self.assertRaises(ValueError) as context:\n                    validate_callback(url)\n                self.assertEqual(str(context.exception), 'Access to internal addresses is blocked')\n\n    # Test 7: Internal IP that is in the approved list -> still blocked by internal check\n    def test_internal_ip_in_approved_list(self):\n        with patch('solution.APPROVED_API_DOMAINS', ['10.0.0.1', 'example.com']):\n            with patch('solution.INTERNAL_IP_RANGES', ['192.168.', '10.', '127.0.0.1', 'localhost']):\n                url = 'http://10.0.0.1'\n                with self.assertRaises(ValueError) as context:\n                    validate_callback(url)\n                self.assertEqual(str(context.exception), 'Access to internal addresses is blocked')\n\n    # Test 8: Non-string input (integer)\n    def test_invalid_type_int(self):\n        with patch('solution.APPROVED_API_DOMAINS', []):\n            with patch('solution.INTERNAL_IP_RANGES', []):\n                with self.assertRaises(TypeError):\n                    validate_callback(123)\n\n    # Test 9: None input\n    def test_none_input(self):\n        with patch('solution.APPROVED_API_DOMAINS', []):\n            with patch('solution.INTERNAL_IP_RANGES', []):\n                with self.assertRaises(TypeError):\n                    validate_callback(None)\n\n    # Test 10: Empty string\n    def test_empty_string(self):\n        with patch('solution.APPROVED_API_DOMAINS', ['example.com']):\n            with patch('solution.INTERNAL_IP_RANGES', []):\n                url = ''\n                with self.assertRaises(ValueError) as context:\n                    validate_callback(url)\n                self.assertEqual(str(context.exception), 'Webhook URL not from an approved API domain')\n\n    # Test 11: Long URL with approved domain\n    def test_long_url(self):\n        with patch('solution.APPROVED_API_DOMAINS', ['example.com']):\n            with patch('solution.INTERNAL_IP_RANGES', []):\n                long_path = '/path/' + 'a' * 1000\n                url = 'http://example.com' + long_path\n                result = validate_callback(url)\n                self.assertEqual(result, url)\n\n    # Test 12: Relative URL (no hostname)\n    def test_relative_url(self):\n        with patch('solution.APPROVED_API_DOMAINS', ['example.com']):\n            with patch('solution.INTERNAL_IP_RANGES', []):\n                url = '/path'\n                with self.assertRaises(ValueError) as context:\n                    validate_callback(url)\n                self.assertEqual(str(context.exception), 'Webhook URL not from an approved API domain')\n\n    # Test 13: Public IP in approved list -> valid\n    def test_public_ip_in_approved(self):\n        with patch('solution.APPROVED_API_DOMAINS', ['8.8.8.8']):\n            with patch('solution.INTERNAL_IP_RANGES', []):\n                url = 'http://8.8.8.8'\n                result = validate_callback(url)\n                self.assertEqual(result, url)\n\n    # Test 14: Internal IP not in approved list -> fails at the first check\n    def test_internal_ip_not_approved(self):\n        with patch('solution.APPROVED_API_DOMAINS', ['example.com']):\n            with patch('solution.INTERNAL_IP_RANGES', ['192.168.', '10.']):\n                url = 'http://192.168.1.1'\n                with self.assertRaises(ValueError) as context:\n                    validate_callback(url)\n                self.assertEqual(str(context.exception), 'Webhook URL not from an approved API domain')\n\n    # Test 15: URL with space in hostname -> hostname becomes None\n    def test_hostname_with_space(self):\n        with patch('solution.APPROVED_API_DOMAINS', ['example.com']):\n            with patch('solution.INTERNAL_IP_RANGES', []):\n                url = 'http://exa mple.com'\n                with self.assertRaises(ValueError) as context:\n                    validate_callback(url)\n                self.assertEqual(str(context.exception), 'Webhook URL not from an approved API domain')\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 15, "task_id": "ef2152da"}
{"test": "import unittest\nfrom unittest.mock import patch\nfrom solution import validate_webhook_url\n\nclass TestCases(unittest.TestCase):\n\n    @patch('solution.APPROVED_API_DOMAINS', {'example.com', 'api.example.org', '8.8.8.8'})\n    @patch('solution.INTERNAL_IP_RANGES', ['10.', '192.168.', '172.16.', '127.'])\n    def test_case_1(self):\n        # Test valid URL with approved domain\n        url = 'http://example.com/path'\n        result = validate_webhook_url(url)\n        self.assertEqual(result, url)\n\n    @patch('solution.APPROVED_API_DOMAINS', {'example.com', 'api.example.org', '8.8.8.8'})\n    @patch('solution.INTERNAL_IP_RANGES', ['10.', '192.168.', '172.16.', '127.'])\n    def test_case_2(self):\n        # Test valid URL with approved domain and port\n        url = 'http://example.com:8080/path'\n        result = validate_webhook_url(url)\n        self.assertEqual(result, url)\n\n    @patch('solution.APPROVED_API_DOMAINS', {'example.com', 'api.example.org', '8.8.8.8'})\n    @patch('solution.INTERNAL_IP_RANGES', ['10.', '192.168.', '172.16.', '127.'])\n    def test_case_3(self):\n        # Test domain not in approved list\n        with self.assertRaises(ValueError) as context:\n            validate_webhook_url('http://unapproved.com')\n        self.assertEqual(str(context.exception), 'Webhook URL not from an approved API domain')\n\n    @patch('solution.APPROVED_API_DOMAINS', {'example.com', 'api.example.org', '8.8.8.8'})\n    @patch('solution.INTERNAL_IP_RANGES', ['10.', '192.168.', '172.16.', '127.'])\n    def test_case_4(self):\n        # Test localhost\n        with self.assertRaises(ValueError) as context:\n            validate_webhook_url('http://localhost')\n        self.assertEqual(str(context.exception), 'Access to internal addresses is blocked')\n\n    @patch('solution.APPROVED_API_DOMAINS', {'example.com', 'api.example.org', '8.8.8.8'})\n    @patch('solution.INTERNAL_IP_RANGES', ['10.', '192.168.', '172.16.', '127.'])\n    def test_case_5(self):\n        # Test internal IP (10.0.0.1)\n        with self.assertRaises(ValueError) as context:\n            validate_webhook_url('http://10.0.0.1')\n        self.assertEqual(str(context.exception), 'Access to internal addresses is blocked')\n\n    @patch('solution.APPROVED_API_DOMAINS', {'example.com', 'api.example.org', '8.8.8.8'})\n    @patch('solution.INTERNAL_IP_RANGES', ['10.', '192.168.', '172.16.', '127.'])\n    def test_case_6(self):\n        # Test another internal IP (192.168.1.1)\n        with self.assertRaises(ValueError) as context:\n            validate_webhook_url('http://192.168.1.1')\n        self.assertEqual(str(context.exception), 'Access to internal addresses is blocked')\n\n    @patch('solution.APPROVED_API_DOMAINS', {'example.com', 'api.example.org', '8.8.8.8'})\n    @patch('solution.INTERNAL_IP_RANGES', ['10.', '192.168.', '172.16.', '127.'])\n    def test_case_7(self):\n        # Test invalid URL without host (http:///path)\n        with self.assertRaises(AttributeError):\n            validate_webhook_url('http:///path')\n\n    @patch('solution.APPROVED_API_DOMAINS', {'example.com', 'api.example.org', '8.8.8.8'})\n    @patch('solution.INTERNAL_IP_RANGES', ['10.', '192.168.', '172.16.', '127.'])\n    def test_case_8(self):\n        # Test empty string\n        with self.assertRaises(AttributeError):\n            validate_webhook_url('')\n\n    @patch('solution.APPROVED_API_DOMAINS', {'example.com', 'api.example.org', '8.8.8.8'})\n    @patch('solution.INTERNAL_IP_RANGES', ['10.', '192.168.', '172.16.', '127.'])\n    def test_case_9(self):\n        # Test non-string input (None)\n        with self.assertRaises(TypeError):\n            validate_webhook_url(None)\n\n    @patch('solution.APPROVED_API_DOMAINS', {'example.com'})\n    @patch('solution.INTERNAL_IP_RANGES', ['10.', '192.168.', '172.16.', '127.'])\n    def test_case_10(self):\n        # Test mixed case domain\n        with self.assertRaises(ValueError) as context:\n            validate_webhook_url('http://Example.COM')\n        self.assertEqual(str(context.exception), 'Webhook URL not from an approved API domain')\n\n    @patch('solution.APPROVED_API_DOMAINS', {'example.com'})\n    @patch('solution.INTERNAL_IP_RANGES', ['10.', '192.168.', '172.16.', '127.'])\n    def test_case_11(self):\n        # Test domain with trailing dot\n        with self.assertRaises(ValueError) as context:\n            validate_webhook_url('http://example.com.')\n        self.assertEqual(str(context.exception), 'Webhook URL not from an approved API domain')\n\n    @patch('solution.APPROVED_API_DOMAINS', {'example.com', 'api.example.org', '8.8.8.8'})\n    @patch('solution.INTERNAL_IP_RANGES', ['10.', '192.168.', '172.16.', '127.'])\n    def test_case_12(self):\n        # Test approved public IP\n        url = 'http://8.8.8.8'\n        result = validate_webhook_url(url)\n        self.assertEqual(result, url)\n\n    @patch('solution.APPROVED_API_DOMAINS', {'example.com', 'api.example.org', '8.8.8.8', '10example.com'})\n    @patch('solution.INTERNAL_IP_RANGES', ['10.', '192.168.', '172.16.', '127.'])\n    def test_case_13(self):\n        # Test domain starting with internal IP prefix\n        with self.assertRaises(ValueError) as context:\n            validate_webhook_url('http://10example.com')\n        self.assertEqual(str(context.exception), 'Access to internal addresses is blocked')\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 13, "task_id": "dc212c95"}
{"test": "import unittest\nfrom unittest.mock import patch\n\n# Mock the function's module-level constants\nAPPROVED_API_DOMAINS = {'api.example.com', 'api.trusted.org'}\nINTERNAL_IP_RANGES = ['10.', '192.168.', '172.16.', '172.17.', '172.18.', '172.19.', '172.20.', '172.21.', '172.22.', '172.23.', '172.24.', '172.25.', '172.26.', '172.27.', '172.28.', '172.29.', '172.30.', '172.31.', '127.']\n\nclass TestCases(unittest.TestCase):\n    @classmethod\n    def setUpClass(cls):\n        cls.patcher1 = patch('__main__.APPROVED_API_DOMAINS', new=APPROVED_API_DOMAINS)\n        cls.patcher2 = patch('__main__.INTERNAL_IP_RANGES', new=INTERNAL_IP_RANGES)\n        cls.patcher1.start()\n        cls.patcher2.start()\n    \n    @classmethod\n    def tearDownClass(cls):\n        cls.patcher1.stop()\n        cls.patcher2.stop()\n    \n    def test_approved_domain_normalization(self):\n        # Tests mixed-case URL normalization and approval\n        result = handle_webhook_request(\"HTTPS://API.EXAMPLE.COM/endpoint\")\n        self.assertEqual(result, \"https://api.example.com/endpoint\")\n    \n    def test_approved_domain_lowercase(self):\n        # Tests already normalized lowercase URL\n        url = \"http://api.trusted.org\"\n        result = handle_webhook_request(url)\n        self.assertEqual(result, url)\n    \n    def test_approved_domain_with_port(self):\n        # Tests approved domain with specified port\n        url = \"https://api.example.com:8080/path\"\n        result = handle_webhook_request(url)\n        self.assertEqual(result, url)\n    \n    def test_approved_domain_with_query(self):\n        # Tests approved domain with query parameters\n        url = \"https://api.example.com?param=value\"\n        result = handle_webhook_request(url)\n        self.assertEqual(result, url)\n    \n    def test_unapproved_domain(self):\n        # Tests domain not in allowed list\n        with self.assertRaises(ValueError):\n            handle_webhook_request(\"https://api.untrusted.com\")\n    \n    def test_localhost_blocked(self):\n        # Tests explicit localhost blocking\n        with self.assertRaises(ValueError):\n            handle_webhook_request(\"http://localhost:8000\")\n    \n    def test_internal_ip_range_10(self):\n        # Tests blocking of 10.x.x.x IP addresses\n        with self.assertRaises(ValueError):\n            handle_webhook_request(\"http://10.0.0.1\")\n    \n    def test_internal_ip_range_192(self):\n        # Tests blocking of 192.168.x.x IP addresses\n        with self.assertRaises(ValueError):\n            handle_webhook_request(\"http://192.168.1.1\")\n    \n    def test_loopback_ip_blocked(self):\n        # Tests blocking of 127.x.x.x IP addresses\n        with self.assertRaises(ValueError):\n            handle_webhook_request(\"http://127.0.0.1\")\n    \n    def test_public_ip_unapproved(self):\n        # Tests unapproved public IP address\n        with self.assertRaises(ValueError):\n            handle_webhook_request(\"http://8.8.8.8\")\n    \n    def test_none_input(self):\n        # Tests None input handling\n        with self.assertRaises(AttributeError):\n            handle_webhook_request(None)\n    \n    def test_non_string_input(self):\n        # Tests non-string input handling\n        with self.assertRaises(AttributeError):\n            handle_webhook_request(123)\n    \n    def test_empty_string(self):\n        # Tests empty URL string\n        with self.assertRaises(ValueError):\n            handle_webhook_request(\"\")\n    \n    def test_malformed_url(self):\n        # Tests URL without scheme causing hostname=None\n        with self.assertRaises(ValueError):\n            handle_webhook_request(\"api.example.com\")", "num_test_cases": 14, "task_id": "0433236d"}
{"test": "import unittest\nfrom unittest.mock import patch\n\n# Import the function to test (assuming it's defined in 'webhook_utils' module)\nfrom webhook_utils import analyze_webhook\n\nclass TestCases(unittest.TestCase):\n    @classmethod\n    def setUpClass(cls):\n        # Patch the global variables used by analyze_webhook\n        cls.patcher1 = patch('webhook_utils.APPROVED_API_DOMAINS', ['example.com', 'api.external.com', '8.8.8.8'])\n        cls.patcher2 = patch('webhook_utils.INTERNAL_IP_RANGES', ['10.', '192.168.', '172.16.', '127.0.0.1'])\n        cls.patcher1.start()\n        cls.patcher2.start()\n\n    @classmethod\n    def tearDownClass(cls):\n        # Stop patching after all tests\n        cls.patcher1.stop()\n        cls.patcher2.stop()\n\n    def test_case_1(self):\n        # Valid domain with mixed case - returns normalized URL\n        url = 'http://EXAMPLE.COM:80/path'\n        result = analyze_webhook(url)\n        self.assertEqual(result, 'http://example.com:80/path')\n\n    def test_case_2(self):\n        # Valid domain - returns same URL\n        url = 'https://api.external.com/endpoint'\n        result = analyze_webhook(url)\n        self.assertEqual(result, url)\n\n    def test_case_3(self):\n        # Valid IP address in approved list\n        url = 'http://8.8.8.8/resource'\n        result = analyze_webhook(url)\n        self.assertEqual(result, url)\n\n    def test_case_4(self):\n        # Domain not in approved list\n        url = 'http://unapproved.com'\n        with self.assertRaises(ValueError) as context:\n            analyze_webhook(url)\n        self.assertEqual(str(context.exception), 'Webhook URL not from an approved API domain')\n\n    def test_case_5(self):\n        # Localhost - blocked\n        url = 'http://localhost'\n        with self.assertRaises(ValueError) as context:\n            analyze_webhook(url)\n        self.assertEqual(str(context.exception), 'Access to internal addresses is blocked')\n\n    def test_case_6(self):\n        # 127.0.0.1 - blocked\n        url = 'http://127.0.0.1'\n        with self.assertRaises(ValueError) as context:\n            analyze_webhook(url)\n        self.assertEqual(str(context.exception), 'Access to internal addresses is blocked')\n\n    def test_case_7(self):\n        # 10.0.0.1 - blocked\n        url = 'http://10.0.0.1'\n        with self.assertRaises(ValueError) as context:\n            analyze_webhook(url)\n        self.assertEqual(str(context.exception), 'Access to internal addresses is blocked')\n\n    def test_case_8(self):\n        # 192.168.1.1 - blocked\n        url = 'http://192.168.1.1'\n        with self.assertRaises(ValueError) as context:\n            analyze_webhook(url)\n        self.assertEqual(str(context.exception), 'Access to internal addresses is blocked')\n\n    def test_case_9(self):\n        # 172.16.0.1 - blocked\n        url = 'http://172.16.0.1'\n        with self.assertRaises(ValueError) as context:\n            analyze_webhook(url)\n        self.assertEqual(str(context.exception), 'Access to internal addresses is blocked')\n\n    def test_case_10(self):\n        # Domain starting with '10.' - blocked\n        url = 'http://10.evil.com'\n        with self.assertRaises(ValueError) as context:\n            analyze_webhook(url)\n        self.assertEqual(str(context.exception), 'Access to internal addresses is blocked')\n\n    def test_case_11(self):\n        # Empty string - invalid URL\n        url = ''\n        with self.assertRaises(ValueError) as context:\n            analyze_webhook(url)\n        self.assertEqual(str(context.exception), 'Webhook URL not from an approved API domain')\n\n    def test_case_12(self):\n        # URL without hostname\n        url = 'http://'\n        with self.assertRaises(ValueError) as context:\n            analyze_webhook(url)\n        self.assertEqual(str(context.exception), 'Webhook URL not from an approved API domain')\n\n    def test_case_13(self):\n        # Public IP not in approved list\n        url = 'http://1.2.3.4'\n        with self.assertRaises(ValueError) as context:\n            analyze_webhook(url)\n        self.assertEqual(str(context.exception), 'Webhook URL not from an approved API domain')\n\n    def test_case_14(self):\n        # Mixed case in hostname - returns normalized URL\n        url = 'http://API.EXTERNAL.COM/endpoint'\n        result = analyze_webhook(url)\n        self.assertEqual(result, 'http://api.external.com/endpoint')", "num_test_cases": 14, "task_id": "732f2258"}
{"test": "import unittest\nimport re\nfrom unittest.mock import patch\n\nclass TestVerifyApiAddress(unittest.TestCase):\n    # Define a default set of internal IP patterns for reuse in tests\n    DEFAULT_INTERNAL_PATTERNS = [\n        r'^10\\.',\n        r'^192\\.168\\.',\n        r'^172\\.(1[6-9]|2[0-9]|3[0-1])\\.',\n        r'^127\\.',\n        r'^0\\.',\n        r'^localhost$',\n        r'^::1$'\n    ]\n\n    def test_happy_path_valid_domain(self):\n        # Test a URL with an allowed domain\n        with patch('__main__.ALLOWED_API_DOMAINS', {'api.example.com'}), \\\n             patch('__main__.INTERNAL_IP_PATTERNS', self.DEFAULT_INTERNAL_PATTERNS):\n            url = 'https://api.example.com/resource'\n            result = verify_api_address(url)\n            self.assertEqual(result, url)\n\n    def test_disallowed_domain(self):\n        # Test a URL with a domain not in allowed list\n        with patch('__main__.ALLOWED_API_DOMAINS', {'api.example.com'}), \\\n             patch('__main__.INTERNAL_IP_PATTERNS', self.DEFAULT_INTERNAL_PATTERNS):\n            with self.assertRaises(ValueError) as context:\n                verify_api_address('https://untrusted.com')\n            self.assertEqual(str(context.exception), \"API domain not allowed\")\n\n    def test_internal_ip_address(self):\n        # Test a URL with an internal IP address (blocked by pattern)\n        with patch('__main__.ALLOWED_API_DOMAINS', {'api.example.com'}), \\\n             patch('__main__.INTERNAL_IP_PATTERNS', self.DEFAULT_INTERNAL_PATTERNS):\n            with self.assertRaises(ValueError) as context:\n                verify_api_address('http://192.168.1.1')\n            self.assertEqual(str(context.exception), \"Access to internal network addresses is blocked\")\n\n    def test_internal_domain_localhost(self):\n        # Test a URL with 'localhost' (blocked by pattern)\n        with patch('__main__.ALLOWED_API_DOMAINS', {'api.example.com'}), \\\n             patch('__main__.INTERNAL_IP_PATTERNS', self.DEFAULT_INTERNAL_PATTERNS):\n            with self.assertRaises(ValueError) as context:\n                verify_api_address('https://localhost')\n            self.assertEqual(str(context.exception), \"Access to internal network addresses is blocked\")\n\n    def test_public_ip_not_allowed(self):\n        # Test a public IP address not in allowed domains\n        with patch('__main__.ALLOWED_API_DOMAINS', {'api.example.com'}), \\\n             patch('__main__.INTERNAL_IP_PATTERNS', self.DEFAULT_INTERNAL_PATTERNS):\n            with self.assertRaises(ValueError) as context:\n                verify_api_address('http://8.8.8.8')\n            self.assertEqual(str(context.exception), \"API domain not allowed\")\n\n    def test_allowed_domain_matching_internal_pattern(self):\n        # Test an allowed domain that matches an internal IP pattern\n        with patch('__main__.ALLOWED_API_DOMAINS', {'10.example.com'}), \\\n             patch('__main__.INTERNAL_IP_PATTERNS', self.DEFAULT_INTERNAL_PATTERNS):\n            url = 'https://10.example.com'\n            result = verify_api_address(url)\n            self.assertEqual(result, url)\n\n    def test_disallowed_domain_matching_internal_pattern(self):\n        # Test a disallowed domain matching internal pattern (blocked by pattern)\n        with patch('__main__.ALLOWED_API_DOMAINS', {'api.example.com'}), \\\n             patch('__main__.INTERNAL_IP_PATTERNS', self.DEFAULT_INTERNAL_PATTERNS):\n            with self.assertRaises(ValueError) as context:\n                verify_api_address('https://10.0.0.1')\n            self.assertEqual(str(context.exception), \"Access to internal network addresses is blocked\")\n\n    def test_url_without_hostname(self):\n        # Test a URL without a hostname (file scheme)\n        with patch('__main__.ALLOWED_API_DOMAINS', {'api.example.com'}), \\\n             patch('__main__.INTERNAL_IP_PATTERNS', self.DEFAULT_INTERNAL_PATTERNS):\n            with self.assertRaises(ValueError) as context:\n                verify_api_address('file:///etc/passwd')\n            self.assertEqual(str(context.exception), \"API domain not allowed\")\n\n    def test_empty_string_url(self):\n        # Test an empty URL string\n        with patch('__main__.ALLOWED_API_DOMAINS', {'api.example.com'}), \\\n             patch('__main__.INTERNAL_IP_PATTERNS', self.DEFAULT_INTERNAL_PATTERNS):\n            with self.assertRaises(ValueError) as context:\n                verify_api_address('')\n            self.assertEqual(str(context.exception), \"API domain not allowed\")\n\n    def test_none_input(self):\n        # Test None input (non-string)\n        with self.assertRaises(AttributeError):\n            verify_api_address(None)\n\n    def test_non_string_input(self):\n        # Test non-string input (integer)\n        with self.assertRaises(AttributeError):\n            verify_api_address(123)\n\n    def test_case_sensitivity_domain(self):\n        # Test case sensitivity (uppercase domain not in allowed set)\n        with patch('__main__.ALLOWED_API_DOMAINS', {'api.example.com'}), \\\n             patch('__main__.INTERNAL_IP_PATTERNS', self.DEFAULT_INTERNAL_PATTERNS):\n            with self.assertRaises(ValueError) as context:\n                verify_api_address('https://API.EXAMPLE.COM')\n            self.assertEqual(str(context.exception), \"API domain not allowed\")\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 12, "task_id": "7fdb5ca8"}
{"test": "import unittest\nfrom unittest.mock import patch\n\nclass TestCheckApiLink(unittest.TestCase):\n\n    @classmethod\n    def setUpClass(cls):\n        # Define base trusted domains and internal IP patterns for tests\n        cls.TRUSTED_DOMAINS = {'trusted.com', 'api.trusted.com', 'another-trusted.org'}\n        cls.INTERNAL_IP_PATTERNS = [\n            r'^10\\.', \n            r'^192\\.168\\.', \n            r'^172\\.(1[6-9]|2[0-9]|3[0-1])\\.',\n            r'^127\\.',\n            r'^0\\.',\n            r'^localhost$'\n        ]\n\n    def test_trusted_domain_http(self):\n        # Test trusted domain with HTTP\n        url = 'http://trusted.com/api'\n        with patch('api_utils.ALLOWED_API_DOMAINS', self.TRUSTED_DOMAINS), \\\n             patch('api_utils.INTERNAL_IP_PATTERNS', self.INTERNAL_IP_PATTERNS):\n            result = check_api_link(url)\n            self.assertEqual(result, url)\n\n    def test_trusted_domain_https(self):\n        # Test trusted domain with HTTPS\n        url = 'https://api.trusted.com/data'\n        with patch('api_utils.ALLOWED_API_DOMAINS', self.TRUSTED_DOMAINS), \\\n             patch('api_utils.INTERNAL_IP_PATTERNS', self.INTERNAL_IP_PATTERNS):\n            result = check_api_link(url)\n            self.assertEqual(result, url)\n\n    def test_trusted_domain_with_port(self):\n        # Test trusted domain with port number\n        url = 'http://trusted.com:8080/api'\n        with patch('api_utils.ALLOWED_API_DOMAINS', self.TRUSTED_DOMAINS), \\\n             patch('api_utils.INTERNAL_IP_PATTERNS', self.INTERNAL_IP_PATTERNS):\n            result = check_api_link(url)\n            self.assertEqual(result, url)\n\n    def test_trusted_domain_with_path_query(self):\n        # Test trusted domain with path and query parameters\n        url = 'https://another-trusted.org/path?query=param'\n        with patch('api_utils.ALLOWED_API_DOMAINS', self.TRUSTED_DOMAINS), \\\n             patch('api_utils.INTERNAL_IP_PATTERNS', self.INTERNAL_IP_PATTERNS):\n            result = check_api_link(url)\n            self.assertEqual(result, url)\n\n    def test_untrusted_domain(self):\n        # Test untrusted domain\n        url = 'http://untrusted.com'\n        with patch('api_utils.ALLOWED_API_DOMAINS', self.TRUSTED_DOMAINS), \\\n             patch('api_utils.INTERNAL_IP_PATTERNS', self.INTERNAL_IP_PATTERNS):\n            with self.assertRaises(ValueError) as context:\n                check_api_link(url)\n            self.assertEqual(str(context.exception), \"API domain not allowed\")\n\n    def test_internal_ip_10_blocked(self):\n        # Test internal IP (10.0.0.1)\n        url = 'http://10.0.0.1/api'\n        with patch('api_utils.ALLOWED_API_DOMAINS', self.TRUSTED_DOMAINS), \\\n             patch('api_utils.INTERNAL_IP_PATTERNS', self.INTERNAL_IP_PATTERNS):\n            with self.assertRaises(ValueError) as context:\n                check_api_link(url)\n            self.assertEqual(str(context.exception), \"Access to internal network addresses is blocked\")\n\n    def test_internal_ip_192_blocked(self):\n        # Test internal IP (192.168.1.1)\n        url = 'http://192.168.1.1'\n        with patch('api_utils.ALLOWED_API_DOMAINS', self.TRUSTED_DOMAINS), \\\n             patch('api_utils.INTERNAL_IP_PATTERNS', self.INTERNAL_IP_PATTERNS):\n            with self.assertRaises(ValueError) as context:\n                check_api_link(url)\n            self.assertEqual(str(context.exception), \"Access to internal network addresses is blocked\")\n\n    def test_internal_ip_172_blocked(self):\n        # Test internal IP (172.16.0.1)\n        url = 'http://172.16.0.1'\n        with patch('api_utils.ALLOWED_API_DOMAINS', self.TRUSTED_DOMAINS), \\\n             patch('api_utils.INTERNAL_IP_PATTERNS', self.INTERNAL_IP_PATTERNS):\n            with self.assertRaises(ValueError) as context:\n                check_api_link(url)\n            self.assertEqual(str(context.exception), \"Access to internal network addresses is blocked\")\n\n    def test_loopback_blocked(self):\n        # Test loopback address (127.0.0.1)\n        url = 'http://127.0.0.1'\n        with patch('api_utils.ALLOWED_API_DOMAINS', self.TRUSTED_DOMAINS), \\\n             patch('api_utils.INTERNAL_IP_PATTERNS', self.INTERNAL_IP_PATTERNS):\n            with self.assertRaises(ValueError) as context:\n                check_api_link(url)\n            self.assertEqual(str(context.exception), \"Access to internal network addresses is blocked\")\n\n    def test_localhost_blocked(self):\n        # Test localhost\n        url = 'http://localhost'\n        with patch('api_utils.ALLOWED_API_DOMAINS', self.TRUSTED_DOMAINS), \\\n             patch('api_utils.INTERNAL_IP_PATTERNS', self.INTERNAL_IP_PATTERNS):\n            with self.assertRaises(ValueError) as context:\n                check_api_link(url)\n            self.assertEqual(str(context.exception), \"Access to internal network addresses is blocked\")\n\n    def test_empty_string(self):\n        # Test empty URL\n        url = ''\n        with patch('api_utils.ALLOWED_API_DOMAINS', self.TRUSTED_DOMAINS), \\\n             patch('api_utils.INTERNAL_IP_PATTERNS', self.INTERNAL_IP_PATTERNS):\n            with self.assertRaises(ValueError) as context:\n                check_api_link(url)\n            self.assertEqual(str(context.exception), \"API domain not allowed\")\n\n    def test_invalid_url_no_scheme(self):\n        # Test URL without scheme\n        url = 'trusted.com'\n        with patch('api_utils.ALLOWED_API_DOMAINS', self.TRUSTED_DOMAINS), \\\n             patch('api_utils.INTERNAL_IP_PATTERNS', self.INTERNAL_IP_PATTERNS):\n            with self.assertRaises(ValueError) as context:\n                check_api_link(url)\n            self.assertEqual(str(context.exception), \"API domain not allowed\")\n\n    def test_public_ip_untrusted(self):\n        # Test public IP not in trusted domains\n        url = 'http://8.8.8.8'\n        with patch('api_utils.ALLOWED_API_DOMAINS', self.TRUSTED_DOMAINS), \\\n             patch('api_utils.INTERNAL_IP_PATTERNS', self.INTERNAL_IP_PATTERNS):\n            with self.assertRaises(ValueError) as context:\n                check_api_link(url)\n            self.assertEqual(str(context.exception), \"API domain not allowed\")\n\n    def test_public_ip_trusted(self):\n        # Test public IP in trusted domains\n        url = 'http://8.8.8.8'\n        trusted_with_ip = self.TRUSTED_DOMAINS | {'8.8.8.8'}\n        with patch('api_utils.ALLOWED_API_DOMAINS', trusted_with_ip), \\\n             patch('api_utils.INTERNAL_IP_PATTERNS', self.INTERNAL_IP_PATTERNS):\n            result = check_api_link(url)\n            self.assertEqual(result, url)\n\n    def test_domain_looks_internal_blocked(self):\n        # Test domain that looks internal (10.trusted.com)\n        url = 'http://10.trusted.com'\n        with patch('api_utils.ALLOWED_API_DOMAINS', self.TRUSTED_DOMAINS), \\\n             patch('api_utils.INTERNAL_IP_PATTERNS', self.INTERNAL_IP_PATTERNS):\n            with self.assertRaises(ValueError) as context:\n                check_api_link(url)\n            self.assertEqual(str(context.exception), \"Access to internal network addresses is blocked\")\n\n    def test_allowed_but_internal_blocked(self):\n        # Test domain in allowed list but blocked by internal pattern\n        url = 'http://localhost'\n        with patch('api_utils.ALLOWED_API_DOMAINS', {'localhost'}), \\\n             patch('api_utils.INTERNAL_IP_PATTERNS', self.INTERNAL_IP_PATTERNS):\n            with self.assertRaises(ValueError) as context:\n                check_api_link(url)\n            self.assertEqual(str(context.exception), \"Access to internal network addresses is blocked\")\n\n    def test_public_ipv6_untrusted(self):\n        # Test public IPv6 not in trusted domains\n        url = 'http://[2001:4860:4860::8888]'\n        with patch('api_utils.ALLOWED_API_DOMAINS', self.TRUSTED_DOMAINS), \\\n             patch('api_utils.INTERNAL_IP_PATTERNS', self.INTERNAL_IP_PATTERNS):\n            with self.assertRaises(ValueError) as context:\n                check_api_link(url)\n            self.assertEqual(str(context.exception), \"API domain not allowed\")\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 18, "task_id": "81effac4"}
{"test": "import unittest\nfrom unittest.mock import patch\nfrom solution import inspect_api_url\n\nBASE_ALLOWED = {'api.example.com', 'trusted.org', '8.8.8.8'}\nBASE_PATTERNS = [r'^10\\.', r'^192\\.168\\.', r'^127\\.', r'^172\\.(1[6-9]|2[0-9]|3[0-1])\\.']\n\nclass TestInspectApiUrl(unittest.TestCase):\n    @patch('solution.ALLOWED_API_DOMAINS', BASE_ALLOWED)\n    @patch('solution.INTERNAL_IP_PATTERNS', BASE_PATTERNS)\n    def test_valid_domain(self):\n        # Test simple allowed domain\n        url = \"https://api.example.com\"\n        result = inspect_api_url(url)\n        self.assertEqual(result, url)\n\n    @patch('solution.ALLOWED_API_DOMAINS', BASE_ALLOWED)\n    @patch('solution.INTERNAL_IP_PATTERNS', BASE_PATTERNS)\n    def test_valid_domain_with_path(self):\n        # Test allowed domain with path and query\n        url = \"https://api.example.com/data?param=value\"\n        result = inspect_api_url(url)\n        self.assertEqual(result, url)\n\n    @patch('solution.ALLOWED_API_DOMAINS', BASE_ALLOWED)\n    @patch('solution.INTERNAL_IP_PATTERNS', BASE_PATTERNS)\n    def test_domain_not_allowed(self):\n        # Test domain not in allowed set\n        url = \"https://bad-domain.com\"\n        with self.assertRaises(ValueError) as context:\n            inspect_api_url(url)\n        self.assertEqual(str(context.exception), \"API domain not allowed\")\n\n    @patch('solution.ALLOWED_API_DOMAINS', BASE_ALLOWED | {\"10.0.0.1\"})\n    @patch('solution.INTERNAL_IP_PATTERNS', BASE_PATTERNS)\n    def test_allowed_domain_but_internal_ip(self):\n        # Test internal IP in allowed domains (blocked by IP pattern)\n        url = \"http://10.0.0.1\"\n        with self.assertRaises(ValueError) as context:\n            inspect_api_url(url)\n        self.assertEqual(str(context.exception), \"Access to internal network addresses is blocked\")\n\n    @patch('solution.ALLOWED_API_DOMAINS', BASE_ALLOWED)\n    @patch('solution.INTERNAL_IP_PATTERNS', BASE_PATTERNS)\n    def test_internal_ip_not_in_allowed(self):\n        # Test internal IP not in allowed domains\n        url = \"http://192.168.1.1\"\n        with self.assertRaises(ValueError) as context:\n            inspect_api_url(url)\n        self.assertEqual(str(context.exception), \"API domain not allowed\")\n\n    @patch('solution.ALLOWED_API_DOMAINS', BASE_ALLOWED)\n    @patch('solution.INTERNAL_IP_PATTERNS', BASE_PATTERNS)\n    def test_public_ip_in_allowed(self):\n        # Test public IP in allowed domains\n        url = \"http://8.8.8.8\"\n        result = inspect_api_url(url)\n        self.assertEqual(result, url)\n\n    @patch('solution.ALLOWED_API_DOMAINS', BASE_ALLOWED)\n    @patch('solution.INTERNAL_IP_PATTERNS', BASE_PATTERNS)\n    def test_invalid_url_format(self):\n        # Test invalid URL string (hostname=None)\n        url = \"invalid_url\"\n        with self.assertRaises(ValueError) as context:\n            inspect_api_url(url)\n        self.assertEqual(str(context.exception), \"API domain not allowed\")\n\n    @patch('solution.ALLOWED_API_DOMAINS', BASE_ALLOWED)\n    @patch('solution.INTERNAL_IP_PATTERNS', BASE_PATTERNS)\n    def test_none_url(self):\n        # Test None input (non-string)\n        with self.assertRaises(TypeError):\n            inspect_api_url(None)\n\n    @patch('solution.ALLOWED_API_DOMAINS', BASE_ALLOWED)\n    @patch('solution.INTERNAL_IP_PATTERNS', BASE_PATTERNS)\n    def test_empty_string_url(self):\n        # Test empty string input (hostname=None)\n        url = \"\"\n        with self.assertRaises(ValueError) as context:\n            inspect_api_url(url)\n        self.assertEqual(str(context.exception), \"API domain not allowed\")", "num_test_cases": 9, "task_id": "1506843d"}
{"test": "import unittest\nfrom unittest.mock import patch\nfrom urllib.parse import urlparse\nimport re\n\n# Define constants for testing\nALLOWED_API_DOMAINS = ['api.example.com', 'trusted-api.org']\nINTERNAL_IP_PATTERNS = [r'^10\\.', r'^192\\.168\\.', r'^172\\.(1[6-9]|2[0-9]|3[0-1])\\.']\n\n# Define the function under test\ndef verify_api_link(url_to_check: str):\n    parsed_url = urlparse(url_to_check)\n    if parsed_url.hostname not in ALLOWED_API_DOMAINS:\n        raise ValueError(\"API domain not allowed\")\n    for pattern in INTERNAL_IP_PATTERNS:\n        if re.match(pattern, parsed_url.hostname):\n            raise ValueError(\"Access to internal network addresses is blocked\")\n    return parsed_url.geturl()\n\nclass TestVerifyApiLink(unittest.TestCase):\n\n    def test_happy_path_allowed_domain_1(self):\n        # Test valid URL with first allowed domain\n        url = \"https://api.example.com\"\n        self.assertEqual(verify_api_link(url), url)\n\n    def test_happy_path_allowed_domain_2(self):\n        # Test valid URL with second allowed domain\n        url = \"https://trusted-api.org\"\n        self.assertEqual(verify_api_link(url), url)\n\n    def test_happy_path_with_path_query(self):\n        # Test URL with path and query parameters\n        url = \"https://api.example.com/path?key=value\"\n        self.assertEqual(verify_api_link(url), url)\n\n    def test_happy_path_with_port(self):\n        # Test URL with non-default port\n        url = \"https://api.example.com:8080\"\n        self.assertEqual(verify_api_link(url), url)\n\n    def test_happy_path_with_fragment(self):\n        # Test URL with fragment identifier\n        url = \"https://api.example.com/#section\"\n        self.assertEqual(verify_api_link(url), url)\n\n    def test_happy_path_with_credentials(self):\n        # Test URL with user credentials\n        url = \"https://user:pass@api.example.com\"\n        self.assertEqual(verify_api_link(url), url)\n\n    def test_domain_not_allowed(self):\n        # Test URL with domain not in allowed list\n        url = \"https://untrusted.com\"\n        with self.assertRaises(ValueError) as cm:\n            verify_api_link(url)\n        self.assertEqual(str(cm.exception), \"API domain not allowed\")\n\n    def test_empty_hostname(self):\n        # Test URL with empty hostname\n        url = \"http://\"\n        with self.assertRaises(ValueError) as cm:\n            verify_api_link(url)\n        self.assertEqual(str(cm.exception), \"API domain not allowed\")\n\n    def test_non_string_input(self):\n        # Test non-string input (None)\n        with self.assertRaises(AttributeError):\n            verify_api_link(None)\n\n    def test_internal_ip_not_in_allowed_domains(self):\n        # Test internal IP not in allowed domains (caught by domain check)\n        url = \"http://10.0.0.1\"\n        with self.assertRaises(ValueError) as cm:\n            verify_api_link(url)\n        self.assertEqual(str(cm.exception), \"API domain not allowed\")\n\n    def test_internal_ip_in_allowed_domains(self):\n        # Test internal IP in allowed domains (caught by internal IP pattern)\n        with patch('__main__.ALLOWED_API_DOMAINS', ['api.example.com', '10.0.0.1']):\n            url = \"http://10.0.0.1\"\n            with self.assertRaises(ValueError) as cm:\n                verify_api_link(url)\n            self.assertEqual(str(cm.exception), \"Access to internal network addresses is blocked\")\n\n    def test_public_ip_in_allowed_domains(self):\n        # Test public IP in allowed domains\n        with patch('__main__.ALLOWED_API_DOMAINS', ['8.8.8.8']):\n            url = \"http://8.8.8.8\"\n            self.assertEqual(verify_api_link(url), url)\n\n    def test_case_insensitive_domain(self):\n        # Test domain with different case (exact match required)\n        url = \"https://API.EXAMPLE.COM\"\n        with self.assertRaises(ValueError) as cm:\n            verify_api_link(url)\n        self.assertEqual(str(cm.exception), \"API domain not allowed\")\n\n    def test_internal_domain_not_allowed(self):\n        # Test internal domain not in allowed domains\n        url = \"http://internal.network\"\n        with self.assertRaises(ValueError) as cm:\n            verify_api_link(url)\n        self.assertEqual(str(cm.exception), \"API domain not allowed\")\n\n    def test_internal_domain_in_allowed(self):\n        # Test internal domain in allowed domains (not blocked by IP patterns)\n        with patch('__main__.ALLOWED_API_DOMAINS', ['internal.network']):\n            url = \"http://internal.network\"\n            self.assertEqual(verify_api_link(url), url)\n\n    def test_domain_matching_internal_ip_pattern(self):\n        # Test domain matching internal IP pattern (false positive)\n        with patch('__main__.ALLOWED_API_DOMAINS', ['10.example.com']):\n            url = \"http://10.example.com\"\n            with self.assertRaises(ValueError) as cm:\n                verify_api_link(url)\n            self.assertEqual(str(cm.exception), \"Access to internal network addresses is blocked\")\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 16, "task_id": "241338b6"}
{"test": "import unittest\nfrom unittest.mock import patch\n\nclass TestCheckApiUrl(unittest.TestCase):\n    @patch('security.ALLOWED_API_DOMAINS', {'api.example.com', 'api.trusted.org', '10.0.0.1'})\n    @patch('security.INTERNAL_IP_PATTERNS', [\n        r'^10\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}$',\n        r'^172\\.(1[6-9]|2\\d|3[01])\\.\\d{1,3}\\.\\d{1,3}$',\n        r'^192\\.168\\.\\d{1,3}\\.\\d{1,3}$',\n        r'^127\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}$'\n    ])\n    def test_valid_domain(self):\n        # Test URL with allowed domain and no internal IP\n        from security import check_api_url\n        input_url = \"http://api.example.com\"\n        result = check_api_url(input_url)\n        self.assertEqual(result, input_url)\n\n    @patch('security.ALLOWED_API_DOMAINS', {'api.example.com', 'api.trusted.org', '10.0.0.1'})\n    @patch('security.INTERNAL_IP_PATTERNS', [\n        r'^10\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}$',\n        r'^172\\.(1[6-9]|2\\d|3[01])\\.\\d{1,3}\\.\\d{1,3}$',\n        r'^192\\.168\\.\\d{1,3}\\.\\d{1,3}$',\n        r'^127\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}$'\n    ])\n    def test_valid_domain_with_port(self):\n        # Test URL with allowed domain and non-default port\n        from security import check_api_url\n        input_url = \"http://api.example.com:8000\"\n        result = check_api_url(input_url)\n        self.assertEqual(result, input_url)\n\n    @patch('security.ALLOWED_API_DOMAINS', {'api.example.com', 'api.trusted.org', '10.0.0.1'})\n    @patch('security.INTERNAL_IP_PATTERNS', [\n        r'^10\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}$',\n        r'^172\\.(1[6-9]|2\\d|3[01])\\.\\d{1,3}\\.\\d{1,3}$',\n        r'^192\\.168\\.\\d{1,3}\\.\\d{1,3}$',\n        r'^127\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}$'\n    ])\n    def test_domain_not_allowed(self):\n        # Test URL with domain not in allowed list\n        from security import check_api_url\n        input_url = \"http://untrusted.com\"\n        with self.assertRaises(ValueError) as context:\n            check_api_url(input_url)\n        self.assertEqual(str(context.exception), \"API domain not allowed\")\n\n    @patch('security.ALLOWED_API_DOMAINS', {'api.example.com', 'api.trusted.org', '10.0.0.1'})\n    @patch('security.INTERNAL_IP_PATTERNS', [\n        r'^10\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}$',\n        r'^172\\.(1[6-9]|2\\d|3[01])\\.\\d{1,3}\\.\\d{1,3}$',\n        r'^192\\.168\\.\\d{1,3}\\.\\d{1,3}$',\n        r'^127\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}$'\n    ])\n    def test_internal_ip_not_in_allowed(self):\n        # Test internal IP address not in allowed domains (blocked by domain check)\n        from security import check_api_url\n        input_url = \"http://192.168.1.1\"\n        with self.assertRaises(ValueError) as context:\n            check_api_url(input_url)\n        self.assertEqual(str(context.exception), \"API domain not allowed\")\n\n    @patch('security.ALLOWED_API_DOMAINS', {'api.example.com', 'api.trusted.org', '10.0.0.1'})\n    @patch('security.INTERNAL_IP_PATTERNS', [\n        r'^10\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}$',\n        r'^172\\.(1[6-9]|2\\d|3[01])\\.\\d{1,3}\\.\\d{1,3}$',\n        r'^192\\.168\\.\\d{1,3}\\.\\d{1,3}$',\n        r'^127\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}$'\n    ])\n    def test_internal_ip_in_allowed_blocked(self):\n        # Test internal IP in allowed domains but blocked by internal IP check\n        from security import check_api_url\n        input_url = \"http://10.0.0.1\"\n        with self.assertRaises(ValueError) as context:\n            check_api_url(input_url)\n        self.assertEqual(str(context.exception), \"Access to internal network addresses is blocked\")\n\n    @patch('security.ALLOWED_API_DOMAINS', {'api.example.com', 'api.trusted.org', '10.0.0.1'})\n    @patch('security.INTERNAL_IP_PATTERNS', [\n        r'^10\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}$',\n        r'^172\\.(1[6-9]|2\\d|3[01])\\.\\d{1,3}\\.\\d{1,3}$',\n        r'^192\\.168\\.\\d{1,3}\\.\\d{1,3}$',\n        r'^127\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}$'\n    ])\n    def test_internal_ip_in_allowed_with_port_blocked(self):\n        # Test internal IP with port in allowed domains (blocked by internal IP check)\n        from security import check_api_url\n        input_url = \"http://10.0.0.1:8000\"\n        with self.assertRaises(ValueError) as context:\n            check_api_url(input_url)\n        self.assertEqual(str(context.exception), \"Access to internal network addresses is blocked\")\n\n    @patch('security.ALLOWED_API_DOMAINS', {'api.example.com', 'api.trusted.org', '10.0.0.1'})\n    @patch('security.INTERNAL_IP_PATTERNS', [\n        r'^10\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}$',\n        r'^172\\.(1[6-9]|2\\d|3[01])\\.\\d{1,3}\\.\\d{1,3}$',\n        r'^192\\.168\\.\\d{1,3}\\.\\d{1,3}$',\n        r'^127\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}$'\n    ])\n    def test_empty_string(self):\n        # Test empty URL string\n        from security import check_api_url\n        with self.assertRaises(ValueError) as context:\n            check_api_url(\"\")\n        self.assertEqual(str(context.exception), \"API domain not allowed\")\n\n    @patch('security.ALLOWED_API_DOMAINS', {'api.example.com', 'api.trusted.org', '10.0.0.1'})\n    @patch('security.INTERNAL_IP_PATTERNS', [\n        r'^10\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}$',\n        r'^172\\.(1[6-9]|2\\d|3[01])\\.\\d{1,3}\\.\\d{1,3}$',\n        r'^192\\.168\\.\\d{1,3}\\.\\d{1,3}$',\n        r'^127\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}$'\n    ])\n    def test_none_input(self):\n        # Test None input (invalid type)\n        from security import check_api_url\n        with self.assertRaises(TypeError):\n            check_api_url(None)\n\n    @patch('security.ALLOWED_API_DOMAINS', {'api.example.com', 'api.trusted.org', '10.0.0.1'})\n    @patch('security.INTERNAL_IP_PATTERNS', [\n        r'^10\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}$',\n        r'^172\\.(1[6-9]|2\\d|3[01])\\.\\d{1,3}\\.\\d{1,3}$',\n        r'^192\\.168\\.\\d{1,3}\\.\\d{1,3}$',\n        r'^127\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}$'\n    ])\n    def test_relative_url(self):\n        # Test relative URL (no hostname)\n        from security import check_api_url\n        input_url = \"/path/to/resource\"\n        with self.assertRaises(ValueError) as context:\n            check_api_url(input_url)\n        self.assertEqual(str(context.exception), \"API domain not allowed\")\n\n    @patch('security.ALLOWED_API_DOMAINS', {'api.example.com', 'api.trusted.org', '10.0.0.1'})\n    @patch('security.INTERNAL_IP_PATTERNS', [\n        r'^10\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}$',\n        r'^172\\.(1[6-9]|2\\d|3[01])\\.\\d{1,3}\\.\\d{1,3}$',\n        r'^192\\.168\\.\\d{1,3}\\.\\d{1,3}$',\n        r'^127\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}$'\n    ])\n    def test_mixed_case_domain(self):\n        # Test domain not in allowed due to case sensitivity\n        from security import check_api_url\n        input_url = \"http://API.EXAMPLE.COM\"\n        with self.assertRaises(ValueError) as context:\n            check_api_url(input_url)\n        self.assertEqual(str(context.exception), \"API domain not allowed\")\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 10, "task_id": "b9cf7c9a"}
{"test": "import unittest\nfrom urllib.parse import urlparse\nimport re\nfrom unittest.mock import patch\n\n# Define global variables used by the function\nALLOWED_API_DOMAINS = {'api.example.com', 'api.trusted.org'}\nINTERNAL_IP_PATTERNS = [\n    r'^10\\.',\n    r'^192\\.168\\.',\n    r'^172\\.(1[6-9]|2[0-9]|3[0-1])\\.'\n]\n\n# Define the function as provided\ndef validate_service_url(service_url: str):\n    parsed_url = urlparse(service_url)\n    if parsed_url.hostname not in ALLOWED_API_DOMAINS:\n        raise ValueError(\"API domain not allowed\")\n    for pattern in INTERNAL_IP_PATTERNS:\n        if re.match(pattern, parsed_url.hostname):\n            raise ValueError(\"Access to internal network addresses is blocked\")\n    return parsed_url.geturl()\n\nclass TestCases(unittest.TestCase):\n    def test_case_1(self):\n        # Valid domain in allowed list returns the same URL\n        url = \"https://api.example.com/resource\"\n        self.assertEqual(validate_service_url(url), url)\n    \n    def test_case_2(self):\n        # Valid domain with port and query parameters returns the same URL\n        url = \"http://api.trusted.org:8080/path?query=param\"\n        self.assertEqual(validate_service_url(url), url)\n    \n    def test_case_3(self):\n        # Disallowed domain raises ValueError\n        url = \"https://api.malicious.com/data\"\n        with self.assertRaises(ValueError) as context:\n            validate_service_url(url)\n        self.assertEqual(str(context.exception), \"API domain not allowed\")\n    \n    def test_case_4(self):\n        # Internal IP address (10.0.0.1) raises ValueError\n        url = \"http://10.0.0.1/api\"\n        with self.assertRaises(ValueError) as context:\n            validate_service_url(url)\n        self.assertEqual(str(context.exception), \"API domain not allowed\")\n    \n    def test_case_5(self):\n        # URL without hostname (None) raises ValueError\n        url = \"/path\"\n        with self.assertRaises(ValueError) as context:\n            validate_service_url(url)\n        self.assertEqual(str(context.exception), \"API domain not allowed\")\n    \n    def test_case_6(self):\n        # Valid domain in mixed case raises ValueError due to case sensitivity\n        url = \"https://API.EXAMPLE.COM/resource\"\n        with self.assertRaises(ValueError) as context:\n            validate_service_url(url)\n        self.assertEqual(str(context.exception), \"API domain not allowed\")\n    \n    def test_case_7(self):\n        # Non-string input (None) raises TypeError\n        with self.assertRaises(TypeError):\n            validate_service_url(None)\n    \n    def test_case_8(self):\n        # Non-string input (integer) raises TypeError\n        with self.assertRaises(TypeError):\n            validate_service_url(123)\n    \n    def test_case_9(self):\n        # Allowed domain that matches internal IP pattern raises ValueError\n        with patch('__main__.ALLOWED_API_DOMAINS', {'10.ants.com'}):\n            url = \"http://10.ants.com\"\n            with self.assertRaises(ValueError) as context:\n                validate_service_url(url)\n            self.assertEqual(str(context.exception), \"Access to internal network addresses is blocked\")\n    \n    def test_case_10(self):\n        # Internal IP in allowed domain via mocking is blocked by IP pattern\n        with patch('__main__.ALLOWED_API_DOMAINS', {'192.168.1.1'}):\n            url = \"http://192.168.1.1\"\n            with self.assertRaises(ValueError) as context:\n                validate_service_url(url)\n            self.assertEqual(str(context.exception), \"Access to internal network addresses is blocked\")\n    \n    def test_case_11(self):\n        # Internal IP (172.16.0.1) in allowed domain via mocking is blocked\n        with patch('__main__.ALLOWED_API_DOMAINS', {'172.16.0.1'}):\n            url = \"ftp://172.16.0.1\"\n            with self.assertRaises(ValueError) as context:\n                validate_service_url(url)\n            self.assertEqual(str(context.exception), \"Access to internal network addresses is blocked\")\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 11, "task_id": "90e1001e"}
{"test": "import unittest\nfrom unittest.mock import patch\n\n# Import the function assuming it's available in a module named 'solution'\n# In practice, adjust the import path as needed\nfrom solution import check_api_endpoint\n\n# Define test class with class-level patching for constants\n@patch('solution.ALLOWED_API_DOMAINS', {'api.example.com', 'external.service.com'})\n@patch('solution.INTERNAL_IP_PATTERNS', [r'^10\\.', r'^192\\.168\\.', r'^172\\.(1[6-9]|2[0-9]|3[0-1])\\.'])\nclass TestCases(unittest.TestCase):\n    \n    def test_case_1(self):\n        # Happy path: allowed domain returns URL unchanged\n        url = 'https://api.example.com/data'\n        result = check_api_endpoint(url)\n        self.assertEqual(result, url)\n    \n    def test_case_2(self):\n        # Happy path: allowed domain with port and path\n        url = 'http://external.service.com:8080/v1'\n        result = check_api_endpoint(url)\n        self.assertEqual(result, url)\n    \n    def test_case_3(self):\n        # Domain not in allowed list raises ValueError\n        with self.assertRaises(ValueError) as context:\n            check_api_endpoint('https://malicious.com')\n        self.assertEqual(str(context.exception), 'API domain not allowed')\n    \n    def test_case_4(self):\n        # Internal IP (10.x.x.x) raises ValueError\n        with self.assertRaises(ValueError) as context:\n            check_api_endpoint('http://10.0.0.1')\n        self.assertEqual(str(context.exception), 'Access to internal network addresses is blocked')\n    \n    def test_case_5(self):\n        # Internal IP (192.168.x.x) raises ValueError\n        with self.assertRaises(ValueError) as context:\n            check_api_endpoint('http://192.168.1.1')\n        self.assertEqual(str(context.exception), 'Access to internal network addresses is blocked')\n    \n    def test_case_6(self):\n        # Internal IP (172.16.x.x) raises ValueError\n        with self.assertRaises(ValueError) as context:\n            check_api_endpoint('http://172.16.0.1')\n        self.assertEqual(str(context.exception), 'Access to internal network addresses is blocked')\n    \n    def test_case_7(self):\n        # Allowed domain matching internal pattern raises (overrides allowed domains)\n        with patch('solution.ALLOWED_API_DOMAINS', {'api.example.com', 'external.service.com', '10.example.com'}):\n            with self.assertRaises(ValueError) as context:\n                check_api_endpoint('http://10.example.com')\n            self.assertEqual(str(context.exception), 'Access to internal network addresses is blocked')\n    \n    def test_case_8(self):\n        # Invalid URL without hostname raises\n        with self.assertRaises(ValueError) as context:\n            check_api_endpoint('http://')\n        self.assertEqual(str(context.exception), 'API domain not allowed')\n    \n    def test_case_9(self):\n        # Public IP not in allowed domains raises\n        with self.assertRaises(ValueError) as context:\n            check_api_endpoint('http://8.8.8.8')\n        self.assertEqual(str(context.exception), 'API domain not allowed')\n    \n    def test_case_10(self):\n        # Allowed domain in uppercase raises (case-sensitive check)\n        with self.assertRaises(ValueError) as context:\n            check_api_endpoint('http://API.EXAMPLE.COM')\n        self.assertEqual(str(context.exception), 'API domain not allowed')\n    \n    def test_case_11(self):\n        # Public IP in allowed domains returns URL (overrides allowed domains)\n        with patch('solution.ALLOWED_API_DOMAINS', {'8.8.8.8'}):\n            url = 'http://8.8.8.8'\n            result = check_api_endpoint(url)\n            self.assertEqual(result, url)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 11, "task_id": "1fe250d4"}
{"test": "import unittest\nfrom unittest.mock import patch\n\nclass TestEnforceApiSecurity(unittest.TestCase):\n    # Define default configurations for the tests\n    DEFAULT_ALLOWED = {'api.example.com', 'external.service.org', '8.8.8.8'}\n    DEFAULT_PATTERNS = [\n        '^10\\\\.',\n        '^192\\\\.168\\\\.',\n        '^172\\\\.(1[6-9]|2[0-9]|3[0-1])\\\\.',\n        '^127\\\\.',\n        '^localhost$'\n    ]\n\n    def test_valid_domain(self):\n        # Test allowed domain without path or port\n        with patch('security.ALLOWED_API_DOMAINS', self.DEFAULT_ALLOWED), \\\n             patch('security.INTERNAL_IP_PATTERNS', self.DEFAULT_PATTERNS):\n            url = 'http://api.example.com'\n            result = enforce_api_security(url)\n            self.assertEqual(result, url)\n\n    def test_valid_domain_with_path(self):\n        # Test allowed domain with path\n        with patch('security.ALLOWED_API_DOMAINS', self.DEFAULT_ALLOWED), \\\n             patch('security.INTERNAL_IP_PATTERNS', self.DEFAULT_PATTERNS):\n            url = 'http://api.example.com/path/to/resource'\n            result = enforce_api_security(url)\n            self.assertEqual(result, url)\n\n    def test_valid_domain_with_port(self):\n        # Test allowed domain with port\n        with patch('security.ALLOWED_API_DOMAINS', self.DEFAULT_ALLOWED), \\\n             patch('security.INTERNAL_IP_PATTERNS', self.DEFAULT_PATTERNS):\n            url = 'http://api.example.com:8080'\n            result = enforce_api_security(url)\n            self.assertEqual(result, url)\n\n    def test_valid_ip(self):\n        # Test allowed external IP\n        with patch('security.ALLOWED_API_DOMAINS', self.DEFAULT_ALLOWED), \\\n             patch('security.INTERNAL_IP_PATTERNS', self.DEFAULT_PATTERNS):\n            url = 'http://8.8.8.8'\n            result = enforce_api_security(url)\n            self.assertEqual(result, url)\n\n    def test_domain_not_allowed(self):\n        # Test disallowed domain\n        with patch('security.ALLOWED_API_DOMAINS', self.DEFAULT_ALLOWED), \\\n             patch('security.INTERNAL_IP_PATTERNS', self.DEFAULT_PATTERNS):\n            with self.assertRaises(ValueError) as context:\n                enforce_api_security('http://unknown.com')\n            self.assertEqual(str(context.exception), \"API domain not allowed\")\n\n    def test_internal_ip_not_allowed(self):\n        # Test internal IP not in allowed domains\n        with patch('security.ALLOWED_API_DOMAINS', self.DEFAULT_ALLOWED), \\\n             patch('security.INTERNAL_IP_PATTERNS', self.DEFAULT_PATTERNS):\n            with self.assertRaises(ValueError) as context:\n                enforce_api_security('http://10.0.0.1')\n            self.assertEqual(str(context.exception), \"API domain not allowed\")\n\n    def test_internal_ip_in_allowed_but_blocked_by_pattern(self):\n        # Test internal IP in allowed domains but blocked by IP pattern\n        allowed = self.DEFAULT_ALLOWED | {'10.0.0.1'}\n        with patch('security.ALLOWED_API_DOMAINS', allowed), \\\n             patch('security.INTERNAL_IP_PATTERNS', self.DEFAULT_PATTERNS):\n            with self.assertRaises(ValueError) as context:\n                enforce_api_security('http://10.0.0.1')\n            self.assertEqual(str(context.exception), \"Access to internal network addresses is blocked\")\n\n    def test_domain_in_allowed_but_matches_internal_pattern(self):\n        # Test domain in allowed list but matches internal IP pattern\n        allowed = self.DEFAULT_ALLOWED | {'10.dangerous.com'}\n        with patch('security.ALLOWED_API_DOMAINS', allowed), \\\n             patch('security.INTERNAL_IP_PATTERNS', self.DEFAULT_PATTERNS):\n            with self.assertRaises(ValueError) as context:\n                enforce_api_security('http://10.dangerous.com')\n            self.assertEqual(str(context.exception), \"Access to internal network addresses is blocked\")\n\n    def test_domain_not_allowed_and_matches_internal_pattern(self):\n        # Test domain not in allowed list and matches internal IP pattern\n        with patch('security.ALLOWED_API_DOMAINS', self.DEFAULT_ALLOWED), \\\n             patch('security.INTERNAL_IP_PATTERNS', self.DEFAULT_PATTERNS):\n            with self.assertRaises(ValueError) as context:\n                enforce_api_security('http://10.dangerous.com')\n            self.assertEqual(str(context.exception), \"API domain not allowed\")\n\n    def test_invalid_url(self):\n        # Test invalid URL format\n        with patch('security.ALLOWED_API_DOMAINS', self.DEFAULT_ALLOWED), \\\n             patch('security.INTERNAL_IP_PATTERNS', self.DEFAULT_PATTERNS):\n            with self.assertRaises(ValueError) as context:\n                enforce_api_security('invalid_url')\n            self.assertEqual(str(context.exception), \"API domain not allowed\")\n\n    def test_localhost_not_allowed(self):\n        # Test localhost not in allowed domains\n        with patch('security.ALLOWED_API_DOMAINS', self.DEFAULT_ALLOWED), \\\n             patch('security.INTERNAL_IP_PATTERNS', self.DEFAULT_PATTERNS):\n            with self.assertRaises(ValueError) as context:\n                enforce_api_security('http://localhost')\n            self.assertEqual(str(context.exception), \"API domain not allowed\")\n\n    def test_127_0_0_1_not_allowed(self):\n        # Test 127.0.0.1 not in allowed domains\n        with patch('security.ALLOWED_API_DOMAINS', self.DEFAULT_ALLOWED), \\\n             patch('security.INTERNAL_IP_PATTERNS', self.DEFAULT_PATTERNS):\n            with self.assertRaises(ValueError) as context:\n                enforce_api_security('http://127.0.0.1')\n            self.assertEqual(str(context.exception), \"API domain not allowed\")\n\n    def test_localhost_in_allowed_but_blocked_by_pattern(self):\n        # Test localhost in allowed domains but blocked by pattern\n        allowed = self.DEFAULT_ALLOWED | {'localhost'}\n        with patch('security.ALLOWED_API_DOMAINS', allowed), \\\n             patch('security.INTERNAL_IP_PATTERNS', self.DEFAULT_PATTERNS):\n            with self.assertRaises(ValueError) as context:\n                enforce_api_security('http://localhost')\n            self.assertEqual(str(context.exception), \"Access to internal network addresses is blocked\")\n\n    def test_empty_string(self):\n        # Test empty URL string\n        with patch('security.ALLOWED_API_DOMAINS', self.DEFAULT_ALLOWED), \\\n             patch('security.INTERNAL_IP_PATTERNS', self.DEFAULT_PATTERNS):\n            with self.assertRaises(ValueError) as context:\n                enforce_api_security('')\n            self.assertEqual(str(context.exception), \"API domain not allowed\")\n\n    def test_url_without_scheme(self):\n        # Test URL without scheme\n        with patch('security.ALLOWED_API_DOMAINS', self.DEFAULT_ALLOWED), \\\n             patch('security.INTERNAL_IP_PATTERNS', self.DEFAULT_PATTERNS):\n            with self.assertRaises(ValueError) as context:\n                enforce_api_security('api.example.com')\n            self.assertEqual(str(context.exception), \"API domain not allowed\")\n\n    def test_non_string_url(self):\n        # Test non-string input (None)\n        with patch('security.ALLOWED_API_DOMAINS', self.DEFAULT_ALLOWED), \\\n             patch('security.INTERNAL_IP_PATTERNS', self.DEFAULT_PATTERNS):\n            with self.assertRaises(TypeError):\n                enforce_api_security(None)\n", "num_test_cases": 16, "task_id": "485c7663"}
{"test": "import unittest\nfrom unittest.mock import patch\n\nclass TestVerifyApiAddress(unittest.TestCase):\n\n    def test_happy_path_domain(self):\n        \"\"\"Test valid URL with allowed domain and public IP.\"\"\"\n        allowed_domains = {'api.example.com'}\n        internal_patterns = [r'^10\\.', r'^192\\.168\\.', r'^172\\.(1[6-9]|2[0-9]|3[0-1])\\.', r'^127\\.']\n        with patch('solution.ALLOWED_API_DOMAINS', allowed_domains), \\\n             patch('solution.INTERNAL_IP_PATTERNS', internal_patterns):\n            url = \"https://api.example.com/resource\"\n            result = verify_api_address(url)\n            self.assertEqual(result, url)\n\n    def test_happy_path_public_ip(self):\n        \"\"\"Test allowed public IP address that does not match internal patterns.\"\"\"\n        allowed_domains = {'8.8.8.8'}\n        internal_patterns = [r'^10\\.', r'^192\\.168\\.', r'^172\\.(1[6-9]|2[0-9]|3[0-1])\\.', r'^127\\.']\n        with patch('solution.ALLOWED_API_DOMAINS', allowed_domains), \\\n             patch('solution.INTERNAL_IP_PATTERNS', internal_patterns):\n            url = \"http://8.8.8.8\"\n            result = verify_api_address(url)\n            self.assertEqual(result, url)\n\n    def test_domain_not_allowed(self):\n        \"\"\"Test domain not in allowed list raises error.\"\"\"\n        allowed_domains = {'api.example.com'}\n        internal_patterns = []\n        with patch('solution.ALLOWED_API_DOMAINS', allowed_domains), \\\n             patch('solution.INTERNAL_IP_PATTERNS', internal_patterns):\n            with self.assertRaises(ValueError) as cm:\n                verify_api_address(\"https://bad.com\")\n            self.assertEqual(str(cm.exception), \"API domain not allowed\")\n\n    def test_allowed_domain_internal_ip(self):\n        \"\"\"Test allowed domain that resolves to internal IP raises error.\"\"\"\n        allowed_domains = {'10.0.0.1'}\n        internal_patterns = [r'^10\\.']\n        with patch('solution.ALLOWED_API_DOMAINS', allowed_domains), \\\n             patch('solution.INTERNAL_IP_PATTERNS', internal_patterns):\n            with self.assertRaises(ValueError) as cm:\n                verify_api_address(\"http://10.0.0.1\")\n            self.assertEqual(str(cm.exception), \"Access to internal network addresses is blocked\")\n\n    def test_not_allowed_internal_ip(self):\n        \"\"\"Test internal IP not in allowed domains raises domain error.\"\"\"\n        allowed_domains = {'api.example.com'}\n        internal_patterns = [r'^10\\.']\n        with patch('solution.ALLOWED_API_DOMAINS', allowed_domains), \\\n             patch('solution.INTERNAL_IP_PATTERNS', internal_patterns):\n            with self.assertRaises(ValueError) as cm:\n                verify_api_address(\"http://10.0.0.1\")\n            self.assertEqual(str(cm.exception), \"API domain not allowed\")\n\n    def test_invalid_url_hostname_none(self):\n        \"\"\"Test invalid URL (hostname None) raises domain error.\"\"\"\n        allowed_domains = {'api.example.com'}\n        internal_patterns = []\n        with patch('solution.ALLOWED_API_DOMAINS', allowed_domains), \\\n             patch('solution.INTERNAL_IP_PATTERNS', internal_patterns):\n            with self.assertRaises(ValueError) as cm:\n                verify_api_address(\"not_a_valid_url\")\n            self.assertEqual(str(cm.exception), \"API domain not allowed\")\n\n    def test_none_input(self):\n        \"\"\"Test None input raises TypeError.\"\"\"\n        allowed_domains = {'api.example.com'}\n        internal_patterns = []\n        with patch('solution.ALLOWED_API_DOMAINS', allowed_domains), \\\n             patch('solution.INTERNAL_IP_PATTERNS', internal_patterns):\n            with self.assertRaises(TypeError):\n                verify_api_address(None)\n\n    def test_non_string_input(self):\n        \"\"\"Test non-string input raises TypeError.\"\"\"\n        allowed_domains = {'api.example.com'}\n        internal_patterns = []\n        with patch('solution.ALLOWED_API_DOMAINS', allowed_domains), \\\n             patch('solution.INTERNAL_IP_PATTERNS', internal_patterns):\n            with self.assertRaises(TypeError):\n                verify_api_address(12345)\n\n    def test_long_url(self):\n        \"\"\"Test long URL with allowed domain passes.\"\"\"\n        allowed_domains = {'api.example.com'}\n        internal_patterns = []\n        with patch('solution.ALLOWED_API_DOMAINS', allowed_domains), \\\n             patch('solution.INTERNAL_IP_PATTERNS', internal_patterns):\n            long_url = \"https://api.example.com/\" + \"a\" * 1000\n            result = verify_api_address(long_url)\n            self.assertEqual(result, long_url)\n\n    def test_complex_url(self):\n        \"\"\"Test complex URL with port, user, and query components.\"\"\"\n        allowed_domains = {'api.example.com'}\n        internal_patterns = []\n        with patch('solution.ALLOWED_API_DOMAINS', allowed_domains), \\\n             patch('solution.INTERNAL_IP_PATTERNS', internal_patterns):\n            url = \"https://user:pass@api.example.com:8080/path?query=value\"\n            result = verify_api_address(url)\n            self.assertEqual(result, url)\n", "num_test_cases": 10, "task_id": "0b1a6967"}
{"test": "import unittest\nimport solution\n\n# Set up the global variables in the solution module for testing\nsolution.ALLOWED_SCHEMES = {'http', 'https'}\nsolution.TRUSTED_RSS_PROVIDERS = {\n    'trusted1.com',\n    'trusted2.org',\n    'example.com',\n    '8.8.8.8',\n    '10.0.0.1',\n    '10.trusted.com'\n}\nsolution.INTERNAL_IP_PATTERNS = [\n    r'^10\\.',\n    r'^172\\.(1[6-9]|2[0-9]|3[0-1])\\.',\n    r'^192\\.168\\.',\n    r'^127\\.',\n    r'^0\\.',\n    r'localhost'\n]\n\nfrom solution import secure_feed_link\n\nclass TestSecureFeedLink(unittest.TestCase):\n\n    def test_trusted_domain_http(self):\n        # Test valid HTTP URL with trusted domain\n        url = \"http://trusted1.com\"\n        self.assertEqual(secure_feed_link(url), url)\n    \n    def test_trusted_domain_https(self):\n        # Test valid HTTPS URL with trusted domain\n        url = \"https://trusted1.com\"\n        self.assertEqual(secure_feed_link(url), url)\n    \n    def test_trusted_domain_with_port(self):\n        # Test trusted domain with port number\n        url = \"http://trusted1.com:8080\"\n        self.assertEqual(secure_feed_link(url), url)\n    \n    def test_trusted_domain_with_path_query_fragment(self):\n        # Test trusted domain with path, query, and fragment\n        url = \"https://trusted1.com/path?query=value#fragment\"\n        self.assertEqual(secure_feed_link(url), url)\n    \n    def test_trusted_public_ip(self):\n        # Test trusted public IP address\n        url = \"http://8.8.8.8\"\n        self.assertEqual(secure_feed_link(url), url)\n    \n    def test_invalid_scheme(self):\n        # Test URL with invalid scheme (ftp)\n        with self.assertRaises(ValueError):\n            secure_feed_link(\"ftp://trusted1.com\")\n    \n    def test_untrusted_domain(self):\n        # Test untrusted domain\n        with self.assertRaises(ValueError):\n            secure_feed_link(\"http://untrusted.com\")\n    \n    def test_untrusted_internal_ip(self):\n        # Test untrusted internal IP (not in trusted set)\n        with self.assertRaises(ValueError):\n            secure_feed_link(\"http://192.168.1.1\")\n    \n    def test_trusted_internal_ip(self):\n        # Test trusted internal IP (blocked by internal pattern)\n        with self.assertRaises(ValueError):\n            secure_feed_link(\"http://10.0.0.1\")\n    \n    def test_empty_url(self):\n        # Test empty URL string\n        with self.assertRaises(ValueError):\n            secure_feed_link(\"\")\n    \n    def test_none_url(self):\n        # Test None URL\n        with self.assertRaises(TypeError):\n            secure_feed_link(None)\n    \n    def test_non_string_url(self):\n        # Test non-string URL (integer)\n        with self.assertRaises(TypeError):\n            secure_feed_link(123)\n    \n    def test_trusted_domain_with_internal_pattern(self):\n        # Test trusted domain that matches internal pattern\n        with self.assertRaises(ValueError):\n            secure_feed_link(\"http://10.trusted.com\")", "num_test_cases": 13, "task_id": "827bdf91"}
{"test": "import unittest\nfrom unittest.mock import patch\nfrom urllib.parse import urlparse\nimport re\n\nclass TestCases(unittest.TestCase):\n    module_name = None\n\n    @classmethod\n    def setUpClass(cls):\n        cls.module_name = validate_feed_source.__module__\n    \n    # Define constants for test scenarios\n    trusted_providers = {'trusted.com', 'example.org'}\n    internal_patterns = [r'^10\\.', r'^172\\.(1[6-9]|2[0-9]|3[0-1])\\.', r'^192\\.168\\.', r'^127\\.']\n    \n    def test_case_1(self):\n        # Test valid HTTP URL with trusted host\n        with patch(f'{self.module_name}.TRUSTED_RSS_PROVIDERS', self.trusted_providers), \\\n             patch(f'{self.module_name}.INTERNAL_IP_PATTERNS', self.internal_patterns):\n            url = 'http://trusted.com'\n            result = validate_feed_source(url)\n            expected = urlparse(url).geturl()\n            self.assertEqual(result, expected)\n    \n    def test_case_2(self):\n        # Test valid HTTPS URL with trusted host\n        with patch(f'{self.module_name}.TRUSTED_RSS_PROVIDERS', self.trusted_providers), \\\n             patch(f'{self.module_name}.INTERNAL_IP_PATTERNS', self.internal_patterns):\n            url = 'https://example.org'\n            result = validate_feed_source(url)\n            expected = urlparse(url).geturl()\n            self.assertEqual(result, expected)\n    \n    def test_case_3(self):\n        # Test non-HTTP/HTTPS scheme (FTP)\n        with patch(f'{self.module_name}.TRUSTED_RSS_PROVIDERS', self.trusted_providers), \\\n             patch(f'{self.module_name}.INTERNAL_IP_PATTERNS', self.internal_patterns):\n            with self.assertRaises(ValueError):\n                validate_feed_source('ftp://trusted.com')\n    \n    def test_case_4(self):\n        # Test trusted host that is internal IP\n        with patch(f'{self.module_name}.TRUSTED_RSS_PROVIDERS', {'10.0.0.1'}), \\\n             patch(f'{self.module_name}.INTERNAL_IP_PATTERNS', self.internal_patterns):\n            with self.assertRaises(ValueError):\n                validate_feed_source('http://10.0.0.1')\n    \n    def test_case_5(self):\n        # Test untrusted host\n        with patch(f'{self.module_name}.TRUSTED_RSS_PROVIDERS', self.trusted_providers), \\\n             patch(f'{self.module_name}.INTERNAL_IP_PATTERNS', self.internal_patterns):\n            with self.assertRaises(ValueError):\n                validate_feed_source('http://untrusted.com')\n    \n    def test_case_6(self):\n        # Test URL with port and path\n        with patch(f'{self.module_name}.TRUSTED_RSS_PROVIDERS', self.trusted_providers), \\\n             patch(f'{self.module_name}.INTERNAL_IP_PATTERNS', self.internal_patterns):\n            url = 'http://trusted.com:8080/path?query=value'\n            result = validate_feed_source(url)\n            expected = urlparse(url).geturl()\n            self.assertEqual(result, expected)\n    \n    def test_case_7(self):\n        # Test empty string input\n        with patch(f'{self.module_name}.TRUSTED_RSS_PROVIDERS', self.trusted_providers), \\\n             patch(f'{self.module_name}.INTERNAL_IP_PATTERNS', self.internal_patterns):\n            with self.assertRaises(ValueError):\n                validate_feed_source('')\n    \n    def test_case_8(self):\n        # Test None input\n        with self.assertRaises(TypeError):\n            validate_feed_source(None)\n    \n    def test_case_9(self):\n        # Test non-string input (integer)\n        with self.assertRaises(TypeError):\n            validate_feed_source(123)\n    \n    def test_case_10(self):\n        # Test valid URL with userinfo\n        with patch(f'{self.module_name}.TRUSTED_RSS_PROVIDERS', self.trusted_providers), \\\n             patch(f'{self.module_name}.INTERNAL_IP_PATTERNS', self.internal_patterns):\n            url = 'http://user:pass@trusted.com'\n            result = validate_feed_source(url)\n            expected = urlparse(url).geturl()\n            self.assertEqual(result, expected)\n    \n    def test_case_11(self):\n        # Test trusted public IP address\n        with patch(f'{self.module_name}.TRUSTED_RSS_PROVIDERS', {'8.8.8.8'}), \\\n             patch(f'{self.module_name}.INTERNAL_IP_PATTERNS', self.internal_patterns):\n            url = 'http://8.8.8.8'\n            result = validate_feed_source(url)\n            expected = urlparse(url).geturl()\n            self.assertEqual(result, expected)\n    \n    def test_case_12(self):\n        # Test internal IP that is not trusted (should fail at trusted check)\n        with patch(f'{self.module_name}.TRUSTED_RSS_PROVIDERS', self.trusted_providers), \\\n             patch(f'{self.module_name}.INTERNAL_IP_PATTERNS', self.internal_patterns):\n            with self.assertRaises(ValueError):\n                validate_feed_source('http://192.168.1.1')\n\ndef run_tests():\n    suite = unittest.TestLoader().loadTestsFromTestCase(TestCases)\n    unittest.TextTestRunner(verbosity=2).run(suite)\n\nif __name__ == '__main__':\n    run_tests()", "num_test_cases": 12, "task_id": "3c805292"}
{"test": "import unittest\nfrom urllib.parse import urlparse\nimport re\n\n# Define constants used by the function\nALLOWED_SCHEMES = ['http', 'https']\nTRUSTED_RSS_PROVIDERS = ['trusted1.com', 'trusted2.org']\nINTERNAL_IP_PATTERNS = [\n    '^10\\\\.',\n    '^192\\\\.168\\\\.',\n    '^172\\\\.(1[6-9]|2[0-9]|3[0-1])\\\\.',\n    '^127\\\\.',\n    '^localhost$'\n]\n\ndef check_feed_url(rss_link: str):\n    \"\"\"Securely validate and sanitize RSS feed URL based on security policies.\"\"\"\n    parsed_url = urlparse(rss_link)\n    if parsed_url.scheme not in ALLOWED_SCHEMES:\n        raise ValueError(\"Only HTTP or HTTPS schemes are allowed\")\n    if parsed_url.hostname not in TRUSTED_RSS_PROVIDERS:\n        raise ValueError(\"RSS feed provider not trusted\")\n    hostname_str = str(parsed_url.hostname)\n    for pattern in INTERNAL_IP_PATTERNS:\n        if re.match(pattern, hostname_str):\n            raise ValueError(\"Access to internal network addresses is blocked\")\n    return parsed_url.geturl()\n\nclass TestCheckFeedUrl(unittest.TestCase):\n\n    def test_valid_http_url(self):\n        \"\"\"Test valid HTTP URL from trusted provider.\"\"\"\n        url = \"http://trusted1.com/rss\"\n        self.assertEqual(check_feed_url(url), url)\n\n    def test_valid_https_url(self):\n        \"\"\"Test valid HTTPS URL from trusted provider.\"\"\"\n        url = \"https://trusted1.com/rss\"\n        self.assertEqual(check_feed_url(url), url)\n\n    def test_valid_url_with_port_and_path(self):\n        \"\"\"Test valid URL with specified port and path.\"\"\"\n        url = \"http://trusted1.com:8080/rss\"\n        self.assertEqual(check_feed_url(url), url)\n\n    def test_valid_url_with_query(self):\n        \"\"\"Test valid URL including query parameters.\"\"\"\n        url = \"https://trusted1.com/rss?param=value\"\n        self.assertEqual(check_feed_url(url), url)\n\n    def test_valid_url_with_user_password(self):\n        \"\"\"Test valid URL with user:password in netloc.\"\"\"\n        url = \"http://user:pass@trusted1.com/rss\"\n        self.assertEqual(check_feed_url(url), url)\n\n    def test_invalid_scheme_ftp(self):\n        \"\"\"Test URL with disallowed FTP scheme.\"\"\"\n        with self.assertRaises(ValueError):\n            check_feed_url(\"ftp://trusted1.com/rss\")\n\n    def test_invalid_scheme_file(self):\n        \"\"\"Test URL with disallowed file scheme.\"\"\"\n        with self.assertRaises(ValueError):\n            check_feed_url(\"file:///path/to/file\")\n\n    def test_untrusted_host(self):\n        \"\"\"Test URL from untrusted provider.\"\"\"\n        with self.assertRaises(ValueError):\n            check_feed_url(\"http://untrusted.com/rss\")\n\n    def test_internal_ip_range_10(self):\n        \"\"\"Test URL in 10.x.x.x internal range.\"\"\"\n        with self.assertRaises(ValueError):\n            check_feed_url(\"http://10.0.0.1/rss\")\n\n    def test_internal_ip_range_192(self):\n        \"\"\"Test URL in 192.168.x.x internal range.\"\"\"\n        with self.assertRaises(ValueError):\n            check_feed_url(\"http://192.168.1.1/rss\")\n\n    def test_internal_ip_range_172(self):\n        \"\"\"Test URL in 172.16-31.x.x internal range.\"\"\"\n        with self.assertRaises(ValueError):\n            check_feed_url(\"http://172.16.0.1/rss\")\n\n    def test_internal_ip_127(self):\n        \"\"\"Test URL with 127.x.x.x internal IP.\"\"\"\n        with self.assertRaises(ValueError):\n            check_feed_url(\"http://127.0.0.1/rss\")\n\n    def test_internal_localhost(self):\n        \"\"\"Test URL with 'localhost' as hostname.\"\"\"\n        with self.assertRaises(ValueError):\n            check_feed_url(\"http://localhost/rss\")\n\n    def test_empty_string_input(self):\n        \"\"\"Test empty string input.\"\"\"\n        with self.assertRaises(ValueError):\n            check_feed_url(\"\")\n\n    def test_invalid_url_no_scheme(self):\n        \"\"\"Test invalid URL without scheme.\"\"\"\n        with self.assertRaises(ValueError):\n            check_feed_url(\"invalid_url\")\n\n    def test_url_with_scheme_but_no_host(self):\n        \"\"\"Test URL with scheme but no host.\"\"\"\n        with self.assertRaises(ValueError):\n            check_feed_url(\"http://\")\n\n    def test_none_input(self):\n        \"\"\"Test None input raises TypeError.\"\"\"\n        with self.assertRaises(TypeError):\n            check_feed_url(None)\n\n    def test_non_string_input_integer(self):\n        \"\"\"Test non-string input (integer) raises TypeError.\"\"\"\n        with self.assertRaises(TypeError):\n            check_feed_url(123)\n\n    def test_valid_https_trusted2(self):\n        \"\"\"Test valid HTTPS URL from second trusted provider.\"\"\"\n        url = \"https://trusted2.org/rss\"\n        self.assertEqual(check_feed_url(url), url)\n\n    def test_invalid_scheme_ftps(self):\n        \"\"\"Test URL with disallowed FTPS scheme.\"\"\"\n        with self.assertRaises(ValueError):\n            check_feed_url(\"ftps://trusted1.com/rss\")\n\n    def test_internal_ip_172_31(self):\n        \"\"\"Test URL in 172.31.x.x internal range.\"\"\"\n        with self.assertRaises(ValueError):\n            check_feed_url(\"http://172.31.255.255/rss\")\n\n    def test_internal_ip_172_boundary(self):\n        \"\"\"Test URL at boundary of invalid 172 range (172.32).\"\"\"\n        # Should not raise as 172.32 is outside the internal range\n        url = \"http://172.32.0.1/rss\"\n        # But hostname not in trusted providers, expect different ValueError\n        with self.assertRaises(ValueError) as context:\n            check_feed_url(url)\n        self.assertEqual(str(context.exception), \"RSS feed provider not trusted\")\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 23, "task_id": "6c82b51f"}
{"test": "import unittest\nimport re\nfrom urllib.parse import urlparse\n\n# Assuming the following constants are defined in the module where validate_rss_link is located:\n# ALLOWED_SCHEMES = {'http', 'https'}\n# TRUSTED_RSS_PROVIDERS = {'trusted1.com', 'trusted2.org', 'example.org', '8.8.8.8'}\n# INTERNAL_IP_PATTERNS = [r'^10\\.', r'^192\\.168\\.', r'^172\\.(1[6-9]|2[0-9]|3[0-1])\\.']\n\nclass TestValidateRSSLink(unittest.TestCase):\n    def test_valid_http_trusted_domain(self):\n        # Happy path: Valid HTTP URL with trusted domain\n        url = 'http://trusted1.com'\n        self.assertEqual(validate_rss_link(url), url)\n\n    def test_valid_https_trusted_domain(self):\n        # Happy path: Valid HTTPS URL with trusted domain\n        url = 'https://trusted2.org'\n        self.assertEqual(validate_rss_link(url), url)\n\n    def test_valid_url_with_path(self):\n        # Happy path: Trusted domain with path in URL\n        url = 'http://example.org/rss'\n        self.assertEqual(validate_rss_link(url), url)\n\n    def test_valid_public_ip_in_trusted_set(self):\n        # Happy path: Public IP address in trusted providers\n        url = 'http://8.8.8.8'\n        self.assertEqual(validate_rss_link(url), url)\n\n    def test_valid_domain_with_port(self):\n        # Happy path: Trusted domain with non-standard port\n        url = 'http://trusted1.com:8080'\n        self.assertEqual(validate_rss_link(url), url)\n\n    def test_invalid_scheme_ftp(self):\n        # Error: Non-HTTP(S) scheme (ftp)\n        with self.assertRaises(ValueError) as context:\n            validate_rss_link('ftp://trusted1.com')\n        self.assertEqual(str(context.exception), \"Only HTTP or HTTPS schemes are allowed\")\n\n    def test_untrusted_domain(self):\n        # Error: Domain not in trusted providers\n        with self.assertRaises(ValueError) as context:\n            validate_rss_link('http://untrusted.com')\n        self.assertEqual(str(context.exception), \"RSS feed provider not trusted\")\n\n    def test_internal_ip_address(self):\n        # Error: Internal IP address (10.0.0.1)\n        with self.assertRaises(ValueError) as context:\n            validate_rss_link('http://10.0.0.1')\n        self.assertEqual(str(context.exception), \"Access to internal network addresses is blocked\")\n\n    def test_domain_like_internal_ip(self):\n        # Error: Domain name resembling internal IP pattern\n        with self.assertRaises(ValueError) as context:\n            validate_rss_link('http://10.example.com')\n        self.assertEqual(str(context.exception), \"Access to internal network addresses is blocked\")\n\n    def test_public_ip_not_in_trusted(self):\n        # Error: Public IP address not in trusted providers\n        with self.assertRaises(ValueError) as context:\n            validate_rss_link('http://1.1.1.1')\n        self.assertEqual(str(context.exception), \"RSS feed provider not trusted\")\n\n    def test_malformed_url_no_hostname(self):\n        # Error: Malformed URL without a hostname\n        with self.assertRaises(ValueError) as context:\n            validate_rss_link('http://')\n        self.assertEqual(str(context.exception), \"RSS feed provider not trusted\")\n\n    def test_internal_ip_192_168(self):\n        # Error: Internal IP in 192.168 range\n        with self.assertRaises(ValueError) as context:\n            validate_rss_link('http://192.168.1.1')\n        self.assertEqual(str(context.exception), \"Access to internal network addresses is blocked\")\n\n    def test_internal_ip_172_16(self):\n        # Error: Internal IP in 172.16 range\n        with self.assertRaises(ValueError) as context:\n            validate_rss_link('http://172.16.0.1')\n        self.assertEqual(str(context.exception), \"Access to internal network addresses is blocked\")\n\n    def test_https_internal_ip(self):\n        # Error: HTTPS URL with internal IP\n        with self.assertRaises(ValueError) as context:\n            validate_rss_link('https://10.0.0.1')\n        self.assertEqual(str(context.exception), \"Access to internal network addresses is blocked\")\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 14, "task_id": "c8bf6f36"}
