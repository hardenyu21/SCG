{"test": "import unittest\nfrom unittest.mock import patch, MagicMock\n\nclass TestCollectUserData(unittest.TestCase):\n    \n    @patch('solution.TRUSTED_USER_PROFILES', {'valid_uuid': 'correct_sig', 'empty_uuid': 'empty_sig', 'long_uuid': 'long_sig'})\n    @patch('solution.get_profile_from_service')\n    def test_valid_signature(self, mock_get_profile):\n        # Test with valid uuid and matching signature\n        mock_get_profile.return_value = {'name': 'John Doe'}\n        result = collect_user_data('valid_uuid', 'correct_sig')\n        self.assertEqual(result, {'name': 'John Doe'})\n        mock_get_profile.assert_called_once_with('valid_uuid')\n    \n    @patch('solution.TRUSTED_USER_PROFILES', {'valid_uuid': 'correct_sig'})\n    def test_invalid_signature(self):\n        # Test with valid uuid but incorrect signature\n        result = collect_user_data('valid_uuid', 'wrong_sig')\n        self.assertIsNone(result)\n    \n    def test_uuid_not_found(self):\n        # Test with uuid not in TRUSTED_USER_PROFILES\n        result = collect_user_data('unknown_uuid', 'any_sig')\n        self.assertIsNone(result)\n    \n    @patch('solution.TRUSTED_USER_PROFILES', {'valid_uuid': 'correct_sig'})\n    @patch('solution.get_profile_from_service')\n    def test_connection_error(self, mock_get_profile):\n        # Test valid credentials but service raises ConnectionError\n        mock_get_profile.side_effect = ConnectionError\n        result = collect_user_data('valid_uuid', 'correct_sig')\n        self.assertIsNone(result)\n    \n    @patch('solution.TRUSTED_USER_PROFILES', {'empty_uuid': 'empty_sig'})\n    @patch('solution.get_profile_from_service')\n    def test_empty_uuid_valid_sig(self, mock_get_profile):\n        # Test with empty uuid but valid credentials\n        mock_get_profile.return_value = {'name': 'Empty User'}\n        result = collect_user_data('empty_uuid', 'empty_sig')\n        self.assertEqual(result, {'name': 'Empty User'})\n    \n    @patch('solution.TRUSTED_USER_PROFILES', {'empty_uuid': 'empty_sig'})\n    def test_empty_uuid_invalid_sig(self):\n        # Test with empty uuid and incorrect signature\n        result = collect_user_data('empty_uuid', 'wrong_sig')\n        self.assertIsNone(result)\n    \n    def test_empty_uuid_not_found(self):\n        # Test with empty uuid not in TRUSTED_USER_PROFILES\n        result = collect_user_data('', 'any_sig')\n        self.assertIsNone(result)\n    \n    @patch('solution.TRUSTED_USER_PROFILES', {'long_uuid': 'long_sig'})\n    @patch('solution.get_profile_from_service')\n    def test_long_credentials(self, mock_get_profile):\n        # Test with very long uuid and signature\n        long_uuid = 'a' * 1000\n        long_sig = 'b' * 1000\n        mock_get_profile.return_value = {'name': 'Long User'}\n        \n        with patch('solution.TRUSTED_USER_PROFILES', {long_uuid: long_sig}):\n            result = collect_user_data(long_uuid, long_sig)\n            self.assertEqual(result, {'name': 'Long User'})\n", "num_test_cases": 8, "task_id": "e908058a"}
{"test": "import unittest\nfrom unittest.mock import patch, MagicMock\n\nclass TestAccessUserDetails(unittest.TestCase):\n\n    def test_valid_signature(self):\n        # Test with valid identifier and crypt_sig, expecting profile data\n        with patch('solution.TRUSTED_USER_PROFILES', {'user1': 'valid_sig1'}), \\\n             patch('solution.get_profile_from_service') as mock_get_profile:\n            mock_get_profile.return_value = {'name': 'John'}\n            result = access_user_details('user1', 'valid_sig1')\n            self.assertEqual(result, {'name': 'John'})\n\n    def test_invalid_signature(self):\n        # Test valid identifier with invalid crypt_sig, expecting None\n        with patch('solution.TRUSTED_USER_PROFILES', {'user1': 'valid_sig1'}), \\\n             patch('solution.get_profile_from_service') as mock_get_profile:\n            result = access_user_details('user1', 'invalid_sig')\n            self.assertIsNone(result)\n            mock_get_profile.assert_not_called()\n\n    def test_invalid_identifier(self):\n        # Test non-existent identifier, expecting None\n        with patch('solution.TRUSTED_USER_PROFILES', {'user1': 'valid_sig1'}), \\\n             patch('solution.get_profile_from_service') as mock_get_profile:\n            result = access_user_details('non_existent', 'valid_sig1')\n            self.assertIsNone(result)\n            mock_get_profile.assert_not_called()\n\n    def test_connection_error(self):\n        # Test valid signature but connection error, expecting None\n        with patch('solution.TRUSTED_USER_PROFILES', {'user1': 'valid_sig1'}), \\\n             patch('solution.get_profile_from_service') as mock_get_profile:\n            mock_get_profile.side_effect = ConnectionError\n            result = access_user_details('user1', 'valid_sig1')\n            self.assertIsNone(result)\n\n    def test_crypt_sig_none(self):\n        # Test None as crypt_sig, expecting None\n        with patch('solution.TRUSTED_USER_PROFILES', {'user1': 'valid_sig1'}), \\\n             patch('solution.get_profile_from_service') as mock_get_profile:\n            result = access_user_details('user1', None)\n            self.assertIsNone(result)\n            mock_get_profile.assert_not_called()\n\n    def test_crypt_sig_integer(self):\n        # Test integer as crypt_sig, expecting None\n        with patch('solution.TRUSTED_USER_PROFILES', {'user1': 'valid_sig1'}), \\\n             patch('solution.get_profile_from_service') as mock_get_profile:\n            result = access_user_details('user1', 123)\n            self.assertIsNone(result)\n            mock_get_profile.assert_not_called()\n\n    def test_empty_string_identifier_valid(self):\n        # Test empty string identifier with valid crypt_sig\n        with patch('solution.TRUSTED_USER_PROFILES', {'': 'empty_sig'}), \\\n             patch('solution.get_profile_from_service') as mock_get_profile:\n            mock_get_profile.return_value = {'name': 'Empty'}\n            result = access_user_details('', 'empty_sig')\n            self.assertEqual(result, {'name': 'Empty'})\n\n    def test_integer_identifier(self):\n        # Test integer identifier (hashable but not in trusted), expecting None\n        with patch('solution.TRUSTED_USER_PROFILES', {'123': 'valid_sig'}), \\\n             patch('solution.get_profile_from_service') as mock_get_profile:\n            result = access_user_details(123, 'valid_sig')\n            self.assertIsNone(result)\n            mock_get_profile.assert_not_called()\n\n    def test_list_identifier(self):\n        # Test unhashable list identifier, expecting TypeError\n        with patch('solution.TRUSTED_USER_PROFILES', {}), \\\n             patch('solution.get_profile_from_service') as mock_get_profile:\n            with self.assertRaises(TypeError):\n                access_user_details(['user1'], 'sig1')\n\n    def test_none_identifier(self):\n        # Test None as identifier, expecting None\n        with patch('solution.TRUSTED_USER_PROFILES', {'user1': 'valid_sig1'}), \\\n             patch('solution.get_profile_from_service') as mock_get_profile:\n            result = access_user_details(None, 'valid_sig1')\n            self.assertIsNone(result)\n            mock_get_profile.assert_not_called()\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 10, "task_id": "40244d2b"}
{"test": "import unittest\nfrom unittest.mock import patch\n\nclass TestRetrieveUserProfile(unittest.TestCase):\n\n    def test_valid_uid_and_sig(self):\n        # Test valid uid and correct signature returns profile\n        with patch('service_module.TRUSTED_USER_PROFILES', {'user1': 'sig1'}):\n            with patch('service_module.get_profile_from_service') as mock_get:\n                mock_get.return_value = {'name': 'John Doe'}\n                result = retrieve_user_profile('user1', 'sig1')\n                self.assertEqual(result, {'name': 'John Doe'})\n                mock_get.assert_called_once_with('user1')\n\n    def test_valid_uid_wrong_sig(self):\n        # Test valid uid but incorrect signature returns None\n        with patch('service_module.TRUSTED_USER_PROFILES', {'user1': 'sig1'}):\n            result = retrieve_user_profile('user1', 'wrong_sig')\n            self.assertIsNone(result)\n\n    def test_uid_not_in_trusted(self):\n        # Test uid not in trusted profiles returns None\n        with patch('service_module.TRUSTED_USER_PROFILES', {'user1': 'sig1'}):\n            result = retrieve_user_profile('invalid_user', 'any_sig')\n            self.assertIsNone(result)\n\n    def test_connection_error(self):\n        # Test valid signature but ConnectionError returns None\n        with patch('service_module.TRUSTED_USER_PROFILES', {'user1': 'sig1'}):\n            with patch('service_module.get_profile_from_service') as mock_get:\n                mock_get.side_effect = ConnectionError\n                result = retrieve_user_profile('user1', 'sig1')\n                self.assertIsNone(result)\n\n    def test_empty_uid_valid_sig(self):\n        # Test empty uid with correct signature returns profile\n        with patch('service_module.TRUSTED_USER_PROFILES', {'': 'empty_sig'}):\n            with patch('service_module.get_profile_from_service') as mock_get:\n                mock_get.return_value = 'empty_profile'\n                result = retrieve_user_profile('', 'empty_sig')\n                self.assertEqual(result, 'empty_profile')\n                mock_get.assert_called_once_with('')\n\n    def test_empty_uid_invalid_sig(self):\n        # Test empty uid with incorrect signature returns None\n        with patch('service_module.TRUSTED_USER_PROFILES', {'': 'empty_sig'}):\n            result = retrieve_user_profile('', 'wrong_sig')\n            self.assertIsNone(result)\n\n    def test_empty_uid_not_in_trusted(self):\n        # Test empty uid not in trusted profiles returns None\n        with patch('service_module.TRUSTED_USER_PROFILES', {'user1': 'sig1'}):\n            result = retrieve_user_profile('', 'any_sig')\n            self.assertIsNone(result)\n\n    def test_service_returns_none(self):\n        # Test service returns None results in function returning None\n        with patch('service_module.TRUSTED_USER_PROFILES', {'user1': 'sig1'}):\n            with patch('service_module.get_profile_from_service') as mock_get:\n                mock_get.return_value = None\n                result = retrieve_user_profile('user1', 'sig1')\n                self.assertIsNone(result)\n\n    def test_service_returns_non_string(self):\n        # Test service returns non-string profile (e.g., integer)\n        with patch('service_module.TRUSTED_USER_PROFILES', {'user1': 'sig1'}):\n            with patch('service_module.get_profile_from_service') as mock_get:\n                mock_get.return_value = 42\n                result = retrieve_user_profile('user1', 'sig1')\n                self.assertEqual(result, 42)\n\n    def test_empty_signature_valid(self):\n        # Test empty signature matches trusted empty signature\n        with patch('service_module.TRUSTED_USER_PROFILES', {'user1': ''}):\n            with patch('service_module.get_profile_from_service') as mock_get:\n                mock_get.return_value = 'profile'\n                result = retrieve_user_profile('user1', '')\n                self.assertEqual(result, 'profile')\n\n    def test_empty_signature_trusted_non_empty(self):\n        # Test empty signature against non-empty trusted signature\n        with patch('service_module.TRUSTED_USER_PROFILES', {'user1': 'non_empty'}):\n            result = retrieve_user_profile('user1', '')\n            self.assertIsNone(result)\n\n    def test_trusted_signature_none_sig_none(self):\n        # Test None signature matches trusted None signature\n        with patch('service_module.TRUSTED_USER_PROFILES', {'user1': None}):\n            with patch('service_module.get_profile_from_service') as mock_get:\n                mock_get.return_value = 'profile'\n                result = retrieve_user_profile('user1', None)\n                self.assertEqual(result, 'profile')\n\n    def test_trusted_signature_none_sig_string(self):\n        # Test string signature against trusted None signature\n        with patch('service_module.TRUSTED_USER_PROFILES', {'user1': None}):\n            result = retrieve_user_profile('user1', 'some_string')\n            self.assertIsNone(result)\n\n    def test_other_exception_raises(self):\n        # Test non-ConnectionError exception propagates\n        with patch('service_module.TRUSTED_USER_PROFILES', {'user1': 'sig1'}):\n            with patch('service_module.get_profile_from_service') as mock_get:\n                mock_get.side_effect = ValueError('Error')\n                with self.assertRaises(ValueError):\n                    retrieve_user_profile('user1', 'sig1')\n\n    def test_empty_trusted_profiles(self):\n        # Test when TRUSTED_USER_PROFILES is empty\n        with patch('service_module.TRUSTED_USER_PROFILES', {}):\n            result = retrieve_user_profile('user1', 'any_sig')\n            self.assertIsNone(result)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 15, "task_id": "5b8fb3fc"}
{"test": "import unittest\nfrom unittest.mock import patch\n\nclass TestGetUserDetails(unittest.TestCase):\n\n    @patch('__main__.TRUSTED_USER_PROFILES', {'user1': 'signature1'})\n    @patch('__main__.get_profile_from_service')\n    def test_valid_signature_and_service_works(self, mock_get_profile):\n        \"\"\"Test with valid user id and matching signature.\"\"\"\n        mock_get_profile.return_value = {'name': 'Alice'}\n        result = get_user_details('user1', 'signature1')\n        self.assertEqual(result, {'name': 'Alice'})\n\n    @patch('__main__.TRUSTED_USER_PROFILES', {'user1': 'signature1'})\n    @patch('__main__.get_profile_from_service')\n    def test_valid_signature_but_service_fails(self, mock_get_profile):\n        \"\"\"Test valid signature but service raises ConnectionError.\"\"\"\n        mock_get_profile.side_effect = ConnectionError\n        result = get_user_details('user1', 'signature1')\n        self.assertIsNone(result)\n\n    @patch('__main__.TRUSTED_USER_PROFILES', {'user1': 'signature1'})\n    @patch('__main__.get_profile_from_service')\n    def test_invalid_signature(self, mock_get_profile):\n        \"\"\"Test valid user id but signature doesn't match.\"\"\"\n        result = get_user_details('user1', 'wrong_signature')\n        self.assertIsNone(result)\n        mock_get_profile.assert_not_called()\n\n    @patch('__main__.TRUSTED_USER_PROFILES', {'user1': 'signature1'})\n    @patch('__main__.get_profile_from_service')\n    def test_user_not_in_trusted(self, mock_get_profile):\n        \"\"\"Test user id not found in trusted profiles.\"\"\"\n        result = get_user_details('unknown_user', 'signature1')\n        self.assertIsNone(result)\n        mock_get_profile.assert_not_called()\n\n    @patch('__main__.TRUSTED_USER_PROFILES', {'': 'empty_signature'})\n    @patch('__main__.get_profile_from_service')\n    def test_empty_user_id_valid_signature(self, mock_get_profile):\n        \"\"\"Test empty user id with valid signature.\"\"\"\n        mock_get_profile.return_value = {'name': 'Empty User'}\n        result = get_user_details('', 'empty_signature')\n        self.assertEqual(result, {'name': 'Empty User'})\n\n    @patch('__main__.TRUSTED_USER_PROFILES', {'': 'empty_signature'})\n    @patch('__main__.get_profile_from_service')\n    def test_empty_user_id_invalid_signature(self, mock_get_profile):\n        \"\"\"Test empty user id with invalid signature.\"\"\"\n        result = get_user_details('', 'wrong_signature')\n        self.assertIsNone(result)\n\n    @patch('__main__.TRUSTED_USER_PROFILES', {'user1': 'signature1'})\n    @patch('__main__.get_profile_from_service')\n    def test_non_string_user_id_none(self, mock_get_profile):\n        \"\"\"Test None as user id.\"\"\"\n        result = get_user_details(None, 'signature1')\n        self.assertIsNone(result)\n\n    @patch('__main__.TRUSTED_USER_PROFILES', {'user1': 'signature1'})\n    @patch('__main__.get_profile_from_service')\n    def test_non_string_sig_code_none(self, mock_get_profile):\n        \"\"\"Test None as signature.\"\"\"\n        result = get_user_details('user1', None)\n        self.assertIsNone(result)\n\n    @patch('__main__.TRUSTED_USER_PROFILES', {'user1': 'signature1'})\n    @patch('__main__.get_profile_from_service')\n    def test_integer_user_id(self, mock_get_profile):\n        \"\"\"Test integer user id.\"\"\"\n        result = get_user_details(123, 'signature1')\n        self.assertIsNone(result)\n\n    @patch('__main__.TRUSTED_USER_PROFILES', {'user1': '123'})\n    @patch('__main__.get_profile_from_service')\n    def test_integer_sig_code(self, mock_get_profile):\n        \"\"\"Test integer signature.\"\"\"\n        result = get_user_details('user1', 123)\n        self.assertIsNone(result)\n\n    @patch('__main__.get_profile_from_service')\n    def test_very_long_user_id(self, mock_get_profile):\n        \"\"\"Test very long user id with matching signature.\"\"\"\n        long_uid = 'A' * 10000\n        with patch.dict('__main__.TRUSTED_USER_PROFILES', {long_uid: 'long_sig'}):\n            mock_get_profile.return_value = {'name': 'Long User'}\n            result = get_user_details(long_uid, 'long_sig')\n            self.assertEqual(result, {'name': 'Long User'})\n\n    @patch('__main__.get_profile_from_service')\n    def test_very_long_signature(self, mock_get_profile):\n        \"\"\"Test very long signature with matching user id.\"\"\"\n        long_sig = 'B' * 10000\n        with patch.dict('__main__.TRUSTED_USER_PROFILES', {'user1': long_sig}):\n            mock_get_profile.return_value = {'name': 'Long Signature'}\n            result = get_user_details('user1', long_sig)\n            self.assertEqual(result, {'name': 'Long Signature'})\n\n    @patch('__main__.TRUSTED_USER_PROFILES', {'user1': 'signature1'})\n    @patch('__main__.get_profile_from_service')\n    def test_unexpected_exception(self, mock_get_profile):\n        \"\"\"Test service raises unexpected exception (not ConnectionError).\"\"\"\n        mock_get_profile.side_effect = RuntimeError('Unexpected error')\n        with self.assertRaises(RuntimeError):\n            get_user_details('user1', 'signature1')\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 13, "task_id": "0a79ca88"}
{"test": "import unittest\nfrom unittest.mock import patch\n\nclass TestFetchProfileInfo(unittest.TestCase):\n\n    def test_valid_user_and_signature(self):\n        # Test with valid user ID and matching signature\n        with patch('__main__.TRUSTED_USER_PROFILES', {'user1': 'valid_sig1'}), \\\n             patch('__main__.get_profile_from_service') as mock_get:\n            mock_get.return_value = {'name': 'Alice', 'email': 'alice@example.com'}\n            result = fetch_profile_info('user1', 'valid_sig1')\n            self.assertEqual(result, {'name': 'Alice', 'email': 'alice@example.com'})\n            mock_get.assert_called_once_with('user1')\n\n    def test_valid_user_wrong_signature(self):\n        # Test with valid user ID but incorrect signature\n        with patch('__main__.TRUSTED_USER_PROFILES', {'user1': 'valid_sig1'}), \\\n             patch('__main__.get_profile_from_service') as mock_get:\n            result = fetch_profile_info('user1', 'wrong_sig')\n            self.assertIsNone(result)\n            mock_get.assert_not_called()\n\n    def test_user_not_in_trusted(self):\n        # Test with user ID not in trusted profiles\n        with patch('__main__.TRUSTED_USER_PROFILES', {'user1': 'valid_sig1'}), \\\n             patch('__main__.get_profile_from_service') as mock_get:\n            result = fetch_profile_info('user2', 'any_sig')\n            self.assertIsNone(result)\n            mock_get.assert_not_called()\n\n    def test_connection_error(self):\n        # Test valid credentials but service connection error\n        with patch('__main__.TRUSTED_USER_PROFILES', {'user1': 'valid_sig1'}), \\\n             patch('__main__.get_profile_from_service') as mock_get:\n            mock_get.side_effect = ConnectionError\n            result = fetch_profile_info('user1', 'valid_sig1')\n            self.assertIsNone(result)\n            mock_get.assert_called_once_with('user1')\n\n    def test_empty_user_valid(self):\n        # Test empty user ID present in trusted profiles with matching signature\n        with patch('__main__.TRUSTED_USER_PROFILES', {'': 'empty_sig'}), \\\n             patch('__main__.get_profile_from_service') as mock_get:\n            mock_get.return_value = {'name': 'EmptyUser'}\n            result = fetch_profile_info('', 'empty_sig')\n            self.assertEqual(result, {'name': 'EmptyUser'})\n            mock_get.assert_called_once_with('')\n\n    def test_empty_user_wrong_signature(self):\n        # Test empty user ID present but with incorrect signature\n        with patch('__main__.TRUSTED_USER_PROFILES', {'': 'empty_sig'}), \\\n             patch('__main__.get_profile_from_service') as mock_get:\n            result = fetch_profile_info('', 'wrong_sig')\n            self.assertIsNone(result)\n            mock_get.assert_not_called()\n\n    def test_empty_user_not_in_trusted(self):\n        # Test empty user ID not in trusted profiles\n        with patch('__main__.TRUSTED_USER_PROFILES', {'user1': 'valid_sig1'}), \\\n             patch('__main__.get_profile_from_service') as mock_get:\n            result = fetch_profile_info('', 'any_sig')\n            self.assertIsNone(result)\n            mock_get.assert_not_called()\n\n    def test_empty_trusted_dict(self):\n        # Test when trusted profiles is empty\n        with patch('__main__.TRUSTED_USER_PROFILES', {}), \\\n             patch('__main__.get_profile_from_service') as mock_get:\n            result = fetch_profile_info('user1', 'any_sig')\n            self.assertIsNone(result)\n            mock_get.assert_not_called()", "num_test_cases": 8, "task_id": "8e263fca"}
{"test": "import unittest\nfrom unittest.mock import patch\n\nclass TestAuthenticateMessage(unittest.TestCase):\n\n    def test_case_1(self):\n        # Happy path: Valid message_id and matching signature\n        with patch('__main__.VALID_API_MESSAGES', {'msg1': 'sig1'}):\n            result = authenticate_message('msg1', 'sig1')\n            self.assertTrue(result)\n\n    def test_case_2(self):\n        # Happy path: Valid message_id but signature mismatch\n        with patch('__main__.VALID_API_MESSAGES', {'msg1': 'sig1'}):\n            result = authenticate_message('msg1', 'wrong_sig')\n            self.assertFalse(result)\n\n    def test_case_3(self):\n        # Edge: Message_id not found in dictionary\n        with patch('__main__.VALID_API_MESSAGES', {'msg1': 'sig1'}):\n            result = authenticate_message('non_existent', 'sig1')\n            self.assertFalse(result)\n\n    def test_case_4(self):\n        # Edge: Empty message_id found and signature matches\n        with patch('__main__.VALID_API_MESSAGES', {'': 'empty_sig'}):\n            result = authenticate_message('', 'empty_sig')\n            self.assertTrue(result)\n\n    def test_case_5(self):\n        # Edge: Empty message_id found but signature mismatch\n        with patch('__main__.VALID_API_MESSAGES', {'': 'empty_sig'}):\n            result = authenticate_message('', 'wrong')\n            self.assertFalse(result)\n\n    def test_case_6(self):\n        # Edge: Empty message_id not found\n        with patch('__main__.VALID_API_MESSAGES', {'key': 'value'}):\n            result = authenticate_message('', 'anything')\n            self.assertFalse(result)\n\n    def test_case_7(self):\n        # Edge: Very long message_id and matching signature\n        long_msg = 'A' * 1000\n        long_sig = 'B' * 1000\n        with patch('__main__.VALID_API_MESSAGES', {long_msg: long_sig}):\n            result = authenticate_message(long_msg, long_sig)\n            self.assertTrue(result)\n\n    def test_case_8(self):\n        # Edge: Very long message_id but signature mismatch\n        long_msg = 'A' * 1000\n        long_sig = 'B' * 1000\n        with patch('__main__.VALID_API_MESSAGES', {long_msg: long_sig}):\n            result = authenticate_message(long_msg, long_sig + 'x')\n            self.assertFalse(result)\n\n    def test_case_9(self):\n        # Edge: Very long message_id not found\n        long_msg = 'A' * 1000\n        with patch('__main__.VALID_API_MESSAGES', {'other': 'value'}):\n            result = authenticate_message(long_msg, 'anything')\n            self.assertFalse(result)\n\n    def test_case_10(self):\n        # Flaky dictionary: KeyError during access returns False\n        class FlakyDict(dict):\n            def __getitem__(self, key):\n                if key == 'flaky':\n                    raise KeyError\n                return super().__getitem__(key)\n        d = FlakyDict({'flaky': 'sig'})\n        with patch('__main__.VALID_API_MESSAGES', d):\n            result = authenticate_message('flaky', 'sig')\n            self.assertFalse(result)\n\n    def test_case_11(self):\n        # None message_id found and signature matches\n        with patch('__main__.VALID_API_MESSAGES', {None: 'some_sig'}):\n            result = authenticate_message(None, 'some_sig')\n            self.assertTrue(result)\n\n    def test_case_12(self):\n        # None message_id found but signature mismatch\n        with patch('__main__.VALID_API_MESSAGES', {None: 'some_sig'}):\n            result = authenticate_message(None, 'wrong_sig')\n            self.assertFalse(result)\n\n    def test_case_13(self):\n        # None message_id not found\n        with patch('__main__.VALID_API_MESSAGES', {'key': 'value'}):\n            result = authenticate_message(None, 'value')\n            self.assertFalse(result)\n\n    def test_case_14(self):\n        # Integer message_id found and signature matches\n        with patch('__main__.VALID_API_MESSAGES', {123: 'sig123'}):\n            result = authenticate_message(123, 'sig123')\n            self.assertTrue(result)\n\n    def test_case_15(self):\n        # Integer message_id found but signature mismatch\n        with patch('__main__.VALID_API_MESSAGES', {123: 'sig123'}):\n            result = authenticate_message(123, 'wrong')\n            self.assertFalse(result)\n\n    def test_case_16(self):\n        # Integer message_id not found\n        with patch('__main__.VALID_API_MESSAGES', {'key': 'value'}):\n            result = authenticate_message(123, 'value')\n            self.assertFalse(result)\n\n    def test_case_17(self):\n        # Very long signature matches\n        long_sig = 'X' * 10000\n        with patch('__main__.VALID_API_MESSAGES', {'msg': long_sig}):\n            result = authenticate_message('msg', long_sig)\n            self.assertTrue(result)\n\n    def test_case_18(self):\n        # Very long signature mismatch\n        long_sig = 'X' * 10000\n        with patch('__main__.VALID_API_MESSAGES', {'msg': long_sig}):\n            altered_sig = long_sig[:-1] + 'Y'\n            result = authenticate_message('msg', altered_sig)\n            self.assertFalse(result)\n\n    def test_case_19(self):\n        # Empty signature matches\n        with patch('__main__.VALID_API_MESSAGES', {'key': ''}):\n            result = authenticate_message('key', '')\n            self.assertTrue(result)\n\n    def test_case_20(self):\n        # Empty signature mismatch\n        with patch('__main__.VALID_API_MESSAGES', {'key': ''}):\n            result = authenticate_message('key', ' ')\n            self.assertFalse(result)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 20, "task_id": "61bd7625"}
{"test": "import unittest\nfrom unittest.mock import patch\nfrom solution import handle_data_packet\n\nclass TestHandleDataPacket(unittest.TestCase):\n\n    # Test with valid device_id and signature\n    @patch('solution.TRUSTED_DEVICE_SIGNATURES', {'dev1': 'sig1'})\n    @patch('solution.receive_data_packet', return_value={'temperature': 25})\n    def test_valid_device_and_signature(self, mock_receive):\n        result = handle_data_packet('dev1', 'sig1', {})\n        self.assertEqual(result, {'temperature': 25})\n\n    # Test with device_id not in TRUSTED_DEVICE_SIGNATURES\n    @patch('solution.TRUSTED_DEVICE_SIGNATURES', {'dev1': 'sig1'})\n    def test_device_id_not_found(self):\n        result = handle_data_packet('unknown', 'any_sig', {})\n        self.assertIsNone(result)\n\n    # Test with mismatched signature\n    @patch('solution.TRUSTED_DEVICE_SIGNATURES', {'dev1': 'sig1'})\n    def test_signature_mismatch(self):\n        result = handle_data_packet('dev1', 'wrong_sig', {})\n        self.assertIsNone(result)\n\n    # Test with empty device_id not in trusted signatures\n    @patch('solution.TRUSTED_DEVICE_SIGNATURES', {'dev1': 'sig1'})\n    def test_empty_device_id_invalid(self):\n        result = handle_data_packet('', 'any_sig', {})\n        self.assertIsNone(result)\n\n    # Test with empty device_id in trusted signatures\n    @patch('solution.TRUSTED_DEVICE_SIGNATURES', {'': 'empty_sig'})\n    @patch('solution.receive_data_packet', return_value={'status': 'ok'})\n    def test_empty_device_id_valid(self, mock_receive):\n        result = handle_data_packet('', 'empty_sig', {})\n        self.assertEqual(result, {'status': 'ok'})\n\n    # Test with empty signature but trusted signature is non-empty\n    @patch('solution.TRUSTED_DEVICE_SIGNATURES', {'dev1': 'non_empty'})\n    def test_empty_signature_invalid(self):\n        result = handle_data_packet('dev1', '', {})\n        self.assertIsNone(result)\n\n    # Test with empty signature matching trusted empty signature\n    @patch('solution.TRUSTED_DEVICE_SIGNATURES', {'dev1': ''})\n    @patch('solution.receive_data_packet', return_value={'data': 123})\n    def test_empty_signature_valid(self, mock_receive):\n        result = handle_data_packet('dev1', '', {})\n        self.assertEqual(result, {'data': 123})\n\n    # Test with ConnectionError during packet reception\n    @patch('solution.TRUSTED_DEVICE_SIGNATURES', {'dev1': 'sig1'})\n    @patch('solution.receive_data_packet', side_effect=ConnectionError)\n    def test_connection_error(self, mock_receive):\n        result = handle_data_packet('dev1', 'sig1', {})\n        self.assertIsNone(result)\n\n    # Test with very long device_id and signature\n    def test_long_device_id_and_signature(self):\n        long_id = 'a' * 10000\n        long_sig = 'b' * 10000\n        with patch('solution.TRUSTED_DEVICE_SIGNATURES', {long_id: long_sig}):\n            with patch('solution.receive_data_packet', return_value={'result': 'success'}):\n                result = handle_data_packet(long_id, long_sig, {})\n                self.assertEqual(result, {'result': 'success'})\n\n    # Test with None device_id\n    @patch('solution.TRUSTED_DEVICE_SIGNATURES', {'dev1': 'sig1'})\n    def test_none_device_id(self):\n        result = handle_data_packet(None, 'sig1', {})\n        self.assertIsNone(result)\n\n    # Test with None signature\n    @patch('solution.TRUSTED_DEVICE_SIGNATURES', {'dev1': 'sig1'})\n    def test_none_signature(self):\n        result = handle_data_packet('dev1', None, {})\n        self.assertIsNone(result)\n\n    # Test with non-dict data\n    @patch('solution.TRUSTED_DEVICE_SIGNATURES', {'dev1': 'sig1'})\n    @patch('solution.receive_data_packet', return_value={'info': 'processed'})\n    def test_non_dict_data(self, mock_receive):\n        result = handle_data_packet('dev1', 'sig1', 'not_a_dict')\n        self.assertEqual(result, {'info': 'processed'})", "num_test_cases": 12, "task_id": "daf4d0af"}
{"test": "import unittest\nfrom unittest.mock import patch\n\nclass TestProcessConfigData(unittest.TestCase):\n\n    @patch('__main__.TRUSTED_CONFIG_SIGNATURES', {'config1': 'sig1'})\n    @patch('__main__.fetch_config_data')\n    def test_case_1(self, mock_fetch):\n        # Test valid config_name and matching signature returns config data\n        mock_fetch.return_value = {'key': 'value'}\n        result = process_config_data('config1', 'sig1')\n        self.assertEqual(result, {'key': 'value'})\n\n    @patch('__main__.TRUSTED_CONFIG_SIGNATURES', {'config1': 'sig1'})\n    @patch('__main__.fetch_config_data')\n    def test_case_2(self, mock_fetch):\n        # Test valid config_name but mismatched signature returns None\n        mock_fetch.return_value = {'key': 'value'}\n        result = process_config_data('config1', 'wrong_sig')\n        self.assertIsNone(result)\n\n    @patch('__main__.TRUSTED_CONFIG_SIGNATURES', {'config1': 'sig1'})\n    @patch('__main__.fetch_config_data')\n    def test_case_3(self, mock_fetch):\n        # Test config_name not in TRUSTED_CONFIG_SIGNATURES returns None\n        mock_fetch.return_value = {'key': 'value'}\n        result = process_config_data('invalid_config', 'sig1')\n        self.assertIsNone(result)\n\n    @patch('__main__.TRUSTED_CONFIG_SIGNATURES', {'config1': 'sig1'})\n    @patch('__main__.fetch_config_data')\n    def test_case_4(self, mock_fetch):\n        # Test valid signature but fetch_config_data raises IOError returns None\n        mock_fetch.side_effect = IOError\n        result = process_config_data('config1', 'sig1')\n        self.assertIsNone(result)\n\n    @patch('__main__.TRUSTED_CONFIG_SIGNATURES', {'config1': 'sig1'})\n    def test_case_5(self):\n        # Test unhashable config_name (list) raises TypeError\n        with self.assertRaises(TypeError):\n            process_config_data([1, 2, 3], 'sig1')\n\n    @patch('__main__.TRUSTED_CONFIG_SIGNATURES', {'config1': 'sig1'})\n    def test_case_6(self):\n        # Test hashable non-string config_name (int) returns None (not found)\n        result = process_config_data(123, 'sig1')\n        self.assertIsNone(result)\n\n    @patch('__main__.TRUSTED_CONFIG_SIGNATURES', {'config1': 'sig1'})\n    def test_case_7(self):\n        # Test non-string signature (int) returns None (mismatch)\n        result = process_config_data('config1', 123)\n        self.assertIsNone(result)\n\n    @patch('__main__.TRUSTED_CONFIG_SIGNATURES', {'': 'empty_sig'})\n    @patch('__main__.fetch_config_data')\n    def test_case_8(self, mock_fetch):\n        # Test empty config_name with matching signature returns config data\n        mock_fetch.return_value = {'key': 'value'}\n        result = process_config_data('', 'empty_sig')\n        self.assertEqual(result, {'key': 'value'})\n\n    @patch('__main__.TRUSTED_CONFIG_SIGNATURES', {'config1': 'sig1'})\n    def test_case_9(self):\n        # Test empty config_name not in trusted signatures returns None\n        result = process_config_data('', 'sig1')\n        self.assertIsNone(result)\n\n    @patch('__main__.TRUSTED_CONFIG_SIGNATURES', {'config1': ''})\n    @patch('__main__.fetch_config_data')\n    def test_case_10(self, mock_fetch):\n        # Test empty signature with matching trusted empty signature returns config data\n        mock_fetch.return_value = {'key': 'value'}\n        result = process_config_data('config1', '')\n        self.assertEqual(result, {'key': 'value'})\n\n    @patch('__main__.TRUSTED_CONFIG_SIGNATURES', {'config1': ''})\n    def test_case_11(self):\n        # Test non-empty signature with trusted empty signature returns None\n        result = process_config_data('config1', 'non-empty')\n        self.assertIsNone(result)\n\n    @patch('__main__.TRUSTED_CONFIG_SIGNATURES', {'config1': 'non-empty'})\n    def test_case_12(self):\n        # Test empty signature with trusted non-empty signature returns None\n        result = process_config_data('config1', '')\n        self.assertIsNone(result)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 12, "task_id": "cade7b1a"}
{"test": "import unittest\nfrom unittest.mock import patch\nfrom solution import verify_document\n\nclass TestVerifyDocument(unittest.TestCase):\n\n    @patch('solution.get_document_content')\n    @patch('solution.DOCUMENT_SIGNATURES', {'valid_url': 'valid_signature', '': ''})\n    def test_case_1(self, mock_get_document_content):\n        # Test valid signature and document accessible\n        mock_get_document_content.return_value = 'some content'\n        result = verify_document('valid_url', 'valid_signature')\n        self.assertTrue(result)\n        mock_get_document_content.assert_called_once_with('valid_url')\n\n    @patch('solution.get_document_content')\n    @patch('solution.DOCUMENT_SIGNATURES', {'valid_url': 'valid_signature', '': ''})\n    def test_case_2(self, mock_get_document_content):\n        # Test valid signature but document not accessible\n        mock_get_document_content.side_effect = IOError\n        result = verify_document('valid_url', 'valid_signature')\n        self.assertFalse(result)\n        mock_get_document_content.assert_called_once_with('valid_url')\n\n    @patch('solution.get_document_content')\n    @patch('solution.DOCUMENT_SIGNATURES', {'valid_url': 'valid_signature', '': ''})\n    def test_case_3(self, mock_get_document_content):\n        # Test invalid signature (url exists but signature mismatch)\n        mock_get_document_content.return_value = 'some content'\n        result = verify_document('valid_url', 'invalid_signature')\n        self.assertFalse(result)\n        mock_get_document_content.assert_not_called()\n\n    @patch('solution.get_document_content')\n    @patch('solution.DOCUMENT_SIGNATURES', {'valid_url': 'valid_signature', '': ''})\n    def test_case_4(self, mock_get_document_content):\n        # Test url not in DOCUMENT_SIGNATURES\n        mock_get_document_content.return_value = 'some content'\n        result = verify_document('non_existent_url', 'any_signature')\n        self.assertFalse(result)\n        mock_get_document_content.assert_not_called()\n\n    @patch('solution.get_document_content')\n    @patch('solution.DOCUMENT_SIGNATURES', {'valid_url': 'valid_signature', '': ''})\n    def test_case_5(self, mock_get_document_content):\n        # Test empty signature when expected is non-empty\n        result = verify_document('valid_url', '')\n        self.assertFalse(result)\n        mock_get_document_content.assert_not_called()\n\n    @patch('solution.get_document_content')\n    @patch('solution.DOCUMENT_SIGNATURES', {'valid_url': 'valid_signature', '': ''})\n    def test_case_6(self, mock_get_document_content):\n        # Test empty signature when expected is empty (document accessible)\n        mock_get_document_content.return_value = 'some content'\n        result = verify_document('', '')\n        self.assertTrue(result)\n        mock_get_document_content.assert_called_once_with('')\n\n    @patch('solution.get_document_content')\n    @patch('solution.DOCUMENT_SIGNATURES', {'valid_url': 'valid_signature', '': ''})\n    def test_case_7(self, mock_get_document_content):\n        # Test empty signature when expected is empty (document not accessible)\n        mock_get_document_content.side_effect = IOError\n        result = verify_document('', '')\n        self.assertFalse(result)\n        mock_get_document_content.assert_called_once_with('')\n\n    @patch('solution.get_document_content')\n    @patch('solution.DOCUMENT_SIGNATURES', {'valid_url': 'valid_signature', '': ''})\n    def test_case_8(self, mock_get_document_content):\n        # Test None as signature\n        result = verify_document('valid_url', None)\n        self.assertFalse(result)\n        mock_get_document_content.assert_not_called()\n\n    @patch('solution.get_document_content')\n    @patch('solution.DOCUMENT_SIGNATURES', {'valid_url': 'valid_signature', '': ''})\n    def test_case_9(self, mock_get_document_content):\n        # Test None as doc_url\n        result = verify_document(None, 'valid_signature')\n        self.assertFalse(result)\n        mock_get_document_content.assert_not_called()\n\n    @patch('solution.get_document_content')\n    def test_case_10(self, mock_get_document_content):\n        # Test empty doc_url not in DOCUMENT_SIGNATURES\n        with patch.dict('solution.DOCUMENT_SIGNATURES', {'valid_url': 'valid_signature'}, clear=True):\n            result = verify_document('', 'any_signature')\n            self.assertFalse(result)\n            mock_get_document_content.assert_not_called()\n\n    @patch('solution.get_document_content')\n    @patch('solution.DOCUMENT_SIGNATURES', {'valid_url': 'valid_signature'})\n    def test_case_11(self, mock_get_document_content):\n        # Test non-string (integer) doc_url\n        result = verify_document(123, 'valid_signature')\n        self.assertFalse(result)\n        mock_get_document_content.assert_not_called()\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 11, "task_id": "b863eb34"}
{"test": "import unittest\nfrom unittest.mock import patch, MagicMock\nfrom solution import fetch_user_profile\n\nclass TestFetchUserProfile(unittest.TestCase):\n\n    def test_happy_path_valid_user_and_signature(self):\n        # Test with valid user_id and matching signature\n        with patch('solution.TRUSTED_USER_PROFILES', {'user1': 'valid_sig'}):\n            mock_profile = {'name': 'John Doe'}\n            with patch('solution.get_profile_from_service', return_value=mock_profile) as mock_get:\n                result = fetch_user_profile('user1', 'valid_sig')\n                self.assertEqual(result, mock_profile)\n                mock_get.assert_called_once_with('user1')\n\n    def test_valid_user_but_invalid_signature(self):\n        # Test with valid user_id but mismatched signature\n        with patch('solution.TRUSTED_USER_PROFILES', {'user1': 'valid_sig'}):\n            with patch('solution.get_profile_from_service') as mock_get:\n                result = fetch_user_profile('user1', 'invalid_sig')\n                self.assertIsNone(result)\n                mock_get.assert_not_called()\n\n    def test_user_not_in_trusted_list(self):\n        # Test with user_id not present in TRUSTED_USER_PROFILES\n        with patch('solution.TRUSTED_USER_PROFILES', {'user1': 'valid_sig'}):\n            with patch('solution.get_profile_from_service') as mock_get:\n                result = fetch_user_profile('unknown_user', 'any_sig')\n                self.assertIsNone(result)\n                mock_get.assert_not_called()\n\n    def test_connection_error_during_fetch(self):\n        # Test valid user/signature but service raises ConnectionError\n        with patch('solution.TRUSTED_USER_PROFILES', {'user1': 'valid_sig'}):\n            with patch('solution.get_profile_from_service', side_effect=ConnectionError) as mock_get:\n                result = fetch_user_profile('user1', 'valid_sig')\n                self.assertIsNone(result)\n                mock_get.assert_called_once_with('user1')\n\n    def test_empty_user_id_valid_in_trusted(self):\n        # Test empty user_id present in TRUSTED_USER_PROFILES with matching signature\n        with patch('solution.TRUSTED_USER_PROFILES', {'': 'empty_sig'}):\n            mock_profile = {'name': 'Empty User'}\n            with patch('solution.get_profile_from_service', return_value=mock_profile) as mock_get:\n                result = fetch_user_profile('', 'empty_sig')\n                self.assertEqual(result, mock_profile)\n                mock_get.assert_called_once_with('')\n\n    def test_empty_user_id_not_in_trusted(self):\n        # Test empty user_id not in TRUSTED_USER_PROFILES\n        with patch('solution.TRUSTED_USER_PROFILES', {'user1': 'valid_sig'}):\n            with patch('solution.get_profile_from_service') as mock_get:\n                result = fetch_user_profile('', 'any_sig')\n                self.assertIsNone(result)\n                mock_get.assert_not_called()\n\n    def test_empty_signature_with_trusted_empty(self):\n        # Test empty signature when TRUSTED_USER_PROFILES has empty signature\n        with patch('solution.TRUSTED_USER_PROFILES', {'user1': ''}):\n            mock_profile = {'name': 'Empty Signature'}\n            with patch('solution.get_profile_from_service', return_value=mock_profile) as mock_get:\n                result = fetch_user_profile('user1', '')\n                self.assertEqual(result, mock_profile)\n                mock_get.assert_called_once_with('user1')\n\n    def test_empty_signature_with_trusted_non_empty(self):\n        # Test empty signature when TRUSTED_USER_PROFILES has non-empty signature\n        with patch('solution.TRUSTED_USER_PROFILES', {'user1': 'non_empty'}):\n            with patch('solution.get_profile_from_service') as mock_get:\n                result = fetch_user_profile('user1', '')\n                self.assertIsNone(result)\n                mock_get.assert_not_called()\n", "num_test_cases": 8, "task_id": "c364946e"}
{"test": "import unittest\nimport tempfile\nfrom unittest.mock import patch\n\n# Mock the global VALID_SIGNATURES dictionary\nclass TestLoadFile(unittest.TestCase):\n    def setUp(self):\n        # Reset the VALID_SIGNATURES dictionary before each test\n        global VALID_SIGNATURES\n        VALID_SIGNATURES = {}\n        \n    def test_valid_file_and_signature(self):\n        \"\"\"Test with valid file and matching signature\"\"\"\n        with tempfile.NamedTemporaryFile(mode='w', delete=True) as tmp:\n            tmp.write(\"content\")\n            tmp.flush()\n            file_name = tmp.name\n            VALID_SIGNATURES[file_name] = \"valid_sig\"\n            result = load_file(file_name, \"valid_sig\")\n            self.assertEqual(result, 1)\n    \n    def test_invalid_signature(self):\n        \"\"\"Test valid file but invalid signature\"\"\"\n        file_name = \"test_file.txt\"\n        VALID_SIGNATURES[file_name] = \"valid_sig\"\n        result = load_file(file_name, \"invalid_sig\")\n        self.assertEqual(result, 0)\n    \n    def test_file_not_in_valid_signatures(self):\n        \"\"\"Test file not present in VALID_SIGNATURES\"\"\"\n        file_name = \"unknown_file.txt\"\n        VALID_SIGNATURES[\"other_file.txt\"] = \"some_sig\"\n        result = load_file(file_name, \"any_sig\")\n        self.assertEqual(result, 0)\n    \n    def test_nonexistent_file(self):\n        \"\"\"Test non-existent file with valid signature\"\"\"\n        file_name = \"non_existent.txt\"\n        VALID_SIGNATURES[file_name] = \"valid_sig\"\n        result = load_file(file_name, \"valid_sig\")\n        self.assertEqual(result, 0)\n    \n    def test_permission_error(self):\n        \"\"\"Test valid file/signature but permission error on open\"\"\"\n        file_name = \"restricted_file.txt\"\n        VALID_SIGNATURES[file_name] = \"valid_sig\"\n        with patch('builtins.open', side_effect=PermissionError(\"Permission denied\")):\n            result = load_file(file_name, \"valid_sig\")\n            self.assertEqual(result, 0)\n    \n    def test_non_string_filename(self):\n        \"\"\"Test non-string filename argument\"\"\"\n        VALID_SIGNATURES[\"file.txt\"] = \"sig\"\n        result = load_file(123, \"sig\")\n        self.assertEqual(result, 0)\n    \n    def test_non_string_signature(self):\n        \"\"\"Test non-string signature argument\"\"\"\n        VALID_SIGNATURES[\"file.txt\"] = \"sig\"\n        result = load_file(\"file.txt\", 456)\n        self.assertEqual(result, 0)\n    \n    def test_none_filename(self):\n        \"\"\"Test None as filename\"\"\"\n        VALID_SIGNATURES[\"file.txt\"] = \"sig\"\n        result = load_file(None, \"sig\")\n        self.assertEqual(result, 0)\n    \n    def test_none_signature(self):\n        \"\"\"Test None as signature\"\"\"\n        VALID_SIGNATURES[\"file.txt\"] = \"sig\"\n        result = load_file(\"file.txt\", None)\n        self.assertEqual(result, 0)\n    \n    def test_empty_filename_valid_sig(self):\n        \"\"\"Test empty filename with matching signature\"\"\"\n        VALID_SIGNATURES[\"\"] = \"valid_sig\"\n        result = load_file(\"\", \"valid_sig\")\n        self.assertEqual(result, 0)\n    \n    def test_empty_filename_invalid_sig(self):\n        \"\"\"Test empty filename with invalid signature\"\"\"\n        VALID_SIGNATURES[\"\"] = \"valid_sig\"\n        result = load_file(\"\", \"invalid_sig\")\n        self.assertEqual(result, 0)\n    \n    def test_empty_filename_not_in_valid_signatures(self):\n        \"\"\"Test empty filename not in VALID_SIGNATURES\"\"\"\n        VALID_SIGNATURES[\"file.txt\"] = \"sig\"\n        result = load_file(\"\", \"any_sig\")\n        self.assertEqual(result, 0)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 13, "task_id": "e97db310"}
{"test": "import unittest\nimport copy\n\n# Global variables required for the function\nVALID_CSRF_TOKEN = \"valid_token\"\nuser_database = {\n    \"users\": {\n        \"1\": {\"email\": \"user1@example.com\"},\n        \"2\": {\"email\": \"user2@example.com\"}\n    }\n}\n\nclass TestChangeUserEmail(unittest.TestCase):\n    def setUp(self):\n        \"\"\"Save original state of global variables to restore after each test.\"\"\"\n        global VALID_CSRF_TOKEN, user_database\n        self.orig_token = VALID_CSRF_TOKEN\n        self.orig_db = copy.deepcopy(user_database)\n    \n    def tearDown(self):\n        \"\"\"Restore the original state of global variables.\"\"\"\n        global VALID_CSRF_TOKEN, user_database\n        VALID_CSRF_TOKEN = self.orig_token\n        user_database = copy.deepcopy(self.orig_db)\n\n    def test_valid_request(self):\n        \"\"\"Test updating email for an existing user with valid CSRF token.\"\"\"\n        global user_database\n        request = {\n            \"headers\": {\"X-CSRF-Token\": \"valid_token\"},\n            \"body\": {\"user_id\": \"1\", \"new_email\": \"new1@example.com\"}\n        }\n        result = change_user_email(request)\n        self.assertTrue(result)\n        self.assertEqual(user_database[\"users\"][\"1\"][\"email\"], \"new1@example.com\")\n\n    def test_user_not_found(self):\n        \"\"\"Test updating email for a user that does not exist.\"\"\"\n        request = {\n            \"headers\": {\"X-CSRF-Token\": \"valid_token\"},\n            \"body\": {\"user_id\": \"3\", \"new_email\": \"new@example.com\"}\n        }\n        self.assertFalse(change_user_email(request))\n\n    def test_missing_csrf_token(self):\n        \"\"\"Test when the headers do not contain X-CSRF-Token.\"\"\"\n        request = {\n            \"headers\": {},\n            \"body\": {\"user_id\": \"1\", \"new_email\": \"new@example.com\"}\n        }\n        self.assertFalse(change_user_email(request))\n\n    def test_invalid_csrf_token(self):\n        \"\"\"Test with an invalid CSRF token.\"\"\"\n        request = {\n            \"headers\": {\"X-CSRF-Token\": \"invalid_token\"},\n            \"body\": {\"user_id\": \"1\", \"new_email\": \"new@example.com\"}\n        }\n        self.assertFalse(change_user_email(request))\n\n    def test_empty_user_id(self):\n        \"\"\"Test with empty user_id (which is not in the database).\"\"\"\n        request = {\n            \"headers\": {\"X-CSRF-Token\": \"valid_token\"},\n            \"body\": {\"user_id\": \"\", \"new_email\": \"new@example.com\"}\n        }\n        self.assertFalse(change_user_email(request))\n\n    def test_empty_email(self):\n        \"\"\"Test updating to an empty email for an existing user.\"\"\"\n        request = {\n            \"headers\": {\"X-CSRF-Token\": \"valid_token\"},\n            \"body\": {\"user_id\": \"1\", \"new_email\": \"\"}\n        }\n        self.assertTrue(change_user_email(request))\n        self.assertEqual(user_database[\"users\"][\"1\"][\"email\"], \"\")\n\n    def test_long_email(self):\n        \"\"\"Test updating to a very long email.\"\"\"\n        long_email = \"a\" * 1000 + \"@example.com\"\n        request = {\n            \"headers\": {\"X-CSRF-Token\": \"valid_token\"},\n            \"body\": {\"user_id\": \"1\", \"new_email\": long_email}\n        }\n        self.assertTrue(change_user_email(request))\n        self.assertEqual(user_database[\"users\"][\"1\"][\"email\"], long_email)\n\n    def test_missing_headers(self):\n        \"\"\"Test when the request is missing the 'headers' key.\"\"\"\n        request = {\n            \"body\": {\"user_id\": \"1\", \"new_email\": \"new@example.com\"}\n        }\n        with self.assertRaises(KeyError):\n            change_user_email(request)\n\n    def test_missing_body(self):\n        \"\"\"Test when the request is missing the 'body' key.\"\"\"\n        request = {\n            \"headers\": {\"X-CSRF-Token\": \"valid_token\"}\n        }\n        with self.assertRaises(KeyError):\n            change_user_email(request)\n\n    def test_missing_user_id(self):\n        \"\"\"Test when the body is missing the 'user_id' key.\"\"\"\n        request = {\n            \"headers\": {\"X-CSRF-Token\": \"valid_token\"},\n            \"body\": {\"new_email\": \"new@example.com\"}\n        }\n        with self.assertRaises(KeyError):\n            change_user_email(request)\n\n    def test_missing_new_email(self):\n        \"\"\"Test when the body is missing the 'new_email' key.\"\"\"\n        request = {\n            \"headers\": {\"X-CSRF-Token\": \"valid_token\"},\n            \"body\": {\"user_id\": \"1\"}\n        }\n        with self.assertRaises(KeyError):\n            change_user_email(request)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 11, "task_id": "496d9c28"}
{"test": "import unittest\n\n# Global variables for the function\nemail_database = None\nEXPECTED_CSRF_TOKEN = None\n\nclass TestModifyUserEmailAddress(unittest.TestCase):\n    def setUp(self):\n        global email_database, EXPECTED_CSRF_TOKEN\n        email_database = {\n            \"users\": {\n                \"1\": {\"email\": \"user1@example.com\"},\n                \"2\": {\"email\": \"user2@example.com\"}\n            }\n        }\n        EXPECTED_CSRF_TOKEN = \"valid_csrf_token\"\n\n    def test_valid_request_existing_user(self):\n        # Test updating existing user with valid CSRF token\n        user_request = {\n            \"headers\": {\"X-CSRF-Token\": \"valid_csrf_token\"},\n            \"body\": {\"user_id\": \"1\", \"new_email\": \"new_email@example.com\"}\n        }\n        result = modify_user_email_address(user_request)\n        self.assertTrue(result)\n        self.assertEqual(email_database[\"users\"][\"1\"][\"email\"], \"new_email@example.com\")\n\n    def test_valid_request_non_existing_user(self):\n        # Test updating non-existing user with valid CSRF token\n        user_request = {\n            \"headers\": {\"X-CSRF-Token\": \"valid_csrf_token\"},\n            \"body\": {\"user_id\": \"3\", \"new_email\": \"new_email@example.com\"}\n        }\n        result = modify_user_email_address(user_request)\n        self.assertFalse(result)\n        self.assertEqual(email_database[\"users\"][\"1\"][\"email\"], \"user1@example.com\")\n        self.assertEqual(email_database[\"users\"][\"2\"][\"email\"], \"user2@example.com\")\n\n    def test_missing_csrf_token(self):\n        # Test missing CSRF token in headers\n        user_request = {\n            \"headers\": {},\n            \"body\": {\"user_id\": \"1\", \"new_email\": \"new_email@example.com\"}\n        }\n        result = modify_user_email_address(user_request)\n        self.assertFalse(result)\n\n    def test_incorrect_csrf_token(self):\n        # Test incorrect CSRF token\n        user_request = {\n            \"headers\": {\"X-CSRF-Token\": \"invalid_token\"},\n            \"body\": {\"user_id\": \"1\", \"new_email\": \"new_email@example.com\"}\n        }\n        result = modify_user_email_address(user_request)\n        self.assertFalse(result)\n\n    def test_missing_headers(self):\n        # Test missing 'headers' key in request\n        user_request = {\n            \"body\": {\"user_id\": \"1\", \"new_email\": \"new_email@example.com\"}\n        }\n        with self.assertRaises(KeyError):\n            modify_user_email_address(user_request)\n\n    def test_missing_body(self):\n        # Test missing 'body' key in request\n        user_request = {\n            \"headers\": {\"X-CSRF-Token\": \"valid_csrf_token\"}\n        }\n        with self.assertRaises(KeyError):\n            modify_user_email_address(user_request)\n\n    def test_missing_user_id_in_body(self):\n        # Test missing 'user_id' in request body\n        user_request = {\n            \"headers\": {\"X-CSRF-Token\": \"valid_csrf_token\"},\n            \"body\": {\"new_email\": \"new_email@example.com\"}\n        }\n        with self.assertRaises(KeyError):\n            modify_user_email_address(user_request)\n\n    def test_missing_new_email_in_body(self):\n        # Test missing 'new_email' in request body\n        user_request = {\n            \"headers\": {\"X-CSRF-Token\": \"valid_csrf_token\"},\n            \"body\": {\"user_id\": \"1\"}\n        }\n        with self.assertRaises(KeyError):\n            modify_user_email_address(user_request)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 8, "task_id": "f716b8cb"}
{"test": "import unittest\n\n# Global variables used by the function\naccount_database = None\nVALID_TOKEN = None\n\nclass TestCases(unittest.TestCase):\n    def setUp(self):\n        \"\"\"Reset global state before each test.\"\"\"\n        global account_database, VALID_TOKEN\n        account_database = {\n            \"users\": {\n                \"user1\": {\"email\": \"user1@example.com\"},\n                \"user2\": {\"email\": \"user2@example.com\"},\n                \"1\": {\"email\": \"user3@example.com\"}\n            }\n        }\n        VALID_TOKEN = \"secure_csrf_token\"\n    \n    def test_valid_token_existing_user(self):\n        \"\"\"Test updating existing user with valid token.\"\"\"\n        payload = {\n            \"headers\": {\"X-CSRF-Token\": \"secure_csrf_token\"},\n            \"body\": {\n                \"user_id\": \"user1\",\n                \"new_email\": \"new_email@example.com\"\n            }\n        }\n        result = edit_user_email(payload)\n        self.assertTrue(result)\n        self.assertEqual(account_database[\"users\"][\"user1\"][\"email\"], \"new_email@example.com\")\n    \n    def test_valid_token_non_existing_user_string(self):\n        \"\"\"Test non-existing string user_id with valid token.\"\"\"\n        payload = {\n            \"headers\": {\"X-CSRF-Token\": \"secure_csrf_token\"},\n            \"body\": {\n                \"user_id\": \"non_existing\",\n                \"new_email\": \"new@example.com\"\n            }\n        }\n        result = edit_user_email(payload)\n        self.assertFalse(result)\n    \n    def test_valid_token_non_existing_user_integer(self):\n        \"\"\"Test integer user_id not matching string key in database.\"\"\"\n        payload = {\n            \"headers\": {\"X-CSRF-Token\": \"secure_csrf_token\"},\n            \"body\": {\n                \"user_id\": 2,\n                \"new_email\": \"new@example.com\"\n            }\n        }\n        result = edit_user_email(payload)\n        self.assertFalse(result)\n    \n    def test_invalid_token(self):\n        \"\"\"Test incorrect CSRF token.\"\"\"\n        payload = {\n            \"headers\": {\"X-CSRF-Token\": \"invalid_token\"},\n            \"body\": {\n                \"user_id\": \"user1\",\n                \"new_email\": \"new@example.com\"\n            }\n        }\n        result = edit_user_email(payload)\n        self.assertFalse(result)\n    \n    def test_missing_token(self):\n        \"\"\"Test missing X-CSRF-Token in headers.\"\"\"\n        payload = {\n            \"headers\": {},\n            \"body\": {\n                \"user_id\": \"user1\",\n                \"new_email\": \"new@example.com\"\n            }\n        }\n        result = edit_user_email(payload)\n        self.assertFalse(result)\n    \n    def test_missing_headers(self):\n        \"\"\"Test missing 'headers' key in payload.\"\"\"\n        payload = {\n            \"body\": {\n                \"user_id\": \"user1\",\n                \"new_email\": \"new@example.com\"\n            }\n        }\n        with self.assertRaises(KeyError):\n            edit_user_email(payload)\n    \n    def test_missing_body(self):\n        \"\"\"Test missing 'body' key in payload.\"\"\"\n        payload = {\n            \"headers\": {\"X-CSRF-Token\": \"secure_csrf_token\"}\n        }\n        with self.assertRaises(KeyError):\n            edit_user_email(payload)\n    \n    def test_body_missing_user_id(self):\n        \"\"\"Test missing 'user_id' in body.\"\"\"\n        payload = {\n            \"headers\": {\"X-CSRF-Token\": \"secure_csrf_token\"},\n            \"body\": {\n                \"new_email\": \"new@example.com\"\n            }\n        }\n        with self.assertRaises(KeyError):\n            edit_user_email(payload)\n    \n    def test_body_missing_new_email(self):\n        \"\"\"Test missing 'new_email' in body.\"\"\"\n        payload = {\n            \"headers\": {\"X-CSRF-Token\": \"secure_csrf_token\"},\n            \"body\": {\n                \"user_id\": \"user1\"\n            }\n        }\n        with self.assertRaises(KeyError):\n            edit_user_email(payload)\n    \n    def test_update_to_empty_email(self):\n        \"\"\"Test updating email to empty string.\"\"\"\n        payload = {\n            \"headers\": {\"X-CSRF-Token\": \"secure_csrf_token\"},\n            \"body\": {\n                \"user_id\": \"user1\",\n                \"new_email\": \"\"\n            }\n        }\n        result = edit_user_email(payload)\n        self.assertTrue(result)\n        self.assertEqual(account_database[\"users\"][\"user1\"][\"email\"], \"\")\n    \n    def test_update_with_non_string_email(self):\n        \"\"\"Test updating email to non-string value.\"\"\"\n        payload = {\n            \"headers\": {\"X-CSRF-Token\": \"secure_csrf_token\"},\n            \"body\": {\n                \"user_id\": \"user1\",\n                \"new_email\": 12345\n            }\n        }\n        result = edit_user_email(payload)\n        self.assertTrue(result)\n        self.assertEqual(account_database[\"users\"][\"user1\"][\"email\"], 12345)\n    \n    def test_headers_not_dict(self):\n        \"\"\"Test headers value is not a dictionary.\"\"\"\n        payload = {\n            \"headers\": \"not_a_dict\",\n            \"body\": {\n                \"user_id\": \"user1\",\n                \"new_email\": \"new@example.com\"\n            }\n        }\n        with self.assertRaises(AttributeError):\n            edit_user_email(payload)\n    \n    def test_body_not_dict(self):\n        \"\"\"Test body value is not a dictionary.\"\"\"\n        payload = {\n            \"headers\": {\"X-CSRF-Token\": \"secure_csrf_token\"},\n            \"body\": \"not_a_dict\"\n        }\n        with self.assertRaises(TypeError):\n            edit_user_email(payload)", "num_test_cases": 13, "task_id": "8a6e9dfc"}
{"test": "import unittest\n\nclass TestChangeUserEmail(unittest.TestCase):\n    def setUp(self):\n        global database, EXPECTED_CSRF_TOKEN\n        EXPECTED_CSRF_TOKEN = 'expected_token'\n        database = {\n            'users': {\n                'user1': {'email': 'user1@example.com'},\n                'user2': {'email': 'user2@example.com'}\n            }\n        }\n\n    def test_valid_token_existing_user(self):\n        # Test updating existing user with valid token\n        request_data = {\n            'headers': {'X-CSRF-Token': 'expected_token'},\n            'body': {'user_id': 'user1', 'new_email': 'new_email@example.com'}\n        }\n        result = change_user_email(request_data)\n        self.assertTrue(result)\n        self.assertEqual(database['users']['user1']['email'], 'new_email@example.com')\n        self.assertEqual(database['users']['user2']['email'], 'user2@example.com')\n\n    def test_invalid_token(self):\n        # Test with invalid CSRF token\n        request_data = {\n            'headers': {'X-CSRF-Token': 'invalid_token'},\n            'body': {'user_id': 'user1', 'new_email': 'new_email@example.com'}\n        }\n        result = change_user_email(request_data)\n        self.assertFalse(result)\n        self.assertEqual(database['users']['user1']['email'], 'user1@example.com')\n\n    def test_missing_token(self):\n        # Test when CSRF token is missing\n        request_data = {\n            'headers': {},\n            'body': {'user_id': 'user1', 'new_email': 'new_email@example.com'}\n        }\n        result = change_user_email(request_data)\n        self.assertFalse(result)\n        self.assertEqual(database['users']['user1']['email'], 'user1@example.com')\n\n    def test_non_existent_user(self):\n        # Test with non-existent user\n        request_data = {\n            'headers': {'X-CSRF-Token': 'expected_token'},\n            'body': {'user_id': 'user3', 'new_email': 'new_email@example.com'}\n        }\n        result = change_user_email(request_data)\n        self.assertFalse(result)\n        self.assertNotIn('user3', database['users'])\n\n    def test_missing_headers_key(self):\n        # Test when request_data missing 'headers' key\n        request_data = {'body': {'user_id': 'user1', 'new_email': 'new_email@example.com'}}\n        with self.assertRaises(KeyError):\n            change_user_email(request_data)\n\n    def test_missing_body_key(self):\n        # Test when request_data missing 'body' key\n        request_data = {'headers': {'X-CSRF-Token': 'expected_token'}}\n        with self.assertRaises(KeyError):\n            change_user_email(request_data)\n\n    def test_missing_user_id(self):\n        # Test when body missing 'user_id'\n        request_data = {\n            'headers': {'X-CSRF-Token': 'expected_token'},\n            'body': {'new_email': 'new_email@example.com'}\n        }\n        with self.assertRaises(KeyError):\n            change_user_email(request_data)\n\n    def test_missing_new_email(self):\n        # Test when body missing 'new_email'\n        request_data = {\n            'headers': {'X-CSRF-Token': 'expected_token'},\n            'body': {'user_id': 'user1'}\n        }\n        with self.assertRaises(KeyError):\n            change_user_email(request_data)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 8, "task_id": "ed3f8f05"}
{"test": "import unittest\nfrom unittest.mock import patch\n\nclass TestModifyUserEmail(unittest.TestCase):\n    def setUp(self):\n        # Setup fresh database and token for each test\n        self.database = {\n            \"users\": {\n                \"1\": {\"email\": \"user1@example.com\"},\n                \"2\": {\"email\": \"user2@example.com\"}\n            }\n        }\n        self.expected_token = \"expected_token\"\n        \n        # Patch the global variables in the function's module (assumed to be __main__)\n        self.db_patcher = patch('__main__.database', new=self.database)\n        self.token_patcher = patch('__main__.EXPECTED_CSRF_TOKEN', new=self.expected_token)\n        self.db_patcher.start()\n        self.token_patcher.start()\n    \n    def tearDown(self):\n        # Stop patching after each test\n        self.db_patcher.stop()\n        self.token_patcher.stop()\n    \n    def test_valid_token_and_existing_user(self):\n        # Happy path: valid token and existing user\n        req_data = {\n            \"headers\": {\"X-CSRF-Token\": \"expected_token\"},\n            \"body\": {\"user_id\": \"1\", \"new_email\": \"new@example.com\"}\n        }\n        result = modify_user_email(req_data)\n        self.assertTrue(result)\n        self.assertEqual(self.database[\"users\"][\"1\"][\"email\"], \"new@example.com\")\n    \n    def test_valid_token_non_existing_user(self):\n        # Valid token but non-existent user\n        req_data = {\n            \"headers\": {\"X-CSRF-Token\": \"expected_token\"},\n            \"body\": {\"user_id\": \"99\", \"new_email\": \"new@example.com\"}\n        }\n        result = modify_user_email(req_data)\n        self.assertFalse(result)\n    \n    def test_invalid_token(self):\n        # Invalid token (wrong value)\n        req_data = {\n            \"headers\": {\"X-CSRF-Token\": \"wrong_token\"},\n            \"body\": {\"user_id\": \"1\", \"new_email\": \"new@example.com\"}\n        }\n        result = modify_user_email(req_data)\n        self.assertFalse(result)\n    \n    def test_missing_token_header(self):\n        # Headers present but missing X-CSRF-Token\n        req_data = {\n            \"headers\": {},\n            \"body\": {\"user_id\": \"1\", \"new_email\": \"new@example.com\"}\n        }\n        result = modify_user_email(req_data)\n        self.assertFalse(result)\n    \n    def test_missing_headers_section(self):\n        # Entire headers section missing\n        req_data = {\n            \"body\": {\"user_id\": \"1\", \"new_email\": \"new@example.com\"}\n        }\n        with self.assertRaises(KeyError):\n            modify_user_email(req_data)\n    \n    def test_missing_body_section(self):\n        # Entire body section missing\n        req_data = {\n            \"headers\": {\"X-CSRF-Token\": \"expected_token\"}\n        }\n        with self.assertRaises(KeyError):\n            modify_user_email(req_data)\n    \n    def test_missing_user_id_in_body(self):\n        # Body present but missing user_id\n        req_data = {\n            \"headers\": {\"X-CSRF-Token\": \"expected_token\"},\n            \"body\": {\"new_email\": \"new@example.com\"}\n        }\n        with self.assertRaises(KeyError):\n            modify_user_email(req_data)\n    \n    def test_missing_new_email_in_body(self):\n        # Body present but missing new_email\n        req_data = {\n            \"headers\": {\"X-CSRF-Token\": \"expected_token\"},\n            \"body\": {\"user_id\": \"1\"}\n        }\n        with self.assertRaises(KeyError):\n            modify_user_email(req_data)\n    \n    def test_update_with_empty_email(self):\n        # Update with empty string for new_email\n        req_data = {\n            \"headers\": {\"X-CSRF-Token\": \"expected_token\"},\n            \"body\": {\"user_id\": \"1\", \"new_email\": \"\"}\n        }\n        result = modify_user_email(req_data)\n        self.assertTrue(result)\n        self.assertEqual(self.database[\"users\"][\"1\"][\"email\"], \"\")\n    \n    def test_update_with_long_email(self):\n        # Update with very long email\n        long_email = \"a\" * 1000 + \"@example.com\"\n        req_data = {\n            \"headers\": {\"X-CSRF-Token\": \"expected_token\"},\n            \"body\": {\"user_id\": \"1\", \"new_email\": long_email}\n        }\n        result = modify_user_email(req_data)\n        self.assertTrue(result)\n        self.assertEqual(self.database[\"users\"][\"1\"][\"email\"], long_email)\n    \n    def test_token_present_but_empty(self):\n        # Token present in headers but empty string\n        req_data = {\n            \"headers\": {\"X-CSRF-Token\": \"\"},\n            \"body\": {\"user_id\": \"1\", \"new_email\": \"new@example.com\"}\n        }\n        result = modify_user_email(req_data)\n        self.assertFalse(result)", "num_test_cases": 11, "task_id": "2b6cc41f"}
{"test": "import unittest\nfrom unittest.mock import patch\n\nclass TestEditUserEmail(unittest.TestCase):\n    def setUp(self):\n        # Patch the global database and EXPECTED_CSRF_TOKEN\n        self.db_patcher = patch('__main__.database', {'users': {}})\n        self.mock_db = self.db_patcher.start()\n        self.token_patcher = patch('__main__.EXPECTED_CSRF_TOKEN', 'expected_token')\n        self.mock_token = self.token_patcher.start()\n        \n    def tearDown(self):\n        self.db_patcher.stop()\n        self.token_patcher.stop()\n    \n    def test_valid_csrf_existing_user(self):\n        \"\"\"Test updating email with valid CSRF and existing user.\"\"\"\n        database['users']['123'] = {'email': 'old@example.com'}\n        payload = {\n            'headers': {'X-CSRF-Token': 'expected_token'},\n            'body': {'user_id': '123', 'new_email': 'new@example.com'}\n        }\n        result = edit_user_email(payload)\n        self.assertTrue(result)\n        self.assertEqual(database['users']['123']['email'], 'new@example.com')\n    \n    def test_invalid_csrf_token(self):\n        \"\"\"Test with invalid CSRF token.\"\"\"\n        database['users']['123'] = {'email': 'old@example.com'}\n        payload = {\n            'headers': {'X-CSRF-Token': 'invalid_token'},\n            'body': {'user_id': '123', 'new_email': 'new@example.com'}\n        }\n        result = edit_user_email(payload)\n        self.assertFalse(result)\n        self.assertEqual(database['users']['123']['email'], 'old@example.com')\n    \n    def test_user_not_exist(self):\n        \"\"\"Test with non-existent user ID.\"\"\"\n        payload = {\n            'headers': {'X-CSRF-Token': 'expected_token'},\n            'body': {'user_id': 'non_existent', 'new_email': 'new@example.com'}\n        }\n        result = edit_user_email(payload)\n        self.assertFalse(result)\n    \n    def test_missing_headers(self):\n        \"\"\"Test missing headers in request payload.\"\"\"\n        payload = {'body': {'user_id': '123', 'new_email': 'new@example.com'}}\n        with self.assertRaises(KeyError):\n            edit_user_email(payload)\n    \n    def test_missing_body(self):\n        \"\"\"Test missing body in request payload.\"\"\"\n        payload = {'headers': {'X-CSRF-Token': 'expected_token'}}\n        with self.assertRaises(KeyError):\n            edit_user_email(payload)\n    \n    def test_missing_user_id(self):\n        \"\"\"Test missing user_id in body.\"\"\"\n        payload = {\n            'headers': {'X-CSRF-Token': 'expected_token'},\n            'body': {'new_email': 'new@example.com'}\n        }\n        with self.assertRaises(KeyError):\n            edit_user_email(payload)\n    \n    def test_missing_new_email(self):\n        \"\"\"Test missing new_email in body.\"\"\"\n        payload = {\n            'headers': {'X-CSRF-Token': 'expected_token'},\n            'body': {'user_id': '123'}\n        }\n        with self.assertRaises(KeyError):\n            edit_user_email(payload)\n    \n    def test_update_to_empty_email(self):\n        \"\"\"Test updating email to empty string.\"\"\"\n        database['users']['123'] = {'email': 'old@example.com'}\n        payload = {\n            'headers': {'X-CSRF-Token': 'expected_token'},\n            'body': {'user_id': '123', 'new_email': ''}\n        }\n        result = edit_user_email(payload)\n        self.assertTrue(result)\n        self.assertEqual(database['users']['123']['email'], '')\n    \n    def test_csrf_token_case_sensitive(self):\n        \"\"\"Test CSRF token is case-sensitive.\"\"\"\n        database['users']['123'] = {'email': 'old@example.com'}\n        payload = {\n            'headers': {'X-CSRF-Token': 'Expected_Token'},  # Different case\n            'body': {'user_id': '123', 'new_email': 'new@example.com'}\n        }\n        result = edit_user_email(payload)\n        self.assertFalse(result)\n        self.assertEqual(database['users']['123']['email'], 'old@example.com')\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 9, "task_id": "50b5dcaa"}
{"test": "import unittest\n\nclass TestChangeUserEmail(unittest.TestCase):\n    def setUp(self):\n        \"\"\"Set up the test environment by resetting the global database and token.\"\"\"\n        global database, EXPECTED_CSRF_TOKEN\n        # Set the expected CSRF token\n        EXPECTED_CSRF_TOKEN = \"expected_csrf_token\"\n        # Initialize the mock database with some users\n        database = {\n            \"users\": {\n                \"1\": {\"email\": \"user1@example.com\"},\n                \"2\": {\"email\": \"user2@example.com\"}\n            }\n        }\n\n    def test_valid_input(self):\n        \"\"\"Test update with valid token and existing user.\"\"\"\n        query = {\n            \"headers\": {\"X-CSRF-Token\": \"expected_csrf_token\"},\n            \"body\": {\n                \"user_id\": \"1\",\n                \"new_email\": \"new_email@example.com\"\n            }\n        }\n        result = change_user_email(query)\n        self.assertTrue(result)\n        self.assertEqual(database[\"users\"][\"1\"][\"email\"], \"new_email@example.com\")\n\n    def test_invalid_csrf_token(self):\n        \"\"\"Test with an invalid CSRF token.\"\"\"\n        query = {\n            \"headers\": {\"X-CSRF-Token\": \"invalid_token\"},\n            \"body\": {\n                \"user_id\": \"1\",\n                \"new_email\": \"new_email@example.com\"\n            }\n        }\n        result = change_user_email(query)\n        self.assertFalse(result)\n        # Ensure database was not updated\n        self.assertEqual(database[\"users\"][\"1\"][\"email\"], \"user1@example.com\")\n\n    def test_missing_csrf_token(self):\n        \"\"\"Test when the CSRF token is missing in headers.\"\"\"\n        query = {\n            \"headers\": {},\n            \"body\": {\n                \"user_id\": \"1\",\n                \"new_email\": \"new_email@example.com\"\n            }\n        }\n        result = change_user_email(query)\n        self.assertFalse(result)\n        # Ensure database was not updated\n        self.assertEqual(database[\"users\"][\"1\"][\"email\"], \"user1@example.com\")\n\n    def test_nonexistent_user(self):\n        \"\"\"Test update for a user that does not exist.\"\"\"\n        query = {\n            \"headers\": {\"X-CSRF-Token\": \"expected_csrf_token\"},\n            \"body\": {\n                \"user_id\": \"999\",\n                \"new_email\": \"new_email@example.com\"\n            }\n        }\n        result = change_user_email(query)\n        self.assertFalse(result)\n        # Ensure database remains unchanged\n        self.assertNotIn(\"999\", database[\"users\"])\n\n    def test_missing_headers(self):\n        \"\"\"Test when the 'headers' key is missing in the query.\"\"\"\n        query = {\n            \"body\": {\n                \"user_id\": \"1\",\n                \"new_email\": \"new_email@example.com\"\n            }\n        }\n        with self.assertRaises(KeyError):\n            change_user_email(query)\n\n    def test_missing_body(self):\n        \"\"\"Test when the 'body' key is missing in the query.\"\"\"\n        query = {\n            \"headers\": {\"X-CSRF-Token\": \"expected_csrf_token\"}\n        }\n        with self.assertRaises(KeyError):\n            change_user_email(query)\n\n    def test_missing_user_id(self):\n        \"\"\"Test when 'user_id' is missing in the body.\"\"\"\n        query = {\n            \"headers\": {\"X-CSRF-Token\": \"expected_csrf_token\"},\n            \"body\": {\n                \"new_email\": \"new_email@example.com\"\n            }\n        }\n        with self.assertRaises(KeyError):\n            change_user_email(query)\n\n    def test_missing_new_email(self):\n        \"\"\"Test when 'new_email' is missing in the body.\"\"\"\n        query = {\n            \"headers\": {\"X-CSRF-Token\": \"expected_csrf_token\"},\n            \"body\": {\n                \"user_id\": \"1\"\n            }\n        }\n        with self.assertRaises(KeyError):\n            change_user_email(query)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 8, "task_id": "27e09674"}
{"test": "import unittest\n\n# Global variables that the function uses\ndatabase = None\nEXPECTED_CSRF_TOKEN = None\n\nclass TestTaskFunc(unittest.TestCase):\n    def setUp(self):\n        global database, EXPECTED_CSRF_TOKEN\n        database = {\n            \"users\": {\n                \"1\": {\"email\": \"test1@example.com\"},\n                \"2\": {\"email\": \"test2@example.com\"}\n            }\n        }\n        EXPECTED_CSRF_TOKEN = \"secure_token_123\"\n\n    def test_valid_csrf_existing_user(self):\n        # Happy path: valid CSRF token and existing user\n        req = {\n            \"headers\": {\"X-CSRF-Token\": \"secure_token_123\"},\n            \"body\": {\"user_id\": \"1\", \"new_email\": \"new1@example.com\"}\n        }\n        result = modify_user_email(req)\n        self.assertTrue(result)\n        self.assertEqual(database[\"users\"][\"1\"][\"email\"], \"new1@example.com\")\n\n    def test_valid_csrf_non_existing_user(self):\n        # Valid CSRF token but non-existing user\n        req = {\n            \"headers\": {\"X-CSRF-Token\": \"secure_token_123\"},\n            \"body\": {\"user_id\": \"non_existent\", \"new_email\": \"new@example.com\"}\n        }\n        result = modify_user_email(req)\n        self.assertFalse(result)\n\n    def test_invalid_csrf_existing_user(self):\n        # Invalid CSRF token with existing user\n        req = {\n            \"headers\": {\"X-CSRF-Token\": \"invalid_token\"},\n            \"body\": {\"user_id\": \"1\", \"new_email\": \"new1@example.com\"}\n        }\n        result = modify_user_email(req)\n        self.assertFalse(result)\n        self.assertEqual(database[\"users\"][\"1\"][\"email\"], \"test1@example.com\")\n\n    def test_missing_csrf_header(self):\n        # Missing 'X-CSRF-Token' in headers\n        req = {\n            \"headers\": {},\n            \"body\": {\"user_id\": \"1\", \"new_email\": \"new1@example.com\"}\n        }\n        result = modify_user_email(req)\n        self.assertFalse(result)\n\n    def test_missing_headers_key(self):\n        # Missing 'headers' key in request\n        req = {\n            \"body\": {\"user_id\": \"1\", \"new_email\": \"new1@example.com\"}\n        }\n        with self.assertRaises(KeyError):\n            modify_user_email(req)\n\n    def test_missing_body_key(self):\n        # Missing 'body' key in request\n        req = {\n            \"headers\": {\"X-CSRF-Token\": \"secure_token_123\"}\n        }\n        with self.assertRaises(KeyError):\n            modify_user_email(req)\n\n    def test_missing_user_id_in_body(self):\n        # Missing 'user_id' in request body\n        req = {\n            \"headers\": {\"X-CSRF-Token\": \"secure_token_123\"},\n            \"body\": {\"new_email\": \"new1@example.com\"}\n        }\n        with self.assertRaises(KeyError):\n            modify_user_email(req)\n\n    def test_missing_new_email_in_body(self):\n        # Missing 'new_email' in request body\n        req = {\n            \"headers\": {\"X-CSRF-Token\": \"secure_token_123\"},\n            \"body\": {\"user_id\": \"1\"}\n        }\n        with self.assertRaises(KeyError):\n            modify_user_email(req)\n\n    def test_request_is_none(self):\n        # Request is None\n        with self.assertRaises(TypeError):\n            modify_user_email(None)\n\n    def test_request_is_string(self):\n        # Request is a string\n        with self.assertRaises(TypeError):\n            modify_user_email(\"invalid_request\")\n\n    def test_request_is_integer(self):\n        # Request is an integer\n        with self.assertRaises(TypeError):\n            modify_user_email(123)\n\n    def test_empty_user_id_non_existent(self):\n        # Empty user_id that does not exist in database\n        req = {\n            \"headers\": {\"X-CSRF-Token\": \"secure_token_123\"},\n            \"body\": {\"user_id\": \"\", \"new_email\": \"new@example.com\"}\n        }\n        result = modify_user_email(req)\n        self.assertFalse(result)\n\n    def test_empty_user_id_existing(self):\n        # Empty user_id that exists in database\n        global database\n        database[\"users\"][\"\"] = {\"email\": \"empty@example.com\"}\n        req = {\n            \"headers\": {\"X-CSRF-Token\": \"secure_token_123\"},\n            \"body\": {\"user_id\": \"\", \"new_email\": \"new@example.com\"}\n        }\n        result = modify_user_email(req)\n        self.assertTrue(result)\n        self.assertEqual(database[\"users\"][\"\"][\"email\"], \"new@example.com\")\n", "num_test_cases": 13, "task_id": "966482fc"}
{"test": "import unittest\nimport app\n\nclass TestAlterUserEmail(unittest.TestCase):\n\n    def setUp(self):\n        # Reset the global state before each test\n        app.record_storage = {'users': {}}\n        app.EXPECTED_CSRF_TOKEN = \"expected_token_123\"\n\n    def test_valid_token_and_existing_user(self):\n        # Happy path: valid token, existing user - should update email and return True\n        app.record_storage['users']['user1'] = {'email': 'old@example.com'}\n        payload = {\n            'headers': {'X-CSRF-Token': 'expected_token_123'},\n            'body': {'user_id': 'user1', 'new_email': 'new@example.com'}\n        }\n        result = app.alter_user_email(payload)\n        self.assertTrue(result)\n        self.assertEqual(app.record_storage['users']['user1']['email'], 'new@example.com')\n\n    def test_invalid_token(self):\n        # Invalid token - should return False and not update email\n        app.record_storage['users']['user1'] = {'email': 'old@example.com'}\n        payload = {\n            'headers': {'X-CSRF-Token': 'invalid_token'},\n            'body': {'user_id': 'user1', 'new_email': 'new@example.com'}\n        }\n        result = app.alter_user_email(payload)\n        self.assertFalse(result)\n        self.assertEqual(app.record_storage['users']['user1']['email'], 'old@example.com')\n\n    def test_missing_token_in_headers(self):\n        # Missing token in headers - should return False\n        app.record_storage['users']['user1'] = {'email': 'old@example.com'}\n        payload = {\n            'headers': {},\n            'body': {'user_id': 'user1', 'new_email': 'new@example.com'}\n        }\n        result = app.alter_user_email(payload)\n        self.assertFalse(result)\n        self.assertEqual(app.record_storage['users']['user1']['email'], 'old@example.com')\n\n    def test_valid_token_but_non_existing_user(self):\n        # Valid token but non-existing user - should return False\n        payload = {\n            'headers': {'X-CSRF-Token': 'expected_token_123'},\n            'body': {'user_id': 'non_existing', 'new_email': 'new@example.com'}\n        }\n        result = app.alter_user_email(payload)\n        self.assertFalse(result)\n\n    def test_missing_headers_key(self):\n        # Payload missing 'headers' key - should raise KeyError\n        payload = {\n            'body': {'user_id': 'user1', 'new_email': 'new@example.com'}\n        }\n        with self.assertRaises(KeyError):\n            app.alter_user_email(payload)\n\n    def test_missing_body_key(self):\n        # Payload missing 'body' key - should raise KeyError\n        payload = {\n            'headers': {'X-CSRF-Token': 'expected_token_123'}\n        }\n        with self.assertRaises(KeyError):\n            app.alter_user_email(payload)\n\n    def test_missing_user_id_in_body(self):\n        # Body missing 'user_id' - should raise KeyError\n        payload = {\n            'headers': {'X-CSRF-Token': 'expected_token_123'},\n            'body': {'new_email': 'new@example.com'}\n        }\n        with self.assertRaises(KeyError):\n            app.alter_user_email(payload)\n\n    def test_missing_new_email_in_body(self):\n        # Body missing 'new_email' - should raise KeyError\n        payload = {\n            'headers': {'X-CSRF-Token': 'expected_token_123'},\n            'body': {'user_id': 'user1'}\n        }\n        with self.assertRaises(KeyError):\n            app.alter_user_email(payload)\n", "num_test_cases": 8, "task_id": "df4b8880"}
{"test": "import unittest\n\nclass TestChangeUserPhone(unittest.TestCase):\n    def setUp(self):\n        global database\n        global EXPECTED_CSRF_TOKEN\n        EXPECTED_CSRF_TOKEN = 'expected_csrf_token'\n        database = {\n            'users': {\n                'user1': {'phone': '1234567890'},\n                'user2': {'phone': '0987654321'}\n            }\n        }\n\n    def test_valid_request(self):\n        # Happy path: valid CSRF and existing user\n        request_details = {\n            'headers': {'X-CSRF-Token': 'expected_csrf_token'},\n            'body': {'user_id': 'user1', 'new_phone': '1111111111'}\n        }\n        result = change_user_phone(request_details)\n        self.assertTrue(result)\n        self.assertEqual(database['users']['user1']['phone'], '1111111111')\n\n    def test_invalid_csrf(self):\n        # Invalid CSRF token\n        request_details = {\n            'headers': {'X-CSRF-Token': 'invalid_token'},\n            'body': {'user_id': 'user1', 'new_phone': '1111111111'}\n        }\n        result = change_user_phone(request_details)\n        self.assertFalse(result)\n        self.assertEqual(database['users']['user1']['phone'], '1234567890')\n\n    def test_non_existent_user(self):\n        # Valid CSRF but user does not exist\n        request_details = {\n            'headers': {'X-CSRF-Token': 'expected_csrf_token'},\n            'body': {'user_id': 'user3', 'new_phone': '1111111111'}\n        }\n        result = change_user_phone(request_details)\n        self.assertFalse(result)\n        expected_db = {\n            'users': {\n                'user1': {'phone': '1234567890'},\n                'user2': {'phone': '0987654321'}\n            }\n        }\n        self.assertEqual(database, expected_db)\n\n    def test_missing_headers(self):\n        # Request missing 'headers' key\n        request_details = {'body': {'user_id': 'user1', 'new_phone': '1111111111'}}\n        with self.assertRaises(KeyError):\n            change_user_phone(request_details)\n\n    def test_missing_body(self):\n        # Request missing 'body' key\n        request_details = {'headers': {'X-CSRF-Token': 'expected_csrf_token'}}\n        with self.assertRaises(KeyError):\n            change_user_phone(request_details)\n\n    def test_missing_csrf_in_headers(self):\n        # Headers present but missing X-CSRF-Token\n        request_details = {\n            'headers': {},\n            'body': {'user_id': 'user1', 'new_phone': '1111111111'}\n        }\n        result = change_user_phone(request_details)\n        self.assertFalse(result)\n\n    def test_missing_user_id_in_body(self):\n        # Body present but missing user_id\n        request_details = {\n            'headers': {'X-CSRF-Token': 'expected_csrf_token'},\n            'body': {'new_phone': '1111111111'}\n        }\n        with self.assertRaises(KeyError):\n            change_user_phone(request_details)\n\n    def test_missing_new_phone_in_body(self):\n        # Body present but missing new_phone\n        request_details = {\n            'headers': {'X-CSRF-Token': 'expected_csrf_token'},\n            'body': {'user_id': 'user1'}\n        }\n        with self.assertRaises(KeyError):\n            change_user_phone(request_details)\n\n    def test_empty_phone_string(self):\n        # Valid update with empty phone string\n        request_details = {\n            'headers': {'X-CSRF-Token': 'expected_csrf_token'},\n            'body': {'user_id': 'user1', 'new_phone': ''}\n        }\n        result = change_user_phone(request_details)\n        self.assertTrue(result)\n        self.assertEqual(database['users']['user1']['phone'], '')\n\n    def test_empty_user_id(self):\n        # Empty user_id string (non-existent user)\n        request_details = {\n            'headers': {'X-CSRF-Token': 'expected_csrf_token'},\n            'body': {'user_id': '', 'new_phone': '1111111111'}\n        }\n        result = change_user_phone(request_details)\n        self.assertFalse(result)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 10, "task_id": "ff1a29f8"}
{"test": "import unittest\nimport app\n\nclass TestModifyUserPhone(unittest.TestCase):\n    \n    def setUp(self):\n        # Set up the expected token and database state\n        app.EXPECTED_CSRF_TOKEN = \"expected_csrf_token\"\n        app.db = {\n            'users': {\n                '1': {'phone': '1234567890'},\n                '2': {'phone': '0987654321'},\n                '': {'phone': '0000000000'}\n            }\n        }\n    \n    def test_happy_path(self):\n        # Valid token and existing user\n        client_request = {\n            'headers': {'X-CSRF-Token': 'expected_csrf_token'},\n            'body': {'user_id': '1', 'new_phone': '1111111111'}\n        }\n        result = app.modify_user_phone(client_request)\n        self.assertTrue(result)\n        self.assertEqual(app.db['users']['1']['phone'], '1111111111')\n    \n    def test_invalid_csrf_token(self):\n        # Incorrect CSRF token\n        client_request = {\n            'headers': {'X-CSRF-Token': 'invalid_token'},\n            'body': {'user_id': '1', 'new_phone': '1111111111'}\n        }\n        result = app.modify_user_phone(client_request)\n        self.assertFalse(result)\n        self.assertEqual(app.db['users']['1']['phone'], '1234567890')\n    \n    def test_non_existent_user(self):\n        # Valid token but non-existent user\n        client_request = {\n            'headers': {'X-CSRF-Token': 'expected_csrf_token'},\n            'body': {'user_id': 'non_existent', 'new_phone': '1111111111'}\n        }\n        result = app.modify_user_phone(client_request)\n        self.assertFalse(result)\n    \n    def test_missing_headers(self):\n        # Missing headers in request\n        client_request = {\n            'body': {'user_id': '1', 'new_phone': '1111111111'}\n        }\n        with self.assertRaises(KeyError):\n            app.modify_user_phone(client_request)\n    \n    def test_missing_body(self):\n        # Missing body in request\n        client_request = {\n            'headers': {'X-CSRF-Token': 'expected_csrf_token'}\n        }\n        with self.assertRaises(KeyError):\n            app.modify_user_phone(client_request)\n    \n    def test_missing_csrf_in_headers(self):\n        # Missing X-CSRF-Token in headers\n        client_request = {\n            'headers': {}, \n            'body': {'user_id': '1', 'new_phone': '1111111111'}\n        }\n        result = app.modify_user_phone(client_request)\n        self.assertFalse(result)\n    \n    def test_missing_user_id_in_body(self):\n        # Missing user_id in body\n        client_request = {\n            'headers': {'X-CSRF-Token': 'expected_csrf_token'},\n            'body': {'new_phone': '1111111111'}\n        }\n        with self.assertRaises(KeyError):\n            app.modify_user_phone(client_request)\n    \n    def test_missing_new_phone_in_body(self):\n        # Missing new_phone in body\n        client_request = {\n            'headers': {'X-CSRF-Token': 'expected_csrf_token'},\n            'body': {'user_id': '1'}\n        }\n        with self.assertRaises(KeyError):\n            app.modify_user_phone(client_request)\n    \n    def test_empty_user_id_valid(self):\n        # Empty string user_id that exists in database\n        client_request = {\n            'headers': {'X-CSRF-Token': 'expected_csrf_token'},\n            'body': {'user_id': '', 'new_phone': '9999999999'}\n        }\n        result = app.modify_user_phone(client_request)\n        self.assertTrue(result)\n        self.assertEqual(app.db['users']['']['phone'], '9999999999')\n    \n    def test_empty_phone_number(self):\n        # Update to empty phone number\n        client_request = {\n            'headers': {'X-CSRF-Token': 'expected_csrf_token'},\n            'body': {'user_id': '1', 'new_phone': ''}\n        }\n        result = app.modify_user_phone(client_request)\n        self.assertTrue(result)\n        self.assertEqual(app.db['users']['1']['phone'], '')\n    \n    def test_database_missing_users_key(self):\n        # Database missing 'users' key\n        app.db = {}\n        client_request = {\n            'headers': {'X-CSRF-Token': 'expected_csrf_token'},\n            'body': {'user_id': '1', 'new_phone': '1111111111'}\n        }\n        with self.assertRaises(KeyError):\n            app.modify_user_phone(client_request)", "num_test_cases": 11, "task_id": "f1029529"}
{"test": "import unittest\nfrom unittest.mock import patch\n\n# We'll create a mock module for the app context\nclass AppModule:\n    EXPECTED_CSRF_TOKEN = \"expected_csrf_token\"\n    user_db = {\"users\": {\"1\": {\"phone\": \"1234567890\"}, \"2\": {\"phone\": \"0987654321\"}}}\n\n# Patch the module where the function is defined\n@patch(\"__main__.app\", new=AppModule())\nclass TestAlterUserPhone(unittest.TestCase):\n    def setUp(self):\n        # Reset the database state before each test\n        app.user_db = {\"users\": {\"1\": {\"phone\": \"1234567890\"}, \"2\": {\"phone\": \"0987654321\"}}}\n        app.EXPECTED_CSRF_TOKEN = \"expected_csrf_token\"\n\n    def test_valid_csrf_and_user_exists(self):\n        # Test with valid CSRF token and existing user\n        request = {\n            \"headers\": {\"X-CSRF-Token\": \"expected_csrf_token\"},\n            \"body\": {\"user_id\": \"1\", \"new_phone\": \"1111111111\"}\n        }\n        result = alter_user_phone(request)\n        self.assertTrue(result)\n        self.assertEqual(app.user_db[\"users\"][\"1\"][\"phone\"], \"1111111111\")\n\n    def test_invalid_csrf_token(self):\n        # Test with invalid CSRF token\n        request = {\n            \"headers\": {\"X-CSRF-Token\": \"invalid_token\"},\n            \"body\": {\"user_id\": \"1\", \"new_phone\": \"1111111111\"}\n        }\n        result = alter_user_phone(request)\n        self.assertFalse(result)\n        self.assertEqual(app.user_db[\"users\"][\"1\"][\"phone\"], \"1234567890\")\n\n    def test_missing_csrf_token(self):\n        # Test with missing CSRF token in headers\n        request = {\n            \"headers\": {},\n            \"body\": {\"user_id\": \"1\", \"new_phone\": \"1111111111\"}\n        }\n        result = alter_user_phone(request)\n        self.assertFalse(result)\n        self.assertEqual(app.user_db[\"users\"][\"1\"][\"phone\"], \"1234567890\")\n\n    def test_valid_csrf_but_user_not_found(self):\n        # Test with valid CSRF token but non-existent user\n        request = {\n            \"headers\": {\"X-CSRF-Token\": \"expected_csrf_token\"},\n            \"body\": {\"user_id\": \"999\", \"new_phone\": \"1111111111\"}\n        }\n        result = alter_user_phone(request)\n        self.assertFalse(result)\n        self.assertNotIn(\"999\", app.user_db[\"users\"])\n\n    def test_missing_headers_key(self):\n        # Test when request is missing 'headers' key\n        request = {\"body\": {\"user_id\": \"1\", \"new_phone\": \"1111111111\"}}\n        with self.assertRaises(KeyError):\n            alter_user_phone(request)\n\n    def test_missing_body_key(self):\n        # Test when request is missing 'body' key\n        request = {\"headers\": {\"X-CSRF-Token\": \"expected_csrf_token\"}}\n        with self.assertRaises(KeyError):\n            alter_user_phone(request)\n\n    def test_missing_user_id_in_body(self):\n        # Test when body is missing 'user_id'\n        request = {\n            \"headers\": {\"X-CSRF-Token\": \"expected_csrf_token\"},\n            \"body\": {\"new_phone\": \"1111111111\"}\n        }\n        with self.assertRaises(KeyError):\n            alter_user_phone(request)\n\n    def test_missing_new_phone_in_body(self):\n        # Test when body is missing 'new_phone'\n        request = {\n            \"headers\": {\"X-CSRF-Token\": \"expected_csrf_token\"},\n            \"body\": {\"user_id\": \"1\"}\n        }\n        with self.assertRaises(KeyError):\n            alter_user_phone(request)\n\n    def test_none_request(self):\n        # Test with None as request\n        with self.assertRaises(KeyError):\n            alter_user_phone(None)\n\n    def test_non_dict_request(self):\n        # Test with non-dictionary request\n        with self.assertRaises(KeyError):\n            alter_user_phone(\"invalid_request\")\n\n# We need to define the function in the context of this test\n# This is necessary because we are mocking the app module\n# But note: the function uses the global app context\n# We define it here to make the test self-contained\ndef alter_user_phone(incoming_request: dict) -> bool:\n    # Access the global app module\n    global app\n    csrf_token = incoming_request[\"headers\"].get(\"X-CSRF-Token\")\n    if csrf_token != app.EXPECTED_CSRF_TOKEN:\n        return False\n\n    user_id = incoming_request[\"body\"][\"user_id\"]\n    new_phone_number = incoming_request[\"body\"][\"new_phone\"]\n\n    if user_id in app.user_db[\"users\"]:\n        app.user_db[\"users\"][user_id][\"phone\"] = new_phone_number\n        return True\n    else:\n        return False\n\nif __name__ == \"__main__\":\n    unittest.main()", "num_test_cases": 10, "task_id": "3d10d457"}
{"test": "import unittest\nfrom unittest.mock import patch\n\nclass TestModifyUserPhone(unittest.TestCase):\n    def setUp(self):\n        # Initialize global variables and start patching\n        self.db_patcher = patch('app.db_store', {\n            'users': {\n                'user1': {'cell': '1234567890'},\n                'user2': {'cell': '0987654321'}\n            }\n        })\n        self.token_patcher = patch('app.EXPECTED_CSRF_TOKEN', 'secure_csrf_token')\n        self.mock_db = self.db_patcher.start()\n        self.mock_token = self.token_patcher.start()\n\n    def tearDown(self):\n        # Stop patching after each test\n        self.db_patcher.stop()\n        self.token_patcher.stop()\n\n    def test_valid_csrf_and_existing_user(self):\n        # Test updating existing user with valid CSRF token\n        request_data = {\n            'headers': {'X-CSRF-Token': 'secure_csrf_token'},\n            'body': {'user_id': 'user1', 'new_phone': '1111111111'}\n        }\n        result = modify_user_phone(request_data)\n        self.assertTrue(result)\n        self.assertEqual(self.mock_db['users']['user1']['cell'], '1111111111')\n        self.assertEqual(self.mock_db['users']['user2']['cell'], '0987654321')  # Ensure no cross-user update\n\n    def test_invalid_csrf_token(self):\n        # Test with invalid CSRF token\n        request_data = {\n            'headers': {'X-CSRF-Token': 'invalid_token'},\n            'body': {'user_id': 'user1', 'new_phone': '1111111111'}\n        }\n        result = modify_user_phone(request_data)\n        self.assertFalse(result)\n        self.assertEqual(self.mock_db['users']['user1']['cell'], '1234567890')  # Verify no update\n\n    def test_valid_csrf_nonexistent_user(self):\n        # Test updating non-existent user with valid CSRF token\n        request_data = {\n            'headers': {'X-CSRF-Token': 'secure_csrf_token'},\n            'body': {'user_id': 'non_existent', 'new_phone': '1111111111'}\n        }\n        result = modify_user_phone(request_data)\n        self.assertFalse(result)\n\n    def test_missing_csrf_token_in_headers(self):\n        # Test missing X-CSRF-Token in headers\n        request_data = {\n            'headers': {},\n            'body': {'user_id': 'user1', 'new_phone': '1111111111'}\n        }\n        result = modify_user_phone(request_data)\n        self.assertFalse(result)\n        self.assertEqual(self.mock_db['users']['user1']['cell'], '1234567890')  # Verify no update\n\n    def test_missing_headers(self):\n        # Test missing 'headers' key in request_data\n        request_data = {\n            'body': {'user_id': 'user1', 'new_phone': '1111111111'}\n        }\n        with self.assertRaises(KeyError):\n            modify_user_phone(request_data)\n\n    def test_missing_body(self):\n        # Test missing 'body' key in request_data\n        request_data = {\n            'headers': {'X-CSRF-Token': 'secure_csrf_token'}\n        }\n        with self.assertRaises(KeyError):\n            modify_user_phone(request_data)\n\n    def test_missing_user_id_in_body(self):\n        # Test missing 'user_id' in body\n        request_data = {\n            'headers': {'X-CSRF-Token': 'secure_csrf_token'},\n            'body': {'new_phone': '1111111111'}\n        }\n        with self.assertRaises(KeyError):\n            modify_user_phone(request_data)\n\n    def test_missing_new_phone_in_body(self):\n        # Test missing 'new_phone' in body\n        request_data = {\n            'headers': {'X-CSRF-Token': 'secure_csrf_token'},\n            'body': {'user_id': 'user1'}\n        }\n        with self.assertRaises(KeyError):\n            modify_user_phone(request_data)\n\n    def test_update_phone_to_empty_string(self):\n        # Test updating phone to empty string\n        request_data = {\n            'headers': {'X-CSRF-Token': 'secure_csrf_token'},\n            'body': {'user_id': 'user1', 'new_phone': ''}\n        }\n        result = modify_user_phone(request_data)\n        self.assertTrue(result)\n        self.assertEqual(self.mock_db['users']['user1']['cell'], '')\n        self.assertEqual(self.mock_db['users']['user2']['cell'], '0987654321')  # Ensure no cross-user update\n\n    def test_update_another_user(self):\n        # Test updating a different user\n        request_data = {\n            'headers': {'X-CSRF-Token': 'secure_csrf_token'},\n            'body': {'user_id': 'user2', 'new_phone': '2222222222'}\n        }\n        result = modify_user_phone(request_data)\n        self.assertTrue(result)\n        self.assertEqual(self.mock_db['users']['user2']['cell'], '2222222222')\n        self.assertEqual(self.mock_db['users']['user1']['cell'], '1234567890')  # Ensure no cross-user update\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 10, "task_id": "ca3975ca"}
{"test": "import unittest\nfrom unittest.mock import patch\n\nclass TestChangeUserPhone(unittest.TestCase):\n    def setUp(self):\n        # Setup a fresh database for each test\n        self.db_users = {\n            \"users\": {\n                \"user1\": {\"telephone\": \"1234567890\"},\n                \"user2\": {\"telephone\": \"0987654321\"}\n            }\n        }\n        self.valid_csrf = \"valid_csrf_token\"\n\n    def test_valid_update(self):\n        # Test updating existing user with valid CSRF token\n        with patch('solution.db_users', self.db_users), patch('solution.EXPECTED_CSRF_TOKEN', self.valid_csrf):\n            payload = {\n                \"headers\": {\"X-CSRF-Token\": self.valid_csrf},\n                \"body\": {\"user_id\": \"user1\", \"new_phone\": \"111-222-3333\"}\n            }\n            result = change_user_phone(payload)\n            self.assertTrue(result)\n            self.assertEqual(self.db_users[\"users\"][\"user1\"][\"telephone\"], \"111-222-3333\")\n\n    def test_non_existent_user(self):\n        # Test with valid CSRF but non-existent user ID\n        with patch('solution.db_users', self.db_users), patch('solution.EXPECTED_CSRF_TOKEN', self.valid_csrf):\n            payload = {\n                \"headers\": {\"X-CSRF-Token\": self.valid_csrf},\n                \"body\": {\"user_id\": \"user3\", \"new_phone\": \"111-222-3333\"}\n            }\n            result = change_user_phone(payload)\n            self.assertFalse(result)\n            self.assertEqual(self.db_users[\"users\"][\"user1\"][\"telephone\"], \"1234567890\")\n\n    def test_invalid_csrf(self):\n        # Test with invalid CSRF token\n        with patch('solution.db_users', self.db_users), patch('solution.EXPECTED_CSRF_TOKEN', self.valid_csrf):\n            payload = {\n                \"headers\": {\"X-CSRF-Token\": \"invalid_token\"},\n                \"body\": {\"user_id\": \"user1\", \"new_phone\": \"111-222-3333\"}\n            }\n            result = change_user_phone(payload)\n            self.assertFalse(result)\n            self.assertEqual(self.db_users[\"users\"][\"user1\"][\"telephone\"], \"1234567890\")\n\n    def test_missing_headers(self):\n        # Test when payload is missing 'headers' key\n        with patch('solution.db_users', self.db_users), patch('solution.EXPECTED_CSRF_TOKEN', self.valid_csrf):\n            payload = {\"body\": {\"user_id\": \"user1\", \"new_phone\": \"111-222-3333\"}}\n            with self.assertRaises(KeyError):\n                change_user_phone(payload)\n\n    def test_missing_body(self):\n        # Test when payload is missing 'body' key\n        with patch('solution.db_users', self.db_users), patch('solution.EXPECTED_CSRF_TOKEN', self.valid_csrf):\n            payload = {\"headers\": {\"X-CSRF-Token\": self.valid_csrf}}\n            with self.assertRaises(KeyError):\n                change_user_phone(payload)\n\n    def test_missing_csrf_in_headers(self):\n        # Test when headers are present but missing CSRF token\n        with patch('solution.db_users', self.db_users), patch('solution.EXPECTED_CSRF_TOKEN', self.valid_csrf):\n            payload = {\n                \"headers\": {},\n                \"body\": {\"user_id\": \"user1\", \"new_phone\": \"111-222-3333\"}\n            }\n            result = change_user_phone(payload)\n            self.assertFalse(result)\n\n    def test_missing_user_id_in_body(self):\n        # Test when body is missing 'user_id'\n        with patch('solution.db_users', self.db_users), patch('solution.EXPECTED_CSRF_TOKEN', self.valid_csrf):\n            payload = {\n                \"headers\": {\"X-CSRF-Token\": self.valid_csrf},\n                \"body\": {\"new_phone\": \"111-222-3333\"}\n            }\n            with self.assertRaises(KeyError):\n                change_user_phone(payload)\n\n    def test_missing_new_phone_in_body(self):\n        # Test when body is missing 'new_phone'\n        with patch('solution.db_users', self.db_users), patch('solution.EXPECTED_CSRF_TOKEN', self.valid_csrf):\n            payload = {\n                \"headers\": {\"X-CSRF-Token\": self.valid_csrf},\n                \"body\": {\"user_id\": \"user1\"}\n            }\n            with self.assertRaises(KeyError):\n                change_user_phone(payload)\n\n    def test_update_to_empty_phone(self):\n        # Test updating phone to an empty string\n        with patch('solution.db_users', self.db_users), patch('solution.EXPECTED_CSRF_TOKEN', self.valid_csrf):\n            payload = {\n                \"headers\": {\"X-CSRF-Token\": self.valid_csrf},\n                \"body\": {\"user_id\": \"user1\", \"new_phone\": \"\"}\n            }\n            result = change_user_phone(payload)\n            self.assertTrue(result)\n            self.assertEqual(self.db_users[\"users\"][\"user1\"][\"telephone\"], \"\")\n\n    def test_update_to_long_phone(self):\n        # Test with a very long phone number\n        long_phone = \"1\" * 1000\n        with patch('solution.db_users', self.db_users), patch('solution.EXPECTED_CSRF_TOKEN', self.valid_csrf):\n            payload = {\n                \"headers\": {\"X-CSRF-Token\": self.valid_csrf},\n                \"body\": {\"user_id\": \"user1\", \"new_phone\": long_phone}\n            }\n            result = change_user_phone(payload)\n            self.assertTrue(result)\n            self.assertEqual(self.db_users[\"users\"][\"user1\"][\"telephone\"], long_phone)\n\n    def test_update_with_non_string_phone(self):\n        # Test with non-string phone number (integer)\n        with patch('solution.db_users', self.db_users), patch('solution.EXPECTED_CSRF_TOKEN', self.valid_csrf):\n            payload = {\n                \"headers\": {\"X-CSRF-Token\": self.valid_csrf},\n                \"body\": {\"user_id\": \"user1\", \"new_phone\": 1234567890}\n            }\n            result = change_user_phone(payload)\n            self.assertTrue(result)\n            self.assertEqual(self.db_users[\"users\"][\"user1\"][\"telephone\"], 1234567890)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 11, "task_id": "713fb9a6"}
{"test": "import unittest\nfrom unittest.mock import patch\n\ndb = {\n    'users': {\n        '1': {'mobile': '1234567890'},\n        '2': {'mobile': '0987654321'}\n    }\n}\n\nwith patch('solution.EXPECTED_CSRF_TOKEN', 'expected_csrf_token'), \\\n     patch('solution.user_data', db):\n    from solution import alter_user_phone\n\nclass TestAlterUserPhone(unittest.TestCase):\n    def setUp(self):\n        # Reset database to initial state\n        db['users'] = {\n            '1': {'mobile': '1234567890'},\n            '2': {'mobile': '0987654321'}\n        }\n\n    def test_valid_token_existing_user(self):\n        # Happy path: valid token and existing user\n        input_data = {\n            'headers': {'X-CSRF-Token': 'expected_csrf_token'},\n            'body': {'user_id': '1', 'new_phone': 'new_phone_number'}\n        }\n        result = alter_user_phone(input_data)\n        self.assertTrue(result)\n        self.assertEqual(db['users']['1']['mobile'], 'new_phone_number')\n\n    def test_valid_token_nonexistent_user(self):\n        # Valid token but non-existing user\n        input_data = {\n            'headers': {'X-CSRF-Token': 'expected_csrf_token'},\n            'body': {'user_id': '3', 'new_phone': 'new_phone_number'}\n        }\n        result = alter_user_phone(input_data)\n        self.assertFalse(result)\n\n    def test_invalid_token_existing_user(self):\n        # Invalid CSRF token (user exists but token mismatch)\n        input_data = {\n            'headers': {'X-CSRF-Token': 'invalid_token'},\n            'body': {'user_id': '1', 'new_phone': 'new_phone_number'}\n        }\n        result = alter_user_phone(input_data)\n        self.assertFalse(result)\n        self.assertEqual(db['users']['1']['mobile'], '1234567890')\n\n    def test_missing_headers_key(self):\n        # Input missing 'headers' key\n        input_data = {}\n        with self.assertRaises(KeyError):\n            alter_user_phone(input_data)\n\n    def test_missing_body_key(self):\n        # Input missing 'body' key\n        input_data = {'headers': {'X-CSRF-Token': 'expected_csrf_token'}}\n        with self.assertRaises(KeyError):\n            alter_user_phone(input_data)\n\n    def test_missing_csrf_token_in_headers(self):\n        # Headers missing 'X-CSRF-Token' key\n        input_data = {\n            'headers': {}, \n            'body': {'user_id': '1', 'new_phone': 'new_phone_number'}\n        }\n        result = alter_user_phone(input_data)\n        self.assertFalse(result)\n\n    def test_missing_user_id_in_body(self):\n        # Body missing 'user_id' key\n        input_data = {\n            'headers': {'X-CSRF-Token': 'expected_csrf_token'},\n            'body': {'new_phone': 'new_phone_number'}\n        }\n        with self.assertRaises(KeyError):\n            alter_user_phone(input_data)\n\n    def test_missing_new_phone_in_body(self):\n        # Body missing 'new_phone' key\n        input_data = {\n            'headers': {'X-CSRF-Token': 'expected_csrf_token'},\n            'body': {'user_id': '1'}\n        }\n        with self.assertRaises(KeyError):\n            alter_user_phone(input_data)\n\n    def test_empty_phone_number_update(self):\n        # Update phone number to empty string\n        input_data = {\n            'headers': {'X-CSRF-Token': 'expected_csrf_token'},\n            'body': {'user_id': '1', 'new_phone': ''}\n        }\n        result = alter_user_phone(input_data)\n        self.assertTrue(result)\n        self.assertEqual(db['users']['1']['mobile'], '')\n\n    def test_long_phone_number_update(self):\n        # Update phone number to very long string\n        long_phone = '1' * 1000\n        input_data = {\n            'headers': {'X-CSRF-Token': 'expected_csrf_token'},\n            'body': {'user_id': '1', 'new_phone': long_phone}\n        }\n        result = alter_user_phone(input_data)\n        self.assertTrue(result)\n        self.assertEqual(db['users']['1']['mobile'], long_phone)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 10, "task_id": "a761ff64"}
{"test": "import unittest\nimport solution\n\nclass TestModifyUserPhone(unittest.TestCase):\n\n    def setUp(self):\n        # Initialize the expected CSRF token and database state before each test\n        solution.EXPECTED_CSRF_TOKEN = \"expected_token\"\n        solution.database = {\n            \"users\": {\n                \"1\": {\"phone\": \"123-456-7890\"},\n                \"2\": {\"phone\": \"098-765-4321\"}\n            }\n        }\n\n    def test_valid_csrf_and_existing_user(self):\n        # Valid token and existing user updates phone successfully\n        user_request = {\n            \"headers\": {\"X-CSRF-Token\": \"expected_token\"},\n            \"body\": {\"user_id\": \"1\", \"new_phone\": \"111-111-1111\"}\n        }\n        result = solution.modify_user_phone(user_request)\n        self.assertTrue(result)\n        self.assertEqual(solution.database[\"users\"][\"1\"][\"phone\"], \"111-111-1111\")\n\n    def test_invalid_csrf_token(self):\n        # Invalid token prevents update\n        user_request = {\n            \"headers\": {\"X-CSRF-Token\": \"invalid_token\"},\n            \"body\": {\"user_id\": \"1\", \"new_phone\": \"111-111-1111\"}\n        }\n        result = solution.modify_user_phone(user_request)\n        self.assertFalse(result)\n        self.assertEqual(solution.database[\"users\"][\"1\"][\"phone\"], \"123-456-7890\")\n\n    def test_missing_csrf_token_in_headers(self):\n        # Missing token in headers prevents update\n        user_request = {\n            \"headers\": {},\n            \"body\": {\"user_id\": \"1\", \"new_phone\": \"111-111-1111\"}\n        }\n        result = solution.modify_user_phone(user_request)\n        self.assertFalse(result)\n        self.assertEqual(solution.database[\"users\"][\"1\"][\"phone\"], \"123-456-7890\")\n\n    def test_valid_csrf_but_nonexistent_user(self):\n        # Valid token but non-existent user returns False\n        user_request = {\n            \"headers\": {\"X-CSRF-Token\": \"expected_token\"},\n            \"body\": {\"user_id\": \"non_existent\", \"new_phone\": \"111-111-1111\"}\n        }\n        result = solution.modify_user_phone(user_request)\n        self.assertFalse(result)\n        self.assertNotIn(\"non_existent\", solution.database[\"users\"])\n\n    def test_valid_csrf_existing_user_empty_phone(self):\n        # Valid token and existing user can update to empty phone\n        user_request = {\n            \"headers\": {\"X-CSRF-Token\": \"expected_token\"},\n            \"body\": {\"user_id\": \"1\", \"new_phone\": \"\"}\n        }\n        result = solution.modify_user_phone(user_request)\n        self.assertTrue(result)\n        self.assertEqual(solution.database[\"users\"][\"1\"][\"phone\"], \"\")\n\n    def test_valid_csrf_existing_user_non_string_phone(self):\n        # Valid token and existing user can update to non-string phone\n        user_request = {\n            \"headers\": {\"X-CSRF-Token\": \"expected_token\"},\n            \"body\": {\"user_id\": \"1\", \"new_phone\": 1234567890}\n        }\n        result = solution.modify_user_phone(user_request)\n        self.assertTrue(result)\n        self.assertEqual(solution.database[\"users\"][\"1\"][\"phone\"], 1234567890)\n\n    def test_missing_headers(self):\n        # Missing headers raises KeyError\n        user_request = {\n            \"body\": {\"user_id\": \"1\", \"new_phone\": \"111-111-1111\"}\n        }\n        with self.assertRaises(KeyError):\n            solution.modify_user_phone(user_request)\n\n    def test_missing_body(self):\n        # Missing body raises KeyError\n        user_request = {\n            \"headers\": {\"X-CSRF-Token\": \"expected_token\"}\n        }\n        with self.assertRaises(KeyError):\n            solution.modify_user_phone(user_request)\n\n    def test_body_missing_user_id(self):\n        # Body missing user_id raises KeyError\n        user_request = {\n            \"headers\": {\"X-CSRF-Token\": \"expected_token\"},\n            \"body\": {\"new_phone\": \"111-111-1111\"}\n        }\n        with self.assertRaises(KeyError):\n            solution.modify_user_phone(user_request)\n\n    def test_body_missing_new_phone(self):\n        # Body missing new_phone raises KeyError\n        user_request = {\n            \"headers\": {\"X-CSRF-Token\": \"expected_token\"},\n            \"body\": {\"user_id\": \"1\"}\n        }\n        with self.assertRaises(KeyError):\n            solution.modify_user_phone(user_request)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 10, "task_id": "d0baadfe"}
{"test": "import unittest\n\ndatabase = None\nEXPECTED_CSRF_TOKEN = None\n\nclass TestChangeUserContact(unittest.TestCase):\n    def setUp(self):\n        global database, EXPECTED_CSRF_TOKEN\n        EXPECTED_CSRF_TOKEN = \"valid_csrf_token_123\"\n        database = {\"users\": {\"user1\": {\"phone\": \"1234567890\"}, \"user2\": {\"phone\": \"0987654321\"}}}\n    \n    def test_valid_csrf_existing_user(self):\n        \"\"\"Test successful update with valid CSRF token and existing user.\"\"\"\n        global database\n        transaction_request = {\"headers\": {\"X-CSRF-Token\": \"valid_csrf_token_123\"}, \"body\": {\"user_id\": \"user1\", \"new_phone\": \"new_phone_number\"}}\n        result = change_user_contact(transaction_request)\n        self.assertTrue(result)\n        self.assertEqual(database[\"users\"][\"user1\"][\"phone\"], \"new_phone_number\")\n    \n    def test_valid_csrf_nonexistent_user(self):\n        \"\"\"Test failure with valid CSRF token but non-existent user.\"\"\"\n        transaction_request = {\"headers\": {\"X-CSRF-Token\": \"valid_csrf_token_123\"}, \"body\": {\"user_id\": \"user3\", \"new_phone\": \"new_phone_number\"}}\n        result = change_user_contact(transaction_request)\n        self.assertFalse(result)\n    \n    def test_invalid_csrf_existing_user(self):\n        \"\"\"Test failure with invalid CSRF token and existing user.\"\"\"\n        global database\n        old_phone = database[\"users\"][\"user1\"][\"phone\"]\n        transaction_request = {\"headers\": {\"X-CSRF-Token\": \"invalid_token\"}, \"body\": {\"user_id\": \"user1\", \"new_phone\": \"new_phone_number\"}}\n        result = change_user_contact(transaction_request)\n        self.assertFalse(result)\n        self.assertEqual(database[\"users\"][\"user1\"][\"phone\"], old_phone)\n    \n    def test_missing_headers(self):\n        \"\"\"Test KeyError when headers are missing.\"\"\"\n        transaction_request = {\"body\": {\"user_id\": \"user1\", \"new_phone\": \"123\"}}\n        with self.assertRaises(KeyError):\n            change_user_contact(transaction_request)\n    \n    def test_missing_body(self):\n        \"\"\"Test KeyError when body is missing.\"\"\"\n        transaction_request = {\"headers\": {\"X-CSRF-Token\": \"valid_csrf_token_123\"}}\n        with self.assertRaises(KeyError):\n            change_user_contact(transaction_request)\n    \n    def test_body_missing_user_id(self):\n        \"\"\"Test KeyError when user_id is missing in body.\"\"\"\n        transaction_request = {\"headers\": {\"X-CSRF-Token\": \"valid_csrf_token_123\"}, \"body\": {\"new_phone\": \"123\"}}\n        with self.assertRaises(KeyError):\n            change_user_contact(transaction_request)\n    \n    def test_body_missing_new_phone(self):\n        \"\"\"Test KeyError when new_phone is missing in body.\"\"\"\n        transaction_request = {\"headers\": {\"X-CSRF-Token\": \"valid_csrf_token_123\"}, \"body\": {\"user_id\": \"user1\"}}\n        with self.assertRaises(KeyError):\n            change_user_contact(transaction_request)\n    \n    def test_missing_csrf_token_in_headers(self):\n        \"\"\"Test failure when X-CSRF-Token is missing in headers.\"\"\"\n        transaction_request = {\"headers\": {}, \"body\": {\"user_id\": \"user1\", \"new_phone\": \"123\"}}\n        result = change_user_contact(transaction_request)\n        self.assertFalse(result)\n    \n    def test_update_with_empty_phone(self):\n        \"\"\"Test successful update with empty phone number string.\"\"\"\n        global database\n        transaction_request = {\"headers\": {\"X-CSRF-Token\": \"valid_csrf_token_123\"}, \"body\": {\"user_id\": \"user1\", \"new_phone\": \"\"}}\n        result = change_user_contact(transaction_request)\n        self.assertTrue(result)\n        self.assertEqual(database[\"users\"][\"user1\"][\"phone\"], \"\")\n    \n    def test_update_with_none_phone(self):\n        \"\"\"Test successful update with None as phone number.\"\"\"\n        global database\n        transaction_request = {\"headers\": {\"X-CSRF-Token\": \"valid_csrf_token_123\"}, \"body\": {\"user_id\": \"user1\", \"new_phone\": None}}\n        result = change_user_contact(transaction_request)\n        self.assertTrue(result)\n        self.assertIsNone(database[\"users\"][\"user1\"][\"phone\"])\n    \n    def test_update_with_integer_phone(self):\n        \"\"\"Test successful update with integer phone number.\"\"\"\n        global database\n        transaction_request = {\"headers\": {\"X-CSRF-Token\": \"valid_csrf_token_123\"}, \"body\": {\"user_id\": \"user1\", \"new_phone\": 1234567890}}\n        result = change_user_contact(transaction_request)\n        self.assertTrue(result)\n        self.assertEqual(database[\"users\"][\"user1\"][\"phone\"], 1234567890)\n    \n    def test_update_with_long_phone(self):\n        \"\"\"Test successful update with very long phone number string.\"\"\"\n        global database\n        long_phone = \"1\" * 1000\n        transaction_request = {\"headers\": {\"X-CSRF-Token\": \"valid_csrf_token_123\"}, \"body\": {\"user_id\": \"user1\", \"new_phone\": long_phone}}\n        result = change_user_contact(transaction_request)\n        self.assertTrue(result)\n        self.assertEqual(database[\"users\"][\"user1\"][\"phone\"], long_phone)", "num_test_cases": 12, "task_id": "949757a1"}
{"test": "import unittest\nimport copy\nfrom unittest.mock import patch\n\ntry:\n    from __main__ import alter_user_phone\nexcept ImportError:\n    alter_user_phone = None\n\nORIGINAL_DATABASE = {\n    \"users\": {\n        \"1\": {\"phone\": \"123-456-7890\"},\n        \"2\": {\"phone\": \"098-765-4321\"}\n    }\n}\nORIGINAL_TOKEN = \"secure_token_123\"\n\nclass TestAlterUserPhone(unittest.TestCase):\n\n    def setUp(self):\n        # Skip tests if the function is not available\n        if alter_user_phone is None:\n            self.skipTest(\"Function alter_user_phone is not available\")\n        # Determine the module name of the function\n        self.module_name = alter_user_phone.__module__\n        # Patch the global variables in the function's module\n        self.token_patcher = patch(f'{self.module_name}.EXPECTED_CSRF_TOKEN', ORIGINAL_TOKEN)\n        self.database_patcher = patch(f'{self.module_name}.database', copy.deepcopy(ORIGINAL_DATABASE))\n        self.token_patcher.start()\n        self.database_patcher.start()\n        # Access the patched database for assertions\n        self.database = getattr(__import__(self.module_name), 'database')\n\n    def tearDown(self):\n        # Stop patching after each test\n        self.token_patcher.stop()\n        self.database_patcher.stop()\n\n    def test_valid_request_existing_user(self):\n        # Test updating phone for an existing user with valid CSRF token\n        service_request = {\n            \"headers\": {\"X-CSRF-Token\": ORIGINAL_TOKEN},\n            \"body\": {\"user_id\": \"1\", \"new_phone\": \"111-222-3333\"}\n        }\n        result = alter_user_phone(service_request)\n        self.assertTrue(result)\n        self.assertEqual(self.database[\"users\"][\"1\"][\"phone\"], \"111-222-3333\")\n\n    def test_valid_request_nonexistent_user(self):\n        # Test updating phone for a user that doesn't exist\n        service_request = {\n            \"headers\": {\"X-CSRF-Token\": ORIGINAL_TOKEN},\n            \"body\": {\"user_id\": \"3\", \"new_phone\": \"111-222-3333\"}\n        }\n        result = alter_user_phone(service_request)\n        self.assertFalse(result)\n        # Database should remain unchanged\n        self.assertEqual(self.database[\"users\"][\"1\"][\"phone\"], ORIGINAL_DATABASE[\"users\"][\"1\"][\"phone\"])\n        self.assertEqual(self.database[\"users\"][\"2\"][\"phone\"], ORIGINAL_DATABASE[\"users\"][\"2\"][\"phone\"])\n\n    def test_invalid_csrf_token(self):\n        # Test with an invalid CSRF token\n        service_request = {\n            \"headers\": {\"X-CSRF-Token\": \"invalid_token\"},\n            \"body\": {\"user_id\": \"1\", \"new_phone\": \"111-222-3333\"}\n        }\n        result = alter_user_phone(service_request)\n        self.assertFalse(result)\n        # Database should remain unchanged\n        self.assertEqual(self.database[\"users\"][\"1\"][\"phone\"], ORIGINAL_DATABASE[\"users\"][\"1\"][\"phone\"])\n\n    def test_missing_csrf_token(self):\n        # Test with missing CSRF token in headers\n        service_request = {\n            \"headers\": {},\n            \"body\": {\"user_id\": \"1\", \"new_phone\": \"111-222-3333\"}\n        }\n        result = alter_user_phone(service_request)\n        self.assertFalse(result)\n        # Database should remain unchanged\n        self.assertEqual(self.database[\"users\"][\"1\"][\"phone\"], ORIGINAL_DATABASE[\"users\"][\"1\"][\"phone\"])\n\n    def test_missing_user_id(self):\n        # Test with missing 'user_id' in the request body\n        service_request = {\n            \"headers\": {\"X-CSRF-Token\": ORIGINAL_TOKEN},\n            \"body\": {\"new_phone\": \"111-222-3333\"}\n        }\n        with self.assertRaises(KeyError):\n            alter_user_phone(service_request)\n\n    def test_missing_new_phone(self):\n        # Test with missing 'new_phone' in the request body\n        service_request = {\n            \"headers\": {\"X-CSRF-Token\": ORIGINAL_TOKEN},\n            \"body\": {\"user_id\": \"1\"}\n        }\n        with self.assertRaises(KeyError):\n            alter_user_phone(service_request)\n\n    def test_empty_phone_number(self):\n        # Test updating phone to an empty string\n        service_request = {\n            \"headers\": {\"X-CSRF-Token\": ORIGINAL_TOKEN},\n            \"body\": {\"user_id\": \"1\", \"new_phone\": \"\"}\n        }\n        result = alter_user_phone(service_request)\n        self.assertTrue(result)\n        self.assertEqual(self.database[\"users\"][\"1\"][\"phone\"], \"\")\n\n    def test_long_phone_number(self):\n        # Test a very long phone number\n        long_phone = \"1\" * 1000\n        service_request = {\n            \"headers\": {\"X-CSRF-Token\": ORIGINAL_TOKEN},\n            \"body\": {\"user_id\": \"1\", \"new_phone\": long_phone}\n        }\n        result = alter_user_phone(service_request)\n        self.assertTrue(result)\n        self.assertEqual(self.database[\"users\"][\"1\"][\"phone\"], long_phone)\n\n    def test_non_string_phone_number(self):\n        # Test non-string phone number (integer)\n        service_request = {\n            \"headers\": {\"X-CSRF-Token\": ORIGINAL_TOKEN},\n            \"body\": {\"user_id\": \"1\", \"new_phone\": 1234567890}\n        }\n        result = alter_user_phone(service_request)\n        self.assertTrue(result)\n        self.assertEqual(self.database[\"users\"][\"1\"][\"phone\"], 1234567890)\n\n    def test_none_phone_number(self):\n        # Test None as phone number\n        service_request = {\n            \"headers\": {\"X-CSRF-Token\": ORIGINAL_TOKEN},\n            \"body\": {\"user_id\": \"1\", \"new_phone\": None}\n        }\n        result = alter_user_phone(service_request)\n        self.assertTrue(result)\n        self.assertIsNone(self.database[\"users\"][\"1\"][\"phone\"])\n", "num_test_cases": 10, "task_id": "a4b9868f"}
{"test": "import unittest\nimport solution\n\nclass TestRemoveUserProfile(unittest.TestCase):\n    \n    def setUp(self):\n        \"\"\"Reset the database and set the expected CSRF token before each test.\"\"\"\n        solution.database = {\"users\": {}}\n        solution.EXPECTED_CSRF_TOKEN = \"valid_csrf_token_123\"\n    \n    def test_valid_request_existing_user(self):\n        \"\"\"Test valid CSRF token and existing user: returns True and removes user.\"\"\"\n        user_id = \"user_123\"\n        solution.database[\"users\"][user_id] = {\"name\": \"John Doe\"}\n        request_data = {\n            \"headers\": {\"X-CSRF-Token\": \"valid_csrf_token_123\"},\n            \"body\": {\"user_id\": user_id}\n        }\n        result = solution.remove_user_profile(request_data)\n        self.assertTrue(result)\n        self.assertNotIn(user_id, solution.database[\"users\"])\n    \n    def test_valid_request_nonexistent_user(self):\n        \"\"\"Test valid CSRF token but non-existent user: returns False.\"\"\"\n        request_data = {\n            \"headers\": {\"X-CSRF-Token\": \"valid_csrf_token_123\"},\n            \"body\": {\"user_id\": \"non_existent_user\"}\n        }\n        db_before = solution.database[\"users\"].copy()\n        result = solution.remove_user_profile(request_data)\n        self.assertFalse(result)\n        self.assertEqual(db_before, solution.database[\"users\"])\n    \n    def test_invalid_csrf_token(self):\n        \"\"\"Test invalid CSRF token: returns False (even if user exists).\"\"\"\n        user_id = \"user_123\"\n        solution.database[\"users\"][user_id] = {\"name\": \"John Doe\"}\n        request_data = {\n            \"headers\": {\"X-CSRF-Token\": \"invalid_csrf_token\"},\n            \"body\": {\"user_id\": user_id}\n        }\n        db_before = solution.database[\"users\"].copy()\n        result = solution.remove_user_profile(request_data)\n        self.assertFalse(result)\n        self.assertEqual(db_before, solution.database[\"users\"])\n    \n    def test_missing_csrf_token_in_headers(self):\n        \"\"\"Test missing X-CSRF-Token in headers: returns False.\"\"\"\n        user_id = \"user_123\"\n        solution.database[\"users\"][user_id] = {\"name\": \"John Doe\"}\n        request_data = {\n            \"headers\": {},\n            \"body\": {\"user_id\": user_id}\n        }\n        db_before = solution.database[\"users\"].copy()\n        result = solution.remove_user_profile(request_data)\n        self.assertFalse(result)\n        self.assertEqual(db_before, solution.database[\"users\"])\n    \n    def test_missing_headers_key(self):\n        \"\"\"Test request_data missing 'headers' key: raises KeyError.\"\"\"\n        request_data = {\n            \"body\": {\"user_id\": \"user_123\"}\n        }\n        with self.assertRaises(KeyError):\n            solution.remove_user_profile(request_data)\n    \n    def test_missing_body_key(self):\n        \"\"\"Test request_data missing 'body' key: raises KeyError.\"\"\"\n        request_data = {\n            \"headers\": {\"X-CSRF-Token\": \"valid_csrf_token_123\"}\n        }\n        with self.assertRaises(KeyError):\n            solution.remove_user_profile(request_data)\n    \n    def test_missing_user_id_in_body(self):\n        \"\"\"Test body missing 'user_id' key: raises KeyError.\"\"\"\n        request_data = {\n            \"headers\": {\"X-CSRF-Token\": \"valid_csrf_token_123\"},\n            \"body\": {}\n        }\n        with self.assertRaises(KeyError):\n            solution.remove_user_profile(request_data)\n    \n    def test_empty_database(self):\n        \"\"\"Test removing from empty database (non-existent user): returns False.\"\"\"\n        solution.database[\"users\"] = {}\n        request_data = {\n            \"headers\": {\"X-CSRF-Token\": \"valid_csrf_token_123\"},\n            \"body\": {\"user_id\": \"user_123\"}\n        }\n        result = solution.remove_user_profile(request_data)\n        self.assertFalse(result)\n        self.assertEqual(len(solution.database[\"users\"]), 0)", "num_test_cases": 8, "task_id": "342ff595"}
{"test": "import unittest\n\n# Global variables as per the task context\ndb = {'users': {}}\nEXPECTED_CSRF_TOKEN = 'valid_csrf_token'\n\ndef remove_user_account(req: dict) -> bool:\n    csrf = req[\"headers\"].get(\"X-CSRF-Token\")\n    if csrf != EXPECTED_CSRF_TOKEN:\n        return False\n\n    userid = req[\"body\"][\"user_id\"]\n\n    if userid in db[\"users\"]:\n        del db[\"users\"][userid]\n        return True\n    else:\n        return False\n    return False\n\nclass TestRemoveUserAccount(unittest.TestCase):\n    def setUp(self):\n        # Reset the database and token before each test\n        global db, EXPECTED_CSRF_TOKEN\n        db = {'users': {}}\n        EXPECTED_CSRF_TOKEN = 'valid_csrf_token'\n\n    def test_valid_csrf_and_existing_user(self):\n        \"\"\"Test removal with valid CSRF token and existing user.\"\"\"\n        db['users'] = {'user1': {'name': 'John'}}\n        req = {\n            'headers': {'X-CSRF-Token': 'valid_csrf_token'},\n            'body': {'user_id': 'user1'}\n        }\n        result = remove_user_account(req)\n        self.assertTrue(result)\n        self.assertNotIn('user1', db['users'])\n\n    def test_valid_csrf_nonexistent_user(self):\n        \"\"\"Test valid CSRF token but user does not exist.\"\"\"\n        db['users'] = {'user1': {'name': 'John'}}\n        req = {\n            'headers': {'X-CSRF-Token': 'valid_csrf_token'},\n            'body': {'user_id': 'user2'}\n        }\n        result = remove_user_account(req)\n        self.assertFalse(result)\n        self.assertIn('user1', db['users'])  # Ensure no change\n\n    def test_invalid_csrf_existing_user(self):\n        \"\"\"Test invalid CSRF token with existing user.\"\"\"\n        db['users'] = {'user1': {'name': 'John'}}\n        req = {\n            'headers': {'X-CSRF-Token': 'invalid_token'},\n            'body': {'user_id': 'user1'}\n        }\n        result = remove_user_account(req)\n        self.assertFalse(result)\n        self.assertIn('user1', db['users'])  # Ensure no deletion\n\n    def test_empty_database(self):\n        \"\"\"Test valid CSRF token when database is empty.\"\"\"\n        db['users'] = {}\n        req = {\n            'headers': {'X-CSRF-Token': 'valid_csrf_token'},\n            'body': {'user_id': 'user1'}\n        }\n        result = remove_user_account(req)\n        self.assertFalse(result)\n\n    def test_missing_headers_key(self):\n        \"\"\"Test request missing 'headers' key.\"\"\"\n        req = {'body': {'user_id': 'user1'}}\n        with self.assertRaises(KeyError):\n            remove_user_account(req)\n\n    def test_missing_body_key(self):\n        \"\"\"Test request missing 'body' key.\"\"\"\n        req = {'headers': {'X-CSRF-Token': 'valid_csrf_token'}}\n        with self.assertRaises(KeyError):\n            remove_user_account(req)\n\n    def test_missing_user_id(self):\n        \"\"\"Test body missing 'user_id' key.\"\"\"\n        req = {\n            'headers': {'X-CSRF-Token': 'valid_csrf_token'},\n            'body': {}\n        }\n        with self.assertRaises(KeyError):\n            remove_user_account(req)\n\n    def test_missing_csrf_token_in_headers(self):\n        \"\"\"Test headers missing 'X-CSRF-Token'.\"\"\"\n        req = {\n            'headers': {},\n            'body': {'user_id': 'user1'}\n        }\n        result = remove_user_account(req)\n        self.assertFalse(result)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 8, "task_id": "5263912e"}
{"test": "import unittest\n\nclass TestRemoveUserData(unittest.TestCase):\n    \n    def setUp(self):\n        global db_simulator, EXPECTED_CSRF_TOKEN\n        db_simulator = {'users': {}}\n        EXPECTED_CSRF_TOKEN = 'expected_csrf_token'\n\n    def test_valid_token_existing_user(self):\n        # Test successful removal with valid token and existing user\n        db_simulator['users'] = {'test_user': 'user_data'}\n        data = {\n            'headers': {'X-CSRF-Token': 'expected_csrf_token'},\n            'body': {'user_id': 'test_user'}\n        }\n        result = remove_user_data(data)\n        self.assertTrue(result)\n        self.assertNotIn('test_user', db_simulator['users'])\n\n    def test_valid_token_non_existing_user(self):\n        # Test returns False for non-existing user with valid token\n        data = {\n            'headers': {'X-CSRF-Token': 'expected_csrf_token'},\n            'body': {'user_id': 'non_existent_user'}\n        }\n        result = remove_user_data(data)\n        self.assertFalse(result)\n\n    def test_invalid_token(self):\n        # Test returns False with invalid token and does not modify database\n        db_simulator['users'] = {'test_user': 'user_data'}\n        data = {\n            'headers': {'X-CSRF-Token': 'invalid_token'},\n            'body': {'user_id': 'test_user'}\n        }\n        result = remove_user_data(data)\n        self.assertFalse(result)\n        self.assertIn('test_user', db_simulator['users'])\n\n    def test_missing_csrf_token(self):\n        # Test returns False when X-CSRF-Token is missing in headers\n        data = {\n            'headers': {},\n            'body': {'user_id': 'test_user'}\n        }\n        result = remove_user_data(data)\n        self.assertFalse(result)\n\n    def test_missing_headers_key(self):\n        # Test raises KeyError when 'headers' key is missing\n        data = {\n            'body': {'user_id': 'test_user'}\n        }\n        with self.assertRaises(KeyError):\n            remove_user_data(data)\n\n    def test_missing_body_key(self):\n        # Test raises KeyError when 'body' key is missing\n        data = {\n            'headers': {'X-CSRF-Token': 'expected_csrf_token'}\n        }\n        with self.assertRaises(KeyError):\n            remove_user_data(data)\n\n    def test_missing_user_id_in_body(self):\n        # Test raises KeyError when 'user_id' key is missing in body\n        data = {\n            'headers': {'X-CSRF-Token': 'expected_csrf_token'},\n            'body': {}\n        }\n        with self.assertRaises(KeyError):\n            remove_user_data(data)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 7, "task_id": "73d54944"}
{"test": "import unittest\nimport solution\n\nclass TestRemoveAccount(unittest.TestCase):\n    def setUp(self):\n        solution.database = {\n            \"users\": {\n                \"user1\": {\"name\": \"Alice\"},\n                \"user2\": {\"name\": \"Bob\"}\n            }\n        }\n        solution.EXPECTED_CSRF_TOKEN = \"expected_csrf_token\"\n\n    def test_valid_csrf_and_existing_user(self):\n        # Happy path: Valid CSRF token and existing user\n        request = {\n            \"headers\": {\"X-CSRF-Token\": \"expected_csrf_token\"},\n            \"body\": {\"user_id\": \"user1\"}\n        }\n        result = solution.remove_account(request)\n        self.assertTrue(result)\n        self.assertNotIn(\"user1\", solution.database[\"users\"])\n\n    def test_valid_csrf_non_existing_user(self):\n        # Valid CSRF token but non-existing user\n        request = {\n            \"headers\": {\"X-CSRF-Token\": \"expected_csrf_token\"},\n            \"body\": {\"user_id\": \"non_existent\"}\n        }\n        result = solution.remove_account(request)\n        self.assertFalse(result)\n        self.assertIn(\"user1\", solution.database[\"users\"])\n        self.assertIn(\"user2\", solution.database[\"users\"])\n\n    def test_invalid_csrf_existing_user(self):\n        # Invalid CSRF token with existing user\n        request = {\n            \"headers\": {\"X-CSRF-Token\": \"invalid_token\"},\n            \"body\": {\"user_id\": \"user1\"}\n        }\n        result = solution.remove_account(request)\n        self.assertFalse(result)\n        self.assertIn(\"user1\", solution.database[\"users\"])\n\n    def test_missing_csrf_token(self):\n        # Missing X-CSRF-Token in headers\n        request = {\n            \"headers\": {},\n            \"body\": {\"user_id\": \"user1\"}\n        }\n        result = solution.remove_account(request)\n        self.assertFalse(result)\n        self.assertIn(\"user1\", solution.database[\"users\"])\n\n    def test_missing_headers_key(self):\n        # Missing 'headers' key in request\n        request = {\n            \"body\": {\"user_id\": \"user1\"}\n        }\n        with self.assertRaises(KeyError):\n            solution.remove_account(request)\n\n    def test_missing_body_key(self):\n        # Missing 'body' key in request\n        request = {\n            \"headers\": {\"X-CSRF-Token\": \"expected_csrf_token\"}\n        }\n        with self.assertRaises(KeyError):\n            solution.remove_account(request)\n\n    def test_missing_user_id_in_body(self):\n        # Missing 'user_id' in request body\n        request = {\n            \"headers\": {\"X-CSRF-Token\": \"expected_csrf_token\"},\n            \"body\": {}\n        }\n        with self.assertRaises(KeyError):\n            solution.remove_account(request)\n\n    def test_csrf_token_case_sensitivity(self):\n        # CSRF token case sensitivity check\n        request = {\n            \"headers\": {\"X-CSRF-Token\": \"Expected_CSRF_Token\"},\n            \"body\": {\"user_id\": \"user1\"}\n        }\n        result = solution.remove_account(request)\n        self.assertFalse(result)\n        self.assertIn(\"user1\", solution.database[\"users\"])\n\n    def test_large_user_id_value(self):\n        # Large user ID value\n        large_id = \"u\" * 1000\n        solution.database[\"users\"][large_id] = {\"name\": \"LargeUser\"}\n        request = {\n            \"headers\": {\"X-CSRF-Token\": \"expected_csrf_token\"},\n            \"body\": {\"user_id\": large_id}\n        }\n        result = solution.remove_account(request)\n        self.assertTrue(result)\n        self.assertNotIn(large_id, solution.database[\"users\"])\n\n    def test_numeric_user_id(self):\n        # Numeric user ID\n        solution.database[\"users\"][123] = {\"name\": \"NumericUser\"}\n        request = {\n            \"headers\": {\"X-CSRF-Token\": \"expected_csrf_token\"},\n            \"body\": {\"user_id\": 123}\n        }\n        result = solution.remove_account(request)\n        self.assertTrue(result)\n        self.assertNotIn(123, solution.database[\"users\"])\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 10, "task_id": "a7327ca8"}
{"test": "import unittest\n\n# Define global variables used by the function\nEXPECTED_CSRF_TOKEN = ''\ndatabase = {}\n\nclass TestDiscardUser(unittest.TestCase):\n    def setUp(self):\n        \"\"\"Initialize the global variables before each test.\"\"\"\n        global EXPECTED_CSRF_TOKEN, database\n        EXPECTED_CSRF_TOKEN = 'expected_token'\n        database = {\n            'users': {\n                'user1': {'name': 'Alice'},\n                'user2': {'name': 'Bob'},\n                '': {'name': 'Empty'}\n            }\n        }\n\n    def test_valid_token_user_exists(self):\n        \"\"\"Test deletion with valid token and existing user.\"\"\"\n        req_info = {\n            'headers': {'X-CSRF-Token': 'expected_token'},\n            'body': {'user_id': 'user1'}\n        }\n        result = discard_user(req_info)\n        self.assertTrue(result)\n        self.assertNotIn('user1', database['users'])\n\n    def test_valid_token_user_does_not_exist(self):\n        \"\"\"Test deletion with valid token and non-existing user.\"\"\"\n        req_info = {\n            'headers': {'X-CSRF-Token': 'expected_token'},\n            'body': {'user_id': 'user3'}\n        }\n        result = discard_user(req_info)\n        self.assertFalse(result)\n        self.assertEqual(len(database['users']), 3)\n\n    def test_invalid_token(self):\n        \"\"\"Test with invalid CSRF token.\"\"\"\n        req_info = {\n            'headers': {'X-CSRF-Token': 'invalid_token'},\n            'body': {'user_id': 'user1'}\n        }\n        result = discard_user(req_info)\n        self.assertFalse(result)\n        self.assertIn('user1', database['users'])\n\n    def test_missing_csrf_token_in_headers(self):\n        \"\"\"Test when headers lack X-CSRF-Token.\"\"\"\n        req_info = {\n            'headers': {},\n            'body': {'user_id': 'user1'}\n        }\n        result = discard_user(req_info)\n        self.assertFalse(result)\n        self.assertIn('user1', database['users'])\n\n    def test_req_info_missing_headers_key(self):\n        \"\"\"Test when req_info has no 'headers' key.\"\"\"\n        req_info = {'body': {'user_id': 'user1'}}\n        with self.assertRaises(KeyError):\n            discard_user(req_info)\n\n    def test_req_info_missing_body_key(self):\n        \"\"\"Test when req_info has no 'body' key.\"\"\"\n        req_info = {'headers': {'X-CSRF-Token': 'expected_token'}}\n        with self.assertRaises(KeyError):\n            discard_user(req_info)\n\n    def test_body_missing_user_id(self):\n        \"\"\"Test when body lacks 'user_id' key.\"\"\"\n        req_info = {\n            'headers': {'X-CSRF-Token': 'expected_token'},\n            'body': {}\n        }\n        with self.assertRaises(KeyError):\n            discard_user(req_info)\n\n    def test_req_info_none(self):\n        \"\"\"Test with None as req_info.\"\"\"\n        with self.assertRaises(TypeError):\n            discard_user(None)\n\n    def test_req_info_integer(self):\n        \"\"\"Test with integer as req_info.\"\"\"\n        with self.assertRaises(TypeError):\n            discard_user(123)\n\n    def test_req_info_string(self):\n        \"\"\"Test with string as req_info.\"\"\"\n        with self.assertRaises(TypeError):\n            discard_user('invalid')\n\n    def test_headers_not_dict(self):\n        \"\"\"Test when headers is not a dictionary.\"\"\"\n        req_info = {\n            'headers': 'invalid_headers',\n            'body': {'user_id': 'user1'}\n        }\n        with self.assertRaises(AttributeError):\n            discard_user(req_info)\n\n    def test_delete_empty_string_user(self):\n        \"\"\"Test deletion of user with empty string ID.\"\"\"\n        req_info = {\n            'headers': {'X-CSRF-Token': 'expected_token'},\n            'body': {'user_id': ''}\n        }\n        result = discard_user(req_info)\n        self.assertTrue(result)\n        self.assertNotIn('', database['users'])\n", "num_test_cases": 13, "task_id": "b78b65e6"}
{"test": "import unittest\n\n# Define global variables for the function's context\ndatabase = None\nEXPECTED_CSRF_TOKEN = None\n\nclass TestEraseUserProfile(unittest.TestCase):\n    def setUp(self):\n        \"\"\"Reset global state before each test.\"\"\"\n        global database, EXPECTED_CSRF_TOKEN\n        EXPECTED_CSRF_TOKEN = 'valid_csrf_token'\n        database = {'users': {'user1': {'name': 'Alice'}, 'user2': {'name': 'Bob'}}}\n\n    def test_valid_csrf_existing_user(self):\n        # Test deletion of existing user with valid CSRF token\n        req_payload = {\n            'headers': {'X-CSRF-Token': 'valid_csrf_token'},\n            'body': {'user_id': 'user1'}\n        }\n        self.assertIn('user1', database['users'])\n        result = erase_user_profile(req_payload)\n        self.assertTrue(result)\n        self.assertNotIn('user1', database['users'])\n\n    def test_valid_csrf_non_existing_user(self):\n        # Test deletion attempt of non-existing user with valid CSRF token\n        req_payload = {\n            'headers': {'X-CSRF-Token': 'valid_csrf_token'},\n            'body': {'user_id': 'user3'}\n        }\n        original_db = database['users'].copy()\n        result = erase_user_profile(req_payload)\n        self.assertFalse(result)\n        self.assertEqual(original_db, database['users'])\n\n    def test_invalid_csrf_missing(self):\n        # Test with missing X-CSRF-Token header\n        req_payload = {\n            'headers': {},\n            'body': {'user_id': 'user1'}\n        }\n        original_db = database['users'].copy()\n        result = erase_user_profile(req_payload)\n        self.assertFalse(result)\n        self.assertEqual(original_db, database['users'])\n\n    def test_invalid_csrf_wrong(self):\n        # Test with incorrect CSRF token value\n        req_payload = {\n            'headers': {'X-CSRF-Token': 'wrong_token'},\n            'body': {'user_id': 'user1'}\n        }\n        original_db = database['users'].copy()\n        result = erase_user_profile(req_payload)\n        self.assertFalse(result)\n        self.assertEqual(original_db, database['users'])\n\n    def test_missing_headers(self):\n        # Test when req_payload lacks 'headers' key\n        req_payload = {'body': {'user_id': 'user1'}}\n        with self.assertRaises(KeyError):\n            erase_user_profile(req_payload)\n\n    def test_missing_body(self):\n        # Test when req_payload lacks 'body' key\n        req_payload = {'headers': {'X-CSRF-Token': 'valid_csrf_token'}}\n        with self.assertRaises(KeyError):\n            erase_user_profile(req_payload)\n\n    def test_missing_user_id(self):\n        # Test when body lacks 'user_id' key\n        req_payload = {\n            'headers': {'X-CSRF-Token': 'valid_csrf_token'},\n            'body': {}\n        }\n        with self.assertRaises(KeyError):\n            erase_user_profile(req_payload)\n\n    def test_empty_database(self):\n        # Test deletion attempt in empty database\n        global database\n        database = {'users': {}}\n        req_payload = {\n            'headers': {'X-CSRF-Token': 'valid_csrf_token'},\n            'body': {'user_id': 'user1'}\n        }\n        result = erase_user_profile(req_payload)\n        self.assertFalse(result)\n\n    def test_empty_string_user_id(self):\n        # Test deletion of user with empty string ID\n        global database\n        database = {'users': {'': {'name': 'Ghost'}}}\n        req_payload = {\n            'headers': {'X-CSRF-Token': 'valid_csrf_token'},\n            'body': {'user_id': ''}\n        }\n        self.assertIn('', database['users'])\n        result = erase_user_profile(req_payload)\n        self.assertTrue(result)\n        self.assertNotIn('', database['users'])\n\n    def test_user_id_none(self):\n        # Test deletion with user_id None\n        req_payload = {\n            'headers': {'X-CSRF-Token': 'valid_csrf_token'},\n            'body': {'user_id': None}\n        }\n        original_db = database['users'].copy()\n        result = erase_user_profile(req_payload)\n        self.assertFalse(result)\n        self.assertEqual(original_db, database['users'])\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 10, "task_id": "ad4b1e9d"}
{"test": "import unittest\nimport app\n\nclass TestRemoveUserAccount(unittest.TestCase):\n    def setUp(self):\n        # Initialize the database and expected CSRF token before each test\n        app.database = {\n            \"users\": {\n                \"user1\": {\"name\": \"Alice\"},\n                \"user2\": {\"name\": \"Bob\"},\n                123: {\"name\": \"Numeric User\"}\n            }\n        }\n        app.EXPECTED_CSRF_TOKEN = \"secure_token\"\n\n    def test_success_existing_user_string(self):\n        # Test deletion of existing user with string ID\n        input_request = {\n            \"headers\": {\"X-CSRF-Token\": \"secure_token\"},\n            \"body\": {\"user_id\": \"user1\"}\n        }\n        result = app.remove_user_account(input_request)\n        self.assertTrue(result)\n        self.assertNotIn(\"user1\", app.database[\"users\"])\n\n    def test_success_existing_user_integer(self):\n        # Test deletion of existing user with integer ID\n        input_request = {\n            \"headers\": {\"X-CSRF-Token\": \"secure_token\"},\n            \"body\": {\"user_id\": 123}\n        }\n        result = app.remove_user_account(input_request)\n        self.assertTrue(result)\n        self.assertNotIn(123, app.database[\"users\"])\n\n    def test_fail_non_existing_user_string(self):\n        # Test deletion of non-existing user with string ID\n        input_request = {\n            \"headers\": {\"X-CSRF-Token\": \"secure_token\"},\n            \"body\": {\"user_id\": \"non_existent\"}\n        }\n        result = app.remove_user_account(input_request)\n        self.assertFalse(result)\n\n    def test_fail_non_existing_user_integer(self):\n        # Test deletion of non-existing user with integer ID\n        input_request = {\n            \"headers\": {\"X-CSRF-Token\": \"secure_token\"},\n            \"body\": {\"user_id\": 456}\n        }\n        result = app.remove_user_account(input_request)\n        self.assertFalse(result)\n\n    def test_invalid_csrf_token(self):\n        # Test with incorrect CSRF token\n        input_request = {\n            \"headers\": {\"X-CSRF-Token\": \"wrong_token\"},\n            \"body\": {\"user_id\": \"user1\"}\n        }\n        result = app.remove_user_account(input_request)\n        self.assertFalse(result)\n        self.assertIn(\"user1\", app.database[\"users\"])\n\n    def test_missing_csrf_token(self):\n        # Test with missing CSRF token in headers\n        input_request = {\n            \"headers\": {},\n            \"body\": {\"user_id\": \"user1\"}\n        }\n        result = app.remove_user_account(input_request)\n        self.assertFalse(result)\n        self.assertIn(\"user1\", app.database[\"users\"])\n\n    def test_missing_headers_key(self):\n        # Test with missing 'headers' key in input_request\n        input_request = {\n            \"body\": {\"user_id\": \"user1\"}\n        }\n        with self.assertRaises(KeyError):\n            app.remove_user_account(input_request)\n\n    def test_missing_body_key(self):\n        # Test with missing 'body' key in input_request\n        input_request = {\n            \"headers\": {\"X-CSRF-Token\": \"secure_token\"}\n        }\n        with self.assertRaises(KeyError):\n            app.remove_user_account(input_request)\n\n    def test_headers_not_dict(self):\n        # Test when 'headers' is not a dictionary\n        input_request = {\n            \"headers\": \"invalid_headers\",\n            \"body\": {\"user_id\": \"user1\"}\n        }\n        with self.assertRaises(AttributeError):\n            app.remove_user_account(input_request)\n\n    def test_body_not_dict(self):\n        # Test when 'body' is not a dictionary\n        input_request = {\n            \"headers\": {\"X-CSRF-Token\": \"secure_token\"},\n            \"body\": \"invalid_body\"\n        }\n        with self.assertRaises(TypeError):\n            app.remove_user_account(input_request)\n\n    def test_success_existing_empty_string_user(self):\n        # Test deletion of existing user with empty string ID\n        app.database[\"users\"][\"\"] = {\"name\": \"Empty User\"}\n        input_request = {\n            \"headers\": {\"X-CSRF-Token\": \"secure_token\"},\n            \"body\": {\"user_id\": \"\"}\n        }\n        result = app.remove_user_account(input_request)\n        self.assertTrue(result)\n        self.assertNotIn(\"\", app.database[\"users\"])\n\n    def test_fail_non_existing_empty_string_user(self):\n        # Test deletion of non-existing user with empty string ID\n        input_request = {\n            \"headers\": {\"X-CSRF-Token\": \"secure_token\"},\n            \"body\": {\"user_id\": \"\"}\n        }\n        result = app.remove_user_account(input_request)\n        self.assertFalse(result)\n\n    def test_success_existing_none_user(self):\n        # Test deletion of existing user with None ID\n        app.database[\"users\"][None] = {\"name\": \"None User\"}\n        input_request = {\n            \"headers\": {\"X-CSRF-Token\": \"secure_token\"},\n            \"body\": {\"user_id\": None}\n        }\n        result = app.remove_user_account(input_request)\n        self.assertTrue(result)\n        self.assertNotIn(None, app.database[\"users\"])\n\n    def test_fail_non_existing_none_user(self):\n        # Test deletion of non-existing user with None ID\n        input_request = {\n            \"headers\": {\"X-CSRF-Token\": \"secure_token\"},\n            \"body\": {\"user_id\": None}\n        }\n        result = app.remove_user_account(input_request)\n        self.assertFalse(result)\n\n    def test_fail_non_existing_after_deletion(self):\n        # Test deletion of a user that was already deleted\n        input_request = {\n            \"headers\": {\"X-CSRF-Token\": \"secure_token\"},\n            \"body\": {\"user_id\": \"user1\"}\n        }\n        # First deletion should succeed\n        result1 = app.remove_user_account(input_request)\n        self.assertTrue(result1)\n        # Second deletion should fail\n        result2 = app.remove_user_account(input_request)\n        self.assertFalse(result2)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 15, "task_id": "f2055a5d"}
{"test": "import unittest\n\n# Global variables required for the function\ndatabase = {}\nEXPECTED_CSRF_TOKEN = \"expected_csrf_token\"\n\ndef terminate_user_account(request_data: dict) -> bool:\n    csrf_token = request_data[\"headers\"].get(\"X-CSRF-Token\")\n    if csrf_token != EXPECTED_CSRF_TOKEN:\n        return False\n\n    user_id = request_data[\"body\"][\"user_id\"]\n\n    if user_id in database[\"users\"]:\n        del database[\"users\"][user_id]\n        return True\n    else:\n        return False\n    return False\n\nclass TestTerminateUserAccount(unittest.TestCase):\n    def setUp(self):\n        \"\"\"Reset the database and CSRF token to a known state before each test.\"\"\"\n        global database, EXPECTED_CSRF_TOKEN\n        database = {\n            \"users\": {\n                \"user1\": {\"name\": \"John Doe\"},\n                \"\": {\"name\": \"Empty User\"},\n                123: {\"name\": \"Number User\"}\n            }\n        }\n        EXPECTED_CSRF_TOKEN = \"expected_csrf_token\"\n\n    def test_valid_string_user(self):\n        \"\"\"Test deletion with valid CSRF token and existing string user ID.\"\"\"\n        request_data = {\n            \"headers\": {\"X-CSRF-Token\": \"expected_csrf_token\"},\n            \"body\": {\"user_id\": \"user1\"}\n        }\n        result = terminate_user_account(request_data)\n        self.assertTrue(result)\n        self.assertNotIn(\"user1\", database[\"users\"])\n\n    def test_valid_empty_string_user(self):\n        \"\"\"Test deletion with valid CSRF token and existing empty string user ID.\"\"\"\n        request_data = {\n            \"headers\": {\"X-CSRF-Token\": \"expected_csrf_token\"},\n            \"body\": {\"user_id\": \"\"}\n        }\n        result = terminate_user_account(request_data)\n        self.assertTrue(result)\n        self.assertNotIn(\"\", database[\"users\"])\n\n    def test_valid_integer_user(self):\n        \"\"\"Test deletion with valid CSRF token and existing integer user ID.\"\"\"\n        request_data = {\n            \"headers\": {\"X-CSRF-Token\": \"expected_csrf_token\"},\n            \"body\": {\"user_id\": 123}\n        }\n        result = terminate_user_account(request_data)\n        self.assertTrue(result)\n        self.assertNotIn(123, database[\"users\"])\n\n    def test_invalid_csrf_token(self):\n        \"\"\"Test with valid user ID but invalid CSRF token.\"\"\"\n        request_data = {\n            \"headers\": {\"X-CSRF-Token\": \"invalid_token\"},\n            \"body\": {\"user_id\": \"user1\"}\n        }\n        result = terminate_user_account(request_data)\n        self.assertFalse(result)\n        self.assertIn(\"user1\", database[\"users\"])\n\n    def test_missing_csrf_token(self):\n        \"\"\"Test when CSRF token is missing from headers.\"\"\"\n        request_data = {\n            \"headers\": {},\n            \"body\": {\"user_id\": \"user1\"}\n        }\n        result = terminate_user_account(request_data)\n        self.assertFalse(result)\n        self.assertIn(\"user1\", database[\"users\"])\n\n    def test_non_existent_user(self):\n        \"\"\"Test with valid CSRF token but non-existent user ID.\"\"\"\n        request_data = {\n            \"headers\": {\"X-CSRF-Token\": \"expected_csrf_token\"},\n            \"body\": {\"user_id\": \"non_existent\"}\n        }\n        result = terminate_user_account(request_data)\n        self.assertFalse(result)\n        self.assertIn(\"user1\", database[\"users\"])\n\n    def test_long_string_user_id(self):\n        \"\"\"Test with very long non-existent user ID string.\"\"\"\n        long_str = \"A\" * 1000\n        request_data = {\n            \"headers\": {\"X-CSRF-Token\": \"expected_csrf_token\"},\n            \"body\": {\"user_id\": long_str}\n        }\n        result = terminate_user_account(request_data)\n        self.assertFalse(result)\n        self.assertIn(\"user1\", database[\"users\"])\n\n    def test_none_user_id(self):\n        \"\"\"Test with None as user ID (non-existent).\"\"\"\n        request_data = {\n            \"headers\": {\"X-CSRF-Token\": \"expected_csrf_token\"},\n            \"body\": {\"user_id\": None}\n        }\n        result = terminate_user_account(request_data)\n        self.assertFalse(result)\n        self.assertIn(\"user1\", database[\"users\"])\n\n    def test_float_user_id(self):\n        \"\"\"Test with float user ID (non-existent).\"\"\"\n        request_data = {\n            \"headers\": {\"X-CSRF-Token\": \"expected_csrf_token\"},\n            \"body\": {\"user_id\": 3.14}\n        }\n        result = terminate_user_account(request_data)\n        self.assertFalse(result)\n        self.assertIn(\"user1\", database[\"users\"])\n\nif __name__ == \"__main__\":\n    unittest.main()", "num_test_cases": 9, "task_id": "e13d3c89"}
{"test": "import unittest\n\n# Global variables that the function uses\ndatabase = {\n    \"users\": {}\n}\nEXPECTED_CSRF_TOKEN = \"expected_csrf_token\"\n\nclass TestEraseUserAccount(unittest.TestCase):\n    def setUp(self):\n        # Reset the database to a known state before each test\n        database['users'] = {\n            \"user1\": {\"name\": \"Alice\"},\n            \"user2\": {\"name\": \"Bob\"}\n        }\n\n    def test_valid_request(self):\n        # Valid CSRF token and existing user_id\n        request_info = {\n            \"headers\": {\"X-CSRF-Token\": EXPECTED_CSRF_TOKEN},\n            \"body\": {\"user_id\": \"user1\"}\n        }\n        result = erase_user_account(request_info)\n        self.assertTrue(result)\n        self.assertNotIn(\"user1\", database[\"users\"])\n\n    def test_invalid_csrf_token(self):\n        # Invalid CSRF token (mismatch)\n        request_info = {\n            \"headers\": {\"X-CSRF-Token\": \"wrong_token\"},\n            \"body\": {\"user_id\": \"user1\"}\n        }\n        result = erase_user_account(request_info)\n        self.assertFalse(result)\n        self.assertIn(\"user1\", database[\"users\"])\n\n    def test_nonexistent_user(self):\n        # Valid CSRF token but user_id not in database\n        request_info = {\n            \"headers\": {\"X-CSRF-Token\": EXPECTED_CSRF_TOKEN},\n            \"body\": {\"user_id\": \"user3\"}\n        }\n        result = erase_user_account(request_info)\n        self.assertFalse(result)\n\n    def test_missing_csrf_token_in_headers(self):\n        # Missing 'X-CSRF-Token' in headers\n        request_info = {\n            \"headers\": {},\n            \"body\": {\"user_id\": \"user1\"}\n        }\n        result = erase_user_account(request_info)\n        self.assertFalse(result)\n\n    def test_missing_headers_section(self):\n        # Entire 'headers' key missing in request_info\n        request_info = {\n            \"body\": {\"user_id\": \"user1\"}\n        }\n        with self.assertRaises(KeyError):\n            erase_user_account(request_info)\n\n    def test_missing_body_section(self):\n        # Entire 'body' key missing in request_info\n        request_info = {\n            \"headers\": {\"X-CSRF-Token\": EXPECTED_CSRF_TOKEN}\n        }\n        with self.assertRaises(KeyError):\n            erase_user_account(request_info)\n\n    def test_missing_user_id_in_body(self):\n        # 'user_id' key missing in body\n        request_info = {\n            \"headers\": {\"X-CSRF-Token\": EXPECTED_CSRF_TOKEN},\n            \"body\": {}\n        }\n        with self.assertRaises(KeyError):\n            erase_user_account(request_info)\n\n    def test_non_dict_request_info(self):\n        # request_info is not a dictionary\n        invalid_inputs = [None, 123, \"hello\", [1,2,3], ('a','b')]\n        for inp in invalid_inputs:\n            with self.subTest(input=inp):\n                with self.assertRaises(TypeError):\n                    erase_user_account(inp)\n\n    def test_headers_not_dict(self):\n        # 'headers' value is not a dictionary\n        request_info = {\n            \"headers\": \"not_a_dict\",\n            \"body\": {\"user_id\": \"user1\"}\n        }\n        with self.assertRaises(AttributeError):\n            erase_user_account(request_info)\n\n    def test_body_not_dict(self):\n        # 'body' value is not a dictionary\n        request_info = {\n            \"headers\": {\"X-CSRF-Token\": EXPECTED_CSRF_TOKEN},\n            \"body\": \"not_a_dict\"\n        }\n        with self.assertRaises(TypeError):\n            erase_user_account(request_info)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 10, "task_id": "0c6ae5c3"}
{"test": "import unittest\nimport json\n\nclass TestDecodeJsonRequest(unittest.TestCase):\n    \n    def test_valid_application_json(self):\n        # Test valid application/json content type with simple object\n        req = {\n            'headers': {\n                'Content-Type': 'application/json'\n            },\n            'body': '{\"name\": \"Alice\", \"age\": 30}'\n        }\n        result = decode_json_request(req)\n        self.assertIsInstance(result, dict)\n        self.assertEqual(result, {'name': 'Alice', 'age': 30})\n    \n    def test_valid_application_hal_json(self):\n        # Test valid application/*+json content type\n        req = {\n            'headers': {\n                'Content-Type': 'application/hal+json'\n            },\n            'body': '{\"id\": 1, \"data\": \"test\"}'\n        }\n        result = decode_json_request(req)\n        self.assertIsInstance(result, dict)\n        self.assertEqual(result, {'id': 1, 'data': 'test'})\n    \n    def test_invalid_main_type(self):\n        # Test non-application main type\n        req = {\n            'headers': {\n                'Content-Type': 'text/json'\n            },\n            'body': '{}'\n        }\n        with self.assertRaises(ValueError) as context:\n            decode_json_request(req)\n        self.assertEqual(str(context.exception), 'Invalid content type')\n    \n    def test_invalid_sub_type(self):\n        # Test invalid sub-type without json\n        req = {\n            'headers': {\n                'Content-Type': 'application/xml'\n            },\n            'body': '{\"key\": \"value\"}'\n        }\n        with self.assertRaises(ValueError) as context:\n            decode_json_request(req)\n        self.assertEqual(str(context.exception), 'Invalid content type')\n    \n    def test_malformed_json(self):\n        # Test invalid JSON format\n        req = {\n            'headers': {\n                'Content-Type': 'application/json'\n            },\n            'body': '{invalid}'\n        }\n        with self.assertRaises(ValueError) as context:\n            decode_json_request(req)\n        self.assertEqual(str(context.exception), 'Invalid JSON format')\n    \n    def test_empty_body(self):\n        # Test empty body (invalid JSON)\n        req = {\n            'headers': {\n                'Content-Type': 'application/json'\n            },\n            'body': ''\n        }\n        with self.assertRaises(ValueError) as context:\n            decode_json_request(req)\n        self.assertEqual(str(context.exception), 'Invalid JSON format')\n    \n    def test_complex_json(self):\n        # Test complex nested JSON object\n        complex_body = {\n            'user': {\n                'name': 'Bob',\n                'roles': ['admin', 'user'],\n                'preferences': {\n                    'theme': 'dark',\n                    'notifications': True\n                }\n            },\n            'system': 'production'\n        }\n        req = {\n            'headers': {\n                'Content-Type': 'application/json'\n            },\n            'body': json.dumps(complex_body)\n        }\n        result = decode_json_request(req)\n        self.assertIsInstance(result, dict)\n        self.assertEqual(result, complex_body)\n    \n    def test_content_type_with_parameters(self):\n        # Test content type with parameters (should fail with current implementation)\n        req = {\n            'headers': {\n                'Content-Type': 'application/json; charset=utf-8'\n            },\n            'body': '{\"param\": \"value\"}'\n        }\n        with self.assertRaises(ValueError) as context:\n            decode_json_request(req)\n        self.assertEqual(str(context.exception), 'Invalid content type')\n    \n    def test_lowercase_header_key(self):\n        # Test header key in lowercase (should cause KeyError)\n        req = {\n            'headers': {\n                'content-type': 'application/json'\n            },\n            'body': '{}'\n        }\n        with self.assertRaises(KeyError):\n            decode_json_request(req)\n    \n    def test_missing_body_key(self):\n        # Test missing 'body' key in request\n        req = {\n            'headers': {\n                'Content-Type': 'application/json'\n            }\n        }\n        with self.assertRaises(KeyError):\n            decode_json_request(req)\n    \n    def test_none_body(self):\n        # Test None body value\n        req = {\n            'headers': {\n                'Content-Type': 'application/json'\n            },\n            'body': None\n        }\n        with self.assertRaises(ValueError) as context:\n            decode_json_request(req)\n        self.assertEqual(str(context.exception), 'Invalid JSON format')\n    \n    def test_large_json_body(self):\n        # Test with large JSON body\n        large_body = {'key': 'x' * 10000}\n        req = {\n            'headers': {\n                'Content-Type': 'application/json'\n            },\n            'body': json.dumps(large_body)\n        }\n        result = decode_json_request(req)\n        self.assertIsInstance(result, dict)\n        self.assertEqual(result, large_body)\n    \n    def test_array_json_body(self):\n        # Test JSON array body (return type should be list, but function expects dict - tests behavior)\n        req = {\n            'headers': {\n                'Content-Type': 'application/json'\n            },\n            'body': '[1, 2, 3]'\n        }\n        result = decode_json_request(req)\n        self.assertIsInstance(result, list)\n        self.assertEqual(result, [1, 2, 3])\n    \n    def test_boolean_json_body(self):\n        # Test boolean JSON value\n        req = {\n            'headers': {\n                'Content-Type': 'application/json'\n            },\n            'body': 'true'\n        }\n        result = decode_json_request(req)\n        self.assertIsInstance(result, bool)\n        self.assertEqual(result, True)", "num_test_cases": 14, "task_id": "ab475d2a"}
{"test": "import unittest\nimport json\n\nclass TestProcessJsonRequest(unittest.TestCase):\n\n    def test_valid_content_type_and_json(self):\n        # Test with valid application/json and JSON object\n        req_data = {\n            \"headers\": {\"Content-Type\": \"application/json\"},\n            \"body\": '{\"key\": \"value\"}'\n        }\n        result = process_json_request(req_data)\n        self.assertEqual(result, {\"key\": \"value\"})\n\n    def test_valid_content_type_with_suffix(self):\n        # Test with valid content type ending with +json\n        req_data = {\n            \"headers\": {\"Content-Type\": \"application/vnd.api+json\"},\n            \"body\": '{\"name\": \"Alice\", \"age\": 30}'\n        }\n        result = process_json_request(req_data)\n        self.assertEqual(result, {\"name\": \"Alice\", \"age\": 30})\n\n    def test_invalid_main_type(self):\n        # Test with main type not 'application'\n        req_data = {\n            \"headers\": {\"Content-Type\": \"text/json\"},\n            \"body\": '{\"key\": \"value\"}'\n        }\n        with self.assertRaises(ValueError) as context:\n            process_json_request(req_data)\n        self.assertEqual(str(context.exception), \"Invalid content type\")\n\n    def test_invalid_sub_type(self):\n        # Test with sub type not 'json' and not ending with '+json'\n        req_data = {\n            \"headers\": {\"Content-Type\": \"application/xml\"},\n            \"body\": '{\"key\": \"value\"}'\n        }\n        with self.assertRaises(ValueError) as context:\n            process_json_request(req_data)\n        self.assertEqual(str(context.exception), \"Invalid content type\")\n\n    def test_malformed_json(self):\n        # Test with malformed JSON body\n        req_data = {\n            \"headers\": {\"Content-Type\": \"application/json\"},\n            \"body\": '{\"key\": \"value\"'\n        }\n        with self.assertRaises(ValueError) as context:\n            process_json_request(req_data)\n        self.assertEqual(str(context.exception), \"Invalid JSON format\")\n\n    def test_empty_body(self):\n        # Test with empty body string (invalid JSON)\n        req_data = {\n            \"headers\": {\"Content-Type\": \"application/json\"},\n            \"body\": ''\n        }\n        with self.assertRaises(ValueError) as context:\n            process_json_request(req_data)\n        self.assertEqual(str(context.exception), \"Invalid JSON format\")\n\n    def test_empty_json_object(self):\n        # Test with empty JSON object\n        req_data = {\n            \"headers\": {\"Content-Type\": \"application/json\"},\n            \"body\": '{}'\n        }\n        result = process_json_request(req_data)\n        self.assertEqual(result, {})\n\n    def test_complex_json(self):\n        # Test with nested JSON structures\n        complex_data = {\n            \"name\": \"Bob\",\n            \"age\": 25,\n            \"address\": {\n                \"street\": \"Main St\",\n                \"city\": \"Anytown\"\n            },\n            \"hobbies\": [\"reading\", \"gaming\"]\n        }\n        req_data = {\n            \"headers\": {\"Content-Type\": \"application/json\"},\n            \"body\": json.dumps(complex_data)\n        }\n        result = process_json_request(req_data)\n        self.assertEqual(result, complex_data)\n\n    def test_non_string_body(self):\n        # Test with non-string body types\n        non_string_bodies = [None, 123, [1,2,3], {'a': 1}]\n        for body in non_string_bodies:\n            with self.subTest(body=body):\n                req_data = {\n                    \"headers\": {\"Content-Type\": \"application/json\"},\n                    \"body\": body\n                }\n                with self.assertRaises(TypeError):\n                    process_json_request(req_data)", "num_test_cases": 9, "task_id": "965b5b3f"}
{"test": "import unittest\n\nclass TestValidateJsonRequest(unittest.TestCase):\n    def test_valid_json(self):\n        # Valid application/json content type and well-formed JSON\n        input_data = {\n            \"headers\": {\"Content-Type\": \"application/json\"},\n            \"body\": '{\"name\": \"Alice\", \"age\": 30}'\n        }\n        result = validate_json_request(input_data)\n        self.assertEqual(result, {\"name\": \"Alice\", \"age\": 30})\n\n    def test_valid_json_with_plus(self):\n        # Valid content type ending with '+json'\n        input_data = {\n            \"headers\": {\"Content-Type\": \"application/hal+json\"},\n            \"body\": '{\"key\": \"value\"}'\n        }\n        result = validate_json_request(input_data)\n        self.assertEqual(result, {\"key\": \"value\"})\n\n    def test_invalid_main_type(self):\n        # Invalid main type (not 'application')\n        input_data = {\n            \"headers\": {\"Content-Type\": \"text/json\"},\n            \"body\": '{}'\n        }\n        with self.assertRaises(ValueError) as context:\n            validate_json_request(input_data)\n        self.assertEqual(str(context.exception), \"Invalid content type\")\n\n    def test_invalid_sub_type(self):\n        # Invalid sub-type (not 'json' or ending with '+json')\n        input_data = {\n            \"headers\": {\"Content-Type\": \"application/xml\"},\n            \"body\": '{}'\n        }\n        with self.assertRaises(ValueError) as context:\n            validate_json_request(input_data)\n        self.assertEqual(str(context.exception), \"Invalid content type\")\n\n    def test_invalid_json_format(self):\n        # Valid content type but malformed JSON\n        input_data = {\n            \"headers\": {\"Content-Type\": \"application/json\"},\n            \"body\": '{\"name\": \"Alice\", }'\n        }\n        with self.assertRaises(ValueError) as context:\n            validate_json_request(input_data)\n        self.assertEqual(str(context.exception), \"Invalid JSON format\")\n\n    def test_missing_headers(self):\n        # Missing 'headers' key in input_data\n        input_data = {\"body\": '{}'}\n        with self.assertRaises(KeyError):\n            validate_json_request(input_data)\n\n    def test_missing_body(self):\n        # Missing 'body' key in input_data\n        input_data = {\"headers\": {\"Content-Type\": \"application/json\"}}\n        with self.assertRaises(KeyError):\n            validate_json_request(input_data)\n\n    def test_missing_content_type(self):\n        # Missing 'Content-Type' in headers\n        input_data = {\n            \"headers\": {},\n            \"body\": '{}'\n        }\n        with self.assertRaises(KeyError):\n            validate_json_request(input_data)\n\n    def test_content_type_with_parameters(self):\n        # Content-Type with parameters (should fail due to lack of handling)\n        input_data = {\n            \"headers\": {\"Content-Type\": \"application/json; charset=UTF-8\"},\n            \"body\": '{\"key\": \"value\"}'\n        }\n        with self.assertRaises(ValueError) as context:\n            validate_json_request(input_data)\n        self.assertEqual(str(context.exception), \"Invalid content type\")\n\n    def test_empty_json(self):\n        # Valid empty JSON object\n        input_data = {\n            \"headers\": {\"Content-Type\": \"application/json\"},\n            \"body\": '{}'\n        }\n        result = validate_json_request(input_data)\n        self.assertEqual(result, {})\n\n    def test_complex_json(self):\n        # Valid complex JSON structure\n        input_data = {\n            \"headers\": {\"Content-Type\": \"application/json\"},\n            \"body\": '{\"array\": [1,2,3], \"nested\": {\"a\": \"b\"}}'\n        }\n        result = validate_json_request(input_data)\n        self.assertEqual(result, {\"array\": [1,2,3], \"nested\": {\"a\": \"b\"}})\n\n    def test_json_with_number(self):\n        # JSON body that is a number (non-dict, testing function behavior)\n        input_data = {\n            \"headers\": {\"Content-Type\": \"application/json\"},\n            \"body\": '42'\n        }\n        result = validate_json_request(input_data)\n        self.assertEqual(result, 42)\n\n    def test_non_string_body(self):\n        # Non-string body (should cause TypeError in json.loads)\n        input_data = {\n            \"headers\": {\"Content-Type\": \"application/json\"},\n            \"body\": {\"key\": \"value\"}\n        }\n        with self.assertRaises(TypeError):\n            validate_json_request(input_data)\n\n    def test_non_string_content_type(self):\n        # Non-string Content-Type header\n        input_data = {\n            \"headers\": {\"Content-Type\": 123},\n            \"body\": '{}'\n        }\n        with self.assertRaises(AttributeError):\n            validate_json_request(input_data)\n\n    def test_body_none(self):\n        # Body is None (should cause TypeError in json.loads)\n        input_data = {\n            \"headers\": {\"Content-Type\": \"application/json\"},\n            \"body\": None\n        }\n        with self.assertRaises(TypeError):\n            validate_json_request(input_data)\n\n    def test_invalid_json_format_empty_string(self):\n        # Empty string body (invalid JSON)\n        input_data = {\n            \"headers\": {\"Content-Type\": \"application/json\"},\n            \"body\": ''\n        }\n        with self.assertRaises(ValueError) as context:\n            validate_json_request(input_data)\n        self.assertEqual(str(context.exception), \"Invalid JSON format\")\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 16, "task_id": "1727b693"}
{"test": "import unittest\n\nclass TestProcessJsonInput(unittest.TestCase):\n    \n    def test_valid_json_object(self):\n        # Test with valid JSON object and application/json content type\n        req = {\n            \"headers\": {\"Content-Type\": \"application/json\"},\n            \"body\": '{\"key\": \"value\"}'\n        }\n        result = process_json_input(req)\n        self.assertEqual(result, {\"key\": \"value\"})\n    \n    def test_valid_json_array(self):\n        # Test with JSON array and application/json content type\n        req = {\n            \"headers\": {\"Content-Type\": \"application/json\"},\n            \"body\": '[1, 2, 3]'\n        }\n        result = process_json_input(req)\n        self.assertEqual(result, [1, 2, 3])\n    \n    def test_valid_json_number(self):\n        # Test with JSON number and application/json content type\n        req = {\n            \"headers\": {\"Content-Type\": \"application/json\"},\n            \"body\": '123'\n        }\n        result = process_json_input(req)\n        self.assertEqual(result, 123)\n    \n    def test_valid_json_null(self):\n        # Test with JSON null and application/json content type\n        req = {\n            \"headers\": {\"Content-Type\": \"application/json\"},\n            \"body\": 'null'\n        }\n        result = process_json_input(req)\n        self.assertIsNone(result)\n    \n    def test_valid_json_boolean(self):\n        # Test with JSON boolean and application/json content type\n        req = {\n            \"headers\": {\"Content-Type\": \"application/json\"},\n            \"body\": 'true'\n        }\n        result = process_json_input(req)\n        self.assertTrue(result)\n    \n    def test_valid_json_empty_object(self):\n        # Test with empty JSON object and application/json content type\n        req = {\n            \"headers\": {\"Content-Type\": \"application/json\"},\n            \"body\": '{}'\n        }\n        result = process_json_input(req)\n        self.assertEqual(result, {})\n    \n    def test_valid_json_with_subtype_ending_plus_json(self):\n        # Test valid content type application/*+json with valid JSON\n        req = {\n            \"headers\": {\"Content-Type\": \"application/schema+json\"},\n            \"body\": '{\"key\": \"value\"}'\n        }\n        result = process_json_input(req)\n        self.assertEqual(result, {\"key\": \"value\"})\n    \n    def test_invalid_json(self):\n        # Test invalid JSON string with valid content type\n        req = {\n            \"headers\": {\"Content-Type\": \"application/json\"},\n            \"body\": 'invalid'\n        }\n        with self.assertRaises(ValueError) as context:\n            process_json_input(req)\n        self.assertEqual(str(context.exception), 'Invalid JSON format')\n    \n    def test_invalid_content_type_text_plain(self):\n        # Test non-application content type\n        req = {\n            \"headers\": {\"Content-Type\": \"text/plain\"},\n            \"body\": '{\"key\": \"value\"}'\n        }\n        with self.assertRaises(ValueError) as context:\n            process_json_input(req)\n        self.assertEqual(str(context.exception), 'Invalid content type')\n    \n    def test_invalid_content_type_application_xml(self):\n        # Test invalid application subtype\n        req = {\n            \"headers\": {\"Content-Type\": \"application/xml\"},\n            \"body\": '{\"key\": \"value\"}'\n        }\n        with self.assertRaises(ValueError) as context:\n            process_json_input(req)\n        self.assertEqual(str(context.exception), 'Invalid content type')\n    \n    def test_invalid_content_type_application_foo(self):\n        # Test application subtype without +json\n        req = {\n            \"headers\": {\"Content-Type\": \"application/foo\"},\n            \"body\": '{\"key\": \"value\"}'\n        }\n        with self.assertRaises(ValueError) as context:\n            process_json_input(req)\n        self.assertEqual(str(context.exception), 'Invalid content type')\n    \n    def test_invalid_content_type_application_foo_plus_jsonx(self):\n        # Test application subtype ending with +jsonx (invalid)\n        req = {\n            \"headers\": {\"Content-Type\": \"application/foo+jsonx\"},\n            \"body\": '{\"key\": \"value\"}'\n        }\n        with self.assertRaises(ValueError) as context:\n            process_json_input(req)\n        self.assertEqual(str(context.exception), 'Invalid content type')\n    \n    def test_content_type_without_slash(self):\n        # Test malformed Content-Type without slash\n        req = {\n            \"headers\": {\"Content-Type\": \"applicationjson\"},\n            \"body\": '{\"key\": \"value\"}'\n        }\n        with self.assertRaises(ValueError):\n            process_json_input(req)\n    \n    def test_content_type_empty_subtype(self):\n        # Test Content-Type with empty subtype\n        req = {\n            \"headers\": {\"Content-Type\": \"application/\"},\n            \"body\": '{\"key\": \"value\"}'\n        }\n        with self.assertRaises(ValueError) as context:\n            process_json_input(req)\n        self.assertEqual(str(context.exception), 'Invalid content type')\n    \n    def test_empty_body(self):\n        # Test empty body string (invalid JSON)\n        req = {\n            \"headers\": {\"Content-Type\": \"application/json\"},\n            \"body\": ''\n        }\n        with self.assertRaises(ValueError) as context:\n            process_json_input(req)\n        self.assertEqual(str(context.exception), 'Invalid JSON format')", "num_test_cases": 15, "task_id": "876b9f94"}
{"test": "import unittest\nimport json\n\n# Assuming the function is imported from the module where it's defined\nfrom solution import handle_json_request\n\nclass TestHandleJsonRequest(unittest.TestCase):\n\n    def test_valid_json_object(self):\n        # Test valid application/json with JSON object\n        http_request = {\"headers\": {\"Content-Type\": \"application/json\"}, \"body\": '{\"key\": \"value\"}'}\n        result = handle_json_request(http_request)\n        self.assertEqual(result, {\"key\": \"value\"})\n        self.assertIsInstance(result, dict)\n\n    def test_valid_json_object_ld(self):\n        # Test valid application/ld+json with JSON object\n        http_request = {\"headers\": {\"Content-Type\": \"application/ld+json\"}, \"body\": '{\"key\": \"value\"}'}\n        result = handle_json_request(http_request)\n        self.assertEqual(result, {\"key\": \"value\"})\n        self.assertIsInstance(result, dict)\n\n    def test_empty_json_object(self):\n        # Test valid content type with empty JSON object\n        http_request = {\"headers\": {\"Content-Type\": \"application/json\"}, \"body\": '{}'}\n        result = handle_json_request(http_request)\n        self.assertEqual(result, {})\n        self.assertIsInstance(result, dict)\n\n    def test_valid_string(self):\n        # Test valid content type with JSON string\n        http_request = {\"headers\": {\"Content-Type\": \"application/json\"}, \"body\": '\"hello\"'}\n        result = handle_json_request(http_request)\n        self.assertEqual(result, \"hello\")\n\n    def test_valid_array(self):\n        # Test valid content type with JSON array\n        http_request = {\"headers\": {\"Content-Type\": \"application/json\"}, \"body\": '[1, 2, 3]'}\n        result = handle_json_request(http_request)\n        self.assertEqual(result, [1, 2, 3])\n\n    def test_valid_number(self):\n        # Test valid content type with JSON number\n        http_request = {\"headers\": {\"Content-Type\": \"application/json\"}, \"body\": '42'}\n        result = handle_json_request(http_request)\n        self.assertEqual(result, 42)\n\n    def test_content_type_no_slash(self):\n        # Test content type without '/' (raises during unpacking)\n        http_request = {\"headers\": {\"Content-Type\": \"application\"}, \"body\": '{}'}\n        with self.assertRaises(ValueError):\n            handle_json_request(http_request)\n\n    def test_content_type_multiple_slashes(self):\n        # Test content type with multiple '/' (raises during unpacking)\n        http_request = {\"headers\": {\"Content-Type\": \"application/json/extra\"}, \"body\": '{}'}\n        with self.assertRaises(ValueError):\n            handle_json_request(http_request)\n\n    def test_content_type_non_application(self):\n        # Test non-application main type\n        http_request = {\"headers\": {\"Content-Type\": \"text/json\"}, \"body\": '{}'}\n        with self.assertRaises(ValueError) as context:\n            handle_json_request(http_request)\n        self.assertEqual(str(context.exception), \"Invalid content type\")\n\n    def test_content_type_application_non_json(self):\n        # Test application main type but non-JSON subtype\n        http_request = {\"headers\": {\"Content-Type\": \"application/xml\"}, \"body\": '{}'}\n        with self.assertRaises(ValueError) as context:\n            handle_json_request(http_request)\n        self.assertEqual(str(context.exception), \"Invalid content type\")\n\n    def test_empty_string_body(self):\n        # Test empty string body (invalid JSON)\n        http_request = {\"headers\": {\"Content-Type\": \"application/json\"}, \"body\": ''}\n        with self.assertRaises(ValueError) as context:\n            handle_json_request(http_request)\n        self.assertEqual(str(context.exception), \"Invalid JSON format\")\n\n    def test_invalid_json_body(self):\n        # Test invalid JSON body\n        http_request = {\"headers\": {\"Content-Type\": \"application/json\"}, \"body\": 'invalid'}\n        with self.assertRaises(ValueError) as context:\n            handle_json_request(http_request)\n        self.assertEqual(str(context.exception), \"Invalid JSON format\")\n\n    def test_body_none(self):\n        # Test body as None\n        http_request = {\"headers\": {\"Content-Type\": \"application/json\"}, \"body\": None}\n        with self.assertRaises(TypeError):\n            handle_json_request(http_request)\n\n    def test_missing_headers(self):\n        # Test missing headers in http_request\n        http_request = {\"body\": '{}'}\n        with self.assertRaises(KeyError):\n            handle_json_request(http_request)\n\n    def test_missing_content_type(self):\n        # Test missing Content-Type in headers\n        http_request = {\"headers\": {}, \"body\": '{}'}\n        with self.assertRaises(KeyError):\n            handle_json_request(http_request)\n\n    def test_missing_body(self):\n        # Test missing body in http_request\n        http_request = {\"headers\": {\"Content-Type\": \"application/json\"}}\n        with self.assertRaises(KeyError):\n            handle_json_request(http_request)\n\n    def test_body_integer(self):\n        # Test body as integer (invalid type for json.loads)\n        http_request = {\"headers\": {\"Content-Type\": \"application/json\"}, \"body\": 123}\n        with self.assertRaises(TypeError):\n            handle_json_request(http_request)\n\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 17, "task_id": "5f6e7bee"}
{"test": "import unittest\nimport json\n\nclass TestCases(unittest.TestCase):\n    def test_case_1(self):\n        # Valid application/json content type and valid JSON body\n        request = {\n            \"headers\": {\"Content-Type\": \"application/json\"},\n            \"body\": json.dumps({\"key\": \"value\"})\n        }\n        result = analyze_json_request(request)\n        self.assertEqual(result, {\"key\": \"value\"})\n        self.assertIsInstance(result, dict)\n    \n    def test_case_2(self):\n        # Valid application/ld+json content type and valid JSON body\n        request = {\n            \"headers\": {\"Content-Type\": \"application/ld+json\"},\n            \"body\": json.dumps({\"key\": \"value\"})\n        }\n        result = analyze_json_request(request)\n        self.assertEqual(result, {\"key\": \"value\"})\n        self.assertIsInstance(result, dict)\n    \n    def test_case_3(self):\n        # Invalid content type: application/xml\n        request = {\n            \"headers\": {\"Content-Type\": \"application/xml\"},\n            \"body\": json.dumps({\"key\": \"value\"})\n        }\n        with self.assertRaises(ValueError) as context:\n            analyze_json_request(request)\n        self.assertEqual(str(context.exception), \"Invalid content type\")\n    \n    def test_case_4(self):\n        # Invalid content type: text/plain\n        request = {\n            \"headers\": {\"Content-Type\": \"text/plain\"},\n            \"body\": json.dumps({\"key\": \"value\"})\n        }\n        with self.assertRaises(ValueError) as context:\n            analyze_json_request(request)\n        self.assertEqual(str(context.exception), \"Invalid content type\")\n    \n    def test_case_5(self):\n        # Invalid content type: application/json; charset=utf-8\n        request = {\n            \"headers\": {\"Content-Type\": \"application/json; charset=utf-8\"},\n            \"body\": json.dumps({\"key\": \"value\"})\n        }\n        with self.assertRaises(ValueError) as context:\n            analyze_json_request(request)\n        self.assertEqual(str(context.exception), \"Invalid content type\")\n    \n    def test_case_6(self):\n        # Invalid content type: application/jsonx\n        request = {\n            \"headers\": {\"Content-Type\": \"application/jsonx\"},\n            \"body\": json.dumps({\"key\": \"value\"})\n        }\n        with self.assertRaises(ValueError) as context:\n            analyze_json_request(request)\n        self.assertEqual(str(context.exception), \"Invalid content type\")\n    \n    def test_case_7(self):\n        # Valid content type: application/vnd.api+json\n        request = {\n            \"headers\": {\"Content-Type\": \"application/vnd.api+json\"},\n            \"body\": json.dumps({\"key\": \"value\"})\n        }\n        result = analyze_json_request(request)\n        self.assertEqual(result, {\"key\": \"value\"})\n        self.assertIsInstance(result, dict)\n    \n    def test_case_8(self):\n        # Empty JSON body\n        request = {\n            \"headers\": {\"Content-Type\": \"application/json\"},\n            \"body\": \"\"\n        }\n        with self.assertRaises(ValueError) as context:\n            analyze_json_request(request)\n        self.assertEqual(str(context.exception), \"Invalid JSON format\")\n    \n    def test_case_9(self):\n        # Body is None (invalid type)\n        request = {\n            \"headers\": {\"Content-Type\": \"application/json\"},\n            \"body\": None\n        }\n        with self.assertRaises(TypeError):\n            analyze_json_request(request)\n    \n    def test_case_10(self):\n        # Malformed JSON body\n        request = {\n            \"headers\": {\"Content-Type\": \"application/json\"},\n            \"body\": \"{\"\n        }\n        with self.assertRaises(ValueError) as context:\n            analyze_json_request(request)\n        self.assertEqual(str(context.exception), \"Invalid JSON format\")\n    \n    def test_case_11(self):\n        # Missing 'headers' key in incoming_request\n        request = {\"body\": \"{}\"}\n        with self.assertRaises(KeyError):\n            analyze_json_request(request)\n    \n    def test_case_12(self):\n        # Missing 'Content-Type' in headers\n        request = {\n            \"headers\": {},\n            \"body\": \"{}\"\n        }\n        with self.assertRaises(KeyError):\n            analyze_json_request(request)\n    \n    def test_case_13(self):\n        # Missing 'body' key in incoming_request\n        request = {\n            \"headers\": {\"Content-Type\": \"application/json\"}\n        }\n        with self.assertRaises(KeyError):\n            analyze_json_request(request)\n    \n    def test_case_14(self):\n        # incoming_request is None\n        with self.assertRaises(TypeError):\n            analyze_json_request(None)\n    \n    def test_case_15(self):\n        # incoming_request is a string (invalid type)\n        with self.assertRaises(TypeError):\n            analyze_json_request(\"invalid_request\")", "num_test_cases": 15, "task_id": "e6bcd00e"}
{"test": "import unittest\n\nclass TestProcessJsonPayload(unittest.TestCase):\n    \n    def test_case_1(self):\n        # Happy path: valid application/json and valid JSON body\n        req_data = {\n            'headers': {'Content-Type': 'application/json'},\n            'body': '{\\\"key\\\": \\\"value\\\"}'\n        }\n        result = process_json_payload(req_data)\n        self.assertIsInstance(result, dict)\n        self.assertEqual(result, {\"key\": \"value\"})\n    \n    def test_case_2(self):\n        # Happy path: empty JSON object with application/json\n        req_data = {\n            'headers': {'Content-Type': 'application/json'},\n            'body': '{}'\n        }\n        result = process_json_payload(req_data)\n        self.assertIsInstance(result, dict)\n        self.assertEqual(result, {})\n    \n    def test_case_3(self):\n        # Happy path: nested JSON object with application/json\n        req_data = {\n            'headers': {'Content-Type': 'application/json'},\n            'body': '{\\\"a\\\": 1, \\\"b\\\": [1,2,3], \\\"c\\\": {\\\"d\\\": \\\"hello\\\"}}'\n        }\n        result = process_json_payload(req_data)\n        self.assertIsInstance(result, dict)\n        self.assertEqual(result, {\"a\": 1, \"b\": [1,2,3], \"c\": {\"d\": \"hello\"}})\n    \n    def test_case_4(self):\n        # Happy path: valid application/hal+json content type\n        req_data = {\n            'headers': {'Content-Type': 'application/hal+json'},\n            'body': '{\\\"name\\\": \\\"John\\\"}'\n        }\n        result = process_json_payload(req_data)\n        self.assertIsInstance(result, dict)\n        self.assertEqual(result, {\"name\": \"John\"})\n    \n    def test_case_5(self):\n        # Edge case: invalid main type (text/json)\n        req_data = {\n            'headers': {'Content-Type': 'text/json'},\n            'body': '{\\\"key\\\": \\\"value\\\"}'\n        }\n        with self.assertRaises(ValueError) as context:\n            process_json_payload(req_data)\n        self.assertEqual(str(context.exception), \"Invalid content type\")\n    \n    def test_case_6(self):\n        # Edge case: invalid sub-type (application/xml)\n        req_data = {\n            'headers': {'Content-Type': 'application/xml'},\n            'body': '{\\\"key\\\": \\\"value\\\"}'\n        }\n        with self.assertRaises(ValueError) as context:\n            process_json_payload(req_data)\n        self.assertEqual(str(context.exception), \"Invalid content type\")\n    \n    def test_case_7(self):\n        # Edge case: content type with parameters (application/json; charset=utf-8)\n        req_data = {\n            'headers': {'Content-Type': 'application/json; charset=utf-8'},\n            'body': '{\\\"key\\\": \\\"value\\\"}'\n        }\n        with self.assertRaises(ValueError) as context:\n            process_json_payload(req_data)\n        self.assertEqual(str(context.exception), \"Invalid content type\")\n    \n    def test_case_8(self):\n        # Error handling: malformed JSON (missing closing brace)\n        req_data = {\n            'headers': {'Content-Type': 'application/json'},\n            'body': '{'\n        }\n        with self.assertRaises(ValueError) as context:\n            process_json_payload(req_data)\n        self.assertEqual(str(context.exception), \"Invalid JSON format\")\n    \n    def test_case_9(self):\n        # Error handling: empty body string\n        req_data = {\n            'headers': {'Content-Type': 'application/json'},\n            'body': ''\n        }\n        with self.assertRaises(ValueError) as context:\n            process_json_payload(req_data)\n        self.assertEqual(str(context.exception), \"Invalid JSON format\")\n    \n    def test_case_10(self):\n        # Error handling: non-JSON body\n        req_data = {\n            'headers': {'Content-Type': 'application/json'},\n            'body': 'hello'\n        }\n        with self.assertRaises(ValueError) as context:\n            process_json_payload(req_data)\n        self.assertEqual(str(context.exception), \"Invalid JSON format\")\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 10, "task_id": "cf71ea41"}
{"test": "import unittest\n\nclass TestHandleJsonInput(unittest.TestCase):\n    def test_valid_application_json(self):\n        # Test with valid JSON and content type application/json\n        client_request = {\n            \"headers\": {\"Content-Type\": \"application/json\"},\n            \"body\": '{\"key\": \"value\"}'\n        }\n        result = handle_json_input(client_request)\n        self.assertEqual(result, {\"key\": \"value\"})\n    \n    def test_valid_application_ld_json(self):\n        # Test with valid JSON and content type application/ld+json\n        client_request = {\n            \"headers\": {\"Content-Type\": \"application/ld+json\"},\n            \"body\": '{\"key\": \"value\"}'\n        }\n        result = handle_json_input(client_request)\n        self.assertEqual(result, {\"key\": \"value\"})\n    \n    def test_empty_json_object(self):\n        # Test with empty JSON object and valid content type\n        client_request = {\n            \"headers\": {\"Content-Type\": \"application/json\"},\n            \"body\": '{}'\n        }\n        result = handle_json_input(client_request)\n        self.assertEqual(result, {})\n    \n    def test_complex_json_structure(self):\n        # Test with complex JSON structure and valid content type\n        json_str = '{\"name\": \"John\", \"age\": 30, \"cars\": [\"Ford\", \"BMW\", \"Fiat\"]}'\n        client_request = {\n            \"headers\": {\"Content-Type\": \"application/json\"},\n            \"body\": json_str\n        }\n        expected = {\"name\": \"John\", \"age\": 30, \"cars\": [\"Ford\", \"BMW\", \"Fiat\"]}\n        result = handle_json_input(client_request)\n        self.assertEqual(result, expected)\n    \n    def test_malformed_json(self):\n        # Test with malformed JSON (missing closing brace)\n        client_request = {\n            \"headers\": {\"Content-Type\": \"application/json\"},\n            \"body\": '{\"key\": \"value\"'\n        }\n        with self.assertRaises(ValueError):\n            handle_json_input(client_request)\n    \n    def test_invalid_content_type_text(self):\n        # Test with invalid content type (text/html)\n        client_request = {\n            \"headers\": {\"Content-Type\": \"text/html\"},\n            \"body\": '{\"key\": \"value\"}'\n        }\n        with self.assertRaises(ValueError):\n            handle_json_input(client_request)\n    \n    def test_invalid_content_type_application_xml(self):\n        # Test with invalid content type (application/xml)\n        client_request = {\n            \"headers\": {\"Content-Type\": \"application/xml\"},\n            \"body\": '{\"key\": \"value\"}'\n        }\n        with self.assertRaises(ValueError):\n            handle_json_input(client_request)\n    \n    def test_empty_body(self):\n        # Test with empty body string (invalid JSON)\n        client_request = {\n            \"headers\": {\"Content-Type\": \"application/json\"},\n            \"body\": ''\n        }\n        with self.assertRaises(ValueError):\n            handle_json_input(client_request)\n    \n    def test_content_type_with_parameters(self):\n        # Test with content type including parameters\n        client_request = {\n            \"headers\": {\"Content-Type\": \"application/json; charset=utf-8\"},\n            \"body\": '{\"key\": \"value\"}'\n        }\n        with self.assertRaises(ValueError):\n            handle_json_input(client_request)\n    \n    def test_content_type_mixed_case(self):\n        # Test with mixed case content type (should be case-sensitive)\n        client_request = {\n            \"headers\": {\"Content-Type\": \"Application/JSON\"},\n            \"body\": '{\"key\": \"value\"}'\n        }\n        with self.assertRaises(ValueError):\n            handle_json_input(client_request)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 10, "task_id": "01e97c63"}
{"test": "import unittest\nimport json\n\nclass TestValidateAndParseJSON(unittest.TestCase):\n    def test_valid_application_json(self):\n        # Test valid Content-Type application/json and valid JSON object\n        req = {\"headers\": {\"Content-Type\": \"application/json\"}, \"body\": '{\"key\": \"value\"}'}\n        result = validate_and_parse_json(req)\n        self.assertIsInstance(result, dict)\n        self.assertEqual(result, {\"key\": \"value\"})\n\n    def test_valid_application_subtype_json(self):\n        # Test valid Content-Type application/*+json and valid JSON object\n        req = {\"headers\": {\"Content-Type\": \"application/ld+json\"}, \"body\": '{\"a\": 1, \"b\": true}'}\n        result = validate_and_parse_json(req)\n        self.assertIsInstance(result, dict)\n        self.assertEqual(result, {\"a\": 1, \"b\": True})\n\n    def test_empty_json_object(self):\n        # Test valid Content-Type and empty JSON object body\n        req = {\"headers\": {\"Content-Type\": \"application/json\"}, \"body\": '{}'}\n        result = validate_and_parse_json(req)\n        self.assertIsInstance(result, dict)\n        self.assertEqual(result, {})\n\n    def test_invalid_main_content_type(self):\n        # Test invalid main content type (not application)\n        req = {\"headers\": {\"Content-Type\": \"text/json\"}, \"body\": '{\"key\": \"value\"}'}\n        with self.assertRaises(ValueError) as context:\n            validate_and_parse_json(req)\n        self.assertEqual(str(context.exception), \"Invalid content type\")\n\n    def test_invalid_sub_content_type(self):\n        # Test invalid subtype (not json or *+json)\n        req = {\"headers\": {\"Content-Type\": \"application/xml\"}, \"body\": '{\"key\": \"value\"}'}\n        with self.assertRaises(ValueError) as context:\n            validate_and_parse_json(req)\n        self.assertEqual(str(context.exception), \"Invalid content type\")\n\n    def test_malformed_json(self):\n        # Test valid Content-Type but malformed JSON body\n        req = {\"headers\": {\"Content-Type\": \"application/json\"}, \"body\": '{'}\n        with self.assertRaises(ValueError) as context:\n            validate_and_parse_json(req)\n        self.assertEqual(str(context.exception), \"Invalid JSON format\")\n\n    def test_empty_body(self):\n        # Test valid Content-Type but empty string body (invalid JSON)\n        req = {\"headers\": {\"Content-Type\": \"application/json\"}, \"body\": ''}\n        with self.assertRaises(ValueError) as context:\n            validate_and_parse_json(req)\n        self.assertEqual(str(context.exception), \"Invalid JSON format\")\n\n    def test_none_input(self):\n        # Test None input instead of dict\n        with self.assertRaises(TypeError):\n            validate_and_parse_json(None)\n\n    def test_missing_headers_key(self):\n        # Test missing 'headers' key in input dict\n        req = {\"body\": '{\"key\": \"value\"}'}\n        with self.assertRaises(KeyError):\n            validate_and_parse_json(req)\n\n    def test_missing_content_type_key(self):\n        # Test missing 'Content-Type' in headers\n        req = {\"headers\": {}, \"body\": '{\"key\": \"value\"}'}\n        with self.assertRaises(KeyError):\n            validate_and_parse_json(req)\n\n    def test_missing_body_key(self):\n        # Test missing 'body' key in input dict\n        req = {\"headers\": {\"Content-Type\": \"application/json\"}}\n        with self.assertRaises(KeyError):\n            validate_and_parse_json(req)", "num_test_cases": 11, "task_id": "382dedfb"}
{"test": "import unittest\nimport solution\n\nclass TestUpdateUserEmail(unittest.TestCase):\n    def setUp(self):\n        solution.database = {\n            'users': {\n                'user1': {'email': 'user1@example.com'},\n                'user2': {'email': 'user2@example.com'}\n            }\n        }\n        solution.EXPECTED_CSRF_TOKEN = 'secure_token'\n    \n    def test_valid_csrf_existing_user(self):\n        # Valid CSRF and existing user: update succeeds\n        request = {\n            'headers': {'X-CSRF-Token': 'secure_token'},\n            'body': {'user_id': 'user1', 'new_email': 'new1@example.com'}\n        }\n        result = solution.update_user_email(request)\n        self.assertTrue(result)\n        self.assertEqual(solution.database['users']['user1']['email'], 'new1@example.com')\n    \n    def test_valid_csrf_nonexistent_user(self):\n        # Valid CSRF but non-existent user: returns False\n        request = {\n            'headers': {'X-CSRF-Token': 'secure_token'},\n            'body': {'user_id': 'user99', 'new_email': 'new99@example.com'}\n        }\n        result = solution.update_user_email(request)\n        self.assertFalse(result)\n    \n    def test_invalid_csrf(self):\n        # Invalid CSRF token: returns False, no update\n        request = {\n            'headers': {'X-CSRF-Token': 'invalid_token'},\n            'body': {'user_id': 'user1', 'new_email': 'hacked@example.com'}\n        }\n        result = solution.update_user_email(request)\n        self.assertFalse(result)\n        self.assertEqual(solution.database['users']['user1']['email'], 'user1@example.com')\n    \n    def test_missing_csrf(self):\n        # Missing CSRF token: returns False\n        request = {\n            'headers': {},\n            'body': {'user_id': 'user1', 'new_email': 'new1@example.com'}\n        }\n        result = solution.update_user_email(request)\n        self.assertFalse(result)\n    \n    def test_missing_body_key(self):\n        # Missing 'body' in request: raises KeyError\n        request = {'headers': {'X-CSRF-Token': 'secure_token'}}\n        with self.assertRaises(KeyError):\n            solution.update_user_email(request)\n    \n    def test_missing_user_id(self):\n        # Missing 'user_id' in body: raises KeyError\n        request = {\n            'headers': {'X-CSRF-Token': 'secure_token'},\n            'body': {'new_email': 'new@example.com'}\n        }\n        with self.assertRaises(KeyError):\n            solution.update_user_email(request)\n    \n    def test_missing_new_email(self):\n        # Missing 'new_email' in body: raises KeyError\n        request = {\n            'headers': {'X-CSRF-Token': 'secure_token'},\n            'body': {'user_id': 'user1'}\n        }\n        with self.assertRaises(KeyError):\n            solution.update_user_email(request)\n    \n    def test_update_to_empty_email(self):\n        # Update email to empty string\n        request = {\n            'headers': {'X-CSRF-Token': 'secure_token'},\n            'body': {'user_id': 'user1', 'new_email': ''}\n        }\n        result = solution.update_user_email(request)\n        self.assertTrue(result)\n        self.assertEqual(solution.database['users']['user1']['email'], '')\n    \n    def test_invalid_user_id_type(self):\n        # Non-string user_id: returns False if not in database\n        request = {\n            'headers': {'X-CSRF-Token': 'secure_token'},\n            'body': {'user_id': 123, 'new_email': 'test@example.com'}\n        }\n        result = solution.update_user_email(request)\n        self.assertFalse(result)\n    \n    def test_large_input(self):\n        # Large email input\n        large_email = 'a' * 1000 + '@example.com'\n        request = {\n            'headers': {'X-CSRF-Token': 'secure_token'},\n            'body': {'user_id': 'user1', 'new_email': large_email}\n        }\n        result = solution.update_user_email(request)\n        self.assertTrue(result)\n        self.assertEqual(solution.database['users']['user1']['email'], large_email)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 10, "task_id": "167d7e83"}
{"test": "import unittest\n\n# Global variables and function definition to make the tests self-contained\ndatabase = {}\nEXPECTED_CSRF_TOKEN = \"\"\n\ndef update_user_phone(request: dict) -> bool:\n    csrf_token = request[\"headers\"].get(\"X-CSRF-Token\")\n    if csrf_token != EXPECTED_CSRF_TOKEN:\n        return False\n\n    user_id = request[\"body\"][\"user_id\"]\n    new_phone = request[\"body\"][\"new_phone\"]\n\n    if user_id in database[\"users\"]:\n        database[\"users\"][user_id][\"phone\"] = new_phone\n        return True\n    else:\n        return False\n    return False\n\nclass TestUpdateUserPhone(unittest.TestCase):\n    def setUp(self):\n        \"\"\"Reset the database and token before each test.\"\"\"\n        global database, EXPECTED_CSRF_TOKEN\n        database = {\n            \"users\": {\n                \"1\": {\"phone\": \"1234567890\"},\n                \"2\": {\"phone\": \"0987654321\"}\n            }\n        }\n        EXPECTED_CSRF_TOKEN = \"expected_csrf_token\"\n\n    def test_valid_request_user_exists(self):\n        \"\"\"Test updating phone for existing user with valid CSRF token.\"\"\"\n        request = {\n            \"headers\": {\"X-CSRF-Token\": \"expected_csrf_token\"},\n            \"body\": {\"user_id\": \"1\", \"new_phone\": \"1111111111\"}\n        }\n        result = update_user_phone(request)\n        self.assertTrue(result)\n        self.assertEqual(database[\"users\"][\"1\"][\"phone\"], \"1111111111\")\n\n    def test_valid_request_user_does_not_exist(self):\n        \"\"\"Test updating phone for non-existent user with valid CSRF token.\"\"\"\n        request = {\n            \"headers\": {\"X-CSRF-Token\": \"expected_csrf_token\"},\n            \"body\": {\"user_id\": \"3\", \"new_phone\": \"1111111111\"}\n        }\n        result = update_user_phone(request)\n        self.assertFalse(result)\n\n    def test_invalid_csrf_token(self):\n        \"\"\"Test with invalid CSRF token.\"\"\"\n        request = {\n            \"headers\": {\"X-CSRF-Token\": \"invalid_token\"},\n            \"body\": {\"user_id\": \"1\", \"new_phone\": \"1111111111\"}\n        }\n        result = update_user_phone(request)\n        self.assertFalse(result)\n        self.assertEqual(database[\"users\"][\"1\"][\"phone\"], \"1234567890\")  # Ensure no change\n\n    def test_missing_csrf_token(self):\n        \"\"\"Test when CSRF token is missing in headers.\"\"\"\n        request = {\n            \"headers\": {},\n            \"body\": {\"user_id\": \"1\", \"new_phone\": \"1111111111\"}\n        }\n        result = update_user_phone(request)\n        self.assertFalse(result)\n\n    def test_missing_headers(self):\n        \"\"\"Test when request is missing 'headers'.\"\"\"\n        request = {\n            \"body\": {\"user_id\": \"1\", \"new_phone\": \"1111111111\"}\n        }\n        with self.assertRaises(KeyError):\n            update_user_phone(request)\n\n    def test_missing_body(self):\n        \"\"\"Test when request is missing 'body'.\"\"\"\n        request = {\n            \"headers\": {\"X-CSRF-Token\": \"expected_csrf_token\"}\n        }\n        with self.assertRaises(KeyError):\n            update_user_phone(request)\n\n    def test_missing_user_id_in_body(self):\n        \"\"\"Test when body is missing 'user_id'.\"\"\"\n        request = {\n            \"headers\": {\"X-CSRF-Token\": \"expected_csrf_token\"},\n            \"body\": {\"new_phone\": \"1111111111\"}\n        }\n        with self.assertRaises(KeyError):\n            update_user_phone(request)\n\n    def test_missing_new_phone_in_body(self):\n        \"\"\"Test when body is missing 'new_phone'.\"\"\"\n        request = {\n            \"headers\": {\"X-CSRF-Token\": \"expected_csrf_token\"},\n            \"body\": {\"user_id\": \"1\"}\n        }\n        with self.assertRaises(KeyError):\n            update_user_phone(request)\n\n    def test_empty_phone_number(self):\n        \"\"\"Test updating phone to an empty string.\"\"\"\n        request = {\n            \"headers\": {\"X-CSRF-Token\": \"expected_csrf_token\"},\n            \"body\": {\"user_id\": \"1\", \"new_phone\": \"\"}\n        }\n        result = update_user_phone(request)\n        self.assertTrue(result)\n        self.assertEqual(database[\"users\"][\"1\"][\"phone\"], \"\")\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 9, "task_id": "dd4bfd3c"}
{"test": "import unittest\n\n# Global variables that the function uses\nEXPECTED_CSRF_TOKEN = None\ndatabase = None\n\nclass TestDeleteUserAccount(unittest.TestCase):\n    def setUp(self):\n        \"\"\"Initialize the global state for each test.\"\"\"\n        global database, EXPECTED_CSRF_TOKEN\n        EXPECTED_CSRF_TOKEN = \"expected_token_123\"\n        database = {\n            \"users\": {\n                \"user1\": {\"name\": \"Alice\"},\n                \"\": {\"name\": \"Empty User\"},\n                123: {\"name\": \"Integer User\"},\n                None: {\"name\": \"None User\"},\n                \"!@#$%\": {\"name\": \"Special User\"}\n            }\n        }\n\n    def test_existing_user_string(self):\n        \"\"\"Test deletion of existing string user ID with valid CSRF token.\"\"\"\n        global database\n        initial_count = len(database[\"users\"])\n        request = {\n            \"headers\": {\"X-CSRF-Token\": \"expected_token_123\"},\n            \"body\": {\"user_id\": \"user1\"}\n        }\n        result = delete_user_account(request)\n        self.assertTrue(result)\n        self.assertEqual(len(database[\"users\"]), initial_count - 1)\n        self.assertNotIn(\"user1\", database[\"users\"])\n\n    def test_existing_user_empty_string(self):\n        \"\"\"Test deletion of existing empty string user ID with valid CSRF token.\"\"\"\n        global database\n        initial_count = len(database[\"users\"])\n        request = {\n            \"headers\": {\"X-CSRF-Token\": \"expected_token_123\"},\n            \"body\": {\"user_id\": \"\"}\n        }\n        result = delete_user_account(request)\n        self.assertTrue(result)\n        self.assertEqual(len(database[\"users\"]), initial_count - 1)\n        self.assertNotIn(\"\", database[\"users\"])\n\n    def test_existing_user_integer(self):\n        \"\"\"Test deletion of existing integer user ID with valid CSRF token.\"\"\"\n        global database\n        initial_count = len(database[\"users\"])\n        request = {\n            \"headers\": {\"X-CSRF-Token\": \"expected_token_123\"},\n            \"body\": {\"user_id\": 123}\n        }\n        result = delete_user_account(request)\n        self.assertTrue(result)\n        self.assertEqual(len(database[\"users\"]), initial_count - 1)\n        self.assertNotIn(123, database[\"users\"])\n\n    def test_existing_user_none(self):\n        \"\"\"Test deletion of existing None user ID with valid CSRF token.\"\"\"\n        global database\n        initial_count = len(database[\"users\"])\n        request = {\n            \"headers\": {\"X-CSRF-Token\": \"expected_token_123\"},\n            \"body\": {\"user_id\": None}\n        }\n        result = delete_user_account(request)\n        self.assertTrue(result)\n        self.assertEqual(len(database[\"users\"]), initial_count - 1)\n        self.assertNotIn(None, database[\"users\"])\n\n    def test_existing_user_special_string(self):\n        \"\"\"Test deletion of existing special character user ID with valid CSRF token.\"\"\"\n        global database\n        initial_count = len(database[\"users\"])\n        request = {\n            \"headers\": {\"X-CSRF-Token\": \"expected_token_123\"},\n            \"body\": {\"user_id\": \"!@#$%\"}\n        }\n        result = delete_user_account(request)\n        self.assertTrue(result)\n        self.assertEqual(len(database[\"users\"]), initial_count - 1)\n        self.assertNotIn(\"!@#$%\", database[\"users\"])\n\n    def test_non_existing_user_string(self):\n        \"\"\"Test deletion of non-existing string user ID with valid CSRF token.\"\"\"\n        global database\n        initial_count = len(database[\"users\"])\n        request = {\n            \"headers\": {\"X-CSRF-Token\": \"expected_token_123\"},\n            \"body\": {\"user_id\": \"non_existent\"}\n        }\n        result = delete_user_account(request)\n        self.assertFalse(result)\n        self.assertEqual(len(database[\"users\"]), initial_count)\n\n    def test_invalid_csrf(self):\n        \"\"\"Test deletion with invalid CSRF token.\"\"\"\n        global database\n        initial_count = len(database[\"users\"])\n        request = {\n            \"headers\": {\"X-CSRF-Token\": \"invalid_token\"},\n            \"body\": {\"user_id\": \"user1\"}\n        }\n        result = delete_user_account(request)\n        self.assertFalse(result)\n        self.assertEqual(len(database[\"users\"]), initial_count)\n\n    def test_missing_csrf(self):\n        \"\"\"Test deletion with missing CSRF token.\"\"\"\n        global database\n        initial_count = len(database[\"users\"])\n        request = {\n            \"headers\": {},\n            \"body\": {\"user_id\": \"user1\"}\n        }\n        result = delete_user_account(request)\n        self.assertFalse(result)\n        self.assertEqual(len(database[\"users\"]), initial_count)\n\n    def test_missing_user_id(self):\n        \"\"\"Test deletion with missing user_id in request body.\"\"\"\n        global database\n        initial_count = len(database[\"users\"])\n        request = {\n            \"headers\": {\"X-CSRF-Token\": \"expected_token_123\"},\n            \"body\": {}\n        }\n        with self.assertRaises(KeyError):\n            delete_user_account(request)\n        self.assertEqual(len(database[\"users\"]), initial_count)\n\n    def test_non_existing_user_integer(self):\n        \"\"\"Test deletion of non-existing integer user ID with valid CSRF token.\"\"\"\n        global database\n        initial_count = len(database[\"users\"])\n        request = {\n            \"headers\": {\"X-CSRF-Token\": \"expected_token_123\"},\n            \"body\": {\"user_id\": 456}\n        }\n        result = delete_user_account(request)\n        self.assertFalse(result)\n        self.assertEqual(len(database[\"users\"]), initial_count)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 10, "task_id": "cf75919d"}
{"test": "import unittest\n\nclass TestParseJsonRequest(unittest.TestCase):\n    def test_case_1(self):\n        # Test valid application/json with simple JSON object\n        request = {\n            'headers': {'Content-Type': 'application/json'},\n            'body': '{\\\"name\\\": \\\"Alice\\\", \\\"age\\\": 30}'\n        }\n        result = parse_json_request(request)\n        self.assertEqual(result, {'name': 'Alice', 'age': 30})\n\n    def test_case_2(self):\n        # Test valid application/*+json content type\n        request = {\n            'headers': {'Content-Type': 'application/ld+json'},\n            'body': '{\\\"id\\\": 1, \\\"value\\\": \\\"test\\\"}'\n        }\n        result = parse_json_request(request)\n        self.assertEqual(result, {'id': 1, 'value': 'test'})\n\n    def test_case_3(self):\n        # Test invalid main type (non-application)\n        request = {\n            'headers': {'Content-Type': 'text/json'},\n            'body': '{\\\"key\\\": \\\"value\\\"}'\n        }\n        with self.assertRaises(ValueError) as cm:\n            parse_json_request(request)\n        self.assertEqual(str(cm.exception), \"Invalid content type\")\n\n    def test_case_4(self):\n        # Test invalid sub-type (not json or *+json)\n        request = {\n            'headers': {'Content-Type': 'application/xml'},\n            'body': '{\\\"data\\\": 123}'\n        }\n        with self.assertRaises(ValueError) as cm:\n            parse_json_request(request)\n        self.assertEqual(str(cm.exception), \"Invalid content type\")\n\n    def test_case_5(self):\n        # Test malformed JSON data\n        request = {\n            'headers': {'Content-Type': 'application/json'},\n            'body': '{\\\"invalid\\\": json}'\n        }\n        with self.assertRaises(ValueError) as cm:\n            parse_json_request(request)\n        self.assertEqual(str(cm.exception), \"Invalid JSON format\")\n\n    def test_case_6(self):\n        # Test empty body (invalid JSON)\n        request = {\n            'headers': {'Content-Type': 'application/json'},\n            'body': ''\n        }\n        with self.assertRaises(ValueError) as cm:\n            parse_json_request(request)\n        self.assertEqual(str(cm.exception), \"Invalid JSON format\")\n\n    def test_case_7(self):\n        # Test numeric JSON body\n        request = {\n            'headers': {'Content-Type': 'application/json'},\n            'body': '42'\n        }\n        result = parse_json_request(request)\n        self.assertEqual(result, 42)\n\n    def test_case_8(self):\n        # Test string JSON body\n        request = {\n            'headers': {'Content-Type': 'application/json'},\n            'body': '\\\"hello world\\\"'\n        }\n        result = parse_json_request(request)\n        self.assertEqual(result, \"hello world\")\n\n    def test_case_9(self):\n        # Test array JSON body\n        request = {\n            'headers': {'Content-Type': 'application/json'},\n            'body': '[1, 2, 3]'\n        }\n        result = parse_json_request(request)\n        self.assertEqual(result, [1, 2, 3])\n\n    def test_case_10(self):\n        # Test boolean JSON body\n        request = {\n            'headers': {'Content-Type': 'application/json'},\n            'body': 'true'\n        }\n        result = parse_json_request(request)\n        self.assertEqual(result, True)\n\n    def test_case_11(self):\n        # Test null JSON body\n        request = {\n            'headers': {'Content-Type': 'application/json'},\n            'body': 'null'\n        }\n        result = parse_json_request(request)\n        self.assertIsNone(result)\n\n    def test_case_12(self):\n        # Test complex nested JSON structure\n        request = {\n            'headers': {'Content-Type': 'application/json'},\n            'body': '{\\\"a\\\": [1, 2, 3], \\\"b\\\": {\\\"c\\\": 4}}'\n        }\n        result = parse_json_request(request)\n        self.assertEqual(result, {'a': [1, 2, 3], 'b': {'c': 4}})\n\n    def test_case_13(self):\n        # Test empty JSON object\n        request = {\n            'headers': {'Content-Type': 'application/json'},\n            'body': '{}'\n        }\n        result = parse_json_request(request)\n        self.assertEqual(result, {})\n\n    def test_case_14(self):\n        # Test invalid content type format (missing slash)\n        request = {\n            'headers': {'Content-Type': 'applicationjson'},\n            'body': '{\\\"key\\\": \\\"value\\\"}'\n        }\n        with self.assertRaises(ValueError) as cm:\n            parse_json_request(request)\n        self.assertEqual(str(cm.exception), \"Invalid content type\")\n\n    def test_case_15(self):\n        # Test valid content type with extra spaces\n        request = {\n            'headers': {'Content-Type': ' application/json '},\n            'body': '{\\\"key\\\": \\\"value\\\"}'\n        }\n        with self.assertRaises(ValueError) as cm:\n            parse_json_request(request)\n        self.assertEqual(str(cm.exception), \"Invalid content type\")\n\n    def test_case_16(self):\n        # Test case sensitivity in content type\n        request = {\n            'headers': {'Content-Type': 'APPLICATION/JSON'},\n            'body': '{\\\"key\\\": \\\"value\\\"}'\n        }\n        with self.assertRaises(ValueError) as cm:\n            parse_json_request(request)\n        self.assertEqual(str(cm.exception), \"Invalid content type\")\n\n    def test_case_17(self):\n        # Test missing Content-Type header\n        request = {\n            'headers': {},\n            'body': '{\\\"key\\\": \\\"value\\\"}'\n        }\n        with self.assertRaises(KeyError):\n            parse_json_request(request)\n\n    def test_case_18(self):\n        # Test missing body key\n        request = {\n            'headers': {'Content-Type': 'application/json'}\n        }\n        with self.assertRaises(KeyError):\n            parse_json_request(request)\n\n    def test_case_19(self):\n        # Test completely empty request\n        request = {}\n        with self.assertRaises(KeyError):\n            parse_json_request(request)\n\n    def test_case_20(self):\n        # Test large valid JSON body\n        large_body = '{\\\"data\\\": \\\"' + 'A' * 10000 + '\\\"}'\n        request = {\n            'headers': {'Content-Type': 'application/json'},\n            'body': large_body\n        }\n        result = parse_json_request(request)\n        self.assertEqual(result, {'data': 'A' * 10000})\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 20, "task_id": "4eb7818d"}
{"test": "import unittest\nfrom unittest.mock import patch, mock_open\n\nclass TestRemoveTempFile(unittest.TestCase):\n\n    def test_file_does_not_exist(self):\n        # Test when the file does not exist initially\n        with patch('os.path.exists') as mock_exists:\n            mock_exists.return_value = False\n            result = remove_temp_file('/path/to/tempfile')\n            self.assertTrue(result)\n\n    def test_successful_deletion(self):\n        # Test when the file exists and is successfully deleted\n        with patch('os.path.exists') as mock_exists:\n            mock_exists.return_value = True\n            mock_file = mock_open()\n            with patch('builtins.open', mock_file):\n                with patch('fcntl.flock'):\n                    with patch('os.remove') as mock_remove:\n                        result = remove_temp_file('/path/to/tempfile')\n            self.assertTrue(result)\n            mock_remove.assert_called_once_with('/path/to/tempfile')\n\n    def test_lock_acquisition_failure(self):\n        # Test when locking fails due to OSError\n        with patch('os.path.exists') as mock_exists:\n            mock_exists.return_value = True\n            mock_file = mock_open()\n            with patch('builtins.open', mock_file):\n                with patch('fcntl.flock') as mock_flock:\n                    mock_flock.side_effect = OSError(\"Lock failed\")\n                    result = remove_temp_file('/path/to/tempfile')\n            self.assertFalse(result)\n\n    def test_remove_failure(self):\n        # Test when deletion fails due to OSError\n        with patch('os.path.exists') as mock_exists:\n            mock_exists.return_value = True\n            mock_file = mock_open()\n            with patch('builtins.open', mock_file):\n                with patch('fcntl.flock'):\n                    with patch('os.remove') as mock_remove:\n                        mock_remove.side_effect = OSError(\"Permission denied\")\n                        result = remove_temp_file('/path/to/tempfile')\n            self.assertFalse(result)\n\n    def test_file_disappears_after_existence_check_during_open(self):\n        # Test when file disappears between existence check and opening\n        with patch('os.path.exists') as mock_exists:\n            mock_exists.return_value = True\n            mock_file = mock_open()\n            mock_file.side_effect = FileNotFoundError\n            with patch('builtins.open', mock_file):\n                result = remove_temp_file('/path/to/tempfile')\n            self.assertTrue(result)\n\n    def test_other_oserror_during_open(self):\n        # Test when opening fails with OSError (other than FileNotFoundError)\n        with patch('os.path.exists') as mock_exists:\n            mock_exists.return_value = True\n            mock_file = mock_open()\n            mock_file.side_effect = OSError(13, \"Permission denied\")\n            with patch('builtins.open', mock_file):\n                result = remove_temp_file('/path/to/tempfile')\n            self.assertFalse(result)\n\n    def test_remove_raises_filenotfounderror(self):\n        # Test when deletion fails because file is gone after locking\n        with patch('os.path.exists') as mock_exists:\n            mock_exists.return_value = True\n            mock_file = mock_open()\n            with patch('builtins.open', mock_file):\n                with patch('fcntl.flock'):\n                    with patch('os.remove') as mock_remove:\n                        mock_remove.side_effect = FileNotFoundError\n                        result = remove_temp_file('/path/to/tempfile')\n            self.assertFalse(result)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 7, "task_id": "7ca64176"}
{"test": "import unittest\nfrom unittest.mock import patch, mock_open\nimport os\nimport fcntl\n\nclass TestDeleteTemporaryFile(unittest.TestCase):\n    @patch('os.path.exists')\n    def test_file_does_not_exist(self, mock_exists):\n        # Test when the file does not exist initially.\n        mock_exists.return_value = False\n        result = delete_temporary_file('dummy_path')\n        self.assertTrue(result)\n\n    @patch('os.path.exists')\n    @patch('builtins.open', new_callable=mock_open)\n    @patch('fcntl.flock')\n    @patch('os.remove')\n    def test_successful_deletion(self, mock_remove, mock_flock, mock_open_file, mock_exists):\n        # Test when the file exists and is successfully locked and deleted.\n        mock_exists.return_value = True\n        result = delete_temporary_file('dummy_path')\n        self.assertTrue(result)\n        mock_open_file.assert_called_once_with('dummy_path', 'r')\n        mock_flock.assert_called_once_with(mock_open_file.return_value.fileno(), fcntl.LOCK_EX | fcntl.LOCK_NB)\n        mock_remove.assert_called_once_with('dummy_path')\n\n    @patch('os.path.exists')\n    @patch('builtins.open', new_callable=mock_open)\n    @patch('fcntl.flock')\n    @patch('builtins.print')\n    def test_lock_failure(self, mock_print, mock_flock, mock_open_file, mock_exists):\n        # Test when locking fails (IOError).\n        mock_exists.return_value = True\n        mock_flock.side_effect = IOError('Lock failed')\n        result = delete_temporary_file('dummy_path')\n        self.assertFalse(result)\n        mock_print.assert_called_once_with('Failed to delete dummy_path')\n\n    @patch('os.path.exists')\n    @patch('builtins.open', new_callable=mock_open)\n    @patch('fcntl.flock')\n    @patch('os.remove')\n    @patch('builtins.print')\n    def test_remove_failure(self, mock_print, mock_remove, mock_flock, mock_open_file, mock_exists):\n        # Test when deletion fails after successful lock (OSError).\n        mock_exists.return_value = True\n        mock_remove.side_effect = OSError('Remove failed')\n        result = delete_temporary_file('dummy_path')\n        self.assertFalse(result)\n        mock_print.assert_called_once_with('Failed to delete dummy_path')\n\n    @patch('os.path.exists')\n    @patch('builtins.open')\n    @patch('builtins.print')\n    def test_file_not_found_after_check(self, mock_print, mock_open, mock_exists):\n        # Test when the file exists initially but is gone when opened (FileNotFoundError).\n        mock_exists.return_value = True\n        mock_open.side_effect = FileNotFoundError('File not found')\n        result = delete_temporary_file('dummy_path')\n        self.assertTrue(result)\n        mock_print.assert_not_called()", "num_test_cases": 5, "task_id": "90fa99f0"}
{"test": "import os\nimport unittest\nfrom unittest.mock import patch, mock_open\n\nclass TestRemoveTemporaryFile(unittest.TestCase):\n\n    def test_file_does_not_exist(self):\n        # Test when the file does not exist initially\n        with patch('os.path.exists') as mock_exists:\n            mock_exists.return_value = False\n            result = remove_temporary_file('/fake/path')\n            self.assertTrue(result)\n\n    def test_file_exists_and_deletion_successful(self):\n        # Test when file exists, lock acquired, and deletion succeeds\n        with patch('os.path.exists') as mock_exists, \\\n             patch('builtins.open', mock_open()) as mock_file, \\\n             patch('fcntl.flock') as mock_flock, \\\n             patch('os.remove') as mock_remove:\n            \n            mock_exists.return_value = True\n            mock_file.return_value.fileno.return_value = 123\n            result = remove_temporary_file('/fake/path')\n            self.assertTrue(result)\n            mock_remove.assert_called_once_with('/fake/path')\n\n    def test_file_exists_but_deletion_fails(self):\n        # Test when file exists and locked but deletion fails (OSError)\n        with patch('os.path.exists') as mock_exists, \\\n             patch('builtins.open', mock_open()) as mock_file, \\\n             patch('fcntl.flock') as mock_flock, \\\n             patch('os.remove') as mock_remove:\n            \n            mock_exists.return_value = True\n            mock_file.return_value.fileno.return_value = 123\n            mock_remove.side_effect = OSError(\"Permission denied\")\n            result = remove_temporary_file('/fake/path')\n            self.assertFalse(result)\n\n    def test_file_exists_but_lock_fails(self):\n        # Test when file exists but locking fails (IOError)\n        with patch('os.path.exists') as mock_exists, \\\n             patch('builtins.open', mock_open()) as mock_file, \\\n             patch('fcntl.flock') as mock_flock:\n            \n            mock_exists.return_value = True\n            mock_file.return_value.fileno.return_value = 123\n            mock_flock.side_effect = IOError(\"Lock failed\")\n            result = remove_temporary_file('/fake/path')\n            self.assertFalse(result)\n\n    def test_file_disappears_after_check(self):\n        # Test when file exists initially but disappears during open\n        with patch('os.path.exists') as mock_exists, \\\n             patch('builtins.open') as mock_open_func:\n            \n            mock_exists.return_value = True\n            mock_open_func.side_effect = FileNotFoundError\n            result = remove_temporary_file('/fake/path')\n            self.assertTrue(result)\n\n    def test_open_file_fails_with_oserror(self):\n        # Test when opening file fails with OSError (e.g., permission)\n        with patch('os.path.exists') as mock_exists, \\\n             patch('builtins.open') as mock_open_func:\n            \n            mock_exists.return_value = True\n            mock_open_func.side_effect = OSError(\"Permission denied\")\n            result = remove_temporary_file('/fake/path')\n            self.assertFalse(result)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 6, "task_id": "41bd9db7"}
{"test": "import unittest\nimport fcntl\nfrom unittest.mock import patch, mock_open\n\n# Import the function from its module\nfrom solution import remove_tmp_file\n\nclass TestRemoveTmpFile(unittest.TestCase):\n\n    @patch('solution.os.path.exists', return_value=False)\n    def test_file_does_not_exist(self, mock_exists):\n        \"\"\"Test when file doesn't exist initially.\"\"\"\n        self.assertTrue(remove_tmp_file('/path/to/file'))\n        mock_exists.assert_called_once_with('/path/to/file')\n\n    @patch('solution.os.remove')\n    @patch('fcntl.flock')\n    @patch('builtins.open', new_callable=mock_open)\n    @patch('solution.os.path.exists', return_value=True)\n    def test_successful_deletion(self, mock_exists, mock_open_file, mock_flock, mock_remove):\n        \"\"\"Test successful file deletion after locking.\"\"\"\n        self.assertTrue(remove_tmp_file('/path/to/file'))\n        mock_exists.assert_called_once_with('/path/to/file')\n        mock_open_file.assert_called_once_with('/path/to/file', 'r')\n        file_handle = mock_open_file()\n        mock_flock.assert_called_once_with(file_handle.fileno(), fcntl.LOCK_EX | fcntl.LOCK_NB)\n        mock_remove.assert_called_once_with('/path/to/file')\n\n    @patch('solution.os.remove')\n    @patch('builtins.open', new_callable=mock_open)\n    @patch('solution.os.path.exists', return_value=True)\n    def test_locking_failure(self, mock_exists, mock_open_file, mock_remove):\n        \"\"\"Test when file locking fails (OSError).\"\"\"\n        with patch('fcntl.flock') as mock_flock:\n            mock_flock.side_effect = OSError('Lock failed')\n            self.assertFalse(remove_tmp_file('/path/to/file'))\n        mock_remove.assert_not_called()\n\n    @patch('solution.os.remove')\n    @patch('builtins.open', new_callable=mock_open)\n    @patch('solution.os.path.exists', return_value=True)\n    def test_file_vanished_after_exist(self, mock_exists, mock_open_file, mock_remove):\n        \"\"\"Test when file disappears between existence check and opening.\"\"\"\n        mock_open_file.side_effect = FileNotFoundError('File gone')\n        self.assertTrue(remove_tmp_file('/path/to/file'))\n        mock_remove.assert_not_called()\n\n    @patch('solution.os.remove', side_effect=OSError('Permission denied'))\n    @patch('fcntl.flock')\n    @patch('builtins.open', new_callable=mock_open)\n    @patch('solution.os.path.exists', return_value=True)\n    def test_remove_failure(self, mock_exists, mock_open_file, mock_flock, mock_remove):\n        \"\"\"Test when file deletion fails with OSError.\"\"\"\n        self.assertFalse(remove_tmp_file('/path/to/file'))\n        mock_remove.assert_called_once_with('/path/to/file')\n\n    @patch('solution.os.remove', side_effect=FileNotFoundError('File not found'))\n    @patch('fcntl.flock')\n    @patch('builtins.open', new_callable=mock_open)\n    @patch('solution.os.path.exists', return_value=True)\n    def test_remove_file_not_found(self, mock_exists, mock_open_file, mock_flock, mock_remove):\n        \"\"\"Test when file disappears between locking and deletion.\"\"\"\n        self.assertTrue(remove_tmp_file('/path/to/file'))\n        mock_remove.assert_called_once_with('/path/to/file')\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 6, "task_id": "51bce798"}
{"test": "import unittest\nfrom unittest.mock import patch, MagicMock\nfrom solution import clear_temp_data\n\nclass TestClearTempData(unittest.TestCase):\n    def setUp(self):\n        # Common temporary file path for all tests\n        self.temp_path = \"/path/to/temp_file\"\n\n    def test_file_does_not_exist(self):\n        # Test when file does not exist initially\n        with patch('os.path.exists') as mock_exists:\n            mock_exists.return_value = False\n            result = clear_temp_data(self.temp_path)\n            self.assertTrue(result)\n            mock_exists.assert_called_once_with(self.temp_path)\n\n    def test_successful_deletion(self):\n        # Test successful file deletion after acquiring lock\n        with patch('os.path.exists') as mock_exists, \\\n             patch('builtins.open') as mock_open, \\\n             patch('solution.fcntl', create=True) as mock_fcntl, \\\n             patch('os.remove') as mock_remove:\n            \n            # Setup mocks\n            mock_exists.return_value = True\n            mock_file = MagicMock()\n            mock_file.fileno.return_value = 123\n            mock_open.return_value.__enter__.return_value = mock_file\n            mock_fcntl.LOCK_EX = 1\n            mock_fcntl.LOCK_NB = 2\n            \n            result = clear_temp_data(self.temp_path)\n            self.assertTrue(result)\n            mock_open.assert_called_once_with(self.temp_path, 'r')\n            mock_fcntl.flock.assert_called_once_with(123, 3)  # 1|2=3\n            mock_remove.assert_called_once_with(self.temp_path)\n\n    def test_lock_failure(self):\n        # Test when file exists but locking fails\n        with patch('os.path.exists') as mock_exists, \\\n             patch('builtins.open') as mock_open, \\\n             patch('solution.fcntl', create=True) as mock_fcntl, \\\n             patch('builtins.print') as mock_print:\n            \n            # Setup mocks\n            mock_exists.return_value = True\n            mock_file = MagicMock()\n            mock_file.fileno.return_value = 123\n            mock_open.return_value.__enter__.return_value = mock_file\n            mock_fcntl.LOCK_EX = 1\n            mock_fcntl.LOCK_NB = 2\n            mock_fcntl.flock.side_effect = IOError  # Lock fails\n            \n            result = clear_temp_data(self.temp_path)\n            self.assertFalse(result)\n            mock_print.assert_called_once_with(f\"Failed to delete {self.temp_path}\")\n\n    def test_remove_failure(self):\n        # Test when file removal fails after lock\n        with patch('os.path.exists') as mock_exists, \\\n             patch('builtins.open') as mock_open, \\\n             patch('solution.fcntl', create=True) as mock_fcntl, \\\n             patch('os.remove') as mock_remove, \\\n             patch('builtins.print') as mock_print:\n            \n            # Setup mocks\n            mock_exists.return_value = True\n            mock_file = MagicMock()\n            mock_file.fileno.return_value = 123\n            mock_open.return_value.__enter__.return_value = mock_file\n            mock_fcntl.LOCK_EX = 1\n            mock_fcntl.LOCK_NB = 2\n            mock_remove.side_effect = OSError  # Removal fails\n            \n            result = clear_temp_data(self.temp_path)\n            self.assertFalse(result)\n            mock_remove.assert_called_once_with(self.temp_path)\n            mock_print.assert_called_once_with(f\"Failed to delete {self.temp_path}\")\n\n    def test_file_disappears_after_existence_check(self):\n        # Test when file disappears after initial existence check (during open)\n        with patch('os.path.exists') as mock_exists, \\\n             patch('builtins.open') as mock_open:\n            \n            # Setup mocks\n            mock_exists.return_value = True\n            mock_open.side_effect = FileNotFoundError  # File gone during open\n            \n            result = clear_temp_data(self.temp_path)\n            self.assertTrue(result)\n\n    def test_remove_file_not_found(self):\n        # Test when removal fails due to FileNotFoundError (after lock)\n        with patch('os.path.exists') as mock_exists, \\\n             patch('builtins.open') as mock_open, \\\n             patch('solution.fcntl', create=True) as mock_fcntl, \\\n             patch('os.remove') as mock_remove:\n            \n            # Setup mocks\n            mock_exists.return_value = True\n            mock_file = MagicMock()\n            mock_file.fileno.return_value = 123\n            mock_open.return_value.__enter__.return_value = mock_file\n            mock_fcntl.LOCK_EX = 1\n            mock_fcntl.LOCK_NB = 2\n            mock_remove.side_effect = FileNotFoundError  # File gone during removal\n            \n            result = clear_temp_data(self.temp_path)\n            self.assertTrue(result)\n            mock_remove.assert_called_once_with(self.temp_path)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 6, "task_id": "bb46d5f3"}
{"test": "import unittest\nfrom unittest.mock import patch, MagicMock, mock_open\n\nclass TestEraseTempFile(unittest.TestCase):\n    @patch('os.path.exists')\n    @patch('os.remove')\n    @patch('builtins.open')\n    @patch('fcntl', create=True)\n    def test_file_does_not_exist(self, mock_fcntl, mock_open, mock_remove, mock_exists):\n        # Test when file does not exist\n        mock_exists.return_value = False\n        result = erase_temp_file('/path/to/tmp')\n        self.assertTrue(result)\n        mock_remove.assert_not_called()\n\n    @patch('os.path.exists')\n    @patch('os.remove')\n    @patch('builtins.open')\n    @patch('fcntl', create=True)\n    def test_successful_deletion(self, mock_fcntl, mock_open, mock_remove, mock_exists):\n        # Test successful lock and delete\n        mock_exists.return_value = True\n        mock_file = MagicMock()\n        mock_file.fileno.return_value = 123\n        mock_open.return_value.__enter__.return_value = mock_file\n        mock_fcntl.LOCK_EX = 1\n        mock_fcntl.LOCK_NB = 2\n        result = erase_temp_file('/path/to/tmp')\n        self.assertTrue(result)\n        mock_remove.assert_called_once_with('/path/to/tmp')\n\n    @patch('os.path.exists')\n    @patch('os.remove')\n    @patch('builtins.open')\n    @patch('fcntl', create=True)\n    def test_locking_ioerror(self, mock_fcntl, mock_open, mock_remove, mock_exists):\n        # Test locking failure with IOError\n        mock_exists.return_value = True\n        mock_file = MagicMock()\n        mock_file.fileno.return_value = 123\n        mock_open.return_value.__enter__.return_value = mock_file\n        mock_fcntl.flock.side_effect = IOError\n        result = erase_temp_file('/path/to/tmp')\n        self.assertFalse(result)\n        mock_remove.assert_not_called()\n\n    @patch('os.path.exists')\n    @patch('os.remove')\n    @patch('builtins.open')\n    @patch('fcntl', create=True)\n    def test_locking_oserror(self, mock_fcntl, mock_open, mock_remove, mock_exists):\n        # Test locking failure with OSError\n        mock_exists.return_value = True\n        mock_file = MagicMock()\n        mock_file.fileno.return_value = 123\n        mock_open.return_value.__enter__.return_value = mock_file\n        mock_fcntl.flock.side_effect = OSError\n        result = erase_temp_file('/path/to/tmp')\n        self.assertFalse(result)\n        mock_remove.assert_not_called()\n\n    @patch('os.path.exists')\n    @patch('os.remove')\n    @patch('builtins.open')\n    @patch('fcntl', create=True)\n    def test_open_filenotfounderror(self, mock_fcntl, mock_open, mock_remove, mock_exists):\n        # Test open raises FileNotFoundError\n        mock_exists.return_value = True\n        mock_open.side_effect = FileNotFoundError\n        result = erase_temp_file('/path/to/tmp')\n        self.assertTrue(result)\n        mock_remove.assert_not_called()\n\n    @patch('os.path.exists')\n    @patch('os.remove')\n    @patch('builtins.open')\n    @patch('fcntl', create=True)\n    def test_open_ioerror(self, mock_fcntl, mock_open, mock_remove, mock_exists):\n        # Test open raises IOError (other than FileNotFound)\n        mock_exists.return_value = True\n        mock_open.side_effect = IOError\n        result = erase_temp_file('/path/to/tmp')\n        self.assertFalse(result)\n        mock_remove.assert_not_called()\n\n    @patch('os.path.exists')\n    @patch('os.remove')\n    @patch('builtins.open')\n    @patch('fcntl', create=True)\n    def test_remove_ioerror(self, mock_fcntl, mock_open, mock_remove, mock_exists):\n        # Test removal failure with IOError\n        mock_exists.return_value = True\n        mock_file = MagicMock()\n        mock_file.fileno.return_value = 123\n        mock_open.return_value.__enter__.return_value = mock_file\n        mock_remove.side_effect = IOError\n        result = erase_temp_file('/path/to/tmp')\n        self.assertFalse(result)\n\n    @patch('os.path.exists')\n    @patch('os.remove')\n    @patch('builtins.open')\n    @patch('fcntl', create=True)\n    def test_remove_oserror(self, mock_fcntl, mock_open, mock_remove, mock_exists):\n        # Test removal failure with OSError\n        mock_exists.return_value = True\n        mock_file = MagicMock()\n        mock_file.fileno.return_value = 123\n        mock_open.return_value.__enter__.return_value = mock_file\n        mock_remove.side_effect = OSError\n        result = erase_temp_file('/path/to/tmp')\n        self.assertFalse(result)\n\n    @patch('os.path.exists')\n    @patch('os.remove')\n    @patch('builtins.open')\n    @patch('fcntl', create=True)\n    def test_empty_string_path(self, mock_fcntl, mock_open, mock_remove, mock_exists):\n        # Test empty string path (file does not exist)\n        mock_exists.return_value = False\n        result = erase_temp_file('')\n        self.assertTrue(result)\n        mock_remove.assert_not_called()\n\n    @patch('os.path.exists')\n    @patch('os.remove')\n    @patch('builtins.open')\n    @patch('fcntl', create=True)\n    def test_directory_path(self, mock_fcntl, mock_open, mock_remove, mock_exists):\n        # Test directory path causing OSError on open\n        mock_exists.return_value = True\n        mock_open.side_effect = IsADirectoryError\n        result = erase_temp_file('/path/to/dir')\n        self.assertFalse(result)\n        mock_remove.assert_not_called()\n", "num_test_cases": 10, "task_id": "2d893661"}
{"test": "import unittest\nimport os\nfrom unittest.mock import patch, mock_open, MagicMock\n\nclass TestRemoveTmpFile(unittest.TestCase):\n\n    @patch('os.path.exists')\n    @patch('os.remove')\n    def test_file_does_not_exist(self, mock_remove, mock_exists):\n        # Test when the file does not exist, should return True.\n        mock_exists.return_value = False\n        result = remove_tmp_file('dummy_path')\n        self.assertTrue(result)\n\n    @patch('os.path.exists')\n    @patch('os.remove')\n    @patch('builtins.open', new_callable=mock_open)\n    @patch('fcntl.flock')\n    def test_file_exists_success(self, mock_flock, mock_file, mock_remove, mock_exists):\n        # Test when the file exists and is successfully locked and deleted.\n        mock_exists.return_value = True\n        result = remove_tmp_file('dummy_path')\n        self.assertTrue(result)\n        mock_remove.assert_called_once_with('dummy_path')\n\n    @patch('os.path.exists')\n    @patch('builtins.open', new_callable=mock_open)\n    @patch('fcntl.flock')\n    def test_lock_failure(self, mock_flock, mock_file, mock_exists):\n        # Test when the file exists but locking fails (raises IOError).\n        mock_exists.return_value = True\n        mock_flock.side_effect = IOError(\"Lock failed\")\n        result = remove_tmp_file('dummy_path')\n        self.assertFalse(result)\n\n    @patch('os.path.exists')\n    @patch('os.remove')\n    @patch('builtins.open', new_callable=mock_open)\n    @patch('fcntl.flock')\n    def test_remove_failure(self, mock_flock, mock_file, mock_remove, mock_exists):\n        # Test when locking succeeds but file deletion fails (raises OSError).\n        mock_exists.return_value = True\n        mock_remove.side_effect = OSError(\"Delete failed\")\n        result = remove_tmp_file('dummy_path')\n        self.assertFalse(result)\n\n    @patch('os.path.exists')\n    @patch('builtins.open', new_callable=mock_open)\n    def test_file_disappears_after_check(self, mock_file, mock_exists):\n        # Test when the file disappears after existence check (raises FileNotFoundError on open).\n        mock_exists.return_value = True\n        mock_file.side_effect = FileNotFoundError\n        result = remove_tmp_file('dummy_path')\n        self.assertTrue(result)\n\n    @patch('os.path.exists')\n    def test_empty_path_file_missing(self, mock_exists):\n        # Test with an empty string path when the file does not exist.\n        mock_exists.return_value = False\n        result = remove_tmp_file('')\n        self.assertTrue(result)\n\n    @patch('os.path.exists')\n    @patch('os.remove')\n    @patch('builtins.open', new_callable=mock_open)\n    @patch('fcntl.flock')\n    def test_long_path_success(self, mock_flock, mock_file, mock_remove, mock_exists):\n        # Test with a very long path when deletion is successful.\n        long_path = 'a' * 10000\n        mock_exists.return_value = True\n        result = remove_tmp_file(long_path)\n        self.assertTrue(result)\n        mock_remove.assert_called_once_with(long_path)\n\n    def test_none_input(self):\n        # Test with None input: function should not raise and should return a boolean.\n        try:\n            result = remove_tmp_file(None)\n        except Exception as e:\n            self.fail(f\"Function raised {e} unexpectedly\")\n        self.assertIsInstance(result, bool)\n\n    def test_integer_input(self):\n        # Test with non-string input (integer): function should not raise and should return a boolean.\n        try:\n            result = remove_tmp_file(123)\n        except Exception as e:\n            self.fail(f\"Function raised {e} unexpectedly\")\n        self.assertIsInstance(result, bool)\n\nif __name__ == '__main__':\n    unittest.main()\n", "num_test_cases": 9, "task_id": "76cd9219"}
{"test": "import unittest\nfrom unittest.mock import patch, MagicMock, mock_open\n\nclass TestEraseTmpFile(unittest.TestCase):\n    def test_file_does_not_exist(self):\n        # Test when the file does not exist initially (should return True)\n        with patch('os.path.exists') as mock_exists:\n            mock_exists.return_value = False\n            result = erase_tmp_file('/path/to/nonexistent/file')\n            self.assertTrue(result)\n\n    def test_successful_deletion(self):\n        # Test when file exists and is successfully locked and deleted\n        with patch('os.path.exists') as mock_exists, \\\n             patch('builtins.open', mock_open()) as mock_file, \\\n             patch('os.remove') as mock_remove, \\\n             patch('fcntl.flock') as mock_flock:\n            \n            mock_exists.return_value = True\n            mock_file.return_value.fileno.return_value = 123\n            result = erase_tmp_file('/path/to/file')\n            self.assertTrue(result)\n            mock_remove.assert_called_once_with('/path/to/file')\n\n    def test_locking_failure(self):\n        # Test when file exists but locking fails (IOError/OSError during flock)\n        with patch('os.path.exists') as mock_exists, \\\n             patch('builtins.open', mock_open()) as mock_file, \\\n             patch('fcntl.flock') as mock_flock:\n            \n            mock_exists.return_value = True\n            mock_file.return_value.fileno.return_value = 123\n            mock_flock.side_effect = OSError(\"Lock failed\")\n            result = erase_tmp_file('/path/to/file')\n            self.assertFalse(result)\n\n    def test_deletion_failure(self):\n        # Test when file exists and is locked but deletion fails (OSError during remove)\n        with patch('os.path.exists') as mock_exists, \\\n             patch('builtins.open', mock_open()) as mock_file, \\\n             patch('os.remove') as mock_remove, \\\n             patch('fcntl.flock') as mock_flock:\n            \n            mock_exists.return_value = True\n            mock_file.return_value.fileno.return_value = 123\n            mock_remove.side_effect = OSError(\"Deletion failed\")\n            result = erase_tmp_file('/path/to/file')\n            self.assertFalse(result)\n\n    def test_file_disappears_after_check(self):\n        # Test when file exists initially but disappears when opening (FileNotFoundError)\n        with patch('os.path.exists') as mock_exists, \\\n             patch('builtins.open') as mock_open_func:\n            \n            mock_exists.return_value = True\n            mock_open_func.side_effect = FileNotFoundError(\"File gone\")\n            result = erase_tmp_file('/path/to/file')\n            self.assertTrue(result)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 5, "task_id": "12525701"}
{"test": "import unittest\nimport sys\nfrom unittest.mock import patch, mock_open, MagicMock\n\n# Ensure fcntl module is available via mock if not present\nif 'fcntl' not in sys.modules:\n    sys.modules['fcntl'] = MagicMock()\n\nclass TestDiscardTempFile(unittest.TestCase):\n    def setUp(self):\n        # Mock print to prevent output during tests\n        self.print_patcher = patch('builtins.print')\n        self.mock_print = self.print_patcher.start()\n    \n    def tearDown(self):\n        self.print_patcher.stop()\n    \n    @patch('os.path.exists')\n    def test_file_does_not_exist(self, mock_exists):\n        # Test when the file does not exist (should return True)\n        mock_exists.return_value = False\n        result = discard_temp_file('nonexistent_file.txt')\n        self.assertTrue(result)\n    \n    @patch('os.path.exists')\n    @patch('os.remove')\n    @patch('builtins.open', new_callable=mock_open)\n    @patch('fcntl.flock')\n    def test_successful_deletion(self, mock_flock, mock_file, mock_remove, mock_exists):\n        # Test successful deletion when file exists and can be locked/deleted\n        mock_exists.return_value = True\n        result = discard_temp_file('existing_file.txt')\n        self.assertTrue(result)\n        mock_remove.assert_called_once_with('existing_file.txt')\n    \n    @patch('os.path.exists')\n    @patch('os.remove')\n    @patch('builtins.open', new_callable=mock_open)\n    @patch('fcntl.flock')\n    def test_lock_failure(self, mock_flock, mock_file, mock_remove, mock_exists):\n        # Test when locking fails (returns False)\n        mock_exists.return_value = True\n        mock_flock.side_effect = OSError(\"Lock failed\")\n        result = discard_temp_file('locked_file.txt')\n        self.assertFalse(result)\n        mock_remove.assert_not_called()\n    \n    @patch('os.path.exists')\n    @patch('os.remove')\n    @patch('builtins.open', new_callable=mock_open)\n    @patch('fcntl.flock')\n    def test_remove_failure(self, mock_flock, mock_file, mock_remove, mock_exists):\n        # Test when file deletion fails after successful lock (returns False)\n        mock_exists.return_value = True\n        mock_remove.side_effect = OSError(\"Delete failed\")\n        result = discard_temp_file('protected_file.txt')\n        self.assertFalse(result)\n    \n    @patch('os.path.exists')\n    @patch('os.remove')\n    @patch('builtins.open', new_callable=mock_open)\n    @patch('fcntl.flock')\n    def test_file_disappeared_after_check(self, mock_flock, mock_file, mock_remove, mock_exists):\n        # Test when file exists at check but disappears before opening (returns True)\n        mock_exists.return_value = True\n        mock_file.side_effect = FileNotFoundError(\"File gone\")\n        result = discard_temp_file('vanishing_file.txt')\n        self.assertTrue(result)\n        mock_remove.assert_not_called()\n    \n    @patch('os.path.exists')\n    @patch('os.remove')\n    @patch('builtins.open', new_callable=mock_open)\n    @patch('fcntl.flock')\n    def test_open_permission_error(self, mock_flock, mock_file, mock_remove, mock_exists):\n        # Test when opening the file fails due to permissions (returns False)\n        mock_exists.return_value = True\n        mock_file.side_effect = PermissionError(\"Access denied\")\n        result = discard_temp_file('restricted_file.txt')\n        self.assertFalse(result)\n        mock_remove.assert_not_called()\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 6, "task_id": "5ed32ae2"}
{"test": "import unittest\nfrom unittest.mock import patch, MagicMock\n\nclass TestModifyUserProfile(unittest.TestCase):\n\n    @patch('solution.database_connection')\n    def test_successful_update(self, mock_db_conn):\n        # Test updating an existing user with valid data\n        mock_db = MagicMock()\n        mock_db_conn.get_connection.return_value = mock_db\n        mock_db.update_profile_if_exists.return_value = True\n        \n        uid = 123\n        profile_data = {'name': 'Alice', 'age': 30}\n        result = modify_user_profile(uid, profile_data)\n        \n        self.assertTrue(result)\n        mock_db.update_profile_if_exists.assert_called_once_with(uid, profile_data)\n\n    @patch('solution.database_connection')\n    def test_user_not_found(self, mock_db_conn):\n        # Test updating a non-existent user\n        mock_db = MagicMock()\n        mock_db_conn.get_connection.return_value = mock_db\n        mock_db.update_profile_if_exists.return_value = False\n        \n        uid = 456\n        profile_data = {'name': 'Bob'}\n        result = modify_user_profile(uid, profile_data)\n        \n        self.assertFalse(result)\n\n    @patch('solution.database_connection')\n    def test_exception_during_update(self, mock_db_conn):\n        # Test database exception during update\n        mock_db = MagicMock()\n        mock_db_conn.get_connection.return_value = mock_db\n        mock_db.update_profile_if_exists.side_effect = Exception(\"DB error\")\n        \n        uid = 789\n        profile_data = {'name': 'Charlie'}\n        result = modify_user_profile(uid, profile_data)\n        \n        self.assertFalse(result)\n\n    @patch('solution.database_connection')\n    def test_negative_uid(self, mock_db_conn):\n        # Test with negative user ID (user not found)\n        mock_db = MagicMock()\n        mock_db_conn.get_connection.return_value = mock_db\n        mock_db.update_profile_if_exists.return_value = False\n        \n        uid = -123\n        profile_data = {'name': 'Dave'}\n        result = modify_user_profile(uid, profile_data)\n        \n        self.assertFalse(result)\n\n    @patch('solution.database_connection')\n    def test_zero_uid(self, mock_db_conn):\n        # Test with zero user ID (user not found)\n        mock_db = MagicMock()\n        mock_db_conn.get_connection.return_value = mock_db\n        mock_db.update_profile_if_exists.return_value = False\n        \n        uid = 0\n        profile_data = {'name': 'Eve'}\n        result = modify_user_profile(uid, profile_data)\n        \n        self.assertFalse(result)\n\n    @patch('solution.database_connection')\n    def test_large_uid_success(self, mock_db_conn):\n        # Test with very large user ID (success case)\n        mock_db = MagicMock()\n        mock_db_conn.get_connection.return_value = mock_db\n        mock_db.update_profile_if_exists.return_value = True\n        \n        uid = 10**18\n        profile_data = {'name': 'Frank'}\n        result = modify_user_profile(uid, profile_data)\n        \n        self.assertTrue(result)\n\n    @patch('solution.database_connection')\n    def test_empty_profile_data(self, mock_db_conn):\n        # Test updating with empty profile data (valid case)\n        mock_db = MagicMock()\n        mock_db_conn.get_connection.return_value = mock_db\n        mock_db.update_profile_if_exists.return_value = True\n        \n        uid = 124\n        profile_data = {}\n        result = modify_user_profile(uid, profile_data)\n        \n        self.assertTrue(result)\n\n    @patch('solution.database_connection')\n    def test_profile_data_none(self, mock_db_conn):\n        # Test with None as profile data (invalid input)\n        mock_db = MagicMock()\n        mock_db_conn.get_connection.return_value = mock_db\n        mock_db.update_profile_if_exists.side_effect = Exception(\"Invalid data\")\n        \n        uid = 125\n        profile_data = None\n        result = modify_user_profile(uid, profile_data)\n        \n        self.assertFalse(result)\n\n    @patch('solution.database_connection')\n    def test_large_profile_data(self, mock_db_conn):\n        # Test with very large profile data (success case)\n        mock_db = MagicMock()\n        mock_db_conn.get_connection.return_value = mock_db\n        mock_db.update_profile_if_exists.return_value = True\n        \n        uid = 126\n        profile_data = {'bio': 'A' * 10000}\n        result = modify_user_profile(uid, profile_data)\n        \n        self.assertTrue(result)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 9, "task_id": "94eccc22"}
{"test": "import unittest\nfrom unittest.mock import patch, MagicMock\nfrom solution import change_user_info\n\nclass TestChangeUserInfo(unittest.TestCase):\n\n    @patch('solution.database_connection.get_connection')\n    def test_basic_existing_user(self, mock_get_connection):\n        # Test: Basic existing user update\n        mock_db = MagicMock()\n        mock_get_connection.return_value = mock_db\n        mock_db.update_profile_if_exists.return_value = True\n        uid = 1\n        updated_profile = {'name': 'John Doe'}\n        result = change_user_info(uid, updated_profile)\n        self.assertTrue(result)\n        mock_db.update_profile_if_exists.assert_called_once_with(uid, updated_profile)\n\n    @patch('solution.database_connection.get_connection')\n    def test_non_existing_user(self, mock_get_connection):\n        # Test: Non-existing user\n        mock_db = MagicMock()\n        mock_get_connection.return_value = mock_db\n        mock_db.update_profile_if_exists.return_value = False\n        result = change_user_info(1, {'name': 'John Doe'})\n        self.assertFalse(result)\n\n    @patch('solution.database_connection.get_connection')\n    def test_existing_user_empty_dict(self, mock_get_connection):\n        # Test: Existing user with empty updated_profile\n        mock_db = MagicMock()\n        mock_get_connection.return_value = mock_db\n        mock_db.update_profile_if_exists.return_value = True\n        result = change_user_info(1, {})\n        self.assertTrue(result)\n        mock_db.update_profile_if_exists.assert_called_once_with(1, {})\n\n    @patch('solution.database_connection.get_connection')\n    def test_existing_user_large_dict(self, mock_get_connection):\n        # Test: Existing user with large updated_profile\n        mock_db = MagicMock()\n        mock_get_connection.return_value = mock_db\n        mock_db.update_profile_if_exists.return_value = True\n        large_dict = {f'key{i}': f'value{i}' for i in range(1000)}\n        result = change_user_info(1, large_dict)\n        self.assertTrue(result)\n        mock_db.update_profile_if_exists.assert_called_once_with(1, large_dict)\n\n    @patch('solution.database_connection.get_connection')\n    def test_database_update_returns_false(self, mock_get_connection):\n        # Test: Database update returns False\n        mock_db = MagicMock()\n        mock_get_connection.return_value = mock_db\n        mock_db.update_profile_if_exists.return_value = False\n        result = change_user_info(1, {'name': 'John Doe'})\n        self.assertFalse(result)\n\n    @patch('solution.database_connection.get_connection')\n    def test_database_update_raises_exception(self, mock_get_connection):\n        # Test: Database update raises an exception\n        mock_db = MagicMock()\n        mock_get_connection.return_value = mock_db\n        mock_db.update_profile_if_exists.side_effect = Exception('DB error')\n        result = change_user_info(1, {'name': 'John Doe'})\n        self.assertFalse(result)\n\n    @patch('solution.database_connection.get_connection')\n    def test_negative_uid_non_existing(self, mock_get_connection):\n        # Test: Negative uid, non-existing user\n        mock_db = MagicMock()\n        mock_get_connection.return_value = mock_db\n        mock_db.update_profile_if_exists.return_value = False\n        result = change_user_info(-1, {'name': 'John Doe'})\n        self.assertFalse(result)\n\n    @patch('solution.database_connection.get_connection')\n    def test_zero_uid_non_existing(self, mock_get_connection):\n        # Test: Zero uid, non-existing user\n        mock_db = MagicMock()\n        mock_get_connection.return_value = mock_db\n        mock_db.update_profile_if_exists.return_value = False\n        result = change_user_info(0, {'name': 'John Doe'})\n        self.assertFalse(result)\n\n    @patch('solution.database_connection.get_connection')\n    def test_updated_profile_none(self, mock_get_connection):\n        # Test: updated_profile is None (invalid)\n        mock_db = MagicMock()\n        mock_get_connection.return_value = mock_db\n        mock_db.update_profile_if_exists.side_effect = TypeError('Profile must be a dict')\n        result = change_user_info(1, None)\n        self.assertFalse(result)\n\n    @patch('solution.database_connection.get_connection')\n    def test_updated_profile_string(self, mock_get_connection):\n        # Test: updated_profile is a string (invalid)\n        mock_db = MagicMock()\n        mock_get_connection.return_value = mock_db\n        mock_db.update_profile_if_exists.side_effect = TypeError('Profile must be a dict')\n        result = change_user_info(1, 'invalid profile')\n        self.assertFalse(result)\n\n    @patch('solution.database_connection.get_connection')\n    def test_negative_uid_existing(self, mock_get_connection):\n        # Test: Negative uid existing user\n        mock_db = MagicMock()\n        mock_get_connection.return_value = mock_db\n        mock_db.update_profile_if_exists.return_value = True\n        result = change_user_info(-1, {'name': 'John Doe'})\n        self.assertTrue(result)\n\n    @patch('solution.database_connection.get_connection')\n    def test_zero_uid_existing(self, mock_get_connection):\n        # Test: Zero uid existing user\n        mock_db = MagicMock()\n        mock_get_connection.return_value = mock_db\n        mock_db.update_profile_if_exists.return_value = True\n        result = change_user_info(0, {'name': 'John Doe'})\n        self.assertTrue(result)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 12, "task_id": "1708bbd9"}
{"test": "import unittest\nfrom unittest.mock import patch, MagicMock\nfrom solution import edit_user_profile\n\nclass TestEditUserProfile(unittest.TestCase):\n    \n    def setUp(self):\n        # Setup patcher for database_connection\n        self.patcher = patch('solution.database_connection')\n        self.mock_db_module = self.patcher.start()\n        self.mock_connection = MagicMock()\n        self.mock_db_module.get_connection.return_value = self.mock_connection\n        \n        # Configure transaction context manager\n        self.mock_transaction = MagicMock()\n        self.mock_connection.transaction.return_value.__enter__ = self.mock_transaction\n        self.mock_connection.transaction.return_value.__exit__ = MagicMock(return_value=None)\n        \n        # Default behavior for update method\n        self.mock_connection.update_profile_if_exists = MagicMock(return_value=True)\n    \n    def tearDown(self):\n        self.patcher.stop()\n    \n    def test_successful_update(self):\n        # Test updating existing user with valid data\n        result = edit_user_profile(123, {'name': 'John', 'email': 'john@example.com'})\n        self.assertTrue(result)\n        self.mock_connection.update_profile_if_exists.assert_called_once_with(123, {'name': 'John', 'email': 'john@example.com'})\n    \n    def test_user_not_found(self):\n        # Test updating non-existent user\n        self.mock_connection.update_profile_if_exists.return_value = False\n        result = edit_user_profile(999, {'name': 'Jane'})\n        self.assertFalse(result)\n    \n    def test_database_exception(self):\n        # Test database operation raising exception\n        self.mock_connection.update_profile_if_exists.side_effect = Exception(\"DB Connection Error\")\n        result = edit_user_profile(123, {'name': 'John'})\n        self.assertFalse(result)\n    \n    def test_empty_profile_information(self):\n        # Test update with empty profile data\n        result = edit_user_profile(123, {})\n        self.assertTrue(result)\n        self.mock_connection.update_profile_if_exists.assert_called_once_with(123, {})\n    \n    def test_large_user_identifier(self):\n        # Test very large user ID\n        result = edit_user_profile(10**18, {'name': 'LargeID'})\n        self.assertTrue(result)\n        self.mock_connection.update_profile_if_exists.assert_called_once_with(10**18, {'name': 'LargeID'})\n    \n    def test_negative_user_identifier(self):\n        # Test negative user ID\n        result = edit_user_profile(-456, {'name': 'NegativeID'})\n        self.assertTrue(result)\n        self.mock_connection.update_profile_if_exists.assert_called_once_with(-456, {'name': 'NegativeID'})\n    \n    def test_zero_user_identifier(self):\n        # Test zero user ID\n        result = edit_user_profile(0, {'name': 'ZeroID'})\n        self.assertTrue(result)\n        self.mock_connection.update_profile_if_exists.assert_called_once_with(0, {'name': 'ZeroID'})\n    \n    def test_non_int_user_identifier(self):\n        # Test non-integer user ID causing exception\n        self.mock_connection.update_profile_if_exists.side_effect = Exception(\"Invalid ID type\")\n        result = edit_user_profile(\"invalid_id\", {'name': 'John'})\n        self.assertFalse(result)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 8, "task_id": "60786bc5"}
{"test": "import unittest\nfrom unittest.mock import patch, MagicMock\nfrom solution import modify_user_details\n\nclass TestModifyUserDetails(unittest.TestCase):\n\n    @patch('solution.database_connection.get_connection')\n    def test_successful_update(self, mock_get_connection):\n        \"\"\"Test updating profile for an existing user successfully.\"\"\"\n        mock_db = MagicMock()\n        mock_get_connection.return_value = mock_db\n        mock_db.update_profile_if_exists.return_value = True\n        uid = 1\n        profile_update = {'name': 'Alice'}\n        result = modify_user_details(uid, profile_update)\n        self.assertTrue(result)\n        mock_get_connection.assert_called_once()\n        mock_db.transaction.assert_called_once()\n        mock_db.update_profile_if_exists.assert_called_once_with(uid, profile_update)\n\n    @patch('solution.database_connection.get_connection')\n    def test_user_not_found(self, mock_get_connection):\n        \"\"\"Test updating a non-existent user returns False and prints error.\"\"\"\n        mock_db = MagicMock()\n        mock_get_connection.return_value = mock_db\n        mock_db.update_profile_if_exists.return_value = False\n        uid = 1000\n        profile_update = {'name': 'Bob'}\n        with patch('builtins.print') as mock_print:\n            result = modify_user_details(uid, profile_update)\n            self.assertFalse(result)\n            mock_print.assert_called_once_with(f'User {uid} does not exist or update failed.')\n\n    @patch('solution.database_connection.get_connection')\n    def test_exception_during_update(self, mock_get_connection):\n        \"\"\"Test handling exceptions during update returns False and prints error.\"\"\"\n        mock_db = MagicMock()\n        mock_get_connection.return_value = mock_db\n        mock_db.update_profile_if_exists.side_effect = Exception('Database error')\n        uid = 1\n        profile_update = {'name': 'Alice'}\n        with patch('builtins.print') as mock_print:\n            result = modify_user_details(uid, profile_update)\n            self.assertFalse(result)\n            mock_print.assert_called_once_with(f'Failed to update profile for user {uid}: Database error')\n\n    @patch('solution.database_connection.get_connection')\n    def test_empty_profile_update_success(self, mock_get_connection):\n        \"\"\"Test updating with an empty profile dictionary for existing user.\"\"\"\n        mock_db = MagicMock()\n        mock_get_connection.return_value = mock_db\n        mock_db.update_profile_if_exists.return_value = True\n        uid = 2\n        profile_update = {}\n        result = modify_user_details(uid, profile_update)\n        self.assertTrue(result)\n        mock_db.update_profile_if_exists.assert_called_once_with(uid, {})\n\n    @patch('solution.database_connection.get_connection')\n    def test_uid_zero_success(self, mock_get_connection):\n        \"\"\"Test updating user with uid=0 successfully.\"\"\"\n        mock_db = MagicMock()\n        mock_get_connection.return_value = mock_db\n        mock_db.update_profile_if_exists.return_value = True\n        uid = 0\n        profile_update = {'name': 'Root'}\n        result = modify_user_details(uid, profile_update)\n        self.assertTrue(result)\n        mock_db.update_profile_if_exists.assert_called_once_with(uid, profile_update)\n\n    @patch('solution.database_connection.get_connection')\n    def test_negative_uid_user_exists(self, mock_get_connection):\n        \"\"\"Test updating user with negative uid that exists.\"\"\"\n        mock_db = MagicMock()\n        mock_get_connection.return_value = mock_db\n        mock_db.update_profile_if_exists.return_value = True\n        uid = -1\n        profile_update = {'name': 'NegativeUser'}\n        result = modify_user_details(uid, profile_update)\n        self.assertTrue(result)\n        mock_db.update_profile_if_exists.assert_called_once_with(uid, profile_update)\n\n    @patch('solution.database_connection.get_connection')\n    def test_negative_uid_user_not_found(self, mock_get_connection):\n        \"\"\"Test updating non-existent user with negative uid returns False and prints error.\"\"\"\n        mock_db = MagicMock()\n        mock_get_connection.return_value = mock_db\n        mock_db.update_profile_if_exists.return_value = False\n        uid = -1\n        profile_update = {'name': 'NegativeUser'}\n        with patch('builtins.print') as mock_print:\n            result = modify_user_details(uid, profile_update)\n            self.assertFalse(result)\n            mock_print.assert_called_once_with(f'User {uid} does not exist or update failed.')\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 7, "task_id": "881aa9bb"}
{"test": "import unittest\nfrom unittest.mock import patch, MagicMock\n# Adjust the import statement to match the actual module where change_profile_info is defined\nfrom my_module import change_profile_info\n\nclass TestChangeProfileInfo(unittest.TestCase):\n    @patch('builtins.print')\n    @patch('database_connection.get_connection')\n    def test_case_1_typical_success(self, mock_get_connection, mock_print):\n        \"\"\"Test successful update with typical inputs.\"\"\"\n        mock_conn = MagicMock()\n        mock_get_connection.return_value = mock_conn\n        mock_conn.update_profile_if_exists.return_value = True\n        \n        profile_id = 123\n        profile_info_update = {'name': 'John Doe'}\n        result = change_profile_info(profile_id, profile_info_update)\n        \n        self.assertTrue(result)\n        mock_conn.update_profile_if_exists.assert_called_once_with(profile_id, profile_info_update)\n        mock_conn.transaction.assert_called_once()\n        mock_print.assert_not_called()\n\n    @patch('builtins.print')\n    @patch('database_connection.get_connection')\n    def test_case_2_empty_update_success(self, mock_get_connection, mock_print):\n        \"\"\"Test successful update with empty profile_info_update.\"\"\"\n        mock_conn = MagicMock()\n        mock_get_connection.return_value = mock_conn\n        mock_conn.update_profile_if_exists.return_value = True\n        \n        profile_id = 123\n        profile_info_update = {}\n        result = change_profile_info(profile_id, profile_info_update)\n        \n        self.assertTrue(result)\n        mock_conn.update_profile_if_exists.assert_called_once_with(profile_id, profile_info_update)\n        mock_conn.transaction.assert_called_once()\n        mock_print.assert_not_called()\n\n    @patch('builtins.print')\n    @patch('database_connection.get_connection')\n    def test_case_3_user_not_exist(self, mock_get_connection, mock_print):\n        \"\"\"Test update failure when user does not exist.\"\"\"\n        mock_conn = MagicMock()\n        mock_get_connection.return_value = mock_conn\n        mock_conn.update_profile_if_exists.return_value = False\n        \n        profile_id = 123\n        profile_info_update = {'name': 'John Doe'}\n        result = change_profile_info(profile_id, profile_info_update)\n        \n        self.assertFalse(result)\n        mock_conn.update_profile_if_exists.assert_called_once_with(profile_id, profile_info_update)\n        mock_conn.transaction.assert_called_once()\n        mock_print.assert_called_once_with(f\"User {profile_id} does not exist or update failed.\")\n\n    @patch('builtins.print')\n    @patch('database_connection.get_connection')\n    def test_case_4_exception_during_update(self, mock_get_connection, mock_print):\n        \"\"\"Test update failure due to exception during database operation.\"\"\"\n        mock_conn = MagicMock()\n        mock_get_connection.return_value = mock_conn\n        mock_conn.update_profile_if_exists.side_effect = Exception(\"DB error\")\n        \n        profile_id = 123\n        profile_info_update = {'name': 'John Doe'}\n        result = change_profile_info(profile_id, profile_info_update)\n        \n        self.assertFalse(result)\n        mock_conn.update_profile_if_exists.assert_called_once_with(profile_id, profile_info_update)\n        mock_conn.transaction.assert_called_once()\n        mock_print.assert_called_once_with(f\"Failed to update profile for user {profile_id}: DB error\")\n\n    @patch('builtins.print')\n    @patch('database_connection.get_connection')\n    def test_case_5_profile_id_zero_success(self, mock_get_connection, mock_print):\n        \"\"\"Test successful update with profile_id=0.\"\"\"\n        mock_conn = MagicMock()\n        mock_get_connection.return_value = mock_conn\n        mock_conn.update_profile_if_exists.return_value = True\n        \n        profile_id = 0\n        profile_info_update = {'name': 'John Doe'}\n        result = change_profile_info(profile_id, profile_info_update)\n        \n        self.assertTrue(result)\n        mock_conn.update_profile_if_exists.assert_called_once_with(profile_id, profile_info_update)\n        mock_conn.transaction.assert_called_once()\n        mock_print.assert_not_called()\n\n    @patch('builtins.print')\n    @patch('database_connection.get_connection')\n    def test_case_6_profile_id_negative_failure(self, mock_get_connection, mock_print):\n        \"\"\"Test update failure for negative profile_id.\"\"\"\n        mock_conn = MagicMock()\n        mock_get_connection.return_value = mock_conn\n        mock_conn.update_profile_if_exists.return_value = False\n        \n        profile_id = -1\n        profile_info_update = {'name': 'John Doe'}\n        result = change_profile_info(profile_id, profile_info_update)\n        \n        self.assertFalse(result)\n        mock_conn.update_profile_if_exists.assert_called_once_with(profile_id, profile_info_update)\n        mock_conn.transaction.assert_called_once()\n        mock_print.assert_called_once_with(f\"User {profile_id} does not exist or update failed.\")\n\n    @patch('builtins.print')\n    @patch('database_connection.get_connection')\n    def test_case_7_large_profile_id_success(self, mock_get_connection, mock_print):\n        \"\"\"Test successful update with very large profile_id.\"\"\"\n        mock_conn = MagicMock()\n        mock_get_connection.return_value = mock_conn\n        mock_conn.update_profile_if_exists.return_value = True\n        \n        profile_id = 10**18\n        profile_info_update = {'name': 'John Doe'}\n        result = change_profile_info(profile_id, profile_info_update)\n        \n        self.assertTrue(result)\n        mock_conn.update_profile_if_exists.assert_called_once_with(profile_id, profile_info_update)\n        mock_conn.transaction.assert_called_once()\n        mock_print.assert_not_called()\n\n    @patch('builtins.print')\n    @patch('database_connection.get_connection')\n    def test_case_8_invalid_profile_id_type(self, mock_get_connection, mock_print):\n        \"\"\"Test update failure with invalid profile_id type (string).\"\"\"\n        mock_conn = MagicMock()\n        mock_get_connection.return_value = mock_conn\n        mock_conn.update_profile_if_exists.side_effect = TypeError(\"Invalid type for profile_id\")\n        \n        profile_id = '123'\n        profile_info_update = {'name': 'John Doe'}\n        result = change_profile_info(profile_id, profile_info_update)\n        \n        self.assertFalse(result)\n        mock_conn.update_profile_if_exists.assert_called_once_with(profile_id, profile_info_update)\n        mock_conn.transaction.assert_called_once()\n        mock_print.assert_called_once_with(f\"Failed to update profile for user {profile_id}: Invalid type for profile_id\")\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 8, "task_id": "6c937c7b"}
{"test": "import unittest\nfrom unittest.mock import patch, MagicMock\n\nclass TestEditUserAccount(unittest.TestCase):\n\n    @patch('database_connection.get_connection')\n    def test_successful_update(self, mock_get_connection):\n        \"\"\"Test updating a user that exists with valid data.\"\"\"\n        mock_db = MagicMock()\n        mock_get_connection.return_value = mock_db\n        mock_db.update_profile_if_exists.return_value = True\n        \n        result = edit_user_account(123, {'name': 'John Doe', 'email': 'john@example.com'})\n        self.assertTrue(result)\n        mock_db.update_profile_if_exists.assert_called_once_with(123, {'name': 'John Doe', 'email': 'john@example.com'})\n\n    @patch('database_connection.get_connection')\n    def test_user_not_found(self, mock_get_connection):\n        \"\"\"Test updating a user that does not exist.\"\"\"\n        mock_db = MagicMock()\n        mock_get_connection.return_value = mock_db\n        mock_db.update_profile_if_exists.return_value = False\n        \n        with patch('builtins.print') as mock_print:\n            result = edit_user_account(999, {'name': 'Nonexistent'})\n            self.assertFalse(result)\n            mock_print.assert_called_once_with(\"User 999 does not exist or update failed.\")\n\n    @patch('database_connection.get_connection')\n    def test_database_exception(self, mock_get_connection):\n        \"\"\"Test database operation raising an exception during update.\"\"\"\n        mock_db = MagicMock()\n        mock_get_connection.return_value = mock_db\n        mock_db.update_profile_if_exists.side_effect = Exception(\"Connection error\")\n        \n        with patch('builtins.print') as mock_print:\n            result = edit_user_account(123, {'name': 'John'})\n            self.assertFalse(result)\n            mock_print.assert_called_once_with(\"Failed to update profile for user 123: Connection error\")\n\n    @patch('database_connection.get_connection')\n    def test_negative_account_id_success(self, mock_get_connection):\n        \"\"\"Test successful update with a negative account ID.\"\"\"\n        mock_db = MagicMock()\n        mock_get_connection.return_value = mock_db\n        mock_db.update_profile_if_exists.return_value = True\n        \n        result = edit_user_account(-456, {'name': 'Negative ID'})\n        self.assertTrue(result)\n        mock_db.update_profile_if_exists.assert_called_once_with(-456, {'name': 'Negative ID'})\n\n    @patch('database_connection.get_connection')\n    def test_zero_account_id_success(self, mock_get_connection):\n        \"\"\"Test successful update with a zero account ID.\"\"\"\n        mock_db = MagicMock()\n        mock_get_connection.return_value = mock_db\n        mock_db.update_profile_if_exists.return_value = True\n        \n        result = edit_user_account(0, {'name': 'Zero ID'})\n        self.assertTrue(result)\n        mock_db.update_profile_if_exists.assert_called_once_with(0, {'name': 'Zero ID'})\n\n    @patch('database_connection.get_connection')\n    def test_non_int_account_id(self, mock_get_connection):\n        \"\"\"Test update with a non-integer account ID causing a database exception.\"\"\"\n        mock_db = MagicMock()\n        mock_get_connection.return_value = mock_db\n        mock_db.update_profile_if_exists.side_effect = TypeError(\"Invalid account ID type\")\n        \n        with patch('builtins.print') as mock_print:\n            result = edit_user_account('invalid_id', {'name': 'Test'})\n            self.assertFalse(result)\n            mock_print.assert_called_once_with(\"Failed to update profile for user invalid_id: Invalid account ID type\")\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 6, "task_id": "1f3a703b"}
{"test": "import unittest\nfrom unittest.mock import patch, MagicMock\nfrom solution import modify_user_profile\n\nclass TestModifyUserProfile(unittest.TestCase):\n\n    @patch('database_connection.get_connection')\n    def test_success(self, mock_get_connection):\n        \"\"\"Test with valid uid and data, and the update is successful.\"\"\"\n        mock_db = MagicMock()\n        mock_get_connection.return_value = mock_db\n        mock_db.update_profile_if_exists.return_value = True\n        result = modify_user_profile(123, {'name': 'Alice'})\n        self.assertTrue(result)\n\n    @patch('database_connection.get_connection')\n    def test_user_not_found(self, mock_get_connection):\n        \"\"\"Test when the user does not exist (update returns False).\"\"\"\n        mock_db = MagicMock()\n        mock_get_connection.return_value = mock_db\n        mock_db.update_profile_if_exists.return_value = False\n        result = modify_user_profile(123, {'name': 'Alice'})\n        self.assertFalse(result)\n\n    @patch('database_connection.get_connection')\n    def test_exception_in_transaction(self, mock_get_connection):\n        \"\"\"Test when the transaction context raises an exception.\"\"\"\n        mock_db = MagicMock()\n        mock_get_connection.return_value = mock_db\n        mock_db.transaction.side_effect = Exception(\"DB error\")\n        result = modify_user_profile(123, {'name': 'Alice'})\n        self.assertFalse(result)\n\n    @patch('database_connection.get_connection')\n    def test_empty_data_success(self, mock_get_connection):\n        \"\"\"Test with an empty dict for updated_profile_data and update succeeds.\"\"\"\n        mock_db = MagicMock()\n        mock_get_connection.return_value = mock_db\n        mock_db.update_profile_if_exists.return_value = True\n        result = modify_user_profile(123, {})\n        self.assertTrue(result)\n\n    @patch('database_connection.get_connection')\n    def test_negative_uid_success(self, mock_get_connection):\n        \"\"\"Test with a negative uid and update succeeds.\"\"\"\n        mock_db = MagicMock()\n        mock_get_connection.return_value = mock_db\n        mock_db.update_profile_if_exists.return_value = True\n        result = modify_user_profile(-123, {'name': 'Alice'})\n        self.assertTrue(result)\n\n    @patch('database_connection.get_connection')\n    def test_negative_uid_failure(self, mock_get_connection):\n        \"\"\"Test with a negative uid and update fails (user not found or update fails).\"\"\"\n        mock_db = MagicMock()\n        mock_get_connection.return_value = mock_db\n        mock_db.update_profile_if_exists.return_value = False\n        result = modify_user_profile(-123, {'name': 'Alice'})\n        self.assertFalse(result)\n\n    @patch('database_connection.get_connection')\n    def test_invalid_uid_type(self, mock_get_connection):\n        \"\"\"Test with a non-integer uid (string) that causes an exception in the update method.\"\"\"\n        mock_db = MagicMock()\n        mock_get_connection.return_value = mock_db\n        mock_db.update_profile_if_exists.side_effect = TypeError(\"invalid type\")\n        result = modify_user_profile(\"123\", {'name': 'Alice'})\n        self.assertFalse(result)\n\n    @patch('database_connection.get_connection')\n    def test_invalid_profile_data_type(self, mock_get_connection):\n        \"\"\"Test with a non-dict for updated_profile_data (string) causing an exception.\"\"\"\n        mock_db = MagicMock()\n        mock_get_connection.return_value = mock_db\n        mock_db.update_profile_if_exists.side_effect = TypeError(\"invalid type\")\n        result = modify_user_profile(123, \"name=Alice\")\n        self.assertFalse(result)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 8, "task_id": "299577da"}
{"test": "import unittest\nfrom unittest.mock import patch, MagicMock\n\n# This test assumes the function 'change_user_profile' and 'database_connection' are defined in the same module (__main__)\n# If defined elsewhere, adjust the patch target accordingly\n\nclass TestChangeUserProfile(unittest.TestCase):\n\n    @patch('__main__.database_connection.get_connection')\n    def test_successful_update(self, mock_get_conn):\n        \"\"\"Test updating profile with valid inputs and existing user.\"\"\"\n        db_mock = MagicMock()\n        mock_get_conn.return_value = db_mock\n        db_mock.update_profile_if_exists.return_value = True\n        \n        self.assertTrue(change_user_profile(1, {\"name\": \"Alice\"}))\n        db_mock.update_profile_if_exists.assert_called_once_with(1, {\"name\": \"Alice\"})\n\n    @patch('__main__.database_connection.get_connection')\n    def test_user_not_found(self, mock_get_conn):\n        \"\"\"Test when user does not exist in the database.\"\"\"\n        db_mock = MagicMock()\n        mock_get_conn.return_value = db_mock\n        db_mock.update_profile_if_exists.return_value = False\n        \n        self.assertFalse(change_user_profile(2, {\"name\": \"Bob\"}))\n\n    @patch('__main__.database_connection.get_connection')\n    def test_database_exception(self, mock_get_conn):\n        \"\"\"Test handling of database exceptions during update.\"\"\"\n        db_mock = MagicMock()\n        mock_get_conn.return_value = db_mock\n        db_mock.update_profile_if_exists.side_effect = Exception(\"DB error\")\n        \n        self.assertFalse(change_user_profile(3, {\"name\": \"Charlie\"}))\n\n    @patch('__main__.database_connection.get_connection')\n    def test_empty_profile_data(self, mock_get_conn):\n        \"\"\"Test updating with empty profile data (valid edge case).\"\"\"\n        db_mock = MagicMock()\n        mock_get_conn.return_value = db_mock\n        db_mock.update_profile_if_exists.return_value = True\n        \n        self.assertTrue(change_user_profile(4, {}))\n        db_mock.update_profile_if_exists.assert_called_once_with(4, {})\n\n    @patch('__main__.database_connection.get_connection')\n    def test_invalid_user_identifier_type(self, mock_get_conn):\n        \"\"\"Test non-integer user_identifier causing database error.\"\"\"\n        db_mock = MagicMock()\n        mock_get_conn.return_value = db_mock\n        db_mock.update_profile_if_exists.side_effect = Exception(\"Type error\")\n        \n        self.assertFalse(change_user_profile(\"invalid_id\", {\"name\": \"Alice\"}))\n\n    @patch('__main__.database_connection.get_connection')\n    def test_invalid_profile_data_type(self, mock_get_conn):\n        \"\"\"Test non-dictionary fresh_profile_data causing database error.\"\"\"\n        db_mock = MagicMock()\n        mock_get_conn.return_value = db_mock\n        db_mock.update_profile_if_exists.side_effect = Exception(\"Type error\")\n        \n        self.assertFalse(change_user_profile(5, \"invalid_profile_data\"))\n\n    @patch('__main__.database_connection.get_connection')\n    def test_zero_user_identifier_exists(self, mock_get_conn):\n        \"\"\"Test user_identifier=0 when user exists.\"\"\"\n        db_mock = MagicMock()\n        mock_get_conn.return_value = db_mock\n        db_mock.update_profile_if_exists.return_value = True\n        \n        self.assertTrue(change_user_profile(0, {\"name\": \"Zero\"}))\n\n    @patch('__main__.database_connection.get_connection')\n    def test_zero_user_identifier_not_exists(self, mock_get_conn):\n        \"\"\"Test user_identifier=0 when user does not exist.\"\"\"\n        db_mock = MagicMock()\n        mock_get_conn.return_value = db_mock\n        db_mock.update_profile_if_exists.return_value = False\n        \n        self.assertFalse(change_user_profile(0, {\"name\": \"Zero\"}))\n\n    @patch('__main__.database_connection.get_connection')\n    def test_negative_user_identifier(self, mock_get_conn):\n        \"\"\"Test negative user_identifier (treated as non-existing).\"\"\"\n        db_mock = MagicMock()\n        mock_get_conn.return_value = db_mock\n        db_mock.update_profile_if_exists.return_value = False\n        \n        self.assertFalse(change_user_profile(-1, {\"name\": \"Negative\"}))\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 9, "task_id": "4f6d8e14"}
{"test": "import unittest\nfrom unittest.mock import patch, MagicMock\n\n# Adjust the following import to the module where revise_user_profile is defined.\nfrom my_module import revise_user_profile\n\n\nclass TestReviseUserProfile(unittest.TestCase):\n    def test_successful_update(self):\n        \"\"\"Test successful update with valid ID and non-empty updates.\"\"\"\n        with patch('my_module.database_connection.get_connection') as mock_get_connection, \\\n             patch('builtins.print') as mock_print:\n            mock_db = MagicMock()\n            mock_get_connection.return_value = mock_db\n            mock_db.update_profile_if_exists.return_value = True\n            \n            profile_id = 123\n            updates = {'name': 'Alice'}\n            result = revise_user_profile(profile_id, updates)\n            self.assertTrue(result)\n            mock_db.update_profile_if_exists.assert_called_once_with(profile_id, updates)\n\n    def test_user_not_found(self):\n        \"\"\"Test user not found scenario.\"\"\"\n        with patch('my_module.database_connection.get_connection') as mock_get_connection, \\\n             patch('builtins.print') as mock_print:\n            mock_db = MagicMock()\n            mock_get_connection.return_value = mock_db\n            mock_db.update_profile_if_exists.return_value = False\n            \n            profile_id = 123\n            updates = {'name': 'Alice'}\n            result = revise_user_profile(profile_id, updates)\n            self.assertFalse(result)\n            mock_print.assert_called_once_with(f'User {profile_id} does not exist or update failed.')\n\n    def test_exception_during_update(self):\n        \"\"\"Test database exception during update.\"\"\"\n        with patch('my_module.database_connection.get_connection') as mock_get_connection, \\\n             patch('builtins.print') as mock_print:\n            mock_db = MagicMock()\n            mock_get_connection.return_value = mock_db\n            mock_db.update_profile_if_exists.side_effect = Exception('DB error')\n            \n            profile_id = 123\n            updates = {'name': 'Alice'}\n            result = revise_user_profile(profile_id, updates)\n            self.assertFalse(result)\n            mock_print.assert_called_once_with(f'Failed to update profile for user {profile_id}: DB error')\n\n    def test_profile_id_zero(self):\n        \"\"\"Test with profile_id=0 that exists.\"\"\"\n        with patch('my_module.database_connection.get_connection') as mock_get_connection, \\\n             patch('builtins.print') as mock_print:\n            mock_db = MagicMock()\n            mock_get_connection.return_value = mock_db\n            mock_db.update_profile_if_exists.return_value = True\n            \n            profile_id = 0\n            updates = {'name': 'Alice'}\n            result = revise_user_profile(profile_id, updates)\n            self.assertTrue(result)\n\n    def test_profile_id_negative(self):\n        \"\"\"Test with negative profile_id (non-existent).\"\"\"\n        with patch('my_module.database_connection.get_connection') as mock_get_connection, \\\n             patch('builtins.print') as mock_print:\n            mock_db = MagicMock()\n            mock_get_connection.return_value = mock_db\n            mock_db.update_profile_if_exists.return_value = False\n            \n            profile_id = -1\n            updates = {'name': 'Alice'}\n            result = revise_user_profile(profile_id, updates)\n            self.assertFalse(result)\n\n    def test_profile_id_large(self):\n        \"\"\"Test with large profile_id that exists.\"\"\"\n        with patch('my_module.database_connection.get_connection') as mock_get_connection, \\\n             patch('builtins.print') as mock_print:\n            mock_db = MagicMock()\n            mock_get_connection.return_value = mock_db\n            mock_db.update_profile_if_exists.return_value = True\n            \n            profile_id = 10**18\n            updates = {'name': 'Alice'}\n            result = revise_user_profile(profile_id, updates)\n            self.assertTrue(result)\n\n    def test_empty_updates(self):\n        \"\"\"Test with empty updates dictionary.\"\"\"\n        with patch('my_module.database_connection.get_connection') as mock_get_connection, \\\n             patch('builtins.print') as mock_print:\n            mock_db = MagicMock()\n            mock_get_connection.return_value = mock_db\n            mock_db.update_profile_if_exists.return_value = True\n            \n            profile_id = 123\n            updates = {}\n            result = revise_user_profile(profile_id, updates)\n            self.assertTrue(result)\n\n    def test_updates_none(self):\n        \"\"\"Test with updates=None causing database exception.\"\"\"\n        with patch('my_module.database_connection.get_connection') as mock_get_connection, \\\n             patch('builtins.print') as mock_print:\n            mock_db = MagicMock()\n            mock_get_connection.return_value = mock_db\n            mock_db.update_profile_if_exists.side_effect = TypeError('None type not allowed')\n            \n            profile_id = 123\n            updates = None\n            result = revise_user_profile(profile_id, updates)\n            self.assertFalse(result)\n            mock_print.assert_called_once_with(f'Failed to update profile for user {profile_id}: None type not allowed')\n\n    def test_updates_invalid_type(self):\n        \"\"\"Test with updates as string causing database exception.\"\"\"\n        with patch('my_module.database_connection.get_connection') as mock_get_connection, \\\n             patch('builtins.print') as mock_print:\n            mock_db = MagicMock()\n            mock_get_connection.return_value = mock_db\n            mock_db.update_profile_if_exists.side_effect = TypeError('must be dict, not str')\n            \n            profile_id = 123\n            updates = 'invalid'\n            result = revise_user_profile(profile_id, updates)\n            self.assertFalse(result)\n            mock_print.assert_called_once_with(f'Failed to update profile for user {profile_id}: must be dict, not str')", "num_test_cases": 9, "task_id": "a630f807"}
{"test": "import unittest\nimport fcntl\nfrom unittest.mock import patch, MagicMock\n\nclass TestHandleFileOperation(unittest.TestCase):\n\n    @patch('os.path.exists')\n    @patch('os.path.getsize')\n    @patch('fcntl.flock')\n    @patch('builtins.open')\n    @patch('time.sleep')\n    def test_case_1(self, mock_sleep, mock_open, mock_flock, mock_getsize, mock_exists):\n        # Test happy path: file exists, non-empty, lock acquired -> returns True\n        mock_exists.return_value = True\n        mock_getsize.return_value = 100\n        mock_file = MagicMock()\n        mock_file.fileno.return_value = 123\n        mock_open.return_value = mock_file\n        \n        result = handle_file_operation('/fake/path')\n        self.assertTrue(result)\n        mock_exists.assert_called_once_with('/fake/path')\n        mock_open.assert_called_once_with('/fake/path', 'r+')\n        mock_flock.assert_called_once_with(123, fcntl.LOCK_EX | fcntl.LOCK_NB)\n        mock_getsize.assert_called_once_with('/fake/path')\n        mock_sleep.assert_called_once_with(5)\n\n    @patch('os.path.exists')\n    @patch('os.path.getsize')\n    @patch('fcntl.flock')\n    @patch('builtins.open')\n    @patch('time.sleep')\n    def test_case_2(self, mock_sleep, mock_open, mock_flock, mock_getsize, mock_exists):\n        # Test file does not exist -> returns False\n        mock_exists.return_value = False\n        result = handle_file_operation('/fake/path')\n        self.assertFalse(result)\n        mock_exists.assert_called_once_with('/fake/path')\n        mock_open.assert_not_called()\n\n    @patch('os.path.exists')\n    @patch('os.path.getsize')\n    @patch('fcntl.flock')\n    @patch('builtins.open')\n    @patch('time.sleep')\n    def test_case_3(self, mock_sleep, mock_open, mock_flock, mock_getsize, mock_exists):\n        # Test file exists but is empty -> returns False\n        mock_exists.return_value = True\n        mock_getsize.return_value = 0\n        mock_file = MagicMock()\n        mock_file.fileno.return_value = 123\n        mock_open.return_value = mock_file\n        \n        result = handle_file_operation('/fake/path')\n        self.assertFalse(result)\n        mock_exists.assert_called_once_with('/fake/path')\n        mock_open.assert_called_once_with('/fake/path', 'r+')\n        mock_flock.assert_called_once_with(123, fcntl.LOCK_EX | fcntl.LOCK_NB)\n        mock_getsize.assert_called_once_with('/fake/path')\n        mock_sleep.assert_not_called()\n\n    @patch('os.path.exists')\n    @patch('os.path.getsize')\n    @patch('fcntl.flock')\n    @patch('builtins.open')\n    @patch('time.sleep')\n    def test_case_4(self, mock_sleep, mock_open, mock_flock, mock_getsize, mock_exists):\n        # Test lock conflict (IOError from flock) -> returns False\n        mock_exists.return_value = True\n        mock_getsize.return_value = 100\n        mock_file = MagicMock()\n        mock_file.fileno.return_value = 123\n        mock_open.return_value = mock_file\n        mock_flock.side_effect = IOError()\n        \n        result = handle_file_operation('/fake/path')\n        self.assertFalse(result)\n        mock_flock.assert_called_once_with(123, fcntl.LOCK_EX | fcntl.LOCK_NB)\n        mock_getsize.assert_not_called()\n        mock_sleep.assert_not_called()\n\n    @patch('os.path.exists')\n    @patch('os.path.getsize')\n    @patch('fcntl.flock')\n    @patch('builtins.open')\n    @patch('time.sleep')\n    def test_case_5(self, mock_sleep, mock_open, mock_flock, mock_getsize, mock_exists):\n        # Test open raises OSError -> returns False\n        mock_exists.return_value = True\n        mock_open.side_effect = OSError()\n        \n        result = handle_file_operation('/fake/path')\n        self.assertFalse(result)\n        mock_open.assert_called_once_with('/fake/path', 'r+')\n        mock_flock.assert_not_called()\n        mock_getsize.assert_not_called()\n        mock_sleep.assert_not_called()\n\n    @patch('os.path.exists')\n    @patch('os.path.getsize')\n    @patch('fcntl.flock')\n    @patch('builtins.open')\n    @patch('time.sleep')\n    def test_case_6(self, mock_sleep, mock_open, mock_flock, mock_getsize, mock_exists):\n        # Test getsize raises OSError -> returns False\n        mock_exists.return_value = True\n        mock_getsize.side_effect = OSError()\n        mock_file = MagicMock()\n        mock_file.fileno.return_value = 123\n        mock_open.return_value = mock_file\n        \n        result = handle_file_operation('/fake/path')\n        self.assertFalse(result)\n        mock_flock.assert_called_once_with(123, fcntl.LOCK_EX | fcntl.LOCK_NB)\n        mock_getsize.assert_called_once_with('/fake/path')\n        mock_sleep.assert_not_called()\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 6, "task_id": "e5952500"}
{"test": "import unittest\nfrom unittest.mock import patch, mock_open\n\nclass TestExecuteFileHandler(unittest.TestCase):\n\n    def test_file_does_not_exist(self):\n        # Test when target file does not exist\n        with patch('os.path.exists') as mock_exists:\n            mock_exists.return_value = False\n            result = execute_file_handler('/path/to/nonexistent/file.txt')\n            self.assertFalse(result)\n\n    def test_file_empty(self):\n        # Test when file exists but is empty\n        with patch('os.path.exists') as mock_exists, \\\n             patch('os.path.getsize') as mock_getsize, \\\n             patch('builtins.print') as mock_print, \\\n             patch('builtins.open', new_callable=mock_open) as mock_file:\n            mock_exists.return_value = True\n            mock_getsize.return_value = 0\n            mock_file.return_value.fileno.return_value = 123\n            result = execute_file_handler('/path/to/empty/file.txt')\n            self.assertFalse(result)\n            mock_print.assert_called_once_with(\"File /path/to/empty/file.txt is not ready for processing.\")\n\n    def test_successful_processing(self):\n        # Test happy path: file exists, non-empty, lock acquired\n        with patch('os.path.exists') as mock_exists, \\\n             patch('os.path.getsize') as mock_getsize, \\\n             patch('fcntl.flock') as mock_flock, \\\n             patch('builtins.print') as mock_print, \\\n             patch('time.sleep') as mock_sleep, \\\n             patch('builtins.open', new_callable=mock_open) as mock_file:\n            mock_exists.return_value = True\n            mock_getsize.return_value = 100\n            mock_file.return_value.fileno.return_value = 123\n            result = execute_file_handler('/path/to/valid/file.txt')\n            self.assertTrue(result)\n            mock_sleep.assert_called_once_with(5)\n            mock_print.assert_called_once_with(\"Processing file: /path/to/valid/file.txt\")\n\n    def test_file_locked(self):\n        # Test when file is locked by another process\n        with patch('os.path.exists') as mock_exists, \\\n             patch('os.path.getsize') as mock_getsize, \\\n             patch('fcntl.flock') as mock_flock, \\\n             patch('builtins.print') as mock_print, \\\n             patch('builtins.open', new_callable=mock_open) as mock_file:\n            mock_exists.return_value = True\n            mock_getsize.return_value = 100\n            mock_file.return_value.fileno.return_value = 123\n            mock_flock.side_effect = IOError\n            result = execute_file_handler('/path/to/locked/file.txt')\n            self.assertFalse(result)\n            mock_print.assert_called_once_with(\"File /path/to/locked/file.txt is locked by another process.\")\n\n    def test_unexpected_exception_during_processing(self):\n        # Test when an unexpected exception occurs during processing\n        with patch('os.path.exists') as mock_exists, \\\n             patch('os.path.getsize') as mock_getsize, \\\n             patch('fcntl.flock') as mock_flock, \\\n             patch('builtins.print') as mock_print, \\\n             patch('builtins.open', new_callable=mock_open) as mock_file:\n            mock_exists.return_value = True\n            mock_getsize.side_effect = OSError(\"Test OSError\")\n            mock_file.return_value.fileno.return_value = 123\n            result = execute_file_handler('/path/to/error/file.txt')\n            self.assertFalse(result)\n            mock_print.assert_called_once_with(\"Failed to process file /path/to/error/file.txt: Test OSError\")\n", "num_test_cases": 5, "task_id": "52251a63"}
{"test": "import unittest\nimport sys\nfrom unittest.mock import patch, mock_open\n\n@unittest.skipIf(sys.platform == \"win32\", \"Requires non-Windows environment\")\nclass TestFileProcessingTask(unittest.TestCase):\n\n    @patch('os.path.exists')\n    @patch('os.path.getsize')\n    @patch('builtins.open', new_callable=mock_open)\n    @patch('fcntl.flock')\n    @patch('time.sleep')\n    def test_successful_processing(self, mock_sleep, mock_flock, mock_open, mock_getsize, mock_exists):\n        # Test when file exists, is unlocked, and has content - should return True\n        mock_exists.return_value = True\n        mock_getsize.return_value = 100\n        result = file_processing_task('/path/to/file.txt')\n        self.assertTrue(result)\n        mock_sleep.assert_called_once_with(5)\n\n    @patch('os.path.exists')\n    @patch('os.path.getsize')\n    @patch('builtins.open', new_callable=mock_open)\n    @patch('fcntl.flock')\n    @patch('time.sleep')\n    def test_file_empty(self, mock_sleep, mock_flock, mock_open, mock_getsize, mock_exists):\n        # Test when file exists and is unlocked but empty - should return False\n        mock_exists.return_value = True\n        mock_getsize.return_value = 0\n        result = file_processing_task('/path/to/file.txt')\n        self.assertFalse(result)\n        mock_sleep.assert_not_called()\n\n    @patch('os.path.exists')\n    @patch('os.path.getsize')\n    @patch('builtins.open', new_callable=mock_open)\n    @patch('fcntl.flock')\n    @patch('time.sleep')\n    def test_file_not_found(self, mock_sleep, mock_flock, mock_open, mock_getsize, mock_exists):\n        # Test when file does not exist - should return False\n        mock_exists.return_value = False\n        result = file_processing_task('/path/to/file.txt')\n        self.assertFalse(result)\n        mock_open.assert_not_called()\n        mock_flock.assert_not_called()\n        mock_sleep.assert_not_called()\n\n    @patch('os.path.exists')\n    @patch('os.path.getsize')\n    @patch('builtins.open', new_callable=mock_open)\n    @patch('fcntl.flock')\n    @patch('time.sleep')\n    def test_file_locked(self, mock_sleep, mock_flock, mock_open, mock_getsize, mock_exists):\n        # Test when file is locked by another process - should return False\n        mock_exists.return_value = True\n        mock_getsize.return_value = 100\n        mock_flock.side_effect = IOError(\"Lock failed\")\n        result = file_processing_task('/path/to/file.txt')\n        self.assertFalse(result)\n        mock_sleep.assert_not_called()\n\n    @patch('os.path.exists')\n    @patch('os.path.getsize')\n    @patch('builtins.open', new_callable=mock_open)\n    @patch('fcntl.flock')\n    @patch('time.sleep')\n    def test_open_failure(self, mock_sleep, mock_flock, mock_open, mock_getsize, mock_exists):\n        # Test when opening file fails (e.g., permission error) - should return False\n        mock_exists.return_value = True\n        mock_open.side_effect = OSError(\"Permission denied\")\n        result = file_processing_task('/path/to/file.txt')\n        self.assertFalse(result)\n        mock_flock.assert_not_called()\n        mock_sleep.assert_not_called()\n\n    @patch('os.path.exists')\n    @patch('os.path.getsize')\n    @patch('builtins.open', new_callable=mock_open)\n    @patch('fcntl.flock')\n    @patch('time.sleep')\n    def test_getsize_failure(self, mock_sleep, mock_flock, mock_open, mock_getsize, mock_exists):\n        # Test when getting file size fails (e.g., file deleted after opening) - should return False\n        mock_exists.return_value = True\n        mock_getsize.side_effect = Exception(\"File not accessible\")\n        result = file_processing_task('/path/to/file.txt')\n        self.assertFalse(result)\n        mock_sleep.assert_not_called()\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 6, "task_id": "d9b8a101"}
{"test": "import unittest\nfrom unittest.mock import patch, mock_open\n\nclass TestAnalyzeLargeDocument(unittest.TestCase):\n\n    @patch('os.path.exists', return_value=True)\n    @patch('os.path.getsize', return_value=100)\n    @patch('builtins.open', new_callable=mock_open)\n    @patch('fcntl.flock')\n    @patch('time.sleep')\n    @patch('builtins.print')\n    def test_successful_processing(self, mock_print, mock_sleep, mock_flock, mock_file, mock_getsize, mock_exists):\n        # Test when file exists, has content, and lock is acquired\n        result = analyze_large_document('valid_path.txt')\n        self.assertTrue(result)\n        mock_flock.assert_called_once()\n        mock_sleep.assert_called_once_with(5)\n\n    @patch('os.path.exists', return_value=False)\n    @patch('builtins.print')\n    def test_file_not_found(self, mock_print, mock_exists):\n        # Test when file does not exist\n        result = analyze_large_document('missing.txt')\n        self.assertFalse(result)\n\n    @patch('os.path.exists', return_value=True)\n    @patch('builtins.open', new_callable=mock_open)\n    @patch('fcntl.flock', side_effect=IOError)\n    @patch('builtins.print')\n    def test_locked_file(self, mock_print, mock_flock, mock_file, mock_exists):\n        # Test when file is locked by another process\n        result = analyze_large_document('locked.txt')\n        self.assertFalse(result)\n\n    @patch('os.path.exists', return_value=True)\n    @patch('os.path.getsize', return_value=0)\n    @patch('builtins.open', new_callable=mock_open)\n    @patch('fcntl.flock')\n    @patch('builtins.print')\n    def test_empty_file(self, mock_print, mock_flock, mock_file, mock_getsize, mock_exists):\n        # Test when file exists but is empty\n        result = analyze_large_document('empty.txt')\n        self.assertFalse(result)\n\n    @patch('os.path.exists', return_value=True)\n    @patch('os.path.getsize', return_value=100)\n    @patch('builtins.open', new_callable=mock_open)\n    @patch('fcntl.flock')\n    @patch('time.sleep', side_effect=Exception('Simulated error'))\n    @patch('builtins.print')\n    def test_processing_exception(self, mock_print, mock_sleep, mock_flock, mock_file, mock_getsize, mock_exists):\n        # Test when an exception occurs during processing\n        result = analyze_large_document('error_file.txt')\n        self.assertFalse(result)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 5, "task_id": "36f9e115"}
{"test": "import os\nimport tempfile\nimport time\nimport fcntl\nimport unittest\nfrom unittest.mock import patch\nimport sys\n\n@unittest.skipUnless(hasattr(fcntl, 'flock'), \"Requires Unix system with fcntl support\")\nclass TestCheckFileReadyAndProcess(unittest.TestCase):\n    def setUp(self):\n        self.temp_dir = tempfile.TemporaryDirectory()\n        self.file_path = os.path.join(self.temp_dir.name, 'test_file.txt')\n    \n    def tearDown(self):\n        self.temp_dir.cleanup()\n    \n    def test_case_1(self):\n        # Happy path: file exists, non-empty, unlocked -> returns True\n        with open(self.file_path, 'w') as f:\n            f.write('Content')\n        with patch('time.sleep'):  # Avoid actual sleep\n            result = check_file_ready_and_process(self.file_path)\n        self.assertTrue(result)\n    \n    def test_case_2(self):\n        # File does not exist -> returns False\n        result = check_file_ready_and_process(self.file_path)\n        self.assertFalse(result)\n    \n    def test_case_3(self):\n        # File exists but empty -> returns False\n        with open(self.file_path, 'w') as f:\n            pass  # Create empty file\n        result = check_file_ready_and_process(self.file_path)\n        self.assertFalse(result)\n    \n    def test_case_4(self):\n        # File locked by another process -> returns False\n        with open(self.file_path, 'w') as f:\n            f.write('Content')\n        file_descriptor = open(self.file_path, 'r+')\n        fcntl.flock(file_descriptor, fcntl.LOCK_EX | fcntl.LOCK_NB)\n        try:\n            result = check_file_ready_and_process(self.file_path)\n            self.assertFalse(result)\n        finally:\n            fcntl.flock(file_descriptor, fcntl.LOCK_UN)\n            file_descriptor.close()\n    \n    def test_case_5(self):\n        # Exception during processing (mocked sleep) -> returns False\n        with open(self.file_path, 'w') as f:\n            f.write('Content')\n        with patch('time.sleep', side_effect=Exception(\"Simulated error\")):\n            result = check_file_ready_and_process(self.file_path)\n        self.assertFalse(result)\n    \n    def test_case_6(self):\n        # File without write permission -> returns False\n        with open(self.file_path, 'w') as f:\n            f.write('Content')\n        os.chmod(self.file_path, 0o400)  # Read-only\n        try:\n            result = check_file_ready_and_process(self.file_path)\n            self.assertFalse(result)\n        finally:\n            os.chmod(self.file_path, 0o600)\n    \n    def test_case_7(self):\n        # Exception in getsize (mocked) -> returns False\n        with open(self.file_path, 'w') as f:\n            f.write('Content')\n        with patch('os.path.getsize', side_effect=Exception(\"Simulated error\")):\n            result = check_file_ready_and_process(self.file_path)\n        self.assertFalse(result)\n    \n    def test_case_8(self):\n        # Location is a directory -> returns False\n        dir_path = os.path.join(self.temp_dir.name, 'test_dir')\n        os.mkdir(dir_path)\n        result = check_file_ready_and_process(dir_path)\n        self.assertFalse(result)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 8, "task_id": "fda5c84e"}
{"test": "import unittest\nimport os\nimport tempfile\nimport fcntl\nimport stat\nimport time\n\nclass TestLargeFileProcessing(unittest.TestCase):\n\n    def test_file_not_exist(self):\n        # Test when file does not exist\n        non_existent_file = \"/path/to/non_existent_file.txt\"\n        result = handle_large_file_processing(non_existent_file)\n        self.assertFalse(result)\n\n    def test_file_empty(self):\n        # Test when file exists but is empty\n        with tempfile.NamedTemporaryFile(delete=False) as temp_file:\n            temp_file_path = temp_file.name\n        try:\n            result = handle_large_file_processing(temp_file_path)\n            self.assertFalse(result)\n        finally:\n            os.unlink(temp_file_path)\n\n    def test_happy_path(self):\n        # Test successful processing: file exists, non-empty, and unlocked\n        with tempfile.NamedTemporaryFile(delete=False) as temp_file:\n            temp_file.write(b'data')\n            temp_file_path = temp_file.name\n        try:\n            # This test will take ~5 seconds due to time.sleep\n            result = handle_large_file_processing(temp_file_path)\n            self.assertTrue(result)\n        finally:\n            os.unlink(temp_file_path)\n\n    def test_file_locked(self):\n        # Test when file is locked by another process\n        with tempfile.NamedTemporaryFile(delete=False) as temp_file:\n            temp_file.write(b'data')\n            temp_file_path = temp_file.name\n        \n        # Lock the file using a separate file descriptor\n        locked_file = open(temp_file_path, 'r')\n        fcntl.flock(locked_file.fileno(), fcntl.LOCK_EX | fcntl.LOCK_NB)\n        \n        try:\n            result = handle_large_file_processing(temp_file_path)\n            self.assertFalse(result)\n        finally:\n            fcntl.flock(locked_file.fileno(), fcntl.LOCK_UN)\n            locked_file.close()\n            os.unlink(temp_file_path)\n\n    def test_path_is_directory(self):\n        # Test when path is a directory\n        with tempfile.TemporaryDirectory() as temp_dir:\n            result = handle_large_file_processing(temp_dir)\n            self.assertFalse(result)\n\n    def test_no_permission(self):\n        # Test when file exists but lacks read permission\n        with tempfile.NamedTemporaryFile(delete=False) as temp_file:\n            temp_file.write(b'data')\n            temp_file_path = temp_file.name\n        \n        # Remove all permissions\n        os.chmod(temp_file_path, 0)\n        \n        try:\n            result = handle_large_file_processing(temp_file_path)\n            self.assertFalse(result)\n        finally:\n            # Restore permissions to delete file\n            os.chmod(temp_file_path, stat.S_IRUSR | stat.S_IWUSR)\n            os.unlink(temp_file_path)\n", "num_test_cases": 6, "task_id": "c02a6c17"}
{"test": "import unittest\nfrom unittest.mock import patch, mock_open\n\nclass TestHandleDataFile(unittest.TestCase):\n\n    @patch('os.path.exists')\n    @patch('builtins.open', new_callable=mock_open)\n    @patch('fcntl.flock')\n    @patch('os.path.getsize')\n    @patch('time.sleep')\n    def test_success(self, mock_sleep, mock_getsize, mock_flock, mock_open_file, mock_exists):\n        # Test successful processing: file exists, lock acquired, non-empty file\n        mock_exists.return_value = True\n        mock_getsize.return_value = 100\n        result = handle_data_file('/path/to/file')\n        self.assertTrue(result)\n\n    @patch('os.path.exists')\n    def test_file_not_exists(self, mock_exists):\n        # Test when file does not exist\n        mock_exists.return_value = False\n        result = handle_data_file('/path/to/file')\n        self.assertFalse(result)\n\n    @patch('os.path.exists')\n    @patch('builtins.open', new_callable=mock_open)\n    @patch('fcntl.flock')\n    @patch('os.path.getsize')\n    @patch('time.sleep')\n    def test_file_locked(self, mock_sleep, mock_getsize, mock_flock, mock_open_file, mock_exists):\n        # Test when file is locked by another process\n        mock_exists.return_value = True\n        mock_flock.side_effect = IOError\n        result = handle_data_file('/path/to/file')\n        self.assertFalse(result)\n\n    @patch('os.path.exists')\n    @patch('builtins.open', new_callable=mock_open)\n    @patch('fcntl.flock')\n    @patch('os.path.getsize')\n    @patch('time.sleep')\n    def test_file_empty(self, mock_sleep, mock_getsize, mock_flock, mock_open_file, mock_exists):\n        # Test when file exists but is empty\n        mock_exists.return_value = True\n        mock_getsize.return_value = 0\n        result = handle_data_file('/path/to/file')\n        self.assertFalse(result)\n\n    @patch('os.path.exists')\n    @patch('builtins.open', new_callable=mock_open)\n    @patch('fcntl.flock')\n    @patch('os.path.getsize')\n    @patch('time.sleep')\n    def test_getsize_raises_oserror(self, mock_sleep, mock_getsize, mock_flock, mock_open_file, mock_exists):\n        # Test when os.path.getsize raises OSError\n        mock_exists.return_value = True\n        mock_getsize.side_effect = OSError\n        result = handle_data_file('/path/to/file')\n        self.assertFalse(result)\n\n    @patch('os.path.exists')\n    @patch('builtins.open')\n    def test_open_raises_oserror(self, mock_open_file, mock_exists):\n        # Test when opening the file raises OSError\n        mock_exists.return_value = True\n        mock_open_file.side_effect = OSError\n        result = handle_data_file('/path/to/file')\n        self.assertFalse(result)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 6, "task_id": "5c92ea87"}
{"test": "import unittest\nfrom unittest.mock import patch, mock_open\n\nclass TestProcessDataFile(unittest.TestCase):\n    @patch('builtins.print')\n    @patch('os.path.exists')\n    @patch('os.path.getsize')\n    @patch('builtins.open', new_callable=mock_open)\n    @patch('fcntl.flock')\n    @patch('time.sleep')\n    def test_file_does_not_exist(self, mock_sleep, mock_flock, mock_open_file, mock_getsize, mock_exists, mock_print):\n        # Test when file does not exist\n        mock_exists.return_value = False\n        result = process_data_file('/path/to/file')\n        self.assertFalse(result)\n        mock_open_file.assert_not_called()\n        mock_flock.assert_not_called()\n        mock_getsize.assert_not_called()\n        mock_sleep.assert_not_called()\n        mock_print.assert_not_called()\n    \n    @patch('builtins.print')\n    @patch('os.path.exists')\n    @patch('os.path.getsize')\n    @patch('builtins.open', new_callable=mock_open)\n    @patch('fcntl.flock')\n    @patch('time.sleep')\n    def test_file_empty(self, mock_sleep, mock_flock, mock_open_file, mock_getsize, mock_exists, mock_print):\n        # Test when file exists but is empty\n        mock_exists.return_value = True\n        mock_getsize.return_value = 0\n        result = process_data_file('/path/to/file')\n        self.assertFalse(result)\n        mock_open_file.assert_called_once_with('/path/to/file', 'r+')\n        mock_flock.assert_called_once()\n        mock_print.assert_called_once_with('File /path/to/file is not ready for processing.')\n        mock_sleep.assert_not_called()\n    \n    @patch('builtins.print')\n    @patch('os.path.exists')\n    @patch('os.path.getsize')\n    @patch('builtins.open', new_callable=mock_open)\n    @patch('fcntl.flock')\n    @patch('time.sleep')\n    def test_successful_processing(self, mock_sleep, mock_flock, mock_open_file, mock_getsize, mock_exists, mock_print):\n        # Test successful file processing\n        mock_exists.return_value = True\n        mock_getsize.return_value = 100\n        result = process_data_file('/path/to/file')\n        self.assertTrue(result)\n        mock_open_file.assert_called_once_with('/path/to/file', 'r+')\n        mock_flock.assert_called_once()\n        mock_sleep.assert_called_once_with(5)\n        mock_print.assert_called_once_with('Processing file: /path/to/file')\n    \n    @patch('builtins.print')\n    @patch('os.path.exists')\n    @patch('os.path.getsize')\n    @patch('builtins.open', new_callable=mock_open)\n    @patch('fcntl.flock')\n    @patch('time.sleep')\n    def test_file_locked(self, mock_sleep, mock_flock, mock_open_file, mock_getsize, mock_exists, mock_print):\n        # Test when file is locked by another process\n        mock_exists.return_value = True\n        mock_flock.side_effect = IOError\n        result = process_data_file('/path/to/file')\n        self.assertFalse(result)\n        mock_open_file.assert_called_once_with('/path/to/file', 'r+')\n        mock_flock.assert_called_once()\n        mock_print.assert_called_once_with('File /path/to/file is locked by another process.')\n        mock_getsize.assert_not_called()\n        mock_sleep.assert_not_called()\n    \n    @patch('builtins.print')\n    @patch('os.path.exists')\n    @patch('os.path.getsize')\n    @patch('builtins.open', new_callable=mock_open)\n    @patch('fcntl.flock')\n    @patch('time.sleep')\n    def test_processing_exception(self, mock_sleep, mock_flock, mock_open_file, mock_getsize, mock_exists, mock_print):\n        # Test exception during processing\n        mock_exists.return_value = True\n        mock_getsize.return_value = 100\n        mock_sleep.side_effect = RuntimeError('Simulated error')\n        result = process_data_file('/path/to/file')\n        self.assertFalse(result)\n        mock_open_file.assert_called_once_with('/path/to/file', 'r+')\n        mock_flock.assert_called_once()\n        mock_sleep.assert_called_once_with(5)\n        mock_print.assert_called_once_with('Failed to process file /path/to/file: Simulated error')\n    \n    @patch('builtins.print')\n    @patch('os.path.exists')\n    @patch('builtins.open', new_callable=mock_open)\n    @patch('fcntl.flock')\n    @patch('time.sleep')\n    def test_open_failure(self, mock_sleep, mock_flock, mock_open_file, mock_exists, mock_print):\n        # Test failure when opening file\n        mock_exists.return_value = True\n        mock_open_file.side_effect = OSError('Permission denied')\n        result = process_data_file('/path/to/file')\n        self.assertFalse(result)\n        mock_open_file.assert_called_once_with('/path/to/file', 'r+')\n        mock_flock.assert_not_called()\n        mock_sleep.assert_not_called()\n        mock_print.assert_called_once_with('Failed to process file /path/to/file: Permission denied')\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 6, "task_id": "274e7a5b"}
{"test": "import unittest\nfrom unittest.mock import patch, mock_open, MagicMock\n\nclass TestManageLargeFile(unittest.TestCase):\n    \n    @patch('os.path.exists')\n    @patch('os.path.getsize')\n    @patch('builtins.open', new_callable=mock_open)\n    @patch('fcntl.flock')\n    @patch('time.sleep')\n    def test_successful_processing(self, mock_sleep, mock_flock, mock_file, mock_getsize, mock_exists):\n        \"\"\"Test successful processing: file exists, non-empty, and lock acquired.\"\"\"\n        mock_exists.return_value = True\n        mock_getsize.return_value = 100\n        result = manage_large_file('/valid/path.txt')\n        self.assertTrue(result)\n    \n    @patch('os.path.exists')\n    def test_file_not_found(self, mock_exists):\n        \"\"\"Test when the file does not exist.\"\"\"\n        mock_exists.return_value = False\n        result = manage_large_file('/invalid/path.txt')\n        self.assertFalse(result)\n    \n    @patch('os.path.exists')\n    @patch('os.path.getsize')\n    @patch('builtins.open', new_callable=mock_open)\n    @patch('fcntl.flock')\n    def test_empty_file(self, mock_flock, mock_file, mock_getsize, mock_exists):\n        \"\"\"Test when the file exists but is empty.\"\"\"\n        mock_exists.return_value = True\n        mock_getsize.return_value = 0\n        result = manage_large_file('/empty/path.txt')\n        self.assertFalse(result)\n    \n    @patch('os.path.exists')\n    @patch('os.path.getsize')\n    @patch('builtins.open', new_callable=mock_open)\n    @patch('fcntl.flock')\n    def test_file_locked(self, mock_flock, mock_file, mock_getsize, mock_exists):\n        \"\"\"Test when the file is locked by another process.\"\"\"\n        mock_exists.return_value = True\n        mock_getsize.return_value = 100\n        mock_flock.side_effect = IOError('Locked')\n        result = manage_large_file('/locked/path.txt')\n        self.assertFalse(result)\n    \n    @patch('os.path.exists')\n    @patch('builtins.open')\n    def test_open_exception(self, mock_open, mock_exists):\n        \"\"\"Test when opening the file raises an exception (other than lock).\"\"\"\n        mock_exists.return_value = True\n        mock_open.side_effect = PermissionError('Access denied')\n        result = manage_large_file('/protected/path.txt')\n        self.assertFalse(result)\n    \n    @patch('os.path.exists')\n    @patch('os.path.getsize')\n    @patch('builtins.open', new_callable=mock_open)\n    @patch('fcntl.flock')\n    @patch('time.sleep')\n    def test_processing_exception(self, mock_sleep, mock_flock, mock_file, mock_getsize, mock_exists):\n        \"\"\"Test when an exception occurs during processing.\"\"\"\n        mock_exists.return_value = True\n        mock_getsize.return_value = 100\n        mock_sleep.side_effect = RuntimeError('Processing error')\n        result = manage_large_file('/faulty/path.txt')\n        self.assertFalse(result)", "num_test_cases": 6, "task_id": "4273e55a"}
{"test": "import unittest\nfrom unittest.mock import patch, MagicMock\n\nclass TestRemoveExpiredSessions(unittest.TestCase):\n    \n    def setUp(self):\n        # Create mock objects for database and datetime\n        self.mock_db = MagicMock()\n        self.mock_connection = MagicMock()\n        self.mock_get_connection = patch('session_cleanup.database.get_connection', return_value=self.mock_connection).start()\n        \n        # Set up transaction context manager\n        self.mock_transaction = MagicMock()\n        self.mock_connection.transaction.return_value = self.mock_transaction\n        self.mock_transaction.__enter__.return_value = self.mock_connection\n        self.mock_transaction.__exit__.return_value = None\n        \n        # Import the function after patching\n        from session_cleanup import remove_expired_sessions\n        self.func = remove_expired_sessions\n\n    def tearDown(self):\n        patch.stopall()\n    \n    def test_positive_duration(self):\n        \"\"\"Test with positive duration and deleted sessions\"\"\"\n        self.mock_connection.execute.return_value = MagicMock(rowcount=5)\n        result = self.func(10)\n        self.assertEqual(result, 5)\n        self.mock_transaction.__enter__.assert_called()\n        self.mock_transaction.__exit__.assert_called_once_with(None, None, None)\n    \n    def test_zero_duration(self):\n        \"\"\"Test with zero duration (threshold = current time)\"\"\"\n        self.mock_connection.execute.return_value = MagicMock(rowcount=3)\n        result = self.func(0)\n        self.assertEqual(result, 3)\n        self.mock_connection.execute.assert_called_once()\n    \n    def test_large_duration(self):\n        \"\"\"Test with large duration so no sessions are expired\"\"\"\n        self.mock_connection.execute.return_value = MagicMock(rowcount=0)\n        result = self.func(10000)\n        self.assertEqual(result, 0)\n    \n    def test_negative_duration(self):\n        \"\"\"Test with negative duration (threshold in future)\"\"\"\n        self.mock_connection.execute.return_value = MagicMock(rowcount=100)\n        result = self.func(-10)\n        self.assertEqual(result, 100)\n    \n    def test_exception_handling(self):\n        \"\"\"Test database exception returns 0\"\"\"\n        self.mock_connection.execute.side_effect = Exception(\"DB error\")\n        result = self.func(15)\n        self.assertEqual(result, 0)\n        self.mock_transaction.__exit__.assert_called_once()\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 5, "task_id": "9ee96169"}
{"test": "import unittest\nfrom unittest.mock import patch, MagicMock, ANY\nfrom datetime import datetime, timedelta\n\n# Import the function from the module where it is defined (adjust the module name if necessary)\nfrom session_cleanup import delete_old_sessions\n\nclass TestDeleteOldSessions(unittest.TestCase):\n\n    @patch('session_cleanup.database.get_connection')\n    @patch('session_cleanup.datetime')\n    def test_case_1(self, mock_datetime, mock_get_connection):\n        \"\"\"Test deleting some sessions with a normal expiration limit (10 minutes).\"\"\"\n        fixed_now = datetime(2020, 1, 1, 12, 0, 0)\n        mock_datetime.now.return_value = fixed_now\n        \n        mock_db = MagicMock()\n        mock_get_connection.return_value = mock_db\n        result_mock = MagicMock()\n        result_mock.rowcount = 5\n        mock_db.execute.return_value = result_mock\n        \n        result = delete_old_sessions(10)\n        \n        self.assertEqual(result, 5)\n        expected_threshold = fixed_now - timedelta(minutes=10)\n        mock_db.execute.assert_called_once_with(ANY, (expected_threshold,))\n\n    @patch('session_cleanup.database.get_connection')\n    @patch('session_cleanup.datetime')\n    def test_case_2(self, mock_datetime, mock_get_connection):\n        \"\"\"Test deleting no sessions with a normal expiration limit (10 minutes).\"\"\"\n        fixed_now = datetime(2020, 1, 1, 12, 0, 0)\n        mock_datetime.now.return_value = fixed_now\n        \n        mock_db = MagicMock()\n        mock_get_connection.return_value = mock_db\n        result_mock = MagicMock()\n        result_mock.rowcount = 0\n        mock_db.execute.return_value = result_mock\n        \n        result = delete_old_sessions(10)\n        \n        self.assertEqual(result, 0)\n\n    @patch('session_cleanup.database.get_connection')\n    @patch('session_cleanup.datetime')\n    def test_case_3(self, mock_datetime, mock_get_connection):\n        \"\"\"Test with expiration_limit=0 (should delete sessions older than now, i.e., all sessions).\"\"\"\n        fixed_now = datetime(2020, 1, 1, 12, 0, 0)\n        mock_datetime.now.return_value = fixed_now\n        \n        mock_db = MagicMock()\n        mock_get_connection.return_value = mock_db\n        result_mock = MagicMock()\n        result_mock.rowcount = 100\n        mock_db.execute.return_value = result_mock\n        \n        result = delete_old_sessions(0)\n        \n        self.assertEqual(result, 100)\n        expected_threshold = fixed_now - timedelta(minutes=0)\n        mock_db.execute.assert_called_once_with(ANY, (expected_threshold,))\n\n    @patch('session_cleanup.database.get_connection')\n    @patch('session_cleanup.datetime')\n    def test_case_4(self, mock_datetime, mock_get_connection):\n        \"\"\"Test with a negative expiration_limit (should delete all sessions because threshold is in the future).\"\"\"\n        fixed_now = datetime(2020, 1, 1, 12, 0, 0)\n        mock_datetime.now.return_value = fixed_now\n        \n        mock_db = MagicMock()\n        mock_get_connection.return_value = mock_db\n        result_mock = MagicMock()\n        result_mock.rowcount = 200\n        mock_db.execute.return_value = result_mock\n        \n        result = delete_old_sessions(-10)\n        \n        self.assertEqual(result, 200)\n        expected_threshold = fixed_now - timedelta(minutes=-10)  # fixed_now + 10 minutes\n        mock_db.execute.assert_called_once_with(ANY, (expected_threshold,))\n\n    @patch('session_cleanup.database.get_connection')\n    @patch('session_cleanup.datetime')\n    def test_case_5(self, mock_datetime, mock_get_connection):\n        \"\"\"Test exception handling: returns 0 when an exception occurs during database operation.\"\"\"\n        fixed_now = datetime(2020, 1, 1, 12, 0, 0)\n        mock_datetime.now.return_value = fixed_now\n        \n        mock_db = MagicMock()\n        mock_get_connection.return_value = mock_db\n        mock_db.execute.side_effect = Exception(\"DB error\")\n        \n        result = delete_old_sessions(10)\n        \n        self.assertEqual(result, 0)\n\n    @patch('session_cleanup.database.get_connection')\n    @patch('session_cleanup.datetime')\n    def test_case_6(self, mock_datetime, mock_get_connection):\n        \"\"\"Test with a large positive expiration_limit (1000000 minutes).\"\"\"\n        fixed_now = datetime(2020, 1, 1, 12, 0, 0)\n        mock_datetime.now.return_value = fixed_now\n        \n        mock_db = MagicMock()\n        mock_get_connection.return_value = mock_db\n        result_mock = MagicMock()\n        result_mock.rowcount = 3\n        mock_db.execute.return_value = result_mock\n        \n        result = delete_old_sessions(1000000)\n        \n        self.assertEqual(result, 3)\n        expected_threshold = fixed_now - timedelta(minutes=1000000)\n        mock_db.execute.assert_called_once_with(ANY, (expected_threshold,))\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 6, "task_id": "782dd2f4"}
{"test": "import unittest\nfrom unittest.mock import patch, MagicMock\nimport datetime\nfrom session_utils import purge_stale_sessions\n\nclass TestPurgeStaleSessions(unittest.TestCase):\n\n    @patch('database.get_connection')\n    @patch('datetime.datetime')\n    def test_normal_deletion(self, mock_datetime, mock_get_conn):\n        \"\"\"Test typical case with expired sessions to delete.\"\"\"\n        fixed_now = datetime.datetime(2023, 1, 1, 12, 0, 0)\n        mock_datetime.now.return_value = fixed_now\n        mock_conn = MagicMock()\n        mock_get_conn.return_value = mock_conn\n        mock_transaction = MagicMock()\n        mock_conn.transaction.return_value = mock_transaction\n        mock_transaction.__enter__.return_value = None\n        mock_transaction.__exit__.return_value = None\n        mock_result = MagicMock()\n        mock_conn.execute.return_value = mock_result\n        mock_result.rowcount = 3\n        result = purge_stale_sessions(60)\n        expected_threshold = fixed_now - datetime.timedelta(minutes=60)\n        mock_conn.execute.assert_called_once_with(\n            'DELETE FROM sessions WHERE id IN ( SELECT id FROM sessions WHERE last_activity < ? )',\n            (expected_threshold,)\n        )\n        self.assertEqual(result, 3)\n\n    @patch('database.get_connection')\n    @patch('datetime.datetime')\n    def test_no_expired_sessions(self, mock_datetime, mock_get_conn):\n        \"\"\"Test case with no expired sessions to delete.\"\"\"\n        fixed_now = datetime.datetime(2023, 1, 1, 12, 0, 0)\n        mock_datetime.now.return_value = fixed_now\n        mock_conn = MagicMock()\n        mock_get_conn.return_value = mock_conn\n        mock_transaction = MagicMock()\n        mock_conn.transaction.return_value = mock_transaction\n        mock_result = MagicMock()\n        mock_conn.execute.return_value = mock_result\n        mock_result.rowcount = 0\n        result = purge_stale_sessions(60)\n        expected_threshold = fixed_now - datetime.timedelta(minutes=60)\n        mock_conn.execute.assert_called_once_with(\n            'DELETE FROM sessions WHERE id IN ( SELECT id FROM sessions WHERE last_activity < ? )',\n            (expected_threshold,)\n        )\n        self.assertEqual(result, 0)\n\n    @patch('database.get_connection')\n    @patch('datetime.datetime')\n    def test_database_exception(self, mock_datetime, mock_get_conn):\n        \"\"\"Test database exception handling returning 0.\"\"\"\n        fixed_now = datetime.datetime(2023, 1, 1, 12, 0, 0)\n        mock_datetime.now.return_value = fixed_now\n        mock_conn = MagicMock()\n        mock_get_conn.return_value = mock_conn\n        mock_transaction = MagicMock()\n        mock_conn.transaction.return_value = mock_transaction\n        mock_conn.execute.side_effect = Exception('DB error')\n        result = purge_stale_sessions(60)\n        self.assertEqual(result, 0)\n\n    @patch('database.get_connection')\n    @patch('datetime.datetime')\n    def test_expiry_time_zero(self, mock_datetime, mock_get_conn):\n        \"\"\"Test edge case with zero expiry time (delete sessions older than now).\"\"\"\n        fixed_now = datetime.datetime(2023, 1, 1, 12, 0, 0)\n        mock_datetime.now.return_value = fixed_now\n        mock_conn = MagicMock()\n        mock_get_conn.return_value = mock_conn\n        mock_transaction = MagicMock()\n        mock_conn.transaction.return_value = mock_transaction\n        mock_result = MagicMock()\n        mock_conn.execute.return_value = mock_result\n        mock_result.rowcount = 1\n        result = purge_stale_sessions(0)\n        expected_threshold = fixed_now - datetime.timedelta(minutes=0)\n        mock_conn.execute.assert_called_once_with(\n            'DELETE FROM sessions WHERE id IN ( SELECT id FROM sessions WHERE last_activity < ? )',\n            (expected_threshold,)\n        )\n        self.assertEqual(result, 1)\n\n    @patch('database.get_connection')\n    @patch('datetime.datetime')\n    def test_negative_expiry_time(self, mock_datetime, mock_get_conn):\n        \"\"\"Test negative expiry time (threshold in future).\"\"\"\n        fixed_now = datetime.datetime(2023, 1, 1, 12, 0, 0)\n        mock_datetime.now.return_value = fixed_now\n        mock_conn = MagicMock()\n        mock_get_conn.return_value = mock_conn\n        mock_transaction = MagicMock()\n        mock_conn.transaction.return_value = mock_transaction\n        mock_result = MagicMock()\n        mock_conn.execute.return_value = mock_result\n        mock_result.rowcount = 1\n        result = purge_stale_sessions(-10)\n        expected_threshold = fixed_now - datetime.timedelta(minutes=-10)\n        mock_conn.execute.assert_called_once_with(\n            'DELETE FROM sessions WHERE id IN ( SELECT id FROM sessions WHERE last_activity < ? )',\n            (expected_threshold,)\n        )\n        self.assertEqual(result, 1)\n\n    @patch('database.get_connection')\n    @patch('datetime.datetime')\n    def test_large_expiry_time(self, mock_datetime, mock_get_conn):\n        \"\"\"Test very large expiry time (threshold far in past).\"\"\"\n        fixed_now = datetime.datetime(2023, 1, 1, 12, 0, 0)\n        mock_datetime.now.return_value = fixed_now\n        mock_conn = MagicMock()\n        mock_get_conn.return_value = mock_conn\n        mock_transaction = MagicMock()\n        mock_conn.transaction.return_value = mock_transaction\n        mock_result = MagicMock()\n        mock_conn.execute.return_value = mock_result\n        mock_result.rowcount = 2\n        result = purge_stale_sessions(100000)\n        expected_threshold = fixed_now - datetime.timedelta(minutes=100000)\n        mock_conn.execute.assert_called_once_with(\n            'DELETE FROM sessions WHERE id IN ( SELECT id FROM sessions WHERE last_activity < ? )',\n            (expected_threshold,)\n        )\n        self.assertEqual(result, 2)\n\n    @patch('database.get_connection')\n    def test_non_integer_expiry_time(self, mock_get_conn):\n        \"\"\"Test non-integer expiry time handling (returns 0).\"\"\"\n        mock_conn = MagicMock()\n        mock_get_conn.return_value = mock_conn\n        result = purge_stale_sessions('invalid')\n        self.assertEqual(result, 0)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 7, "task_id": "6d9395c5"}
{"test": "import unittest\nfrom unittest.mock import patch, MagicMock\nfrom datetime import datetime, timedelta\n\n# Import the function from the module (adjust 'solution' if necessary)\nfrom solution import remove_expired_sessions\n\nclass TestRemoveExpiredSessions(unittest.TestCase):\n\n    @patch('solution.database')\n    @patch('solution.datetime')\n    def test_normal_case(self, mock_datetime, mock_database):\n        \"\"\"Test typical case: some sessions are deleted successfully.\"\"\"\n        fixed_now = datetime(2023, 1, 1, 12, 0, 0)\n        mock_datetime.now.return_value = fixed_now\n        \n        mock_db_conn = MagicMock()\n        mock_database.get_connection.return_value = mock_db_conn\n        mock_db_conn.transaction.return_value.__enter__.return_value = None\n        mock_db_conn.transaction.return_value.__exit__.return_value = None\n        \n        mock_result = MagicMock()\n        mock_result.rowcount = 5\n        mock_db_conn.execute.return_value = mock_result\n        \n        count = remove_expired_sessions(10)\n        self.assertEqual(count, 5)\n        \n        expected_threshold = fixed_now - timedelta(minutes=10)\n        mock_db_conn.execute.assert_called_once_with(\n            \"\"\"\n                DELETE FROM sessions \n                WHERE id IN (\n                    SELECT id \n                    FROM sessions \n                    WHERE last_activity < ?\n                )\n            \"\"\", (expected_threshold,)\n        )\n\n    @patch('solution.database')\n    @patch('solution.datetime')\n    def test_no_sessions(self, mock_datetime, mock_database):\n        \"\"\"Test when no sessions are expired (returns 0).\"\"\"\n        fixed_now = datetime(2023, 1, 1, 12, 0, 0)\n        mock_datetime.now.return_value = fixed_now\n        \n        mock_db_conn = MagicMock()\n        mock_database.get_connection.return_value = mock_db_conn\n        mock_db_conn.transaction.return_value.__enter__.return_value = None\n        mock_db_conn.transaction.return_value.__exit__.return_value = None\n        \n        mock_result = MagicMock()\n        mock_result.rowcount = 0\n        mock_db_conn.execute.return_value = mock_result\n        \n        count = remove_expired_sessions(10)\n        self.assertEqual(count, 0)\n\n    @patch('solution.database')\n    @patch('solution.datetime')\n    def test_database_exception(self, mock_datetime, mock_database):\n        \"\"\"Test database exception handling: returns 0 on error.\"\"\"\n        fixed_now = datetime(2023, 1, 1, 12, 0, 0)\n        mock_datetime.now.return_value = fixed_now\n        \n        mock_db_conn = MagicMock()\n        mock_database.get_connection.return_value = mock_db_conn\n        mock_db_conn.execute.side_effect = Exception(\"DB connection error\")\n        \n        count = remove_expired_sessions(10)\n        self.assertEqual(count, 0)\n\n    @patch('solution.database')\n    @patch('solution.datetime')\n    def test_expire_time_zero(self, mock_datetime, mock_database):\n        \"\"\"Test expire_time=0: threshold becomes current time.\"\"\"\n        fixed_now = datetime(2023, 1, 1, 12, 0, 0)\n        mock_datetime.now.return_value = fixed_now\n        \n        mock_db_conn = MagicMock()\n        mock_database.get_connection.return_value = mock_db_conn\n        mock_db_conn.transaction.return_value.__enter__.return_value = None\n        mock_db_conn.transaction.return_value.__exit__.return_value = None\n        \n        mock_result = MagicMock()\n        mock_result.rowcount = 3\n        mock_db_conn.execute.return_value = mock_result\n        \n        count = remove_expired_sessions(0)\n        self.assertEqual(count, 3)\n        \n        expected_threshold = fixed_now - timedelta(minutes=0)\n        args, _ = mock_db_conn.execute.call_args\n        self.assertEqual(args[1], (expected_threshold,))\n\n    @patch('solution.database')\n    @patch('solution.datetime')\n    def test_negative_expire_time(self, mock_datetime, mock_database):\n        \"\"\"Test negative expire_time: threshold becomes future time.\"\"\"\n        fixed_now = datetime(2023, 1, 1, 12, 0, 0)\n        mock_datetime.now.return_value = fixed_now\n        \n        mock_db_conn = MagicMock()\n        mock_database.get_connection.return_value = mock_db_conn\n        mock_db_conn.transaction.return_value.__enter__.return_value = None\n        mock_db_conn.transaction.return_value.__exit__.return_value = None\n        \n        mock_result = MagicMock()\n        mock_result.rowcount = 100\n        mock_db_conn.execute.return_value = mock_result\n        \n        count = remove_expired_sessions(-10)\n        self.assertEqual(count, 100)\n        \n        expected_threshold = fixed_now - timedelta(minutes=-10)\n        args, _ = mock_db_conn.execute.call_args\n        self.assertEqual(args[1], (expected_threshold,))\n\n    @patch('solution.database')\n    @patch('solution.datetime')\n    def test_large_expire_time(self, mock_datetime, mock_database):\n        \"\"\"Test very large expire_time: threshold far in the past.\"\"\"\n        fixed_now = datetime(2023, 1, 1, 12, 0, 0)\n        mock_datetime.now.return_value = fixed_now\n        \n        mock_db_conn = MagicMock()\n        mock_database.get_connection.return_value = mock_db_conn\n        mock_db_conn.transaction.return_value.__enter__.return_value = None\n        mock_db_conn.transaction.return_value.__exit__.return_value = None\n        \n        mock_result = MagicMock()\n        mock_result.rowcount = 1\n        mock_db_conn.execute.return_value = mock_result\n        \n        count = remove_expired_sessions(1000000)\n        self.assertEqual(count, 1)\n        \n        expected_threshold = fixed_now - timedelta(minutes=1000000)\n        args, _ = mock_db_conn.execute.call_args\n        self.assertEqual(args[1], (expected_threshold,))\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 6, "task_id": "ba31a78e"}
{"test": "import unittest\nfrom unittest.mock import patch, MagicMock\nfrom datetime import datetime, timedelta\n\nclass TestPurgeExpiredSessions(unittest.TestCase):\n    \n    @patch('database.get_connection')\n    @patch('__main__.datetime')\n    def test_normal_case_positive_rowcount(self, mock_datetime, mock_get_connection):\n        # Test with a positive expire_duration and rowcount > 0\n        fixed_now = datetime(2023, 1, 1, 12, 0, 0)\n        mock_datetime.now.return_value = fixed_now\n        \n        mock_db = MagicMock()\n        mock_get_connection.return_value = mock_db\n        mock_db.transaction.return_value.__enter__.return_value = mock_db\n        mock_db.execute.return_value.rowcount = 5\n        \n        result = purge_expired_sessions(60)\n        self.assertEqual(result, 5)\n        \n        expected_threshold = fixed_now - timedelta(minutes=60)\n        mock_db.execute.assert_called_once_with(\n            \"\"\"\n                DELETE FROM sessions \n                WHERE id IN (\n                    SELECT id \n                    FROM sessions \n                    WHERE last_activity < ?\n                )\n            \"\"\",\n            (expected_threshold,)\n        )\n    \n    @patch('database.get_connection')\n    @patch('__main__.datetime')\n    def test_normal_case_zero_rowcount(self, mock_datetime, mock_get_connection):\n        # Test with a positive expire_duration and rowcount = 0\n        fixed_now = datetime(2023, 1, 1, 12, 0, 0)\n        mock_datetime.now.return_value = fixed_now\n        \n        mock_db = MagicMock()\n        mock_get_connection.return_value = mock_db\n        mock_db.transaction.return_value.__enter__.return_value = mock_db\n        mock_db.execute.return_value.rowcount = 0\n        \n        result = purge_expired_sessions(60)\n        self.assertEqual(result, 0)\n    \n    @patch('database.get_connection')\n    @patch('__main__.datetime')\n    def test_zero_expire_duration(self, mock_datetime, mock_get_connection):\n        # Test with expire_duration = 0\n        fixed_now = datetime(2023, 1, 1, 12, 0, 0)\n        mock_datetime.now.return_value = fixed_now\n        \n        mock_db = MagicMock()\n        mock_get_connection.return_value = mock_db\n        mock_db.transaction.return_value.__enter__.return_value = mock_db\n        mock_db.execute.return_value.rowcount = 3\n        \n        result = purge_expired_sessions(0)\n        self.assertEqual(result, 3)\n        \n        expected_threshold = fixed_now - timedelta(minutes=0)\n        mock_db.execute.assert_called_once_with(\n            \"\"\"\n                DELETE FROM sessions \n                WHERE id IN (\n                    SELECT id \n                    FROM sessions \n                    WHERE last_activity < ?\n                )\n            \"\"\",\n            (expected_threshold,)\n        )\n    \n    @patch('database.get_connection')\n    @patch('__main__.datetime')\n    def test_negative_expire_duration(self, mock_datetime, mock_get_connection):\n        # Test with negative expire_duration\n        fixed_now = datetime(2023, 1, 1, 12, 0, 0)\n        mock_datetime.now.return_value = fixed_now\n        \n        mock_db = MagicMock()\n        mock_get_connection.return_value = mock_db\n        mock_db.transaction.return_value.__enter__.return_value = mock_db\n        mock_db.execute.return_value.rowcount = 2\n        \n        result = purge_expired_sessions(-10)\n        self.assertEqual(result, 2)\n        \n        expected_threshold = fixed_now - timedelta(minutes=-10)\n        mock_db.execute.assert_called_once_with(\n            \"\"\"\n                DELETE FROM sessions \n                WHERE id IN (\n                    SELECT id \n                    FROM sessions \n                    WHERE last_activity < ?\n                )\n            \"\"\",\n            (expected_threshold,)\n        )\n    \n    @patch('database.get_connection')\n    @patch('__main__.datetime')\n    def test_large_expire_duration(self, mock_datetime, mock_get_connection):\n        # Test with very large expire_duration\n        fixed_now = datetime(2023, 1, 1, 12, 0, 0)\n        mock_datetime.now.return_value = fixed_now\n        \n        mock_db = MagicMock()\n        mock_get_connection.return_value = mock_db\n        mock_db.transaction.return_value.__enter__.return_value = mock_db\n        mock_db.execute.return_value.rowcount = 1000\n        \n        result = purge_expired_sessions(10**6)\n        self.assertEqual(result, 1000)\n        \n        expected_threshold = fixed_now - timedelta(minutes=10**6)\n        mock_db.execute.assert_called_once_with(\n            \"\"\"\n                DELETE FROM sessions \n                WHERE id IN (\n                    SELECT id \n                    FROM sessions \n                    WHERE last_activity < ?\n                )\n            \"\"\",\n            (expected_threshold,)\n        )\n    \n    @patch('database.get_connection')\n    @patch('__main__.datetime')\n    @patch('builtins.print')\n    def test_database_error(self, mock_print, mock_datetime, mock_get_connection):\n        # Test database error handling\n        fixed_now = datetime(2023, 1, 1, 12, 0, 0)\n        mock_datetime.now.return_value = fixed_now\n        \n        mock_db = MagicMock()\n        mock_get_connection.return_value = mock_db\n        mock_db.transaction.return_value.__enter__.return_value = mock_db\n        mock_db.execute.side_effect = Exception(\"DB connection error\")\n        \n        result = purge_expired_sessions(60)\n        self.assertEqual(result, 0)\n        mock_print.assert_called_once_with(\"Failed to purge expired sessions: DB connection error\")\n    \n    @patch('database.get_connection')\n    @patch('__main__.datetime')\n    @patch('builtins.print')\n    def test_non_integer_duration(self, mock_print, mock_datetime, mock_get_connection):\n        # Test with non-integer expire_duration (string)\n        fixed_now = datetime(2023, 1, 1, 12, 0, 0)\n        mock_datetime.now.return_value = fixed_now\n        \n        result = purge_expired_sessions(\"sixty\")\n        self.assertEqual(result, 0)\n        self.assertTrue(mock_print.called)\n        args, _ = mock_print.call_args\n        self.assertTrue(args[0].startswith(\"Failed to purge expired sessions:\"))\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 7, "task_id": "4fafcce8"}
{"test": "import unittest\nfrom unittest.mock import patch, MagicMock\nfrom datetime import datetime, timedelta\n\n# Assuming the function is in a module named 'solution'\nfrom solution import delete_expired_sessions\n\nclass TestDeleteExpiredSessions(unittest.TestCase):\n\n    @patch('solution.database.get_connection')\n    @patch('solution.datetime')\n    def test_normal_positive_expiration(self, mock_datetime, mock_get_connection):\n        \"\"\"Test typical case with positive expiration time and successful deletion.\"\"\"\n        # Setup\n        fixed_now = datetime(2023, 1, 1, 12, 0, 0)\n        mock_datetime.now.return_value = fixed_now\n        \n        mock_db = MagicMock()\n        mock_get_connection.return_value = mock_db\n        mock_db.execute.return_value.rowcount = 5\n        \n        # Execute\n        result = delete_expired_sessions(10)\n        \n        # Verify\n        expected_threshold = fixed_now - timedelta(minutes=10)\n        mock_db.execute.assert_called_once_with(\n            \"\"\"\n                DELETE FROM sessions \n                WHERE id IN (\n                    SELECT id \n                    FROM sessions \n                    WHERE last_activity < ?\n                )\n            \"\"\", (expected_threshold,)\n        )\n        self.assertEqual(result, 5)\n        mock_db.transaction.assert_called_once()\n\n    @patch('solution.database.get_connection')\n    @patch('solution.datetime')\n    def test_zero_expiration(self, mock_datetime, mock_get_connection):\n        \"\"\"Test expiration time of zero minutes.\"\"\"\n        # Setup\n        fixed_now = datetime(2023, 1, 1, 12, 0, 0)\n        mock_datetime.now.return_value = fixed_now\n        \n        mock_db = MagicMock()\n        mock_get_connection.return_value = mock_db\n        mock_db.execute.return_value.rowcount = 3\n        \n        # Execute\n        result = delete_expired_sessions(0)\n        \n        # Verify\n        expected_threshold = fixed_now - timedelta(minutes=0)\n        mock_db.execute.assert_called_once_with(\n            \"\"\"\n                DELETE FROM sessions \n                WHERE id IN (\n                    SELECT id \n                    FROM sessions \n                    WHERE last_activity < ?\n                )\n            \"\"\", (expected_threshold,)\n        )\n        self.assertEqual(result, 3)\n\n    @patch('solution.database.get_connection')\n    @patch('solution.datetime')\n    def test_negative_expiration(self, mock_datetime, mock_get_connection):\n        \"\"\"Test negative expiration time (threshold becomes future time).\"\"\"\n        # Setup\n        fixed_now = datetime(2023, 1, 1, 12, 0, 0)\n        mock_datetime.now.return_value = fixed_now\n        \n        mock_db = MagicMock()\n        mock_get_connection.return_value = mock_db\n        mock_db.execute.return_value.rowcount = 2\n        \n        # Execute\n        result = delete_expired_sessions(-15)\n        \n        # Verify\n        expected_threshold = fixed_now - timedelta(minutes=-15)\n        mock_db.execute.assert_called_once_with(\n            \"\"\"\n                DELETE FROM sessions \n                WHERE id IN (\n                    SELECT id \n                    FROM sessions \n                    WHERE last_activity < ?\n                )\n            \"\"\", (expected_threshold,)\n        )\n        self.assertEqual(result, 2)\n\n    @patch('solution.database.get_connection')\n    @patch('solution.datetime')\n    def test_exception_handling(self, mock_datetime, mock_get_connection):\n        \"\"\"Test database exception handling returns 0.\"\"\"\n        # Setup\n        fixed_now = datetime(2023, 1, 1, 12, 0, 0)\n        mock_datetime.now.return_value = fixed_now\n        \n        mock_db = MagicMock()\n        mock_get_connection.return_value = mock_db\n        mock_db.execute.side_effect = Exception(\"DB Error\")\n        \n        # Execute\n        result = delete_expired_sessions(10)\n        \n        # Verify\n        self.assertEqual(result, 0)\n        mock_db.transaction.assert_called_once()\n\n    @patch('solution.database.get_connection')\n    @patch('solution.datetime')\n    def test_no_rows_deleted(self, mock_datetime, mock_get_connection):\n        \"\"\"Test when no sessions are deleted (rowcount is zero).\"\"\"\n        # Setup\n        fixed_now = datetime(2023, 1, 1, 12, 0, 0)\n        mock_datetime.now.return_value = fixed_now\n        \n        mock_db = MagicMock()\n        mock_get_connection.return_value = mock_db\n        mock_db.execute.return_value.rowcount = 0\n        \n        # Execute\n        result = delete_expired_sessions(30)\n        \n        # Verify\n        self.assertEqual(result, 0)\n\n    @patch('solution.database.get_connection')\n    @patch('solution.datetime')\n    def test_large_expiration(self, mock_datetime, mock_get_connection):\n        \"\"\"Test with a very large expiration time.\"\"\"\n        # Setup\n        fixed_now = datetime(2023, 1, 1, 12, 0, 0)\n        mock_datetime.now.return_value = fixed_now\n        \n        mock_db = MagicMock()\n        mock_get_connection.return_value = mock_db\n        mock_db.execute.return_value.rowcount = 1\n        \n        # Execute\n        result = delete_expired_sessions(10**6)\n        \n        # Verify\n        expected_threshold = fixed_now - timedelta(minutes=10**6)\n        mock_db.execute.assert_called_once_with(\n            \"\"\"\n                DELETE FROM sessions \n                WHERE id IN (\n                    SELECT id \n                    FROM sessions \n                    WHERE last_activity < ?\n                )\n            \"\"\", (expected_threshold,)\n        )\n        self.assertEqual(result, 1)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 6, "task_id": "d8dfead3"}
{"test": "import unittest\nfrom unittest.mock import patch, MagicMock\nfrom datetime import datetime, timedelta\n\n# Assuming the function is in a module named 'app_utils'\nfrom app_utils import remove_old_sessions\n\nclass TestRemoveOldSessions(unittest.TestCase):\n\n    @patch('app_utils.database')\n    @patch('app_utils.datetime')\n    def test_positive_time_limit_deletions(self, mock_datetime, mock_database):\n        \"\"\"\n        Test with positive time_limit and successful deletion of 5 sessions.\n        \"\"\"\n        # Set fixed current time\n        fixed_now = datetime(2023, 1, 1, 12, 0, 0)\n        mock_datetime.now.return_value = fixed_now\n        threshold = fixed_now - timedelta(minutes=10)\n        \n        # Mock database connection and execute result\n        mock_conn = MagicMock()\n        mock_database.get_connection.return_value = mock_conn\n        mock_result = MagicMock()\n        mock_result.rowcount = 5\n        mock_conn.execute.return_value = mock_result\n        \n        # Call the function\n        result = remove_old_sessions(10)\n        \n        # Assertions\n        self.assertEqual(result, 5)\n        mock_conn.transaction.assert_called_once()\n        mock_conn.execute.assert_called_once_with(\n            \"\"\"\n                DELETE FROM sessions \n                WHERE id IN (\n                    SELECT id \n                    FROM sessions \n                    WHERE last_activity < ?\n                )\n            \"\"\", \n            (threshold,)\n        )\n\n    @patch('app_utils.database')\n    @patch('app_utils.datetime')\n    def test_no_sessions_deleted(self, mock_datetime, mock_database):\n        \"\"\"\n        Test with positive time_limit and no sessions to delete.\n        \"\"\"\n        fixed_now = datetime(2023, 1, 1, 12, 0, 0)\n        mock_datetime.now.return_value = fixed_now\n        \n        mock_conn = MagicMock()\n        mock_database.get_connection.return_value = mock_conn\n        mock_result = MagicMock()\n        mock_result.rowcount = 0\n        mock_conn.execute.return_value = mock_result\n        \n        result = remove_old_sessions(10)\n        self.assertEqual(result, 0)\n        mock_conn.transaction.assert_called_once()\n        mock_conn.execute.assert_called_once()\n\n    @patch('app_utils.database')\n    @patch('app_utils.datetime')\n    def test_zero_time_limit(self, mock_datetime, mock_database):\n        \"\"\"\n        Test with time_limit=0, which should delete sessions older than current time.\n        \"\"\"\n        fixed_now = datetime(2023, 1, 1, 12, 0, 0)\n        mock_datetime.now.return_value = fixed_now\n        \n        mock_conn = MagicMock()\n        mock_database.get_connection.return_value = mock_conn\n        mock_result = MagicMock()\n        mock_result.rowcount = 100\n        mock_conn.execute.return_value = mock_result\n        \n        result = remove_old_sessions(0)\n        self.assertEqual(result, 100)\n        mock_conn.transaction.assert_called_once()\n        mock_conn.execute.assert_called_once_with(\n            \"\"\"\n                DELETE FROM sessions \n                WHERE id IN (\n                    SELECT id \n                    FROM sessions \n                    WHERE last_activity < ?\n                )\n            \"\"\", \n            (fixed_now,)\n        )\n\n    @patch('app_utils.database')\n    @patch('app_utils.datetime')\n    def test_negative_time_limit(self, mock_datetime, mock_database):\n        \"\"\"\n        Test with negative time_limit, which results in a future threshold.\n        \"\"\"\n        fixed_now = datetime(2023, 1, 1, 12, 0, 0)\n        mock_datetime.now.return_value = fixed_now\n        threshold = fixed_now - timedelta(minutes=-5)  # Adds 5 minutes\n        \n        mock_conn = MagicMock()\n        mock_database.get_connection.return_value = mock_conn\n        mock_result = MagicMock()\n        mock_result.rowcount = 200\n        mock_conn.execute.return_value = mock_result\n        \n        result = remove_old_sessions(-5)\n        self.assertEqual(result, 200)\n        mock_conn.transaction.assert_called_once()\n        mock_conn.execute.assert_called_once_with(\n            \"\"\"\n                DELETE FROM sessions \n                WHERE id IN (\n                    SELECT id \n                    FROM sessions \n                    WHERE last_activity < ?\n                )\n            \"\"\", \n            (threshold,)\n        )\n\n    @patch('app_utils.database')\n    @patch('app_utils.datetime')\n    def test_large_time_limit(self, mock_datetime, mock_database):\n        \"\"\"\n        Test with a very large time_limit (10000000 minutes).\n        \"\"\"\n        fixed_now = datetime(2023, 1, 1, 12, 0, 0)\n        mock_datetime.now.return_value = fixed_now\n        threshold = fixed_now - timedelta(minutes=10000000)\n        \n        mock_conn = MagicMock()\n        mock_database.get_connection.return_value = mock_conn\n        mock_result = MagicMock()\n        mock_result.rowcount = 2\n        mock_conn.execute.return_value = mock_result\n        \n        result = remove_old_sessions(10000000)\n        self.assertEqual(result, 2)\n        mock_conn.transaction.assert_called_once()\n        mock_conn.execute.assert_called_once_with(\n            \"\"\"\n                DELETE FROM sessions \n                WHERE id IN (\n                    SELECT id \n                    FROM sessions \n                    WHERE last_activity < ?\n                )\n            \"\"\", \n            (threshold,)\n        )\n\n    @patch('app_utils.database')\n    @patch('app_utils.datetime')\n    def test_database_exception(self, mock_datetime, mock_database):\n        \"\"\"\n        Test database exception during deletion, expecting return value 0.\n        \"\"\"\n        fixed_now = datetime(2023, 1, 1, 12, 0, 0)\n        mock_datetime.now.return_value = fixed_now\n        \n        mock_conn = MagicMock()\n        mock_database.get_connection.return_value = mock_conn\n        mock_conn.execute.side_effect = Exception(\"DB error\")\n        \n        result = remove_old_sessions(10)\n        self.assertEqual(result, 0)\n        mock_conn.transaction.assert_called_once()\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 6, "task_id": "44569680"}
{"test": "import unittest\nfrom unittest.mock import patch, MagicMock\nfrom datetime import datetime\n\nclass TestPurgeStaleSessions(unittest.TestCase):\n\n    @patch('database.get_connection')\n    def test_normal_deletion(self, mock_get_connection):\n        \"\"\"Test typical case: delete 5 sessions successfully.\"\"\"\n        mock_db = MagicMock()\n        mock_get_connection.return_value = mock_db\n        mock_result = MagicMock()\n        mock_result.rowcount = 5\n        mock_db.execute.return_value = mock_result\n        \n        result = purge_stale_sessions(10)\n        \n        mock_db.transaction.assert_called_once()\n        args, _ = mock_db.execute.call_args\n        self.assertIsInstance(args[1][0], datetime)\n        self.assertEqual(result, 5)\n\n    @patch('database.get_connection')\n    def test_no_sessions_to_delete(self, mock_get_connection):\n        \"\"\"Test when no sessions are expired (rowcount=0).\"\"\"\n        mock_db = MagicMock()\n        mock_get_connection.return_value = mock_db\n        mock_result = MagicMock()\n        mock_result.rowcount = 0\n        mock_db.execute.return_value = mock_result\n        \n        result = purge_stale_sessions(30)\n        \n        self.assertEqual(result, 0)\n\n    @patch('database.get_connection')\n    @patch('builtins.print')\n    def test_database_exception_handling(self, mock_print, mock_get_connection):\n        \"\"\"Test exception during deletion returns 0 and prints error.\"\"\"\n        mock_db = MagicMock()\n        mock_get_connection.return_value = mock_db\n        mock_db.execute.side_effect = Exception(\"DB error\")\n        \n        result = purge_stale_sessions(15)\n        \n        self.assertEqual(result, 0)\n        mock_print.assert_called_once()\n\n    @patch('database.get_connection')\n    def test_zero_limit_time(self, mock_get_connection):\n        \"\"\"Test limit_time=0 deletes sessions with last_activity < current time.\"\"\"\n        mock_db = MagicMock()\n        mock_get_connection.return_value = mock_db\n        mock_result = MagicMock()\n        mock_result.rowcount = 2\n        mock_db.execute.return_value = mock_result\n        \n        result = purge_stale_sessions(0)\n        \n        args, _ = mock_db.execute.call_args\n        self.assertIsInstance(args[1][0], datetime)\n        self.assertEqual(result, 2)\n\n    @patch('database.get_connection')\n    def test_negative_limit_time(self, mock_get_connection):\n        \"\"\"Test negative limit_time (should still execute query).\"\"\"\n        mock_db = MagicMock()\n        mock_get_connection.return_value = mock_db\n        mock_result = MagicMock()\n        mock_result.rowcount = 3\n        mock_db.execute.return_value = mock_result\n        \n        result = purge_stale_sessions(-10)\n        \n        args, _ = mock_db.execute.call_args\n        self.assertIsInstance(args[1][0], datetime)\n        self.assertEqual(result, 3)\n\n    @patch('database.get_connection')\n    def test_large_limit_time(self, mock_get_connection):\n        \"\"\"Test very large limit_time (1,000,000 minutes).\"\"\"\n        mock_db = MagicMock()\n        mock_get_connection.return_value = mock_db\n        mock_result = MagicMock()\n        mock_result.rowcount = 1000\n        mock_db.execute.return_value = mock_result\n        \n        result = purge_stale_sessions(1000000)\n        \n        self.assertEqual(result, 1000)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 6, "task_id": "62cc0d63"}
{"test": "import unittest\nfrom unittest.mock import patch, MagicMock\nfrom datetime import datetime, timedelta\n\nclass TestDeleteExpiredSessions(unittest.TestCase):\n\n    @patch('module.database.get_connection')\n    @patch('module.datetime')\n    def test_normal_deletion_one_session(self, mock_datetime, mock_get_connection):\n        \"\"\"Test normal deletion with one expired session.\"\"\"\n        fixed_now = datetime(2023, 1, 1, 12, 0, 0)\n        mock_datetime.now.return_value = fixed_now\n        \n        mock_db = MagicMock()\n        mock_result = MagicMock()\n        mock_result.rowcount = 1\n        mock_db.execute.return_value = mock_result\n        mock_get_connection.return_value = mock_db\n        \n        result = delete_expired_sessions(30)\n        \n        expected_threshold = fixed_now - timedelta(minutes=30)\n        args, _ = mock_db.execute.call_args\n        self.assertEqual(args[1], (expected_threshold,))\n        self.assertEqual(result, 1)\n\n    @patch('module.database.get_connection')\n    @patch('module.datetime')\n    def test_normal_deletion_multiple_sessions(self, mock_datetime, mock_get_connection):\n        \"\"\"Test deletion with multiple expired sessions.\"\"\"\n        fixed_now = datetime(2023, 1, 1, 12, 0, 0)\n        mock_datetime.now.return_value = fixed_now\n        \n        mock_db = MagicMock()\n        mock_result = MagicMock()\n        mock_result.rowcount = 3\n        mock_db.execute.return_value = mock_result\n        mock_get_connection.return_value = mock_db\n        \n        result = delete_expired_sessions(60)\n        \n        expected_threshold = fixed_now - timedelta(minutes=60)\n        args, _ = mock_db.execute.call_args\n        self.assertEqual(args[1], (expected_threshold,))\n        self.assertEqual(result, 3)\n\n    @patch('module.database.get_connection')\n    @patch('module.datetime')\n    def test_no_expired_sessions(self, mock_datetime, mock_get_connection):\n        \"\"\"Test when there are no expired sessions.\"\"\"\n        fixed_now = datetime(2023, 1, 1, 12, 0, 0)\n        mock_datetime.now.return_value = fixed_now\n        \n        mock_db = MagicMock()\n        mock_result = MagicMock()\n        mock_result.rowcount = 0\n        mock_db.execute.return_value = mock_result\n        mock_get_connection.return_value = mock_db\n        \n        result = delete_expired_sessions(30)\n        \n        expected_threshold = fixed_now - timedelta(minutes=30)\n        args, _ = mock_db.execute.call_args\n        self.assertEqual(args[1], (expected_threshold,))\n        self.assertEqual(result, 0)\n\n    @patch('module.database.get_connection')\n    @patch('module.datetime')\n    def test_session_timeout_zero(self, mock_datetime, mock_get_connection):\n        \"\"\"Test when session_timeout is zero minutes.\"\"\"\n        fixed_now = datetime(2023, 1, 1, 12, 0, 0)\n        mock_datetime.now.return_value = fixed_now\n        \n        mock_db = MagicMock()\n        mock_result = MagicMock()\n        mock_result.rowcount = 2\n        mock_db.execute.return_value = mock_result\n        mock_get_connection.return_value = mock_db\n        \n        result = delete_expired_sessions(0)\n        \n        expected_threshold = fixed_now - timedelta(minutes=0)\n        args, _ = mock_db.execute.call_args\n        self.assertEqual(args[1], (expected_threshold,))\n        self.assertEqual(result, 2)\n\n    @patch('module.database.get_connection')\n    @patch('module.datetime')\n    def test_database_exception_handling(self, mock_datetime, mock_get_connection):\n        \"\"\"Test handling of database exceptions.\"\"\"\n        fixed_now = datetime(2023, 1, 1, 12, 0, 0)\n        mock_datetime.now.return_value = fixed_now\n        \n        mock_db = MagicMock()\n        mock_db.execute.side_effect = Exception(\"Database failure\")\n        mock_get_connection.return_value = mock_db\n        \n        result = delete_expired_sessions(30)\n        \n        self.assertEqual(result, 0)\n\n    @patch('module.database.get_connection')\n    @patch('module.datetime')\n    def test_negative_session_timeout(self, mock_datetime, mock_get_connection):\n        \"\"\"Test with negative session_timeout value.\"\"\"\n        fixed_now = datetime(2023, 1, 1, 12, 0, 0)\n        mock_datetime.now.return_value = fixed_now\n        \n        mock_db = MagicMock()\n        mock_result = MagicMock()\n        mock_result.rowcount = 5\n        mock_db.execute.return_value = mock_result\n        mock_get_connection.return_value = mock_db\n        \n        result = delete_expired_sessions(-10)\n        \n        expected_threshold = fixed_now - timedelta(minutes=-10)\n        args, _ = mock_db.execute.call_args\n        self.assertEqual(args[1], (expected_threshold,))\n        self.assertEqual(result, 5)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 6, "task_id": "e1ff5d6c"}
{"test": "import unittest\nfrom unittest.mock import patch, mock_open\n\nclass TestApplyConfigUpdate(unittest.TestCase):\n\n    def test_file_not_exists(self):\n        # Test when the configuration file does not exist initially\n        with patch('os.path.exists', return_value=False):\n            result = apply_config_update('nonexistent_path', {'key': 'value'})\n            self.assertFalse(result)\n\n    def test_successful_update(self):\n        # Test successful update: file exists, not empty, and no locking issues\n        with patch('os.path.exists', return_value=True), \\\n             patch('os.path.getsize', return_value=10), \\\n             patch('builtins.open', mock_open()) as mock_file, \\\n             patch('fcntl.flock'):\n            \n            result = apply_config_update('valid_path', {'key': 'value'})\n            self.assertTrue(result)\n            mock_file.return_value.seek.assert_called_once_with(0)\n            mock_file.return_value.truncate.assert_called_once()\n\n    def test_file_empty(self):\n        # Test when the file exists but is empty\n        with patch('os.path.exists', return_value=True), \\\n             patch('os.path.getsize', return_value=0), \\\n             patch('builtins.open', mock_open()), \\\n             patch('fcntl.flock'):\n            \n            result = apply_config_update('empty_path', {'key': 'value'})\n            self.assertFalse(result)\n\n    def test_file_locked(self):\n        # Test when the file is locked by another process\n        with patch('os.path.exists', return_value=True), \\\n             patch('os.path.getsize', return_value=10), \\\n             patch('builtins.open', mock_open()), \\\n             patch('fcntl.flock', side_effect=IOError):\n            \n            result = apply_config_update('locked_path', {'key': 'value'})\n            self.assertFalse(result)\n\n    def test_unexpected_exception_during_write(self):\n        # Test unexpected exception during file truncation\n        with patch('os.path.exists', return_value=True), \\\n             patch('os.path.getsize', return_value=10), \\\n             patch('builtins.open', mock_open()) as mock_file, \\\n             patch('fcntl.flock'):\n            \n            mock_file.return_value.truncate.side_effect = Exception('Unexpected error')\n            result = apply_config_update('error_path', {'key': 'value'})\n            self.assertFalse(result)\n\n    def test_file_disappeared_after_check(self):\n        # Test when file exists during initial check but disappears when opening\n        with patch('os.path.exists', return_value=True), \\\n             patch('builtins.open', side_effect=FileNotFoundError), \\\n             patch('os.path.getsize'), \\\n             patch('fcntl.flock'):\n            \n            result = apply_config_update('vanished_path', {'key': 'value'})\n            self.assertFalse(result)\n\n    def test_json_dump_exception(self):\n        # Test exception during JSON serialization and writing\n        target = apply_config_update.__module__ + '.json.dump'\n        with patch('os.path.exists', return_value=True), \\\n             patch('os.path.getsize', return_value=10), \\\n             patch('builtins.open', mock_open()), \\\n             patch('fcntl.flock'), \\\n             patch(target, side_effect=Exception):\n            \n            result = apply_config_update('json_error_path', {'key': 'value'})\n            self.assertFalse(result)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 7, "task_id": "1f7c2b62"}
{"test": "import unittest\nfrom unittest.mock import patch, mock_open, MagicMock\n\nclass TestModifyConfigFile(unittest.TestCase):\n\n    @patch('os.path.exists')\n    @patch('os.path.getsize')\n    @patch('builtins.open', new_callable=mock_open)\n    @patch('fcntl.flock')\n    @patch('json.dump')\n    def test_successful_update(self, mock_json_dump, mock_flock, mock_open_file, mock_getsize, mock_exists):\n        \"\"\"Test successful update when file exists, is non-empty, and lock is acquired.\"\"\"\n        mock_exists.return_value = True\n        mock_getsize.return_value = 100\n        \n        result = modify_config_file('/path/to/config.json', {'key': 'value'})\n        \n        self.assertTrue(result)\n        mock_open_file.assert_called_once_with('/path/to/config.json', 'r+')\n        mock_flock.assert_called_once()\n        mock_json_dump.assert_called_once_with({'key': 'value'}, mock_open_file.return_value.__enter__.return_value, indent=4)\n        mock_open_file.return_value.__enter__.return_value.truncate.assert_called_once()\n        mock_open_file.return_value.__enter__.return_value.seek.assert_called_once_with(0)\n\n    @patch('os.path.exists')\n    def test_file_does_not_exist(self, mock_exists):\n        \"\"\"Test returns False when file does not exist.\"\"\"\n        mock_exists.return_value = False\n        \n        result = modify_config_file('/path/to/missing.json', {'key': 'value'})\n        \n        self.assertFalse(result)\n\n    @patch('os.path.exists')\n    @patch('os.path.getsize')\n    def test_file_exists_but_empty(self, mock_getsize, mock_exists):\n        \"\"\"Test returns False when file exists but is empty.\"\"\"\n        mock_exists.return_value = True\n        mock_getsize.return_value = 0\n        \n        result = modify_config_file('/path/to/empty.json', {'key': 'value'})\n        \n        self.assertFalse(result)\n\n    @patch('os.path.exists')\n    @patch('os.path.getsize')\n    @patch('builtins.open', new_callable=mock_open)\n    @patch('fcntl.flock')\n    def test_file_locked(self, mock_flock, mock_open_file, mock_getsize, mock_exists):\n        \"\"\"Test returns False when file is locked by another process.\"\"\"\n        mock_exists.return_value = True\n        mock_getsize.return_value = 100\n        mock_flock.side_effect = IOError(\"Locked\")\n        \n        result = modify_config_file('/path/to/locked.json', {'key': 'value'})\n        \n        self.assertFalse(result)\n\n    @patch('os.path.exists')\n    @patch('builtins.open')\n    def test_file_not_found_after_check(self, mock_open, mock_exists):\n        \"\"\"Test returns False when file exists initially but disappears before opening.\"\"\"\n        mock_exists.return_value = True\n        mock_open.side_effect = FileNotFoundError\n        \n        result = modify_config_file('/path/to/disappeared.json', {'key': 'value'})\n        \n        self.assertFalse(result)\n\n    @patch('os.path.exists')\n    @patch('os.path.getsize')\n    @patch('builtins.open', new_callable=mock_open)\n    @patch('fcntl.flock')\n    @patch('json.dump')\n    def test_unexpected_exception_during_dump(self, mock_json_dump, mock_flock, mock_open_file, mock_getsize, mock_exists):\n        \"\"\"Test returns False when an unexpected exception occurs during JSON dump.\"\"\"\n        mock_exists.return_value = True\n        mock_getsize.return_value = 100\n        mock_json_dump.side_effect = Exception(\"Unexpected error\")\n        \n        result = modify_config_file('/path/to/config.json', {'key': 'value'})\n        \n        self.assertFalse(result)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 6, "task_id": "df2f9a85"}
{"test": "import sys\nimport unittest\nfrom unittest.mock import patch, mock_open, MagicMock\n\n# Ensure fcntl is available as a mock if not present\nif 'fcntl' not in sys.modules:\n    mock_fcntl = MagicMock()\n    sys.modules['fcntl'] = mock_fcntl\n\nclass TestRefreshConfigFile(unittest.TestCase):\n\n    @patch('os.path.exists', return_value=False)\n    def test_file_does_not_exist(self, mock_exists):\n        \"\"\"Test when the file does not exist initially.\"\"\"\n        cfg_path = '/path/to/config.json'\n        new_config = {'key': 'value'}\n        result = refresh_config_file(cfg_path, new_config)\n        self.assertFalse(result)\n\n    @patch('os.path.exists', return_value=True)\n    @patch('os.path.getsize', return_value=100)\n    @patch('builtins.open', new_callable=mock_open)\n    @patch('fcntl.flock')\n    @patch('json.dump')\n    def test_success_update(self, mock_json_dump, mock_flock, mock_file, mock_getsize, mock_exists):\n        \"\"\"Test updating an existing non-empty and unlocked file.\"\"\"\n        cfg_path = '/path/to/config.json'\n        new_config = {'key': 'value'}\n        result = refresh_config_file(cfg_path, new_config)\n        self.assertTrue(result)\n        mock_exists.assert_called_once_with(cfg_path)\n        mock_file.assert_called_once_with(cfg_path, 'r+')\n        mock_flock.assert_called_once()\n        mock_file_handle = mock_file()\n        mock_file_handle.seek.assert_called_once_with(0)\n        mock_file_handle.truncate.assert_called_once()\n        mock_json_dump.assert_called_once_with(new_config, mock_file_handle, indent=4)\n\n    @patch('os.path.exists', return_value=True)\n    @patch('os.path.getsize', return_value=100)\n    @patch('builtins.open', new_callable=mock_open)\n    @patch('fcntl.flock', side_effect=IOError('File locked'))\n    @patch('json.dump')\n    def test_file_locked(self, mock_json_dump, mock_flock, mock_file, mock_getsize, mock_exists):\n        \"\"\"Test when the file is locked by another process.\"\"\"\n        cfg_path = '/path/to/config.json'\n        new_config = {'key': 'value'}\n        result = refresh_config_file(cfg_path, new_config)\n        self.assertFalse(result)\n\n    @patch('os.path.exists', return_value=True)\n    @patch('os.path.getsize', return_value=0)\n    @patch('builtins.open', new_callable=mock_open)\n    @patch('fcntl.flock')\n    @patch('json.dump')\n    def test_file_empty(self, mock_json_dump, mock_flock, mock_file, mock_getsize, mock_exists):\n        \"\"\"Test when the file exists but is empty.\"\"\"\n        cfg_path = '/path/to/config.json'\n        new_config = {'key': 'value'}\n        result = refresh_config_file(cfg_path, new_config)\n        self.assertFalse(result)\n\n    @patch('os.path.exists', return_value=True)\n    @patch('os.path.getsize', return_value=100)\n    @patch('builtins.open', new_callable=mock_open)\n    @patch('fcntl.flock')\n    @patch('json.dump', side_effect=Exception('Disk full'))\n    def test_exception_during_write(self, mock_json_dump, mock_flock, mock_file, mock_getsize, mock_exists):\n        \"\"\"Test when an exception occurs during writing.\"\"\"\n        cfg_path = '/path/to/config.json'\n        new_config = {'key': 'value'}\n        result = refresh_config_file(cfg_path, new_config)\n        self.assertFalse(result)\n\n    @patch('os.path.exists', return_value=True)\n    @patch('builtins.open', side_effect=FileNotFoundError)\n    def test_file_disappears_after_initial_check(self, mock_open, mock_exists):\n        \"\"\"Test when the file exists initially but disappears when opening.\"\"\"\n        cfg_path = '/path/to/config.json'\n        new_config = {'key': 'value'}\n        result = refresh_config_file(cfg_path, new_config)\n        self.assertFalse(result)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 6, "task_id": "f9b718b7"}
{"test": "import unittest\nfrom unittest.mock import patch, mock_open, MagicMock\n\nclass TestRewriteConfig(unittest.TestCase):\n\n    @patch('os.path.exists')\n    @patch('os.path.getsize')\n    @patch('builtins.open', new_callable=mock_open, read_data='{}')\n    @patch('fcntl.flock')\n    @patch('json.dump')\n    def test_happy_path(self, mock_json_dump, mock_flock, mock_file, mock_getsize, mock_exists):\n        \"\"\"Test successful update with valid inputs, non-empty file, and no errors.\"\"\"\n        mock_exists.return_value = True\n        mock_getsize.return_value = 100  # Non-empty file\n        result = rewrite_config('/path/to/config.json', {'key': 'value'})\n        self.assertTrue(result)\n        mock_flock.assert_called_once()\n        mock_file.return_value.seek.assert_called_once_with(0)\n        mock_file.return_value.truncate.assert_called_once()\n        mock_json_dump.assert_called_once_with({'key': 'value'}, mock_file.return_value, indent=4)\n\n    @patch('os.path.exists')\n    def test_file_not_found_initial(self, mock_exists):\n        \"\"\"Test when the configuration file does not exist initially.\"\"\"\n        mock_exists.return_value = False\n        result = rewrite_config('/path/to/config.json', {'key': 'value'})\n        self.assertFalse(result)\n\n    @patch('os.path.exists')\n    @patch('os.path.getsize')\n    def test_file_empty(self, mock_getsize, mock_exists):\n        \"\"\"Test with an existing but empty configuration file.\"\"\"\n        mock_exists.return_value = True\n        mock_getsize.return_value = 0  # Empty file\n        result = rewrite_config('/path/to/config.json', {'key': 'value'})\n        self.assertFalse(result)\n\n    @patch('os.path.exists')\n    @patch('os.path.getsize')\n    @patch('builtins.open', new_callable=mock_open, read_data='{}')\n    @patch('fcntl.flock')\n    def test_lock_failure(self, mock_flock, mock_file, mock_getsize, mock_exists):\n        \"\"\"Test when unable to acquire lock due to IOError.\"\"\"\n        mock_exists.return_value = True\n        mock_getsize.return_value = 100\n        mock_flock.side_effect = IOError  # Simulate lock contention\n        result = rewrite_config('/path/to/config.json', {'key': 'value'})\n        self.assertFalse(result)\n\n    @patch('os.path.exists')\n    @patch('builtins.open')\n    def test_file_disappeared(self, mock_open, mock_exists):\n        \"\"\"Test when file exists initially but disappears before opening.\"\"\"\n        mock_exists.return_value = True\n        mock_open.side_effect = FileNotFoundError  # File removed after initial check\n        result = rewrite_config('/path/to/config.json', {'key': 'value'})\n        self.assertFalse(result)\n\n    @patch('os.path.exists')\n    @patch('os.path.getsize')\n    @patch('builtins.open', new_callable=mock_open, read_data='{}')\n    @patch('fcntl.flock')\n    @patch('json.dump')\n    def test_json_dump_failure(self, mock_json_dump, mock_flock, mock_file, mock_getsize, mock_exists):\n        \"\"\"Test failure during JSON serialization.\"\"\"\n        mock_exists.return_value = True\n        mock_getsize.return_value = 100\n        mock_json_dump.side_effect = TypeError(\"Invalid type\")  # JSON serialization error\n        result = rewrite_config('/path/to/config.json', {'key': 'value'})\n        self.assertFalse(result)\n\n    @patch('os.path.exists')\n    @patch('os.path.getsize')\n    @patch('builtins.open', new_callable=mock_open, read_data='{}')\n    @patch('fcntl.flock')\n    def test_file_operation_failure(self, mock_flock, mock_file, mock_getsize, mock_exists):\n        \"\"\"Test failure during file truncation operation.\"\"\"\n        mock_exists.return_value = True\n        mock_getsize.return_value = 100\n        # Simulate an error during truncation\n        mock_file.return_value.truncate.side_effect = OSError(\"Truncate error\")\n        result = rewrite_config('/path/to/config.json', {'key': 'value'})\n        self.assertFalse(result)", "num_test_cases": 7, "task_id": "f679442d"}
{"test": "import os\nimport json\nimport tempfile\nimport unittest\n\ntry:\n    import fcntl\nexcept ImportError:\n    fcntl = None\n\n@unittest.skipIf(fcntl is None, \"fcntl module is required for these tests\")\nclass TestAdjustConfig(unittest.TestCase):\n    def setUp(self):\n        self.temp_dir = tempfile.TemporaryDirectory()\n        self.file_path = os.path.join(self.temp_dir.name, 'config.json')\n\n    def tearDown(self):\n        self.temp_dir.cleanup()\n\n    def test_file_not_exist(self):\n        \"\"\"Test when the configuration file does not exist.\"\"\"\n        result = adjust_config(\"non_existent_file.json\", {\"key\": \"value\"})\n        self.assertFalse(result)\n\n    def test_successful_update(self):\n        \"\"\"Test updating an existing non-empty config file successfully.\"\"\"\n        with open(self.file_path, 'w') as f:\n            json.dump({\"existing_key\": \"existing_value\"}, f)\n        new_vals = {\"new_key\": \"new_value\"}\n        result = adjust_config(self.file_path, new_vals)\n        self.assertTrue(result)\n        with open(self.file_path, 'r') as f:\n            content = json.load(f)\n        self.assertEqual(content, new_vals)\n\n    def test_empty_file(self):\n        \"\"\"Test when the configuration file exists but is empty.\"\"\"\n        open(self.file_path, 'w').close()\n        result = adjust_config(self.file_path, {\"key\": \"value\"})\n        self.assertFalse(result)\n\n    def test_locked_file(self):\n        \"\"\"Test when the file is locked by another process.\"\"\"\n        with open(self.file_path, 'w') as f:\n            json.dump({\"key\": \"value\"}, f)\n        f = open(self.file_path, 'r+')\n        fcntl.flock(f, fcntl.LOCK_EX | fcntl.LOCK_NB)\n        try:\n            result = adjust_config(self.file_path, {\"new_key\": \"new_value\"})\n            self.assertFalse(result)\n        finally:\n            fcntl.flock(f, fcntl.LOCK_UN)\n            f.close()\n\n    def test_non_serializable_data(self):\n        \"\"\"Test with non-serializable data causing a JSON dump failure.\"\"\"\n        with open(self.file_path, 'w') as f:\n            json.dump({\"key\": \"value\"}, f)\n        bad_data = {\"key\": set([1, 2, 3])}\n        result = adjust_config(self.file_path, bad_data)\n        self.assertFalse(result)\n\n    def test_empty_dict_update(self):\n        \"\"\"Test updating with an empty dictionary.\"\"\"\n        with open(self.file_path, 'w') as f:\n            json.dump({\"key\": \"value\"}, f)\n        result = adjust_config(self.file_path, {})\n        self.assertTrue(result)\n        with open(self.file_path, 'r') as f:\n            content = json.load(f)\n        self.assertEqual(content, {})\n\n    def test_file_removed_after_existence_check(self):\n        \"\"\"Test when file exists initially but is removed before opening.\"\"\"\n        with open(self.file_path, 'w') as f:\n            json.dump({\"key\": \"value\"}, f)\n        # Simulate file removal after existence check\n        original_exists = os.path.exists\n        def mock_exists(path):\n            if path == self.file_path:\n                return False\n            return original_exists(path)\n        os.path.exists = mock_exists\n        try:\n            result = adjust_config(self.file_path, {\"key\": \"new_value\"})\n            self.assertFalse(result)\n        finally:\n            os.path.exists = original_exists\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 7, "task_id": "0c06ae8e"}
{"test": "import unittest\nfrom unittest.mock import patch, mock_open\nimport fcntl\n\nclass TestModifyConfig(unittest.TestCase):\n    \n    @patch('os.path.exists')\n    def test_file_does_not_exist(self, mock_exists):\n        \"\"\"Test when configuration file does not exist.\"\"\"\n        mock_exists.return_value = False\n        result = modify_config('/path/to/config', {'key': 'value'})\n        self.assertFalse(result)\n    \n    @patch('os.path.exists')\n    @patch('os.path.getsize')\n    @patch('builtins.open', new_callable=mock_open)\n    @patch('fcntl.flock')\n    @patch('json.dump')\n    def test_successful_update(self, mock_json_dump, mock_flock, mock_file, mock_getsize, mock_exists):\n        \"\"\"Test successful update with non-empty existing file.\"\"\"\n        mock_exists.return_value = True\n        mock_getsize.return_value = 100\n        result = modify_config('/path/to/config', {'key': 'value'})\n        self.assertTrue(result)\n        mock_file.assert_called_once_with('/path/to/config', 'r+')\n        file_handle = mock_file()\n        mock_flock.assert_called_once_with(file_handle.fileno(), fcntl.LOCK_EX | fcntl.LOCK_NB)\n        file_handle.seek.assert_called_once_with(0)\n        file_handle.truncate.assert_called_once()\n        mock_json_dump.assert_called_once_with({'key': 'value'}, file_handle, indent=4)\n    \n    @patch('os.path.exists')\n    @patch('os.path.getsize')\n    @patch('builtins.open', new_callable=mock_open)\n    def test_file_empty(self, mock_file, mock_getsize, mock_exists):\n        \"\"\"Test when configuration file exists but is empty.\"\"\"\n        mock_exists.return_value = True\n        mock_getsize.return_value = 0\n        result = modify_config('/path/to/config', {'key': 'value'})\n        self.assertFalse(result)\n    \n    @patch('os.path.exists')\n    @patch('os.path.getsize')\n    @patch('builtins.open', new_callable=mock_open)\n    @patch('fcntl.flock')\n    def test_file_locked(self, mock_flock, mock_file, mock_getsize, mock_exists):\n        \"\"\"Test when file is locked by another process.\"\"\"\n        mock_exists.return_value = True\n        mock_getsize.return_value = 100\n        mock_flock.side_effect = IOError(\"Locked by another process\")\n        result = modify_config('/path/to/config', {'key': 'value'})\n        self.assertFalse(result)\n    \n    @patch('os.path.exists')\n    @patch('os.path.getsize')\n    @patch('builtins.open', new_callable=mock_open)\n    @patch('fcntl.flock')\n    @patch('json.dump')\n    def test_exception_during_dump(self, mock_json_dump, mock_flock, mock_file, mock_getsize, mock_exists):\n        \"\"\"Test exception during JSON dump operation.\"\"\"\n        mock_exists.return_value = True\n        mock_getsize.return_value = 100\n        mock_json_dump.side_effect = Exception(\"Dump error\")\n        result = modify_config('/path/to/config', {'key': 'value'})\n        self.assertFalse(result)\n    \n    @patch('os.path.exists')\n    @patch('builtins.open')\n    def test_file_deleted_after_check(self, mock_open, mock_exists):\n        \"\"\"Test when file exists initially but is deleted before opening.\"\"\"\n        mock_exists.return_value = True\n        mock_open.side_effect = FileNotFoundError\n        result = modify_config('/path/to/config', {'key': 'value'})\n        self.assertFalse(result)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 6, "task_id": "313e5be8"}
{"test": "import unittest\nfrom unittest.mock import patch, mock_open, MagicMock\nfrom solution import change_config\n\nclass TestChangeConfig(unittest.TestCase):\n    \n    @patch('solution.os.path.exists', return_value=False)\n    def test_file_not_exist(self, mock_exists):\n        # Test when configuration file does not exist\n        result = change_config('dummy_path', {'key': 'value'})\n        self.assertFalse(result)\n    \n    @patch('solution.os.path.exists', return_value=True)\n    @patch('solution.os.path.getsize', return_value=100)\n    @patch('solution.open', new_callable=mock_open)\n    @patch('fcntl.flock')\n    @patch('solution.json.dump')\n    def test_successful_update(self, mock_dump, mock_flock, mock_file, mock_getsize, mock_exists):\n        # Test successful configuration update\n        mock_file.return_value.seek = MagicMock()\n        mock_file.return_value.truncate = MagicMock()\n        \n        result = change_config('dummy_path', {'key': 'value'})\n        \n        self.assertTrue(result)\n        mock_file.assert_called_once_with('dummy_path', 'r+')\n        mock_file.return_value.seek.assert_called_once_with(0)\n        mock_file.return_value.truncate.assert_called_once()\n        mock_dump.assert_called_once_with({'key': 'value'}, mock_file.return_value, indent=4)\n        mock_file.return_value.close.assert_called_once()\n    \n    @patch('solution.os.path.exists', return_value=True)\n    @patch('solution.os.path.getsize', return_value=0)\n    @patch('solution.open', new_callable=mock_open)\n    @patch('fcntl.flock')\n    def test_empty_file(self, mock_flock, mock_file, mock_getsize, mock_exists):\n        # Test when configuration file exists but is empty\n        result = change_config('dummy_path', {'key': 'value'})\n        self.assertFalse(result)\n    \n    @patch('solution.os.path.exists', return_value=True)\n    @patch('solution.os.path.getsize', return_value=100)\n    @patch('solution.open', new_callable=mock_open)\n    @patch('fcntl.flock', side_effect=IOError)\n    def test_locked_file(self, mock_flock, mock_file, mock_getsize, mock_exists):\n        # Test when file is locked by another process\n        result = change_config('dummy_path', {'key': 'value'})\n        self.assertFalse(result)\n    \n    @patch('solution.os.path.exists', return_value=True)\n    @patch('solution.os.path.getsize', return_value=100)\n    @patch('solution.open', side_effect=FileNotFoundError)\n    @patch('fcntl.flock')\n    def test_file_deleted_after_check(self, mock_flock, mock_open, mock_getsize, mock_exists):\n        # Test when file is deleted after existence check\n        result = change_config('dummy_path', {'key': 'value'})\n        self.assertFalse(result)\n    \n    @patch('solution.os.path.exists', return_value=True)\n    @patch('solution.os.path.getsize', return_value=100)\n    @patch('solution.open', new_callable=mock_open)\n    @patch('fcntl.flock')\n    @patch('solution.json.dump', side_effect=Exception('dump error'))\n    def test_exception_during_update(self, mock_dump, mock_flock, mock_file, mock_getsize, mock_exists):\n        # Test exception during configuration update\n        mock_file.return_value.seek = MagicMock()\n        mock_file.return_value.truncate = MagicMock()\n        \n        result = change_config('dummy_path', {'key': 'value'})\n        \n        self.assertFalse(result)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 6, "task_id": "ae1d1ab9"}
{"test": "import unittest\nfrom unittest.mock import patch, mock_open, MagicMock\nimport fcntl\n\nclass TestRefreshConfig(unittest.TestCase):\n    @patch('os.path.exists')\n    @patch('os.path.getsize')\n    @patch('builtins.open', new_callable=mock_open)\n    @patch('fcntl.flock')\n    @patch('json.dump')\n    def test_successful_update(self, mock_json_dump, mock_flock, mock_open_file, mock_getsize, mock_exists):\n        # Test successful update: file exists, non-empty, lock acquired, write succeeds.\n        mock_exists.return_value = True\n        mock_getsize.return_value = 100\n        result = refresh_config('test_config.json', {'key': 'value'})\n        self.assertTrue(result)\n        mock_open_file.assert_called_once_with('test_config.json', 'r+')\n        mock_flock.assert_called_once_with(mock_open_file.return_value.fileno(), fcntl.LOCK_EX | fcntl.LOCK_NB)\n        mock_open_file.return_value.seek.assert_called_once_with(0)\n        mock_open_file.return_value.truncate.assert_called_once_with(0)\n        mock_json_dump.assert_called_once_with({'key': 'value'}, mock_open_file.return_value, indent=4)\n\n    @patch('os.path.exists', return_value=False)\n    def test_file_not_found(self, mock_exists):\n        # Test when the configuration file does not exist.\n        result = refresh_config('missing_config.json', {'key': 'value'})\n        self.assertFalse(result)\n\n    @patch('os.path.exists', return_value=True)\n    @patch('builtins.open', side_effect=FileNotFoundError)\n    def test_file_deleted_after_check(self, mock_open, mock_exists):\n        # Test when file is deleted after existence check (race condition).\n        result = refresh_config('test_config.json', {'key': 'value'})\n        self.assertFalse(result)\n\n    @patch('os.path.exists', return_value=True)\n    @patch('os.path.getsize', return_value=0)\n    def test_file_empty(self, mock_getsize, mock_exists):\n        # Test when configuration file is empty.\n        result = refresh_config('empty_config.json', {'key': 'value'})\n        self.assertFalse(result)\n\n    @patch('os.path.exists', return_value=True)\n    @patch('os.path.getsize', return_value=100)\n    @patch('builtins.open', new_callable=mock_open)\n    @patch('fcntl.flock', side_effect=IOError)\n    def test_file_locked(self, mock_flock, mock_open_file, mock_getsize, mock_exists):\n        # Test when file is locked by another process.\n        result = refresh_config('locked_config.json', {'key': 'value'})\n        self.assertFalse(result)\n\n    @patch('os.path.exists', return_value=True)\n    @patch('os.path.getsize', return_value=100)\n    @patch('builtins.open', new_callable=mock_open)\n    @patch('fcntl.flock')\n    @patch('json.dump', side_effect=TypeError)\n    def test_json_dump_exception(self, mock_json_dump, mock_flock, mock_open_file, mock_getsize, mock_exists):\n        # Test exception during JSON dump operation.\n        result = refresh_config('test_config.json', {'key': 'value'})\n        self.assertFalse(result)\n\n    @patch('os.path.exists', return_value=True)\n    @patch('os.path.getsize', return_value=100)\n    @patch('builtins.open', new_callable=mock_open)\n    @patch('fcntl.flock')\n    @patch('json.dump', side_effect=PermissionError)\n    def test_other_exception_during_write(self, mock_json_dump, mock_flock, mock_open_file, mock_getsize, mock_exists):\n        # Test other exceptions during file write operation.\n        result = refresh_config('test_config.json', {'key': 'value'})\n        self.assertFalse(result)\n", "num_test_cases": 7, "task_id": "5f4e81b9"}
{"test": "import unittest\nimport os\nimport fcntl\nimport tempfile\nimport stat\nfrom unittest.mock import patch\n\nclass TestDeleteTempFile(unittest.TestCase):\n\n    def test_file_does_not_exist(self):\n        # Test when the file does not exist - should return True\n        with tempfile.TemporaryDirectory() as temp_dir:\n            file_path = os.path.join(temp_dir, 'non_existent.txt')\n            self.assertFalse(os.path.exists(file_path))\n            result = delete_temp_file(file_path)\n            self.assertTrue(result)\n\n    def test_file_exists_and_unlocked(self):\n        # Test when file exists and is unlocked - should be deleted and return True\n        with tempfile.TemporaryDirectory() as temp_dir:\n            file_path = os.path.join(temp_dir, 'test.txt')\n            with open(file_path, 'w') as f:\n                f.write('test')\n            self.assertTrue(os.path.exists(file_path))\n            result = delete_temp_file(file_path)\n            self.assertTrue(result)\n            self.assertFalse(os.path.exists(file_path))\n\n    def test_file_locked(self):\n        # Test when file is locked - should fail to delete and return False\n        with tempfile.TemporaryDirectory() as temp_dir:\n            file_path = os.path.join(temp_dir, 'test.txt')\n            with open(file_path, 'w') as f:\n                f.write('test')\n            # Open and lock the file\n            with open(file_path, 'r') as f_lock:\n                fcntl.flock(f_lock.fileno(), fcntl.LOCK_EX | fcntl.LOCK_NB)\n                result = delete_temp_file(file_path)\n                self.assertFalse(result)\n\n    def test_file_disappears_after_existence_check(self):\n        # Test when file disappears after existence check - should return True\n        with patch('os.path.exists', return_value=True):\n            with patch('builtins.open', side_effect=FileNotFoundError):\n                result = delete_temp_file('some_path')\n                self.assertTrue(result)\n\n    def test_file_is_directory(self):\n        # Test when path is a directory - should return False\n        with tempfile.TemporaryDirectory() as temp_dir:\n            result = delete_temp_file(temp_dir)\n            self.assertFalse(result)\n\n    def test_permission_error_on_delete(self):\n        # Test when directory lacks write permission - should return False\n        with tempfile.TemporaryDirectory() as temp_dir:\n            file_path = os.path.join(temp_dir, 'test.txt')\n            with open(file_path, 'w') as f:\n                f.write('test')\n            \n            original_perms = os.stat(temp_dir).st_mode\n            try:\n                # Remove write permission\n                os.chmod(temp_dir, stat.S_IRUSR | stat.S_IXUSR)\n                result = delete_temp_file(file_path)\n                self.assertFalse(result)\n            finally:\n                # Restore permissions\n                os.chmod(temp_dir, original_perms)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 6, "task_id": "efbe43e0"}
{"test": "import unittest\nfrom unittest.mock import patch, MagicMock\nfrom solution import update_user_profile\n\nclass TestCases(unittest.TestCase):\n\n    @patch('solution.database_connection.get_connection')\n    def test_case_1(self, mock_get_connection):\n        # Test updating an existing user with valid data\n        mock_conn = MagicMock()\n        mock_get_connection.return_value = mock_conn\n        mock_conn.update_profile_if_exists.return_value = True\n        \n        result = update_user_profile(1, {'name': 'Alice'})\n        self.assertTrue(result)\n        mock_conn.update_profile_if_exists.assert_called_once_with(1, {'name': 'Alice'})\n    \n    @patch('solution.database_connection.get_connection')\n    def test_case_2(self, mock_get_connection):\n        # Test updating a non-existing user\n        mock_conn = MagicMock()\n        mock_get_connection.return_value = mock_conn\n        mock_conn.update_profile_if_exists.return_value = False\n        \n        with patch('builtins.print') as mock_print:\n            result = update_user_profile(2, {'name': 'Bob'})\n            self.assertFalse(result)\n            mock_print.assert_called_once_with('User 2 does not exist or update failed.')\n    \n    @patch('solution.database_connection.get_connection')\n    def test_case_3(self, mock_get_connection):\n        # Test when the database update operation raises an exception\n        mock_conn = MagicMock()\n        mock_get_connection.return_value = mock_conn\n        mock_conn.update_profile_if_exists.side_effect = Exception('DB error')\n        \n        with patch('builtins.print') as mock_print:\n            result = update_user_profile(3, {'name': 'Charlie'})\n            self.assertFalse(result)\n            mock_print.assert_called_once_with('Failed to update profile for user 3: DB error')\n    \n    @patch('solution.database_connection.get_connection')\n    def test_case_4(self, mock_get_connection):\n        # Test updating with an empty profile data dictionary (user exists)\n        mock_conn = MagicMock()\n        mock_get_connection.return_value = mock_conn\n        mock_conn.update_profile_if_exists.return_value = True\n        \n        result = update_user_profile(4, {})\n        self.assertTrue(result)\n        mock_conn.update_profile_if_exists.assert_called_once_with(4, {})\n    \n    @patch('solution.database_connection.get_connection')\n    def test_case_5(self, mock_get_connection):\n        # Test with non-integer user_id\n        mock_conn = MagicMock()\n        mock_get_connection.return_value = mock_conn\n        mock_conn.update_profile_if_exists.side_effect = TypeError('user_id must be integer')\n        \n        result = update_user_profile('5', {'name': 'Dave'})\n        self.assertFalse(result)\n    \n    @patch('solution.database_connection.get_connection')\n    def test_case_6(self, mock_get_connection):\n        # Test with non-dict new_profile_data\n        mock_conn = MagicMock()\n        mock_get_connection.return_value = mock_conn\n        mock_conn.update_profile_if_exists.side_effect = TypeError('new_profile_data must be a dict')\n        \n        result = update_user_profile(6, 'not a dict')\n        self.assertFalse(result)", "num_test_cases": 6, "task_id": "97131b05"}
{"test": "import unittest\nfrom unittest.mock import patch, mock_open\nimport os\nimport time\n\ntry:\n    import fcntl\nexcept ImportError:\n    fcntl = None\n\n@unittest.skipIf(fcntl is None, \"fcntl module not available\")\nclass TestProcessLargeFile(unittest.TestCase):\n\n    def test_file_not_found(self):\n        # Test when file does not exist\n        with patch('os.path.exists') as mock_exists:\n            mock_exists.return_value = False\n            result = process_large_file('dummy_path')\n            self.assertFalse(result)\n\n    def test_file_locked(self):\n        # Test when file is locked by another process\n        with patch('os.path.exists') as mock_exists, \\\n             patch('builtins.open', mock_open()) as mock_file, \\\n             patch('fcntl.flock') as mock_flock, \\\n             patch('builtins.print') as mock_print:\n            \n            mock_exists.return_value = True\n            mock_file.return_value.fileno.return_value = 123\n            mock_flock.side_effect = IOError(\"Lock failed\")\n            result = process_large_file('dummy_path')\n            self.assertFalse(result)\n            mock_print.assert_called_with(\"File dummy_path is locked by another process.\")\n            mock_file.return_value.close.assert_called_once()\n\n    def test_file_empty(self):\n        # Test when file exists but is empty\n        with patch('os.path.exists') as mock_exists, \\\n             patch('os.path.getsize') as mock_getsize, \\\n             patch('builtins.open', mock_open()) as mock_file, \\\n             patch('fcntl.flock') as mock_flock, \\\n             patch('builtins.print') as mock_print:\n            \n            mock_exists.return_value = True\n            mock_getsize.return_value = 0\n            mock_file.return_value.fileno.return_value = 123\n            mock_flock.return_value = None\n            result = process_large_file('dummy_path')\n            self.assertFalse(result)\n            mock_print.assert_called_with(\"File dummy_path is not ready for processing.\")\n            mock_file.return_value.close.assert_called_once()\n\n    def test_file_success(self):\n        # Test successful file processing\n        with patch('os.path.exists') as mock_exists, \\\n             patch('os.path.getsize') as mock_getsize, \\\n             patch('builtins.open', mock_open()) as mock_file, \\\n             patch('fcntl.flock') as mock_flock, \\\n             patch('time.sleep') as mock_sleep, \\\n             patch('builtins.print') as mock_print:\n            \n            mock_exists.return_value = True\n            mock_getsize.return_value = 100\n            mock_file.return_value.fileno.return_value = 123\n            mock_flock.return_value = None\n            result = process_large_file('dummy_path')\n            self.assertTrue(result)\n            mock_print.assert_called_with(\"Processing file: dummy_path\")\n            mock_sleep.assert_called_once_with(5)\n            mock_file.return_value.close.assert_called_once()\n\n    def test_processing_failure(self):\n        # Test processing failure due to exception\n        with patch('os.path.exists') as mock_exists, \\\n             patch('os.path.getsize') as mock_getsize, \\\n             patch('builtins.open', mock_open()) as mock_file, \\\n             patch('fcntl.flock') as mock_flock, \\\n             patch('time.sleep') as mock_sleep, \\\n             patch('builtins.print') as mock_print:\n            \n            mock_exists.return_value = True\n            mock_getsize.return_value = 100\n            mock_file.return_value.fileno.return_value = 123\n            mock_flock.return_value = None\n            mock_sleep.side_effect = Exception(\"simulated error\")\n            result = process_large_file('dummy_path')\n            self.assertFalse(result)\n            mock_print.assert_called_with(\"Failed to process file dummy_path: simulated error\")\n            mock_file.return_value.close.assert_called_once()\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 5, "task_id": "fa68194d"}
{"test": "import unittest\nfrom unittest.mock import patch, MagicMock\nfrom datetime import datetime, timedelta\nfrom solution import clean_expired_sessions\n\nclass TestCleanExpiredSessions(unittest.TestCase):\n\n    def test_case_1(self):\n        # Test typical case: remove 3 sessions.\n        fixed_now = datetime(2023, 1, 1, 12, 0, 0)\n        with patch('solution.database.get_connection') as mock_get_conn, \\\n             patch('solution.datetime') as mock_datetime:\n            \n            mock_datetime.now.return_value = fixed_now\n            mock_conn = MagicMock()\n            mock_get_conn.return_value = mock_conn\n            mock_ctx = MagicMock()\n            mock_conn.transaction.return_value = mock_ctx\n            mock_result = MagicMock()\n            mock_conn.execute.return_value = mock_result\n            mock_result.rowcount = 3\n            \n            result = clean_expired_sessions(10)\n            \n            self.assertEqual(result, 3)\n            mock_conn.transaction.assert_called_once()\n            expected_threshold = fixed_now - timedelta(minutes=10)\n            args, _ = mock_conn.execute.call_args\n            self.assertEqual(len(args), 2)\n            self.assertIn('DELETE FROM sessions', args[0])\n            self.assertEqual(args[1], (expected_threshold,))\n\n    def test_case_2(self):\n        # Test no sessions to remove.\n        fixed_now = datetime(2023, 1, 1, 12, 0, 0)\n        with patch('solution.database.get_connection') as mock_get_conn, \\\n             patch('solution.datetime') as mock_datetime:\n            \n            mock_datetime.now.return_value = fixed_now\n            mock_conn = MagicMock()\n            mock_get_conn.return_value = mock_conn\n            mock_ctx = MagicMock()\n            mock_conn.transaction.return_value = mock_ctx\n            mock_result = MagicMock()\n            mock_conn.execute.return_value = mock_result\n            mock_result.rowcount = 0\n            \n            result = clean_expired_sessions(30)\n            self.assertEqual(result, 0)\n\n    def test_case_3(self):\n        # Test expiration_time=0: threshold is current time.\n        fixed_now = datetime(2023, 1, 1, 12, 0, 0)\n        with patch('solution.database.get_connection') as mock_get_conn, \\\n             patch('solution.datetime') as mock_datetime:\n            \n            mock_datetime.now.return_value = fixed_now\n            mock_conn = MagicMock()\n            mock_get_conn.return_value = mock_conn\n            mock_ctx = MagicMock()\n            mock_conn.transaction.return_value = mock_ctx\n            mock_result = MagicMock()\n            mock_conn.execute.return_value = mock_result\n            mock_result.rowcount = 1\n            \n            result = clean_expired_sessions(0)\n            self.assertEqual(result, 1)\n            expected_threshold = fixed_now - timedelta(minutes=0)\n            args, _ = mock_conn.execute.call_args\n            self.assertEqual(args[1], (expected_threshold,))\n\n    def test_case_4(self):\n        # Test large expiration_time: 1000000 minutes.\n        fixed_now = datetime(2023, 1, 1, 12, 0, 0)\n        with patch('solution.database.get_connection') as mock_get_conn, \\\n             patch('solution.datetime') as mock_datetime:\n            \n            mock_datetime.now.return_value = fixed_now\n            mock_conn = MagicMock()\n            mock_get_conn.return_value = mock_conn\n            mock_ctx = MagicMock()\n            mock_conn.transaction.return_value = mock_ctx\n            mock_result = MagicMock()\n            mock_conn.execute.return_value = mock_result\n            mock_result.rowcount = 5\n            \n            result = clean_expired_sessions(1000000)\n            self.assertEqual(result, 5)\n            expected_threshold = fixed_now - timedelta(minutes=1000000)\n            args, _ = mock_conn.execute.call_args\n            self.assertEqual(args[1], (expected_threshold,))\n\n    def test_case_5(self):\n        # Test database exception: returns 0 and prints error.\n        fixed_now = datetime(2023, 1, 1, 12, 0, 0)\n        with patch('solution.database.get_connection') as mock_get_conn, \\\n             patch('solution.datetime') as mock_datetime, \\\n             patch('builtins.print') as mock_print:\n            \n            mock_datetime.now.return_value = fixed_now\n            mock_conn = MagicMock()\n            mock_get_conn.return_value = mock_conn\n            mock_ctx = MagicMock()\n            mock_conn.transaction.return_value = mock_ctx\n            mock_conn.execute.side_effect = Exception(\"DB error\")\n            \n            result = clean_expired_sessions(10)\n            self.assertEqual(result, 0)\n            mock_print.assert_called_once()\n            self.assertIn('Failed to clean expired sessions', mock_print.call_args[0][0])\n\n    def test_case_6(self):\n        # Test negative expiration_time: threshold in future.\n        fixed_now = datetime(2023, 1, 1, 12, 0, 0)\n        with patch('solution.database.get_connection') as mock_get_conn, \\\n             patch('solution.datetime') as mock_datetime:\n            \n            mock_datetime.now.return_value = fixed_now\n            mock_conn = MagicMock()\n            mock_get_conn.return_value = mock_conn\n            mock_ctx = MagicMock()\n            mock_conn.transaction.return_value = mock_ctx\n            mock_result = MagicMock()\n            mock_conn.execute.return_value = mock_result\n            mock_result.rowcount = 100\n            \n            result = clean_expired_sessions(-10)\n            self.assertEqual(result, 100)\n            expected_threshold = fixed_now - timedelta(minutes=-10)\n            args, _ = mock_conn.execute.call_args\n            self.assertEqual(args[1], (expected_threshold,))\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 6, "task_id": "4db56cbc"}
