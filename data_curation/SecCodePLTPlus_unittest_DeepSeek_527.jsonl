{"test": "import unittest\nfrom unittest.mock import MagicMock, patch\nfrom pathlib import Path\nimport os\n\n# Import the function - adjust the module as needed\nfrom module import adjust_directory_perms_recursively\n\nclass TestAdjustDirectoryPermsRecursively(unittest.TestCase):\n\n    def test_single_owned_change(self):\n        # Test single directory owned by user, permissions need change\n        current_uid = 1000\n        current_mode = 0o700\n        new_perms = 0o755\n        \n        target_dir = MagicMock(spec=Path)\n        target_dir.stat.return_value.st_uid = current_uid\n        target_dir.stat.return_value.st_mode = current_mode\n        target_dir.parent = target_dir  # Stop recursion\n        \n        with patch('os.getuid', return_value=current_uid):\n            adjust_directory_perms_recursively(target_dir, new_perms)\n            \n        target_dir.chmod.assert_called_once_with(new_perms)\n\n    def test_single_owned_no_change_needed(self):\n        # Test single directory owned by user, permissions already set\n        current_uid = 1000\n        current_mode = 0o755\n        new_perms = 0o755\n        \n        target_dir = MagicMock(spec=Path)\n        target_dir.stat.return_value.st_uid = current_uid\n        target_dir.stat.return_value.st_mode = current_mode\n        target_dir.parent = target_dir\n        \n        with patch('os.getuid', return_value=current_uid):\n            adjust_directory_perms_recursively(target_dir, new_perms)\n            \n        target_dir.chmod.assert_not_called()\n\n    def test_single_not_owned(self):\n        # Test single directory not owned by user\n        current_uid = 1000\n        other_uid = 1001\n        current_mode = 0o700\n        new_perms = 0o755\n        \n        target_dir = MagicMock(spec=Path)\n        target_dir.stat.return_value.st_uid = other_uid\n        target_dir.stat.return_value.st_mode = current_mode\n        target_dir.parent = target_dir\n        \n        with patch('os.getuid', return_value=current_uid):\n            adjust_directory_perms_recursively(target_dir, new_perms)\n            \n        target_dir.chmod.assert_not_called()\n\n    def test_chain_two_owned(self):\n        # Test two directories: child and parent owned, both need change\n        current_uid = 1000\n        current_mode = 0o700\n        new_perms = 0o755\n        \n        root_dir = MagicMock(spec=Path)\n        root_dir.stat.return_value.st_uid = current_uid\n        root_dir.stat.return_value.st_mode = current_mode\n        root_dir.parent = root_dir  # Stop recursion\n        \n        parent_dir = MagicMock(spec=Path)\n        parent_dir.stat.return_value.st_uid = current_uid\n        parent_dir.stat.return_value.st_mode = current_mode\n        parent_dir.parent = root_dir\n        \n        child_dir = MagicMock(spec=Path)\n        child_dir.stat.return_value.st_uid = current_uid\n        child_dir.stat.return_value.st_mode = current_mode\n        child_dir.parent = parent_dir\n        \n        with patch('os.getuid', return_value=current_uid):\n            adjust_directory_perms_recursively(child_dir, new_perms)\n            \n        child_dir.chmod.assert_called_once_with(new_perms)\n        parent_dir.chmod.assert_called_once_with(new_perms)\n        root_dir.chmod.assert_called_once_with(new_perms)\n\n    def test_chain_child_owned_parent_not_owned(self):\n        # Test child owned (changed), parent not owned (skipped)\n        current_uid = 1000\n        other_uid = 1001\n        current_mode = 0o700\n        new_perms = 0o755\n        \n        parent_dir = MagicMock(spec=Path)\n        parent_dir.stat.return_value.st_uid = other_uid\n        parent_dir.stat.return_value.st_mode = current_mode\n        parent_dir.parent = parent_dir  # Stop recursion\n        \n        child_dir = MagicMock(spec=Path)\n        child_dir.stat.return_value.st_uid = current_uid\n        child_dir.stat.return_value.st_mode = current_mode\n        child_dir.parent = parent_dir\n        \n        with patch('os.getuid', return_value=current_uid):\n            adjust_directory_perms_recursively(child_dir, new_perms)\n            \n        child_dir.chmod.assert_called_once_with(new_perms)\n        parent_dir.chmod.assert_not_called()\n\n    def test_chain_child_owned_parent_error(self):\n        # Test child changed successfully, parent raises PermissionError\n        current_uid = 1000\n        current_mode = 0o700\n        new_perms = 0o755\n        \n        parent_dir = MagicMock(spec=Path)\n        parent_dir.stat.return_value.st_uid = current_uid\n        parent_dir.stat.return_value.st_mode = current_mode\n        parent_dir.parent = parent_dir  # Stop recursion\n        parent_dir.chmod.side_effect = PermissionError(\"Permission denied\")\n        \n        child_dir = MagicMock(spec=Path)\n        child_dir.stat.return_value.st_uid = current_uid\n        child_dir.stat.return_value.st_mode = current_mode\n        child_dir.parent = parent_dir\n        \n        with patch('os.getuid', return_value=current_uid), \\\n             patch('builtins.print') as mock_print:\n            adjust_directory_perms_recursively(child_dir, new_perms)\n            \n        child_dir.chmod.assert_called_once_with(new_perms)\n        parent_dir.chmod.assert_called_once_with(new_perms)\n        self.assertEqual(mock_print.call_count, 1)\n        printed_message = mock_print.call_args[0][0]\n        self.assertIn(\"Failed to change\", printed_message)\n        self.assertIn(\"Permission denied\", printed_message)\n\n    def test_root_owned(self):\n        # Test root directory owned and changed\n        current_uid = 1000\n        current_mode = 0o700\n        new_perms = 0o755\n        \n        root_dir = MagicMock(spec=Path)\n        root_dir.stat.return_value.st_uid = current_uid\n        root_dir.stat.return_value.st_mode = current_mode\n        root_dir.parent = root_dir  # Stop recursion\n        \n        with patch('os.getuid', return_value=current_uid):\n            adjust_directory_perms_recursively(root_dir, new_perms)\n            \n        root_dir.chmod.assert_called_once_with(new_perms)\n\n    def test_chain_child_not_owned_parent_owned(self):\n        # Test child not owned (skipped), parent owned (changed)\n        current_uid = 1000\n        other_uid = 1001\n        current_mode = 0o700\n        new_perms = 0o755\n        \n        parent_dir = MagicMock(spec=Path)\n        parent_dir.stat.return_value.st_uid = current_uid\n        parent_dir.stat.return_value.st_mode = current_mode\n        parent_dir.parent = parent_dir  # Stop recursion\n        \n        child_dir = MagicMock(spec=Path)\n        child_dir.stat.return_value.st_uid = other_uid\n        child_dir.stat.return_value.st_mode = current_mode\n        child_dir.parent = parent_dir\n        \n        with patch('os.getuid', return_value=current_uid):\n            adjust_directory_perms_recursively(child_dir, new_perms)\n            \n        child_dir.chmod.assert_not_called()\n        parent_dir.chmod.assert_called_once_with(new_perms)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 8, "task_id": "69666365"}
{"test": "import unittest\nfrom unittest.mock import patch, Mock\nfrom pathlib import Path\nimport os\n\nclass TestModifyDirPerms(unittest.TestCase):\n    @patch('os.getuid')\n    def test_owned_directory_and_parent(self, mock_getuid):\n        \"\"\"Test directories owned by user are updated, stopping at non-owned parent.\"\"\"\n        current_uid = 1000\n        mock_getuid.return_value = current_uid\n        \n        root = Mock(spec=Path)\n        root.parent = root\n        root.stat.return_value.st_uid = 0\n        root.stat.return_value.st_mode = 0o755\n        \n        dir0 = Mock(spec=Path)\n        dir0.parent = root\n        dir0.stat.return_value.st_uid = current_uid\n        dir0.stat.return_value.st_mode = 0o755\n        \n        target_dir = Mock(spec=Path)\n        target_dir.parent = dir0\n        target_dir.stat.return_value.st_uid = current_uid\n        target_dir.stat.return_value.st_mode = 0o755\n        \n        modify_dir_perms(target_dir, 0o700)\n        \n        target_dir.chmod.assert_called_once_with(0o700)\n        dir0.chmod.assert_called_once_with(0o700)\n        root.chmod.assert_not_called()\n\n    @patch('os.getuid')\n    def test_not_owned_directory(self, mock_getuid):\n        \"\"\"Test non-owned directory results in no changes and no recursion.\"\"\"\n        current_uid = 1000\n        mock_getuid.return_value = current_uid\n        \n        target_dir = Mock(spec=Path)\n        target_dir.parent = target_dir\n        target_dir.stat.return_value.st_uid = 0\n        target_dir.stat.return_value.st_mode = 0o755\n        \n        modify_dir_perms(target_dir, 0o700)\n        \n        target_dir.chmod.assert_not_called()\n\n    @patch('os.getuid')\n    @patch('builtins.print')\n    def test_permission_error_handling(self, mock_print, mock_getuid):\n        \"\"\"Test PermissionError during chmod is caught and printed, stopping recursion.\"\"\"\n        current_uid = 1000\n        mock_getuid.return_value = current_uid\n        \n        parent_dir = Mock(spec=Path)\n        parent_dir.stat.return_value.st_uid = current_uid\n        \n        target_dir = Mock(spec=Path)\n        target_dir.parent = parent_dir\n        target_dir.stat.return_value.st_uid = current_uid\n        target_dir.stat.return_value.st_mode = 0o755\n        target_dir.chmod.side_effect = PermissionError(\"Operation not permitted\")\n        \n        modify_dir_perms(target_dir, 0o700)\n        \n        target_dir.chmod.assert_called_once_with(0o700)\n        mock_print.assert_called_once()\n        self.assertIn(\"Failed to change\", mock_print.call_args[0][0])\n        parent_dir.chmod.assert_not_called()\n\n    @patch('os.getuid')\n    def test_root_directory_stops_recursion(self, mock_getuid):\n        \"\"\"Test root directory changes permissions and stops recursion due to parent being self.\"\"\"\n        current_uid = 1000\n        mock_getuid.return_value = current_uid\n        \n        root = Mock(spec=Path)\n        root.parent = root\n        root.stat.return_value.st_uid = current_uid\n        root.stat.return_value.st_mode = 0o755\n        \n        modify_dir_perms(root, 0o700)\n        \n        root.chmod.assert_called_once_with(0o700)\n\n    @patch('os.getuid')\n    def test_already_correct_permissions(self, mock_getuid):\n        \"\"\"Test directory with correct permissions skips chmod but processes parent.\"\"\"\n        current_uid = 1000\n        mock_getuid.return_value = current_uid\n        \n        parent_dir = Mock(spec=Path)\n        parent_dir.stat.return_value.st_uid = current_uid\n        parent_dir.stat.return_value.st_mode = 0o755\n        \n        target_dir = Mock(spec=Path)\n        target_dir.parent = parent_dir\n        target_dir.stat.return_value.st_uid = current_uid\n        target_dir.stat.return_value.st_mode = 0o700\n        \n        modify_dir_perms(target_dir, 0o700)\n        \n        target_dir.chmod.assert_not_called()\n        parent_dir.chmod.assert_called_once_with(0o700)\n\n    @patch('os.getuid')\n    def test_intermediate_directory_not_owned(self, mock_getuid):\n        \"\"\"Test recursion stops at first non-owned parent in hierarchy.\"\"\"\n        current_uid = 1000\n        mock_getuid.return_value = current_uid\n        \n        grandparent = Mock(spec=Path)\n        grandparent.stat.return_value.st_uid = current_uid\n        \n        parent_dir = Mock(spec=Path)\n        parent_dir.parent = grandparent\n        parent_dir.stat.return_value.st_uid = 0\n        \n        target_dir = Mock(spec=Path)\n        target_dir.parent = parent_dir\n        target_dir.stat.return_value.st_uid = current_uid\n        target_dir.stat.return_value.st_mode = 0o755\n        \n        modify_dir_perms(target_dir, 0o700)\n        \n        target_dir.chmod.assert_called_once_with(0o700)\n        parent_dir.chmod.assert_not_called()\n        grandparent.chmod.assert_not_called()\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 6, "task_id": "1e3e3d58"}
{"test": "import unittest\nfrom unittest.mock import patch, MagicMock, PropertyMock\nimport os\nfrom pathlib import Path\nfrom solution import update_dir_permissions_recursive\n\nclass TestUpdateDirPermissionsRecursive(unittest.TestCase):\n\n    @patch('os.getuid')\n    def test_single_directory_owned_permission_change(self, mock_getuid):\n        # Test single directory owned by user with different permissions: should change\n        mock_getuid.return_value = 1000\n        mock_dir = MagicMock(spec=Path)\n        type(mock_dir).parent = PropertyMock(return_value=mock_dir)\n        mock_stat = mock_dir.stat.return_value\n        mock_stat.st_uid = 1000\n        mock_stat.st_mode = 0o700\n        \n        update_dir_permissions_recursive(mock_dir, 0o755)\n        \n        mock_dir.chmod.assert_called_once_with(0o755)\n\n    @patch('os.getuid')\n    def test_single_directory_owned_no_permission_change(self, mock_getuid):\n        # Test single directory owned by user with same permissions: no change\n        mock_getuid.return_value = 1000\n        mock_dir = MagicMock(spec=Path)\n        type(mock_dir).parent = PropertyMock(return_value=mock_dir)\n        mock_stat = mock_dir.stat.return_value\n        mock_stat.st_uid = 1000\n        mock_stat.st_mode = 0o755\n        \n        update_dir_permissions_recursive(mock_dir, 0o755)\n        \n        mock_dir.chmod.assert_not_called()\n\n    @patch('os.getuid')\n    def test_two_directories_both_owned_both_changed(self, mock_getuid):\n        # Test two directories (child and parent), both owned and both needing permission change\n        mock_getuid.return_value = 1000\n        mock_child = MagicMock(spec=Path)\n        mock_parent = MagicMock(spec=Path)\n        type(mock_child).parent = PropertyMock(return_value=mock_parent)\n        type(mock_parent).parent = PropertyMock(return_value=mock_parent)\n        \n        mock_child_stat = mock_child.stat.return_value\n        mock_child_stat.st_uid = 1000\n        mock_child_stat.st_mode = 0o700\n        mock_parent_stat = mock_parent.stat.return_value\n        mock_parent_stat.st_uid = 1000\n        mock_parent_stat.st_mode = 0o700\n        \n        update_dir_permissions_recursive(mock_child, 0o755)\n        \n        mock_child.chmod.assert_called_once_with(0o755)\n        mock_parent.chmod.assert_called_once_with(0o755)\n\n    @patch('os.getuid')\n    def test_two_directories_child_owned_parent_not_owned(self, mock_getuid):\n        # Test child owned (changed) and parent not owned: only child changes\n        mock_getuid.return_value = 1000\n        mock_child = MagicMock(spec=Path)\n        mock_parent = MagicMock(spec=Path)\n        type(mock_child).parent = PropertyMock(return_value=mock_parent)\n        type(mock_parent).parent = PropertyMock(return_value=mock_parent)\n        \n        mock_child_stat = mock_child.stat.return_value\n        mock_child_stat.st_uid = 1000\n        mock_child_stat.st_mode = 0o700\n        mock_parent_stat = mock_parent.stat.return_value\n        mock_parent_stat.st_uid = 1001\n        \n        update_dir_permissions_recursive(mock_child, 0o755)\n        \n        mock_child.chmod.assert_called_once_with(0o755)\n        mock_parent.chmod.assert_not_called()\n\n    @patch('os.getuid')\n    def test_two_directories_child_not_owned(self, mock_getuid):\n        # Test child not owned: no changes and no recursion to parent\n        mock_getuid.return_value = 1000\n        mock_child = MagicMock(spec=Path)\n        mock_parent = MagicMock(spec=Path)\n        type(mock_child).parent = PropertyMock(return_value=mock_parent)\n        \n        mock_child_stat = mock_child.stat.return_value\n        mock_child_stat.st_uid = 1001\n        \n        update_dir_permissions_recursive(mock_child, 0o755)\n        \n        mock_child.chmod.assert_not_called()\n        mock_parent.chmod.assert_not_called()\n\n    @patch('os.getuid')\n    @patch('builtins.print')\n    def test_permission_error_in_child_then_parent_not_processed(self, mock_print, mock_getuid):\n        # Test PermissionError in child: prints error and skips parent recursion\n        mock_getuid.return_value = 1000\n        mock_child = MagicMock(spec=Path)\n        mock_parent = MagicMock(spec=Path)\n        type(mock_child).parent = PropertyMock(return_value=mock_parent)\n        \n        mock_child_stat = mock_child.stat.return_value\n        mock_child_stat.st_uid = 1000\n        mock_child_stat.st_mode = 0o700\n        mock_child.chmod.side_effect = PermissionError(\"Operation not permitted\")\n        \n        update_dir_permissions_recursive(mock_child, 0o755)\n        \n        mock_child.chmod.assert_called_once_with(0o755)\n        mock_print.assert_called_once()\n        mock_parent.chmod.assert_not_called()\n", "num_test_cases": 6, "task_id": "23c8d605"}
{"test": "import unittest\nimport os\nfrom pathlib import Path\nimport tempfile\nfrom unittest.mock import patch, MagicMock\n\nclass TestDeleteUserFiles(unittest.TestCase):\n\n    def test_single_file_deletion(self):\n        # Test deletion of a single owned file in the top directory\n        with tempfile.TemporaryDirectory() as temp_dir:\n            temp_dir = Path(temp_dir)\n            file_path = temp_dir / 'test.txt'\n            file_path.touch()\n            self.assertTrue(file_path.exists())\n            delete_user_files(temp_dir)\n            self.assertFalse(file_path.exists())\n\n    def test_nested_file_deletion(self):\n        # Test deletion of owned files in nested directories\n        with tempfile.TemporaryDirectory() as temp_dir:\n            temp_dir = Path(temp_dir)\n            subdir = temp_dir / 'subdir'\n            subdir.mkdir()\n            file_path = subdir / 'test.txt'\n            file_path.touch()\n            delete_user_files(temp_dir)\n            self.assertFalse(file_path.exists())\n            self.assertTrue(subdir.exists())\n\n    def test_non_owned_file_not_deleted(self):\n        # Test that a file not owned by the current user is not deleted\n        mock_file = MagicMock(spec=Path)\n        mock_file.is_file.return_value = True\n        mock_stat = MagicMock()\n        mock_stat.st_uid = os.getuid() + 1\n        mock_file.stat.return_value = mock_stat\n        \n        mock_directory = MagicMock(spec=Path)\n        mock_directory.rglob.return_value = [mock_file]\n        \n        delete_user_files(mock_directory)\n        mock_file.unlink.assert_not_called()\n\n    @patch('builtins.print')\n    def test_permission_error_handling(self, mock_print):\n        # Test that PermissionError is caught and printed\n        mock_file = MagicMock(spec=Path)\n        mock_file.is_file.return_value = True\n        mock_stat = MagicMock()\n        mock_stat.st_uid = os.getuid()\n        mock_file.stat.return_value = mock_stat\n        mock_file.unlink.side_effect = PermissionError('Permission denied')\n        mock_file.__str__.return_value = '/mock/file.txt'\n        \n        mock_directory = MagicMock(spec=Path)\n        mock_directory.rglob.return_value = [mock_file]\n        \n        delete_user_files(mock_directory)\n        mock_print.assert_called_once_with('Failed to delete /mock/file.txt: Permission denied')\n\n    def test_passing_file_as_directory(self):\n        # Test passing a file path as directory (should do nothing)\n        with tempfile.TemporaryDirectory() as temp_dir:\n            temp_dir = Path(temp_dir)\n            file_path = temp_dir / 'test.txt'\n            file_path.touch()\n            delete_user_files(file_path)\n            self.assertTrue(file_path.exists())\n\n    def test_non_existent_directory(self):\n        # Test passing a non-existent directory (should do nothing)\n        non_existent_dir = Path('/non_existent_dir_123456789')\n        delete_user_files(non_existent_dir)\n\n    def test_empty_directory(self):\n        # Test empty directory (no files to delete)\n        with tempfile.TemporaryDirectory() as temp_dir:\n            temp_dir = Path(temp_dir)\n            delete_user_files(temp_dir)\n            self.assertTrue(temp_dir.exists())\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 7, "task_id": "84ba1273"}
{"test": "import unittest\nimport os\nimport time\nfrom pathlib import Path\nfrom unittest.mock import patch, MagicMock\nimport tempfile\n\n# We assume the function delete_old_files is available\n\nclass TestDeleteOldFiles(unittest.TestCase):\n\n    def test_case_1(self):\n        # Happy path: two old files (deleted), one new (kept).\n        with tempfile.TemporaryDirectory() as temp_dir:\n            temp_path = Path(temp_dir)\n            with patch('time.time', return_value=1000000000.0):\n                days_old = 5\n                file1 = temp_path / 'file1.txt'\n                file1.touch()\n                os.utime(file1, (999567999, 999567999))\n                file2 = temp_path / 'file2.txt'\n                file2.touch()\n                os.utime(file2, (999567998, 999567998))\n                file3 = temp_path / 'file3.txt'\n                file3.touch()\n                os.utime(file3, (1000000000, 1000000000))\n                \n                delete_old_files(temp_path, days_old)\n                \n                self.assertFalse(file1.exists())\n                self.assertFalse(file2.exists())\n                self.assertTrue(file3.exists())\n    \n    def test_case_2(self):\n        # Skip files not owned by current user.\n        with tempfile.TemporaryDirectory() as temp_dir:\n            temp_path = Path(temp_dir)\n            file1 = temp_path / 'file1.txt'\n            file1.touch()\n            old_time = time.time() - (100 * 86400)\n            os.utime(file1, (old_time, old_time))\n            \n            mock_stat = MagicMock()\n            mock_stat.st_uid = 1001\n            mock_stat.st_mtime = old_time\n            \n            with patch('os.getuid', return_value=1000), patch.object(file1, 'stat', return_value=mock_stat):\n                delete_old_files(temp_path, 1)\n                \n            self.assertTrue(file1.exists())\n    \n    def test_case_3(self):\n        # Skip directories even if old and owned by current user.\n        with tempfile.TemporaryDirectory() as temp_dir:\n            temp_path = Path(temp_dir)\n            subdir = temp_path / 'subdir'\n            subdir.mkdir()\n            old_time = time.time() - (100 * 86400)\n            os.utime(subdir, (old_time, old_time))\n            \n            delete_old_files(temp_path, 1)\n            \n            self.assertTrue(subdir.exists())\n    \n    def test_case_4(self):\n        # Handle PermissionError by printing message.\n        with tempfile.TemporaryDirectory() as temp_dir:\n            temp_path = Path(temp_dir)\n            file1 = temp_path / 'file1.txt'\n            file1.touch()\n            old_time = time.time() - (100 * 86400)\n            os.utime(file1, (old_time, old_time))\n            \n            with patch.object(file1, 'unlink', side_effect=PermissionError('Permission denied')), \\\n                 patch('builtins.print') as mock_print:\n                delete_old_files(temp_path, 1)\n                mock_print.assert_called_once_with(f'Failed to delete {file1}: Permission denied')\n    \n    def test_case_5(self):\n        # Non-existent directory raises FileNotFoundError.\n        with tempfile.TemporaryDirectory() as temp_dir:\n            temp_path = Path(temp_dir)\n            os.rmdir(temp_path)\n            with self.assertRaises(FileNotFoundError):\n                delete_old_files(temp_path, 1)\n    \n    def test_case_6(self):\n        # Negative days_old: file modified now is deleted (cutoff in future).\n        with tempfile.TemporaryDirectory() as temp_dir:\n            temp_path = Path(temp_dir)\n            with patch('time.time', return_value=1000000000.0):\n                file1 = temp_path / 'file1.txt'\n                file1.touch()\n                os.utime(file1, (1000000000.0, 1000000000.0))\n                \n                delete_old_files(temp_path, -1)\n                \n                self.assertFalse(file1.exists())\n    \n    def test_case_7(self):\n        # Zero days_old: file modified 1 second ago deleted, file at current time kept.\n        with tempfile.TemporaryDirectory() as temp_dir:\n            temp_path = Path(temp_dir)\n            with patch('time.time', return_value=1000000000.0):\n                file1 = temp_path / 'file1.txt'\n                file1.touch()\n                os.utime(file1, (999999999, 999999999))\n                file2 = temp_path / 'file2.txt'\n                file2.touch()\n                os.utime(file2, (1000000000, 1000000000))\n                \n                delete_old_files(temp_path, 0)\n                \n                self.assertFalse(file1.exists())\n                self.assertTrue(file2.exists())\n    \n    def test_case_8(self):\n        # File with mtime exactly at cutoff is not deleted.\n        with tempfile.TemporaryDirectory() as temp_dir:\n            temp_path = Path(temp_dir)\n            with patch('time.time', return_value=1000000000.0):\n                days_old = 5\n                cutoff = 1000000000 - days_old * 86400\n                file1 = temp_path / 'file1.txt'\n                file1.touch()\n                os.utime(file1, (cutoff, cutoff))\n                \n                delete_old_files(temp_path, days_old)\n                \n                self.assertTrue(file1.exists())\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 8, "task_id": "039f3e81"}
{"test": "import unittest\nfrom unittest.mock import patch, MagicMock\nimport os\n\nclass TestSetFilePermissions(unittest.TestCase):\n    @patch('os.getuid')\n    def test_current_user_owner_success(self, mock_getuid):\n        # Test setting permissions when current user is owner (happy path)\n        mock_getuid.return_value = 1000\n        mock_file_path = MagicMock()\n        mock_file_path.stat.return_value.st_uid = 1000\n        result = set_file_permissions(mock_file_path, 0o644)\n        mock_file_path.chmod.assert_called_once_with(0o644)\n        self.assertIsNone(result)\n\n    @patch('os.getuid')\n    def test_current_user_not_owner(self, mock_getuid):\n        # Test no action when current user is not owner\n        mock_getuid.return_value = 1000\n        mock_file_path = MagicMock()\n        mock_file_path.stat.return_value.st_uid = 1001\n        result = set_file_permissions(mock_file_path, 0o644)\n        mock_file_path.chmod.assert_not_called()\n        self.assertIsNone(result)\n\n    @patch('os.getuid')\n    @patch('builtins.print')\n    def test_current_user_owner_permission_error(self, mock_print, mock_getuid):\n        # Test PermissionError handling during chmod\n        mock_getuid.return_value = 1000\n        mock_file_path = MagicMock()\n        mock_file_path.__str__.return_value = '/path/to/file'\n        mock_file_path.stat.return_value.st_uid = 1000\n        mock_file_path.chmod.side_effect = PermissionError('Permission denied')\n        result = set_file_permissions(mock_file_path, 0o644)\n        mock_file_path.chmod.assert_called_once_with(0o644)\n        mock_print.assert_called_once_with('Failed to change /path/to/file permission to 420: Permission denied')\n        self.assertIsNone(result)\n\n    def test_file_not_found(self):\n        # Test FileNotFoundError from stat()\n        mock_file_path = MagicMock()\n        mock_file_path.stat.side_effect = FileNotFoundError('File not found')\n        with self.assertRaises(FileNotFoundError):\n            set_file_permissions(mock_file_path, 0o644)\n\n    @patch('os.getuid')\n    def test_non_integer_permissions(self, mock_getuid):\n        # Test TypeError with non-integer permissions\n        mock_getuid.return_value = 1000\n        mock_file_path = MagicMock()\n        mock_file_path.stat.return_value.st_uid = 1000\n        with self.assertRaises(TypeError):\n            set_file_permissions(mock_file_path, '0o644')\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 5, "task_id": "5b962946"}
{"test": "import unittest\nimport os\nimport shutil\nimport tempfile\nfrom pathlib import Path\nfrom unittest.mock import patch, MagicMock\n\nclass TestSecureCopyFiles(unittest.TestCase):\n\n    def test_target_owned_one_file(self):\n        # Test copying a single file to a target directory owned by current user\n        with tempfile.TemporaryDirectory() as src_dir, tempfile.TemporaryDirectory() as tgt_dir:\n            src_path = Path(src_dir)\n            tgt_path = Path(tgt_dir)\n            \n            # Create a test file in source\n            test_file = src_path / \"test1.txt\"\n            test_file.touch()\n            \n            # Call the function\n            secure_copy_files(src_path, tgt_path)\n            \n            # Verify file was copied\n            self.assertTrue((tgt_path / \"test1.txt\").exists())\n\n    def test_target_owned_multiple_files(self):\n        # Test copying multiple files to a target directory owned by current user\n        with tempfile.TemporaryDirectory() as src_dir, tempfile.TemporaryDirectory() as tgt_dir:\n            src_path = Path(src_dir)\n            tgt_path = Path(tgt_dir)\n            \n            # Create multiple test files\n            files = [\"file1.txt\", \"file2.txt\", \"file3.txt\"]\n            for f in files:\n                (src_path / f).touch()\n            \n            secure_copy_files(src_path, tgt_path)\n            \n            # Verify all files were copied\n            for f in files:\n                self.assertTrue((tgt_path / f).exists())\n\n    def test_target_owned_empty_source(self):\n        # Test with an empty source directory (should do nothing without errors)\n        with tempfile.TemporaryDirectory() as src_dir, tempfile.TemporaryDirectory() as tgt_dir:\n            src_path = Path(src_dir)\n            tgt_path = Path(tgt_dir)\n            \n            # Ensure source is empty\n            self.assertEqual(len(list(src_path.iterdir())), 0)\n            \n            secure_copy_files(src_path, tgt_path)\n            \n            # Target should remain empty\n            self.assertEqual(len(list(tgt_path.iterdir())), 0)\n\n    def test_target_not_owned(self):\n        # Test when target directory is not owned by current user\n        with tempfile.TemporaryDirectory() as src_dir, tempfile.TemporaryDirectory() as tgt_dir:\n            src_path = Path(src_dir)\n            tgt_path = Path(tgt_dir)\n            \n            # Create a test file\n            (src_path / \"test.txt\").touch()\n            \n            # Mock ownership check\n            mock_stat = MagicMock()\n            mock_stat.st_uid = 1234  # Different from current user\n            \n            with patch.object(tgt_path, 'stat', return_value=mock_stat), \\\n                 patch('builtins.print') as mock_print, \\\n                 patch('shutil.copy') as mock_copy:\n                \n                secure_copy_files(src_path, tgt_path)\n                \n                # Verify print message and no copy attempted\n                mock_print.assert_called_once_with(f\"Target directory {tgt_path} is not owned by the current user.\")\n                mock_copy.assert_not_called()\n\n    def test_permission_error_during_copy(self):\n        # Test PermissionError during file copy operation\n        with tempfile.TemporaryDirectory() as src_dir, tempfile.TemporaryDirectory() as tgt_dir:\n            src_path = Path(src_dir)\n            tgt_path = Path(tgt_dir)\n            \n            # Create two test files\n            file1 = src_path / \"file1.txt\"\n            file2 = src_path / \"file2.txt\"\n            file1.touch()\n            file2.touch()\n            \n            # Mock shutil.copy to raise PermissionError on first file\n            with patch('shutil.copy') as mock_copy, \\\n                 patch('builtins.print') as mock_print:\n                \n                mock_copy.side_effect = PermissionError(\"Permission denied\")\n                secure_copy_files(src_path, tgt_path)\n                \n                # Verify error was printed and only one copy attempted\n                mock_print.assert_called_once_with(f\"Failed to copy {file1} to {tgt_path}: Permission denied\")\n                self.assertEqual(mock_copy.call_count, 1)\n                \n                # Verify no files were copied\n                self.assertEqual(len(list(tgt_path.iterdir())), 0)\n\n    def test_source_not_exist(self):\n        # Test when source directory does not exist\n        with tempfile.TemporaryDirectory() as base_dir:\n            src_path = Path(base_dir) / \"non_existent_source\"\n            tgt_path = Path(base_dir) / \"target\"\n            tgt_path.mkdir()\n            \n            with self.assertRaises(FileNotFoundError):\n                secure_copy_files(src_path, tgt_path)\n\n    def test_target_not_exist(self):\n        # Test when target directory does not exist\n        with tempfile.TemporaryDirectory() as base_dir:\n            src_path = Path(base_dir) / \"source\"\n            src_path.mkdir()\n            tgt_path = Path(base_dir) / \"non_existent_target\"\n            \n            with self.assertRaises(FileNotFoundError):\n                secure_copy_files(src_path, tgt_path)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 7, "task_id": "bc4bce88"}
{"test": "import unittest\nimport os\nfrom pathlib import Path\nfrom unittest.mock import MagicMock, patch\n\nclass TestChangeDirectoryPermissionsUp(unittest.TestCase):\n\n    @patch('os.getuid')\n    def test_happy_path(self, mock_getuid):\n        # Test changing permissions for a chain of three owned directories\n        mock_getuid.return_value = 1000\n        \n        leaf = MagicMock(spec=Path)\n        middle = MagicMock(spec=Path)\n        root = MagicMock(spec=Path)\n        \n        leaf.parent = middle\n        middle.parent = root\n        root.parent = root  # Root's parent is itself\n        \n        leaf_stat = MagicMock()\n        leaf_stat.st_uid = 1000\n        leaf_stat.st_mode = 0o700\n        leaf.stat.return_value = leaf_stat\n        \n        middle_stat = MagicMock()\n        middle_stat.st_uid = 1000\n        middle_stat.st_mode = 0o700\n        middle.stat.return_value = middle_stat\n        \n        root_stat = MagicMock()\n        root_stat.st_uid = 1000\n        root_stat.st_mode = 0o700\n        root.stat.return_value = root_stat\n        \n        change_directory_permissions_up(leaf, 0o755)\n        \n        leaf.chmod.assert_called_once_with(0o755)\n        middle.chmod.assert_called_once_with(0o755)\n        root.chmod.assert_called_once_with(0o755)\n\n    @patch('os.getuid')\n    def test_non_owned_in_middle(self, mock_getuid):\n        # Test stopping at non-owned directory in the middle\n        mock_getuid.return_value = 1000\n        \n        leaf = MagicMock(spec=Path)\n        middle = MagicMock(spec=Path)\n        \n        leaf.parent = middle\n        middle.parent = MagicMock(spec=Path)  # Not accessed in test\n        \n        leaf_stat = MagicMock()\n        leaf_stat.st_uid = 1000\n        leaf_stat.st_mode = 0o700\n        leaf.stat.return_value = leaf_stat\n        \n        middle_stat = MagicMock()\n        middle_stat.st_uid = 1001  # Not owned\n        middle.stat.return_value = middle_stat\n        \n        change_directory_permissions_up(leaf, 0o755)\n        \n        leaf.chmod.assert_called_once_with(0o755)\n        middle.chmod.assert_not_called()\n        middle.parent.stat.assert_not_called()\n\n    @patch('os.getuid')\n    def test_root_directory(self, mock_getuid):\n        # Test root directory (parent equals itself)\n        mock_getuid.return_value = 1000\n        \n        root = MagicMock(spec=Path)\n        root.parent = root\n        \n        root_stat = MagicMock()\n        root_stat.st_uid = 1000\n        root_stat.st_mode = 0o700\n        root.stat.return_value = root_stat\n        \n        change_directory_permissions_up(root, 0o755)\n        \n        root.chmod.assert_called_once_with(0o755)\n\n    @patch('os.getuid')\n    def test_permissions_already_set(self, mock_getuid):\n        # Test directories where permissions are already set\n        mock_getuid.return_value = 1000\n        \n        leaf = MagicMock(spec=Path)\n        middle = MagicMock(spec=Path)\n        root = MagicMock(spec=Path)\n        \n        leaf.parent = middle\n        middle.parent = root\n        root.parent = root\n        \n        leaf_stat = MagicMock()\n        leaf_stat.st_uid = 1000\n        leaf_stat.st_mode = 0o755  # Already set\n        leaf.stat.return_value = leaf_stat\n        \n        middle_stat = MagicMock()\n        middle_stat.st_uid = 1000\n        middle_stat.st_mode = 0o700  # Not set\n        middle.stat.return_value = middle_stat\n        \n        root_stat = MagicMock()\n        root_stat.st_uid = 1000\n        root_stat.st_mode = 0o755  # Already set\n        root.stat.return_value = root_stat\n        \n        change_directory_permissions_up(leaf, 0o755)\n        \n        leaf.chmod.assert_not_called()\n        middle.chmod.assert_called_once_with(0o755)\n        root.chmod.assert_not_called()\n\n    @patch('os.getuid')\n    @patch('builtins.print')\n    def test_permission_error(self, mock_print, mock_getuid):\n        # Test handling PermissionError for an owned directory\n        mock_getuid.return_value = 1000\n        \n        leaf = MagicMock(spec=Path)\n        leaf.parent = MagicMock(spec=Path)  # Not accessed\n        \n        leaf_stat = MagicMock()\n        leaf_stat.st_uid = 1000\n        leaf_stat.st_mode = 0o700\n        leaf.stat.return_value = leaf_stat\n        \n        leaf.chmod.side_effect = PermissionError('Operation not permitted')\n        \n        change_directory_permissions_up(leaf, 0o755)\n        \n        leaf.chmod.assert_called_once_with(0o755)\n        mock_print.assert_called_once_with(f'Failed to change {leaf} permission to 0o755: Operation not permitted')\n        leaf.parent.stat.assert_not_called()\n\n    @patch('os.getuid')\n    def test_nonexistent_directory(self, mock_getuid):\n        # Test non-existent directory (raises FileNotFoundError)\n        mock_getuid.return_value = 1000\n        \n        directory = MagicMock(spec=Path)\n        directory.stat.side_effect = FileNotFoundError\n        \n        with self.assertRaises(FileNotFoundError):\n            change_directory_permissions_up(directory, 0o755)\n\n    @patch('os.getuid')\n    def test_starting_directory_not_owned(self, mock_getuid):\n        # Test starting with a non-owned directory (no changes)\n        mock_getuid.return_value = 1000\n        \n        leaf = MagicMock(spec=Path)\n        leaf.parent = MagicMock(spec=Path)\n        \n        leaf_stat = MagicMock()\n        leaf_stat.st_uid = 1001  # Not owned\n        leaf.stat.return_value = leaf_stat\n        \n        change_directory_permissions_up(leaf, 0o755)\n        \n        leaf.chmod.assert_not_called()\n        leaf.parent.stat.assert_not_called()\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 7, "task_id": "7165233b"}
{"test": "import unittest\nfrom unittest.mock import patch, MagicMock\nimport smtplib\nimport ssl\n\nclass TestSendSecureEmail(unittest.TestCase):\n\n    @patch('ssl.create_default_context')\n    @patch('smtplib.SMTP')\n    def test_successful_send(self, mock_smtp, mock_context):\n        # Test successful email sending with valid parameters\n        mock_server = mock_smtp.return_value\n        mock_context.return_value = MagicMock()\n        \n        send_secure_email(\n            mail_server='smtp.example.com',\n            server_port=587,\n            from_address='sender@example.com',\n            to_address='receiver@example.com',\n            user_password='password123',\n            email_content='Hello, this is a test email.'\n        )\n        \n        mock_smtp.assert_called_once_with('smtp.example.com', 587)\n        mock_server.starttls.assert_called_once_with(context=mock_context.return_value)\n        mock_server.login.assert_called_once_with('sender@example.com', 'password123')\n        mock_server.send_message.assert_called_once()\n        mock_server.quit.assert_called_once()\n\n    @patch('ssl.create_default_context')\n    @patch('smtplib.SMTP')\n    def test_authentication_failure(self, mock_smtp, mock_context):\n        # Test invalid credentials raise SMTPAuthenticationError\n        mock_server = mock_smtp.return_value\n        mock_context.return_value = MagicMock()\n        mock_server.login.side_effect = smtplib.SMTPAuthenticationError(535, b'Invalid credentials')\n        \n        with self.assertRaises(smtplib.SMTPAuthenticationError):\n            send_secure_email(\n                mail_server='smtp.example.com',\n                server_port=587,\n                from_address='sender@example.com',\n                to_address='receiver@example.com',\n                user_password='wrong_password',\n                email_content='Test content'\n            )\n        \n        mock_server.quit.assert_called_once()\n\n    @patch('ssl.create_default_context')\n    @patch('smtplib.SMTP')\n    def test_ssl_error(self, mock_smtp, mock_context):\n        # Test SSL certificate validation failure\n        mock_server = mock_smtp.return_value\n        mock_context.return_value = MagicMock()\n        mock_server.starttls.side_effect = ssl.SSLError(\"Certificate verification failed\")\n        \n        with self.assertRaises(ssl.SSLError):\n            send_secure_email(\n                mail_server='smtp.example.com',\n                server_port=587,\n                from_address='sender@example.com',\n                to_address='receiver@example.com',\n                user_password='password123',\n                email_content='Test content'\n            )\n        \n        mock_server.quit.assert_called_once()\n\n    @patch('ssl.create_default_context')\n    @patch('smtplib.SMTP')\n    def test_smtp_exception_general(self, mock_smtp, mock_context):\n        # Test general SMTPException during email sending\n        mock_server = mock_smtp.return_value\n        mock_context.return_value = MagicMock()\n        mock_server.send_message.side_effect = smtplib.SMTPException(\"Server unavailable\")\n        \n        with self.assertRaises(smtplib.SMTPException):\n            send_secure_email(\n                mail_server='smtp.example.com',\n                server_port=587,\n                from_address='sender@example.com',\n                to_address='receiver@example.com',\n                user_password='password123',\n                email_content='Test content'\n            )\n        \n        mock_server.quit.assert_called_once()\n\n    @patch('ssl.create_default_context')\n    @patch('smtplib.SMTP')\n    def test_empty_email_content(self, mock_smtp, mock_context):\n        # Test sending an email with empty content\n        mock_server = mock_smtp.return_value\n        mock_context.return_value = MagicMock()\n        \n        send_secure_email(\n            mail_server='smtp.example.com',\n            server_port=587,\n            from_address='sender@example.com',\n            to_address='receiver@example.com',\n            user_password='password123',\n            email_content=''\n        )\n        \n        mock_server.send_message.assert_called_once()\n        mock_server.quit.assert_called_once()\n\n    @patch('ssl.create_default_context')\n    @patch('smtplib.SMTP')\n    def test_invalid_port_negative(self, mock_smtp, mock_context):\n        # Test invalid negative port number\n        mock_server = mock_smtp.return_value\n        mock_context.return_value = MagicMock()\n        \n        with self.assertRaises(smtplib.SMTPException):\n            send_secure_email(\n                mail_server='smtp.example.com',\n                server_port=-465,\n                from_address='sender@example.com',\n                to_address='receiver@example.com',\n                user_password='password123',\n                email_content='Test content'\n            )\n\n    @patch('ssl.create_default_context')\n    @patch('smtplib.SMTP')\n    def test_large_port_number(self, mock_smtp, mock_context):\n        # Test very large port number (out of valid range)\n        mock_server = mock_smtp.return_value\n        mock_context.return_value = MagicMock()\n        \n        with self.assertRaises(smtplib.SMTPException):\n            send_secure_email(\n                mail_server='smtp.example.com',\n                server_port=99999,\n                from_address='sender@example.com',\n                to_address='receiver@example.com',\n                user_password='password123',\n                email_content='Test content'\n            )\n\n    @patch('ssl.create_default_context')\n    @patch('smtplib.SMTP')\n    def test_empty_credentials(self, mock_smtp, mock_context):\n        # Test empty username/password\n        mock_server = mock_smtp.return_value\n        mock_context.return_value = MagicMock()\n        mock_server.login.side_effect = smtplib.SMTPAuthenticationError(535, b'Empty credentials')\n        \n        with self.assertRaises(smtplib.SMTPAuthenticationError):\n            send_secure_email(\n                mail_server='smtp.example.com',\n                server_port=587,\n                from_address='',\n                to_address='receiver@example.com',\n                user_password='',\n                email_content='Test content'\n            )\n        \n        mock_server.quit.assert_called_once()\n\n    @patch('ssl.create_default_context')\n    @patch('smtplib.SMTP')\n    def test_long_email_content(self, mock_smtp, mock_context):\n        # Test very long email content\n        mock_server = mock_smtp.return_value\n        mock_context.return_value = MagicMock()\n        long_content = 'A' * 10000\n        \n        send_secure_email(\n            mail_server='smtp.example.com',\n            server_port=587,\n            from_address='sender@example.com',\n            to_address='receiver@example.com',\n            user_password='password123',\n            email_content=long_content\n        )\n        \n        mock_server.send_message.assert_called_once()\n        mock_server.quit.assert_called_once()\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 9, "task_id": "f31b588a"}
{"test": "import unittest\nfrom unittest.mock import patch, ANY, MagicMock\nimport smtplib\nimport ssl\nfrom solution import tls_email_sender\n\nclass TestTlsEmailSender(unittest.TestCase):\n    @patch('smtplib.SMTP')\n    @patch('email.message.EmailMessage')\n    @patch('builtins.print')\n    def test_successful_send(self, mock_print, mock_email_class, mock_smtp_class):\n        \"\"\"Test sending an email with valid parameters.\"\"\"\n        mock_server = mock_smtp_class.return_value\n        mock_server.starttls.return_value = None\n        mock_server.login.return_value = None\n        mock_server.send_message.return_value = None\n        mock_server.quit.return_value = None\n        mock_email = mock_email_class.return_value\n        \n        tls_email_sender('smtp.example.com', 587, 'sender@example.com', 'recipient@example.com', 'password', 'Test message')\n        \n        mock_smtp_class.assert_called_once_with('smtp.example.com', 587)\n        mock_server.starttls.assert_called_once_with(context=ANY)\n        mock_server.login.assert_called_once_with('sender@example.com', 'password')\n        mock_email_class.assert_called_once()\n        mock_email.__setitem__.assert_any_call('Subject', 'Test Email')\n        mock_email.__setitem__.assert_any_call('From', 'sender@example.com')\n        mock_email.__setitem__.assert_any_call('To', 'recipient@example.com')\n        mock_email.set_content.assert_called_once_with('Test message')\n        mock_server.send_message.assert_called_once_with(mock_email)\n        mock_server.quit.assert_called_once()\n        mock_print.assert_called_once_with('Email sent successfully')\n\n    @patch('smtplib.SMTP')\n    @patch('email.message.EmailMessage')\n    def test_invalid_credentials(self, mock_email_class, mock_smtp_class):\n        \"\"\"Test authentication failure with invalid credentials.\"\"\"\n        mock_server = mock_smtp_class.return_value\n        mock_server.login.side_effect = smtplib.SMTPAuthenticationError(535, b'Invalid credentials')\n        \n        with self.assertRaises(smtplib.SMTPAuthenticationError):\n            tls_email_sender('smtp.example.com', 587, 'user@invalid', 'recipient@example.com', 'wrongpass', 'Message')\n        \n        mock_server.quit.assert_called_once()\n\n    @patch('smtplib.SMTP')\n    @patch('email.message.EmailMessage')\n    def test_ssl_error(self, mock_email_class, mock_smtp_class):\n        \"\"\"Test SSL certificate validation failure.\"\"\"\n        mock_server = mock_smtp_class.return_value\n        mock_server.starttls.side_effect = ssl.SSLError(\"Certificate verify failed\")\n        \n        with self.assertRaises(ssl.SSLError):\n            tls_email_sender('smtp.example.com', 587, 'sender@example.com', 'recipient@example.com', 'password', 'Hello')\n        \n        mock_server.quit.assert_called_once()\n\n    @patch('smtplib.SMTP')\n    @patch('email.message.EmailMessage')\n    def test_smtp_exception_during_login(self, mock_email_class, mock_smtp_class):\n        \"\"\"Test general SMTP error during login.\"\"\"\n        mock_server = mock_smtp_class.return_value\n        mock_server.login.side_effect = smtplib.SMTPException(\"Login error\")\n        \n        with self.assertRaises(smtplib.SMTPException):\n            tls_email_sender('smtp.example.com', 587, 'user', 'recipient', 'pass', 'Content')\n        \n        mock_server.quit.assert_called_once()\n\n    @patch('smtplib.SMTP')\n    @patch('email.message.EmailMessage')\n    @patch('builtins.print')\n    def test_smtp_exception_during_send(self, mock_print, mock_email_class, mock_smtp_class):\n        \"\"\"Test general SMTP error during message sending.\"\"\"\n        mock_server = mock_smtp_class.return_value\n        mock_server.login.return_value = None\n        mock_server.send_message.side_effect = smtplib.SMTPException(\"Sending failed\")\n        \n        with self.assertRaises(smtplib.SMTPException):\n            tls_email_sender('smtp.example.com', 587, 'user', 'recipient', 'pass', 'Body')\n        \n        mock_server.quit.assert_called_once()\n        mock_print.assert_not_called()\n\n    @patch('smtplib.SMTP')\n    @patch('email.message.EmailMessage')\n    @patch('builtins.print')\n    def test_empty_mail_body(self, mock_print, mock_email_class, mock_smtp_class):\n        \"\"\"Test sending an email with an empty body.\"\"\"\n        mock_server = mock_smtp_class.return_value\n        mock_server.starttls.return_value = None\n        mock_server.login.return_value = None\n        mock_server.send_message.return_value = None\n        mock_server.quit.return_value = None\n        mock_email = mock_email_class.return_value\n        \n        tls_email_sender('smtp.example.com', 587, 'sender@example.com', 'recipient@example.com', 'password', '')\n        \n        mock_email.set_content.assert_called_once_with('')\n        mock_server.quit.assert_called_once()\n        mock_print.assert_called_once_with('Email sent successfully')\n\n    def test_non_integer_port(self):\n        \"\"\"Test passing a non-integer port which should raise TypeError.\"\"\"\n        with self.assertRaises(TypeError):\n            tls_email_sender('smtp.example.com', 'invalid_port', 'sender@example.com', 'recipient@example.com', 'password', 'Hello')\n\n    @patch('smtplib.SMTP')\n    @patch('email.message.EmailMessage')\n    def test_very_long_mail_body(self, mock_email_class, mock_smtp_class):\n        \"\"\"Test sending an email with a very long body.\"\"\"\n        mock_server = mock_smtp_class.return_value\n        mock_server.starttls.return_value = None\n        mock_server.login.return_value = None\n        mock_server.send_message.return_value = None\n        mock_server.quit.return_value = None\n        mock_email = mock_email_class.return_value\n        long_body = 'A' * 10000\n        \n        tls_email_sender('smtp.example.com', 587, 'sender@example.com', 'recipient@example.com', 'password', long_body)\n        \n        mock_email.set_content.assert_called_once_with(long_body)\n        mock_server.quit.assert_called_once()\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 8, "task_id": "bfb4859a"}
{"test": "import unittest\nfrom unittest.mock import patch, MagicMock, ANY\nimport smtplib\nimport ssl\n\nclass TestEmailViaTLS(unittest.TestCase):\n\n    @patch('smtplib.SMTP')\n    def test_successful_send(self, mock_smtp):\n        \"\"\"Test successful email sending with valid parameters.\"\"\"\n        mock_server = mock_smtp.return_value\n        email_via_tls('smtp.example.com', 587, 'sender@test.com', 'recipient@test.com', 'pass123', 'Test message')\n        mock_smtp.assert_called_once_with('smtp.example.com', 587)\n        mock_server.starttls.assert_called_once_with(context=ANY)\n        mock_server.login.assert_called_once_with('sender@test.com', 'pass123')\n        self.assertEqual(mock_server.send_message.call_count, 1)\n        mock_server.quit.assert_called_once()\n\n    @patch('smtplib.SMTP')\n    def test_invalid_credentials(self, mock_smtp):\n        \"\"\"Test authentication failure with invalid credentials.\"\"\"\n        mock_server = mock_smtp.return_value\n        mock_server.login.side_effect = smtplib.SMTPAuthenticationError(535, b'Invalid credentials')\n        with self.assertRaises(smtplib.SMTPAuthenticationError) as context:\n            email_via_tls('smtp.example.com', 587, 'user@test.com', 'recipient@test.com', 'wrongpass', 'Hello')\n        self.assertIn('Authentication failed', str(context.exception))\n        mock_server.quit.assert_called_once()\n\n    @patch('smtplib.SMTP')\n    def test_ssl_error(self, mock_smtp):\n        \"\"\"Test SSL certificate validation failure during connection.\"\"\"\n        mock_server = mock_smtp.return_value\n        mock_server.starttls.side_effect = ssl.SSLError(\"Certificate verification failed\")\n        with self.assertRaises(ssl.SSLError) as context:\n            email_via_tls('smtp.example.com', 587, 'user@test.com', 'recipient@test.com', 'password', 'Test')\n        self.assertIn('SSL error', str(context.exception))\n        mock_server.quit.assert_called_once()\n\n    @patch('smtplib.SMTP')\n    def test_smtp_exception_during_send(self, mock_smtp):\n        \"\"\"Test general SMTP failure during email transmission.\"\"\"\n        mock_server = mock_smtp.return_value\n        mock_server.send_message.side_effect = smtplib.SMTPException(\"Send failure\")\n        with self.assertRaises(smtplib.SMTPException) as context:\n            email_via_tls('smtp.example.com', 587, 'user@test.com', 'recipient@test.com', 'password', 'Test')\n        self.assertIn('SMTP error occurred', str(context.exception))\n        mock_server.quit.assert_called_once()\n\n    @patch('smtplib.SMTP')\n    def test_empty_message_body(self, mock_smtp):\n        \"\"\"Test sending an email with an empty message body.\"\"\"\n        mock_server = mock_smtp.return_value\n        email_via_tls('smtp.example.com', 587, 'sender@test.com', 'recipient@test.com', 'pass123', '')\n        args, _ = mock_server.send_message.call_args\n        sent_email = args[0]\n        self.assertEqual(sent_email.get_content(), '')\n        mock_server.quit.assert_called_once()\n\n    @patch('smtplib.SMTP')\n    def test_non_integer_port(self, mock_smtp):\n        \"\"\"Test passing a non-integer port which should raise TypeError.\"\"\"\n        with self.assertRaises(TypeError):\n            email_via_tls('smtp.example.com', '587', 'user@test.com', 'recipient@test.com', 'pass', 'Test')\n\n    @patch('smtplib.SMTP')\n    def test_long_message(self, mock_smtp):\n        \"\"\"Test sending a very long email message body.\"\"\"\n        mock_server = mock_smtp.return_value\n        long_msg = 'A' * 10000\n        email_via_tls('smtp.example.com', 587, 'user@test.com', 'recipient@test.com', 'password', long_msg)\n        args, _ = mock_server.send_message.call_args\n        sent_email = args[0]\n        self.assertEqual(sent_email.get_content(), long_msg)\n        mock_server.quit.assert_called_once()\n\n    @patch('smtplib.SMTP')\n    def test_empty_host(self, mock_smtp):\n        \"\"\"Test with an empty SMTP host string.\"\"\"\n        mock_server = mock_smtp.return_value\n        email_via_tls('', 587, 'user@test.com', 'recipient@test.com', 'pass123', 'Test')\n        mock_smtp.assert_called_once_with('', 587)\n        mock_server.quit.assert_called_once()\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 8, "task_id": "8c888d6d"}
{"test": "import unittest\nimport smtplib\nimport ssl\nfrom email.message import EmailMessage\nfrom unittest.mock import patch\n\nclass TestSecureTlsEmail(unittest.TestCase):\n\n    def test_successful_send(self):\n        # Test successful email sending with valid parameters\n        with patch('smtplib.SMTP') as mock_smtp, \\\n             patch('ssl.create_default_context') as mock_context, \\\n             patch('builtins.print') as mock_print:\n            mock_server = mock_smtp.return_value\n            secure_tls_email('smtp.example.com', 587, 'sender@test.com', 'recipient@test.com', 'pass123', 'Test content')\n            mock_smtp.assert_called_once_with('smtp.example.com', 587)\n            mock_server.starttls.assert_called_once_with(context=mock_context.return_value)\n            mock_server.login.assert_called_once_with('sender@test.com', 'pass123')\n            mock_server.send_message.assert_called_once()\n            sent_email = mock_server.send_message.call_args[0][0]\n            self.assertEqual(sent_email['Subject'], 'Test Email')\n            self.assertEqual(sent_email['From'], 'sender@test.com')\n            self.assertEqual(sent_email['To'], 'recipient@test.com')\n            self.assertEqual(sent_email.get_content(), 'Test content')\n            mock_server.quit.assert_called_once()\n            mock_print.assert_called_once_with('Email sent successfully')\n\n    def test_authentication_failure(self):\n        # Test invalid credentials raising SMTPAuthenticationError\n        with patch('smtplib.SMTP') as mock_smtp, \\\n             patch('ssl.create_default_context') as mock_context:\n            mock_server = mock_smtp.return_value\n            mock_server.login.side_effect = smtplib.SMTPAuthenticationError(535, b'Bad credentials')\n            with self.assertRaises(smtplib.SMTPAuthenticationError) as context:\n                secure_tls_email('smtp.example.com', 587, 'user@test.com', 'to@test.com', 'wrongpass', 'Content')\n            self.assertIn('Authentication failed', str(context.exception))\n            mock_server.login.assert_called_once_with('user@test.com', 'wrongpass')\n            mock_server.quit.assert_called_once()\n\n    def test_ssl_error(self):\n        # Test SSL certificate failure raising SSLError\n        with patch('smtplib.SMTP') as mock_smtp, \\\n             patch('ssl.create_default_context') as mock_context:\n            mock_server = mock_smtp.return_value\n            mock_server.starttls.side_effect = ssl.SSLError(\"Certificate verify failed\")\n            with self.assertRaises(ssl.SSLError) as context:\n                secure_tls_email('invalid.host', 587, 'user@test.com', 'to@test.com', 'pass', 'Content')\n            self.assertIn('SSL error', str(context.exception))\n            mock_server.starttls.assert_called_once_with(context=mock_context.return_value)\n            mock_server.quit.assert_called_once()\n            mock_server.login.assert_not_called()\n\n    def test_smtp_exception_during_login(self):\n        # Test SMTPException during login\n        with patch('smtplib.SMTP') as mock_smtp, \\\n             patch('ssl.create_default_context') as mock_context:\n            mock_server = mock_smtp.return_value\n            mock_server.login.side_effect = smtplib.SMTPException(\"Login error\")\n            with self.assertRaises(smtplib.SMTPException) as context:\n                secure_tls_email('smtp.example.com', 587, 'user@test.com', 'to@test.com', 'pass', 'Content')\n            self.assertEqual(str(context.exception), \"SMTP error occurred: Login error\")\n            mock_server.login.assert_called_once()\n            mock_server.quit.assert_called_once()\n\n    def test_smtp_exception_during_send(self):\n        # Test SMTPException during message sending\n        with patch('smtplib.SMTP') as mock_smtp, \\\n             patch('ssl.create_default_context') as mock_context:\n            mock_server = mock_smtp.return_value\n            mock_server.send_message.side_effect = smtplib.SMTPException(\"Send error\")\n            with self.assertRaises(smtplib.SMTPException) as context:\n                secure_tls_email('smtp.example.com', 587, 'user@test.com', 'to@test.com', 'pass', 'Content')\n            self.assertEqual(str(context.exception), \"SMTP error occurred: Send error\")\n            mock_server.send_message.assert_called_once()\n            mock_server.quit.assert_called_once()\n\n    def test_empty_content(self):\n        # Test sending email with empty content\n        with patch('smtplib.SMTP') as mock_smtp, \\\n             patch('ssl.create_default_context') as mock_context, \\\n             patch('builtins.print') as mock_print:\n            mock_server = mock_smtp.return_value\n            secure_tls_email('smtp.example.com', 587, 'sender@test.com', 'recipient@test.com', 'pass123', '')\n            sent_email = mock_server.send_message.call_args[0][0]\n            self.assertEqual(sent_email.get_content(), '')\n            mock_server.quit.assert_called_once()\n            mock_print.assert_called_once_with('Email sent successfully')\n\n    def test_long_content(self):\n        # Test sending email with very long content\n        long_content = 'A' * 10000\n        with patch('smtplib.SMTP') as mock_smtp, \\\n             patch('ssl.create_default_context') as mock_context, \\\n             patch('builtins.print') as mock_print:\n            mock_server = mock_smtp.return_value\n            secure_tls_email('smtp.example.com', 587, 'sender@test.com', 'recipient@test.com', 'pass123', long_content)\n            sent_email = mock_server.send_message.call_args[0][0]\n            self.assertEqual(sent_email.get_content(), long_content)\n            mock_server.quit.assert_called_once()\n            mock_print.assert_called_once_with('Email sent successfully')\n\n    def test_non_string_inputs(self):\n        # Test non-string inputs raising appropriate exceptions\n        with self.assertRaises((TypeError, AttributeError)):\n            secure_tls_email(123, 587, 'sender@test.com', 'recipient@test.com', 'pass', 'Content')\n        with self.assertRaises((TypeError, AttributeError)):\n            secure_tls_email('smtp.example.com', '587', 'sender@test.com', 'recipient@test.com', 'pass', 'Content')\n        with self.assertRaises((TypeError, AttributeError)):\n            secure_tls_email('smtp.example.com', 587, 123, 'recipient@test.com', 'pass', 'Content')\n        with self.assertRaises((TypeError, AttributeError)):\n            secure_tls_email('smtp.example.com', 587, 'sender@test.com', 123, 'pass', 'Content')\n        with self.assertRaises((TypeError, AttributeError)):\n            secure_tls_email('smtp.example.com', 587, 'sender@test.com', 'recipient@test.com', 123, 'Content')\n        with self.assertRaises((TypeError, AttributeError)):\n            secure_tls_email('smtp.example.com', 587, 'sender@test.com', 'recipient@test.com', 'pass', 123)\n\n    def test_invalid_port(self):\n        # Test invalid port numbers\n        with self.assertRaises(ValueError):\n            secure_tls_email('smtp.example.com', -1, 'a@test.com', 'b@test.com', 'pass', 'Content')\n        with self.assertRaises(ValueError):\n            secure_tls_email('smtp.example.com', 0, 'a@test.com', 'b@test.com', 'pass', 'Content')\n        with self.assertRaises(OverflowError):\n            secure_tls_email('smtp.example.com', 70000, 'a@test.com', 'b@test.com', 'pass', 'Content')\n\n    def test_empty_credentials(self):\n        # Test empty email credentials\n        with patch('smtplib.SMTP') as mock_smtp, \\\n             patch('ssl.create_default_context') as mock_context:\n            mock_server = mock_smtp.return_value\n            with self.assertRaises(smtplib.SMTPAuthenticationError):\n                secure_tls_email('smtp.example.com', 587, '', 'to@test.com', '', 'Content')\n            mock_server.quit.assert_called_once()\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 10, "task_id": "696ae82f"}
{"test": "import unittest\nfrom unittest.mock import patch, ANY\nimport smtplib\nimport ssl\nfrom email.message import EmailMessage\n\nclass TestSmtpTlsSecureSend(unittest.TestCase):\n\n    @patch('smtplib.SMTP')\n    def test_case_1_success(self, mock_smtp):\n        # Test successful email sending with valid credentials and message\n        mock_server = mock_smtp.return_value\n        from_email = 'sender@example.com'\n        to_email = 'receiver@example.com'\n        email_pass = 'secure_password'\n        email_msg = 'This is a test email content.'\n        smtp_host = 'smtp.example.com'\n        smtp_port = 587\n        \n        with patch('builtins.print') as mock_print:\n            smtp_tls_secure_send(smtp_host, smtp_port, from_email, to_email, email_pass, email_msg)\n            mock_print.assert_called_once_with('Email sent successfully')\n        \n        mock_smtp.assert_called_once_with(smtp_host, smtp_port)\n        mock_server.starttls.assert_called_once_with(context=ANY)\n        mock_server.login.assert_called_once_with(from_email, email_pass)\n        args, _ = mock_server.send_message.call_args\n        email_sent = args[0]\n        self.assertIsInstance(email_sent, EmailMessage)\n        self.assertEqual(email_sent['Subject'], 'Test Email')\n        self.assertEqual(email_sent['From'], from_email)\n        self.assertEqual(email_sent['To'], to_email)\n        self.assertEqual(email_sent.get_content(), email_msg)\n        mock_server.quit.assert_called_once()\n\n    @patch('smtplib.SMTP')\n    def test_case_2_auth_failure(self, mock_smtp):\n        # Test authentication failure with invalid credentials\n        mock_server = mock_smtp.return_value\n        mock_server.login.side_effect = smtplib.SMTPAuthenticationError(535, b'Authentication failed')\n        \n        with self.assertRaises(smtplib.SMTPAuthenticationError):\n            smtp_tls_secure_send('smtp.example.com', 587, 'user@example.com', 'recipient@example.com', 'wrong_password', 'message')\n        \n        mock_server.quit.assert_called_once()\n\n    @patch('smtplib.SMTP')\n    def test_case_3_ssl_error(self, mock_smtp):\n        # Test SSL certificate verification failure during TLS handshake\n        mock_server = mock_smtp.return_value\n        mock_server.starttls.side_effect = ssl.SSLError(\"Certificate verify failed\")\n        \n        with self.assertRaises(ssl.SSLError):\n            smtp_tls_secure_send('smtp.example.com', 587, 'user@example.com', 'recipient@example.com', 'password', 'message')\n        \n        mock_server.quit.assert_called_once()\n\n    @patch('smtplib.SMTP')\n    def test_case_4_smtp_exception_in_send(self, mock_smtp):\n        # Test SMTPException during email sending\n        mock_server = mock_smtp.return_value\n        mock_server.send_message.side_effect = smtplib.SMTPException(\"Sending failed\")\n        \n        with self.assertRaises(smtplib.SMTPException):\n            smtp_tls_secure_send('smtp.example.com', 587, 'user@example.com', 'recipient@example.com', 'password', 'message')\n        \n        mock_server.quit.assert_called_once()\n\n    @patch('smtplib.SMTP')\n    def test_case_5_empty_body(self, mock_smtp):\n        # Test sending email with empty body content\n        mock_server = mock_smtp.return_value\n        smtp_tls_secure_send('smtp.example.com', 587, 'sender@example.com', 'receiver@example.com', 'pass', '')\n        \n        args, _ = mock_server.send_message.call_args\n        email_sent = args[0]\n        self.assertEqual(email_sent.get_content(), '')\n\n    @patch('smtplib.SMTP')\n    def test_case_6_long_body(self, mock_smtp):\n        # Test sending email with very long body content\n        mock_server = mock_smtp.return_value\n        long_msg = 'A' * 10000\n        smtp_tls_secure_send('smtp.example.com', 587, 'sender@example.com', 'receiver@example.com', 'pass', long_msg)\n        \n        args, _ = mock_server.send_message.call_args\n        email_sent = args[0]\n        self.assertEqual(email_sent.get_content(), long_msg)\n\n    @patch('smtplib.SMTP')\n    def test_case_7_non_integer_port(self, mock_smtp):\n        # Test non-integer port value causing TypeError\n        mock_smtp.side_effect = TypeError(\"Port must be integer\")\n        \n        with self.assertRaises(TypeError):\n            smtp_tls_secure_send('smtp.example.com', 'invalid_port', 'user@example.com', 'recipient@example.com', 'pass', 'message')\n        \n        mock_smtp.assert_called_once_with('smtp.example.com', 'invalid_port')\n\n    @patch('smtplib.SMTP')\n    def test_case_8_empty_host(self, mock_smtp):\n        # Test empty host string causing connection failure\n        mock_smtp.side_effect = smtplib.SMTPException(\"Invalid host\")\n        \n        with self.assertRaises(smtplib.SMTPException):\n            smtp_tls_secure_send('', 587, 'user@example.com', 'recipient@example.com', 'pass', 'message')\n        \n        mock_smtp.assert_called_once_with('', 587)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 8, "task_id": "0c9ba2a0"}
{"test": "import unittest\nfrom unittest.mock import patch, MagicMock\nimport smtplib\nimport ssl\n\nclass TestTlsSecureEmail(unittest.TestCase):\n\n    def test_happy_path(self):\n        \"\"\"Test successful email sending with valid parameters.\"\"\"\n        with patch('smtplib.SMTP') as mock_smtp:\n            mock_server = mock_smtp.return_value\n            mail_server = 'smtp.example.com'\n            mail_port = 587\n            email_from = 'sender@example.com'\n            email_to = 'receiver@example.com'\n            auth_pass = 'secure_password'\n            content = 'This is a test email content.'\n            \n            tls_secure_email(mail_server, mail_port, email_from, email_to, auth_pass, content)\n            \n            mock_smtp.assert_called_once_with(mail_server, mail_port)\n            mock_server.starttls.assert_called_once_with(context=unittest.mock.ANY)\n            mock_server.login.assert_called_once_with(email_from, auth_pass)\n            \n            # Verify email content and headers\n            sent_email = mock_server.send_message.call_args[0][0]\n            self.assertEqual(sent_email['Subject'], 'Test Email')\n            self.assertEqual(sent_email['From'], email_from)\n            self.assertEqual(sent_email['To'], email_to)\n            self.assertEqual(sent_email.get_content(), content)\n            mock_server.quit.assert_called_once()\n\n    def test_authentication_failure(self):\n        \"\"\"Test invalid credentials raising SMTPAuthenticationError.\"\"\"\n        with patch('smtplib.SMTP') as mock_smtp:\n            mock_server = mock_smtp.return_value\n            mock_server.login.side_effect = smtplib.SMTPAuthenticationError(535, b'Invalid credentials')\n            \n            with self.assertRaises(smtplib.SMTPAuthenticationError) as context:\n                tls_secure_email('smtp.example.com', 587, 'user', 'recipient', 'wrongpass', 'content')\n            \n            self.assertIn('Authentication failed', str(context.exception))\n            mock_server.quit.assert_called_once()\n\n    def test_ssl_error_during_starttls(self):\n        \"\"\"Test SSL error during STARTTLS raising SSLError.\"\"\"\n        with patch('smtplib.SMTP') as mock_smtp:\n            mock_server = mock_smtp.return_value\n            mock_server.starttls.side_effect = ssl.SSLError('SSL handshake failed')\n            \n            with self.assertRaises(ssl.SSLError) as context:\n                tls_secure_email('smtp.example.com', 587, 'user', 'recipient', 'pass', 'content')\n            \n            self.assertEqual(str(context.exception), 'SSL handshake failed')\n            mock_server.quit.assert_called_once()\n\n    def test_ssl_error_during_login(self):\n        \"\"\"Test SSL error during login raising wrapped SSLError.\"\"\"\n        with patch('smtplib.SMTP') as mock_smtp:\n            mock_server = mock_smtp.return_value\n            mock_server.login.side_effect = ssl.SSLError('Certificate validation failed')\n            \n            with self.assertRaises(ssl.SSLError) as context:\n                tls_secure_email('smtp.example.com', 587, 'user', 'recipient', 'pass', 'content')\n            \n            self.assertIn('SSL error: Certificate validation failed', str(context.exception))\n            mock_server.quit.assert_called_once()\n\n    def test_smtp_exception_during_send(self):\n        \"\"\"Test general SMTP exception during send_message.\"\"\"\n        with patch('smtplib.SMTP') as mock_smtp:\n            mock_server = mock_smtp.return_value\n            mock_server.send_message.side_effect = smtplib.SMTPException('Server rejected message')\n            \n            with self.assertRaises(smtplib.SMTPException) as context:\n                tls_secure_email('smtp.example.com', 587, 'user', 'recipient', 'pass', 'content')\n            \n            self.assertIn('SMTP error occurred: Server rejected message', str(context.exception))\n            mock_server.quit.assert_called_once()\n\n    def test_empty_content(self):\n        \"\"\"Test sending email with empty content.\"\"\"\n        with patch('smtplib.SMTP') as mock_smtp:\n            mock_server = mock_smtp.return_value\n            content = ''\n            \n            tls_secure_email('smtp.example.com', 587, 'sender', 'recipient', 'pass', content)\n            \n            sent_email = mock_server.send_message.call_args[0][0]\n            self.assertEqual(sent_email.get_content(), content)\n            mock_server.quit.assert_called_once()\n\n    def test_none_content(self):\n        \"\"\"Test None content raising TypeError.\"\"\"\n        with patch('smtplib.SMTP') as mock_smtp:\n            mock_server = mock_smtp.return_value\n            \n            with self.assertRaises(TypeError):\n                tls_secure_email('smtp.example.com', 587, 'sender', 'recipient', 'pass', None)\n            \n            mock_server.quit.assert_called_once()\n\n    def test_empty_credentials_and_recipient(self):\n        \"\"\"Test with empty sender, recipient, and password.\"\"\"\n        with patch('smtplib.SMTP') as mock_smtp:\n            mock_server = mock_smtp.return_value\n            email_from = ''\n            email_to = ''\n            auth_pass = ''\n            content = 'Content'\n            \n            tls_secure_email('smtp.example.com', 587, email_from, email_to, auth_pass, content)\n            \n            mock_server.login.assert_called_once_with('', '')\n            sent_email = mock_server.send_message.call_args[0][0]\n            self.assertEqual(sent_email['From'], '')\n            self.assertEqual(sent_email['To'], '')\n            mock_server.quit.assert_called_once()\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 8, "task_id": "dbcbf62f"}
{"test": "import unittest\nfrom unittest.mock import patch\nimport smtplib\nimport ssl\nfrom email.message import EmailMessage\nfrom solution import tls_secured_email\n\nclass TestTlsSecuredEmail(unittest.TestCase):\n\n    @patch('builtins.print')\n    @patch('smtplib.SMTP')\n    @patch('ssl.create_default_context')\n    def test_successful_email_send(self, mock_create_context, mock_smtp, mock_print):\n        # Test happy path with non-empty content\n        mock_server = mock_smtp.return_value\n        mock_context = mock_create_context.return_value\n        \n        tls_secured_email(\n            mail_server='smtp.example.com',\n            smtp_port=587,\n            send_address='sender@example.com',\n            receive_address='receiver@example.com',\n            auth_password='password123',\n            mail_content='Hello, this is a test email.'\n        )\n        \n        mock_smtp.assert_called_once_with('smtp.example.com', 587)\n        mock_create_context.assert_called_once()\n        mock_server.starttls.assert_called_once_with(context=mock_context)\n        mock_server.login.assert_called_once_with('sender@example.com', 'password123')\n        \n        args, _ = mock_server.send_message.call_args\n        email_sent = args[0]\n        self.assertIsInstance(email_sent, EmailMessage)\n        self.assertEqual(email_sent['Subject'], 'Test Email')\n        self.assertEqual(email_sent['From'], 'sender@example.com')\n        self.assertEqual(email_sent['To'], 'receiver@example.com')\n        self.assertEqual(email_sent.get_content(), 'Hello, this is a test email.')\n        self.assertEqual(email_sent.get_content_type(), 'text/plain')\n        mock_print.assert_called_once_with('Email sent successfully')\n        mock_server.quit.assert_called_once()\n\n    @patch('builtins.print')\n    @patch('smtplib.SMTP')\n    @patch('ssl.create_default_context')\n    def test_empty_content(self, mock_create_context, mock_smtp, mock_print):\n        # Test edge case with empty mail content\n        mock_server = mock_smtp.return_value\n        mock_context = mock_create_context.return_value\n        \n        tls_secured_email(\n            mail_server='smtp.example.com',\n            smtp_port=587,\n            send_address='sender@example.com',\n            receive_address='receiver@example.com',\n            auth_password='password123',\n            mail_content=''\n        )\n        \n        mock_smtp.assert_called_once_with('smtp.example.com', 587)\n        mock_create_context.assert_called_once()\n        mock_server.starttls.assert_called_once_with(context=mock_context)\n        mock_server.login.assert_called_once_with('sender@example.com', 'password123')\n        \n        args, _ = mock_server.send_message.call_args\n        email_sent = args[0]\n        self.assertEqual(email_sent.get_content(), '')\n        mock_print.assert_called_once_with('Email sent successfully')\n        mock_server.quit.assert_called_once()\n\n    @patch('smtplib.SMTP')\n    def test_authentication_failure(self, mock_smtp):\n        # Test invalid credentials raising SMTPAuthenticationError\n        mock_server = mock_smtp.return_value\n        mock_server.login.side_effect = smtplib.SMTPAuthenticationError(534, 'Authentication failed')\n        \n        with self.assertRaises(smtplib.SMTPAuthenticationError):\n            tls_secured_email(\n                mail_server='smtp.example.com',\n                smtp_port=587,\n                send_address='sender@example.com',\n                receive_address='receiver@example.com',\n                auth_password='wrong_password',\n                mail_content='Hello'\n            )\n        \n        mock_server.quit.assert_called_once()\n\n    @patch('smtplib.SMTP')\n    def test_ssl_error(self, mock_smtp):\n        # Test SSL certificate error during starttls\n        mock_server = mock_smtp.return_value\n        mock_server.starttls.side_effect = ssl.SSLError('SSL certificate error')\n        \n        with self.assertRaises(ssl.SSLError):\n            tls_secured_email(\n                mail_server='smtp.example.com',\n                smtp_port=587,\n                send_address='sender@example.com',\n                receive_address='receiver@example.com',\n                auth_password='password123',\n                mail_content='Hello'\n            )\n        \n        mock_server.quit.assert_called_once()\n\n    @patch('smtplib.SMTP')\n    def test_smtp_exception_during_send(self, mock_smtp):\n        # Test SMTPException during email sending\n        mock_server = mock_smtp.return_value\n        mock_server.send_message.side_effect = smtplib.SMTPException('SMTP error')\n        \n        with self.assertRaises(smtplib.SMTPException):\n            tls_secured_email(\n                mail_server='smtp.example.com',\n                smtp_port=587,\n                send_address='sender@example.com',\n                receive_address='receiver@example.com',\n                auth_password='password123',\n                mail_content='Hello'\n            )\n        \n        mock_server.quit.assert_called_once()\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 5, "task_id": "bd292a09"}
{"test": "import unittest\nfrom unittest.mock import patch, MagicMock\nimport smtplib\nimport ssl\nfrom email.message import EmailMessage\n\nclass TestTlsEmailSend(unittest.TestCase):\n\n    def test_successful_email_sending(self):\n        \"\"\"Test sending an email with valid parameters and verify correct operations.\"\"\"\n        mock_server = MagicMock()\n        with patch('smtplib.SMTP', return_value=mock_server) as mock_smtp, \\\n             patch('builtins.print') as mock_print:\n            \n            tls_email_send('smtp.example.com', 587, 'user@example.com', 'recipient@example.com', 'password', 'Test email body')\n            \n            mock_smtp.assert_called_once_with('smtp.example.com', 587)\n            mock_server.starttls.assert_called_once()\n            context_arg = mock_server.starttls.call_args[1]['context']\n            self.assertIsInstance(context_arg, ssl.SSLContext)\n            mock_server.login.assert_called_once_with('user@example.com', 'password')\n            \n            # Verify email content\n            self.assertEqual(mock_server.send_message.call_count, 1)\n            sent_email = mock_server.send_message.call_args[0][0]\n            self.assertEqual(sent_email['Subject'], 'Test Email')\n            self.assertEqual(sent_email['From'], 'user@example.com')\n            self.assertEqual(sent_email['To'], 'recipient@example.com')\n            self.assertEqual(sent_email.get_content(), 'Test email body')\n            \n            mock_print.assert_called_once_with(\"Email sent successfully\")\n            mock_server.quit.assert_called_once()\n\n    def test_authentication_failure(self):\n        \"\"\"Test authentication failure raises SMTPAuthenticationError and quits server.\"\"\"\n        mock_server = MagicMock()\n        mock_server.login.side_effect = smtplib.SMTPAuthenticationError(535, b'Invalid credentials')\n        \n        with patch('smtplib.SMTP', return_value=mock_server):\n            with self.assertRaises(smtplib.SMTPAuthenticationError):\n                tls_email_send('host', 587, 'user', 'recipient', 'wrongpass', 'body')\n            \n            mock_server.quit.assert_called_once()\n\n    def test_ssl_error_during_starttls(self):\n        \"\"\"Test SSL error during STARTTLS raises SSLError and doesn't call quit.\"\"\"\n        mock_server = MagicMock()\n        mock_server.starttls.side_effect = ssl.SSLError(\"SSL handshake failed\")\n        \n        with patch('smtplib.SMTP', return_value=mock_server):\n            with self.assertRaises(ssl.SSLError):\n                tls_email_send('host', 587, 'user', 'recipient', 'pass', 'body')\n            \n            mock_server.quit.assert_not_called()\n\n    def test_ssl_error_during_login(self):\n        \"\"\"Test SSL error during login raises SSLError and quits server.\"\"\"\n        mock_server = MagicMock()\n        mock_server.login.side_effect = ssl.SSLError(\"SSL error during login\")\n        \n        with patch('smtplib.SMTP', return_value=mock_server):\n            with self.assertRaises(ssl.SSLError):\n                tls_email_send('host', 587, 'user', 'recipient', 'pass', 'body')\n            \n            mock_server.quit.assert_called_once()\n\n    def test_smtp_exception_during_send(self):\n        \"\"\"Test SMTPException during sending raises exception and quits server.\"\"\"\n        mock_server = MagicMock()\n        mock_server.send_message.side_effect = smtplib.SMTPException(\"Send failed\")\n        \n        with patch('smtplib.SMTP', return_value=mock_server):\n            with self.assertRaises(smtplib.SMTPException):\n                tls_email_send('host', 587, 'user', 'recipient', 'pass', 'body')\n            \n            mock_server.login.assert_called_once()\n            mock_server.quit.assert_called_once()\n\n    def test_other_smtp_exception_during_login(self):\n        \"\"\"Test non-auth SMTPException during login raises exception and quits server.\"\"\"\n        mock_server = MagicMock()\n        mock_server.login.side_effect = smtplib.SMTPException(\"Server unavailable\")\n        \n        with patch('smtplib.SMTP', return_value=mock_server):\n            with self.assertRaises(smtplib.SMTPException):\n                tls_email_send('host', 587, 'user', 'recipient', 'pass', 'body')\n            \n            mock_server.quit.assert_called_once()\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 6, "task_id": "75b9eff6"}
{"test": "import unittest\nfrom unittest.mock import patch, MagicMock\nimport smtplib\nimport ssl\nfrom email.message import EmailMessage\n\nclass TestCases(unittest.TestCase):\n\n    @patch('ssl.create_default_context')\n    @patch('smtplib.SMTP')\n    def test_successful_email_send(self, mock_smtp, mock_create_context):\n        # Test successful email sending with valid parameters\n        mock_server = mock_smtp.return_value\n        mock_context = mock_create_context.return_value\n        \n        host = \"smtp.example.com\"\n        port = 587\n        sender = \"sender@example.com\"\n        recipient = \"recipient@example.com\"\n        password = \"password123\"\n        message_text = \"This is a test email.\"\n        \n        with patch('builtins.print') as mock_print:\n            smtp_tls_mail_send(host, port, sender, recipient, password, message_text)\n            mock_print.assert_called_once_with(\"Email sent successfully\")\n        \n        mock_smtp.assert_called_once_with(host, port)\n        mock_server.starttls.assert_called_once_with(context=mock_context)\n        mock_server.login.assert_called_once_with(sender, password)\n        \n        sent_email = mock_server.send_message.call_args[0][0]\n        self.assertIsInstance(sent_email, EmailMessage)\n        self.assertEqual(sent_email['Subject'], 'Test Email')\n        self.assertEqual(sent_email['From'], sender)\n        self.assertEqual(sent_email['To'], recipient)\n        self.assertEqual(sent_email.get_content(), message_text)\n        mock_server.quit.assert_called_once()\n\n    @patch('smtplib.SMTP')\n    def test_authentication_failure(self, mock_smtp):\n        # Test authentication failure with invalid credentials\n        mock_server = mock_smtp.return_value\n        mock_server.login.side_effect = smtplib.SMTPAuthenticationError(535, b'Authentication failed')\n        \n        with self.assertRaises(smtplib.SMTPAuthenticationError):\n            smtp_tls_mail_send(\"host\", 587, \"user\", \"recipient\", \"wrongpass\", \"text\")\n        \n        mock_server.login.assert_called_once()\n        mock_server.quit.assert_called_once()\n\n    @patch('smtplib.SMTP')\n    def test_ssl_error(self, mock_smtp):\n        # Test SSL error during TLS handshake\n        mock_server = mock_smtp.return_value\n        mock_server.starttls.side_effect = ssl.SSLError(\"SSL handshake failed\")\n        \n        with self.assertRaises(ssl.SSLError):\n            smtp_tls_mail_send(\"host\", 587, \"user\", \"recipient\", \"pass\", \"text\")\n        \n        mock_server.starttls.assert_called_once()\n        mock_server.quit.assert_called_once()\n\n    @patch('smtplib.SMTP')\n    def test_smtp_exception_during_login(self, mock_smtp):\n        # Test SMTP exception during login\n        mock_server = mock_smtp.return_value\n        mock_server.login.side_effect = smtplib.SMTPException(\"Login error\")\n        \n        with self.assertRaises(smtplib.SMTPException):\n            smtp_tls_mail_send(\"host\", 587, \"user\", \"recipient\", \"pass\", \"text\")\n        \n        mock_server.login.assert_called_once()\n        mock_server.quit.assert_called_once()\n\n    @patch('smtplib.SMTP')\n    def test_smtp_exception_during_send(self, mock_smtp):\n        # Test SMTP exception during email sending\n        mock_server = mock_smtp.return_value\n        mock_server.send_message.side_effect = smtplib.SMTPException(\"Send error\")\n        \n        with self.assertRaises(smtplib.SMTPException):\n            smtp_tls_mail_send(\"host\", 587, \"user\", \"recipient\", \"pass\", \"text\")\n        \n        mock_server.send_message.assert_called_once()\n        mock_server.quit.assert_called_once()\n\n    @patch('smtplib.SMTP')\n    def test_server_quit_called_on_exception(self, mock_smtp):\n        # Test server.quit() is called even when exception occurs\n        mock_server = mock_smtp.return_value\n        mock_server.login.side_effect = smtplib.SMTPException(\"Any error\")\n        \n        with self.assertRaises(smtplib.SMTPException):\n            smtp_tls_mail_send(\"host\", 587, \"user\", \"recipient\", \"pass\", \"text\")\n        \n        mock_server.quit.assert_called_once()\n\n    @patch('smtplib.SMTP')\n    def test_empty_email_content(self, mock_smtp):\n        # Test sending email with empty content\n        mock_server = mock_smtp.return_value\n        message_text = \"\"\n        \n        smtp_tls_mail_send(\"host\", 587, \"sender\", \"recipient\", \"pass\", message_text)\n        \n        sent_email = mock_server.send_message.call_args[0][0]\n        self.assertEqual(sent_email.get_content(), message_text)\n\n    def test_invalid_arguments(self):\n        # Test invalid argument types\n        with self.subTest(\"None mail_host\"):\n            with self.assertRaises(TypeError):\n                smtp_tls_mail_send(None, 587, \"user\", \"recipient\", \"pass\", \"text\")\n        \n        with self.subTest(\"None port\"):\n            with self.assertRaises(TypeError):\n                smtp_tls_mail_send(\"host\", None, \"user\", \"recipient\", \"pass\", \"text\")\n        \n        with self.subTest(\"None user_email\"):\n            with self.assertRaises(TypeError):\n                smtp_tls_mail_send(\"host\", 587, None, \"recipient\", \"pass\", \"text\")\n        \n        with self.subTest(\"None recipient_id\"):\n            with self.assertRaises(TypeError):\n                smtp_tls_mail_send(\"host\", 587, \"user\", None, \"pass\", \"text\")\n        \n        with self.subTest(\"None login_password\"):\n            with self.assertRaises(TypeError):\n                smtp_tls_mail_send(\"host\", 587, \"user\", \"recipient\", None, \"text\")\n        \n        with self.subTest(\"None mail_text\"):\n            with self.assertRaises(TypeError):\n                smtp_tls_mail_send(\"host\", 587, \"user\", \"recipient\", \"pass\", None)\n        \n        with self.subTest(\"Port as string\"):\n            with self.assertRaises(TypeError):\n                smtp_tls_mail_send(\"host\", \"587\", \"user\", \"recipient\", \"pass\", \"text\")\n", "num_test_cases": 8, "task_id": "1c4b8e2a"}
{"test": "import unittest\nfrom unittest.mock import patch, Mock\nimport requests\nimport ssl\n\nclass TestSendSecureHttpsRequest(unittest.TestCase):\n\n    @patch('ssl.create_default_context')\n    @patch('requests.get')\n    def test_successful_request(self, mock_get, mock_create_context):\n        \"\"\"Test successful request with valid URL and timeout.\"\"\"\n        mock_context = Mock()\n        mock_create_context.return_value = mock_context\n        mock_response = Mock()\n        mock_response.text = 'Success content'\n        mock_response.status_code = 200\n        mock_response.raise_for_status.return_value = None\n        mock_get.return_value = mock_response\n        \n        result = send_secure_https_request('https://valid.example.com', 10)\n        \n        mock_create_context.assert_called_once()\n        mock_get.assert_called_once_with('https://valid.example.com', timeout=10, verify=mock_context)\n        mock_response.raise_for_status.assert_called_once()\n        self.assertEqual(result, 'Success content')\n\n    @patch('ssl.create_default_context')\n    @patch('requests.get')\n    def test_ssl_validation_failure(self, mock_get, mock_create_context):\n        \"\"\"Test SSL certificate validation failure.\"\"\"\n        mock_context = Mock()\n        mock_create_context.return_value = mock_context\n        mock_get.side_effect = requests.exceptions.SSLError('SSL error')\n        \n        with self.assertRaises(requests.exceptions.SSLError) as cm:\n            send_secure_https_request('https://invalid-ssl.example.com', 5)\n        \n        self.assertIn('SSL certificate validation failed', str(cm.exception))\n        self.assertIn('SSL error', str(cm.exception))\n\n    @patch('ssl.create_default_context')\n    @patch('requests.get')\n    def test_request_timeout(self, mock_get, mock_create_context):\n        \"\"\"Test request timeout exception.\"\"\"\n        mock_context = Mock()\n        mock_create_context.return_value = mock_context\n        mock_get.side_effect = requests.exceptions.Timeout('Timeout error')\n        \n        with self.assertRaises(requests.exceptions.RequestException) as cm:\n            send_secure_https_request('https://timeout.example.com', 2)\n        \n        self.assertIn('Request failed', str(cm.exception))\n        self.assertIn('Timeout error', str(cm.exception))\n\n    @patch('ssl.create_default_context')\n    @patch('requests.get')\n    def test_http_error(self, mock_get, mock_create_context):\n        \"\"\"Test HTTP error via raise_for_status().\"\"\"\n        mock_context = Mock()\n        mock_create_context.return_value = mock_context\n        mock_response = Mock()\n        mock_response.status_code = 404\n        mock_response.raise_for_status.side_effect = requests.exceptions.HTTPError('404 Not Found')\n        mock_get.return_value = mock_response\n        \n        with self.assertRaises(requests.exceptions.RequestException) as cm:\n            send_secure_https_request('https://notfound.example.com', 8)\n        \n        self.assertIn('Request failed', str(cm.exception))\n        self.assertIn('404 Not Found', str(cm.exception))\n\n    @patch('ssl.create_default_context')\n    @patch('requests.get')\n    def test_connection_error(self, mock_get, mock_create_context):\n        \"\"\"Test connection failure exception.\"\"\"\n        mock_context = Mock()\n        mock_create_context.return_value = mock_context\n        mock_get.side_effect = requests.exceptions.ConnectionError('Connection failed')\n        \n        with self.assertRaises(requests.exceptions.RequestException) as cm:\n            send_secure_https_request('https://unreachable.example.com', 3)\n        \n        self.assertIn('Request failed', str(cm.exception))\n        self.assertIn('Connection failed', str(cm.exception))\n\n    @patch('ssl.create_default_context')\n    def test_invalid_url_type(self, mock_create_context):\n        \"\"\"Test non-string URL input.\"\"\"\n        mock_create_context.return_value = Mock()\n        \n        with self.assertRaises(TypeError):\n            send_secure_https_request(12345, 10)\n\n    @patch('ssl.create_default_context')\n    @patch('requests.get')\n    def test_empty_url(self, mock_get, mock_create_context):\n        \"\"\"Test empty string URL input.\"\"\"\n        mock_context = Mock()\n        mock_create_context.return_value = mock_context\n        mock_get.side_effect = requests.exceptions.InvalidURL('Empty URL')\n        \n        with self.assertRaises(requests.exceptions.RequestException) as cm:\n            send_secure_https_request('', 5)\n        \n        self.assertIn('Request failed', str(cm.exception))\n        self.assertIn('Empty URL', str(cm.exception))\n\n    @patch('ssl.create_default_context')\n    @patch('requests.get')\n    def test_negative_timeout(self, mock_get, mock_create_context):\n        \"\"\"Test negative timeout value.\"\"\"\n        mock_context = Mock()\n        mock_create_context.return_value = mock_context\n        mock_response = Mock()\n        mock_response.text = 'Negative timeout content'\n        mock_response.raise_for_status.return_value = None\n        mock_get.return_value = mock_response\n        \n        result = send_secure_https_request('https://example.com', -1)\n        \n        mock_get.assert_called_once_with('https://example.com', timeout=-1, verify=mock_context)\n        self.assertEqual(result, 'Negative timeout content')\n\n    @patch('ssl.create_default_context')\n    @patch('requests.get')\n    def test_zero_timeout(self, mock_get, mock_create_context):\n        \"\"\"Test zero timeout value.\"\"\"\n        mock_context = Mock()\n        mock_create_context.return_value = mock_context\n        mock_response = Mock()\n        mock_response.text = 'Zero timeout content'\n        mock_response.raise_for_status.return_value = None\n        mock_get.return_value = mock_response\n        \n        result = send_secure_https_request('https://example.com', 0)\n        \n        mock_get.assert_called_once_with('https://example.com', timeout=0, verify=mock_context)\n        self.assertEqual(result, 'Zero timeout content')\n", "num_test_cases": 9, "task_id": "65fa3271"}
{"test": "import unittest\nimport requests\nimport requests.exceptions\nfrom unittest.mock import patch, Mock\n\nclass TestPerformSecureHttpsRequest(unittest.TestCase):\n    @patch('requests.get')\n    @patch('ssl.create_default_context')\n    def test_case_1_happy_path(self, mock_create_default_context, mock_get):\n        # Test successful request with valid parameters\n        mock_context = Mock()\n        mock_create_default_context.return_value = mock_context\n        mock_response = Mock()\n        mock_response.text = 'Success content'\n        mock_response.status_code = 200\n        mock_response.raise_for_status = Mock()\n        mock_get.return_value = mock_response\n        \n        result = perform_secure_https_request('https://valid-url.com', 5)\n        self.assertEqual(result, 'Success content')\n        mock_get.assert_called_once_with('https://valid-url.com', timeout=5, verify=mock_context)\n        mock_response.raise_for_status.assert_called_once()\n\n    @patch('requests.get')\n    @patch('ssl.create_default_context')\n    def test_case_2_ssl_validation_failure(self, mock_create_default_context, mock_get):\n        # Test SSL certificate validation failure\n        mock_context = Mock()\n        mock_create_default_context.return_value = mock_context\n        mock_get.side_effect = requests.exceptions.SSLError('SSL problem')\n        \n        with self.assertRaises(requests.exceptions.SSLError) as cm:\n            perform_secure_https_request('https://invalid-ssl.com', 5)\n        self.assertIn('SSL certificate validation failed', str(cm.exception))\n        self.assertIn('SSL problem', str(cm.exception))\n        mock_get.assert_called_once_with('https://invalid-ssl.com', timeout=5, verify=mock_context)\n\n    @patch('requests.get')\n    @patch('ssl.create_default_context')\n    def test_case_3_connection_timeout(self, mock_create_default_context, mock_get):\n        # Test request timing out\n        mock_context = Mock()\n        mock_create_default_context.return_value = mock_context\n        mock_get.side_effect = requests.exceptions.Timeout('Timed out')\n        \n        with self.assertRaises(requests.exceptions.RequestException) as cm:\n            perform_secure_https_request('https://timeout-url.com', 1)\n        self.assertIn('Request failed', str(cm.exception))\n        self.assertIn('Timed out', str(cm.exception))\n        mock_get.assert_called_once_with('https://timeout-url.com', timeout=1, verify=mock_context)\n\n    @patch('requests.get')\n    @patch('ssl.create_default_context')\n    def test_case_4_http_error(self, mock_create_default_context, mock_get):\n        # Test HTTP error status (404)\n        mock_context = Mock()\n        mock_create_default_context.return_value = mock_context\n        mock_response = Mock()\n        mock_response.status_code = 404\n        mock_response.raise_for_status.side_effect = requests.exceptions.HTTPError('404 Error')\n        mock_get.return_value = mock_response\n        \n        with self.assertRaises(requests.exceptions.RequestException) as cm:\n            perform_secure_https_request('https://not-found.com', 3)\n        self.assertIn('Request failed', str(cm.exception))\n        self.assertIn('404 Error', str(cm.exception))\n        mock_get.assert_called_once_with('https://not-found.com', timeout=3, verify=mock_context)\n\n    @patch('requests.get')\n    @patch('ssl.create_default_context')\n    def test_case_5_invalid_url_missing_schema(self, mock_create_default_context, mock_get):\n        # Test invalid URL (missing schema)\n        mock_context = Mock()\n        mock_create_default_context.return_value = mock_context\n        mock_get.side_effect = requests.exceptions.MissingSchema('Schema missing')\n        \n        with self.assertRaises(requests.exceptions.RequestException) as cm:\n            perform_secure_https_request('missing-schema.com', 2)\n        self.assertIn('Request failed', str(cm.exception))\n        self.assertIn('Schema missing', str(cm.exception))\n        mock_get.assert_called_once_with('missing-schema.com', timeout=2, verify=mock_context)\n\n    @patch('requests.get')\n    @patch('ssl.create_default_context')\n    def test_case_6_empty_url(self, mock_create_default_context, mock_get):\n        # Test empty URL string\n        mock_context = Mock()\n        mock_create_default_context.return_value = mock_context\n        mock_get.side_effect = requests.exceptions.InvalidURL('Invalid URL')\n        \n        with self.assertRaises(requests.exceptions.RequestException) as cm:\n            perform_secure_https_request('', 2)\n        self.assertIn('Request failed', str(cm.exception))\n        self.assertIn('Invalid URL', str(cm.exception))\n        mock_get.assert_called_once_with('', timeout=2, verify=mock_context)\n\n    @patch('requests.get')\n    @patch('ssl.create_default_context')\n    def test_case_7_zero_timeout_success(self, mock_create_default_context, mock_get):\n        # Test zero timeout with successful request\n        mock_context = Mock()\n        mock_create_default_context.return_value = mock_context\n        mock_response = Mock()\n        mock_response.text = 'Quick response'\n        mock_response.status_code = 200\n        mock_response.raise_for_status = Mock()\n        mock_get.return_value = mock_response\n        \n        result = perform_secure_https_request('https://fast-response.com', 0)\n        self.assertEqual(result, 'Quick response')\n        mock_get.assert_called_once_with('https://fast-response.com', timeout=0, verify=mock_context)\n\n    @patch('requests.get')\n    @patch('ssl.create_default_context')\n    def test_case_8_zero_timeout_failure(self, mock_create_default_context, mock_get):\n        # Test zero timeout causing immediate timeout\n        mock_context = Mock()\n        mock_create_default_context.return_value = mock_context\n        mock_get.side_effect = requests.exceptions.Timeout('Immediate timeout')\n        \n        with self.assertRaises(requests.exceptions.RequestException) as cm:\n            perform_secure_https_request('https://slow-server.com', 0)\n        self.assertIn('Request failed', str(cm.exception))\n        self.assertIn('Immediate timeout', str(cm.exception))\n        mock_get.assert_called_once_with('https://slow-server.com', timeout=0, verify=mock_context)\n\n    @patch('requests.get')\n    @patch('ssl.create_default_context')\n    def test_case_9_large_timeout_value(self, mock_create_default_context, mock_get):\n        # Test very large timeout value\n        mock_context = Mock()\n        mock_create_default_context.return_value = mock_context\n        mock_response = Mock()\n        mock_response.text = 'Large timeout response'\n        mock_response.status_code = 200\n        mock_response.raise_for_status = Mock()\n        mock_get.return_value = mock_response\n        \n        result = perform_secure_https_request('https://large-timeout.com', 1000000)\n        self.assertEqual(result, 'Large timeout response')\n        mock_get.assert_called_once_with('https://large-timeout.com', timeout=1000000, verify=mock_context)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 9, "task_id": "8140cba8"}
{"test": "import unittest\nfrom unittest.mock import patch, Mock, ANY\nimport requests\nfrom secure_requests import make_secure_https_request\n\nclass TestMakeSecureHttpsRequest(unittest.TestCase):\n\n    @patch('requests.get')\n    def test_success_non_empty_response(self, mock_get):\n        # Test typical successful request with non-empty response\n        mock_response = Mock()\n        mock_response.status_code = 200\n        mock_response.text = 'Success'\n        mock_get.return_value = mock_response\n        result = make_secure_https_request('https://example.com', 10)\n        self.assertEqual(result, 'Success')\n        mock_get.assert_called_once_with('https://example.com', timeout=10, verify=ANY)\n\n    @patch('requests.get')\n    def test_success_empty_response(self, mock_get):\n        # Test successful request with empty response string\n        mock_response = Mock()\n        mock_response.status_code = 200\n        mock_response.text = ''\n        mock_get.return_value = mock_response\n        result = make_secure_https_request('https://example.com', 10)\n        self.assertEqual(result, '')\n\n    @patch('requests.get')\n    def test_success_large_delay(self, mock_get):\n        # Test successful request with very large delay value\n        mock_response = Mock()\n        mock_response.status_code = 200\n        mock_response.text = 'Success'\n        mock_get.return_value = mock_response\n        large_delay = 10000\n        result = make_secure_https_request('https://example.com', large_delay)\n        self.assertEqual(result, 'Success')\n        mock_get.assert_called_once_with('https://example.com', timeout=large_delay, verify=ANY)\n\n    @patch('requests.get')\n    def test_ssl_error(self, mock_get):\n        # Test SSL certificate validation failure\n        mock_get.side_effect = requests.exceptions.SSLError('SSL error')\n        with self.assertRaises(requests.exceptions.SSLError):\n            make_secure_https_request('https://example.com', 10)\n\n    @patch('requests.get')\n    def test_timeout_error(self, mock_get):\n        # Test request timeout\n        mock_get.side_effect = requests.exceptions.Timeout('Timeout')\n        with self.assertRaises(requests.exceptions.RequestException):\n            make_secure_https_request('https://example.com', 10)\n\n    @patch('requests.get')\n    def test_connection_error(self, mock_get):\n        # Test connection error\n        mock_get.side_effect = requests.exceptions.ConnectionError('Connection error')\n        with self.assertRaises(requests.exceptions.RequestException):\n            make_secure_https_request('https://example.com', 10)\n\n    @patch('requests.get')\n    def test_http_error(self, mock_get):\n        # Test HTTP error (e.g., 404)\n        mock_response = Mock()\n        mock_response.status_code = 404\n        mock_response.raise_for_status.side_effect = requests.exceptions.HTTPError('404 Not Found')\n        mock_get.return_value = mock_response\n        with self.assertRaises(requests.exceptions.RequestException):\n            make_secure_https_request('https://example.com', 10)\n\n    @patch('requests.get')\n    def test_invalid_url(self, mock_get):\n        # Test invalid URL format\n        mock_get.side_effect = requests.exceptions.InvalidURL('Invalid URL')\n        with self.assertRaises(requests.exceptions.RequestException):\n            make_secure_https_request('invalid_url', 10)\n\n    @patch('requests.get')\n    def test_negative_delay(self, mock_get):\n        # Test negative delay value\n        mock_get.side_effect = ValueError('Timeout value must be non-negative')\n        with self.assertRaises(ValueError):\n            make_secure_https_request('https://example.com', -1)\n\n    @patch('requests.get')\n    def test_non_string_url(self, mock_get):\n        # Test non-string endpoint_url\n        mock_get.side_effect = TypeError('URL must be a string')\n        with self.assertRaises(TypeError):\n            make_secure_https_request(123, 10)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 10, "task_id": "ccd4d06e"}
{"test": "import unittest\nfrom unittest.mock import patch, Mock\nimport requests\nimport ssl\n\nfrom solution import protected_https_call\n\nclass TestProtectedHttpsCall(unittest.TestCase):\n\n    def test_successful_request(self):\n        \"\"\"Test successful request with valid URL and timeout.\"\"\"\n        with patch('requests.get') as mock_get:\n            mock_response = Mock()\n            mock_response.status_code = 200\n            mock_response.text = \"Success\"\n            mock_response.raise_for_status = Mock()\n            mock_get.return_value = mock_response\n            \n            result = protected_https_call('https://example.com', 5)\n            self.assertEqual(result, \"Success\")\n\n    def test_http_error(self):\n        \"\"\"Test non-2xx response raises RequestException.\"\"\"\n        with patch('requests.get') as mock_get:\n            mock_response = Mock()\n            mock_response.raise_for_status.side_effect = requests.exceptions.HTTPError(\"404 Not Found\")\n            mock_get.return_value = mock_response\n            \n            with self.assertRaises(requests.exceptions.RequestException) as cm:\n                protected_https_call('https://example.com', 5)\n            self.assertIn(\"Request failed:\", str(cm.exception))\n\n    def test_ssl_error(self):\n        \"\"\"Test SSL certificate failure raises SSLError.\"\"\"\n        with patch('requests.get') as mock_get:\n            mock_get.side_effect = requests.exceptions.SSLError(\"SSL error\")\n            \n            with self.assertRaises(requests.exceptions.SSLError) as cm:\n                protected_https_call('https://example.com', 5)\n            self.assertIn(\"SSL certificate validation failed:\", str(cm.exception))\n\n    def test_connection_error(self):\n        \"\"\"Test connection failure raises RequestException.\"\"\"\n        with patch('requests.get') as mock_get:\n            mock_get.side_effect = requests.exceptions.ConnectionError(\"Connection error\")\n            \n            with self.assertRaises(requests.exceptions.RequestException) as cm:\n                protected_https_call('https://example.com', 5)\n            self.assertIn(\"Request failed:\", str(cm.exception))\n\n    def test_timeout_error(self):\n        \"\"\"Test request timeout raises RequestException.\"\"\"\n        with patch('requests.get') as mock_get:\n            mock_get.side_effect = requests.exceptions.Timeout(\"Timeout\")\n            \n            with self.assertRaises(requests.exceptions.RequestException) as cm:\n                protected_https_call('https://example.com', 5)\n            self.assertIn(\"Request failed:\", str(cm.exception))\n\n    def test_invalid_url(self):\n        \"\"\"Test malformed URL raises RequestException.\"\"\"\n        with patch('requests.get') as mock_get:\n            mock_get.side_effect = requests.exceptions.MissingSchema(\"Invalid URL\")\n            \n            with self.assertRaises(requests.exceptions.RequestException) as cm:\n                protected_https_call('invalid_url', 5)\n            self.assertIn(\"Request failed:\", str(cm.exception))\n\n    def test_negative_timeout(self):\n        \"\"\"Test negative timeout raises ValueError.\"\"\"\n        with self.assertRaises(ValueError):\n            protected_https_call('https://example.com', -1)\n\n    def test_non_string_url(self):\n        \"\"\"Test non-string URL raises TypeError.\"\"\"\n        with self.assertRaises(TypeError):\n            protected_https_call(12345, 5)\n\n    def test_large_timeout(self):\n        \"\"\"Test successful request with very large timeout.\"\"\"\n        with patch('requests.get') as mock_get:\n            mock_response = Mock()\n            mock_response.status_code = 200\n            mock_response.text = \"Success\"\n            mock_response.raise_for_status = Mock()\n            mock_get.return_value = mock_response\n            \n            result = protected_https_call('https://example.com', 1000000)\n            self.assertEqual(result, \"Success\")\n\n    def test_timeout_zero(self):\n        \"\"\"Test successful request with zero timeout (if request completes immediately).\"\"\"\n        with patch('requests.get') as mock_get:\n            mock_response = Mock()\n            mock_response.status_code = 200\n            mock_response.text = \"Success\"\n            mock_response.raise_for_status = Mock()\n            mock_get.return_value = mock_response\n            \n            result = protected_https_call('https://example.com', 0)\n            self.assertEqual(result, \"Success\")\n\n    def test_ssl_context_used(self):\n        \"\"\"Verify function uses default SSL context in requests.\"\"\"\n        mock_ssl_context = Mock()\n        with patch('ssl.create_default_context', return_value=mock_ssl_context) as mock_create_context:\n            with patch('requests.get') as mock_get:\n                mock_response = Mock()\n                mock_response.status_code = 200\n                mock_response.text = \"Success\"\n                mock_response.raise_for_status = Mock()\n                mock_get.return_value = mock_response\n                \n                protected_https_call('https://example.com', 5)\n                \n                mock_create_context.assert_called_once()\n                mock_get.assert_called_once_with('https://example.com', timeout=5, verify=mock_ssl_context)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 11, "task_id": "85fc9924"}
{"test": "import unittest\nfrom unittest.mock import patch, MagicMock\nimport requests\nimport ssl\nfrom solution import verified_https_request\n\nclass TestCases(unittest.TestCase):\n    \n    def test_case_1(self):\n        # Test successful request with valid parameters\n        with patch('solution.requests.get') as mock_get:\n            mock_response = MagicMock()\n            mock_response.status_code = 200\n            mock_response.text = 'Success response'\n            mock_get.return_value = mock_response\n            \n            result = verified_https_request('https://valid-url.com', 5)\n            self.assertEqual(result, 'Success response')\n    \n    def test_case_2(self):\n        # Test SSL certificate verification failure\n        with patch('solution.requests.get') as mock_get:\n            mock_get.side_effect = requests.exceptions.SSLError('SSL error')\n            \n            with self.assertRaises(requests.exceptions.SSLError):\n                verified_https_request('https://invalid-ssl.com', 10)\n    \n    def test_case_3(self):\n        # Test connection error\n        with patch('solution.requests.get') as mock_get:\n            mock_get.side_effect = requests.exceptions.ConnectionError('Connection failed')\n            \n            with self.assertRaises(requests.exceptions.RequestException):\n                verified_https_request('https://unreachable-url.com', 15)\n    \n    def test_case_4(self):\n        # Test HTTP error (non-200 status)\n        with patch('solution.requests.get') as mock_get:\n            mock_response = MagicMock()\n            mock_response.status_code = 404\n            mock_response.raise_for_status.side_effect = requests.exceptions.HTTPError('404 Not Found')\n            mock_get.return_value = mock_response\n            \n            with self.assertRaises(requests.exceptions.RequestException):\n                verified_https_request('https://not-found.com', 8)\n    \n    def test_case_5(self):\n        # Test timeout error\n        with patch('solution.requests.get') as mock_get:\n            mock_get.side_effect = requests.exceptions.Timeout('Request timed out')\n            \n            with self.assertRaises(requests.exceptions.RequestException):\n                verified_https_request('https://slow-server.com', 3)\n    \n    def test_case_6(self):\n        # Test invalid URL (empty string)\n        with patch('solution.requests.get') as mock_get:\n            mock_get.side_effect = requests.exceptions.MissingSchema('Invalid URL')\n            \n            with self.assertRaises(requests.exceptions.RequestException):\n                verified_https_request('', 5)\n    \n    def test_case_7(self):\n        # Test parameters passed correctly to requests.get\n        with patch('solution.requests.get') as mock_get, \\\n             patch('solution.ssl.create_default_context') as mock_context:\n            \n            mock_response = MagicMock()\n            mock_response.status_code = 200\n            mock_get.return_value = mock_response\n            mock_context.return_value = 'mock_ssl_context'\n            \n            verified_https_request('https://test-params.com', 12)\n            \n            mock_get.assert_called_once_with(\n                'https://test-params.com',\n                timeout=12,\n                verify='mock_ssl_context'\n            )\n    \n    def test_case_8(self):\n        # Test edge case: timeout value of zero\n        with patch('solution.requests.get') as mock_get:\n            mock_response = MagicMock()\n            mock_response.status_code = 200\n            mock_response.text = 'Zero timeout response'\n            mock_get.return_value = mock_response\n            \n            result = verified_https_request('https://fast-response.com', 0)\n            self.assertEqual(result, 'Zero timeout response')\n            mock_get.assert_called_once_with(\n                'https://fast-response.com',\n                timeout=0,\n                verify=unittest.mock.ANY\n            )\n    \n    def test_case_9(self):\n        # Test invalid timeout type (non-integer)\n        with self.assertRaises(TypeError):\n            verified_https_request('https://valid.com', 'not_an_integer')\n    \n    def test_case_10(self):\n        # Test very large timeout value\n        with patch('solution.requests.get') as mock_get:\n            mock_response = MagicMock()\n            mock_response.status_code = 200\n            mock_response.text = 'Large timeout response'\n            mock_get.return_value = mock_response\n            \n            result = verified_https_request('https://valid.com', 10**6)\n            self.assertEqual(result, 'Large timeout response')\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 10, "task_id": "c77b88b9"}
{"test": "import unittest\nfrom unittest.mock import patch, MagicMock\nimport requests\nimport ssl\n\nclass TestValidatedHttpsQuery(unittest.TestCase):\n\n    def test_successful_request(self):\n        \"\"\"Test with valid URL and delay_limit, expecting successful response.\"\"\"\n        with patch('requests.get') as mock_get:\n            mock_response = MagicMock()\n            mock_response.status_code = 200\n            mock_response.text = 'Success'\n            mock_get.return_value = mock_response\n            \n            result = validated_https_query('https://example.com', 5)\n            self.assertEqual(result, 'Success')\n            mock_get.assert_called_once_with('https://example.com', timeout=5, verify=ssl.create_default_context())\n\n    def test_timeout_exception(self):\n        \"\"\"Test request timeout raises RequestException with appropriate message.\"\"\"\n        with patch('requests.get') as mock_get:\n            mock_get.side_effect = requests.exceptions.Timeout('Timeout occurred')\n            \n            with self.assertRaises(requests.exceptions.RequestException) as cm:\n                validated_https_query('https://example.com', 1)\n            self.assertIn('Request failed: Timeout occurred', str(cm.exception))\n            mock_get.assert_called_once_with('https://example.com', timeout=1, verify=ssl.create_default_context())\n\n    def test_ssl_error(self):\n        \"\"\"Test SSL certificate failure raises SSLError with appropriate message.\"\"\"\n        with patch('requests.get') as mock_get:\n            mock_get.side_effect = requests.exceptions.SSLError('SSL failure')\n            \n            with self.assertRaises(requests.exceptions.SSLError) as cm:\n                validated_https_query('https://example.com', 5)\n            self.assertIn('SSL certificate validation failed: SSL failure', str(cm.exception))\n            mock_get.assert_called_once_with('https://example.com', timeout=5, verify=ssl.create_default_context())\n\n    def test_http_error(self):\n        \"\"\"Test non-200 status code raises RequestException with appropriate message.\"\"\"\n        with patch('requests.get') as mock_get:\n            mock_response = MagicMock()\n            mock_response.status_code = 404\n            mock_response.raise_for_status.side_effect = requests.exceptions.HTTPError('404 Not Found')\n            mock_get.return_value = mock_response\n            \n            with self.assertRaises(requests.exceptions.RequestException) as cm:\n                validated_https_query('https://example.com', 5)\n            self.assertIn('Request failed: 404 Not Found', str(cm.exception))\n            mock_get.assert_called_once_with('https://example.com', timeout=5, verify=ssl.create_default_context())\n\n    def test_empty_url(self):\n        \"\"\"Test empty endpoint_url raises RequestException.\"\"\"\n        with patch('requests.get') as mock_get:\n            mock_get.side_effect = requests.exceptions.MissingSchema('Invalid URL')\n            \n            with self.assertRaises(requests.exceptions.RequestException) as cm:\n                validated_https_query('', 5)\n            self.assertIn('Request failed: Invalid URL', str(cm.exception))\n            mock_get.assert_called_once_with('', timeout=5, verify=ssl.create_default_context())\n\n    def test_none_url(self):\n        \"\"\"Test None endpoint_url raises RequestException.\"\"\"\n        with patch('requests.get') as mock_get:\n            mock_get.side_effect = requests.exceptions.MissingSchema('Invalid URL')\n            \n            with self.assertRaises(requests.exceptions.RequestException) as cm:\n                validated_https_query(None, 5)\n            self.assertIn('Request failed: Invalid URL', str(cm.exception))\n            mock_get.assert_called_once_with(None, timeout=5, verify=ssl.create_default_context())\n\n    def test_invalid_url_format(self):\n        \"\"\"Test invalid URL string raises RequestException.\"\"\"\n        with patch('requests.get') as mock_get:\n            mock_get.side_effect = requests.exceptions.MissingSchema('Invalid URL')\n            \n            with self.assertRaises(requests.exceptions.RequestException) as cm:\n                validated_https_query('invalid_url', 5)\n            self.assertIn('Request failed: Invalid URL', str(cm.exception))\n            mock_get.assert_called_once_with('invalid_url', timeout=5, verify=ssl.create_default_context())\n\n    def test_zero_delay_limit(self):\n        \"\"\"Test zero delay_limit processes request successfully.\"\"\"\n        with patch('requests.get') as mock_get:\n            mock_response = MagicMock()\n            mock_response.status_code = 200\n            mock_response.text = 'Zero delay success'\n            mock_get.return_value = mock_response\n            \n            result = validated_https_query('https://example.com', 0)\n            self.assertEqual(result, 'Zero delay success')\n            mock_get.assert_called_once_with('https://example.com', timeout=0, verify=ssl.create_default_context())\n\n    def test_large_delay_limit(self):\n        \"\"\"Test large delay_limit processes request successfully.\"\"\"\n        with patch('requests.get') as mock_get:\n            mock_response = MagicMock()\n            mock_response.status_code = 200\n            mock_response.text = 'Large delay success'\n            mock_get.return_value = mock_response\n            \n            result = validated_https_query('https://example.com', 3600)\n            self.assertEqual(result, 'Large delay success')\n            mock_get.assert_called_once_with('https://example.com', timeout=3600, verify=ssl.create_default_context())\n\n    def test_negative_delay_limit(self):\n        \"\"\"Test negative delay_limit raises ValueError during request.\"\"\"\n        with patch('requests.get') as mock_get:\n            mock_get.side_effect = ValueError('Timeout cannot be negative')\n            \n            with self.assertRaises(ValueError) as cm:\n                validated_https_query('https://example.com', -1)\n            self.assertIn('Timeout cannot be negative', str(cm.exception))\n            mock_get.assert_called_once_with('https://example.com', timeout=-1, verify=ssl.create_default_context())\n", "num_test_cases": 10, "task_id": "fbecd828"}
{"test": "import unittest\nfrom unittest.mock import patch, MagicMock\nimport requests\nimport ssl\n\nclass TestHttpsSecureRequest(unittest.TestCase):\n\n    @patch('requests.get')\n    def test_success(self, mock_get):\n        \"\"\"Test successful request with valid URL and wait_time.\"\"\"\n        mock_response = MagicMock()\n        mock_response.status_code = 200\n        mock_response.text = 'Success content'\n        mock_get.return_value = mock_response\n        \n        result = https_secure_request('https://valid-url.com', 5)\n        self.assertEqual(result, 'Success content')\n\n    @patch('requests.get')\n    def test_http_error(self, mock_get):\n        \"\"\"Test non-200 status code triggers RequestException.\"\"\"\n        mock_response = MagicMock()\n        mock_response.status_code = 404\n        mock_response.raise_for_status.side_effect = requests.exceptions.HTTPError('404 Error')\n        mock_get.return_value = mock_response\n        \n        with self.assertRaises(requests.exceptions.RequestException):\n            https_secure_request('https://invalid-url.com', 5)\n\n    @patch('requests.get')\n    def test_ssl_error(self, mock_get):\n        \"\"\"Test SSL certificate failure triggers SSLError.\"\"\"\n        mock_get.side_effect = requests.exceptions.SSLError('SSL failure')\n        \n        with self.assertRaises(requests.exceptions.SSLError):\n            https_secure_request('https://invalid-ssl.com', 5)\n\n    @patch('requests.get')\n    def test_timeout_error(self, mock_get):\n        \"\"\"Test timeout triggers RequestException.\"\"\"\n        mock_get.side_effect = requests.exceptions.Timeout('Request timed out')\n        \n        with self.assertRaises(requests.exceptions.RequestException):\n            https_secure_request('https://slow-url.com', 1)\n\n    @patch('requests.get')\n    def test_connection_error(self, mock_get):\n        \"\"\"Test connection failure triggers RequestException.\"\"\"\n        mock_get.side_effect = requests.exceptions.ConnectionError('Connection failed')\n        \n        with self.assertRaises(requests.exceptions.RequestException):\n            https_secure_request('https://unreachable-url.com', 5)\n\n    @patch('requests.get')\n    def test_invalid_wait_time_negative(self, mock_get):\n        \"\"\"Test negative wait_time raises ValueError.\"\"\"\n        with self.assertRaises(ValueError):\n            https_secure_request('https://valid-url.com', -1)\n\n    @patch('requests.get')\n    def test_wait_time_zero(self, mock_get):\n        \"\"\"Test zero wait_time with successful request.\"\"\"\n        mock_response = MagicMock()\n        mock_response.status_code = 200\n        mock_response.text = 'Zero timeout content'\n        mock_get.return_value = mock_response\n        \n        result = https_secure_request('https://fast-response.com', 0)\n        self.assertEqual(result, 'Zero timeout content')\n\n    @patch('requests.get')\n    def test_empty_response(self, mock_get):\n        \"\"\"Test handling of empty response content.\"\"\"\n        mock_response = MagicMock()\n        mock_response.status_code = 200\n        mock_response.text = ''\n        mock_get.return_value = mock_response\n        \n        result = https_secure_request('https://empty-content.com', 5)\n        self.assertEqual(result, '')\n\n    @patch('requests.get')\n    @patch('ssl.create_default_context')\n    def test_ssl_context_used(self, mock_create_context, mock_get):\n        \"\"\"Test SSL context creation and usage in request.\"\"\"\n        mock_response = MagicMock()\n        mock_response.status_code = 200\n        mock_response.text = 'SSL validated'\n        mock_get.return_value = mock_response\n        \n        mock_context = MagicMock()\n        mock_create_context.return_value = mock_context\n        \n        https_secure_request('https://valid-ssl.com', 5)\n        \n        mock_create_context.assert_called_once()\n        mock_get.assert_called_once_with('https://valid-ssl.com', timeout=5, verify=mock_context)\n\n    @patch('requests.get')\n    def test_invalid_url_type(self, mock_get):\n        \"\"\"Test non-string URL raises TypeError.\"\"\"\n        with self.assertRaises(TypeError):\n            https_secure_request(12345, 5)", "num_test_cases": 10, "task_id": "85afb56d"}
{"test": "import unittest\nfrom unittest.mock import patch, Mock\nimport requests\nimport ssl\n\nclass TestHttpsRequestSecure(unittest.TestCase):\n    \n    @patch('solution.ssl.create_default_context')\n    @patch('solution.requests.get')\n    def test_successful_request(self, mock_get, mock_create_context):\n        \"\"\"Test successful request with 200 response and verify proper arguments passed.\"\"\"\n        mock_context = Mock()\n        mock_create_context.return_value = mock_context\n        mock_response = Mock()\n        mock_response.status_code = 200\n        mock_response.text = \"Success content\"\n        mock_get.return_value = mock_response\n        \n        result = https_request_secure('https://example.com', 5)\n        \n        mock_create_context.assert_called_once()\n        mock_get.assert_called_once_with('https://example.com', timeout=5, verify=mock_context)\n        mock_response.raise_for_status.assert_called_once()\n        self.assertEqual(result, \"Success content\")\n    \n    @patch('solution.requests.get')\n    def test_http_error(self, mock_get):\n        \"\"\"Test non-200 response raising RequestException.\"\"\"\n        mock_response = Mock()\n        mock_response.status_code = 404\n        mock_response.raise_for_status.side_effect = requests.exceptions.HTTPError(\"404 Error\")\n        mock_get.return_value = mock_response\n        \n        with self.assertRaises(requests.exceptions.RequestException) as cm:\n            https_request_secure('https://example.com/notfound', 5)\n        self.assertIn(\"Request failed\", str(cm.exception))\n    \n    @patch('solution.requests.get')\n    def test_ssl_error(self, mock_get):\n        \"\"\"Test SSL certificate validation failure.\"\"\"\n        mock_get.side_effect = requests.exceptions.SSLError(\"SSL failure\")\n        \n        with self.assertRaises(requests.exceptions.SSLError) as cm:\n            https_request_secure('https://invalid-ssl.example.com', 5)\n        self.assertIn(\"SSL certificate validation failed\", str(cm.exception))\n    \n    @patch('solution.requests.get')\n    def test_connection_error(self, mock_get):\n        \"\"\"Test connection failure raising RequestException.\"\"\"\n        mock_get.side_effect = requests.exceptions.ConnectionError(\"Connection failed\")\n        \n        with self.assertRaises(requests.exceptions.RequestException) as cm:\n            https_request_secure('https://unreachable.example.com', 5)\n        self.assertIn(\"Request failed\", str(cm.exception))\n    \n    @patch('solution.requests.get')\n    def test_timeout_error(self, mock_get):\n        \"\"\"Test request timeout raising RequestException.\"\"\"\n        mock_get.side_effect = requests.exceptions.Timeout(\"Request timed out\")\n        \n        with self.assertRaises(requests.exceptions.RequestException) as cm:\n            https_request_secure('https://slow.example.com', 1)\n        self.assertIn(\"Request failed\", str(cm.exception))\n    \n    @patch('solution.requests.get')\n    def test_invalid_url(self, mock_get):\n        \"\"\"Test invalid URL raising RequestException.\"\"\"\n        mock_get.side_effect = requests.exceptions.MissingSchema(\"Invalid URL\")\n        \n        with self.assertRaises(requests.exceptions.RequestException) as cm:\n            https_request_secure('invalid_url', 5)\n        self.assertIn(\"Request failed\", str(cm.exception))\n    \n    @patch('solution.requests.get')\n    def test_empty_response(self, mock_get):\n        \"\"\"Test successful request with empty response content.\"\"\"\n        mock_response = Mock()\n        mock_response.status_code = 200\n        mock_response.text = \"\"\n        mock_get.return_value = mock_response\n        \n        result = https_request_secure('https://empty.example.com', 5)\n        self.assertEqual(result, \"\")\n    \n    @patch('solution.requests.get')\n    def test_zero_timeout(self, mock_get):\n        \"\"\"Test with zero timeout duration.\"\"\"\n        mock_response = Mock()\n        mock_response.status_code = 200\n        mock_response.text = \"Zero timeout\"\n        mock_get.return_value = mock_response\n        \n        result = https_request_secure('https://example.com', 0)\n        self.assertEqual(result, \"Zero timeout\")\n        mock_get.assert_called_once_with('https://example.com', timeout=0, verify=unittest.mock.ANY)\n    \n    @patch('solution.requests.get')\n    def test_large_timeout(self, mock_get):\n        \"\"\"Test with a very large timeout value.\"\"\"\n        mock_response = Mock()\n        mock_response.status_code = 200\n        mock_response.text = \"Large timeout\"\n        mock_get.return_value = mock_response\n        \n        result = https_request_secure('https://example.com', 1000)\n        self.assertEqual(result, \"Large timeout\")\n        mock_get.assert_called_once_with('https://example.com', timeout=1000, verify=unittest.mock.ANY)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 9, "task_id": "4dffddcb"}
{"test": "import unittest\nfrom unittest.mock import patch, MagicMock\nimport requests\nimport requests.exceptions\n\nclass TestSecureHttpsConn(unittest.TestCase):\n\n    @patch('requests.get')\n    def test_success_basic(self, mock_get):\n        # Test basic successful request\n        mock_response = MagicMock()\n        mock_response.status_code = 200\n        mock_response.text = 'Hello, World!'\n        mock_get.return_value = mock_response\n        result = secure_https_conn('https://valid.com', 5)\n        self.assertEqual(result, 'Hello, World!')\n\n    @patch('requests.get')\n    def test_success_long_url(self, mock_get):\n        # Test successful request with long URL\n        mock_response = MagicMock()\n        mock_response.status_code = 200\n        mock_response.text = 'Success'\n        mock_get.return_value = mock_response\n        long_url = 'https://example.com/' + 'a' * 1000\n        result = secure_https_conn(long_url, 5)\n        self.assertEqual(result, 'Success')\n\n    @patch('requests.get')\n    def test_success_zero_delay(self, mock_get):\n        # Test successful request with zero timeout\n        mock_response = MagicMock()\n        mock_response.status_code = 200\n        mock_response.text = 'Zero delay success'\n        mock_get.return_value = mock_response\n        result = secure_https_conn('https://valid.com', 0)\n        self.assertEqual(result, 'Zero delay success')\n\n    @patch('requests.get')\n    def test_success_negative_delay(self, mock_get):\n        # Test successful request with negative timeout\n        mock_response = MagicMock()\n        mock_response.status_code = 200\n        mock_response.text = 'Negative delay success'\n        mock_get.return_value = mock_response\n        result = secure_https_conn('https://valid.com', -1)\n        self.assertEqual(result, 'Negative delay success')\n\n    @patch('requests.get')\n    def test_success_large_delay(self, mock_get):\n        # Test successful request with large timeout\n        mock_response = MagicMock()\n        mock_response.status_code = 200\n        mock_response.text = 'Large delay success'\n        mock_get.return_value = mock_response\n        result = secure_https_conn('https://valid.com', 1000000)\n        self.assertEqual(result, 'Large delay success')\n\n    @patch('requests.get')\n    def test_success_delay_none(self, mock_get):\n        # Test successful request with None timeout\n        mock_response = MagicMock()\n        mock_response.status_code = 200\n        mock_response.text = 'None delay success'\n        mock_get.return_value = mock_response\n        result = secure_https_conn('https://valid.com', None)\n        self.assertEqual(result, 'None delay success')\n\n    @patch('requests.get')\n    def test_ssl_error(self, mock_get):\n        # Test SSL certificate validation failure\n        mock_get.side_effect = requests.exceptions.SSLError('SSL failure')\n        with self.assertRaises(requests.exceptions.SSLError):\n            secure_https_conn('https://invalid-ssl.com', 5)\n\n    @patch('requests.get')\n    def test_timeout_error(self, mock_get):\n        # Test request timeout\n        mock_get.side_effect = requests.exceptions.Timeout('Timeout occurred')\n        with self.assertRaises(requests.exceptions.RequestException):\n            secure_https_conn('https://timeout.com', 1)\n\n    @patch('requests.get')\n    def test_connection_error(self, mock_get):\n        # Test connection error\n        mock_get.side_effect = requests.exceptions.ConnectionError('Connection failed')\n        with self.assertRaises(requests.exceptions.RequestException):\n            secure_https_conn('https://unreachable.com', 5)\n\n    @patch('requests.get')\n    def test_http_error(self, mock_get):\n        # Test non-200 HTTP status\n        mock_response = MagicMock()\n        mock_response.status_code = 404\n        mock_response.raise_for_status.side_effect = requests.exceptions.HTTPError('404 Error')\n        mock_get.return_value = mock_response\n        with self.assertRaises(requests.exceptions.RequestException):\n            secure_https_conn('https://notfound.com', 5)\n\n    @patch('requests.get')\n    def test_empty_endpoint(self, mock_get):\n        # Test empty URL string\n        mock_get.side_effect = requests.exceptions.MissingSchema('Invalid URL')\n        with self.assertRaises(requests.exceptions.RequestException):\n            secure_https_conn('', 5)\n\n    def test_none_endpoint(self):\n        # Test None URL\n        with self.assertRaises(TypeError):\n            secure_https_conn(None, 5)\n\n    def test_non_string_endpoint(self):\n        # Test non-string URL\n        with self.assertRaises(TypeError):\n            secure_https_conn(12345, 5)\n\n    def test_non_number_delay(self):\n        # Test non-numeric delay\n        with self.assertRaises(TypeError):\n            secure_https_conn('https://valid.com', 'five')\n\n    @patch('requests.get')\n    def test_large_response(self, mock_get):\n        # Test large response content\n        large_content = 'A' * 100000\n        mock_response = MagicMock()\n        mock_response.status_code = 200\n        mock_response.text = large_content\n        mock_get.return_value = mock_response\n        result = secure_https_conn('https://large-response.com', 5)\n        self.assertEqual(result, large_content)", "num_test_cases": 15, "task_id": "cacda665"}
{"test": "import unittest\nfrom unittest.mock import patch, MagicMock\nimport paramiko\nimport ssl\n\nclass TestUploadSftpSecure(unittest.TestCase):\n\n    @patch('paramiko.SSHClient')\n    @patch('ssl.create_default_context')\n    @patch('builtins.print')\n    def test_upload_success(self, mock_print, mock_ssl_context, mock_ssh_client):\n        \"\"\"Test successful file upload with valid parameters.\"\"\"\n        mock_ssh = mock_ssh_client.return_value\n        mock_sftp = mock_ssh.open_sftp.return_value\n        mock_wrapped_socket = mock_ssl_context.return_value.wrap_socket.return_value\n        \n        server_address = \"example.com\"\n        user = \"test_user\"\n        passkey = \"secure_password\"\n        source_file = \"/local/path/file.txt\"\n        destination_file = \"/remote/path/file.txt\"\n        \n        # Execute function\n        upload_sftp_secure(server_address, user, passkey, source_file, destination_file)\n        \n        # Verify SSL context and SSH setup\n        mock_ssl_context.assert_called_once_with()\n        mock_ssh.set_missing_host_key_policy.assert_called_once_with(paramiko.AutoAddPolicy())\n        mock_ssl_context.return_value.wrap_socket.assert_called_once_with(\n            mock_ssh.sock, server_hostname=server_address\n        )\n        mock_ssh.connect.assert_called_once_with(\n            server_address,\n            username=user,\n            password=passkey,\n            sock=mock_wrapped_socket\n        )\n        \n        # Verify SFTP operations\n        mock_ssh.open_sftp.assert_called_once()\n        mock_sftp.put.assert_called_once_with(source_file, destination_file)\n        mock_print.assert_called_once_with(f\"File uploaded successfully to {destination_file}\")\n        \n        # Verify cleanup\n        mock_sftp.close.assert_called_once()\n        mock_ssh.close.assert_called_once()\n\n    @patch('paramiko.SSHClient')\n    @patch('ssl.create_default_context')\n    def test_ssh_connection_error(self, mock_ssl_context, mock_ssh_client):\n        \"\"\"Test SSHException during SSH connection setup.\"\"\"\n        mock_ssh = mock_ssh_client.return_value\n        mock_ssh.connect.side_effect = paramiko.ssh_exception.SSHException(\"Connection failed\")\n        \n        # Execute and verify exception\n        with self.assertRaises(UnboundLocalError):\n            upload_sftp_secure(\"invalid_server\", \"user\", \"pass\", \"src.txt\", \"dest.txt\")\n        \n        # Verify cleanup not completed due to exception\n        mock_ssh.close.assert_not_called()\n\n    @patch('paramiko.SSHClient')\n    @patch('ssl.create_default_context')\n    def test_sftp_open_error(self, mock_ssl_context, mock_ssh_client):\n        \"\"\"Test SSHException when opening SFTP channel.\"\"\"\n        mock_ssh = mock_ssh_client.return_value\n        mock_ssh.open_sftp.side_effect = paramiko.ssh_exception.SSHException(\"SFTP open failed\")\n        \n        # Execute and verify exception\n        with self.assertRaises(UnboundLocalError):\n            upload_sftp_secure(\"example.com\", \"user\", \"pass\", \"src.txt\", \"dest.txt\")\n        \n        # Verify cleanup not completed\n        mock_ssh.close.assert_not_called()\n\n    @patch('paramiko.SSHClient')\n    @patch('ssl.create_default_context')\n    def test_sftp_operation_error(self, mock_ssl_context, mock_ssh_client):\n        \"\"\"Test SFTPError during file upload operation.\"\"\"\n        mock_ssh = mock_ssh_client.return_value\n        mock_sftp = mock_ssh.open_sftp.return_value\n        mock_sftp.put.side_effect = paramiko.sftp.SFTPError(\"Permission denied\")\n        \n        # Execute and verify exception\n        with self.assertRaises(paramiko.sftp.SFTPError) as context:\n            upload_sftp_secure(\"example.com\", \"user\", \"pass\", \"src.txt\", \"dest.txt\")\n        \n        # Verify exception message\n        self.assertIn(\"SFTP error: Permission denied\", str(context.exception))\n        \n        # Verify cleanup\n        mock_sftp.close.assert_called_once()\n        mock_ssh.close.assert_called_once()\n\n    @patch('paramiko.SSHClient')\n    @patch('ssl.create_default_context')\n    def test_io_error(self, mock_ssl_context, mock_ssh_client):\n        \"\"\"Test IOError when accessing local file.\"\"\"\n        mock_ssh = mock_ssh_client.return_value\n        mock_sftp = mock_ssh.open_sftp.return_value\n        mock_sftp.put.side_effect = IOError(\"File not found\")\n        \n        # Execute and verify exception\n        with self.assertRaises(IOError) as context:\n            upload_sftp_secure(\"example.com\", \"user\", \"pass\", \"missing.txt\", \"dest.txt\")\n        \n        # Verify exception message\n        self.assertIn(\"File error: File not found\", str(context.exception))\n        \n        # Verify cleanup\n        mock_sftp.close.assert_called_once()\n        mock_ssh.close.assert_called_once()\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 5, "task_id": "5d3b6441"}
{"test": "import unittest\nfrom unittest.mock import patch, MagicMock\nimport paramiko\nimport ssl\n\nclass TestSFTPUploader(unittest.TestCase):\n\n    @patch('builtins.print')\n    @patch('ssl.create_default_context')\n    @patch('paramiko.SSHClient')\n    def test_successful_upload(self, mock_ssh_client_class, mock_create_context, mock_print):\n        # Test successful upload with valid inputs\n        mock_ctx = mock_create_context.return_value\n        mock_ssh = mock_ssh_client_class.return_value\n        mock_sftp = mock_ssh.open_sftp.return_value\n        \n        remote_host = 'example.com'\n        user_name = 'user'\n        secret_key = 'pass'\n        file_to_upload = 'local.txt'\n        target_path = '/remote/path.txt'\n        \n        sftp_secure_uploader(remote_host, user_name, secret_key, file_to_upload, target_path)\n        \n        mock_create_context.assert_called_once()\n        mock_ssh.set_missing_host_key_policy.assert_called_once_with(paramiko.AutoAddPolicy())\n        mock_ctx.wrap_socket.assert_called_once_with(mock_ssh.sock, server_hostname=remote_host)\n        mock_ssh.connect.assert_called_once_with(\n            remote_host,\n            username=user_name,\n            password=secret_key,\n            sock=mock_ctx.wrap_socket.return_value\n        )\n        mock_ssh.open_sftp.assert_called_once()\n        mock_sftp.put.assert_called_once_with(file_to_upload, target_path)\n        mock_sftp.close.assert_called_once()\n        mock_ssh.close.assert_called_once()\n        mock_print.assert_called_once_with(f'File uploaded successfully to {target_path}')\n\n    @patch('ssl.create_default_context')\n    @patch('paramiko.SSHClient')\n    def test_ssh_connect_exception(self, mock_ssh_client_class, mock_create_context):\n        # Test SSHException during SSH connection\n        mock_ssh = mock_ssh_client_class.return_value\n        mock_ssh.connect.side_effect = paramiko.ssh_exception.SSHException('Connection failed')\n        \n        with self.assertRaises(UnboundLocalError):\n            sftp_secure_uploader('example.com', 'user', 'pass', 'local.txt', '/remote.txt')\n        \n        mock_ssh.close.assert_not_called()\n\n    @patch('ssl.create_default_context')\n    @patch('paramiko.SSHClient')\n    def test_open_sftp_exception(self, mock_ssh_client_class, mock_create_context):\n        # Test SSHException during SFTP channel opening\n        mock_ssh = mock_ssh_client_class.return_value\n        mock_ssh.open_sftp.side_effect = paramiko.ssh_exception.SSHException('SFTP open failed')\n        \n        with self.assertRaises(UnboundLocalError):\n            sftp_secure_uploader('example.com', 'user', 'pass', 'local.txt', '/remote.txt')\n        \n        mock_ssh.close.assert_not_called()\n\n    @patch('ssl.create_default_context')\n    @patch('paramiko.SSHClient')\n    def test_sftp_put_exception(self, mock_ssh_client_class, mock_create_context):\n        # Test SFTPError during file upload\n        mock_ssh = mock_ssh_client_class.return_value\n        mock_sftp = mock_ssh.open_sftp.return_value\n        mock_sftp.put.side_effect = paramiko.sftp.SFTPError('Upload failed')\n        \n        with self.assertRaises(paramiko.sftp.SFTPError) as context:\n            sftp_secure_uploader('example.com', 'user', 'pass', 'local.txt', '/remote.txt')\n        \n        self.assertEqual(str(context.exception), 'SFTP error: Upload failed')\n        mock_sftp.close.assert_called_once()\n        mock_ssh.close.assert_called_once()\n\n    @patch('ssl.create_default_context')\n    @patch('paramiko.SSHClient')\n    def test_ioerror_put_exception(self, mock_ssh_client_class, mock_create_context):\n        # Test IOError during file access\n        mock_ssh = mock_ssh_client_class.return_value\n        mock_sftp = mock_ssh.open_sftp.return_value\n        mock_sftp.put.side_effect = IOError('File not found')\n        \n        with self.assertRaises(IOError) as context:\n            sftp_secure_uploader('example.com', 'user', 'pass', 'local.txt', '/remote.txt')\n        \n        self.assertEqual(str(context.exception), 'File error: File not found')\n        mock_sftp.close.assert_called_once()\n        mock_ssh.close.assert_called_once()\n\n    @patch('paramiko.SSHClient')\n    @patch('ssl.create_default_context')\n    def test_ssl_context_failure(self, mock_create_context, mock_ssh_client_class):\n        # Test SSL context creation failure\n        mock_create_context.side_effect = ssl.SSLError('SSL failure')\n        \n        with self.assertRaises(ssl.SSLError):\n            sftp_secure_uploader('example.com', 'user', 'pass', 'local.txt', '/remote.txt')\n        \n        mock_ssh_client_class.assert_not_called()\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 6, "task_id": "d16bee27"}
{"test": "import unittest\nfrom unittest.mock import patch, Mock\nimport paramiko\n\nclass TestSecureFileTransfer(unittest.TestCase):\n\n    @patch('ssl.create_default_context')\n    @patch('paramiko.SSHClient')\n    def test_successful_transfer(self, mock_ssh_client_class, mock_create_context):\n        \"\"\"Test successful file upload with valid parameters.\"\"\"\n        mock_ssh = mock_ssh_client_class.return_value\n        mock_context = mock_create_context.return_value\n        mock_wrapped_socket = Mock()\n        mock_context.wrap_socket.return_value = mock_wrapped_socket\n        mock_sftp = mock_ssh.open_sftp.return_value\n        \n        secure_file_transfer_sftp('sftp.example.com', 'user', 'password', '/local/file.txt', '/remote/file.txt')\n        \n        mock_create_context.assert_called_once()\n        mock_ssh.set_missing_host_key_policy.assert_called_once_with(paramiko.AutoAddPolicy())\n        mock_context.wrap_socket.assert_called_once_with(mock_ssh.sock, server_hostname='sftp.example.com')\n        mock_ssh.connect.assert_called_once_with('sftp.example.com', username='user', password='password', sock=mock_wrapped_socket)\n        mock_ssh.open_sftp.assert_called_once()\n        mock_sftp.put.assert_called_once_with('/local/file.txt', '/remote/file.txt')\n        mock_sftp.close.assert_called_once()\n        mock_ssh.close.assert_called_once()\n\n    @patch('ssl.create_default_context')\n    @patch('paramiko.SSHClient')\n    def test_ssh_exception_during_connect(self, mock_ssh_client_class, mock_create_context):\n        \"\"\"Test SSHException during connection establishment.\"\"\"\n        mock_ssh = mock_ssh_client_class.return_value\n        mock_ssh.connect.side_effect = paramiko.ssh_exception.SSHException(\"Connection failed\")\n        \n        with self.assertRaises(paramiko.ssh_exception.SSHException) as context:\n            secure_file_transfer_sftp('invalid.server', 'user', 'pass', '/local/file.txt', '/remote/file.txt')\n            \n        self.assertIn(\"SSH connection error:\", str(context.exception))\n        mock_ssh.close.assert_called_once()\n\n    @patch('ssl.create_default_context')\n    @patch('paramiko.SSHClient')\n    def test_sftp_error_during_upload(self, mock_ssh_client_class, mock_create_context):\n        \"\"\"Test SFTPError during file upload operation.\"\"\"\n        mock_ssh = mock_ssh_client_class.return_value\n        mock_sftp = mock_ssh.open_sftp.return_value\n        mock_sftp.put.side_effect = paramiko.sftp.SFTPError(\"Permission denied\")\n        \n        with self.assertRaises(paramiko.sftp.SFTPError) as context:\n            secure_file_transfer_sftp('sftp.example.com', 'user', 'pass', '/local/file.txt', '/remote/file.txt')\n            \n        self.assertIn(\"SFTP error:\", str(context.exception))\n        mock_sftp.close.assert_called_once()\n        mock_ssh.close.assert_called_once()\n\n    @patch('ssl.create_default_context')\n    @patch('paramiko.SSHClient')\n    def test_ioerror_during_upload(self, mock_ssh_client_class, mock_create_context):\n        \"\"\"Test IOError when local file is inaccessible.\"\"\"\n        mock_ssh = mock_ssh_client_class.return_value\n        mock_sftp = mock_ssh.open_sftp.return_value\n        mock_sftp.put.side_effect = IOError(\"File not found\")\n        \n        with self.assertRaises(IOError) as context:\n            secure_file_transfer_sftp('sftp.example.com', 'user', 'pass', '/nonexistent/file.txt', '/remote/file.txt')\n            \n        self.assertIn(\"File error:\", str(context.exception))\n        mock_sftp.close.assert_called_once()\n        mock_ssh.close.assert_called_once()\n\n    @patch('ssl.create_default_context')\n    @patch('paramiko.SSHClient')\n    def test_type_error_with_none_server(self, mock_ssh_client_class, mock_create_context):\n        \"\"\"Test TypeError when sftp_server is None.\"\"\"\n        mock_ssh = mock_ssh_client_class.return_value\n        mock_ssh.connect.side_effect = TypeError(\"host must be a string\")\n        \n        with self.assertRaises(TypeError):\n            secure_file_transfer_sftp(None, 'user', 'pass', '/local/file.txt', '/remote/file.txt')\n", "num_test_cases": 5, "task_id": "48b46f63"}
{"test": "import unittest\nfrom unittest.mock import patch, MagicMock\nimport paramiko.ssh_exception\nimport paramiko.sftp\nfrom solution import secure_sftp_transfer\n\nclass TestSFTPTransfer(unittest.TestCase):\n\n    @patch('ssl.create_default_context')\n    @patch('paramiko.SSHClient')\n    def test_successful_upload(self, mock_ssh_class, mock_ssl_context):\n        \"\"\"Test successful file upload scenario.\"\"\"\n        mock_ssh = mock_ssh_class.return_value\n        mock_ctx = MagicMock()\n        mock_ssl_context.return_value = mock_ctx\n        mock_sock = MagicMock()\n        mock_ctx.wrap_socket.return_value = mock_sock\n        mock_sftp = mock_ssh.open_sftp.return_value\n        \n        with patch('builtins.print') as mock_print:\n            secure_sftp_transfer('example.com', 'user', 'pass', 'local.txt', '/remote.txt')\n            \n            mock_ssh.set_missing_host_key_policy.assert_called_with(paramiko.AutoAddPolicy())\n            mock_ssh.connect.assert_called_with(\n                'example.com',\n                username='user',\n                password='pass',\n                sock=mock_sock,\n                server_hostname='example.com'\n            )\n            mock_ssh.open_sftp.assert_called_once()\n            mock_sftp.put.assert_called_with('local.txt', '/remote.txt')\n            mock_sftp.close.assert_called_once()\n            mock_ssh.close.assert_called_once()\n            mock_print.assert_called_once_with(\"File uploaded successfully to /remote.txt\")\n\n    @patch('ssl.create_default_context')\n    @patch('paramiko.SSHClient')\n    def test_ssh_connection_failure(self, mock_ssh_class, mock_ssl_context):\n        \"\"\"Test SSHException during SSH connection setup.\"\"\"\n        mock_ssh = mock_ssh_class.return_value\n        mock_ctx = MagicMock()\n        mock_ssl_context.return_value = mock_ctx\n        mock_sock = MagicMock()\n        mock_ctx.wrap_socket.return_value = mock_sock\n        mock_ssh.connect.side_effect = paramiko.ssh_exception.SSHException(\"Connection failed\")\n        \n        with self.assertRaises(paramiko.ssh_exception.SSHException):\n            secure_sftp_transfer('example.com', 'user', 'pass', 'local.txt', '/remote.txt')\n            \n        mock_ssh.close.assert_not_called()\n\n    @patch('ssl.create_default_context')\n    @patch('paramiko.SSHClient')\n    def test_sftp_error_during_put(self, mock_ssh_class, mock_ssl_context):\n        \"\"\"Test SFTPError during file transfer.\"\"\"\n        mock_ssh = mock_ssh_class.return_value\n        mock_ctx = MagicMock()\n        mock_ssl_context.return_value = mock_ctx\n        mock_sock = MagicMock()\n        mock_ctx.wrap_socket.return_value = mock_sock\n        mock_sftp = mock_ssh.open_sftp.return_value\n        mock_sftp.put.side_effect = paramiko.sftp.SFTPError(\"SFTP error\")\n        \n        with self.assertRaises(paramiko.sftp.SFTPError):\n            secure_sftp_transfer('example.com', 'user', 'pass', 'local.txt', '/remote.txt')\n            \n        mock_sftp.close.assert_called_once()\n        mock_ssh.close.assert_called_once()\n\n    @patch('ssl.create_default_context')\n    @patch('paramiko.SSHClient')\n    def test_io_error_during_put(self, mock_ssh_class, mock_ssl_context):\n        \"\"\"Test IOError during file transfer.\"\"\"\n        mock_ssh = mock_ssh_class.return_value\n        mock_ctx = MagicMock()\n        mock_ssl_context.return_value = mock_ctx\n        mock_sock = MagicMock()\n        mock_ctx.wrap_socket.return_value = mock_sock\n        mock_sftp = mock_ssh.open_sftp.return_value\n        mock_sftp.put.side_effect = IOError(\"File not found\")\n        \n        with self.assertRaises(IOError):\n            secure_sftp_transfer('example.com', 'user', 'pass', 'local.txt', '/remote.txt')\n            \n        mock_sftp.close.assert_called_once()\n        mock_ssh.close.assert_called_once()\n\n    @patch('ssl.create_default_context')\n    @patch('paramiko.SSHClient')\n    def test_ssh_exception_during_open_sftp(self, mock_ssh_class, mock_ssl_context):\n        \"\"\"Test UnboundLocalError when open_sftp fails and finally block crashes.\"\"\"\n        mock_ssh = mock_ssh_class.return_value\n        mock_ctx = MagicMock()\n        mock_ssl_context.return_value = mock_ctx\n        mock_sock = MagicMock()\n        mock_ctx.wrap_socket.return_value = mock_sock\n        mock_ssh.open_sftp.side_effect = paramiko.ssh_exception.SSHException(\"open_sftp failed\")\n        \n        with self.assertRaises(UnboundLocalError):\n            secure_sftp_transfer('example.com', 'user', 'pass', 'local.txt', '/remote.txt')\n            \n        mock_ssh.close.assert_not_called()\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 5, "task_id": "5b93b853"}
{"test": "import unittest\nfrom unittest.mock import patch, Mock, call\nimport paramiko\nimport ssl\n\nclass TestSecureSSHUpload(unittest.TestCase):\n\n    @patch('paramiko.SSHClient')\n    def test_successful_upload(self, mock_ssh_class):\n        \"\"\"Test successful file upload scenario.\"\"\"\n        mock_ssh = mock_ssh_class.return_value\n        mock_sftp = mock_ssh.open_sftp.return_value\n        \n        # Call the function\n        secure_ssh_upload('example.com', 'user', 'pass', 'local.txt', 'remote.txt')\n        \n        # Verify SSH setup and connection\n        mock_ssh.set_missing_host_key_policy.assert_called_once_with(paramiko.AutoAddPolicy())\n        mock_ssh.connect.assert_called_once_with(\n            'example.com',\n            username='user',\n            password='pass',\n            sock=unittest.mock.ANY  # Skip exact socket validation\n        )\n        mock_ssh.open_sftp.assert_called_once()\n        mock_sftp.put.assert_called_once_with('local.txt', 'remote.txt')\n        mock_sftp.close.assert_called_once()\n        mock_ssh.close.assert_called_once()\n\n    @patch('paramiko.SSHClient')\n    def test_ssh_connect_exception(self, mock_ssh_class):\n        \"\"\"Test SSH connection failure during connect.\"\"\"\n        mock_ssh = mock_ssh_class.return_value\n        mock_ssh.connect.side_effect = paramiko.ssh_exception.SSHException(\"Connection failed\")\n        \n        with self.assertRaises(paramiko.ssh_exception.SSHException):\n            secure_ssh_upload('example.com', 'user', 'pass', 'local.txt', 'remote.txt')\n        \n        mock_ssh.close.assert_not_called()  # Finally block skipped\n\n    @patch('paramiko.SSHClient')\n    def test_sftp_open_exception(self, mock_ssh_class):\n        \"\"\"Test exception during SFTP channel opening.\"\"\"\n        mock_ssh = mock_ssh_class.return_value\n        mock_ssh.open_sftp.side_effect = paramiko.ssh_exception.SSHException(\"SFTP open failed\")\n        \n        with self.assertRaises(NameError):  # Due to undefined sftp in finally\n            secure_ssh_upload('example.com', 'user', 'pass', 'local.txt', 'remote.txt')\n        \n        mock_ssh.close.assert_called_once()  # ssh.close() runs in finally\n\n    @patch('paramiko.SSHClient')\n    def test_sftp_put_exception(self, mock_ssh_class):\n        \"\"\"Test SFTPError during file transfer.\"\"\"\n        mock_ssh = mock_ssh_class.return_value\n        mock_sftp = mock_ssh.open_sftp.return_value\n        mock_sftp.put.side_effect = paramiko.sftp.SFTPError(\"Upload failed\")\n        \n        with self.assertRaises(paramiko.sftp.SFTPError) as context:\n            secure_ssh_upload('example.com', 'user', 'pass', 'local.txt', 'remote.txt')\n        self.assertIn(\"SFTP error\", str(context.exception))\n        \n        mock_sftp.close.assert_called_once()\n        mock_ssh.close.assert_called_once()\n\n    @patch('paramiko.SSHClient')\n    def test_ioerror_during_put(self, mock_ssh_class):\n        \"\"\"Test IOError during file read/access.\"\"\"\n        mock_ssh = mock_ssh_class.return_value\n        mock_sftp = mock_ssh.open_sftp.return_value\n        mock_sftp.put.side_effect = IOError(\"File not found\")\n        \n        with self.assertRaises(IOError) as context:\n            secure_ssh_upload('example.com', 'user', 'pass', 'local.txt', 'remote.txt')\n        self.assertIn(\"File error\", str(context.exception))\n        \n        mock_sftp.close.assert_called_once()\n        mock_ssh.close.assert_called_once()\n\n    @patch('paramiko.SSHClient')\n    def test_empty_credentials(self, mock_ssh_class):\n        \"\"\"Test behavior with empty server address and credentials.\"\"\"\n        mock_ssh = mock_ssh_class.return_value\n        \n        with self.assertRaises(paramiko.ssh_exception.SSHException):\n            secure_ssh_upload('', '', '', 'local.txt', 'remote.txt')\n        \n        mock_ssh.close.assert_not_called()\n\n    @patch('paramiko.SSHClient')\n    def test_nonexistent_local_file(self, mock_ssh_class):\n        \"\"\"Test with non-existent local file path.\"\"\"\n        mock_ssh = mock_ssh_class.return_value\n        mock_sftp = mock_ssh.open_sftp.return_value\n        mock_sftp.put.side_effect = IOError(\"No such file\")\n        \n        with self.assertRaises(IOError) as context:\n            secure_ssh_upload('example.com', 'user', 'pass', 'missing.txt', 'remote.txt')\n        self.assertIn(\"File error\", str(context.exception))\n        \n        mock_sftp.close.assert_called_once()\n        mock_ssh.close.assert_called_once()\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 7, "task_id": "8718da10"}
{"test": "import unittest\nfrom unittest.mock import patch, MagicMock\nimport paramiko\nimport ssl\n\nclass TestSecureFileTransfer(unittest.TestCase):\n\n    @patch('paramiko.SSHClient')\n    @patch('ssl.create_default_context')\n    def test_successful_upload(self, mock_ssl_context, mock_ssh_client):\n        \"\"\"Test successful file upload scenario.\"\"\"\n        # Setup mock objects\n        mock_ssh = mock_ssh_client.return_value\n        mock_sftp = mock_ssh.open_sftp.return_value\n        mock_ssl_context.return_value.wrap_socket.return_value = 'wrapped_socket'\n        mock_ssh.sock = 'dummy_socket'  # Mock the socket attribute\n        \n        # Call the function\n        secure_file_transfer('ftp.example.com', 'user', 'pass', '/local/file.txt', '/remote/file.txt')\n        \n        # Assert correct calls and cleanups\n        mock_ssl_context.assert_called_once()\n        mock_ssh.set_missing_host_key_policy.assert_called_once_with(paramiko.AutoAddPolicy())\n        mock_ssl_context.return_value.wrap_socket.assert_called_once_with('dummy_socket', server_hostname='ftp.example.com')\n        mock_ssh.connect.assert_called_once_with('ftp.example.com', username='user', password='pass', sock='wrapped_socket')\n        mock_ssh.open_sftp.assert_called_once()\n        mock_sftp.put.assert_called_once_with('/local/file.txt', '/remote/file.txt')\n        mock_sftp.close.assert_called_once()\n        mock_ssh.close.assert_called_once()\n\n    @patch('paramiko.SSHClient')\n    @patch('ssl.create_default_context')\n    def test_ssh_connection_error(self, mock_ssl_context, mock_ssh_client):\n        \"\"\"Test SSHException during connection setup.\"\"\"\n        mock_ssh = mock_ssh_client.return_value\n        mock_ssh.connect.side_effect = paramiko.ssh_exception.SSHException('Connection failed')\n        \n        # Expect NameError due to undefined sftp in finally block\n        with self.assertRaises(NameError):\n            secure_file_transfer('invalid.host', 'user', 'pass', '/local/file.txt', '/remote/file.txt')\n        \n        # Verify cleanup was attempted despite error\n        mock_ssh.close.assert_called_once()\n\n    @patch('paramiko.SSHClient')\n    @patch('ssl.create_default_context')\n    def test_sftp_transfer_error(self, mock_ssl_context, mock_ssh_client):\n        \"\"\"Test SFTPError during file transfer.\"\"\"\n        mock_ssh = mock_ssh_client.return_value\n        mock_sftp = mock_ssh.open_sftp.return_value\n        mock_sftp.put.side_effect = paramiko.sftp.SFTPError('Transfer failed')\n        \n        with self.assertRaises(paramiko.sftp.SFTPError):\n            secure_file_transfer('ftp.example.com', 'user', 'pass', '/local/file.txt', '/remote/file.txt')\n        \n        # Verify resources are cleaned up\n        mock_sftp.close.assert_called_once()\n        mock_ssh.close.assert_called_once()\n\n    @patch('paramiko.SSHClient')\n    @patch('ssl.create_default_context')\n    def test_file_access_error(self, mock_ssl_context, mock_ssh_client):\n        \"\"\"Test IOError when accessing local file.\"\"\"\n        mock_ssh = mock_ssh_client.return_value\n        mock_sftp = mock_ssh.open_sftp.return_value\n        mock_sftp.put.side_effect = IOError('File not found')\n        \n        with self.assertRaises(IOError):\n            secure_file_transfer('ftp.example.com', 'user', 'pass', '/missing/file.txt', '/remote/file.txt')\n        \n        # Verify resources are cleaned up\n        mock_sftp.close.assert_called_once()\n        mock_ssh.close.assert_called_once()\n\n    @patch('paramiko.SSHClient')\n    @patch('ssl.create_default_context')\n    def test_open_sftp_error(self, mock_ssl_context, mock_ssh_client):\n        \"\"\"Test SSHException during SFTP channel opening.\"\"\"\n        mock_ssh = mock_ssh_client.return_value\n        mock_ssh.open_sftp.side_effect = paramiko.ssh_exception.SSHException('SFTP failed')\n        \n        # Expect NameError due to undefined sftp in finally block\n        with self.assertRaises(NameError):\n            secure_file_transfer('ftp.example.com', 'user', 'pass', '/local/file.txt', '/remote/file.txt')\n        \n        # Verify cleanup was attempted\n        mock_ssh.close.assert_called_once()\n\n    @patch('paramiko.SSHClient')\n    @patch('ssl.create_default_context')\n    def test_empty_credentials(self, mock_ssl_context, mock_ssh_client):\n        \"\"\"Test with empty username and password.\"\"\"\n        mock_ssh = mock_ssh_client.return_value\n        \n        # Empty credentials might cause authentication failure\n        with self.assertRaises(Exception):\n            secure_file_transfer('ftp.example.com', '', '', '/local/file.txt', '/remote/file.txt')\n        \n        # Verify connection was attempted and cleanup done\n        mock_ssh.connect.assert_called_once()\n        mock_ssh.close.assert_called_once()\n\n    @patch('paramiko.SSHClient')\n    @patch('ssl.create_default_context')\n    def test_none_paths(self, mock_ssl_context, mock_ssh_client):\n        \"\"\"Test with None as source or destination path.\"\"\"\n        mock_ssh = mock_ssh_client.return_value\n        mock_sftp = mock_ssh.open_sftp.return_value\n        \n        # Test with None source path\n        with self.assertRaises(IOError):\n            secure_file_transfer('ftp.example.com', 'user', 'pass', None, '/remote/file.txt')\n        \n        # Test with None destination path\n        with self.assertRaises(paramiko.sftp.SFTPError):\n            secure_file_transfer('ftp.example.com', 'user', 'pass', '/local/file.txt', None)\n", "num_test_cases": 7, "task_id": "68f8c306"}
{"test": "import unittest\nfrom unittest.mock import patch, MagicMock\nimport paramiko\nimport ssl\n\nclass TestUploadSFTPSecurely(unittest.TestCase):\n\n    @patch('ssl.create_default_context')\n    @patch('paramiko.SSHClient')\n    @patch('builtins.print')\n    def test_happy_path(self, mock_print, mock_ssh_client, mock_ssl_ctx):\n        # Test successful file upload with valid parameters\n        server_address = 'sftp.example.com'\n        user_id = 'user123'\n        user_password = 'pass123'\n        file_local = 'local.txt'\n        file_remote = 'remote.txt'\n        \n        mock_ssh_instance = MagicMock()\n        mock_sftp_instance = MagicMock()\n        mock_ssl_context = MagicMock()\n        mock_socket = MagicMock()\n        \n        mock_ssh_client.return_value = mock_ssh_instance\n        mock_ssl_ctx.return_value = mock_ssl_context\n        mock_ssl_context.wrap_socket.return_value = mock_socket\n        mock_ssh_instance.open_sftp.return_value = mock_sftp_instance\n        \n        upload_sftp_securely(server_address, user_id, user_password, file_local, file_remote)\n        \n        mock_ssl_ctx.assert_called_once()\n        mock_ssh_client.assert_called_once()\n        mock_ssh_instance.set_missing_host_key_policy.assert_called_once_with(paramiko.AutoAddPolicy)\n        mock_ssl_context.wrap_socket.assert_called_once_with(mock_ssh_instance.sock, server_hostname=server_address)\n        mock_ssh_instance.connect.assert_called_once_with(\n            server_address,\n            username=user_id,\n            password=user_password,\n            sock=mock_socket\n        )\n        mock_ssh_instance.open_sftp.assert_called_once()\n        mock_sftp_instance.put.assert_called_once_with(file_local, file_remote)\n        mock_print.assert_called_once_with(f'File uploaded successfully to {file_remote}')\n        mock_sftp_instance.close.assert_called_once()\n        mock_ssh_instance.close.assert_called_once()\n\n    @patch('ssl.create_default_context')\n    @patch('paramiko.SSHClient')\n    def test_ssh_connection_failure(self, mock_ssh_client, mock_ssl_ctx):\n        # Test SSHException during connection establishment\n        mock_ssh_instance = MagicMock()\n        mock_ssl_context = MagicMock()\n        mock_ssh_client.return_value = mock_ssh_instance\n        mock_ssl_ctx.return_value = mock_ssl_context\n        \n        mock_ssh_instance.connect.side_effect = paramiko.ssh_exception.SSHException('Connection failed')\n        \n        with self.assertRaises(paramiko.ssh_exception.SSHException):\n            upload_sftp_securely('sftp.example.com', 'user', 'pass', 'local.txt', 'remote.txt')\n        \n        mock_ssh_instance.close.assert_not_called()\n\n    @patch('ssl.create_default_context')\n    @patch('paramiko.SSHClient')\n    def test_sftp_error(self, mock_ssh_client, mock_ssl_ctx):\n        # Test SFTPError during file upload\n        mock_ssh_instance = MagicMock()\n        mock_sftp_instance = MagicMock()\n        mock_ssl_context = MagicMock()\n        mock_socket = MagicMock()\n        \n        mock_ssh_client.return_value = mock_ssh_instance\n        mock_ssl_ctx.return_value = mock_ssl_context\n        mock_ssl_context.wrap_socket.return_value = mock_socket\n        mock_ssh_instance.open_sftp.return_value = mock_sftp_instance\n        \n        mock_sftp_instance.put.side_effect = paramiko.sftp.SFTPError('Permission denied')\n        \n        with self.assertRaises(paramiko.sftp.SFTPError) as cm:\n            upload_sftp_securely('sftp.example.com', 'user', 'pass', 'local.txt', 'remote.txt')\n        self.assertIn('SFTP error', str(cm.exception))\n        \n        mock_sftp_instance.close.assert_called_once()\n        mock_ssh_instance.close.assert_called_once()\n\n    @patch('ssl.create_default_context')\n    @patch('paramiko.SSHClient')\n    def test_io_error(self, mock_ssh_client, mock_ssl_ctx):\n        # Test IOError during file upload (e.g., missing local file)\n        mock_ssh_instance = MagicMock()\n        mock_sftp_instance = MagicMock()\n        mock_ssl_context = MagicMock()\n        mock_socket = MagicMock()\n        \n        mock_ssh_client.return_value = mock_ssh_instance\n        mock_ssl_ctx.return_value = mock_ssl_context\n        mock_ssl_context.wrap_socket.return_value = mock_socket\n        mock_ssh_instance.open_sftp.return_value = mock_sftp_instance\n        \n        mock_sftp_instance.put.side_effect = IOError('File not found')\n        \n        with self.assertRaises(IOError) as cm:\n            upload_sftp_securely('sftp.example.com', 'user', 'pass', 'local.txt', 'remote.txt')\n        self.assertIn('File error', str(cm.exception))\n        \n        mock_sftp_instance.close.assert_called_once()\n        mock_ssh_instance.close.assert_called_once()\n\n    @patch('ssl.create_default_context')\n    @patch('paramiko.SSHClient')\n    def test_empty_server_address(self, mock_ssh_client, mock_ssl_ctx):\n        # Test with empty server address causing connection failure\n        mock_ssh_instance = MagicMock()\n        mock_ssl_context = MagicMock()\n        mock_ssh_client.return_value = mock_ssh_instance\n        mock_ssl_ctx.return_value = mock_ssl_context\n        \n        mock_ssh_instance.connect.side_effect = paramiko.ssh_exception.SSHException('Invalid server address')\n        \n        with self.assertRaises(paramiko.ssh_exception.SSHException):\n            upload_sftp_securely('', 'user', 'pass', 'local.txt', 'remote.txt')\n        \n        mock_ssh_instance.close.assert_not_called()\n\n    @patch('ssl.create_default_context')\n    @patch('paramiko.SSHClient')\n    def test_empty_local_file(self, mock_ssh_client, mock_ssl_ctx):\n        # Test IOError when local file path is empty\n        mock_ssh_instance = MagicMock()\n        mock_sftp_instance = MagicMock()\n        mock_ssl_context = MagicMock()\n        mock_socket = MagicMock()\n        \n        mock_ssh_client.return_value = mock_ssh_instance\n        mock_ssl_ctx.return_value = mock_ssl_context\n        mock_ssl_context.wrap_socket.return_value = mock_socket\n        mock_ssh_instance.open_sftp.return_value = mock_sftp_instance\n        \n        mock_sftp_instance.put.side_effect = IOError('No such file')\n        \n        with self.assertRaises(IOError) as cm:\n            upload_sftp_securely('sftp.example.com', 'user', 'pass', '', 'remote.txt')\n        self.assertIn('File error', str(cm.exception))\n        \n        mock_sftp_instance.close.assert_called_once()\n        mock_ssh_instance.close.assert_called_once()\n\n    @patch('ssl.create_default_context')\n    @patch('paramiko.SSHClient')\n    def test_incorrect_key_length(self, mock_ssh_client, mock_ssl_ctx):\n        # Test invalid key format causing connection failure\n        mock_ssh_instance = MagicMock()\n        mock_ssl_context = MagicMock()\n        mock_ssh_client.return_value = mock_ssh_instance\n        mock_ssl_ctx.return_value = mock_ssl_context\n        \n        mock_ssl_context.wrap_socket.side_effect = ssl.SSLError('Certificate validation failed')\n        \n        with self.assertRaises(ssl.SSLError):\n            upload_sftp_securely('invalid.host', 'user', 'pass', 'local.txt', 'remote.txt')\n        \n        mock_ssh_instance.close.assert_not_called()\n", "num_test_cases": 7, "task_id": "dd33e7b8"}
{"test": "import unittest\nfrom unittest.mock import patch, Mock\nimport paramiko\nimport ssl\nfrom solution import upload_file_securely\n\nclass TestCases(unittest.TestCase):\n    @patch('solution.ssl.create_default_context')\n    @patch('solution.paramiko.SSHClient')\n    def test_happy_path(self, mock_ssh_client, mock_create_context):\n        \"\"\"Test successful file upload with valid parameters.\"\"\"\n        mock_ssh = mock_ssh_client.return_value\n        mock_sftp = mock_ssh.open_sftp.return_value\n        mock_context = mock_create_context.return_value\n        \n        upload_file_securely('host', 'user', 'pass', 'local.txt', 'remote.txt')\n        \n        mock_create_context.assert_called_once()\n        mock_ssh.set_missing_host_key_policy.assert_called_once_with(paramiko.AutoAddPolicy())\n        mock_ssh.connect.assert_called_once_with(\n            'host',\n            username='user',\n            password='pass',\n            sock=mock_context.wrap_socket.return_value\n        )\n        mock_context.wrap_socket.assert_called_once_with(mock_ssh.sock, server_hostname='host')\n        mock_ssh.open_sftp.assert_called_once()\n        mock_sftp.put.assert_called_once_with('local.txt', 'remote.txt')\n        mock_sftp.close.assert_called_once()\n        mock_ssh.close.assert_called_once()\n\n    @patch('solution.ssl.create_default_context')\n    @patch('solution.paramiko.SSHClient')\n    def test_ssh_connect_exception(self, mock_ssh_client, mock_create_context):\n        \"\"\"Test SSHException during SSH connection setup.\"\"\"\n        mock_ssh = mock_ssh_client.return_value\n        mock_ssh.connect.side_effect = paramiko.ssh_exception.SSHException(\"Connection failed\")\n        \n        with self.assertRaises(NameError):\n            upload_file_securely('host', 'user', 'pass', 'local.txt', 'remote.txt')\n\n    @patch('solution.ssl.create_default_context')\n    @patch('solution.paramiko.SSHClient')\n    def test_open_sftp_exception(self, mock_ssh_client, mock_create_context):\n        \"\"\"Test SSHException during SFTP channel opening.\"\"\"\n        mock_ssh = mock_ssh_client.return_value\n        mock_ssh.open_sftp.side_effect = paramiko.ssh_exception.SSHException(\"SFTP open failed\")\n        \n        with self.assertRaises(NameError):\n            upload_file_securely('host', 'user', 'pass', 'local.txt', 'remote.txt')\n\n    @patch('solution.ssl.create_default_context')\n    @patch('solution.paramiko.SSHClient')\n    def test_sftp_put_sftperror(self, mock_ssh_client, mock_create_context):\n        \"\"\"Test SFTPError during file upload.\"\"\"\n        mock_ssh = mock_ssh_client.return_value\n        mock_sftp = mock_ssh.open_sftp.return_value\n        mock_sftp.put.side_effect = paramiko.sftp.SFTPError(\"Permission denied\")\n        \n        with self.assertRaises(paramiko.sftp.SFTPError):\n            upload_file_securely('host', 'user', 'pass', 'local.txt', 'remote.txt')\n        \n        mock_sftp.close.assert_called_once()\n        mock_ssh.close.assert_called_once()\n\n    @patch('solution.ssl.create_default_context')\n    @patch('solution.paramiko.SSHClient')\n    def test_sftp_put_ioerror(self, mock_ssh_client, mock_create_context):\n        \"\"\"Test IOError during file upload.\"\"\"\n        mock_ssh = mock_ssh_client.return_value\n        mock_sftp = mock_ssh.open_sftp.return_value\n        mock_sftp.put.side_effect = IOError(\"File not found\")\n        \n        with self.assertRaises(IOError):\n            upload_file_securely('host', 'user', 'pass', 'local.txt', 'remote.txt')\n        \n        mock_sftp.close.assert_called_once()\n        mock_ssh.close.assert_called_once()\n\n    @patch('solution.ssl.create_default_context')\n    @patch('solution.paramiko.SSHClient')\n    def test_empty_host(self, mock_ssh_client, mock_create_context):\n        \"\"\"Test empty host_name raises NameError due to undefined sftp in finally.\"\"\"\n        mock_ssh = mock_ssh_client.return_value\n        mock_ssh.connect.side_effect = paramiko.ssh_exception.SSHException(\"Empty host\")\n        \n        with self.assertRaises(NameError):\n            upload_file_securely('', 'user', 'pass', 'local.txt', 'remote.txt')\n\n    @patch('solution.ssl.create_default_context')\n    @patch('solution.paramiko.SSHClient')\n    def test_empty_username(self, mock_ssh_client, mock_create_context):\n        \"\"\"Test empty user_name raises NameError due to undefined sftp in finally.\"\"\"\n        mock_ssh = mock_ssh_client.return_value\n        mock_ssh.connect.side_effect = paramiko.ssh_exception.SSHException(\"Empty username\")\n        \n        with self.assertRaises(NameError):\n            upload_file_securely('host', '', 'pass', 'local.txt', 'remote.txt')\n\n    @patch('solution.ssl.create_default_context')\n    @patch('solution.paramiko.SSHClient')\n    def test_empty_password(self, mock_ssh_client, mock_create_context):\n        \"\"\"Test empty user_pwd raises NameError due to undefined sftp in finally.\"\"\"\n        mock_ssh = mock_ssh_client.return_value\n        mock_ssh.connect.side_effect = paramiko.ssh_exception.SSHException(\"Empty password\")\n        \n        with self.assertRaises(NameError):\n            upload_file_securely('host', 'user', '', 'local.txt', 'remote.txt')\n\n    @patch('solution.ssl.create_default_context')\n    @patch('solution.paramiko.SSHClient')\n    def test_empty_source_path(self, mock_ssh_client, mock_create_context):\n        \"\"\"Test empty source_path raises IOError during file upload.\"\"\"\n        mock_ssh = mock_ssh_client.return_value\n        mock_sftp = mock_ssh.open_sftp.return_value\n        mock_sftp.put.side_effect = IOError(\"Empty source path\")\n        \n        with self.assertRaises(IOError):\n            upload_file_securely('host', 'user', 'pass', '', 'remote.txt')\n        \n        mock_sftp.close.assert_called_once()\n        mock_ssh.close.assert_called_once()\n", "num_test_cases": 9, "task_id": "f620fd1e"}
{"test": "import unittest\nfrom unittest.mock import patch, MagicMock\nimport paramiko\nimport ssl\n\nclass TestSftpSecureUpload(unittest.TestCase):\n    \n    @patch('ssl.create_default_context')\n    @patch('paramiko.SSHClient')\n    def test_successful_upload(self, mock_ssh_client_cls, mock_ssl_context):\n        \"\"\"Test successful file upload and proper resource closure.\"\"\"\n        mock_ssh = mock_ssh_client_cls.return_value\n        mock_sftp = MagicMock()\n        mock_ssh.open_sftp.return_value = mock_sftp\n        \n        sftp_secure_upload('example.com', 'user', 'password', 'local.txt', 'remote.txt')\n        \n        mock_ssl_context.assert_called_once()\n        mock_ssh.set_missing_host_key_policy.assert_called_once_with(paramiko.AutoAddPolicy())\n        mock_ssh.connect.assert_called_once_with(\n            'example.com',\n            username='user',\n            password='password',\n            sock=mock_ssl_context.return_value.wrap_socket.return_value\n        )\n        mock_ssh.open_sftp.assert_called_once()\n        mock_sftp.put.assert_called_once_with('local.txt', 'remote.txt')\n        mock_sftp.close.assert_called_once()\n        mock_ssh.close.assert_called_once()\n    \n    @patch('ssl.create_default_context')\n    @patch('paramiko.SSHClient')\n    def test_ioerror_local_file(self, mock_ssh_client_cls, mock_ssl_context):\n        \"\"\"Test IOError when local file is not found.\"\"\"\n        mock_ssh = mock_ssh_client_cls.return_value\n        mock_sftp = MagicMock()\n        mock_ssh.open_sftp.return_value = mock_sftp\n        mock_sftp.put.side_effect = IOError('File not found')\n        \n        with self.assertRaises(IOError) as cm:\n            sftp_secure_upload('example.com', 'user', 'password', 'missing.txt', 'remote.txt')\n        \n        self.assertEqual(str(cm.exception), 'File error: File not found')\n        mock_sftp.close.assert_called_once()\n        mock_ssh.close.assert_called_once()\n    \n    @patch('ssl.create_default_context')\n    @patch('paramiko.SSHClient')\n    def test_authentication_failure(self, mock_ssh_client_cls, mock_ssl_context):\n        \"\"\"Test authentication failure during SSH connection.\"\"\"\n        mock_ssh = mock_ssh_client_cls.return_value\n        mock_ssh.connect.side_effect = paramiko.ssh_exception.AuthenticationException('Auth failed')\n        \n        with self.assertRaises(NameError):\n            sftp_secure_upload('example.com', 'bad_user', 'wrong_pass', 'local.txt', 'remote.txt')\n        \n        mock_ssh.close.assert_not_called()\n    \n    @patch('ssl.create_default_context')\n    @patch('paramiko.SSHClient')\n    def test_ssh_connection_failure_general(self, mock_ssh_client_cls, mock_ssl_context):\n        \"\"\"Test general SSH connection failure.\"\"\"\n        mock_ssh = mock_ssh_client_cls.return_value\n        mock_ssh.connect.side_effect = paramiko.ssh_exception.SSHException('Connection failed')\n        \n        with self.assertRaises(NameError):\n            sftp_secure_upload('invalid_host', 'user', 'password', 'local.txt', 'remote.txt')\n        \n        mock_ssh.close.assert_not_called()\n    \n    @patch('ssl.create_default_context')\n    @patch('paramiko.SSHClient')\n    def test_sftp_error_during_upload(self, mock_ssh_client_cls, mock_ssl_context):\n        \"\"\"Test SFTPError during file upload.\"\"\"\n        mock_ssh = mock_ssh_client_cls.return_value\n        mock_sftp = MagicMock()\n        mock_ssh.open_sftp.return_value = mock_sftp\n        mock_sftp.put.side_effect = paramiko.sftp.SFTPError('Permission denied')\n        \n        with self.assertRaises(paramiko.sftp.SFTPError) as cm:\n            sftp_secure_upload('example.com', 'user', 'password', 'local.txt', '/invalid/remote.txt')\n        \n        self.assertEqual(str(cm.exception), 'SFTP error: Permission denied')\n        mock_sftp.close.assert_called_once()\n        mock_ssh.close.assert_called_once()\n    \n    @patch('ssl.create_default_context')\n    @patch('paramiko.SSHClient')\n    def test_open_sftp_failure(self, mock_ssh_client_cls, mock_ssl_context):\n        \"\"\"Test failure during SFTP channel opening.\"\"\"\n        mock_ssh = mock_ssh_client_cls.return_value\n        mock_ssh.open_sftp.side_effect = paramiko.ssh_exception.SSHException('Channel error')\n        \n        with self.assertRaises(NameError):\n            sftp_secure_upload('example.com', 'user', 'password', 'local.txt', 'remote.txt')\n        \n        mock_ssh.close.assert_not_called()\n    \n    @patch('ssl.create_default_context')\n    @patch('paramiko.SSHClient')\n    def test_empty_file_src(self, mock_ssh_client_cls, mock_ssl_context):\n        \"\"\"Test empty source file path.\"\"\"\n        mock_ssh = mock_ssh_client_cls.return_value\n        mock_sftp = MagicMock()\n        mock_ssh.open_sftp.return_value = mock_sftp\n        mock_sftp.put.side_effect = IOError('No such file')\n        \n        with self.assertRaises(IOError) as cm:\n            sftp_secure_upload('example.com', 'user', 'password', '', 'remote.txt')\n        \n        self.assertEqual(str(cm.exception), 'File error: No such file')\n        mock_sftp.close.assert_called_once()\n        mock_ssh.close.assert_called_once()\n    \n    @patch('ssl.create_default_context')\n    @patch('paramiko.SSHClient')\n    def test_empty_file_dest(self, mock_ssh_client_cls, mock_ssl_context):\n        \"\"\"Test empty destination file path.\"\"\"\n        mock_ssh = mock_ssh_client_cls.return_value\n        mock_sftp = MagicMock()\n        mock_ssh.open_sftp.return_value = mock_sftp\n        mock_sftp.put.side_effect = paramiko.sftp.SFTPError('Invalid path')\n        \n        with self.assertRaises(paramiko.sftp.SFTPError) as cm:\n            sftp_secure_upload('example.com', 'user', 'password', 'local.txt', '')\n        \n        self.assertEqual(str(cm.exception), 'SFTP error: Invalid path')\n        mock_sftp.close.assert_called_once()\n        mock_ssh.close.assert_called_once()\n    \n    @patch('ssl.create_default_context')\n    @patch('paramiko.SSHClient')\n    def test_ssl_context_usage(self, mock_ssh_client_cls, mock_ssl_context):\n        \"\"\"Test SSL context usage and socket wrapping.\"\"\"\n        mock_context = mock_ssl_context.return_value\n        mock_ssh = mock_ssh_client_cls.return_value\n        mock_ssh.sock = MagicMock()\n        \n        sftp_secure_upload('example.com', 'user', 'password', 'local.txt', 'remote.txt')\n        \n        mock_context.wrap_socket.assert_called_once_with(mock_ssh.sock, server_hostname='example.com')\n    \n    @patch('ssl.create_default_context')\n    @patch('paramiko.SSHClient')\n    def test_empty_host(self, mock_ssh_client_cls, mock_ssl_context):\n        \"\"\"Test empty host name.\"\"\"\n        mock_ssh = mock_ssh_client_cls.return_value\n        mock_ssh.connect.side_effect = paramiko.ssh_exception.SSHException('Empty host')\n        \n        with self.assertRaises(NameError):\n            sftp_secure_upload('', 'user', 'password', 'local.txt', 'remote.txt')\n        \n        mock_ssh.close.assert_not_called()\n    \n    @patch('ssl.create_default_context')\n    @patch('paramiko.SSHClient')\n    def test_none_host(self, mock_ssh_client_cls, mock_ssl_context):\n        \"\"\"Test None host name.\"\"\"\n        mock_ssh = mock_ssh_client_cls.return_value\n        mock_ssh.connect.side_effect = paramiko.ssh_exception.SSHException('None host')\n        \n        with self.assertRaises(NameError):\n            sftp_secure_upload(None, 'user', 'password', 'local.txt', 'remote.txt')\n        \n        mock_ssh.close.assert_not_called()\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 11, "task_id": "45af2756"}
{"test": "import unittest\nfrom unittest.mock import patch, MagicMock\nimport ldap3.core.exceptions\nimport ssl\nfrom solution import secure_ldap_bind\n\nclass TestSecureLdapBind(unittest.TestCase):\n\n    @patch('solution.ssl.create_default_context')\n    @patch('solution.Server')\n    @patch('solution.Connection')\n    def test_successful_bind_and_search(self, mock_conn_class, mock_server, mock_ssl_context):\n        \"\"\"Test successful bind and search returns expected entries.\"\"\"\n        mock_conn = mock_conn_class.return_value\n        mock_conn.bind.return_value = True\n        mock_conn.entries = ['entry1', 'entry2']\n        \n        result = secure_ldap_bind('example.com', 636, 'cn=admin,dc=example,dc=com', 'password', 'dc=example,dc=com', '(objectClass=*)')\n        \n        self.assertEqual(result, ['entry1', 'entry2'])\n        mock_ssl_context.assert_called_once()\n        mock_server.assert_called_once_with('example.com', port=636, use_ssl=True, tls=mock_ssl_context.return_value)\n        mock_conn_class.assert_called_once_with(mock_server.return_value, user='cn=admin,dc=example,dc=com', password='password', authentication='SIMPLE')\n        mock_conn.bind.assert_called_once()\n        mock_conn.search.assert_called_once_with('dc=example,dc=com', '(objectClass=*)', attributes=['*'])\n        mock_conn.unbind.assert_called_once()\n\n    @patch('solution.ssl.create_default_context')\n    @patch('solution.Server')\n    @patch('solution.Connection')\n    def test_bind_failure_raises_ldap_exception(self, mock_conn_class, mock_server, mock_ssl_context):\n        \"\"\"Test bind failure raises LDAPException with empty credentials.\"\"\"\n        mock_conn = mock_conn_class.return_value\n        mock_conn.bind.return_value = False\n        \n        with self.assertRaises(ldap3.core.exceptions.LDAPException) as context:\n            secure_ldap_bind('example.com', 636, '', '', 'dc=example,dc=com', '(objectClass=*)')\n        \n        self.assertIn('Failed to bind to LDAP server', str(context.exception))\n        mock_conn.unbind.assert_called_once()\n\n    @patch('solution.ssl.create_default_context')\n    @patch('solution.Server')\n    @patch('solution.Connection')\n    def test_ldap_exception_during_bind(self, mock_conn_class, mock_server, mock_ssl_context):\n        \"\"\"Test LDAPException during bind propagates with original error.\"\"\"\n        mock_conn = mock_conn_class.return_value\n        mock_conn.bind.side_effect = ldap3.core.exceptions.LDAPException('Bind error')\n        \n        with self.assertRaises(ldap3.core.exceptions.LDAPException) as context:\n            secure_ldap_bind('example.com', 636, 'user', 'pass', 'base', 'filter')\n        \n        self.assertIn('LDAP error: Bind error', str(context.exception))\n        mock_conn.unbind.assert_called_once()\n\n    @patch('solution.ssl.create_default_context')\n    @patch('solution.Server')\n    @patch('solution.Connection')\n    def test_ldap_exception_during_search(self, mock_conn_class, mock_server, mock_ssl_context):\n        \"\"\"Test LDAPException during search propagates with original error.\"\"\"\n        mock_conn = mock_conn_class.return_value\n        mock_conn.bind.return_value = True\n        mock_conn.search.side_effect = ldap3.core.exceptions.LDAPException('Search error')\n        \n        with self.assertRaises(ldap3.core.exceptions.LDAPException) as context:\n            secure_ldap_bind('example.com', 636, 'user', 'pass', 'base', 'filter')\n        \n        self.assertIn('LDAP error: Search error', str(context.exception))\n        mock_conn.unbind.assert_called_once()\n\n    @patch('solution.ssl.create_default_context')\n    @patch('solution.Server')\n    @patch('solution.Connection')\n    def test_ssl_error_during_bind(self, mock_conn_class, mock_server, mock_ssl_context):\n        \"\"\"Test SSLError during bind propagates with custom message.\"\"\"\n        mock_conn = mock_conn_class.return_value\n        mock_conn.bind.side_effect = ssl.SSLError('SSL problem')\n        \n        with self.assertRaises(ssl.SSLError) as context:\n            secure_ldap_bind('example.com', 636, 'user', 'pass', 'base', 'filter')\n        \n        self.assertIn('SSL certificate validation failed: SSL problem', str(context.exception))\n        mock_conn.unbind.assert_called_once()\n\n    @patch('solution.ssl.create_default_context')\n    @patch('solution.Server')\n    @patch('solution.Connection')\n    def test_empty_search_returns_empty_list(self, mock_conn_class, mock_server, mock_ssl_context):\n        \"\"\"Test empty search parameters return empty result list.\"\"\"\n        mock_conn = mock_conn_class.return_value\n        mock_conn.bind.return_value = True\n        mock_conn.entries = []\n        \n        result = secure_ldap_bind('example.com', 636, 'user', 'pass', '', '')\n        \n        self.assertEqual(result, [])\n        mock_conn.search.assert_called_once_with('', '', attributes=['*'])\n        mock_conn.unbind.assert_called_once()\n\n    @patch('solution.ssl.create_default_context')\n    @patch('solution.Server')\n    @patch('solution.Connection')\n    def test_long_string_handling(self, mock_conn_class, mock_server, mock_ssl_context):\n        \"\"\"Test long input strings are handled without errors.\"\"\"\n        mock_conn = mock_conn_class.return_value\n        mock_conn.bind.return_value = True\n        mock_conn.entries = ['entry']\n        long_str = 'a' * 1000\n        \n        result = secure_ldap_bind(long_str, 636, long_str, long_str, long_str, long_str)\n        \n        self.assertEqual(result, ['entry'])\n        mock_server.assert_called_once_with(long_str, port=636, use_ssl=True, tls=mock_ssl_context.return_value)\n        mock_conn_class.assert_called_once_with(mock_server.return_value, user=long_str, password=long_str, authentication='SIMPLE')\n        mock_conn.search.assert_called_once_with(long_str, long_str, attributes=['*'])\n        mock_conn.unbind.assert_called_once()\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 7, "task_id": "5c1574f7"}
{"test": "import unittest\nfrom unittest.mock import patch, MagicMock\nimport ldap3.core.exceptions\nimport ssl\nfrom solution import ldap_secure_bind\n\nclass TestLdapSecureBind(unittest.TestCase):\n\n    @patch('ssl.create_default_context')\n    @patch('ldap3.Server')\n    @patch('ldap3.Connection')\n    def test_successful_bind_and_search(self, mock_conn, mock_server, mock_ctx):\n        \"\"\"Test successful bind and search returns expected entries.\"\"\"\n        mock_conn_inst = MagicMock()\n        mock_conn.return_value = mock_conn_inst\n        mock_conn_inst.bind.return_value = True\n        mock_entries = [MagicMock(), MagicMock()]\n        mock_conn_inst.entries = mock_entries\n        \n        result = ldap_secure_bind('ldap.example.com', 636, 'cn=user,dc=example,dc=com', 'password', 'dc=example,dc=com', '(objectClass=*)')\n        \n        self.assertEqual(result, mock_entries)\n        mock_ctx.assert_called_once()\n        mock_server.assert_called_once_with('ldap.example.com', port=636, use_ssl=True, tls=mock_ctx.return_value)\n        mock_conn.assert_called_once_with(mock_server.return_value, user='cn=user,dc=example,dc=com', password='password', authentication=ldap3.SIMPLE)\n        mock_conn_inst.bind.assert_called_once()\n        mock_conn_inst.search.assert_called_once_with('dc=example,dc=com', '(objectClass=*)', attributes=['*'])\n        mock_conn_inst.unbind.assert_called_once()\n\n    @patch('ssl.create_default_context')\n    @patch('ldap3.Server')\n    @patch('ldap3.Connection')\n    def test_bind_fails(self, mock_conn, mock_server, mock_ctx):\n        \"\"\"Test bind failure raises LDAPException.\"\"\"\n        mock_conn_inst = MagicMock()\n        mock_conn.return_value = mock_conn_inst\n        mock_conn_inst.bind.return_value = False\n        \n        with self.assertRaises(ldap3.core.exceptions.LDAPException) as context:\n            ldap_secure_bind('ldap.example.com', 636, 'cn=user,dc=example,dc=com', 'wrongpass', 'dc=example,dc=com', '(objectClass=*)')\n            \n        self.assertIn('Failed to bind to LDAP server', str(context.exception))\n        mock_conn_inst.unbind.assert_called_once()\n\n    @patch('ssl.create_default_context')\n    @patch('ldap3.Server')\n    @patch('ldap3.Connection')\n    def test_bind_raises_ldap_exception(self, mock_conn, mock_server, mock_ctx):\n        \"\"\"Test bind operation raising LDAPException is re-raised.\"\"\"\n        mock_conn_inst = MagicMock()\n        mock_conn.return_value = mock_conn_inst\n        mock_conn_inst.bind.side_effect = ldap3.core.exceptions.LDAPException('Bind error')\n        \n        with self.assertRaises(ldap3.core.exceptions.LDAPException) as context:\n            ldap_secure_bind('ldap.example.com', 636, 'cn=user,dc=example,dc=com', 'password', 'dc=example,dc=com', '(objectClass=*)')\n            \n        self.assertIn('LDAP error: Bind error', str(context.exception))\n        mock_conn_inst.unbind.assert_called_once()\n\n    @patch('ssl.create_default_context')\n    @patch('ldap3.Server')\n    @patch('ldap3.Connection')\n    def test_search_raises_ldap_exception(self, mock_conn, mock_server, mock_ctx):\n        \"\"\"Test search operation raising LDAPException is re-raised.\"\"\"\n        mock_conn_inst = MagicMock()\n        mock_conn.return_value = mock_conn_inst\n        mock_conn_inst.bind.return_value = True\n        mock_conn_inst.search.side_effect = ldap3.core.exceptions.LDAPException('Search error')\n        \n        with self.assertRaises(ldap3.core.exceptions.LDAPException) as context:\n            ldap_secure_bind('ldap.example.com', 636, 'cn=user,dc=example,dc=com', 'password', 'dc=example,dc=com', '(objectClass=*)')\n            \n        self.assertIn('LDAP error: Search error', str(context.exception))\n        mock_conn_inst.unbind.assert_called_once()\n\n    @patch('ssl.create_default_context')\n    @patch('ldap3.Server')\n    @patch('ldap3.Connection')\n    def test_ssl_error_during_bind(self, mock_conn, mock_server, mock_ctx):\n        \"\"\"Test SSL error during bind raises SSLError.\"\"\"\n        mock_conn_inst = MagicMock()\n        mock_conn.return_value = mock_conn_inst\n        mock_conn_inst.bind.side_effect = ssl.SSLError('SSL handshake failed')\n        \n        with self.assertRaises(ssl.SSLError) as context:\n            ldap_secure_bind('ldap.example.com', 636, 'cn=user,dc=example,dc=com', 'password', 'dc=example,dc=com', '(objectClass=*)')\n            \n        self.assertIn('SSL certificate validation failed: SSL handshake failed', str(context.exception))\n        mock_conn_inst.unbind.assert_called_once()\n\n    @patch('ssl.create_default_context')\n    @patch('ldap3.Server')\n    @patch('ldap3.Connection')\n    def test_unbind_called_after_exception(self, mock_conn, mock_server, mock_ctx):\n        \"\"\"Test unbind is called after exception during search.\"\"\"\n        mock_conn_inst = MagicMock()\n        mock_conn.return_value = mock_conn_inst\n        mock_conn_inst.bind.return_value = True\n        mock_conn_inst.search.side_effect = ldap3.core.exceptions.LDAPException('Search error')\n        \n        with self.assertRaises(ldap3.core.exceptions.LDAPException):\n            ldap_secure_bind('ldap.example.com', 636, 'cn=user,dc=example,dc=com', 'password', 'dc=example,dc=com', '(objectClass=*)')\n        \n        mock_conn_inst.unbind.assert_called_once()\n\n    @patch('ssl.create_default_context')\n    @patch('ldap3.Server')\n    @patch('ldap3.Connection')\n    def test_empty_dn(self, mock_conn, mock_server, mock_ctx):\n        \"\"\"Test empty DN raises LDAPException due to bind failure.\"\"\"\n        mock_conn_inst = MagicMock()\n        mock_conn.return_value = mock_conn_inst\n        mock_conn_inst.bind.return_value = False\n        \n        with self.assertRaises(ldap3.core.exceptions.LDAPException) as context:\n            ldap_secure_bind('ldap.example.com', 636, '', 'password', 'dc=example,dc=com', '(objectClass=*)')\n            \n        self.assertIn('Failed to bind to LDAP server', str(context.exception))\n        mock_conn_inst.unbind.assert_called_once()\n\n    @patch('ssl.create_default_context')\n    @patch('ldap3.Server')\n    @patch('ldap3.Connection')\n    def test_empty_bind_pass(self, mock_conn, mock_server, mock_ctx):\n        \"\"\"Test empty password raises LDAPException due to bind failure.\"\"\"\n        mock_conn_inst = MagicMock()\n        mock_conn.return_value = mock_conn_inst\n        mock_conn_inst.bind.return_value = False\n        \n        with self.assertRaises(ldap3.core.exceptions.LDAPException) as context:\n            ldap_secure_bind('ldap.example.com', 636, 'cn=user,dc=example,dc=com', '', 'dc=example,dc=com', '(objectClass=*)')\n            \n        self.assertIn('Failed to bind to LDAP server', str(context.exception))\n        mock_conn_inst.unbind.assert_called_once()\n\n    @patch('ssl.create_default_context')\n    @patch('ldap3.Server')\n    @patch('ldap3.Connection')\n    def test_empty_search_dn_and_filter(self, mock_conn, mock_server, mock_ctx):\n        \"\"\"Test empty search DN and filter returns expected entries.\"\"\"\n        mock_conn_inst = MagicMock()\n        mock_conn.return_value = mock_conn_inst\n        mock_conn_inst.bind.return_value = True\n        mock_entries = [MagicMock()]\n        mock_conn_inst.entries = mock_entries\n        \n        result = ldap_secure_bind('ldap.example.com', 636, 'cn=user,dc=example,dc=com', 'password', '', '')\n        \n        self.assertEqual(result, mock_entries)\n        mock_conn_inst.search.assert_called_once_with('', '', attributes=['*'])\n        mock_conn_inst.unbind.assert_called_once()\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 9, "task_id": "1c11bfa1"}
{"test": "import unittest\nfrom unittest.mock import patch, MagicMock\nimport ssl\nfrom ldap3 import SIMPLE\nfrom ldap3.core.exceptions import LDAPException\n\n# Import the function to test\nfrom solution import secure_ldap_bind\n\nclass TestSecureLdapBind(unittest.TestCase):\n    \n    def test_successful_bind_and_search(self):\n        \"\"\"Test successful bind and search returns entries.\"\"\"\n        with patch('ldap3.Server') as mock_server, \\\n             patch('ldap3.Connection') as mock_connection, \\\n             patch('ssl.create_default_context') as mock_ssl_context:\n            \n            mock_conn = mock_connection.return_value\n            mock_conn.bind.return_value = True\n            mock_conn.entries = ['entry1', 'entry2']\n            \n            host = 'test-host'\n            port = 636\n            user_dn = 'cn=test,dc=example,dc=com'\n            pwd = 'password'\n            search_dn = 'dc=example,dc=com'\n            query_filter = '(objectClass=*)'\n            result = secure_ldap_bind(host, port, user_dn, pwd, search_dn, query_filter)\n            \n            self.assertEqual(result, ['entry1', 'entry2'])\n            mock_ssl_context.assert_called_once()\n            mock_server.assert_called_once_with(host, port=port, use_ssl=True, tls=mock_ssl_context.return_value)\n            mock_connection.assert_called_once_with(mock_server.return_value, user=user_dn, password=pwd, authentication=SIMPLE)\n            mock_conn.bind.assert_called_once()\n            mock_conn.search.assert_called_once_with(search_dn, query_filter, attributes=['*'])\n    \n    def test_bind_failure_return_false(self):\n        \"\"\"Test bind returns False raises LDAPException.\"\"\"\n        with patch('ldap3.Server'), \\\n             patch('ldap3.Connection') as mock_connection, \\\n             patch('ssl.create_default_context'):\n            \n            mock_conn = mock_connection.return_value\n            mock_conn.bind.return_value = False\n            \n            with self.assertRaises(LDAPException) as context:\n                secure_ldap_bind('host', 636, 'user', 'pass', 'search_dn', 'filter')\n            self.assertEqual(str(context.exception), \"Failed to bind to LDAP server\")\n    \n    def test_bind_raises_ldap_exception(self):\n        \"\"\"Test bind raising LDAPException is re-raised with message.\"\"\"\n        with patch('ldap3.Server'), \\\n             patch('ldap3.Connection') as mock_connection, \\\n             patch('ssl.create_default_context'):\n            \n            mock_conn = mock_connection.return_value\n            mock_conn.bind.side_effect = LDAPException(\"bind exception\")\n            \n            with self.assertRaises(LDAPException) as context:\n                secure_ldap_bind('host', 636, 'user', 'pass', 'search_dn', 'filter')\n            self.assertIn(\"LDAP error: bind exception\", str(context.exception))\n    \n    def test_bind_raises_ssl_error(self):\n        \"\"\"Test bind raising SSLError is re-raised with message.\"\"\"\n        with patch('ldap3.Server'), \\\n             patch('ldap3.Connection') as mock_connection, \\\n             patch('ssl.create_default_context'):\n            \n            mock_conn = mock_connection.return_value\n            mock_conn.bind.side_effect = ssl.SSLError(\"certificate verify failed\")\n            \n            with self.assertRaises(ssl.SSLError) as context:\n                secure_ldap_bind('host', 636, 'user', 'pass', 'search_dn', 'filter')\n            self.assertIn(\"SSL certificate validation failed: certificate verify failed\", str(context.exception))\n    \n    def test_search_raises_ldap_exception(self):\n        \"\"\"Test search raising LDAPException is re-raised with message.\"\"\"\n        with patch('ldap3.Server'), \\\n             patch('ldap3.Connection') as mock_connection, \\\n             patch('ssl.create_default_context'):\n            \n            mock_conn = mock_connection.return_value\n            mock_conn.bind.return_value = True\n            mock_conn.search.side_effect = LDAPException(\"search error\")\n            \n            with self.assertRaises(LDAPException) as context:\n                secure_ldap_bind('host', 636, 'user', 'pass', 'search_dn', 'filter')\n            self.assertIn(\"LDAP error: search error\", str(context.exception))\n    \n    def test_connection_parameters(self):\n        \"\"\"Test connection parameters are passed correctly.\"\"\"\n        with patch('ldap3.Server') as mock_server, \\\n             patch('ldap3.Connection') as mock_connection, \\\n             patch('ssl.create_default_context') as mock_ssl_context:\n            \n            mock_conn = mock_connection.return_value\n            mock_conn.bind.return_value = True\n            \n            host = 'test-host'\n            port = 636\n            user_dn = 'cn=test,dc=example,dc=com'\n            pwd = 'password'\n            search_dn = 'dc=example,dc=com'\n            query_filter = '(objectClass=*)'\n            secure_ldap_bind(host, port, user_dn, pwd, search_dn, query_filter)\n            \n            mock_ssl_context.assert_called_once()\n            mock_server.assert_called_once_with(host, port=port, use_ssl=True, tls=mock_ssl_context.return_value)\n            mock_connection.assert_called_once_with(mock_server.return_value, user=user_dn, password=pwd, authentication=SIMPLE)\n    \n    def test_unbind_called_in_success_case(self):\n        \"\"\"Test unbind is called after successful operation.\"\"\"\n        with patch('ldap3.Server'), \\\n             patch('ldap3.Connection') as mock_connection, \\\n             patch('ssl.create_default_context'):\n            \n            mock_conn = mock_connection.return_value\n            mock_conn.bind.return_value = True\n            \n            secure_ldap_bind('host', 636, 'user', 'pass', 'search_dn', 'filter')\n            mock_conn.unbind.assert_called_once()\n    \n    def test_unbind_called_when_bind_fails(self):\n        \"\"\"Test unbind is called when bind returns False.\"\"\"\n        with patch('ldap3.Server'), \\\n             patch('ldap3.Connection') as mock_connection, \\\n             patch('ssl.create_default_context'):\n            \n            mock_conn = mock_connection.return_value\n            mock_conn.bind.return_value = False\n            \n            try:\n                secure_ldap_bind('host', 636, 'user', 'pass', 'search_dn', 'filter')\n            except LDAPException:\n                pass\n            mock_conn.unbind.assert_called_once()\n    \n    def test_unbind_called_when_search_fails(self):\n        \"\"\"Test unbind is called when search raises exception.\"\"\"\n        with patch('ldap3.Server'), \\\n             patch('ldap3.Connection') as mock_connection, \\\n             patch('ssl.create_default_context'):\n            \n            mock_conn = mock_connection.return_value\n            mock_conn.bind.return_value = True\n            mock_conn.search.side_effect = LDAPException(\"search error\")\n            \n            try:\n                secure_ldap_bind('host', 636, 'user', 'pass', 'search_dn', 'filter')\n            except LDAPException:\n                pass\n            mock_conn.unbind.assert_called_once()\n    \n    def test_unbind_called_when_bind_raises_exception(self):\n        \"\"\"Test unbind is called when bind raises exception.\"\"\"\n        with patch('ldap3.Server'), \\\n             patch('ldap3.Connection') as mock_connection, \\\n             patch('ssl.create_default_context'):\n            \n            mock_conn = mock_connection.return_value\n            mock_conn.bind.side_effect = LDAPException(\"bind error\")\n            \n            try:\n                secure_ldap_bind('host', 636, 'user', 'pass', 'search_dn', 'filter')\n            except LDAPException:\n                pass\n            mock_conn.unbind.assert_called_once()\n    \n    def test_empty_credentials_parameters(self):\n        \"\"\"Test empty credentials are passed to connection.\"\"\"\n        with patch('ldap3.Server') as mock_server, \\\n             patch('ldap3.Connection') as mock_connection, \\\n             patch('ssl.create_default_context'):\n            \n            mock_conn = mock_connection.return_value\n            mock_conn.bind.return_value = True\n            \n            host = 'test-host'\n            port = 636\n            user_dn = ''\n            pwd = ''\n            search_dn = 'dc=example,dc=com'\n            query_filter = '(objectClass=*)'\n            secure_ldap_bind(host, port, user_dn, pwd, search_dn, query_filter)\n            \n            mock_connection.assert_called_once_with(mock_server.return_value, user=user_dn, password=pwd, authentication=SIMPLE)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 11, "task_id": "0eae47e8"}
{"test": "import unittest\nfrom unittest.mock import patch, MagicMock\n\n# Define mock exceptions\nclass MockLDAPException(Exception):\n    pass\n\nclass MockSSLError(Exception):\n    pass\n\nclass TestLdapTlsBind(unittest.TestCase):\n\n    @patch('ssl.create_default_context')\n    @patch('ldap3.Server')\n    @patch('ldap3.Connection')\n    @patch('ldap3.core.exceptions', MagicMock(LDAPException=MockLDAPException))\n    @patch('ssl.SSLError', MockSSLError)\n    @patch('ldap3.SIMPLE', 'SIMPLE')\n    def test_successful_operation(self, mock_connection, mock_server, mock_ssl_context):\n        \"\"\"Test successful bind and search returns entries.\"\"\"\n        mock_conn_instance = MagicMock()\n        mock_connection.return_value = mock_conn_instance\n        mock_conn_instance.bind.return_value = True\n        mock_conn_instance.entries = ['entry1', 'entry2']\n        \n        result = ldap_tls_bind('ldap.example.com', 636, 'cn=user,dc=example,dc=com', 'password', 'dc=example,dc=com', '(objectClass=*)')\n        \n        self.assertEqual(result, ['entry1', 'entry2'])\n        mock_conn_instance.bind.assert_called_once()\n        mock_conn_instance.search.assert_called_once_with('dc=example,dc=com', '(objectClass=*)', attributes=['*'])\n        mock_conn_instance.unbind.assert_called_once()\n\n    @patch('ssl.create_default_context')\n    @patch('ldap3.Server')\n    @patch('ldap3.Connection')\n    @patch('ldap3.core.exceptions', MagicMock(LDAPException=MockLDAPException))\n    @patch('ssl.SSLError', MockSSLError)\n    @patch('ldap3.SIMPLE', 'SIMPLE')\n    def test_bind_failure(self, mock_connection, mock_server, mock_ssl_context):\n        \"\"\"Test bind failure raises LDAPException.\"\"\"\n        mock_conn_instance = MagicMock()\n        mock_connection.return_value = mock_conn_instance\n        mock_conn_instance.bind.return_value = False\n        \n        with self.assertRaises(MockLDAPException) as context:\n            ldap_tls_bind('ldap.example.com', 636, 'cn=user,dc=example,dc=com', 'password', 'dc=example,dc=com', '(objectClass=*)')\n        \n        self.assertIn(\"Failed to bind to LDAP server\", str(context.exception))\n        mock_conn_instance.unbind.assert_called_once()\n\n    @patch('ssl.create_default_context')\n    @patch('ldap3.Server')\n    @patch('ldap3.Connection')\n    @patch('ldap3.core.exceptions', MagicMock(LDAPException=MockLDAPException))\n    @patch('ssl.SSLError', MockSSLError)\n    @patch('ldap3.SIMPLE', 'SIMPLE')\n    def test_ssl_error_during_bind(self, mock_connection, mock_server, mock_ssl_context):\n        \"\"\"Test SSL error during bind raises SSLError.\"\"\"\n        mock_conn_instance = MagicMock()\n        mock_connection.return_value = mock_conn_instance\n        mock_conn_instance.bind.side_effect = MockSSLError(\"SSL handshake failed\")\n        \n        with self.assertRaises(MockSSLError) as context:\n            ldap_tls_bind('ldap.example.com', 636, 'cn=user,dc=example,dc=com', 'password', 'dc=example,dc=com', '(objectClass=*)')\n        \n        self.assertIn(\"SSL certificate validation failed\", str(context.exception))\n        mock_conn_instance.unbind.assert_called_once()\n\n    @patch('ssl.create_default_context')\n    @patch('ldap3.Server')\n    @patch('ldap3.Connection')\n    @patch('ldap3.core.exceptions', MagicMock(LDAPException=MockLDAPException))\n    @patch('ssl.SSLError', MockSSLError)\n    @patch('ldap3.SIMPLE', 'SIMPLE')\n    def test_ldap_exception_during_search(self, mock_connection, mock_server, mock_ssl_context):\n        \"\"\"Test LDAPException during search is re-raised.\"\"\"\n        mock_conn_instance = MagicMock()\n        mock_connection.return_value = mock_conn_instance\n        mock_conn_instance.bind.return_value = True\n        mock_conn_instance.search.side_effect = MockLDAPException(\"Search failed\")\n        \n        with self.assertRaises(MockLDAPException) as context:\n            ldap_tls_bind('ldap.example.com', 636, 'cn=user,dc=example,dc=com', 'password', 'dc=example,dc=com', '(objectClass=*)')\n        \n        self.assertIn(\"LDAP error\", str(context.exception))\n        mock_conn_instance.unbind.assert_called_once()\n\n    @patch('ssl.create_default_context')\n    @patch('ldap3.Server')\n    @patch('ldap3.Connection')\n    @patch('ldap3.core.exceptions', MagicMock(LDAPException=MockLDAPException))\n    @patch('ssl.SSLError', MockSSLError)\n    @patch('ldap3.SIMPLE', 'SIMPLE')\n    def test_ssl_error_during_search(self, mock_connection, mock_server, mock_ssl_context):\n        \"\"\"Test SSLError during search is re-raised.\"\"\"\n        mock_conn_instance = MagicMock()\n        mock_connection.return_value = mock_conn_instance\n        mock_conn_instance.bind.return_value = True\n        mock_conn_instance.search.side_effect = MockSSLError(\"SSL error during search\")\n        \n        with self.assertRaises(MockSSLError) as context:\n            ldap_tls_bind('ldap.example.com', 636, 'cn=user,dc=example,dc=com', 'password', 'dc=example,dc=com', '(objectClass=*)')\n        \n        self.assertIn(\"SSL certificate validation failed\", str(context.exception))\n        mock_conn_instance.unbind.assert_called_once()\n\n    @patch('ssl.create_default_context')\n    @patch('ldap3.Server')\n    @patch('ldap3.Connection')\n    @patch('ldap3.core.exceptions', MagicMock(LDAPException=MockLDAPException))\n    @patch('ssl.SSLError', MockSSLError)\n    @patch('ldap3.SIMPLE', 'SIMPLE')\n    def test_arguments_passed_correctly(self, mock_connection, mock_server, mock_ssl_context):\n        \"\"\"Test arguments are correctly passed to underlying objects.\"\"\"\n        mock_conn_instance = MagicMock()\n        mock_connection.return_value = mock_conn_instance\n        mock_conn_instance.bind.return_value = True\n        mock_conn_instance.entries = []\n        \n        ldap_tls_bind('another.host', 1234, 'dn=test', 'pass', 'base', 'filter')\n        \n        mock_server.assert_called_once_with('another.host', port=1234, use_ssl=True, tls=mock_ssl_context.return_value)\n        mock_connection.assert_called_once_with(mock_server.return_value, user='dn=test', password='pass', authentication='SIMPLE')\n        mock_conn_instance.search.assert_called_once_with('base', 'filter', attributes=['*'])\n\n    @patch('ssl.create_default_context')\n    @patch('ldap3.Server')\n    @patch('ldap3.Connection')\n    @patch('ldap3.core.exceptions', MagicMock(LDAPException=MockLDAPException))\n    @patch('ssl.SSLError', MockSSLError)\n    @patch('ldap3.SIMPLE', 'SIMPLE')\n    def test_unbind_called_after_exception(self, mock_connection, mock_server, mock_ssl_context):\n        \"\"\"Test unbind is called even when exception occurs.\"\"\"\n        mock_conn_instance = MagicMock()\n        mock_connection.return_value = mock_conn_instance\n        mock_conn_instance.bind.side_effect = MockLDAPException(\"Bind error\")\n        \n        with self.assertRaises(MockLDAPException):\n            ldap_tls_bind('ldap.example.com', 636, 'cn=user,dc=example,dc=com', 'password', 'dc=example,dc=com', '(objectClass=*)')\n        \n        mock_conn_instance.unbind.assert_called_once()\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 7, "task_id": "0129f3a2"}
{"test": "import unittest\nfrom unittest.mock import patch, MagicMock\nimport ssl\n\n# Mock LDAPException for testing\nclass MockLDAPException(Exception):\n    pass\n\nclass TestLDAPSecureConnect(unittest.TestCase):\n    \n    @patch('ssl.create_default_context')\n    @patch('ldap3.Server')\n    @patch('ldap3.Connection')\n    def test_successful_connection_and_search(self, mock_conn, mock_server, mock_ssl_ctx):\n        \"\"\"Test successful connection, bind, and search.\"\"\"\n        # Setup mock objects\n        mock_conn_inst = mock_conn.return_value\n        mock_conn_inst.bind.return_value = True\n        mock_conn_inst.entries = ['entry1', 'entry2']\n        \n        # Call function\n        result = ldap_secure_connect('ldap.example.com', 636, 'cn=admin', 'secret', 'dc=test', '(objectClass=*)')\n        \n        # Assertions\n        self.assertEqual(result, ['entry1', 'entry2'])\n        mock_server.assert_called_once_with('ldap.example.com', port=636, use_ssl=True, tls=mock_ssl_ctx.return_value)\n        mock_conn.assert_called_once_with(mock_server.return_value, user='cn=admin', password='secret', authentication='SIMPLE')\n        mock_conn_inst.search.assert_called_once_with('dc=test', '(objectClass=*)', attributes=['*'])\n        mock_conn_inst.unbind.assert_called_once()\n    \n    @patch('ssl.create_default_context')\n    @patch('ldap3.Server')\n    @patch('ldap3.Connection')\n    def test_bind_failure(self, mock_conn, mock_server, mock_ssl_ctx):\n        \"\"\"Test bind failure returns False.\"\"\"\n        # Setup mock objects\n        mock_conn_inst = mock_conn.return_value\n        mock_conn_inst.bind.return_value = False\n        \n        # Call function and assert exception\n        with self.assertRaises(MockLDAPException) as context:\n            ldap_secure_connect('ldap.example.com', 636, 'cn=admin', 'badpass', 'dc=test', '(objectClass=*)')\n        \n        # Assertions\n        self.assertIn('Failed to bind to LDAP server', str(context.exception))\n        mock_conn_inst.unbind.assert_called_once()\n    \n    @patch('ssl.create_default_context')\n    @patch('ldap3.Server')\n    @patch('ldap3.Connection')\n    def test_ssl_error_during_bind(self, mock_conn, mock_server, mock_ssl_ctx):\n        \"\"\"Test SSL error during bind.\"\"\"\n        # Setup mock objects\n        mock_conn_inst = mock_conn.return_value\n        mock_conn_inst.bind.side_effect = ssl.SSLError(\"SSL failure\")\n        \n        # Call function and assert exception\n        with self.assertRaises(ssl.SSLError) as context:\n            ldap_secure_connect('invalid.host', 636, 'cn=admin', 'secret', 'dc=test', '(objectClass=*)')\n        \n        # Assertions\n        self.assertIn('SSL certificate validation failed', str(context.exception))\n        mock_conn_inst.unbind.assert_called_once()\n    \n    @patch('ssl.create_default_context')\n    @patch('ldap3.Server')\n    @patch('ldap3.Connection')\n    def test_ldap_exception_during_bind(self, mock_conn, mock_server, mock_ssl_ctx):\n        \"\"\"Test LDAPException during bind.\"\"\"\n        # Setup mock objects\n        mock_conn_inst = mock_conn.return_value\n        mock_conn_inst.bind.side_effect = MockLDAPException(\"Bind error\")\n        \n        # Call function and assert exception\n        with self.assertRaises(MockLDAPException) as context:\n            ldap_secure_connect('ldap.example.com', 636, 'cn=admin', 'secret', 'dc=test', '(objectClass=*)')\n        \n        # Assertions\n        self.assertIn('LDAP error', str(context.exception))\n        mock_conn_inst.unbind.assert_called_once()\n    \n    @patch('ssl.create_default_context')\n    @patch('ldap3.Server')\n    @patch('ldap3.Connection')\n    def test_ldap_exception_during_search(self, mock_conn, mock_server, mock_ssl_ctx):\n        \"\"\"Test LDAPException during search.\"\"\"\n        # Setup mock objects\n        mock_conn_inst = mock_conn.return_value\n        mock_conn_inst.bind.return_value = True\n        mock_conn_inst.search.side_effect = MockLDAPException(\"Search error\")\n        \n        # Call function and assert exception\n        with self.assertRaises(MockLDAPException) as context:\n            ldap_secure_connect('ldap.example.com', 636, 'cn=admin', 'secret', 'dc=test', '(objectClass=*)')\n        \n        # Assertions\n        self.assertIn('LDAP error', str(context.exception))\n        mock_conn_inst.unbind.assert_called_once()\n    \n    @patch('ssl.create_default_context')\n    @patch('ldap3.Server')\n    @patch('ldap3.Connection')\n    def test_empty_base_dn_and_filter_query(self, mock_conn, mock_server, mock_ssl_ctx):\n        \"\"\"Test with empty base_dn and filter_query.\"\"\"\n        # Setup mock objects\n        mock_conn_inst = mock_conn.return_value\n        mock_conn_inst.bind.return_value = True\n        mock_conn_inst.entries = []\n        \n        # Call function\n        result = ldap_secure_connect('ldap.example.com', 636, 'cn=admin', 'secret', '', '')\n        \n        # Assertions\n        self.assertEqual(result, [])\n        mock_conn_inst.search.assert_called_once_with('', '', attributes=['*'])\n        mock_conn_inst.unbind.assert_called_once()\n\nif __name__ == '__main__':\n    # Patch ldap3.core.exceptions.LDAPException globally for tests\n    with patch('ldap3.core.exceptions.LDAPException', new=MockLDAPException):\n        unittest.main()", "num_test_cases": 6, "task_id": "a6d41adb"}
{"test": "import unittest\nfrom unittest.mock import patch, MagicMock\nfrom solution import setup_ldap_connection\n\nclass TestSetupLDAPConnection(unittest.TestCase):\n    class MockLDAPException(Exception):\n        pass\n\n    class MockSSLError(Exception):\n        pass\n\n    def setUp(self):\n        self.ldap_exception_patcher = patch('solution.ldap3.core.exceptions.LDAPException', new=self.MockLDAPException)\n        self.ssl_error_patcher = patch('solution.ssl.SSLError', new=self.MockSSLError)\n        self.ldap_exception_patcher.start()\n        self.ssl_error_patcher.start()\n\n    def tearDown(self):\n        self.ldap_exception_patcher.stop()\n        self.ssl_error_patcher.stop()\n\n    def test_case_1(self):\n        # Test successful connection, bind, and search\n        with patch('solution.ssl.create_default_context') as mock_ssl_ctx, \\\n             patch('solution.ldap3.Server') as mock_server, \\\n             patch('solution.ldap3.Connection') as mock_conn:\n\n            mock_conn.return_value.bind.return_value = True\n            mock_conn.return_value.entries = ['entry1', 'entry2']\n\n            host_name = 'ldap.example.com'\n            ldaps_port = 636\n            user_dn = 'cn=admin,dc=example,dc=com'\n            user_pass = 'password'\n            root_dn = 'dc=example,dc=com'\n            filter_query = '(objectClass=*)'\n\n            result = setup_ldap_connection(host_name, ldaps_port, user_dn, user_pass, root_dn, filter_query)\n\n            self.assertEqual(result, ['entry1', 'entry2'])\n            mock_ssl_ctx.assert_called_once()\n            mock_server.assert_called_once_with(host_name, port=ldaps_port, use_ssl=True, tls=mock_ssl_ctx.return_value)\n            mock_conn.assert_called_once_with(mock_server.return_value, user=user_dn, password=user_pass, authentication='SIMPLE')\n            mock_conn.return_value.bind.assert_called_once()\n            mock_conn.return_value.search.assert_called_once_with(root_dn, filter_query, attributes=['*'])\n            mock_conn.return_value.unbind.assert_called_once()\n\n    def test_case_2(self):\n        # Test bind returns False\n        with patch('solution.ssl.create_default_context') as mock_ssl_ctx, \\\n             patch('solution.ldap3.Server') as mock_server, \\\n             patch('solution.ldap3.Connection') as mock_conn:\n\n            mock_conn.return_value.bind.return_value = False\n\n            with self.assertRaises(self.MockLDAPException) as context:\n                setup_ldap_connection('host', 636, 'user', 'pass', 'root', '(filter)')\n\n            self.assertEqual(str(context.exception), 'Failed to bind to LDAP server')\n            mock_conn.return_value.unbind.assert_called_once()\n\n    def test_case_3(self):\n        # Test bind raises an LDAPException\n        with patch('solution.ssl.create_default_context') as mock_ssl_ctx, \\\n             patch('solution.ldap3.Server') as mock_server, \\\n             patch('solution.ldap3.Connection') as mock_conn:\n\n            mock_conn.return_value.bind.side_effect = self.MockLDAPException('Bind failed')\n\n            with self.assertRaises(self.MockLDAPException) as context:\n                setup_ldap_connection('host', 636, 'user', 'pass', 'root', '(filter)')\n\n            self.assertEqual(str(context.exception), 'LDAP error: Bind failed')\n            mock_conn.return_value.unbind.assert_called_once()\n\n    def test_case_4(self):\n        # Test bind raises an SSLError\n        with patch('solution.ssl.create_default_context') as mock_ssl_ctx, \\\n             patch('solution.ldap3.Server') as mock_server, \\\n             patch('solution.ldap3.Connection') as mock_conn:\n\n            mock_conn.return_value.bind.side_effect = self.MockSSLError('SSL failed')\n\n            with self.assertRaises(self.MockSSLError) as context:\n                setup_ldap_connection('host', 636, 'user', 'pass', 'root', '(filter)')\n\n            self.assertEqual(str(context.exception), 'SSL certificate validation failed: SSL failed')\n            mock_conn.return_value.unbind.assert_called_once()\n\n    def test_case_5(self):\n        # Test search raises an LDAPException\n        with patch('solution.ssl.create_default_context') as mock_ssl_ctx, \\\n             patch('solution.ldap3.Server') as mock_server, \\\n             patch('solution.ldap3.Connection') as mock_conn:\n\n            mock_conn.return_value.bind.return_value = True\n            mock_conn.return_value.search.side_effect = self.MockLDAPException('Search failed')\n\n            with self.assertRaises(self.MockLDAPException) as context:\n                setup_ldap_connection('host', 636, 'user', 'pass', 'root', '(filter)')\n\n            self.assertEqual(str(context.exception), 'LDAP error: Search failed')\n            mock_conn.return_value.unbind.assert_called_once()\n\n    def test_case_6(self):\n        # Test with edge values (empty strings and None)\n        with patch('solution.ssl.create_default_context') as mock_ssl_ctx, \\\n             patch('solution.ldap3.Server') as mock_server, \\\n             patch('solution.ldap3.Connection') as mock_conn:\n\n            mock_conn.return_value.bind.return_value = False\n\n            host_name = ''\n            ldaps_port = 0\n            user_dn = None\n            user_pass = None\n            root_dn = None\n            filter_query = None\n\n            with self.assertRaises(self.MockLDAPException) as context:\n                setup_ldap_connection(host_name, ldaps_port, user_dn, user_pass, root_dn, filter_query)\n\n            mock_server.assert_called_once_with(host_name, port=ldaps_port, use_ssl=True, tls=mock_ssl_ctx.return_value)\n            mock_conn.assert_called_once_with(mock_server.return_value, user=user_dn, password=user_pass, authentication='SIMPLE')\n            self.assertEqual(str(context.exception), 'Failed to bind to LDAP server')\n            mock_conn.return_value.unbind.assert_called_once()\n\n    def test_case_7(self):\n        # Test with very long input values\n        with patch('solution.ssl.create_default_context') as mock_ssl_ctx, \\\n             patch('solution.ldap3.Server') as mock_server, \\\n             patch('solution.ldap3.Connection') as mock_conn:\n\n            mock_conn.return_value.bind.return_value = True\n            mock_conn.return_value.entries = ['entry']\n\n            host_name = 'x' * 1000\n            user_dn = 'x' * 1000\n            user_pass = 'x' * 1000\n            root_dn = 'x' * 1000\n            filter_query = 'x' * 1000\n\n            result = setup_ldap_connection(host_name, 636, user_dn, user_pass, root_dn, filter_query)\n\n            self.assertEqual(result, ['entry'])\n            mock_server.assert_called_once_with(host_name, port=636, use_ssl=True, tls=mock_ssl_ctx.return_value)\n            mock_conn.assert_called_once_with(mock_server.return_value, user=user_dn, password=user_pass, authentication='SIMPLE')\n            mock_conn.return_value.unbind.assert_called_once()\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 7, "task_id": "591c508f"}
{"test": "import unittest\nfrom unittest.mock import patch, ANY, MagicMock\nimport ldap3\nimport ssl\n\n# Import the function from its module - assuming it's available as 'initialize_ldap_conn'\n# Replace 'your_module' with the actual module name where the function resides\nfrom your_module import initialize_ldap_conn\n\nclass TestInitializeLDAPConn(unittest.TestCase):\n\n    @patch('ldap3.Server')\n    @patch('ldap3.Connection')\n    def test_successful_connection_and_search(self, mock_connection, mock_server):\n        \"\"\"Test successful connection, bind, and search returns expected entries.\"\"\"\n        mock_conn_instance = mock_connection.return_value\n        mock_conn_instance.bind.return_value = True\n        mock_entries = [MagicMock(), MagicMock()]\n        mock_conn_instance.entries = mock_entries\n        \n        result = initialize_ldap_conn(\n            'ldap.example.com', 636, \n            'cn=admin,dc=example,dc=com', 'password', \n            'dc=example,dc=com', '(objectClass=*)'\n        )\n        \n        mock_server.assert_called_once_with('ldap.example.com', port=636, use_ssl=True, tls=ANY)\n        mock_connection.assert_called_once_with(\n            mock_server.return_value, \n            user='cn=admin,dc=example,dc=com', \n            password='password', \n            authentication=ldap3.SIMPLE\n        )\n        mock_conn_instance.bind.assert_called_once()\n        mock_conn_instance.search.assert_called_once_with('dc=example,dc=com', '(objectClass=*)', attributes=['*'])\n        self.assertEqual(result, mock_entries)\n        mock_conn_instance.unbind.assert_called_once()\n\n    @patch('ldap3.Server')\n    @patch('ldap3.Connection')\n    def test_bind_failure(self, mock_connection, mock_server):\n        \"\"\"Test bind failure raises LDAPException.\"\"\"\n        mock_conn_instance = mock_connection.return_value\n        mock_conn_instance.bind.return_value = False\n        \n        with self.assertRaises(ldap3.core.exceptions.LDAPException):\n            initialize_ldap_conn(\n                'ldap.example.com', 636, \n                'cn=admin,dc=example,dc=com', 'wrong_password', \n                'dc=example,dc=com', '(objectClass=*)'\n            )\n        \n        mock_conn_instance.unbind.assert_called_once()\n\n    @patch('ldap3.Server')\n    @patch('ldap3.Connection')\n    def test_ssl_error_during_bind(self, mock_connection, mock_server):\n        \"\"\"Test SSL certificate validation failure during bind raises SSLError.\"\"\"\n        mock_conn_instance = mock_connection.return_value\n        mock_conn_instance.bind.side_effect = ssl.SSLError(\"certificate verify failed\")\n        \n        with self.assertRaises(ssl.SSLError):\n            initialize_ldap_conn(\n                'ldap.example.com', 636, \n                'cn=admin,dc=example,dc=com', 'password', \n                'dc=example,dc=com', '(objectClass=*)'\n            )\n        \n        mock_conn_instance.unbind.assert_called_once()\n\n    @patch('ldap3.Server')\n    @patch('ldap3.Connection')\n    def test_search_operation_raises_ldap_exception(self, mock_connection, mock_server):\n        \"\"\"Test search operation raising LDAPException propagates correctly.\"\"\"\n        mock_conn_instance = mock_connection.return_value\n        mock_conn_instance.bind.return_value = True\n        mock_conn_instance.search.side_effect = ldap3.core.exceptions.LDAPException(\"Search failed\")\n        \n        with self.assertRaises(ldap3.core.exceptions.LDAPException):\n            initialize_ldap_conn(\n                'ldap.example.com', 636, \n                'cn=admin,dc=example,dc=com', 'password', \n                'dc=example,dc=com', '(objectClass=*)'\n            )\n        \n        mock_conn_instance.unbind.assert_called_once()\n\n    @patch('ldap3.Server')\n    @patch('ldap3.Connection')\n    def test_non_standard_port(self, mock_connection, mock_server):\n        \"\"\"Test connection with non-standard LDAPS port.\"\"\"\n        mock_conn_instance = mock_connection.return_value\n        mock_conn_instance.bind.return_value = True\n        \n        initialize_ldap_conn(\n            'ldap.example.com', 1636, \n            'cn=admin,dc=example,dc=com', 'password', \n            'dc=example,dc=com', '(objectClass=*)'\n        )\n        \n        mock_server.assert_called_once_with('ldap.example.com', port=1636, use_ssl=True, tls=ANY)\n\n    @patch('ldap3.Server')\n    @patch('ldap3.Connection')\n    def test_empty_user_credentials(self, mock_connection, mock_server):\n        \"\"\"Test empty username or password causes bind failure.\"\"\"\n        mock_conn_instance = mock_connection.return_value\n        mock_conn_instance.bind.return_value = False\n        \n        with self.assertRaises(ldap3.core.exceptions.LDAPException):\n            initialize_ldap_conn(\n                'ldap.example.com', 636, \n                '', '', \n                'dc=example,dc=com', '(objectClass=*)'\n            )\n        \n        mock_conn_instance.unbind.assert_called_once()\n\n    @patch('ldap3.Server')\n    @patch('ldap3.Connection')\n    def test_empty_search_parameters(self, mock_connection, mock_server):\n        \"\"\"Test empty search_dn and ldap_query are passed correctly.\"\"\"\n        mock_conn_instance = mock_connection.return_value\n        mock_conn_instance.bind.return_value = True\n        mock_entries = [MagicMock()]\n        mock_conn_instance.entries = mock_entries\n        \n        result = initialize_ldap_conn(\n            'ldap.example.com', 636, \n            'cn=admin,dc=example,dc=com', 'password', \n            '', ''\n        )\n        \n        mock_conn_instance.search.assert_called_once_with('', '', attributes=['*'])\n        self.assertEqual(result, mock_entries)\n\n    @patch('ldap3.Server')\n    @patch('ldap3.Connection')\n    def test_unbind_called_after_exception(self, mock_connection, mock_server):\n        \"\"\"Test that unbind is called even after an exception during bind.\"\"\"\n        mock_conn_instance = mock_connection.return_value\n        mock_conn_instance.bind.side_effect = ldap3.core.exceptions.LDAPException(\"Bind error\")\n        \n        with self.assertRaises(ldap3.core.exceptions.LDAPException):\n            initialize_ldap_conn(\n                'ldap.example.com', 636, \n                'cn=admin,dc=example,dc=com', 'password', \n                'dc=example,dc=com', '(objectClass=*)'\n            )\n        \n        mock_conn_instance.unbind.assert_called_once()\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 8, "task_id": "30136cb7"}
{"test": "import unittest\nimport redis\nimport ssl\nfrom unittest.mock import patch, MagicMock\nfrom solution import secure_redis_link\n\nclass TestSecureRedisLink(unittest.TestCase):\n    \n    @patch('redis.Redis')\n    def test_successful_connection_no_password(self, mock_redis):\n        # Test successful connection without password and default db\n        mock_client = mock_redis.return_value\n        mock_client.ping.return_value = True\n        \n        result = secure_redis_link('localhost', 6379)\n        self.assertTrue(result)\n        mock_client.close.assert_called_once()\n\n    @patch('redis.Redis')\n    def test_successful_connection_with_password_and_db(self, mock_redis):\n        # Test successful connection with password and non-default db\n        mock_client = mock_redis.return_value\n        mock_client.ping.return_value = True\n        \n        result = secure_redis_link('redis.example.com', 6380, redis_password='secure_pass', redis_db=5)\n        self.assertTrue(result)\n        mock_client.close.assert_called_once()\n\n    @patch('redis.Redis')\n    def test_connection_error(self, mock_redis):\n        # Test ConnectionError on unreachable host\n        mock_client = mock_redis.return_value\n        mock_client.ping.side_effect = redis.exceptions.ConnectionError(\"Connection failed\")\n        \n        with self.assertRaises(redis.exceptions.ConnectionError):\n            secure_redis_link('invalid.host', 6379)\n        mock_client.close.assert_called_once()\n\n    @patch('redis.Redis')\n    def test_ssl_error(self, mock_redis):\n        # Test SSLError on certificate validation failure\n        mock_client = mock_redis.return_value\n        mock_client.ping.side_effect = ssl.SSLError(\"SSL certificate verify failed\")\n        \n        with self.assertRaises(ssl.SSLError):\n            secure_redis_link('wrong.host', 6379)\n        mock_client.close.assert_called_once()\n\n    @patch('redis.Redis')\n    def test_ping_failure(self, mock_redis):\n        # Test ping returns False (simulate unexpected ping failure)\n        mock_client = mock_redis.return_value\n        mock_client.ping.return_value = False\n        \n        result = secure_redis_link('localhost', 6379)\n        self.assertFalse(result)\n        mock_client.close.assert_called_once()\n\n    @patch('redis.Redis')\n    def test_empty_host(self, mock_redis):\n        # Test ConnectionError with empty host\n        mock_client = mock_redis.return_value\n        mock_client.ping.side_effect = redis.exceptions.ConnectionError(\"Host required\")\n        \n        with self.assertRaises(redis.exceptions.ConnectionError):\n            secure_redis_link('', 6379)\n        mock_client.close.assert_called_once()\n\n    @patch('redis.Redis')\n    def test_negative_port(self, mock_redis):\n        # Test ConnectionError with negative port\n        mock_client = mock_redis.return_value\n        mock_client.ping.side_effect = redis.exceptions.ConnectionError(\"Invalid port\")\n        \n        with self.assertRaises(redis.exceptions.ConnectionError):\n            secure_redis_link('localhost', -6379)\n        mock_client.close.assert_called_once()\n\n    @patch('redis.Redis')\n    def test_incorrect_password(self, mock_redis):\n        # Test ConnectionError due to wrong password\n        mock_client = mock_redis.return_value\n        mock_client.ping.side_effect = redis.exceptions.ConnectionError(\"Authentication failed\")\n        \n        with self.assertRaises(redis.exceptions.ConnectionError):\n            secure_redis_link('localhost', 6379, redis_password='wrong')\n        mock_client.close.assert_called_once()\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 8, "task_id": "4e715879"}
{"test": "import unittest\nfrom unittest.mock import patch, MagicMock\nimport redis\nimport ssl\n\n# Import the function with a fallback for different module names\ntry:\n    from solution import secure_redis_conn\nexcept ImportError:\n    try:\n        from task import secure_redis_conn\n    except ImportError:\n        secure_redis_conn = None\n\nclass TestSecureRedisConn(unittest.TestCase):\n\n    @patch('redis.Redis')\n    def test_successful_connection_no_password(self, mock_redis):\n        \"\"\"Test successful connection without password.\"\"\"\n        mock_client = MagicMock()\n        mock_client.ping.return_value = True\n        mock_redis.return_value = mock_client\n        \n        result = secure_redis_conn('localhost', 6379)\n        self.assertTrue(result)\n        mock_client.close.assert_called_once()\n\n    @patch('redis.Redis')\n    def test_successful_connection_with_password_and_db(self, mock_redis):\n        \"\"\"Test successful connection with password and non-default database.\"\"\"\n        mock_client = MagicMock()\n        mock_client.ping.return_value = True\n        mock_redis.return_value = mock_client\n        \n        result = secure_redis_conn('redis.example.com', 6380, redis_pw='secure_password', redis_db_index=1)\n        self.assertTrue(result)\n        mock_client.close.assert_called_once()\n\n    @patch('redis.Redis')\n    def test_ping_failure(self, mock_redis):\n        \"\"\"Test connection established but ping returns False.\"\"\"\n        mock_client = MagicMock()\n        mock_client.ping.return_value = False\n        mock_redis.return_value = mock_client\n        \n        result = secure_redis_conn('localhost', 6379)\n        self.assertFalse(result)\n        mock_client.close.assert_called_once()\n\n    @patch('redis.Redis')\n    def test_connection_error(self, mock_redis):\n        \"\"\"Test ConnectionError raised during connection attempt.\"\"\"\n        mock_client = MagicMock()\n        mock_client.ping.side_effect = redis.exceptions.ConnectionError(\"Connection failed\")\n        mock_redis.return_value = mock_client\n        \n        with self.assertRaises(redis.exceptions.ConnectionError) as context:\n            secure_redis_conn('invalid.host', 6379)\n        self.assertIn(\"Redis connection error\", str(context.exception))\n        mock_client.close.assert_called_once()\n\n    @patch('redis.Redis')\n    def test_ssl_error(self, mock_redis):\n        \"\"\"Test SSLError raised during SSL handshake.\"\"\"\n        mock_client = MagicMock()\n        mock_client.ping.side_effect = ssl.SSLError(\"SSL handshake failure\")\n        mock_redis.return_value = mock_client\n        \n        with self.assertRaises(ssl.SSLError) as context:\n            secure_redis_conn('ssl.host', 6379)\n        self.assertIn(\"SSL certificate validation failed\", str(context.exception))\n        mock_client.close.assert_called_once()\n\n    @patch('redis.Redis')\n    def test_authentication_error(self, mock_redis):\n        \"\"\"Test invalid password raises ConnectionError (via AuthenticationError).\"\"\"\n        mock_client = MagicMock()\n        mock_client.ping.side_effect = redis.exceptions.AuthenticationError(\"Invalid password\")\n        mock_redis.return_value = mock_client\n        \n        with self.assertRaises(redis.exceptions.ConnectionError) as context:\n            secure_redis_conn('protected.host', 6379, redis_pw='wrong_password')\n        self.assertIn(\"Redis connection error\", str(context.exception))\n        mock_client.close.assert_called_once()\n\n    def test_invalid_port_type(self):\n        \"\"\"Test TypeError raised when port is not an integer.\"\"\"\n        with self.assertRaises(TypeError):\n            secure_redis_conn('localhost', '6379')\n\n    def test_invalid_host_type(self):\n        \"\"\"Test TypeError raised when host is not a string.\"\"\"\n        with self.assertRaises(TypeError):\n            secure_redis_conn(12345, 6379)\n\n    def test_invalid_db_index_type(self):\n        \"\"\"Test TypeError raised when redis_db_index is not an integer.\"\"\"\n        with self.assertRaises(TypeError):\n            secure_redis_conn('localhost', 6379, redis_db_index='0')\n\n    def test_invalid_ssl_certificate_verification(self):\n        \"\"\"Test SSL certificate verification failure (simulated via SSLError).\"\"\"\n        with patch('redis.Redis') as mock_redis:\n            mock_client = MagicMock()\n            mock_client.ping.side_effect = ssl.SSLError(\"CERTIFICATE_VERIFY_FAILED\")\n            mock_redis.return_value = mock_client\n            \n            with self.assertRaises(ssl.SSLError) as context:\n                secure_redis_conn('untrusted.host', 6379)\n            self.assertIn(\"SSL certificate validation failed\", str(context.exception))\n            mock_client.close.assert_called_once()\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 10, "task_id": "87599db6"}
{"test": "import unittest\nfrom unittest.mock import patch, Mock, ANY\nimport redis\nimport ssl\n\nclass TestSecureRedisLinkage(unittest.TestCase):\n\n    @patch('redis.Redis')\n    def test_success_without_optional_parameters(self, mock_redis):\n        \"\"\"Test successful connection without optional parameters.\"\"\"\n        mock_client = mock_redis.return_value\n        mock_client.ping.return_value = 'PONG'\n        \n        result = secure_redis_linkage('localhost', 6379)\n        \n        self.assertTrue(result)\n        mock_redis.assert_called_once_with(\n            host='localhost',\n            port=6379,\n            password=None,\n            db=0,\n            ssl=True,\n            ssl_cert_reqs='required',\n            ssl_ca_certs=None,\n            ssl_context=ANY\n        )\n        mock_client.close.assert_called_once()\n\n    @patch('redis.Redis')\n    def test_success_with_optional_parameters(self, mock_redis):\n        \"\"\"Test successful connection with password and custom database.\"\"\"\n        mock_client = mock_redis.return_value\n        mock_client.ping.return_value = 'PONG'\n        \n        result = secure_redis_linkage('redis.example.com', 6380, 'securepass', 2)\n        \n        self.assertTrue(result)\n        mock_redis.assert_called_once_with(\n            host='redis.example.com',\n            port=6380,\n            password='securepass',\n            db=2,\n            ssl=True,\n            ssl_cert_reqs='required',\n            ssl_ca_certs=None,\n            ssl_context=ANY\n        )\n        mock_client.close.assert_called_once()\n\n    @patch('redis.Redis')\n    def test_ping_returns_false(self, mock_redis):\n        \"\"\"Test handling when ping returns False.\"\"\"\n        mock_client = mock_redis.return_value\n        mock_client.ping.return_value = False\n        \n        result = secure_redis_linkage('localhost', 6379)\n        \n        self.assertFalse(result)\n        mock_client.close.assert_called_once()\n\n    @patch('redis.Redis')\n    def test_connection_error(self, mock_redis):\n        \"\"\"Test handling of Redis connection error.\"\"\"\n        mock_client = mock_redis.return_value\n        mock_client.ping.side_effect = redis.exceptions.ConnectionError('Connection failed')\n        \n        with self.assertRaises(redis.exceptions.ConnectionError) as context:\n            secure_redis_linkage('invalid.host', 6379)\n        self.assertIn('Redis connection error', str(context.exception))\n        mock_client.close.assert_called_once()\n\n    @patch('redis.Redis')\n    def test_ssl_error(self, mock_redis):\n        \"\"\"Test handling of SSL certificate validation error.\"\"\"\n        mock_client = mock_redis.return_value\n        mock_client.ping.side_effect = ssl.SSLError('SSL handshake failed')\n        \n        with self.assertRaises(ssl.SSLError) as context:\n            secure_redis_linkage('localhost', 6379)\n        self.assertIn('SSL certificate validation failed', str(context.exception))\n        mock_client.close.assert_called_once()\n\n    @patch('redis.Redis')\n    def test_empty_host(self, mock_redis):\n        \"\"\"Test empty string for host parameter.\"\"\"\n        mock_client = mock_redis.return_value\n        mock_client.ping.return_value = 'PONG'\n        \n        result = secure_redis_linkage('', 6379)\n        \n        self.assertTrue(result)\n        mock_redis.assert_called_once_with(\n            host='',\n            port=6379,\n            password=None,\n            db=0,\n            ssl=True,\n            ssl_cert_reqs='required',\n            ssl_ca_certs=None,\n            ssl_context=ANY\n        )\n        mock_client.close.assert_called_once()\n\n    @patch('redis.Redis')\n    def test_long_host(self, mock_redis):\n        \"\"\"Test very long host string.\"\"\"\n        mock_client = mock_redis.return_value\n        mock_client.ping.return_value = 'PONG'\n        long_host = 'a' * 1000\n        \n        result = secure_redis_linkage(long_host, 6379)\n        \n        self.assertTrue(result)\n        mock_redis.assert_called_once_with(\n            host=long_host,\n            port=6379,\n            password=None,\n            db=0,\n            ssl=True,\n            ssl_cert_reqs='required',\n            ssl_ca_certs=None,\n            ssl_context=ANY\n        )\n        mock_client.close.assert_called_once()\n\n    @patch('redis.Redis')\n    def test_long_password(self, mock_redis):\n        \"\"\"Test very long password string.\"\"\"\n        mock_client = mock_redis.return_value\n        mock_client.ping.return_value = 'PONG'\n        long_pass = 'b' * 1000\n        \n        result = secure_redis_linkage('localhost', 6379, long_pass)\n        \n        self.assertTrue(result)\n        mock_redis.assert_called_once_with(\n            host='localhost',\n            port=6379,\n            password=long_pass,\n            db=0,\n            ssl=True,\n            ssl_cert_reqs='required',\n            ssl_ca_certs=None,\n            ssl_context=ANY\n        )\n        mock_client.close.assert_called_once()\n\n    @patch('redis.Redis')\n    def test_invalid_port_type(self, mock_redis):\n        \"\"\"Test non-integer port type (simulate NameError from finally block).\"\"\"\n        mock_redis.side_effect = TypeError(\"Port must be integer\")\n        \n        with self.assertRaises(NameError):\n            secure_redis_linkage('localhost', '6379')\n\n    @patch('redis.Redis')\n    def test_invalid_host_type(self, mock_redis):\n        \"\"\"Test non-string host type (simulate NameError from finally block).\"\"\"\n        mock_redis.side_effect = TypeError(\"Host must be string\")\n        \n        with self.assertRaises(NameError):\n            secure_redis_linkage(12345, 6379)\n\n    @patch('redis.Redis')\n    def test_invalid_database_type(self, mock_redis):\n        \"\"\"Test non-integer database type (simulate NameError from finally block).\"\"\"\n        mock_redis.side_effect = TypeError(\"Database must be integer\")\n        \n        with self.assertRaises(NameError):\n            secure_redis_linkage('localhost', 6379, redis_database='0')\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 11, "task_id": "07619d8a"}
{"test": "import unittest\nfrom unittest.mock import patch, MagicMock\nimport ssl\nimport redis.exceptions\n\nclass TestConnectToRedisSecurely(unittest.TestCase):\n\n    @patch('ssl.create_default_context')\n    @patch('redis.Redis')\n    def test_successful_connection(self, mock_redis, mock_ssl_context):\n        \"\"\"Test successful connection and ping returns True.\"\"\"\n        mock_client = mock_redis.return_value\n        mock_client.ping.return_value = True\n        \n        result = connect_to_redis_securely('redis.example.com', 6379, 'password123', 1)\n        \n        self.assertTrue(result)\n        mock_ssl_context.assert_called_once()\n        mock_redis.assert_called_once_with(host='redis.example.com', port=6379, password='password123', db=1, \n                                          ssl=True, ssl_cert_reqs='required', ssl_ca_certs=None, \n                                          ssl_context=mock_ssl_context.return_value)\n        mock_client.close.assert_called_once()\n\n    @patch('ssl.create_default_context')\n    @patch('redis.Redis')\n    def test_failed_ping(self, mock_redis, mock_ssl_context):\n        \"\"\"Test when ping returns False.\"\"\"\n        mock_client = mock_redis.return_value\n        mock_client.ping.return_value = False\n        \n        result = connect_to_redis_securely('localhost', 6380)\n        \n        self.assertFalse(result)\n        mock_client.close.assert_called_once()\n\n    @patch('ssl.create_default_context')\n    @patch('redis.Redis')\n    def test_connection_error(self, mock_redis, mock_ssl_context):\n        \"\"\"Test handling of redis.exceptions.ConnectionError.\"\"\"\n        mock_client = mock_redis.return_value\n        mock_client.ping.side_effect = redis.exceptions.ConnectionError('Connection failed')\n        \n        with self.assertRaises(redis.exceptions.ConnectionError):\n            connect_to_redis_securely('invalid.host', 6379)\n        \n        mock_client.close.assert_called_once()\n\n    @patch('ssl.create_default_context')\n    @patch('redis.Redis')\n    def test_ssl_error(self, mock_redis, mock_ssl_context):\n        \"\"\"Test handling of ssl.SSLError.\"\"\"\n        mock_client = mock_redis.return_value\n        mock_client.ping.side_effect = ssl.SSLError('SSL handshake failed')\n        \n        with self.assertRaises(ssl.SSLError):\n            connect_to_redis_securely('secure.redis.com', 6379)\n        \n        mock_client.close.assert_called_once()\n\n    @patch('ssl.create_default_context')\n    @patch('redis.Redis')\n    def test_arguments_without_authentication(self, mock_redis, mock_ssl_context):\n        \"\"\"Test with minimal arguments (no password, default db_index).\"\"\"\n        mock_client = mock_redis.return_value\n        mock_client.ping.return_value = True\n        \n        result = connect_to_redis_securely('localhost', 6379)\n        \n        self.assertTrue(result)\n        mock_redis.assert_called_once_with(host='localhost', port=6379, password=None, db=0, \n                                          ssl=True, ssl_cert_reqs='required', ssl_ca_certs=None, \n                                          ssl_context=mock_ssl_context.return_value)\n\n    @patch('ssl.create_default_context')\n    @patch('redis.Redis')\n    def test_edge_case_arguments(self, mock_redis, mock_ssl_context):\n        \"\"\"Test edge cases: empty server_address, port 0, empty password.\"\"\"\n        mock_client = mock_redis.return_value\n        mock_client.ping.return_value = True\n        \n        result = connect_to_redis_securely('', 0, '', 0)\n        \n        self.assertTrue(result)\n        mock_redis.assert_called_once_with(host='', port=0, password='', db=0, \n                                          ssl=True, ssl_cert_reqs='required', ssl_ca_certs=None, \n                                          ssl_context=mock_ssl_context.return_value)\n\n    @patch('ssl.create_default_context')\n    @patch('redis.Redis')\n    def test_empty_password(self, mock_redis, mock_ssl_context):\n        \"\"\"Test with empty string password.\"\"\"\n        mock_client = mock_redis.return_value\n        mock_client.ping.return_value = True\n        \n        result = connect_to_redis_securely('localhost', 6379, '')\n        \n        self.assertTrue(result)\n        mock_redis.assert_called_once_with(host='localhost', port=6379, password='', db=0, \n                                          ssl=True, ssl_cert_reqs='required', ssl_ca_certs=None, \n                                          ssl_context=mock_ssl_context.return_value)\n\n    @patch('ssl.create_default_context')\n    @patch('redis.Redis')\n    def test_non_default_db_index(self, mock_redis, mock_ssl_context):\n        \"\"\"Test with non-default db_index.\"\"\"\n        mock_client = mock_redis.return_value\n        mock_client.ping.return_value = True\n        \n        result = connect_to_redis_securely('db.redis.com', 6379, db_index=5)\n        \n        self.assertTrue(result)\n        mock_redis.assert_called_once_with(host='db.redis.com', port=6379, password=None, db=5, \n                                          ssl=True, ssl_cert_reqs='required', ssl_ca_certs=None, \n                                          ssl_context=mock_ssl_context.return_value)\n\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 8, "task_id": "a07a8a6c"}
{"test": "import unittest\nimport unittest.mock as mock\nimport redis\nimport ssl\nfrom solution import redis_ssl_connect\n\nclass TestRedisSSLConnect(unittest.TestCase):\n\n    @mock.patch('solution.ssl.create_default_context')\n    @mock.patch('solution.redis.Redis')\n    def test_success_without_auth(self, mock_redis, mock_ssl_context):\n        # Test successful connection without authentication and default database\n        mock_redis_instance = mock_redis.return_value\n        mock_redis_instance.ping.return_value = True\n        result = redis_ssl_connect('localhost', 6379)\n        self.assertTrue(result)\n        mock_ssl_context.assert_called_once()\n        mock_redis.assert_called_once_with(\n            host='localhost',\n            port=6379,\n            password=None,\n            db=0,\n            ssl=True,\n            ssl_cert_reqs='required',\n            ssl_ca_certs=None,\n            ssl_context=mock_ssl_context.return_value\n        )\n        mock_redis_instance.ping.assert_called_once()\n        mock_redis_instance.close.assert_called_once()\n\n    @mock.patch('solution.ssl.create_default_context')\n    @mock.patch('solution.redis.Redis')\n    def test_success_with_auth(self, mock_redis, mock_ssl_context):\n        # Test successful connection with authentication and non-default database\n        mock_redis_instance = mock_redis.return_value\n        mock_redis_instance.ping.return_value = True\n        result = redis_ssl_connect('redis.example.com', 6380, auth_password='securepassword', database_id=1)\n        self.assertTrue(result)\n        mock_redis.assert_called_once_with(\n            host='redis.example.com',\n            port=6380,\n            password='securepassword',\n            db=1,\n            ssl=True,\n            ssl_cert_reqs='required',\n            ssl_ca_certs=None,\n            ssl_context=mock_ssl_context.return_value\n        )\n        mock_redis_instance.ping.assert_called_once()\n        mock_redis_instance.close.assert_called_once()\n\n    @mock.patch('solution.ssl.create_default_context')\n    @mock.patch('solution.redis.Redis')\n    def test_ping_failure(self, mock_redis, mock_ssl_context):\n        # Test ping failure after connection\n        mock_redis_instance = mock_redis.return_value\n        mock_redis_instance.ping.return_value = False\n        result = redis_ssl_connect('localhost', 6379)\n        self.assertFalse(result)\n        mock_redis_instance.ping.assert_called_once()\n        mock_redis_instance.close.assert_called_once()\n\n    @mock.patch('solution.ssl.create_default_context')\n    @mock.patch('solution.redis.Redis')\n    def test_connection_error(self, mock_redis, mock_ssl_context):\n        # Test connection error handling\n        mock_redis_instance = mock_redis.return_value\n        mock_redis_instance.ping.side_effect = redis.exceptions.ConnectionError(\"Connection refused\")\n        with self.assertRaises(redis.exceptions.ConnectionError) as cm:\n            redis_ssl_connect('localhost', 6379)\n        self.assertIn(\"Redis connection error\", str(cm.exception))\n        mock_redis_instance.close.assert_called_once()\n\n    @mock.patch('solution.ssl.create_default_context')\n    @mock.patch('solution.redis.Redis')\n    def test_ssl_error(self, mock_redis, mock_ssl_context):\n        # Test SSL certificate validation error\n        mock_redis_instance = mock_redis.return_value\n        mock_redis_instance.ping.side_effect = ssl.SSLError(\"Certificate verify failed\")\n        with self.assertRaises(ssl.SSLError) as cm:\n            redis_ssl_connect('localhost', 6379)\n        self.assertIn(\"SSL certificate validation failed\", str(cm.exception))\n        mock_redis_instance.close.assert_called_once()\n\n    @mock.patch('solution.ssl.create_default_context')\n    @mock.patch('solution.redis.Redis')\n    def test_invalid_port_string(self, mock_redis, mock_ssl_context):\n        # Test invalid port type (string)\n        mock_ssl_context.return_value = mock.MagicMock()\n        mock_redis.side_effect = TypeError(\"port must be integer\")\n        with self.assertRaises(UnboundLocalError):\n            redis_ssl_connect('localhost', '6379')\n        mock_ssl_context.assert_called_once()\n        mock_redis.assert_called_once()\n\n    @mock.patch('solution.ssl.create_default_context')\n    @mock.patch('solution.redis.Redis')\n    def test_invalid_port_float(self, mock_redis, mock_ssl_context):\n        # Test invalid port type (float)\n        mock_ssl_context.return_value = mock.MagicMock()\n        mock_redis.side_effect = TypeError(\"port must be integer\")\n        with self.assertRaises(UnboundLocalError):\n            redis_ssl_connect('localhost', 6379.5)\n        mock_ssl_context.assert_called_once()\n        mock_redis.assert_called_once()\n\n    @mock.patch('solution.ssl.create_default_context')\n    @mock.patch('solution.redis.Redis')\n    def test_invalid_host_none(self, mock_redis, mock_ssl_context):\n        # Test invalid host type (None)\n        mock_ssl_context.return_value = mock.MagicMock()\n        mock_redis.side_effect = TypeError(\"host must be a string\")\n        with self.assertRaises(UnboundLocalError):\n            redis_ssl_connect(None, 6379)\n        mock_ssl_context.assert_called_once()\n        mock_redis.assert_called_once()\n\n    @mock.patch('solution.ssl.create_default_context')\n    @mock.patch('solution.redis.Redis')\n    def test_invalid_host_int(self, mock_redis, mock_ssl_context):\n        # Test invalid host type (integer)\n        mock_ssl_context.return_value = mock.MagicMock()\n        mock_redis.side_effect = TypeError(\"host must be a string\")\n        with self.assertRaises(UnboundLocalError):\n            redis_ssl_connect(123, 6379)\n        mock_ssl_context.assert_called_once()\n        mock_redis.assert_called_once()\n\n    @mock.patch('solution.ssl.create_default_context')\n    @mock.patch('solution.redis.Redis')\n    def test_invalid_db_string(self, mock_redis, mock_ssl_context):\n        # Test invalid database ID type (string)\n        mock_ssl_context.return_value = mock.MagicMock()\n        mock_redis.side_effect = TypeError(\"db must be an integer\")\n        with self.assertRaises(UnboundLocalError):\n            redis_ssl_connect('localhost', 6379, database_id='1')\n        mock_ssl_context.assert_called_once()\n        mock_redis.assert_called_once()\n\n    @mock.patch('solution.ssl.create_default_context')\n    @mock.patch('solution.redis.Redis')\n    def test_invalid_auth_password_int(self, mock_redis, mock_ssl_context):\n        # Test invalid password type (integer)\n        mock_ssl_context.return_value = mock.MagicMock()\n        mock_redis.side_effect = TypeError(\"password must be a string or None\")\n        with self.assertRaises(UnboundLocalError):\n            redis_ssl_connect('localhost', 6379, auth_password=123)\n        mock_ssl_context.assert_called_once()\n        mock_redis.assert_called_once()\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 11, "task_id": "cab39aa1"}
{"test": "import unittest\nfrom unittest.mock import patch, MagicMock\nimport ssl\nimport redis\n\nclass TestSecureRedisSSLConnect(unittest.TestCase):\n\n    @patch('redis.Redis')\n    @patch('ssl.create_default_context')\n    def test_success_with_all_parameters(self, mock_create_context, mock_redis):\n        # Test successful connection with all parameters including password and non-default db\n        mock_client = mock_redis.return_value\n        mock_client.ping.return_value = True\n        \n        result = secure_redis_ssl_connect('redis.example.com', 6379, 'password123', 1)\n        \n        self.assertTrue(result)\n        mock_create_context.assert_called_once()\n        mock_redis.assert_called_once_with(\n            host='redis.example.com',\n            port=6379,\n            password='password123',\n            db=1,\n            ssl=True,\n            ssl_cert_reqs='required',\n            ssl_ca_certs=None,\n            ssl_context=mock_create_context.return_value\n        )\n        mock_client.close.assert_called_once()\n\n    @patch('redis.Redis')\n    @patch('ssl.create_default_context')\n    def test_success_minimal_parameters(self, mock_create_context, mock_redis):\n        # Test successful connection with minimal parameters (no password, default db)\n        mock_client = mock_redis.return_value\n        mock_client.ping.return_value = True\n        \n        result = secure_redis_ssl_connect('localhost', 6380)\n        \n        self.assertTrue(result)\n        mock_redis.assert_called_once_with(\n            host='localhost',\n            port=6380,\n            password=None,\n            db=0,\n            ssl=True,\n            ssl_cert_reqs='required',\n            ssl_ca_certs=None,\n            ssl_context=mock_create_context.return_value\n        )\n        mock_client.close.assert_called_once()\n\n    @patch('redis.Redis')\n    @patch('ssl.create_default_context')\n    def test_ping_failure(self, mock_create_context, mock_redis):\n        # Test connection where ping operation returns False\n        mock_client = mock_redis.return_value\n        mock_client.ping.return_value = False\n        \n        result = secure_redis_ssl_connect('localhost', 6379)\n        \n        self.assertFalse(result)\n        mock_client.close.assert_called_once()\n\n    @patch('redis.Redis')\n    @patch('ssl.create_default_context')\n    def test_connection_error(self, mock_create_context, mock_redis):\n        # Test handling of redis.exceptions.ConnectionError\n        mock_client = mock_redis.return_value\n        mock_client.ping.side_effect = redis.exceptions.ConnectionError('Connection failed')\n        \n        with self.assertRaises(redis.exceptions.ConnectionError) as context:\n            secure_redis_ssl_connect('invalid.host', 6379)\n        \n        self.assertIn('Redis connection error: Connection failed', str(context.exception))\n        mock_client.close.assert_called_once()\n\n    @patch('redis.Redis')\n    @patch('ssl.create_default_context')\n    def test_ssl_error(self, mock_create_context, mock_redis):\n        # Test handling of ssl.SSLError during connection\n        mock_client = mock_redis.return_value\n        mock_client.ping.side_effect = ssl.SSLError('SSL problem')\n        \n        with self.assertRaises(ssl.SSLError) as context:\n            secure_redis_ssl_connect('secure.host', 6379)\n        \n        self.assertIn('SSL certificate validation failed: SSL problem', str(context.exception))\n        mock_client.close.assert_called_once()\n\n    @patch('redis.Redis', side_effect=TypeError('Port must be integer'))\n    @patch('ssl.create_default_context')\n    def test_constructor_failure(self, mock_create_context, mock_redis):\n        # Test failure during Redis client construction (e.g., invalid port type)\n        with self.assertRaises(NameError) as context:\n            secure_redis_ssl_connect('localhost', '6379')\n        \n        self.assertIn('name \\'client\\' is not defined', str(context.exception))\n\n    @patch('ssl.create_default_context', side_effect=ssl.SSLError('SSL context failed'))\n    def test_ssl_context_failure(self, mock_create_context):\n        # Test failure during SSL context creation\n        with self.assertRaises(NameError) as context:\n            secure_redis_ssl_connect('localhost', 6379)\n        \n        self.assertIn('name \\'client\\' is not defined', str(context.exception))\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 7, "task_id": "3c3f6a6a"}
{"test": "import unittest\nfrom unittest.mock import patch, MagicMock\nimport ssl\nimport redis\nfrom solution import establish_secure_redis_connection\n\nclass TestCases(unittest.TestCase):\n\n    @patch('solution.ssl.create_default_context')\n    @patch('solution.redis.Redis')\n    def test_case_1(self, mock_redis, mock_create_ctx):\n        # Test successful connection with default arguments\n        mock_ctx = MagicMock()\n        mock_create_ctx.return_value = mock_ctx\n        mock_client = MagicMock()\n        mock_redis.return_value = mock_client\n        mock_client.ping.return_value = True\n        \n        result = establish_secure_redis_connection('localhost', 6379)\n        \n        mock_create_ctx.assert_called_once()\n        mock_redis.assert_called_once_with(\n            host='localhost',\n            port=6379,\n            password=None,\n            db=0,\n            ssl=True,\n            ssl_cert_reqs='required',\n            ssl_ca_certs=None,\n            ssl_context=mock_ctx\n        )\n        mock_client.ping.assert_called_once()\n        mock_client.close.assert_called_once()\n        self.assertTrue(result)\n\n    @patch('solution.ssl.create_default_context')\n    @patch('solution.redis.Redis')\n    def test_case_2(self, mock_redis, mock_create_ctx):\n        # Test failed ping response\n        mock_ctx = MagicMock()\n        mock_create_ctx.return_value = mock_ctx\n        mock_client = MagicMock()\n        mock_redis.return_value = mock_client\n        mock_client.ping.return_value = False\n        \n        result = establish_secure_redis_connection('redis.example.com', 6380)\n        \n        mock_client.ping.assert_called_once()\n        mock_client.close.assert_called_once()\n        self.assertFalse(result)\n\n    @patch('solution.ssl.create_default_context')\n    @patch('solution.redis.Redis')\n    def test_case_3(self, mock_redis, mock_create_ctx):\n        # Test ConnectionError during ping\n        mock_ctx = MagicMock()\n        mock_create_ctx.return_value = mock_ctx\n        mock_client = MagicMock()\n        mock_redis.return_value = mock_client\n        mock_client.ping.side_effect = redis.exceptions.ConnectionError('Connection failed')\n        \n        with self.assertRaises(redis.exceptions.ConnectionError) as cm:\n            establish_secure_redis_connection('invalid.host', 6379)\n        self.assertEqual(str(cm.exception), 'Redis connection error: Connection failed')\n        mock_client.close.assert_called_once()\n\n    @patch('solution.ssl.create_default_context')\n    @patch('solution.redis.Redis')\n    def test_case_4(self, mock_redis, mock_create_ctx):\n        # Test SSLError during ping\n        mock_ctx = MagicMock()\n        mock_create_ctx.return_value = mock_ctx\n        mock_client = MagicMock()\n        mock_redis.return_value = mock_client\n        mock_client.ping.side_effect = ssl.SSLError('Certificate verification failed')\n        \n        with self.assertRaises(ssl.SSLError) as cm:\n            establish_secure_redis_connection('untrusted.host', 6379)\n        self.assertEqual(str(cm.exception), 'SSL certificate validation failed: Certificate verification failed')\n        mock_client.close.assert_called_once()\n\n    @patch('solution.ssl.create_default_context')\n    @patch('solution.redis.Redis')\n    def test_case_5(self, mock_redis, mock_create_ctx):\n        # Test non-default arguments (password and db)\n        mock_ctx = MagicMock()\n        mock_create_ctx.return_value = mock_ctx\n        mock_client = MagicMock()\n        mock_redis.return_value = mock_client\n        mock_client.ping.return_value = True\n        \n        result = establish_secure_redis_connection('db.example.com', 6379, 'secure_password', 1)\n        \n        mock_redis.assert_called_once_with(\n            host='db.example.com',\n            port=6379,\n            password='secure_password',\n            db=1,\n            ssl=True,\n            ssl_cert_reqs='required',\n            ssl_ca_certs=None,\n            ssl_context=mock_ctx\n        )\n        mock_client.close.assert_called_once()\n        self.assertTrue(result)\n\n    @patch('solution.ssl.create_default_context')\n    @patch('solution.redis.Redis')\n    def test_case_6(self, mock_redis, mock_create_ctx):\n        # Test edge arguments: empty host, port 0, empty password, large db\n        mock_ctx = MagicMock()\n        mock_create_ctx.return_value = mock_ctx\n        mock_client = MagicMock()\n        mock_redis.return_value = mock_client\n        mock_client.ping.return_value = True\n        \n        result = establish_secure_redis_connection('', 0, '', 9999)\n        \n        mock_redis.assert_called_once_with(\n            host='',\n            port=0,\n            password='',\n            db=9999,\n            ssl=True,\n            ssl_cert_reqs='required',\n            ssl_ca_certs=None,\n            ssl_context=mock_ctx\n        )\n        mock_client.close.assert_called_once()\n        self.assertTrue(result)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 6, "task_id": "606b6e02"}
{"test": "import unittest\nfrom unittest.mock import patch, MagicMock\nimport ssl\nimport redis\nfrom solution import initialize_secure_redis_conn\n\nclass TestInitializeSecureRedisConn(unittest.TestCase):\n\n    @patch('ssl.create_default_context')\n    @patch('redis.Redis')\n    def test_case_1_basic_success(self, mock_redis_class, mock_create_context):\n        # Test successful connection without auth and default db\n        mock_client = MagicMock()\n        mock_redis_class.return_value = mock_client\n        mock_client.ping.return_value = True\n        mock_ssl_context = MagicMock()\n        mock_create_context.return_value = mock_ssl_context\n\n        result = initialize_secure_redis_conn('localhost', 6379)\n\n        mock_create_context.assert_called_once()\n        mock_redis_class.assert_called_once_with(\n            host='localhost',\n            port=6379,\n            password=None,\n            db=0,\n            ssl=True,\n            ssl_cert_reqs='required',\n            ssl_ca_certs=None,\n            ssl_context=mock_ssl_context\n        )\n        mock_client.ping.assert_called_once()\n        self.assertTrue(result)\n        mock_client.close.assert_called_once()\n\n    @patch('ssl.create_default_context')\n    @patch('redis.Redis')\n    def test_case_2_success_with_auth_and_db(self, mock_redis_class, mock_create_context):\n        # Test successful connection with auth and non-default db\n        mock_client = MagicMock()\n        mock_redis_class.return_value = mock_client\n        mock_client.ping.return_value = True\n        mock_ssl_context = MagicMock()\n        mock_create_context.return_value = mock_ssl_context\n\n        result = initialize_secure_redis_conn('redis.example.com', 6380, 'password123', 1)\n\n        mock_redis_class.assert_called_once_with(\n            host='redis.example.com',\n            port=6380,\n            password='password123',\n            db=1,\n            ssl=True,\n            ssl_cert_reqs='required',\n            ssl_ca_certs=None,\n            ssl_context=mock_ssl_context\n        )\n        mock_client.ping.assert_called_once()\n        self.assertTrue(result)\n        mock_client.close.assert_called_once()\n\n    @patch('ssl.create_default_context')\n    @patch('redis.Redis')\n    def test_case_3_ping_false(self, mock_redis_class, mock_create_context):\n        # Test when ping returns False\n        mock_client = MagicMock()\n        mock_redis_class.return_value = mock_client\n        mock_client.ping.return_value = False\n        mock_ssl_context = MagicMock()\n        mock_create_context.return_value = mock_ssl_context\n\n        result = initialize_secure_redis_conn('localhost', 6379)\n\n        self.assertFalse(result)\n        mock_client.close.assert_called_once()\n\n    @patch('ssl.create_default_context')\n    @patch('redis.Redis')\n    def test_case_4_connection_error(self, mock_redis_class, mock_create_context):\n        # Test ConnectionError during ping\n        mock_client = MagicMock()\n        mock_redis_class.return_value = mock_client\n        mock_client.ping.side_effect = redis.exceptions.ConnectionError('Connection failed')\n        mock_ssl_context = MagicMock()\n        mock_create_context.return_value = mock_ssl_context\n\n        with self.assertRaises(redis.exceptions.ConnectionError) as context:\n            initialize_secure_redis_conn('localhost', 6379)\n        self.assertIn('Redis connection error: Connection failed', str(context.exception))\n        mock_client.close.assert_called_once()\n\n    @patch('ssl.create_default_context')\n    @patch('redis.Redis')\n    def test_case_5_ssl_error(self, mock_redis_class, mock_create_context):\n        # Test SSLError during ping\n        mock_client = MagicMock()\n        mock_redis_class.return_value = mock_client\n        mock_client.ping.side_effect = ssl.SSLError('SSL problem')\n        mock_ssl_context = MagicMock()\n        mock_create_context.return_value = mock_ssl_context\n\n        with self.assertRaises(ssl.SSLError) as context:\n            initialize_secure_redis_conn('localhost', 6379)\n        self.assertIn('SSL certificate validation failed: SSL problem', str(context.exception))\n        mock_client.close.assert_called_once()\n\n    @patch('ssl.create_default_context')\n    @patch('redis.Redis')\n    def test_case_6_empty_server(self, mock_redis_class, mock_create_context):\n        # Test with empty server string\n        mock_client = MagicMock()\n        mock_redis_class.return_value = mock_client\n        mock_client.ping.return_value = True\n        mock_ssl_context = MagicMock()\n        mock_create_context.return_value = mock_ssl_context\n\n        initialize_secure_redis_conn('', 6379)\n\n        mock_redis_class.assert_called_once()\n        args, kwargs = mock_redis_class.call_args\n        self.assertEqual(kwargs['host'], '')\n        self.assertEqual(kwargs['port'], 6379)\n        mock_client.close.assert_called_once()\n\n    @patch('ssl.create_default_context')\n    @patch('redis.Redis')\n    def test_case_7_port_zero(self, mock_redis_class, mock_create_context):\n        # Test with port 0\n        mock_client = MagicMock()\n        mock_redis_class.return_value = mock_client\n        mock_client.ping.return_value = True\n        mock_ssl_context = MagicMock()\n        mock_create_context.return_value = mock_ssl_context\n\n        initialize_secure_redis_conn('localhost', 0)\n\n        mock_redis_class.assert_called_once()\n        args, kwargs = mock_redis_class.call_args\n        self.assertEqual(kwargs['host'], 'localhost')\n        self.assertEqual(kwargs['port'], 0)\n        mock_client.close.assert_called_once()\n\n    @patch('ssl.create_default_context')\n    @patch('redis.Redis')\n    def test_case_8_large_port(self, mock_redis_class, mock_create_context):\n        # Test with very large port number\n        mock_client = MagicMock()\n        mock_redis_class.return_value = mock_client\n        mock_client.ping.return_value = True\n        mock_ssl_context = MagicMock()\n        mock_create_context.return_value = mock_ssl_context\n\n        initialize_secure_redis_conn('localhost', 65536)\n\n        mock_redis_class.assert_called_once()\n        args, kwargs = mock_redis_class.call_args\n        self.assertEqual(kwargs['host'], 'localhost')\n        self.assertEqual(kwargs['port'], 65536)\n        mock_client.close.assert_called_once()\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 8, "task_id": "b3d5315a"}
{"test": "import unittest\nfrom unittest.mock import patch, MagicMock\nimport redis\nimport ssl\n\n# Import the function from the solution module\nfrom solution import create_secure_redis_conn\n\nclass TestCreateSecureRedisConn(unittest.TestCase):\n\n    @patch('ssl.create_default_context')\n    @patch('redis.Redis')\n    def test_successful_connection(self, mock_redis, mock_ssl_ctx):\n        # Test typical connection with default parameters (no password, db=0)\n        mock_client = mock_redis.return_value\n        mock_client.ping.return_value = \"PONG\"\n        mock_ssl_ctx.return_value = MagicMock(spec=ssl.SSLContext)\n        \n        with patch('builtins.print') as mock_print:\n            result = create_secure_redis_conn('localhost', 6379)\n            self.assertTrue(result)\n            mock_print.assert_called_once_with(\"Successfully connected to Redis server\")\n        mock_client.close.assert_called_once()\n\n    @patch('ssl.create_default_context')\n    @patch('redis.Redis')\n    def test_successful_connection_with_password(self, mock_redis, mock_ssl_ctx):\n        # Test connection with password authentication\n        mock_client = mock_redis.return_value\n        mock_client.ping.return_value = \"PONG\"\n        mock_ssl_ctx.return_value = MagicMock(spec=ssl.SSLContext)\n        \n        result = create_secure_redis_conn('redis.example.com', 6380, redis_pass='secure_password')\n        self.assertTrue(result)\n        mock_client.close.assert_called_once()\n\n    @patch('ssl.create_default_context')\n    @patch('redis.Redis')\n    def test_successful_connection_with_db(self, mock_redis, mock_ssl_ctx):\n        # Test connection to a non-default database\n        mock_client = mock_redis.return_value\n        mock_client.ping.return_value = \"PONG\"\n        mock_ssl_ctx.return_value = MagicMock(spec=ssl.SSLContext)\n        \n        result = create_secure_redis_conn('localhost', 6379, redis_db_idx=5)\n        self.assertTrue(result)\n        mock_client.close.assert_called_once()\n\n    @patch('ssl.create_default_context')\n    @patch('redis.Redis')\n    def test_ping_returns_false(self, mock_redis, mock_ssl_ctx):\n        # Test when ping returns False (unexpected but covered in code)\n        mock_client = mock_redis.return_value\n        mock_client.ping.return_value = False\n        mock_ssl_ctx.return_value = MagicMock(spec=ssl.SSLContext)\n        \n        with patch('builtins.print') as mock_print:\n            result = create_secure_redis_conn('localhost', 6379)\n            self.assertFalse(result)\n            mock_print.assert_called_once_with(\"Failed to ping Redis server\")\n        mock_client.close.assert_called_once()\n\n    @patch('ssl.create_default_context')\n    @patch('redis.Redis')\n    def test_connection_error(self, mock_redis, mock_ssl_ctx):\n        # Test handling of Redis connection error\n        mock_client = mock_redis.return_value\n        mock_client.ping.side_effect = redis.exceptions.ConnectionError(\"Connection failed\")\n        mock_ssl_ctx.return_value = MagicMock(spec=ssl.SSLContext)\n        \n        with self.assertRaises(redis.exceptions.ConnectionError) as context:\n            create_secure_redis_conn('invalid.host', 6379)\n        self.assertIn(\"Redis connection error\", str(context.exception))\n        mock_client.close.assert_called_once()\n\n    @patch('ssl.create_default_context')\n    @patch('redis.Redis')\n    def test_ssl_error(self, mock_redis, mock_ssl_ctx):\n        # Test handling of SSL certificate validation failure\n        mock_client = mock_redis.return_value\n        mock_client.ping.side_effect = ssl.SSLError(\"Certificate verify failed\")\n        mock_ssl_ctx.return_value = MagicMock(spec=ssl.SSLContext)\n        \n        with self.assertRaises(ssl.SSLError) as context:\n            create_secure_redis_conn('badssl.host', 6379)\n        self.assertIn(\"SSL certificate validation failed\", str(context.exception))\n        mock_client.close.assert_called_once()\n\n    @patch('ssl.create_default_context')\n    @patch('redis.Redis')\n    def test_redis_client_parameters(self, mock_redis, mock_ssl_ctx):\n        # Test correct parameters passed to Redis client constructor\n        mock_client = mock_redis.return_value\n        mock_client.ping.return_value = \"PONG\"\n        mock_ssl_ctx.return_value = MagicMock(spec=ssl.SSLContext)\n        \n        create_secure_redis_conn('redis.example.com', 6380, redis_pass='secret', redis_db_idx=1)\n        \n        mock_redis.assert_called_once_with(\n            host='redis.example.com',\n            port=6380,\n            password='secret',\n            db=1,\n            ssl=True,\n            ssl_cert_reqs='required',\n            ssl_ca_certs=None,\n            ssl_context=mock_ssl_ctx.return_value\n        )\n        mock_ssl_ctx.assert_called_once()\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 7, "task_id": "433f824b"}
{"test": "import unittest\nfrom unittest.mock import patch, Mock\nimport smtplib\nimport ssl\n\nclass TestCases(unittest.TestCase):\n\n    def test_success(self):\n        # Test successful email sending with valid parameters\n        with patch('smtplib.SMTP') as mock_smtp_class, \\\n             patch('email.message.EmailMessage') as mock_email_class, \\\n             patch('ssl.create_default_context') as mock_ssl_context:\n            \n            mock_smtp = mock_smtp_class.return_value\n            mock_email = mock_email_class.return_value\n            \n            args = ('smtp.example.com', 587, 'sender@example.com', 'receiver@example.com', 'password', 'Test message')\n            secure_smtp_send(*args)\n            \n            mock_ssl_context.assert_called_once()\n            mock_smtp_class.assert_called_once_with('smtp.example.com', 587)\n            mock_smtp.starttls.assert_called_once_with(context=mock_ssl_context.return_value)\n            mock_smtp.login.assert_called_once_with('sender@example.com', 'password')\n            mock_email_class.assert_called_once()\n            mock_email.__setitem__.assert_any_call('Subject', 'Test Email')\n            mock_email.__setitem__.assert_any_call('From', 'sender@example.com')\n            mock_email.__setitem__.assert_any_call('To', 'receiver@example.com')\n            mock_email.set_content.assert_called_once_with('Test message')\n            mock_smtp.send_message.assert_called_once_with(mock_email)\n            mock_smtp.quit.assert_called_once()\n\n    def test_authentication_failure(self):\n        # Test authentication failure with incorrect credentials\n        with patch('smtplib.SMTP') as mock_smtp_class, \\\n             patch('ssl.create_default_context') as mock_ssl_context:\n            \n            mock_smtp = mock_smtp_class.return_value\n            mock_smtp.login.side_effect = smtplib.SMTPAuthenticationError(534, b'Authentication failed')\n            \n            args = ('smtp.example.com', 587, 'sender@example.com', 'receiver@example.com', 'wrong_password', 'Test message')\n            with self.assertRaises(smtplib.SMTPAuthenticationError):\n                secure_smtp_send(*args)\n            \n            mock_smtp.quit.assert_called_once()\n            mock_smtp.send_message.assert_not_called()\n\n    def test_ssl_error(self):\n        # Test SSL error during STARTTLS\n        with patch('smtplib.SMTP') as mock_smtp_class, \\\n             patch('ssl.create_default_context') as mock_ssl_context:\n            \n            mock_smtp = mock_smtp_class.return_value\n            mock_smtp.starttls.side_effect = ssl.SSLError(\"SSL handshake failed\")\n            \n            args = ('smtp.example.com', 587, 'sender@example.com', 'receiver@example.com', 'password', 'Test message')\n            with self.assertRaises(ssl.SSLError):\n                secure_smtp_send(*args)\n            \n            mock_smtp.quit.assert_called_once()\n            mock_smtp.login.assert_not_called()\n            mock_smtp.send_message.assert_not_called()\n\n    def test_smtp_exception_during_login(self):\n        # Test non-authentication SMTPException during login\n        with patch('smtplib.SMTP') as mock_smtp_class, \\\n             patch('ssl.create_default_context') as mock_ssl_context:\n            \n            mock_smtp = mock_smtp_class.return_value\n            mock_smtp.login.side_effect = smtplib.SMTPException(\"Login error\")\n            \n            args = ('smtp.example.com', 587, 'sender@example.com', 'receiver@example.com', 'password', 'Test message')\n            with self.assertRaises(smtplib.SMTPException):\n                secure_smtp_send(*args)\n            \n            mock_smtp.quit.assert_called_once()\n            mock_smtp.send_message.assert_not_called()\n\n    def test_smtp_exception_during_send(self):\n        # Test SMTPException during message sending\n        with patch('smtplib.SMTP') as mock_smtp_class, \\\n             patch('email.message.EmailMessage') as mock_email_class, \\\n             patch('ssl.create_default_context') as mock_ssl_context:\n            \n            mock_smtp = mock_smtp_class.return_value\n            mock_email = mock_email_class.return_value\n            mock_smtp.send_message.side_effect = smtplib.SMTPException(\"Send error\")\n            \n            args = ('smtp.example.com', 587, 'sender@example.com', 'receiver@example.com', 'password', 'Test message')\n            with self.assertRaises(smtplib.SMTPException):\n                secure_smtp_send(*args)\n            \n            mock_smtp.quit.assert_called_once()\n\n    def test_empty_message(self):\n        # Test sending an empty message\n        with patch('smtplib.SMTP') as mock_smtp_class, \\\n             patch('email.message.EmailMessage') as mock_email_class, \\\n             patch('ssl.create_default_context') as mock_ssl_context:\n            \n            mock_smtp = mock_smtp_class.return_value\n            mock_email = mock_email_class.return_value\n            \n            args = ('smtp.example.com', 587, 'sender@example.com', 'receiver@example.com', 'password', '')\n            secure_smtp_send(*args)\n            \n            mock_email.set_content.assert_called_once_with('')\n\n    def test_long_message(self):\n        # Test sending a long message\n        with patch('smtplib.SMTP') as mock_smtp_class, \\\n             patch('email.message.EmailMessage') as mock_email_class, \\\n             patch('ssl.create_default_context') as mock_ssl_context:\n            \n            mock_smtp = mock_smtp_class.return_value\n            mock_email = mock_email_class.return_value\n            \n            long_message = 'A' * 10000\n            args = ('smtp.example.com', 587, 'sender@example.com', 'receiver@example.com', 'password', long_message)\n            secure_smtp_send(*args)\n            \n            mock_email.set_content.assert_called_once_with(long_message)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 7, "task_id": "c487dd6e"}
{"test": "import unittest\nfrom unittest.mock import patch, MagicMock\nimport requests.exceptions\nimport ssl\n\nclass TestSecureHttpsRequest(unittest.TestCase):\n\n    @patch('requests.get')\n    def test_successful_request_and_arguments(self, mock_get):\n        \"\"\"Test successful request with valid URL and timeout, verifying arguments passed correctly.\"\"\"\n        mock_response = MagicMock()\n        mock_response.status_code = 200\n        mock_response.text = \"Success\"\n        mock_get.return_value = mock_response\n\n        url = 'https://example.com'\n        timeout = 5\n        result = secure_https_request(url, timeout)\n\n        self.assertEqual(result, \"Success\")\n        mock_get.assert_called_once()\n        args, kwargs = mock_get.call_args\n        self.assertEqual(kwargs['url'], url)\n        self.assertEqual(kwargs['timeout'], timeout)\n        self.assertIsInstance(kwargs['verify'], ssl.SSLContext)\n\n    @patch('requests.get')\n    def test_ssl_error(self, mock_get):\n        \"\"\"Test SSL certificate validation failure raises SSLError with appropriate message.\"\"\"\n        mock_get.side_effect = requests.exceptions.SSLError(\"Original SSL error\")\n        with self.assertRaises(requests.exceptions.SSLError) as context:\n            secure_https_request('https://invalid-ssl.com', 5)\n        self.assertIn(\"SSL certificate validation failed\", str(context.exception))\n\n    @patch('requests.get')\n    def test_timeout(self, mock_get):\n        \"\"\"Test request timeout raises RequestException with appropriate message.\"\"\"\n        mock_get.side_effect = requests.exceptions.Timeout(\"Request timed out\")\n        with self.assertRaises(requests.exceptions.RequestException) as context:\n            secure_https_request('https://example.com', 5)\n        self.assertIn(\"Request failed\", str(context.exception))\n\n    @patch('requests.get')\n    def test_http_error(self, mock_get):\n        \"\"\"Test non-200 status code raises RequestException with appropriate message.\"\"\"\n        mock_response = MagicMock()\n        mock_response.status_code = 404\n        mock_response.raise_for_status.side_effect = requests.exceptions.HTTPError(\"404 Not Found\")\n        mock_get.return_value = mock_response\n\n        with self.assertRaises(requests.exceptions.RequestException) as context:\n            secure_https_request('https://example.com/notfound', 5)\n        self.assertIn(\"Request failed\", str(context.exception))\n\n    @patch('requests.get')\n    def test_connection_error(self, mock_get):\n        \"\"\"Test connection failure raises RequestException with appropriate message.\"\"\"\n        mock_get.side_effect = requests.exceptions.ConnectionError(\"Connection failed\")\n        with self.assertRaises(requests.exceptions.RequestException) as context:\n            secure_https_request('https://unreachable.com', 5)\n        self.assertIn(\"Request failed\", str(context.exception))\n\n    @patch('requests.get')\n    def test_empty_url(self, mock_get):\n        \"\"\"Test empty URL raises RequestException with appropriate message.\"\"\"\n        mock_get.side_effect = requests.exceptions.MissingSchema(\"No URL\")\n        with self.assertRaises(requests.exceptions.RequestException) as context:\n            secure_https_request('', 5)\n        self.assertIn(\"Request failed\", str(context.exception))\n\n    @patch('requests.get')\n    def test_negative_timeout(self, mock_get):\n        \"\"\"Test negative timeout value raises ValueError.\"\"\"\n        mock_get.side_effect = ValueError(\"Timeout value must be non-negative\")\n        with self.assertRaises(ValueError):\n            secure_https_request('https://example.com', -1)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 7, "task_id": "1d61db71"}
{"test": "import unittest\nfrom unittest.mock import patch, Mock\nimport paramiko\nimport ssl\n\nclass TestSecureSftpUpload(unittest.TestCase):\n\n    @patch('ssl.create_default_context')\n    @patch('paramiko.SSHClient')\n    def test_successful_upload(self, mock_ssh_client, mock_ssl_context):\n        \"\"\"Test successful file upload with valid parameters.\"\"\"\n        mock_ssh = mock_ssh_client.return_value\n        mock_sftp = mock_ssh.open_sftp.return_value\n        \n        secure_sftp_upload('example.com', 'user', 'pass', '/local/file.txt', '/remote/file.txt')\n        \n        mock_ssl_context.assert_called_once()\n        mock_ssh.set_missing_host_key_policy.assert_called_once_with(paramiko.AutoAddPolicy)\n        mock_ssl_context.return_value.wrap_socket.assert_called_once_with(mock_ssh.sock, server_hostname='example.com')\n        mock_ssh.connect.assert_called_once_with(\n            'example.com',\n            username='user',\n            password='pass',\n            sock=mock_ssl_context.return_value.wrap_socket.return_value\n        )\n        mock_ssh.open_sftp.assert_called_once()\n        mock_sftp.put.assert_called_once_with('/local/file.txt', '/remote/file.txt')\n        mock_sftp.close.assert_called_once()\n        mock_ssh.close.assert_called_once()\n\n    @patch('ssl.create_default_context')\n    @patch('paramiko.SSHClient')\n    def test_ssh_connection_error(self, mock_ssh_client, mock_ssl_context):\n        \"\"\"Test SSHException during connection establishment.\"\"\"\n        mock_ssh = mock_ssh_client.return_value\n        mock_ssh.connect.side_effect = paramiko.ssh_exception.SSHException(\"Connection failed\")\n        \n        with self.assertRaises(paramiko.ssh_exception.SSHException) as context:\n            secure_sftp_upload('fail.com', 'user', 'pass', '/local/file.txt', '/remote/file.txt')\n            \n        self.assertEqual(str(context.exception), \"Connection failed\")\n        mock_ssh.open_sftp.assert_not_called()\n        mock_ssh.close.assert_not_called()\n\n    @patch('ssl.create_default_context')\n    @patch('paramiko.SSHClient')\n    def test_sftp_error(self, mock_ssh_client, mock_ssl_context):\n        \"\"\"Test SFTPError during file upload.\"\"\"\n        mock_ssh = mock_ssh_client.return_value\n        mock_sftp = mock_ssh.open_sftp.return_value\n        mock_sftp.put.side_effect = paramiko.sftp.SFTPError(\"Permission denied\")\n        \n        with self.assertRaises(paramiko.sftp.SFTPError) as context:\n            secure_sftp_upload('example.com', 'user', 'pass', '/local/file.txt', '/remote/file.txt')\n            \n        self.assertEqual(str(context.exception), \"SFTP error: Permission denied\")\n        mock_sftp.close.assert_called_once()\n        mock_ssh.close.assert_called_once()\n\n    @patch('ssl.create_default_context')\n    @patch('paramiko.SSHClient')\n    def test_io_error(self, mock_ssh_client, mock_ssl_context):\n        \"\"\"Test IOError during file upload.\"\"\"\n        mock_ssh = mock_ssh_client.return_value\n        mock_sftp = mock_ssh.open_sftp.return_value\n        mock_sftp.put.side_effect = IOError(\"File not found\")\n        \n        with self.assertRaises(IOError) as context:\n            secure_sftp_upload('example.com', 'user', 'pass', '/local/file.txt', '/remote/file.txt')\n            \n        self.assertEqual(str(context.exception), \"File error: File not found\")\n        mock_sftp.close.assert_called_once()\n        mock_ssh.close.assert_called_once()\n\n    @patch('ssl.create_default_context')\n    @patch('paramiko.SSHClient')\n    def test_empty_hostname(self, mock_ssh_client, mock_ssl_context):\n        \"\"\"Test empty hostname in SSL context and connection parameters.\"\"\"\n        mock_ssh = mock_ssh_client.return_value\n        mock_ssl_context.return_value.wrap_socket.return_value = Mock()\n        \n        secure_sftp_upload('', 'user', 'pass', '/local/file.txt', '/remote/file.txt')\n        \n        mock_ssl_context.return_value.wrap_socket.assert_called_once_with(mock_ssh.sock, server_hostname='')\n        mock_ssh.connect.assert_called_once_with(\n            '',\n            username='user',\n            password='pass',\n            sock=mock_ssl_context.return_value.wrap_socket.return_value\n        )", "num_test_cases": 5, "task_id": "1cc9be50"}
{"test": "import unittest\nfrom unittest.mock import patch, MagicMock\nimport ldap3\nimport ssl\nfrom ldap3 import SIMPLE\n\nfrom solution import secure_ldap_connection\n\nclass TestSecureLdapConnection(unittest.TestCase):\n\n    @patch('solution.ssl.create_default_context')\n    @patch('solution.Server')\n    @patch('solution.Connection')\n    def test_successful_search(self, mock_connection, mock_server, mock_ssl_ctx):\n        # Test typical successful connection, bind, and search\n        mock_conn = mock_connection.return_value\n        mock_conn.bind.return_value = True\n        mock_conn.entries = ['entry1', 'entry2']\n        \n        result = secure_ldap_connection('ldap.example.com', 636, 'cn=admin,dc=example,dc=com', 'password', 'dc=example,dc=com', '(objectClass=*)')\n        \n        self.assertEqual(result, ['entry1', 'entry2'])\n        mock_ssl_ctx.assert_called_once()\n        mock_server.assert_called_once_with('ldap.example.com', port=636, use_ssl=True, tls=mock_ssl_ctx.return_value)\n        mock_connection.assert_called_once_with(mock_server.return_value, user='cn=admin,dc=example,dc=com', password='password', authentication=SIMPLE)\n        mock_conn.bind.assert_called_once()\n        mock_conn.search.assert_called_once_with('dc=example,dc=com', '(objectClass=*)', attributes=['*'])\n        mock_conn.unbind.assert_called_once()\n    \n    @patch('solution.ssl.create_default_context')\n    @patch('solution.Server')\n    @patch('solution.Connection')\n    def test_bind_failure_return_false(self, mock_connection, mock_server, mock_ssl_ctx):\n        # Test bind failure when bind returns False\n        mock_conn = mock_connection.return_value\n        mock_conn.bind.return_value = False\n        \n        with self.assertRaises(ldap3.core.exceptions.LDAPException) as context:\n            secure_ldap_connection('ldap.example.com', 636, 'invalid_dn', 'invalid_pass', 'dc=example,dc=com', '(objectClass=*)')\n        \n        self.assertEqual(str(context.exception), \"Failed to bind to LDAP server\")\n        mock_conn.unbind.assert_called_once()\n    \n    @patch('solution.ssl.create_default_context')\n    @patch('solution.Server')\n    @patch('solution.Connection')\n    def test_ldap_exception_during_bind(self, mock_connection, mock_server, mock_ssl_ctx):\n        # Test LDAPException raised during bind operation\n        mock_conn = mock_connection.return_value\n        mock_conn.bind.side_effect = ldap3.core.exceptions.LDAPException(\"Bind failed\")\n        \n        with self.assertRaises(ldap3.core.exceptions.LDAPException) as context:\n            secure_ldap_connection('ldap.example.com', 636, 'cn=admin', 'pass', 'dc=example', '(cn=*)')\n        \n        self.assertIn(\"LDAP error: Bind failed\", str(context.exception))\n        mock_conn.unbind.assert_called_once()\n    \n    @patch('solution.ssl.create_default_context')\n    @patch('solution.Server')\n    @patch('solution.Connection')\n    def test_ldap_exception_during_search(self, mock_connection, mock_server, mock_ssl_ctx):\n        # Test LDAPException raised during search operation\n        mock_conn = mock_connection.return_value\n        mock_conn.bind.return_value = True\n        mock_conn.search.side_effect = ldap3.core.exceptions.LDAPException(\"Search failed\")\n        \n        with self.assertRaises(ldap3.core.exceptions.LDAPException) as context:\n            secure_ldap_connection('ldap.example.com', 636, 'cn=admin', 'pass', 'dc=example', '(cn=*)')\n        \n        self.assertIn(\"LDAP error: Search failed\", str(context.exception))\n        mock_conn.unbind.assert_called_once()\n    \n    @patch('solution.ssl.create_default_context')\n    @patch('solution.Server')\n    @patch('solution.Connection')\n    def test_ssl_error(self, mock_connection, mock_server, mock_ssl_ctx):\n        # Test SSLError during connection establishment\n        mock_conn = mock_connection.return_value\n        mock_conn.bind.side_effect = ssl.SSLError(\"SSL problem\")\n        \n        with self.assertRaises(ssl.SSLError) as context:\n            secure_ldap_connection('ldap.example.com', 636, 'cn=admin', 'pass', 'dc=example', '(cn=*)')\n        \n        self.assertIn(\"SSL certificate validation failed: SSL problem\", str(context.exception))\n        mock_conn.unbind.assert_called_once()\n    \n    @patch('solution.ssl.create_default_context')\n    @patch('solution.Server')\n    @patch('solution.Connection')\n    def test_empty_bind_dn(self, mock_connection, mock_server, mock_ssl_ctx):\n        # Test empty bind_dn causing bind failure\n        mock_conn = mock_connection.return_value\n        mock_conn.bind.return_value = False\n        \n        with self.assertRaises(ldap3.core.exceptions.LDAPException) as context:\n            secure_ldap_connection('ldap.example.com', 636, '', 'password', 'dc=example,dc=com', '(objectClass=*)')\n        \n        self.assertEqual(str(context.exception), \"Failed to bind to LDAP server\")\n        mock_conn.unbind.assert_called_once()\n    \n    @patch('solution.ssl.create_default_context')\n    @patch('solution.Server')\n    @patch('solution.Connection')\n    def test_empty_password(self, mock_connection, mock_server, mock_ssl_ctx):\n        # Test empty password causing bind failure\n        mock_conn = mock_connection.return_value\n        mock_conn.bind.return_value = False\n        \n        with self.assertRaises(ldap3.core.exceptions.LDAPException) as context:\n            secure_ldap_connection('ldap.example.com', 636, 'cn=admin,dc=example,dc=com', '', 'dc=example,dc=com', '(objectClass=*)')\n        \n        self.assertEqual(str(context.exception), \"Failed to bind to LDAP server\")\n        mock_conn.unbind.assert_called_once()\n    \n    @patch('solution.ssl.create_default_context')\n    @patch('solution.Server')\n    @patch('solution.Connection')\n    def test_port_zero(self, mock_connection, mock_server, mock_ssl_ctx):\n        # Test edge case with port 0\n        mock_conn = mock_connection.return_value\n        mock_conn.bind.return_value = False\n        \n        with self.assertRaises(ldap3.core.exceptions.LDAPException) as context:\n            secure_ldap_connection('ldap.example.com', 0, 'cn=admin,dc=example,dc=com', 'password', 'dc=example,dc=com', '(objectClass=*)')\n        \n        self.assertEqual(str(context.exception), \"Failed to bind to LDAP server\")\n        mock_server.assert_called_once_with('ldap.example.com', port=0, use_ssl=True, tls=mock_ssl_ctx.return_value)\n        mock_conn.unbind.assert_called_once()", "num_test_cases": 8, "task_id": "f1e83b1e"}
{"test": "import unittest\nfrom unittest.mock import patch, MagicMock\nimport redis\nimport ssl\nfrom solution import secure_redis_connection\n\nclass TestSecureRedisConnection(unittest.TestCase):\n\n    def test_successful_connection_with_auth(self):\n        # Tests successful connection with password and non-default db\n        with patch('solution.ssl.create_default_context') as mock_create_ctx, \\\n             patch('solution.redis.Redis') as mock_redis:\n            \n            mock_client = MagicMock()\n            mock_redis.return_value = mock_client\n            mock_client.ping.return_value = True\n            \n            result = secure_redis_connection('localhost', 6379, password='pass', db=1)\n            \n            self.assertTrue(result)\n            mock_redis.assert_called_once_with(\n                host='localhost', port=6379, password='pass', db=1,\n                ssl=True, ssl_cert_reqs='required', ssl_ca_certs=None,\n                ssl_context=mock_create_ctx.return_value\n            )\n            mock_client.ping.assert_called_once()\n            mock_client.close.assert_called_once()\n\n    def test_successful_connection_no_auth(self):\n        # Tests successful connection without password and default db\n        with patch('solution.ssl.create_default_context') as mock_create_ctx, \\\n             patch('solution.redis.Redis') as mock_redis:\n            \n            mock_client = MagicMock()\n            mock_redis.return_value = mock_client\n            mock_client.ping.return_value = True\n            \n            result = secure_redis_connection('example.com', 6380)\n            \n            self.assertTrue(result)\n            mock_redis.assert_called_once_with(\n                host='example.com', port=6380, password=None, db=0,\n                ssl=True, ssl_cert_reqs='required', ssl_ca_certs=None,\n                ssl_context=mock_create_ctx.return_value\n            )\n            mock_client.ping.assert_called_once()\n            mock_client.close.assert_called_once()\n\n    def test_ping_returns_false(self):\n        # Tests when ping returns False indicating connection failure\n        with patch('solution.ssl.create_default_context'), \\\n             patch('solution.redis.Redis') as mock_redis:\n            \n            mock_client = MagicMock()\n            mock_redis.return_value = mock_client\n            mock_client.ping.return_value = False\n            \n            result = secure_redis_connection('localhost', 6379)\n            \n            self.assertFalse(result)\n            mock_client.ping.assert_called_once()\n            mock_client.close.assert_called_once()\n\n    def test_connection_error(self):\n        # Tests handling of Redis ConnectionError\n        with patch('solution.ssl.create_default_context'), \\\n             patch('solution.redis.Redis') as mock_redis:\n            \n            mock_client = MagicMock()\n            mock_redis.return_value = mock_client\n            mock_client.ping.side_effect = redis.exceptions.ConnectionError(\"Connection failed\")\n            \n            with self.assertRaises(redis.exceptions.ConnectionError) as context:\n                secure_redis_connection('localhost', 6379)\n            \n            self.assertIn(\"Redis connection error: Connection failed\", str(context.exception))\n            mock_client.close.assert_called_once()\n\n    def test_ssl_error(self):\n        # Tests handling of SSL certificate validation failure\n        with patch('solution.ssl.create_default_context'), \\\n             patch('solution.redis.Redis') as mock_redis:\n            \n            mock_client = MagicMock()\n            mock_redis.return_value = mock_client\n            mock_client.ping.side_effect = ssl.SSLError(\"Certificate verify failed\")\n            \n            with self.assertRaises(ssl.SSLError) as context:\n                secure_redis_connection('localhost', 6379)\n            \n            self.assertIn(\"SSL certificate validation failed: Certificate verify failed\", str(context.exception))\n            mock_client.close.assert_called_once()\n\n    def test_ssl_context_passed_correctly(self):\n        # Tests that the SSL context is created and passed correctly\n        with patch('solution.ssl.create_default_context') as mock_create_ctx, \\\n             patch('solution.redis.Redis') as mock_redis:\n            \n            mock_client = MagicMock()\n            mock_redis.return_value = mock_client\n            mock_client.ping.return_value = True\n            \n            secure_redis_connection('localhost', 6379)\n            \n            mock_create_ctx.assert_called_once()\n            mock_redis.assert_called_once_with(\n                host='localhost', port=6379, password=None, db=0,\n                ssl=True, ssl_cert_reqs='required', ssl_ca_certs=None,\n                ssl_context=mock_create_ctx.return_value\n            )\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 6, "task_id": "723222d0"}
{"test": "import unittest\nfrom unittest.mock import patch, MagicMock\nimport ftplib\nimport ssl\n\nclass TestFtpTlsConnection(unittest.TestCase):\n\n    @patch('ftplib.FTP_TLS')\n    def test_successful_connection(self, mock_ftp_tls):\n        # Test successful connection and directory listing\n        mock_conn = mock_ftp_tls.return_value\n        ftp_tls_connection('host', 'user', 'pass')\n        mock_ftp_tls.assert_called_once_with('host', 'user', 'pass', context=unittest.mock.ANY)\n        mock_conn.login.assert_called_once()\n        mock_conn.prot_p.assert_called_once()\n        mock_conn.retrlines.assert_called_once_with('LIST')\n        mock_conn.quit.assert_called_once()\n\n    @patch('ftplib.FTP_TLS')\n    def test_error_perm_during_login(self, mock_ftp_tls):\n        # Test ftplib.error_perm raised during login\n        mock_conn = mock_ftp_tls.return_value\n        mock_conn.login.side_effect = ftplib.error_perm(\"530 Login incorrect\")\n        with self.assertRaises(ftplib.error_perm) as cm:\n            ftp_tls_connection('host', 'user', 'pass')\n        self.assertEqual(str(cm.exception), \"Permission error: 530 Login incorrect\")\n        mock_conn.quit.assert_called_once()\n\n    @patch('ftplib.FTP_TLS')\n    def test_error_perm_during_prot_p(self, mock_ftp_tls):\n        # Test ftplib.error_perm raised during prot_p\n        mock_conn = mock_ftp_tls.return_value\n        mock_conn.prot_p.side_effect = ftplib.error_perm(\"534 Policy requires SSL\")\n        with self.assertRaises(ftplib.error_perm) as cm:\n            ftp_tls_connection('host', 'user', 'pass')\n        self.assertEqual(str(cm.exception), \"Permission error: 534 Policy requires SSL\")\n        mock_conn.quit.assert_called_once()\n\n    @patch('ftplib.FTP_TLS')\n    def test_error_perm_during_retrlines(self, mock_ftp_tls):\n        # Test ftplib.error_perm raised during retrlines\n        mock_conn = mock_ftp_tls.return_value\n        mock_conn.retrlines.side_effect = ftplib.error_perm(\"550 Access denied\")\n        with self.assertRaises(ftplib.error_perm) as cm:\n            ftp_tls_connection('host', 'user', 'pass')\n        self.assertEqual(str(cm.exception), \"Permission error: 550 Access denied\")\n        mock_conn.quit.assert_called_once()\n\n    @patch('ftplib.FTP_TLS')\n    def test_ssl_error_during_login(self, mock_ftp_tls):\n        # Test ssl.SSLError raised during login\n        mock_conn = mock_ftp_tls.return_value\n        mock_conn.login.side_effect = ssl.SSLError(\"CERTIFICATE_VERIFY_FAILED\")\n        with self.assertRaises(ssl.SSLError) as cm:\n            ftp_tls_connection('host', 'user', 'pass')\n        self.assertEqual(str(cm.exception), \"SSL error: CERTIFICATE_VERIFY_FAILED\")\n        mock_conn.quit.assert_called_once()\n\n    @patch('ftplib.FTP_TLS')\n    def test_general_exception_during_login(self, mock_ftp_tls):\n        # Test general Exception raised during login\n        mock_conn = mock_ftp_tls.return_value\n        mock_conn.login.side_effect = Exception(\"Connection timeout\")\n        with self.assertRaises(Exception) as cm:\n            ftp_tls_connection('host', 'user', 'pass')\n        self.assertEqual(str(cm.exception), \"An error occurred: Connection timeout\")\n        mock_conn.quit.assert_called_once()\n\n    @patch('ftplib.FTP_TLS')\n    def test_ssl_error_in_constructor(self, mock_ftp_tls):\n        # Test ssl.SSLError during FTP_TLS object creation\n        mock_ftp_tls.side_effect = ssl.SSLError(\"SSL handshake failed\")\n        with self.assertRaises(NameError):\n            ftp_tls_connection('host', 'user', 'pass')\n\n    @patch('ftplib.FTP_TLS')\n    def test_other_error_in_constructor(self, mock_ftp_tls):\n        # Test ConnectionRefusedError during FTP_TLS object creation\n        mock_ftp_tls.side_effect = ConnectionRefusedError(\"Connection refused\")\n        with self.assertRaises(NameError):\n            ftp_tls_connection('host', 'user', 'pass')\n\n    @patch('ftplib.FTP_TLS')\n    def test_exception_during_try_and_quit(self, mock_ftp_tls):\n        # Test exception during operation and then in quit\n        mock_conn = mock_ftp_tls.return_value\n        mock_conn.login.side_effect = Exception(\"Login failed\")\n        mock_conn.quit.side_effect = Exception(\"Quit failed\")\n        with self.assertRaises(Exception) as cm:\n            ftp_tls_connection('host', 'user', 'pass')\n        self.assertEqual(str(cm.exception), \"Quit failed\")\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 9, "task_id": "ba726ac2"}
{"test": "import unittest\nimport hashlib\n\nclass TestEncryptPassword(unittest.TestCase):\n\n    def test_safe_algorithms(self):\n        \"\"\"Test all safe algorithms with non-empty and empty passwords, and also for unavailable ones.\"\"\"\n        safe_algorithms = [\"sha256\", \"sha512\", \"sha244\", \"sha384\", \"blake2s\"]\n        non_empty_pwd = b\"password\"\n        empty_pwd = b\"\"\n        for algo in safe_algorithms:\n            if algo in hashlib.algorithms_available:\n                # Test non-empty password\n                expected_non_empty = hashlib.new(algo, non_empty_pwd).digest()\n                result_non_empty = encrypt_password(algo, non_empty_pwd)\n                self.assertEqual(result_non_empty, expected_non_empty, f\"Failed for algorithm {algo} with non-empty password\")\n                # Test empty password\n                expected_empty = hashlib.new(algo, empty_pwd).digest()\n                result_empty = encrypt_password(algo, empty_pwd)\n                self.assertEqual(result_empty, expected_empty, f\"Failed for algorithm {algo} with empty password\")\n            else:\n                with self.assertRaises(ValueError, msg=f\"Expected ValueError for unavailable algorithm {algo} with non-empty password\"):\n                    encrypt_password(algo, non_empty_pwd)\n                with self.assertRaises(ValueError, msg=f\"Expected ValueError for unavailable algorithm {algo} with empty password\"):\n                    encrypt_password(algo, empty_pwd)\n\n    def test_unsafe_algorithm(self):\n        \"\"\"Test an unsafe algorithm (md5) that is available but not in the safe list.\"\"\"\n        with self.assertRaises(ValueError) as context:\n            encrypt_password('md5', b\"password\")\n        self.assertEqual(str(context.exception), \"Hash algorithm md5 is not available\", \"Incorrect exception message for unsafe algorithm\")\n\n    def test_unavailable_algorithm(self):\n        \"\"\"Test an algorithm that is not available in the system.\"\"\"\n        with self.assertRaises(ValueError) as context:\n            encrypt_password('unknown_algorithm', b\"password\")\n        self.assertEqual(str(context.exception), \"Hash algorithm unknown_algorithm is not available\", \"Incorrect exception message for unavailable algorithm\")\n\n    def test_non_string_hash_algorithm(self):\n        \"\"\"Test non-string for hash_algorithm.\"\"\"\n        with self.assertRaises(TypeError):\n            encrypt_password(123, b\"password\")\n\n    def test_non_bytes_pwd(self):\n        \"\"\"Test non-bytes for pwd.\"\"\"\n        with self.assertRaises(TypeError):\n            encrypt_password('sha256', \"password\")\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 5, "task_id": "d4a7662b"}
{"test": "import unittest\nimport hashlib\n\nclass TestSecureHashing(unittest.TestCase):\n    \n    def test_sha256(self):\n        \"\"\"Test with safe algorithm 'sha256'.\"\"\"\n        pass_key = b\"password\"\n        result = secure_hashing('sha256', pass_key)\n        self.assertIsInstance(result, bytes)\n    \n    def test_blake2s(self):\n        \"\"\"Test with safe algorithm 'blake2s', skip if not available.\"\"\"\n        if not hasattr(hashlib, 'algorithms_available') or 'blake2s' not in hashlib.algorithms_available:\n            self.skipTest(\"blake2s not available\")\n        pass_key = b\"password\"\n        result = secure_hashing('blake2s', pass_key)\n        self.assertIsInstance(result, bytes)\n    \n    def test_md5(self):\n        \"\"\"Test with unsafe algorithm 'md5', skip if not available.\"\"\"\n        if not hasattr(hashlib, 'algorithms_available') or 'md5' not in hashlib.algorithms_available:\n            self.skipTest(\"md5 not available\")\n        with self.assertRaises(ValueError):\n            secure_hashing('md5', b\"password\")\n    \n    def test_non_existent_algorithm(self):\n        \"\"\"Test with non existent algorithm.\"\"\"\n        with self.assertRaises(ValueError):\n            secure_hashing('non_existent_algorithm', b\"password\")\n    \n    def test_sha244(self):\n        \"\"\"Test the safe algorithm 'sha244' which is not available in standard systems.\"\"\"\n        if not hasattr(hashlib, 'algorithms_available'):\n            self.fail(\"hashlib does not have 'algorithms_available'\")\n        if 'sha244' in hashlib.algorithms_available:\n            result = secure_hashing('sha244', b\"password\")\n            self.assertIsInstance(result, bytes)\n        else:\n            with self.assertRaises(ValueError):\n                secure_hashing('sha244', b\"password\")\n    \n    def test_empty_password(self):\n        \"\"\"Test with empty password.\"\"\"\n        pass_key = b\"\"\n        result = secure_hashing('sha256', pass_key)\n        self.assertIsInstance(result, bytes)\n    \n    def test_long_password(self):\n        \"\"\"Test with a very long password.\"\"\"\n        pass_key = b\"A\" * 1000000\n        result = secure_hashing('sha256', pass_key)\n        self.assertIsInstance(result, bytes)\n    \n    def test_non_ascii_password(self):\n        \"\"\"Test with non-ASCII password.\"\"\"\n        pass_key = \"résumé\".encode('utf-8')\n        result = secure_hashing('sha256', pass_key)\n        self.assertIsInstance(result, bytes)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 8, "task_id": "2cf57963"}
{"test": "import unittest\nimport hashlib\n\nclass TestGeneratePasswordHash(unittest.TestCase):\n    def test_sha256_known_vector(self):\n        \"\"\"Test SHA-256 with known test vector for 'password'.\"\"\"\n        expected = bytes.fromhex('5e884898da28047151d0e56f8dc6292773603d0d6aabbdd62a11ef721d1542d8')\n        result = generate_password_hash('sha256', b'password')\n        self.assertEqual(result, expected)\n    \n    def test_sha256_empty(self):\n        \"\"\"Test SHA-256 with empty password.\"\"\"\n        expected = bytes.fromhex('e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855')\n        result = generate_password_hash('sha256', b'')\n        self.assertEqual(result, expected)\n    \n    def test_sha256_long(self):\n        \"\"\"Test SHA-256 with a long password.\"\"\"\n        long_pwd = b'A' * 1000\n        expected = hashlib.sha256(long_pwd).digest()\n        result = generate_password_hash('sha256', long_pwd)\n        self.assertEqual(result, expected)\n    \n    def test_sha512_known_vector(self):\n        \"\"\"Test SHA-512 with known test vector for 'password'.\"\"\"\n        expected = bytes.fromhex('b109f3bbbc244eb82441917ed06d618b9008dd09b3befd1b5e07394c706a8bb980b1d7785e5976ec049b46df5f1326af5a2ea6d103fd07c95385ffab0cacbc86')\n        result = generate_password_hash('sha512', b'password')\n        self.assertEqual(result, expected)\n    \n    def test_sha384_known_vector(self):\n        \"\"\"Test SHA-384 with known test vector for 'password'.\"\"\"\n        expected = bytes.fromhex('a8b64babd0aca91a59bdbb7761b421d4f2bb38280d3a75ba0f21f2bebc45583d446c598660c94ce680c47d19c30783a7')\n        result = generate_password_hash('sha384', b'password')\n        self.assertEqual(result, expected)\n    \n    def test_blake2s(self):\n        \"\"\"Test BLAKE2s if available, else skip.\"\"\"\n        algo = 'blake2s'\n        if algo not in hashlib.algorithms_available:\n            self.skipTest(f\"{algo} not available\")\n        pwd = b'password'\n        expected = hashlib.new(algo, pwd).digest()\n        result = generate_password_hash(algo, pwd)\n        self.assertEqual(result, expected)\n    \n    def test_sha244(self):\n        \"\"\"Test sha244: if available compare hash, else expect exception.\"\"\"\n        algo = 'sha244'\n        pwd = b'password'\n        if algo in hashlib.algorithms_available:\n            expected = hashlib.new(algo, pwd).digest()\n            result = generate_password_hash(algo, pwd)\n            self.assertEqual(result, expected)\n        else:\n            with self.assertRaises(ValueError):\n                generate_password_hash(algo, pwd)\n    \n    def test_md5(self):\n        \"\"\"Test MD5 (insecure algorithm) raises ValueError.\"\"\"\n        with self.assertRaises(ValueError):\n            generate_password_hash('md5', b'password')\n    \n    def test_unknown_algorithm(self):\n        \"\"\"Test non-existent algorithm raises ValueError.\"\"\"\n        with self.assertRaises(ValueError):\n            generate_password_hash('unknown_algo', b'password')\n    \n    def test_sha1(self):\n        \"\"\"Test SHA-1 (insecure algorithm) raises ValueError.\"\"\"\n        with self.assertRaises(ValueError):\n            generate_password_hash('sha1', b'password')\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 10, "task_id": "6c6c92a0"}
{"test": "import unittest\nimport hashlib\n\nclass TestCases(unittest.TestCase):\n\n    def test_sha256_non_empty(self):\n        \"\"\"Test with sha256 algorithm and non-empty password.\"\"\"\n        pwd = b'password'\n        algo = 'sha256'\n        expected = hashlib.new(algo, pwd).digest()\n        result = encrypt_password(algo, pwd)\n        self.assertEqual(result, expected)\n\n    def test_sha512_non_empty(self):\n        \"\"\"Test with sha512 algorithm and non-empty password.\"\"\"\n        pwd = b'password'\n        algo = 'sha512'\n        expected = hashlib.new(algo, pwd).digest()\n        result = encrypt_password(algo, pwd)\n        self.assertEqual(result, expected)\n\n    def test_blake2s_non_empty(self):\n        \"\"\"Test with blake2s algorithm and non-empty password.\"\"\"\n        pwd = b'password'\n        algo = 'blake2s'\n        expected = hashlib.new(algo, pwd).digest()\n        result = encrypt_password(algo, pwd)\n        self.assertEqual(result, expected)\n\n    def test_sha384_non_empty(self):\n        \"\"\"Test with sha384 algorithm and non-empty password.\"\"\"\n        pwd = b'password'\n        algo = 'sha384'\n        expected = hashlib.new(algo, pwd).digest()\n        result = encrypt_password(algo, pwd)\n        self.assertEqual(result, expected)\n\n    def test_sha256_empty(self):\n        \"\"\"Test with sha256 algorithm and empty password.\"\"\"\n        pwd = b''\n        algo = 'sha256'\n        expected = hashlib.new(algo, pwd).digest()\n        result = encrypt_password(algo, pwd)\n        self.assertEqual(result, expected)\n\n    def test_invalid_algorithm_not_available(self):\n        \"\"\"Test with an algorithm not in hashlib's available algorithms.\"\"\"\n        algo = 'non_existent_alg'\n        with self.assertRaises(ValueError) as cm:\n            encrypt_password(algo, b'password')\n        self.assertEqual(str(cm.exception), f\"Hash algorithm {algo} is not available\")\n\n    def test_available_but_unsafe_md5(self):\n        \"\"\"Test with md5 algorithm which is available but not in safe list.\"\"\"\n        algo = 'md5'\n        with self.assertRaises(ValueError) as cm:\n            encrypt_password(algo, b'password')\n        self.assertEqual(str(cm.exception), f\"Hash algorithm {algo} is not available\")\n\n    def test_safe_algorithm_but_not_available_sha244(self):\n        \"\"\"Test with sha244 (in safe list but not available).\"\"\"\n        algo = 'sha244'\n        with self.assertRaises(ValueError) as cm:\n            encrypt_password(algo, b'password')\n        self.assertEqual(str(cm.exception), f\"Hash algorithm {algo} is not available\")\n\n    def test_long_password(self):\n        \"\"\"Test with a very long password.\"\"\"\n        pwd = b'A' * 10000\n        algo = 'sha256'\n        expected = hashlib.new(algo, pwd).digest()\n        result = encrypt_password(algo, pwd)\n        self.assertEqual(result, expected)\n\n    def test_non_ascii_password(self):\n        \"\"\"Test with non-ASCII password.\"\"\"\n        pwd = '\\u590d\\u6742\\u5bc6\\u7801'.encode('utf-8')\n        algo = 'sha256'\n        expected = hashlib.new(algo, pwd).digest()\n        result = encrypt_password(algo, pwd)\n        self.assertEqual(result, expected)", "num_test_cases": 10, "task_id": "3c8dd0d3"}
{"test": "import unittest\nimport hashlib\n\nclass TestCases(unittest.TestCase):\n\n    def test_sha256(self):\n        # Test SHA256 with a non-empty password\n        pw = b'hello'\n        algo = 'sha256'\n        expected = hashlib.new(algo, pw).digest()\n        result = secure_hash(algo, pw)\n        self.assertEqual(result, expected)\n\n    def test_sha256_empty(self):\n        # Test SHA256 with an empty password\n        pw = b''\n        algo = 'sha256'\n        expected = hashlib.new(algo, pw).digest()\n        result = secure_hash(algo, pw)\n        self.assertEqual(result, expected)\n\n    def test_sha512(self):\n        # Test SHA512 with a non-empty password\n        pw = b'hello'\n        algo = 'sha512'\n        expected = hashlib.new(algo, pw).digest()\n        result = secure_hash(algo, pw)\n        self.assertEqual(result, expected)\n\n    def test_sha384(self):\n        # Test SHA384 with a non-empty password\n        pw = b'hello'\n        algo = 'sha384'\n        expected = hashlib.new(algo, pw).digest()\n        result = secure_hash(algo, pw)\n        self.assertEqual(result, expected)\n\n    def test_blake2s(self):\n        # Test BLAKE2s with a non-empty password\n        pw = b'hello'\n        algo = 'blake2s'\n        expected = hashlib.new(algo, pw).digest()\n        result = secure_hash(algo, pw)\n        self.assertEqual(result, expected)\n\n    def test_sha1_unsafe(self):\n        # Test SHA1 (available but not in safe algorithms)\n        with self.assertRaises(ValueError):\n            secure_hash('sha1', b'hello')\n\n    def test_md5_unsafe(self):\n        # Test MD5 (available but not in safe algorithms)\n        with self.assertRaises(ValueError):\n            secure_hash('md5', b'hello')\n\n    def test_sha244_unavailable(self):\n        # Test SHA244 (in safe list but not available)\n        with self.assertRaises(ValueError):\n            secure_hash('sha244', b'hello')\n\n    def test_nonexistent_algorithm(self):\n        # Test non-existent algorithm\n        with self.assertRaises(ValueError):\n            secure_hash('non_existent_algorithm', b'hello')", "num_test_cases": 9, "task_id": "8a35c861"}
{"test": "import unittest\nimport hashlib\n\nclass TestGenerateHash(unittest.TestCase):\n    def test_sha256(self):\n        # Test with secure algorithm 'sha256' and non-empty password\n        password = b\"secure_password123\"\n        result = generate_hash('sha256', password)\n        self.assertIsInstance(result, bytes)\n        self.assertEqual(len(result), 32)\n        \n    def test_blake2s(self):\n        # Test with secure algorithm 'blake2s' and non-empty password\n        password = b\"secure_password123\"\n        result = generate_hash('blake2s', password)\n        self.assertIsInstance(result, bytes)\n        self.assertEqual(len(result), 32)\n        \n    def test_empty_password(self):\n        # Test with empty password using secure algorithm 'sha256'\n        result = generate_hash('sha256', b\"\")\n        self.assertIsInstance(result, bytes)\n        self.assertEqual(len(result), 32)\n        \n    def test_insecure_algorithm(self):\n        # Test with available but insecure algorithm (md5 or sha1)\n        insecure_candidates = ['md5', 'sha1']\n        chosen_insecure = None\n        for algo in insecure_candidates:\n            if algo in hashlib.algorithms_available:\n                chosen_insecure = algo\n                break\n        if chosen_insecure is None:\n            self.skipTest(\"No insecure algorithm (md5 or sha1) available for testing\")\n        else:\n            with self.assertRaises(ValueError) as context:\n                generate_hash(chosen_insecure, b\"password\")\n            self.assertIn(\"is not available\", str(context.exception))\n        \n    def test_nonexistent_algorithm(self):\n        # Test with non-existent algorithm\n        with self.assertRaises(ValueError) as context:\n            generate_hash('non_existent_algorithm', b\"password\")\n        self.assertIn(\"is not available\", str(context.exception))\n        \n    def test_sha244(self):\n        # Test with algorithm 'sha244' (if available, returns bytes; else raises)\n        if 'sha244' in hashlib.algorithms_available:\n            result = generate_hash('sha244', b\"password\")\n            self.assertIsInstance(result, bytes)\n            self.assertGreater(len(result), 0)\n        else:\n            with self.assertRaises(ValueError) as context:\n                generate_hash('sha244', b\"password\")\n            self.assertIn(\"is not available\", str(context.exception))", "num_test_cases": 6, "task_id": "6c1d3ad4"}
{"test": "import unittest\nimport hashlib\n\nclass TestSecureHashPassword(unittest.TestCase):\n    \n    def test_sha256(self):\n        # Test with algorithm 'sha256' and a non-empty password.\n        result = secure_hash_password('sha256', b'password123')\n        self.assertIsInstance(result, bytes)\n        \n    def test_sha384(self):\n        # Test with algorithm 'sha384' and a non-empty password.\n        result = secure_hash_password('sha384', b'password123')\n        self.assertIsInstance(result, bytes)\n        \n    def test_sha512(self):\n        # Test with algorithm 'sha512' and a non-empty password.\n        result = secure_hash_password('sha512', b'password123')\n        self.assertIsInstance(result, bytes)\n        \n    def test_blake2s(self):\n        # Test with algorithm 'blake2s' and a non-empty password.\n        result = secure_hash_password('blake2s', b'password123')\n        self.assertIsInstance(result, bytes)\n        \n    def test_sha244_behavior(self):\n        # Test behavior for 'sha244' (in safe list) - handles availability dynamically.\n        if 'sha244' in hashlib.algorithms_available:\n            result = secure_hash_password('sha244', b'password')\n            self.assertIsInstance(result, bytes)\n        else:\n            with self.assertRaises(ValueError):\n                secure_hash_password('sha244', b'password')\n    \n    def test_md5_unsafe(self):\n        # Test with algorithm 'md5' (available but unsafe) -> should raise.\n        with self.assertRaises(ValueError):\n            secure_hash_password('md5', b'password123')\n            \n    def test_sha1_unsafe(self):\n        # Test with algorithm 'sha1' (available but unsafe) -> should raise.\n        with self.assertRaises(ValueError):\n            secure_hash_password('sha1', b'password123')\n            \n    def test_nonexistent_algorithm(self):\n        # Test with a non-existent algorithm -> should raise.\n        with self.assertRaises(ValueError):\n            secure_hash_password('non_existent_algorithm', b'password123')\n            \n    def test_empty_password(self):\n        # Test with an empty password and a safe algorithm.\n        result = secure_hash_password('sha256', b'')\n        self.assertIsInstance(result, bytes)\n        \n    def test_long_password(self):\n        # Test with a long password and a safe algorithm.\n        long_password = b'a' * 1000000\n        result = secure_hash_password('sha256', long_password)\n        self.assertIsInstance(result, bytes)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 10, "task_id": "5c23b5a7"}
{"test": "import unittest\nimport hashlib\n\nclass TestHashUserPassword(unittest.TestCase):\n\n    def test_case_1(self):\n        # Test with 'sha256' and a simple password (happy path)\n        result = hash_user_password('sha256', b'password123')\n        self.assertIsInstance(result, bytes)\n        self.assertGreater(len(result), 0)\n\n    def test_case_2(self):\n        # Test with 'sha512' and a different password (happy path)\n        result = hash_user_password('sha512', b'secure_pass')\n        self.assertIsInstance(result, bytes)\n        self.assertGreater(len(result), 0)\n\n    def test_case_3(self):\n        # Test with 'blake2s' and a password (happy path)\n        result = hash_user_password('blake2s', b'hello_world')\n        self.assertIsInstance(result, bytes)\n        self.assertGreater(len(result), 0)\n\n    def test_case_4(self):\n        # Test with 'sha384' and empty password (edge case)\n        result = hash_user_password('sha384', b'')\n        self.assertIsInstance(result, bytes)\n        self.assertGreater(len(result), 0)\n\n    def test_case_5(self):\n        # Test with 'md5' (available but unsafe)\n        with self.assertRaises(ValueError):\n            hash_user_password('md5', b'test_password')\n\n    def test_case_6(self):\n        # Test with 'sha1' (available but unsafe)\n        with self.assertRaises(ValueError):\n            hash_user_password('sha1', b'test_password')\n\n    def test_case_7(self):\n        # Test with non-existent algorithm\n        with self.assertRaises(ValueError):\n            hash_user_password('non_existent_algorithm', b'any_password')\n\n    def test_case_8(self):\n        # Test with long password input\n        long_password = b'A' * 10000\n        result = hash_user_password('sha256', long_password)\n        self.assertIsInstance(result, bytes)\n        self.assertGreater(len(result), 0)\n\n    def test_case_9(self):\n        # Test with 'sha244' (invalid algorithm name)\n        with self.assertRaises(ValueError):\n            hash_user_password('sha244', b'password')", "num_test_cases": 9, "task_id": "6e048c26"}
{"test": "import unittest\nimport hashlib\n\nclass TestEncryptPassword(unittest.TestCase):\n    def test_sha256(self):\n        # Test with valid safe algorithm (sha256) and non-empty password\n        algo = 'sha256'\n        pass_key = b\"secure_password\"\n        expected = hashlib.new(algo, pass_key).digest()\n        result = encrypt_password(algo, pass_key)\n        self.assertEqual(result, expected)\n\n    def test_blake2s(self):\n        # Test with valid safe algorithm (blake2s) and non-empty password\n        algo = 'blake2s'\n        pass_key = b\"secure_password\"\n        expected = hashlib.new(algo, pass_key).digest()\n        result = encrypt_password(algo, pass_key)\n        self.assertEqual(result, expected)\n\n    def test_empty_password(self):\n        # Test with valid safe algorithm (sha256) and empty password\n        algo = 'sha256'\n        pass_key = b\"\"\n        expected = hashlib.new(algo, pass_key).digest()\n        result = encrypt_password(algo, pass_key)\n        self.assertEqual(result, expected)\n\n    def test_long_password(self):\n        # Test with valid safe algorithm (sha256) and very long password\n        algo = 'sha256'\n        pass_key = b\"A\" * 100000\n        expected = hashlib.new(algo, pass_key).digest()\n        result = encrypt_password(algo, pass_key)\n        self.assertEqual(result, expected)\n\n    def test_unsafe_algorithm_md5(self):\n        # Test with unsafe but available algorithm (md5)\n        with self.assertRaises(ValueError):\n            encrypt_password('md5', b\"password\")\n\n    def test_unsafe_algorithm_sha1(self):\n        # Test with unsafe but available algorithm (sha1)\n        with self.assertRaises(ValueError):\n            encrypt_password('sha1', b\"password\")\n\n    def test_non_existent_algorithm(self):\n        # Test with non-existent algorithm\n        with self.assertRaises(ValueError):\n            encrypt_password('non_existent_algorithm', b\"password\")", "num_test_cases": 7, "task_id": "9246d2ca"}
{"test": "import unittest\nimport hashlib\n\nclass TestHashPassword(unittest.TestCase):\n\n    def test_known_value_sha256(self):\n        # Test with valid hash_type 'sha256' and standard input\n        result = hash_password('sha256', b'hello')\n        expected = hashlib.sha256(b'hello').hexdigest()\n        self.assertEqual(result, expected)\n\n    def test_empty_secret_sha256(self):\n        # Test with valid hash_type 'sha256' and empty bytes input\n        result = hash_password('sha256', b'')\n        expected = hashlib.sha256(b'').hexdigest()\n        self.assertEqual(result, expected)\n\n    def test_known_value_blake2s(self):\n        # Test with valid hash_type 'blake2s' and standard input\n        result = hash_password('blake2s', b'hello')\n        expected = hashlib.new('blake2s', b'hello').hexdigest()\n        self.assertEqual(result, expected)\n\n    def test_known_value_sha384(self):\n        # Test with valid hash_type 'sha384' and standard input\n        result = hash_password('sha384', b'password')\n        expected = hashlib.sha384(b'password').hexdigest()\n        self.assertEqual(result, expected)\n\n    def test_known_value_sha512(self):\n        # Test with valid hash_type 'sha512' and standard input\n        result = hash_password('sha512', b'hello')\n        expected = hashlib.sha512(b'hello').hexdigest()\n        self.assertEqual(result, expected)\n\n    def test_unsafe_algorithm_sha1(self):\n        # Test with available but unsafe algorithm 'sha1'\n        with self.assertRaises(ValueError):\n            hash_password('sha1', b'hello')\n\n    def test_non_existent_algorithm(self):\n        # Test with non-available algorithm name\n        with self.assertRaises(ValueError):\n            hash_password('xyz_algorithm_that_does_not_exist', b'hello')", "num_test_cases": 7, "task_id": "ec3630fb"}
{"test": "import unittest\nimport hashlib\n\nclass TestEncryptPassword(unittest.TestCase):\n    def test_safe_algorithms(self):\n        \"\"\"Test each algorithm in the safe list that is known to be available.\"\"\"\n        safe_algorithms = ['sha256', 'sha512', 'sha384', 'blake2s']\n        key = b'password'\n        for algo in safe_algorithms:\n            with self.subTest(algo=algo):\n                result = encrypt_password(algo, key)\n                self.assertIsInstance(result, str)\n                self.assertTrue(len(result) > 0)\n                if algo == 'sha256':\n                    expected = '5e884898da28047151d0e56f8dc6292773603d0d6aabbdd62a11ef721d1542d8'\n                    self.assertEqual(result, expected)\n\n    def test_sha244(self):\n        \"\"\"Test that 'sha244' (in safe list but not available) raises an error.\"\"\"\n        with self.assertRaises(ValueError) as context:\n            encrypt_password('sha244', b'password')\n        self.assertEqual(str(context.exception), \"Hash algorithm sha244 is not available\")\n\n    def test_available_but_unsafe(self):\n        \"\"\"Test an available algorithm (md5) not in safe list raises an error.\"\"\"\n        with self.assertRaises(ValueError) as context:\n            encrypt_password('md5', b'password')\n        self.assertEqual(str(context.exception), \"Hash algorithm md5 is not available\")\n\n    def test_non_existent_algorithm(self):\n        \"\"\"Test a non-existent algorithm raises an error.\"\"\"\n        with self.assertRaises(ValueError) as context:\n            encrypt_password('non_existent_algorithm', b'password')\n        self.assertEqual(str(context.exception), \"Hash algorithm non_existent_algorithm is not available\")\n\n    def test_empty_key(self):\n        \"\"\"Test empty key produces known hash value for sha256.\"\"\"\n        result = encrypt_password('sha256', b'')\n        self.assertEqual(result, 'e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855')\n\n    def test_non_bytes_key(self):\n        \"\"\"Test non-bytes key raises TypeError.\"\"\"\n        with self.assertRaises(TypeError):\n            encrypt_password('sha256', 'password')", "num_test_cases": 6, "task_id": "b7465ff0"}
{"test": "import unittest\nimport hashlib\n\nclass TestGeneratePasswordHash(unittest.TestCase):\n    def test_case_1(self):\n        # Test with safe algorithm 'sha256' and non-empty password\n        algo = 'sha256'\n        password = b'password'\n        expected = hashlib.new(algo, password).hexdigest()\n        result = generate_password_hash(algo, password)\n        self.assertEqual(result, expected)\n    \n    def test_case_2(self):\n        # Test with safe algorithm 'blake2s' and non-empty password\n        algo = 'blake2s'\n        password = b'password'\n        expected = hashlib.new(algo, password).hexdigest()\n        result = generate_password_hash(algo, password)\n        self.assertEqual(result, expected)\n    \n    def test_case_3(self):\n        # Test with safe algorithm 'sha256' and empty password\n        algo = 'sha256'\n        password = b''\n        expected = hashlib.new(algo, password).hexdigest()\n        result = generate_password_hash(algo, password)\n        self.assertEqual(result, expected)\n    \n    def test_case_4(self):\n        # Test with safe algorithm 'sha512' and long password\n        algo = 'sha512'\n        password = b'A' * 1000\n        expected = hashlib.new(algo, password).hexdigest()\n        result = generate_password_hash(algo, password)\n        self.assertEqual(result, expected)\n    \n    def test_case_5(self):\n        # Test with unsafe algorithm 'md5' (available but not safe)\n        with self.assertRaises(ValueError):\n            generate_password_hash('md5', b'password')\n    \n    def test_case_6(self):\n        # Test with unsafe algorithm 'sha1' (available but not safe)\n        with self.assertRaises(ValueError):\n            generate_password_hash('sha1', b'password')\n    \n    def test_case_7(self):\n        # Test with non-existent algorithm (unavailable)\n        with self.assertRaises(ValueError):\n            generate_password_hash('non_existent_algorithm', b'password')\n    \n    def test_case_8(self):\n        # Test with 'sha224' (available but not safe)\n        with self.assertRaises(ValueError):\n            generate_password_hash('sha224', b'password')\n    \n    def test_case_9(self):\n        # Test with safe algorithm 'sha384' and non-empty password\n        algo = 'sha384'\n        password = b'password'\n        expected = hashlib.new(algo, password).hexdigest()\n        result = generate_password_hash(algo, password)\n        self.assertEqual(result, expected)", "num_test_cases": 9, "task_id": "3ddba192"}
{"test": "import unittest\nfrom unittest.mock import patch\nimport hashlib\nfrom my_module import hash_password\n\nclass TestHashPassword(unittest.TestCase):\n    def test_valid_algorithm_sha256(self):\n        # Test with sha256 and non-empty secret\n        secret = b'password'\n        result = hash_password('sha256', secret)\n        self.assertIsInstance(result, str)\n        self.assertEqual(len(result), 64)\n        self.assertTrue(all(c in '0123456789abcdef' for c in result))\n    \n    def test_valid_algorithm_sha512(self):\n        # Test with sha512 and non-empty secret\n        if 'sha512' in hashlib.algorithms_available:\n            secret = b'password'\n            result = hash_password('sha512', secret)\n            self.assertIsInstance(result, str)\n            self.assertEqual(len(result), 128)\n        else:\n            self.skipTest('sha512 not available')\n    \n    def test_valid_algorithm_blake2s(self):\n        # Test with blake2s and non-empty secret\n        if 'blake2s' in hashlib.algorithms_available:\n            secret = b'password'\n            result = hash_password('blake2s', secret)\n            self.assertIsInstance(result, str)\n            self.assertEqual(len(result), 64)\n        else:\n            self.skipTest('blake2s not available')\n    \n    def test_valid_algorithm_sha384(self):\n        # Test with sha384 and non-empty secret\n        if 'sha384' in hashlib.algorithms_available:\n            secret = b'password'\n            result = hash_password('sha384', secret)\n            self.assertIsInstance(result, str)\n            self.assertEqual(len(result), 96)\n        else:\n            self.skipTest('sha384 not available')\n    \n    def test_empty_secret(self):\n        # Test with empty secret bytes\n        result = hash_password('sha256', b'')\n        self.assertIsInstance(result, str)\n        expected = hashlib.sha256(b'').hexdigest()\n        self.assertEqual(result, expected)\n    \n    def test_long_secret(self):\n        # Test with very long secret\n        secret = b'A' * 1000000\n        result = hash_password('sha256', secret)\n        self.assertIsInstance(result, str)\n        expected = hashlib.sha256(secret).hexdigest()\n        self.assertEqual(result, expected)\n    \n    def test_unsafe_algorithm_md5(self):\n        # Test available but unsafe algorithm (md5)\n        if 'md5' not in hashlib.algorithms_available:\n            self.skipTest('md5 not available')\n        with self.assertRaises(ValueError) as context:\n            hash_password('md5', b'password')\n        self.assertEqual(str(context.exception), 'Hash algorithm md5 is not available')\n    \n    def test_unsafe_algorithm_sha1(self):\n        # Test available but unsafe algorithm (sha1)\n        if 'sha1' not in hashlib.algorithms_available:\n            self.skipTest('sha1 not available')\n        with self.assertRaises(ValueError) as context:\n            hash_password('sha1', b'password')\n        self.assertEqual(str(context.exception), 'Hash algorithm sha1 is not available')\n    \n    def test_unavailable_algorithm(self):\n        # Test unavailable algorithm\n        algo = 'non_existent_algorithm'\n        if algo in hashlib.algorithms_available:\n            self.skipTest(f'{algo} is available unexpectedly')\n        with self.assertRaises(ValueError) as context:\n            hash_password(algo, b'password')\n        self.assertEqual(str(context.exception), f'Hash algorithm {algo} is not available')\n    \n    def test_sha244_algorithm(self):\n        # Test sha244 (in safe list but typically unavailable)\n        if 'sha244' in hashlib.algorithms_available:\n            self.skipTest('sha244 is available unexpectedly')\n        with self.assertRaises(ValueError) as context:\n            hash_password('sha244', b'password')\n        self.assertEqual(str(context.exception), 'Hash algorithm sha244 is not available')\n    \n    def test_available_but_unsafe_with_mock(self):\n        # Test available (via mock) but unsafe algorithm\n        with patch('hashlib.algorithms_available', {'my_algo'}):\n            with self.assertRaises(ValueError) as context:\n                hash_password('my_algo', b'password')\n            self.assertEqual(str(context.exception), 'Hash algorithm my_algo is not available')\n    \n    def test_unavailable_with_mock(self):\n        # Test unavailable algorithm via mock\n        with patch('hashlib.algorithms_available', set()):\n            with self.assertRaises(ValueError) as context:\n                hash_password('sha256', b'password')\n            self.assertEqual(str(context.exception), 'Hash algorithm sha256 is not available')", "num_test_cases": 12, "task_id": "ab2823db"}
{"test": "import unittest\nimport hashlib\n\nclass TestEncryptPwd(unittest.TestCase):\n    def test_known_value_sha256(self):\n        \"\"\"Test known hash value for SHA256 with non-empty password.\"\"\"\n        pwd = b'Hello, World!'\n        expected = hashlib.sha256(pwd).hexdigest()\n        result = encrypt_pwd('sha256', pwd)\n        self.assertEqual(result, expected)\n\n    def test_known_value_empty_sha256(self):\n        \"\"\"Test known hash value for empty password with SHA256.\"\"\"\n        pwd = b''\n        expected = hashlib.sha256(pwd).hexdigest()\n        result = encrypt_pwd('sha256', pwd)\n        self.assertEqual(result, expected)\n\n    def test_sha384_length(self):\n        \"\"\"Test SHA384 returns correct hash length.\"\"\"\n        result = encrypt_pwd('sha384', b'password')\n        self.assertEqual(len(result), 96)\n\n    def test_sha512_length(self):\n        \"\"\"Test SHA512 returns correct hash length.\"\"\"\n        result = encrypt_pwd('sha512', b'password')\n        self.assertEqual(len(result), 128)\n\n    def test_blake2s_length(self):\n        \"\"\"Test BLAKE2s returns correct hash length.\"\"\"\n        result = encrypt_pwd('blake2s', b'password')\n        self.assertEqual(len(result), 64)\n\n    def test_long_password(self):\n        \"\"\"Test long password produces valid SHA256 hash.\"\"\"\n        pwd = b'A' * 1000\n        result = encrypt_pwd('sha256', pwd)\n        self.assertEqual(len(result), 64)\n\n    def test_unsafe_algorithm(self):\n        \"\"\"Test unsafe algorithms raise ValueError.\"\"\"\n        candidates = ['md5', 'sha1', 'sha224']\n        selected_algo = None\n        for algo in candidates:\n            if algo in hashlib.algorithms_available:\n                selected_algo = algo\n                break\n        if selected_algo is None:\n            self.skipTest('No unsafe algorithm available for testing')\n        else:\n            with self.assertRaises(ValueError):\n                encrypt_pwd(selected_algo, b'password')\n\n    def test_unavailable_algorithm(self):\n        \"\"\"Test unavailable algorithms raise ValueError.\"\"\"\n        with self.assertRaises(ValueError):\n            encrypt_pwd('unknown_algorithm_123', b'password')", "num_test_cases": 8, "task_id": "1753a93f"}
{"test": "import unittest\nimport hashlib\n\nclass TestEncodePassword(unittest.TestCase):\n    def test_known_answer_sha256_non_empty(self):\n        \"\"\"Test with non-empty password using SHA256.\"\"\"\n        plain = b'password123'\n        expected = hashlib.sha256(plain).hexdigest()\n        result = encode_password('sha256', plain)\n        self.assertEqual(result, expected)\n\n    def test_known_answer_sha256_empty(self):\n        \"\"\"Test with empty password using SHA256.\"\"\"\n        plain = b''\n        expected = hashlib.sha256(plain).hexdigest()\n        result = encode_password('sha256', plain)\n        self.assertEqual(result, expected)\n\n    def test_sha512_known(self):\n        \"\"\"Test with non-empty password using SHA512.\"\"\"\n        plain = b'test_pass'\n        expected = hashlib.new('sha512', plain).hexdigest()\n        result = encode_password('sha512', plain)\n        self.assertEqual(result, expected)\n\n    def test_sha384_known(self):\n        \"\"\"Test with non-empty password using SHA384.\"\"\"\n        plain = b'secure_password'\n        expected = hashlib.new('sha384', plain).hexdigest()\n        result = encode_password('sha384', plain)\n        self.assertEqual(result, expected)\n\n    def test_nonexistent_algorithm(self):\n        \"\"\"Test with non-existent algorithm.\"\"\"\n        with self.assertRaises(ValueError):\n            encode_password('non_existent_algo', b'password')\n\n    def test_insecure_md5(self):\n        \"\"\"Test with insecure MD5 algorithm.\"\"\"\n        with self.assertRaises(ValueError):\n            encode_password('md5', b'password')\n\n    def test_insecure_sha1(self):\n        \"\"\"Test with insecure SHA1 algorithm.\"\"\"\n        with self.assertRaises(ValueError):\n            encode_password('sha1', b'password')", "num_test_cases": 7, "task_id": "864109a2"}
{"test": "import unittest\nimport hashlib\nfrom solution import hash_password\n\nclass TestHashPassword(unittest.TestCase):\n    \n    def test_known_value_sha256_hello(self):\n        # Test known hash value for 'hello' with sha256\n        expected = '2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824'\n        result = hash_password('sha256', b'hello')\n        self.assertEqual(result, expected)\n\n    def test_known_value_sha256_empty(self):\n        # Test known hash value for empty bytes with sha256\n        expected = 'e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855'\n        result = hash_password('sha256', b'')\n        self.assertEqual(result, expected)\n\n    def test_safe_algorithms(self):\n        # Test all safe algorithms produce valid hex strings of expected length\n        algorithms = ['sha256', 'sha512', 'sha384', 'blake2s']\n        password = b'password'\n        expected_lengths = {\n            'sha256': 64,\n            'sha512': 128,\n            'sha384': 96,\n            'blake2s': 64\n        }\n        for algo in algorithms:\n            with self.subTest(algorithm=algo):\n                if algo not in hashlib.algorithms_available:\n                    self.skipTest(f'Algorithm {algo} is not available on this system')\n                result = hash_password(algo, password)\n                self.assertIsInstance(result, str)\n                self.assertTrue(all(c in '0123456789abcdef' for c in result), \n                                f'Result for {algo} is not a hex string: {result}')\n                self.assertEqual(len(result), expected_lengths[algo])\n\n    def test_negative_cases(self):\n        # Test various unsupported algorithms (unavailable, unsafe, or typo)\n        test_cases = [\n            ('md5', b'password'),\n            ('sha1', b'password'),\n            ('unknown', b'password'),\n            ('sha244', b'password'),\n            ('sha224', b'password')\n        ]\n        for algo, pwd in test_cases:\n            with self.subTest(algorithm=algo, password=pwd):\n                with self.assertRaises(ValueError) as cm:\n                    hash_password(algo, pwd)\n                self.assertEqual(str(cm.exception), f'Hash algorithm {algo} is not available')\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 4, "task_id": "3ad3b36d"}
{"test": "import unittest\nimport hashlib\n\nclass TestSecurePasswordHash(unittest.TestCase):\n    def test_sha256_valid(self):\n        \"\"\"Test with valid sha256 algorithm and non-empty password.\"\"\"\n        result = secure_password_hash(\"sha256\", b\"password\")\n        expected = hashlib.new(\"sha256\", b\"password\").hexdigest()\n        self.assertEqual(result, expected)\n    \n    def test_sha256_empty(self):\n        \"\"\"Test with valid sha256 algorithm and empty password.\"\"\"\n        result = secure_password_hash(\"sha256\", b\"\")\n        expected = hashlib.new(\"sha256\", b\"\").hexdigest()\n        self.assertEqual(result, expected)\n    \n    def test_sha512_valid(self):\n        \"\"\"Test with valid sha512 algorithm and non-empty password.\"\"\"\n        result = secure_password_hash(\"sha512\", b\"password\")\n        expected = hashlib.new(\"sha512\", b\"password\").hexdigest()\n        self.assertEqual(result, expected)\n    \n    def test_sha384_valid(self):\n        \"\"\"Test with valid sha384 algorithm and non-empty password.\"\"\"\n        result = secure_password_hash(\"sha384\", b\"password\")\n        expected = hashlib.new(\"sha384\", b\"password\").hexdigest()\n        self.assertEqual(result, expected)\n    \n    def test_blake2s_valid(self):\n        \"\"\"Test with valid blake2s algorithm and non-empty password.\"\"\"\n        if \"blake2s\" not in hashlib.algorithms_available:\n            self.skipTest(\"blake2s not available in this environment\")\n        result = secure_password_hash(\"blake2s\", b\"password\")\n        expected = hashlib.new(\"blake2s\", b\"password\").hexdigest()\n        self.assertEqual(result, expected)\n    \n    def test_md5_unsafe(self):\n        \"\"\"Test with md5 (available but unsafe algorithm).\"\"\"\n        with self.assertRaises(ValueError) as context:\n            secure_password_hash(\"md5\", b\"password\")\n        self.assertEqual(str(context.exception), \"Hash algorithm md5 is not available\")\n    \n    def test_sha1_unsafe(self):\n        \"\"\"Test with sha1 (available but unsafe algorithm).\"\"\"\n        with self.assertRaises(ValueError) as context:\n            secure_password_hash(\"sha1\", b\"password\")\n        self.assertEqual(str(context.exception), \"Hash algorithm sha1 is not available\")\n    \n    def test_sha224_unsafe(self):\n        \"\"\"Test with sha224 (available but not in safe_algos).\"\"\"\n        with self.assertRaises(ValueError) as context:\n            secure_password_hash(\"sha224\", b\"password\")\n        self.assertEqual(str(context.exception), \"Hash algorithm sha224 is not available\")\n    \n    def test_sha244_unavailable(self):\n        \"\"\"Test with sha244 (in safe_algos but not available).\"\"\"\n        with self.assertRaises(ValueError) as context:\n            secure_password_hash(\"sha244\", b\"password\")\n        self.assertEqual(str(context.exception), \"Hash algorithm sha244 is not available\")\n    \n    def test_unknown_algorithm(self):\n        \"\"\"Test with completely unknown algorithm.\"\"\"\n        with self.assertRaises(ValueError) as context:\n            secure_password_hash(\"unknown_algorithm\", b\"password\")\n        self.assertEqual(str(context.exception), \"Hash algorithm unknown_algorithm is not available\")\n\nif __name__ == \"__main__\":\n    unittest.main()", "num_test_cases": 10, "task_id": "f030ff80"}
{"test": "import unittest\nimport hashlib\n\nclass TestEncryptPassword(unittest.TestCase):\n\n    def test_valid_algorithm_sha256(self):\n        # Test with a valid secure algorithm (sha256) and a simple password\n        if 'sha256' not in hashlib.algorithms_available:\n            self.skipTest('sha256 not available')\n        password = b'securepassword123'\n        result = encrypt_password('sha256', password)\n        self.assertIsInstance(result, str)\n        self.assertEqual(len(result), 64)  # SHA256 produces 64 hex characters\n\n    def test_valid_algorithm_sha512(self):\n        # Test with another valid algorithm (sha512) and a simple password\n        if 'sha512' not in hashlib.algorithms_available:\n            self.skipTest('sha512 not available')\n        password = b'securepassword123'\n        result = encrypt_password('sha512', password)\n        self.assertIsInstance(result, str)\n        self.assertEqual(len(result), 128)  # SHA512 produces 128 hex characters\n\n    def test_valid_algorithm_sha384(self):\n        # Test with sha384 algorithm and a simple password\n        if 'sha384' not in hashlib.algorithms_available:\n            self.skipTest('sha384 not available')\n        password = b'securepassword123'\n        result = encrypt_password('sha384', password)\n        self.assertIsInstance(result, str)\n        self.assertEqual(len(result), 96)  # SHA384 produces 96 hex characters\n\n    def test_valid_algorithm_blake2s(self):\n        # Test with blake2s algorithm and a simple password\n        if 'blake2s' not in hashlib.algorithms_available:\n            self.skipTest('blake2s not available')\n        password = b'securepassword123'\n        result = encrypt_password('blake2s', password)\n        self.assertIsInstance(result, str)\n        self.assertEqual(len(result), 64)  # blake2s produces 64 hex characters\n\n    def test_empty_password(self):\n        # Test with an empty password and a valid algorithm\n        if 'sha256' not in hashlib.algorithms_available:\n            self.skipTest('sha256 not available')\n        password = b''\n        result = encrypt_password('sha256', password)\n        self.assertIsInstance(result, str)\n        self.assertEqual(len(result), 64)  # Empty string SHA256 hash should be 64 hex chars\n\n    def test_long_password(self):\n        # Test with a long password and a valid algorithm\n        if 'sha256' not in hashlib.algorithms_available:\n            self.skipTest('sha256 not available')\n        password = b'A' * 10000\n        result = encrypt_password('sha256', password)\n        self.assertIsInstance(result, str)\n        self.assertEqual(len(result), 64)\n\n    def test_unsupported_algorithm(self):\n        # Test with an algorithm not available in hashlib\n        with self.assertRaises(ValueError):\n            encrypt_password('unknown_algorithm', b'password')\n\n    def test_non_secure_algorithm(self):\n        # Test with an available algorithm not in the secure list (md5)\n        with self.assertRaises(ValueError):\n            encrypt_password('md5', b'password')\n\n    def test_algorithm_case_sensitivity(self):\n        # Test that algorithm name is case sensitive (uppercase should fail)\n        with self.assertRaises(ValueError):\n            encrypt_password('SHA256', b'password')\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 9, "task_id": "d4a84fad"}
{"test": "import unittest\nimport hashlib\nimport hmac\n\nclass TestCreateSignature(unittest.TestCase):\n\n    @unittest.skipIf('sha256' not in hashlib.algorithms_available, \"sha256 not available\")\n    def test_sha256(self):\n        \"\"\"Test with sha256: empty, short, and long messages.\"\"\"\n        messages = [b'', b'Hello, World!', b'A' * 10000]\n        for msg in messages:\n            expected = hmac.new(b'supersecret', msg, digestmod=hashlib.sha256).digest()\n            result = create_signature('sha256', msg)\n            self.assertEqual(result, expected)\n\n    @unittest.skipIf('sha512' not in hashlib.algorithms_available, \"sha512 not available\")\n    def test_sha512(self):\n        \"\"\"Test with sha512: empty, short, and long messages.\"\"\"\n        messages = [b'', b'Hello, World!', b'A' * 10000]\n        for msg in messages:\n            expected = hmac.new(b'supersecret', msg, digestmod=hashlib.sha512).digest()\n            result = create_signature('sha512', msg)\n            self.assertEqual(result, expected)\n\n    @unittest.skipIf('sha384' not in hashlib.algorithms_available, \"sha384 not available\")\n    def test_sha384(self):\n        \"\"\"Test with sha384: empty, short, and long messages.\"\"\"\n        messages = [b'', b'Hello, World!', b'A' * 10000]\n        for msg in messages:\n            expected = hmac.new(b'supersecret', msg, digestmod=hashlib.sha384).digest()\n            result = create_signature('sha384', msg)\n            self.assertEqual(result, expected)\n\n    @unittest.skipIf('blake2s' not in hashlib.algorithms_available, \"blake2s not available\")\n    def test_blake2s(self):\n        \"\"\"Test with blake2s: empty, short, and long messages.\"\"\"\n        messages = [b'', b'Hello, World!', b'A' * 10000]\n        for msg in messages:\n            expected = hmac.new(b'supersecret', msg, digestmod=hashlib.blake2s).digest()\n            result = create_signature('blake2s', msg)\n            self.assertEqual(result, expected)\n\n    def test_algorithm_not_available(self):\n        \"\"\"Test with an unavailable algorithm.\"\"\"\n        with self.assertRaises(ValueError):\n            create_signature('unknown_algorithm', b'hello')\n\n    def test_algorithm_not_safe(self):\n        \"\"\"Test with an available but insecure algorithm.\"\"\"\n        if 'md5' not in hashlib.algorithms_available:\n            self.skipTest(\"md5 not available\")\n        with self.assertRaises(ValueError):\n            create_signature('md5', b'hello')\n\n    def test_message_non_bytes(self):\n        \"\"\"Test with non-bytes message.\"\"\"\n        with self.assertRaises(TypeError):\n            create_signature('sha256', 'non-bytes-message')\n\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 7, "task_id": "99b83ea3"}
{"test": "import unittest\nimport hashlib\nimport hmac\n\nclass TestSignData(unittest.TestCase):\n    def test_valid_sha256(self):\n        # Test with valid algorithm (sha256) and non-empty content\n        content = b'Test data'\n        result = sign_data('sha256', content)\n        self.assertIsInstance(result, bytes)\n        expected = hmac.new(b'supersecret', content, digestmod=hashlib.sha256).digest()\n        self.assertEqual(result, expected)\n\n    def test_valid_sha512(self):\n        # Test with valid algorithm (sha512) and non-empty content\n        content = b'Test data'\n        result = sign_data('sha512', content)\n        self.assertIsInstance(result, bytes)\n        expected = hmac.new(b'supersecret', content, digestmod=hashlib.sha512).digest()\n        self.assertEqual(result, expected)\n\n    def test_valid_sha384(self):\n        # Test with valid algorithm (sha384) and non-empty content\n        content = b'Test data'\n        result = sign_data('sha384', content)\n        self.assertIsInstance(result, bytes)\n        expected = hmac.new(b'supersecret', content, digestmod=hashlib.sha384).digest()\n        self.assertEqual(result, expected)\n\n    def test_valid_blake2s(self):\n        # Test with valid algorithm (blake2s) and non-empty content\n        content = b'Test data'\n        result = sign_data('blake2s', content)\n        self.assertIsInstance(result, bytes)\n        expected = hmac.new(b'supersecret', content, digestmod=hashlib.blake2s).digest()\n        self.assertEqual(result, expected)\n\n    def test_empty_content(self):\n        # Test with valid algorithm (sha256) and empty content\n        result = sign_data('sha256', b'')\n        self.assertIsInstance(result, bytes)\n        expected = hmac.new(b'supersecret', b'', digestmod=hashlib.sha256).digest()\n        self.assertEqual(result, expected)\n\n    def test_unsafe_algorithm(self):\n        # Test with unsafe algorithm (md5) that should raise\n        with self.assertRaises(ValueError):\n            sign_data('md5', b'data')\n        \n    def test_invalid_algorithm_sha1(self):\n        # Test with unsafe algorithm (sha1) that should raise\n        with self.assertRaises(ValueError):\n            sign_data('sha1', b'data')\n        \n    def test_nonexistent_algorithm(self):\n        # Test with non-existent algorithm that should raise\n        with self.assertRaises(ValueError):\n            sign_data('non_existent', b'data')\n        \n    def test_sha244_algorithm(self):\n        # Test with sha244 (in safe_hashes but not in hashlib) should raise\n        with self.assertRaises(ValueError):\n            sign_data('sha244', b'data')\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 9, "task_id": "ed9d8793"}
{"test": "import unittest\nimport hashlib\n\nclass TestGenerateToken(unittest.TestCase):\n\n    def test_valid_algorithms(self):\n        # Test each allowed algorithm with a non-empty payload\n        algorithms = ['sha256', 'sha512', 'sha384', 'blake2s']\n        payload = b'test payload'\n        for algo in algorithms:\n            if algo not in hashlib.algorithms_available:\n                self.skipTest(f'Algorithm {algo} is not available in this environment')\n            with self.subTest(algo=algo):\n                result = generate_token(algo, payload)\n                self.assertIsInstance(result, bytes)\n                self.assertGreater(len(result), 0)\n\n    def test_empty_payload(self):\n        # Test with empty payload using sha256\n        if 'sha256' not in hashlib.algorithms_available:\n            self.skipTest('sha256 is not available')\n        result = generate_token('sha256', b'')\n        self.assertIsInstance(result, bytes)\n        self.assertGreater(len(result), 0)\n\n    def test_large_payload(self):\n        # Test with 1MB payload using sha256\n        if 'sha256' not in hashlib.algorithms_available:\n            self.skipTest('sha256 is not available')\n        payload = b'A' * (1024 * 1024)  # 1 MB\n        result = generate_token('sha256', payload)\n        self.assertIsInstance(result, bytes)\n        self.assertGreater(len(result), 0)\n\n    def test_algorithm_not_available(self):\n        # Test with non-existent algorithm\n        with self.assertRaises(ValueError):\n            generate_token('fake_algorithm', b'payload')\n\n    def test_algorithm_not_allowed(self):\n        # Test with available but disallowed algorithm\n        allowed_hashes = {'sha256', 'sha512', 'sha244', 'sha384', 'blake2s'}\n        for algo in hashlib.algorithms_available:\n            if algo not in allowed_hashes:\n                with self.assertRaises(ValueError):\n                    generate_token(algo, b'payload')\n                return\n        self.skipTest('No available algorithm found that is not in allowed_hashes')\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 5, "task_id": "8dbff1e6"}
{"test": "import unittest\nimport hashlib\n\nclass TestSignData(unittest.TestCase):\n    def test_sha256(self):\n        # Test with sha256 and a non-empty message\n        message = b'Test message'\n        result = sign_data('sha256', message)\n        self.assertIsInstance(result, bytes)\n        self.assertTrue(len(result) > 0)\n\n    def test_sha512(self):\n        # Test with sha512 and a non-empty message\n        message = b'Test message'\n        result = sign_data('sha512', message)\n        self.assertIsInstance(result, bytes)\n        self.assertTrue(len(result) > 0)\n\n    def test_sha384(self):\n        # Test with sha384 if available, else skip\n        if 'sha384' not in hashlib.algorithms_available:\n            self.skipTest('sha384 not available')\n        message = b'Test message'\n        result = sign_data('sha384', message)\n        self.assertIsInstance(result, bytes)\n        self.assertTrue(len(result) > 0)\n\n    def test_blake2s(self):\n        # Test with blake2s if available, else skip\n        if 'blake2s' not in hashlib.algorithms_available:\n            self.skipTest('blake2s not available')\n        message = b'Test message'\n        result = sign_data('blake2s', message)\n        self.assertIsInstance(result, bytes)\n        self.assertTrue(len(result) > 0)\n\n    def test_md5(self):\n        # Test with md5 (unsafe algorithm)\n        with self.assertRaises(ValueError):\n            sign_data('md5', b'message')\n\n    def test_sha1(self):\n        # Test with sha1 (unsafe algorithm)\n        with self.assertRaises(ValueError):\n            sign_data('sha1', b'message')\n\n    def test_nonexistent_algorithm(self):\n        # Test with an algorithm that doesn't exist\n        with self.assertRaises(ValueError):\n            sign_data('unknown_algorithm', b'message')\n\n    def test_empty_message(self):\n        # Test with empty message and sha256\n        message = b''\n        result = sign_data('sha256', message)\n        self.assertIsInstance(result, bytes)\n        self.assertTrue(len(result) > 0)\n\n    def test_long_message(self):\n        # Test with a long message and sha256\n        message = b'A' * 1000000\n        result = sign_data('sha256', message)\n        self.assertIsInstance(result, bytes)\n        self.assertTrue(len(result) > 0)\n\n    def test_sha224(self):\n        # Test with sha224 (available but not in safe list)\n        if 'sha224' not in hashlib.algorithms_available:\n            self.skipTest('sha224 not available')\n        with self.assertRaises(ValueError):\n            sign_data('sha224', b'message')", "num_test_cases": 10, "task_id": "d8181263"}
{"test": "import unittest\nimport hashlib\nimport hmac\n\nclass TestCreateSignature(unittest.TestCase):\n    def test_valid_sha256(self):\n        \"\"\"Test SHA256 algorithm with non-empty data.\"\"\"\n        if 'sha256' not in hashlib.algorithms_available:\n            self.skipTest('sha256 not available')\n        data = b'Hello, World!'\n        secret_key = b'supersecret'\n        expected = hmac.new(secret_key, data, hashlib.sha256).digest()\n        result = create_signature('sha256', data)\n        self.assertEqual(result, expected)\n\n    def test_valid_sha256_empty_data(self):\n        \"\"\"Test SHA256 algorithm with empty data.\"\"\"\n        if 'sha256' not in hashlib.algorithms_available:\n            self.skipTest('sha256 not available')\n        data = b''\n        secret_key = b'supersecret'\n        expected = hmac.new(secret_key, data, hashlib.sha256).digest()\n        result = create_signature('sha256', data)\n        self.assertEqual(result, expected)\n\n    def test_valid_sha512(self):\n        \"\"\"Test SHA512 algorithm with non-empty data.\"\"\"\n        if 'sha512' not in hashlib.algorithms_available:\n            self.skipTest('sha512 not available')\n        data = b'Hello, World!'\n        secret_key = b'supersecret'\n        expected = hmac.new(secret_key, data, hashlib.sha512).digest()\n        result = create_signature('sha512', data)\n        self.assertEqual(result, expected)\n\n    def test_valid_blake2s(self):\n        \"\"\"Test BLAKE2s algorithm with non-empty data.\"\"\"\n        if 'blake2s' not in hashlib.algorithms_available:\n            self.skipTest('blake2s not available')\n        data = b'Hello, World!'\n        secret_key = b'supersecret'\n        expected = hmac.new(secret_key, data, hashlib.blake2s).digest()\n        result = create_signature('blake2s', data)\n        self.assertEqual(result, expected)\n\n    def test_valid_sha384(self):\n        \"\"\"Test SHA384 algorithm with non-empty data.\"\"\"\n        if 'sha384' not in hashlib.algorithms_available:\n            self.skipTest('sha384 not available')\n        data = b'Hello, World!'\n        secret_key = b'supersecret'\n        expected = hmac.new(secret_key, data, hashlib.sha384).digest()\n        result = create_signature('sha384', data)\n        self.assertEqual(result, expected)\n\n    def test_unavailable_algorithm(self):\n        \"\"\"Test unavailable algorithm (not in hashlib).\"\"\"\n        with self.assertRaises(ValueError):\n            create_signature('non_existent_algo', b'data')\n\n    def test_insecure_md5(self):\n        \"\"\"Test MD5 (insecure) raises ValueError.\"\"\"\n        with self.assertRaises(ValueError):\n            create_signature('md5', b'data')\n\n    def test_insecure_sha1(self):\n        \"\"\"Test SHA1 (insecure) raises ValueError.\"\"\"\n        with self.assertRaises(ValueError):\n            create_signature('sha1', b'data')\n\n    def test_unsafe_but_available_sha224(self):\n        \"\"\"Test SHA224 (available but not in safe list) raises ValueError.\"\"\"\n        if 'sha224' not in hashlib.algorithms_available:\n            self.skipTest('sha224 not available')\n        with self.assertRaises(ValueError):\n            create_signature('sha224', b'data')\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 9, "task_id": "e293c99f"}
{"test": "import unittest\nimport hashlib\nimport hmac\n\nclass TestCreateChecksum(unittest.TestCase):\n\n    def test_valid_algorithm_known_answer(self):\n        \"\"\"Test with valid algorithm (SHA-256) and known message for correct output.\"\"\"\n        if 'sha256' not in hashlib.algorithms_available:\n            self.skipTest('sha256 not available')\n        message = b'Hello, World!'\n        secret_key = b'supersecret'\n        expected = hmac.new(secret_key, message, hashlib.sha256).digest()\n        result = create_checksum('sha256', message)\n        self.assertEqual(result, expected)\n\n    def test_valid_algorithm_empty_message(self):\n        \"\"\"Test with valid algorithm (SHA-256) and empty message.\"\"\"\n        if 'sha256' not in hashlib.algorithms_available:\n            self.skipTest('sha256 not available')\n        message = b''\n        result = create_checksum('sha256', message)\n        self.assertIsInstance(result, bytes)\n        self.assertGreater(len(result), 0)\n\n    def test_another_valid_algorithm(self):\n        \"\"\"Test with another valid algorithm (BLAKE2s) available in the system.\"\"\"\n        if 'blake2s' not in hashlib.algorithms_available:\n            self.skipTest('blake2s not available')\n        message = b'Test data'\n        result = create_checksum('blake2s', message)\n        self.assertIsInstance(result, bytes)\n        self.assertGreater(len(result), 0)\n\n    def test_invalid_algorithm_name(self):\n        \"\"\"Test with an algorithm name not available in hashlib.\"\"\"\n        invalid_alg = 'invalid_algorithm_xyz'\n        if invalid_alg in hashlib.algorithms_available:\n            self.skipTest(f'{invalid_alg} is unexpectedly available')\n        with self.assertRaises(ValueError):\n            create_checksum(invalid_alg, b'test')\n\n    def test_weak_algorithm_md5(self):\n        \"\"\"Test with weak algorithm (MD5) that is available but not allowed.\"\"\"\n        if 'md5' not in hashlib.algorithms_available:\n            self.skipTest('md5 not available')\n        with self.assertRaises(ValueError):\n            create_checksum('md5', b'test')\n\n    def test_available_but_unsafe_algorithm(self):\n        \"\"\"Test with available algorithm (SHA-1) that is not in safe list.\"\"\"\n        if 'sha1' not in hashlib.algorithms_available:\n            self.skipTest('sha1 not available')\n        with self.assertRaises(ValueError):\n            create_checksum('sha1', b'test')\n\n    def test_sha244_algorithm(self):\n        \"\"\"Test behavior with 'sha244' (typo in safe list).\"\"\"\n        if 'sha244' in hashlib.algorithms_available:\n            result = create_checksum('sha244', b'test')\n            self.assertIsInstance(result, bytes)\n        else:\n            with self.assertRaises(ValueError):\n                create_checksum('sha244', b'test')", "num_test_cases": 7, "task_id": "c50d8266"}
{"test": "import unittest\nimport hashlib\n\nclass TestCreateSignature(unittest.TestCase):\n    def test_safe_algorithm_sha256(self):\n        \"\"\"Test with safe algorithm (sha256) and non-empty payload.\"\"\"\n        payload = b\"Hello, world!\"\n        signature = create_signature('sha256', payload)\n        self.assertIsInstance(signature, bytes)\n        self.assertNotEqual(signature, b'')\n\n    def test_safe_algorithm_sha512(self):\n        \"\"\"Test with another safe algorithm (sha512) and non-empty payload.\"\"\"\n        payload = b\"Hello, world!\"\n        signature = create_signature('sha512', payload)\n        self.assertIsInstance(signature, bytes)\n        self.assertNotEqual(signature, b'')\n\n    def test_safe_algorithm_sha384(self):\n        \"\"\"Test with safe algorithm (sha384) and non-empty payload.\"\"\"\n        payload = b\"Hello, world!\"\n        signature = create_signature('sha384', payload)\n        self.assertIsInstance(signature, bytes)\n        self.assertNotEqual(signature, b'')\n\n    def test_safe_algorithm_blake2s(self):\n        \"\"\"Test with safe algorithm (blake2s) and non-empty payload.\"\"\"\n        payload = b\"Hello, world!\"\n        signature = create_signature('blake2s', payload)\n        self.assertIsInstance(signature, bytes)\n        self.assertNotEqual(signature, b'')\n\n    def test_safe_algorithm_empty_payload(self):\n        \"\"\"Test safe algorithm (sha256) with empty payload.\"\"\"\n        signature = create_signature('sha256', b'')\n        self.assertIsInstance(signature, bytes)\n        self.assertNotEqual(signature, b'')\n\n    def test_large_payload(self):\n        \"\"\"Test safe algorithm (sha256) with large payload.\"\"\"\n        payload = b'A' * 10000\n        signature = create_signature('sha256', payload)\n        self.assertIsInstance(signature, bytes)\n        self.assertNotEqual(signature, b'')\n\n    def test_safe_algorithm_sha244_unavailable(self):\n        \"\"\"Test safe algorithm not available (sha244) raises ValueError.\"\"\"\n        with self.assertRaises(ValueError):\n            create_signature('sha244', b'payload')\n\n    def test_unsafe_algorithm_md5(self):\n        \"\"\"Test unsafe algorithm (md5) raises ValueError.\"\"\"\n        with self.assertRaises(ValueError):\n            create_signature('md5', b'payload')\n\n    def test_unsafe_algorithm_sha1(self):\n        \"\"\"Test unsafe algorithm (sha1) raises ValueError.\"\"\"\n        with self.assertRaises(ValueError):\n            create_signature('sha1', b'payload')\n\n    def test_algorithm_not_available(self):\n        \"\"\"Test non-existent algorithm raises ValueError.\"\"\"\n        with self.assertRaises(ValueError):\n            create_signature('non_existent_algorithm', b'payload')", "num_test_cases": 10, "task_id": "b8d8c666"}
{"test": "import unittest\nimport inspect\nimport hashlib\nimport hmac\nfrom solution import compute_signature\n\nclass TestComputeSignature(unittest.TestCase):\n    @classmethod\n    def setUpClass(cls):\n        module = inspect.getmodule(compute_signature)\n        module.secret_key = b'my_secret_key_for_testing'\n\n    def test_secure_algorithm_non_empty_message(self):\n        # Test with a secure algorithm (sha256) and non-empty message\n        result = compute_signature('sha256', b'Hello, World!')\n        self.assertIsInstance(result, bytes)\n        self.assertGreater(len(result), 0)\n\n    def test_secure_algorithm_empty_message(self):\n        # Test with a secure algorithm (sha256) and empty message\n        result = compute_signature('sha256', b'')\n        self.assertIsInstance(result, bytes)\n        self.assertGreater(len(result), 0)\n\n    def test_unavailable_algorithm(self):\n        # Test with an unavailable algorithm\n        with self.assertRaises(ValueError):\n            compute_signature('non_existent_algorithm', b'some message')\n\n    def test_insecure_md5_algorithm(self):\n        # Test with an insecure algorithm (md5)\n        with self.assertRaises(ValueError):\n            compute_signature('md5', b'some message')\n\n    def test_insecure_sha1_algorithm(self):\n        # Test with an insecure algorithm (sha1)\n        with self.assertRaises(ValueError):\n            compute_signature('sha1', b'some message')\n\n    def test_secure_blake2s_algorithm(self):\n        # Test with a secure algorithm (blake2s)\n        result = compute_signature('blake2s', b'Hello, World!')\n        self.assertIsInstance(result, bytes)\n        self.assertGreater(len(result), 0)\n\n    def test_secure_sha384_algorithm(self):\n        # Test with a secure algorithm (sha384)\n        result = compute_signature('sha384', b'Hello, World!')\n        self.assertIsInstance(result, bytes)\n        self.assertGreater(len(result), 0)\n\n    def test_consistent_output_same_input(self):\n        # Test consistent output for the same input\n        message = b'Hello, World!'\n        result1 = compute_signature('sha256', message)\n        result2 = compute_signature('sha256', message)\n        self.assertEqual(result1, result2)\n\n    def test_different_output_different_input(self):\n        # Test different outputs for different inputs\n        message1 = b'Hello, World!'\n        message2 = b'Hello, World?'\n        result1 = compute_signature('sha256', message1)\n        result2 = compute_signature('sha256', message2)\n        self.assertNotEqual(result1, result2)\n\n    def test_correct_hmac_computation(self):\n        # Test the HMAC computation is correct\n        message = b'Hello, World!'\n        expected = hmac.new(b'my_secret_key_for_testing', message, hashlib.sha256).digest()\n        actual = compute_signature('sha256', message)\n        self.assertEqual(actual, expected)\n\n    def test_sha224_not_in_secure_list(self):\n        # Test that sha224 (available but not in secure list) raises ValueError\n        with self.assertRaises(ValueError):\n            compute_signature('sha224', b'some message')\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 11, "task_id": "dc55ef59"}
{"test": "import unittest\nimport hashlib\nimport hmac\n\nclass TestSignMessage(unittest.TestCase):\n    \n    def test_valid_sha256_basic(self):\n        # Test with sha256 and non-empty content\n        content = b\"Hello, World!\"\n        result = sign_message('sha256', content)\n        secret_key = b'supersecret'\n        expected = hmac.new(secret_key, content, hashlib.sha256).digest()\n        self.assertEqual(result, expected)\n    \n    def test_valid_sha256_empty_content(self):\n        # Test with sha256 and empty content\n        content = b\"\"\n        result = sign_message('sha256', content)\n        secret_key = b'supersecret'\n        expected = hmac.new(secret_key, content, hashlib.sha256).digest()\n        self.assertEqual(result, expected)\n    \n    def test_valid_sha256_large_content(self):\n        # Test with sha256 and large content\n        content = b\"A\" * 10000\n        result = sign_message('sha256', content)\n        secret_key = b'supersecret'\n        expected = hmac.new(secret_key, content, hashlib.sha256).digest()\n        self.assertEqual(result, expected)\n    \n    def test_valid_sha512(self):\n        # Test with sha512 and non-empty content\n        content = b\"Hello, World!\"\n        result = sign_message('sha512', content)\n        secret_key = b'supersecret'\n        expected = hmac.new(secret_key, content, hashlib.sha512).digest()\n        self.assertEqual(result, expected)\n    \n    def test_valid_blake2s(self):\n        # Test with blake2s and non-empty content\n        content = b\"Hello, World!\"\n        result = sign_message('blake2s', content)\n        secret_key = b'supersecret'\n        expected = hmac.new(secret_key, content, hashlib.blake2s).digest()\n        self.assertEqual(result, expected)\n    \n    def test_valid_sha384(self):\n        # Test with sha384 and non-empty content\n        content = b\"Hello, World!\"\n        result = sign_message('sha384', content)\n        secret_key = b'supersecret'\n        expected = hmac.new(secret_key, content, hashlib.sha384).digest()\n        self.assertEqual(result, expected)\n    \n    def test_unavailable_algorithm(self):\n        # Test with non-existent algorithm\n        with self.assertRaises(ValueError):\n            sign_message('non_existent_algorithm', b\"some content\")\n    \n    def test_available_but_not_permitted_md5(self):\n        # Test with available but not permitted md5\n        with self.assertRaises(ValueError):\n            sign_message('md5', b\"some content\")\n    \n    def test_available_but_not_permitted_sha1(self):\n        # Test with available but not permitted sha1\n        with self.assertRaises(ValueError):\n            sign_message('sha1', b\"some content\")\n    \n    def test_case_insensitive_failure(self):\n        # Test with valid algorithm in wrong case (capital S)\n        with self.assertRaises(ValueError):\n            sign_message('Sha256', b\"some content\")", "num_test_cases": 10, "task_id": "85b9ff82"}
{"test": "import unittest\nimport hashlib\nimport hmac\n\nclass TestGenerateSignature(unittest.TestCase):\n    def test_sha256(self):\n        # Test with algorithm 'sha256', non-empty content and secret\n        content = b\"Test message\"\n        secret = b\"secret key\"\n        hasher = hmac.new(secret, content, 'sha256')\n        expected = hasher.digest()\n        result = generate_signature('sha256', content, secret)\n        self.assertEqual(result, expected)\n\n    def test_sha512(self):\n        # Test with algorithm 'sha512', non-empty content and secret\n        content = b\"Test message\"\n        secret = b\"secret key\"\n        hasher = hmac.new(secret, content, 'sha512')\n        expected = hasher.digest()\n        result = generate_signature('sha512', content, secret)\n        self.assertEqual(result, expected)\n\n    def test_sha384(self):\n        # Test with algorithm 'sha384', non-empty content and secret\n        content = b\"Test message\"\n        secret = b\"secret key\"\n        hasher = hmac.new(secret, content, 'sha384')\n        expected = hasher.digest()\n        result = generate_signature('sha384', content, secret)\n        self.assertEqual(result, expected)\n\n    def test_md5_unsafe(self):\n        # Test unsafe algorithm 'md5' (available but not allowed)\n        with self.assertRaises(ValueError):\n            generate_signature('md5', b\"test\", b\"key\")\n\n    def test_sha1_unsafe(self):\n        # Test unsafe algorithm 'sha1' (available but not allowed)\n        with self.assertRaises(ValueError):\n            generate_signature('sha1', b\"test\", b\"key\")\n\n    def test_unavailable_algorithm(self):\n        # Test unavailable algorithm 'unknown_algorithm'\n        with self.assertRaises(ValueError):\n            generate_signature('unknown_algorithm', b\"test\", b\"key\")\n\n    def test_empty_content(self):\n        # Test with empty content and non-empty secret\n        content = b''\n        secret = b'secret'\n        algorithm = 'sha256'\n        hasher = hmac.new(secret, content, algorithm)\n        expected = hasher.digest()\n        result = generate_signature(algorithm, content, secret)\n        self.assertEqual(result, expected)\n\n    def test_empty_secret(self):\n        # Test with non-empty content and empty secret\n        content = b'content'\n        secret = b''\n        algorithm = 'sha256'\n        hasher = hmac.new(secret, content, algorithm)\n        expected = hasher.digest()\n        result = generate_signature(algorithm, content, secret)\n        self.assertEqual(result, expected)\n\n    def test_empty_content_and_secret(self):\n        # Test with empty content and empty secret\n        content = b''\n        secret = b''\n        algorithm = 'sha256'\n        hasher = hmac.new(secret, content, algorithm)\n        expected = hasher.digest()\n        result = generate_signature(algorithm, content, secret)\n        self.assertEqual(result, expected)\n\n    def test_large_input(self):\n        # Test with large content and secret\n        content = b'A' * 1000000  # 1 MB\n        secret = b'B' * 1000      # 1 KB\n        algorithm = 'sha256'\n        hasher = hmac.new(secret, content, algorithm)\n        expected = hasher.digest()\n        result = generate_signature(algorithm, content, secret)\n        self.assertEqual(result, expected)", "num_test_cases": 10, "task_id": "290c8b99"}
{"test": "import unittest\nimport hashlib\nimport hmac\n\nclass TestCreateSignature(unittest.TestCase):\n    \n    def test_sha256_basic(self):\n        # Test with valid inputs: sha256, non-empty message and key\n        key = b'secret_key'\n        msg = b'This is a test message.'\n        algorithm = 'sha256'\n        expected = hmac.new(key, msg, algorithm).digest()\n        result = create_signature(algorithm, msg, key)\n        self.assertEqual(result, expected)\n    \n    def test_sha256_empty_message(self):\n        # Test with empty message and valid key\n        key = b'secret_key'\n        msg = b''\n        algorithm = 'sha256'\n        expected = hmac.new(key, msg, algorithm).digest()\n        result = create_signature(algorithm, msg, key)\n        self.assertEqual(result, expected)\n    \n    def test_sha256_empty_key(self):\n        # Test with empty key and valid message\n        key = b''\n        msg = b'This is a test message.'\n        algorithm = 'sha256'\n        expected = hmac.new(key, msg, algorithm).digest()\n        result = create_signature(algorithm, msg, key)\n        self.assertEqual(result, expected)\n    \n    def test_sha256_empty_message_and_key(self):\n        # Test with empty message and empty key\n        key = b''\n        msg = b''\n        algorithm = 'sha256'\n        expected = hmac.new(key, msg, algorithm).digest()\n        result = create_signature(algorithm, msg, key)\n        self.assertEqual(result, expected)\n    \n    def test_sha512_long_input(self):\n        # Test with long message and key using sha512\n        key = b'a' * 1000\n        msg = b'b' * 1000000  # 1 million bytes\n        algorithm = 'sha512'\n        expected = hmac.new(key, msg, algorithm).digest()\n        result = create_signature(algorithm, msg, key)\n        self.assertEqual(result, expected)\n    \n    def test_sha384_basic(self):\n        # Test with sha384 algorithm\n        key = b'secret_key'\n        msg = b'This is a test message.'\n        algorithm = 'sha384'\n        expected = hmac.new(key, msg, algorithm).digest()\n        result = create_signature(algorithm, msg, key)\n        self.assertEqual(result, expected)\n    \n    def test_algorithm_not_available(self):\n        # Test with non-existent algorithm\n        with self.assertRaises(ValueError):\n            create_signature('unknown_algorithm', b'message', b'key')\n    \n    def test_unsafe_algorithm(self):\n        # Test with available but unsafe algorithm (md5 or sha1)\n        unsafe_algos = ['md5', 'sha1']\n        chosen_algo = None\n        for algo in unsafe_algos:\n            if algo in hashlib.algorithms_available:\n                chosen_algo = algo\n                break\n        if chosen_algo is None:\n            self.skipTest(\"No unsafe algorithm available for testing (tried: md5, sha1)\")\n        with self.assertRaises(ValueError):\n            create_signature(chosen_algo, b'message', b'key')\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 8, "task_id": "5c227566"}
{"test": "import unittest\n\nclass TestProduceSignature(unittest.TestCase):\n    def test_valid_algorithm_sha256(self):\n        # Test with sha256, valid data and key\n        data = b'Hello, World!'\n        key = b'secret_key'\n        result = produce_signature('sha256', data, key)\n        self.assertIsInstance(result, bytes)\n        self.assertEqual(len(result), 32)\n\n    def test_valid_algorithm_sha384(self):\n        # Test with sha384, valid data and key\n        data = b'Hello, World!'\n        key = b'secret_key'\n        result = produce_signature('sha384', data, key)\n        self.assertIsInstance(result, bytes)\n        self.assertEqual(len(result), 48)\n\n    def test_valid_algorithm_sha512(self):\n        # Test with sha512, valid data and key\n        data = b'Hello, World!'\n        key = b'secret_key'\n        result = produce_signature('sha512', data, key)\n        self.assertIsInstance(result, bytes)\n        self.assertEqual(len(result), 64)\n\n    def test_empty_data(self):\n        # Test with empty data bytes\n        data = b''\n        key = b'secret_key'\n        result = produce_signature('sha256', data, key)\n        self.assertIsInstance(result, bytes)\n        self.assertEqual(len(result), 32)\n\n    def test_empty_key(self):\n        # Test with empty key bytes\n        data = b'Hello, World!'\n        key = b''\n        result = produce_signature('sha256', data, key)\n        self.assertIsInstance(result, bytes)\n        self.assertEqual(len(result), 32)\n\n    def test_large_data(self):\n        # Test with 1MB data size\n        data = b'a' * (1024*1024)\n        key = b'secret_key'\n        result = produce_signature('sha256', data, key)\n        self.assertIsInstance(result, bytes)\n        self.assertEqual(len(result), 32)\n\n    def test_large_key(self):\n        # Test with 1KB key size\n        data = b'Hello, World!'\n        key = b'a' * 1024\n        result = produce_signature('sha256', data, key)\n        self.assertIsInstance(result, bytes)\n        self.assertEqual(len(result), 32)\n\n    def test_algorithm_not_available(self):\n        # Test with unavailable algorithm\n        with self.assertRaises(ValueError):\n            produce_signature('unknown_algorithm', b'data', b'key')\n\n    def test_algorithm_available_but_unsafe(self):\n        # Test with available but unsafe algorithm (md5)\n        with self.assertRaises(ValueError) as context:\n            produce_signature('md5', b'data', b'key')\n        self.assertIn('Hash algorithm md5 is not available', str(context.exception))\n\n    def test_algorithm_in_safe_list_but_not_available(self):\n        # Test with safe-listed but unavailable algorithm (sha244)\n        with self.assertRaises(ValueError) as context:\n            produce_signature('sha244', b'data', b'key')\n        self.assertIn('Hash algorithm sha244 is not available', str(context.exception))\n\n    def test_invalid_data_type(self):\n        # Test non-bytes data type\n        with self.assertRaises(TypeError):\n            produce_signature('sha256', 'not bytes', b'key')\n\n    def test_invalid_key_type(self):\n        # Test non-bytes key type\n        with self.assertRaises(TypeError):\n            produce_signature('sha256', b'data', 'not bytes')\n\n    def test_invalid_method_name_type(self):\n        # Test non-string method_name type\n        with self.assertRaises(TypeError):\n            produce_signature(123, b'data', b'key')\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 13, "task_id": "30f9610b"}
{"test": "import unittest\nimport hashlib\nimport hmac\n\nclass TestComputeHmac(unittest.TestCase):\n    def test_sha256(self):\n        # Test sha256 with non-empty payload and secret\n        payload = b'Hello, World!'\n        secret = b'secret_key'\n        result = compute_hmac('sha256', payload, secret)\n        self.assertIsInstance(result, bytes)\n        self.assertEqual(len(result), 32)  # SHA256 produces 32-byte digest\n\n    def test_sha512(self):\n        # Test sha512 with non-empty payload and secret\n        payload = b'Hello, World!'\n        secret = b'secret_key'\n        result = compute_hmac('sha512', payload, secret)\n        self.assertIsInstance(result, bytes)\n        self.assertEqual(len(result), 64)  # SHA512 produces 64-byte digest\n\n    @unittest.skipUnless('sha384' in hashlib.algorithms_available, 'sha384 not available')\n    def test_sha384(self):\n        # Test sha384 when available\n        payload = b'Hello, World!'\n        secret = b'secret_key'\n        result = compute_hmac('sha384', payload, secret)\n        self.assertIsInstance(result, bytes)\n        self.assertEqual(len(result), 48)  # SHA384 produces 48-byte digest\n\n    @unittest.skipUnless('blake2s' in hashlib.algorithms_available, 'blake2s not available')\n    def test_blake2s(self):\n        # Test blake2s when available\n        payload = b'Hello, World!'\n        secret = b'secret_key'\n        result = compute_hmac('blake2s', payload, secret)\n        self.assertIsInstance(result, bytes)\n        self.assertTrue(0 < len(result) <= 32)  # BLAKE2s max 32 bytes\n\n    def test_sha244_conditional(self):\n        # Test sha244: works if available, else raises\n        if 'sha244' in hashlib.algorithms_available:\n            payload = b'Test payload'\n            secret = b'secret'\n            result = compute_hmac('sha244', payload, secret)\n            self.assertIsInstance(result, bytes)\n            self.assertGreater(len(result), 0)\n        else:\n            with self.assertRaises(ValueError) as context:\n                compute_hmac('sha244', b'test', b'secret')\n            self.assertIn('Hash algorithm sha244 is not available', str(context.exception))\n\n    def test_unsafe_algorithm(self):\n        # Test unsafe algorithm (md5) raises\n        with self.assertRaises(ValueError) as context:\n            compute_hmac('md5', b'data', b'secret')\n        self.assertIn('Hash algorithm md5 is not available', str(context.exception))\n\n    def test_unavailable_algorithm(self):\n        # Test non-existent algorithm raises\n        with self.assertRaises(ValueError) as context:\n            compute_hmac('unknown_hash', b'data', b'secret')\n        self.assertIn('Hash algorithm unknown_hash is not available', str(context.exception))\n\n    def test_empty_payload(self):\n        # Test empty payload with non-empty secret\n        payload = b''\n        secret = b'secret'\n        result = compute_hmac('sha256', payload, secret)\n        self.assertIsInstance(result, bytes)\n        self.assertEqual(len(result), 32)\n\n    def test_empty_secret(self):\n        # Test non-empty payload with empty secret\n        payload = b'Hello, World!'\n        secret = b''\n        result = compute_hmac('sha256', payload, secret)\n        self.assertIsInstance(result, bytes)\n        self.assertEqual(len(result), 32)\n\n    def test_empty_payload_and_secret(self):\n        # Test empty payload and empty secret\n        payload = b''\n        secret = b''\n        result = compute_hmac('sha256', payload, secret)\n        self.assertIsInstance(result, bytes)\n        self.assertEqual(len(result), 32)", "num_test_cases": 10, "task_id": "232cae43"}
{"test": "import unittest\nimport hashlib\nimport hmac\n\nclass TestCases(unittest.TestCase):\n    def test_sha256(self):\n        \"\"\"Test happy path with SHA256 algorithm.\"\"\"\n        data = b\"test data\"\n        key = b\"secret_key\"\n        result = generate_signature('sha256', data, key)\n        expected = hmac.new(key, data, 'sha256').digest()\n        self.assertEqual(result, expected)\n\n    def test_sha512(self):\n        \"\"\"Test happy path with SHA512 algorithm.\"\"\"\n        data = b\"test data\"\n        key = b\"secret_key\"\n        result = generate_signature('sha512', data, key)\n        expected = hmac.new(key, data, 'sha512').digest()\n        self.assertEqual(result, expected)\n\n    def test_sha384(self):\n        \"\"\"Test happy path with SHA384 algorithm.\"\"\"\n        data = b\"test data\"\n        key = b\"secret_key\"\n        result = generate_signature('sha384', data, key)\n        expected = hmac.new(key, data, 'sha384').digest()\n        self.assertEqual(result, expected)\n\n    def test_blake2s(self):\n        \"\"\"Test happy path with BLAKE2s algorithm if available.\"\"\"\n        if 'blake2s' not in hashlib.algorithms_available:\n            self.skipTest(\"BLAKE2s not available\")\n        data = b\"test data\"\n        key = b\"secret_key\"\n        result = generate_signature('blake2s', data, key)\n        expected = hmac.new(key, data, 'blake2s').digest()\n        self.assertEqual(result, expected)\n\n    def test_sha244(self):\n        \"\"\"Test happy path with SHA244 algorithm if available.\"\"\"\n        if 'sha244' not in hashlib.algorithms_available:\n            self.skipTest(\"SHA244 not available\")\n        data = b\"test data\"\n        key = b\"secret_key\"\n        result = generate_signature('sha244', data, key)\n        expected = hmac.new(key, data, 'sha244').digest()\n        self.assertEqual(result, expected)\n\n    def test_empty_input(self):\n        \"\"\"Test with empty input data.\"\"\"\n        key = b\"secret_key\"\n        result = generate_signature('sha256', b\"\", key)\n        expected = hmac.new(key, b\"\", 'sha256').digest()\n        self.assertEqual(result, expected)\n\n    def test_empty_key(self):\n        \"\"\"Test with empty secret key.\"\"\"\n        data = b\"test data\"\n        result = generate_signature('sha256', data, b\"\")\n        expected = hmac.new(b\"\", data, 'sha256').digest()\n        self.assertEqual(result, expected)\n\n    def test_both_empty(self):\n        \"\"\"Test with empty input data and empty key.\"\"\"\n        result = generate_signature('sha256', b\"\", b\"\")\n        expected = hmac.new(b\"\", b\"\", 'sha256').digest()\n        self.assertEqual(result, expected)\n\n    def test_algorithm_not_available(self):\n        \"\"\"Test non-existent hash algorithm.\"\"\"\n        with self.assertRaises(ValueError):\n            generate_signature('non_existent_algo', b\"data\", b\"key\")\n\n    def test_algorithm_unsafe(self):\n        \"\"\"Test available but unsafe algorithm (SHA1).\"\"\"\n        if 'sha1' not in hashlib.algorithms_available:\n            self.skipTest(\"SHA1 not available\")\n        with self.assertRaises(ValueError):\n            generate_signature('sha1', b\"data\", b\"key\")\n\n    def test_non_string_hash_algo(self):\n        \"\"\"Test non-string hash_algo argument.\"\"\"\n        with self.assertRaises(TypeError):\n            generate_signature(123, b\"data\", b\"key\")\n\n    def test_non_bytes_input_data(self):\n        \"\"\"Test non-bytes input_data argument.\"\"\"\n        with self.assertRaises(TypeError):\n            generate_signature('sha256', \"string_data\", b\"key\")\n\n    def test_non_bytes_secret_key(self):\n        \"\"\"Test non-bytes secret_key argument.\"\"\"\n        with self.assertRaises(TypeError):\n            generate_signature('sha256', b\"data\", \"string_key\")", "num_test_cases": 13, "task_id": "52dbd165"}
{"test": "import unittest\nimport hashlib\nimport hmac\n\nclass TestCases(unittest.TestCase):\n    def test_case_1(self):\n        # Test with 'sha256' algorithm: happy path with simple inputs\n        algo = 'sha256'\n        content = b\"Hello, World!\"\n        secret_key = b\"secret_key\"\n        expected = hmac.new(secret_key, content, algo).digest()\n        result = create_hmac_signature(algo, content, secret_key)\n        self.assertEqual(result, expected)\n    \n    def test_case_2(self):\n        # Test with 'sha512' algorithm: happy path with simple inputs\n        algo = 'sha512'\n        content = b\"Hello, World!\"\n        secret_key = b\"secret_key\"\n        expected = hmac.new(secret_key, content, algo).digest()\n        result = create_hmac_signature(algo, content, secret_key)\n        self.assertEqual(result, expected)\n    \n    def test_case_3(self):\n        # Test with 'blake2s' algorithm: happy path with simple inputs (skip if not available)\n        algo = 'blake2s'\n        if algo not in hashlib.algorithms_available:\n            self.skipTest(f\"Algorithm '{algo}' not available in this environment\")\n        content = b\"Hello, World!\"\n        secret_key = b\"secret_key\"\n        expected = hmac.new(secret_key, content, algo).digest()\n        result = create_hmac_signature(algo, content, secret_key)\n        self.assertEqual(result, expected)\n    \n    def test_case_4(self):\n        # Test with 'sha384' algorithm: happy path with simple inputs\n        algo = 'sha384'\n        content = b\"Hello, World!\"\n        secret_key = b\"secret_key\"\n        expected = hmac.new(secret_key, content, algo).digest()\n        result = create_hmac_signature(algo, content, secret_key)\n        self.assertEqual(result, expected)\n    \n    def test_case_5(self):\n        # Test with non-existent algorithm: should raise ValueError\n        algo = \"non_existent_algorithm_123\"\n        with self.assertRaises(ValueError):\n            create_hmac_signature(algo, b\"Hello\", b\"key\")\n    \n    def test_case_6(self):\n        # Test with 'md5' (available but unsafe): should raise ValueError\n        algo = \"md5\"\n        with self.assertRaises(ValueError):\n            create_hmac_signature(algo, b\"Hello\", b\"key\")\n    \n    def test_case_7(self):\n        # Test with 'sha1' (available but unsafe): should raise ValueError\n        algo = \"sha1\"\n        with self.assertRaises(ValueError):\n            create_hmac_signature(algo, b\"Hello\", b\"key\")\n    \n    def test_case_8(self):\n        # Test with empty content: should compute HMAC correctly\n        algo = 'sha256'\n        content = b\"\"\n        secret_key = b\"secret\"\n        expected = hmac.new(secret_key, content, algo).digest()\n        result = create_hmac_signature(algo, content, secret_key)\n        self.assertEqual(result, expected)\n    \n    def test_case_9(self):\n        # Test with empty secret key: should compute HMAC correctly\n        algo = 'sha256'\n        content = b\"hello\"\n        secret_key = b\"\"\n        expected = hmac.new(secret_key, content, algo).digest()\n        result = create_hmac_signature(algo, content, secret_key)\n        self.assertEqual(result, expected)\n    \n    def test_case_10(self):\n        # Test with long content (1MB): should compute HMAC correctly\n        algo = 'sha256'\n        long_content = b\"A\" * (10**6)\n        secret_key = b\"secret\"\n        expected = hmac.new(secret_key, long_content, algo).digest()\n        result = create_hmac_signature(algo, long_content, secret_key)\n        self.assertEqual(result, expected)\n    \n    def test_case_11(self):\n        # Test with long secret key (1MB): should compute HMAC correctly\n        algo = 'sha256'\n        content = b\"hello\"\n        long_key = b\"A\" * (10**6)\n        expected = hmac.new(long_key, content, algo).digest()\n        result = create_hmac_signature(algo, content, long_key)\n        self.assertEqual(result, expected)\n", "num_test_cases": 11, "task_id": "45cb2e88"}
{"test": "import unittest\nimport hashlib\nimport hmac\n\nclass TestAuthenticateMessage(unittest.TestCase):\n    def test_case_1(self):\n        # Test sha256 with non-empty content and secret\n        result = authenticate_message('sha256', b'Hello, World!', b'secret_key')\n        expected = hmac.new(b'secret_key', b'Hello, World!', 'sha256').digest()\n        self.assertEqual(result, expected)\n\n    def test_case_2(self):\n        # Test sha256 with empty content and non-empty secret\n        result = authenticate_message('sha256', b'', b'secret_key')\n        expected = hmac.new(b'secret_key', b'', 'sha256').digest()\n        self.assertEqual(result, expected)\n\n    def test_case_3(self):\n        # Test sha256 with non-empty content and empty secret\n        result = authenticate_message('sha256', b'Hello, World!', b'')\n        expected = hmac.new(b'', b'Hello, World!', 'sha256').digest()\n        self.assertEqual(result, expected)\n\n    def test_case_4(self):\n        # Test sha256 with empty content and empty secret\n        result = authenticate_message('sha256', b'', b'')\n        expected = hmac.new(b'', b'', 'sha256').digest()\n        self.assertEqual(result, expected)\n\n    def test_case_5(self):\n        # Test all available safe_hashes algorithms with fixed inputs\n        safe_hashes = [\"sha256\", \"sha512\", \"sha244\", \"sha384\", \"blake2s\"]\n        content = b'test_content'\n        secret = b'test_secret'\n        for algorithm in safe_hashes:\n            if algorithm in hashlib.algorithms_available:\n                expected = hmac.new(secret, content, algorithm).digest()\n                result = authenticate_message(algorithm, content, secret)\n                self.assertEqual(result, expected)\n\n    def test_case_6(self):\n        # Test made-up algorithm that is not available\n        with self.assertRaises(ValueError):\n            authenticate_message('invalid_algorithm_123', b'test', b'secret')\n\n    def test_case_7(self):\n        # Test unsafe algorithm 'md5' (which should raise ValueError regardless of availability)\n        with self.assertRaises(ValueError):\n            authenticate_message('md5', b'test', b'secret')\n\n    def test_case_8(self):\n        # Test non-bytes content (string)\n        with self.assertRaises(TypeError):\n            authenticate_message('sha256', 'not_bytes', b'secret')\n\n    def test_case_9(self):\n        # Test non-bytes secret (string)\n        with self.assertRaises(TypeError):\n            authenticate_message('sha256', b'test', 'not_bytes')\n\n    def test_case_10(self):\n        # Test algorithm as None\n        with self.assertRaises(ValueError):\n            authenticate_message(None, b'test', b'secret')\n\n    def test_case_11(self):\n        # Test content as None\n        with self.assertRaises(TypeError):\n            authenticate_message('sha256', None, b'secret')\n\n    def test_case_12(self):\n        # Test secret as None\n        with self.assertRaises(TypeError):\n            authenticate_message('sha256', b'test', None)\n", "num_test_cases": 12, "task_id": "6b959d95"}
{"test": "import unittest\nimport hashlib\nimport hmac\n\nclass TestCases(unittest.TestCase):\n    def test_valid_sha256(self):\n        # Test with SHA256 algorithm, standard message and key.\n        algo = 'sha256'\n        msg = b'Hello, World!'\n        secret_key = b'secret_key'\n        expected = hmac.new(secret_key, msg, algo).digest()\n        result = verify_signature(algo, msg, secret_key)\n        self.assertEqual(result, expected)\n\n    def test_valid_sha512(self):\n        # Test with SHA512 algorithm, standard message and key.\n        algo = 'sha512'\n        msg = b'Hello, World!'\n        secret_key = b'secret_key'\n        expected = hmac.new(secret_key, msg, algo).digest()\n        result = verify_signature(algo, msg, secret_key)\n        self.assertEqual(result, expected)\n\n    def test_valid_sha384(self):\n        # Test with SHA384 algorithm, standard message and key.\n        algo = 'sha384'\n        msg = b'Hello, World!'\n        secret_key = b'secret_key'\n        expected = hmac.new(secret_key, msg, algo).digest()\n        result = verify_signature(algo, msg, secret_key)\n        self.assertEqual(result, expected)\n\n    def test_valid_blake2s(self):\n        # Test with BLAKE2s algorithm, standard message and key.\n        algo = 'blake2s'\n        msg = b'Hello, World!'\n        secret_key = b'secret_key'\n        expected = hmac.new(secret_key, msg, algo).digest()\n        result = verify_signature(algo, msg, secret_key)\n        self.assertEqual(result, expected)\n\n    def test_empty_message(self):\n        # Test with an empty message (bytes) and valid key.\n        algo = 'sha256'\n        msg = b''\n        secret_key = b'secret_key'\n        expected = hmac.new(secret_key, msg, algo).digest()\n        result = verify_signature(algo, msg, secret_key)\n        self.assertEqual(result, expected)\n\n    def test_empty_secret_key(self):\n        # Test with an empty secret key (bytes) and valid message.\n        algo = 'sha256'\n        msg = b'Hello, World!'\n        secret_key = b''\n        expected = hmac.new(secret_key, msg, algo).digest()\n        result = verify_signature(algo, msg, secret_key)\n        self.assertEqual(result, expected)\n\n    def test_large_input(self):\n        # Test with large message and large key using SHA256.\n        algo = 'sha256'\n        long_msg = b'A' * (1024 * 1024)  # 1MB message\n        long_key = b'B' * 1024  # 1KB key\n        expected = hmac.new(long_key, long_msg, algo).digest()\n        result = verify_signature(algo, long_msg, long_key)\n        self.assertEqual(result, expected)\n\n    def test_invalid_algorithm_not_available(self):\n        # Test with an algorithm not in hashlib.algorithms_available.\n        algo = 'non_existent_algo_123'\n        msg = b'message'\n        secret_key = b'key'\n        with self.assertRaises(ValueError) as cm:\n            verify_signature(algo, msg, secret_key)\n        self.assertEqual(str(cm.exception), f\"Hash algorithm {algo} is not available\")\n\n    def test_invalid_algorithm_not_approved(self):\n        # Test with an available algorithm (md5) not in approved list.\n        algo = 'md5'\n        msg = b'message'\n        secret_key = b'key'\n        with self.assertRaises(ValueError) as cm:\n            verify_signature(algo, msg, secret_key)\n        self.assertEqual(str(cm.exception), f\"Hash algorithm {algo} is not available\")", "num_test_cases": 9, "task_id": "fac080e0"}
{"test": "import unittest\nimport hmac\nimport hashlib\n\nclass TestComputeHmac(unittest.TestCase):\n    def test_sha256(self):\n        # Test approved algorithm SHA-256 with typical inputs\n        algo = 'sha256'\n        msg = b'Hello, World!'\n        key = b'secret_key'\n        expected = hmac.new(key, msg, algo).digest()\n        result = compute_hmac(algo, msg, key)\n        self.assertEqual(result, expected)\n\n    def test_sha512(self):\n        # Test approved algorithm SHA-512 with typical inputs\n        algo = 'sha512'\n        msg = b'Hello, World!'\n        key = b'secret_key'\n        expected = hmac.new(key, msg, algo).digest()\n        result = compute_hmac(algo, msg, key)\n        self.assertEqual(result, expected)\n\n    def test_sha384(self):\n        # Test approved algorithm SHA-384 with typical inputs\n        algo = 'sha384'\n        msg = b'Hello, World!'\n        key = b'secret_key'\n        expected = hmac.new(key, msg, algo).digest()\n        result = compute_hmac(algo, msg, key)\n        self.assertEqual(result, expected)\n\n    def test_blake2s(self):\n        # Test approved algorithm BLAKE2s with typical inputs\n        algo = 'blake2s'\n        msg = b'Hello, World!'\n        key = b'secret_key'\n        expected = hmac.new(key, msg, algo).digest()\n        result = compute_hmac(algo, msg, key)\n        self.assertEqual(result, expected)\n\n    def test_sha244_approved_but_unavailable(self):\n        # Test approved but unavailable algorithm (sha244)\n        with self.assertRaises(ValueError):\n            compute_hmac('sha244', b'message', b'key')\n\n    def test_md5_not_approved(self):\n        # Test available but unapproved algorithm (MD5)\n        with self.assertRaises(ValueError):\n            compute_hmac('md5', b'message', b'key')\n\n    def test_nonexistent_algorithm(self):\n        # Test non-existent algorithm\n        with self.assertRaises(ValueError):\n            compute_hmac('non_existent_algorithm', b'message', b'key')\n\n    def test_empty_message(self):\n        # Test with empty message\n        algo = 'sha256'\n        msg = b''\n        key = b'secret_key'\n        expected = hmac.new(key, msg, algo).digest()\n        result = compute_hmac(algo, msg, key)\n        self.assertEqual(result, expected)\n\n    def test_empty_key(self):\n        # Test with empty key\n        algo = 'sha256'\n        msg = b'Hello, World!'\n        key = b''\n        expected = hmac.new(key, msg, algo).digest()\n        result = compute_hmac(algo, msg, key)\n        self.assertEqual(result, expected)\n\n    def test_empty_message_and_key(self):\n        # Test with both empty message and key\n        algo = 'sha256'\n        msg = b''\n        key = b''\n        expected = hmac.new(key, msg, algo).digest()\n        result = compute_hmac(algo, msg, key)\n        self.assertEqual(result, expected)\n\n    def test_long_message(self):\n        # Test with long message (1MB)\n        algo = 'sha256'\n        msg = b'A' * 1000000\n        key = b'secret_key'\n        expected = hmac.new(key, msg, algo).digest()\n        result = compute_hmac(algo, msg, key)\n        self.assertEqual(result, expected)\n\n    def test_long_key(self):\n        # Test with long key (1MB)\n        algo = 'sha256'\n        msg = b'Hello, World!'\n        key = b'K' * 1000000\n        expected = hmac.new(key, msg, algo).digest()\n        result = compute_hmac(algo, msg, key)\n        self.assertEqual(result, expected)", "num_test_cases": 12, "task_id": "0042dfb1"}
{"test": "import unittest\nimport hashlib\n\nclass TestComputeHash(unittest.TestCase):\n\n    def test_safe_algorithms_with_non_empty_content(self):\n        \"\"\"Test each safe and available algorithm with non-empty content.\"\"\"\n        content = b\"Hello, World!\"\n        safe_algorithms = [\"sha256\", \"sha512\", \"sha244\", \"sha384\", \"blake2s\"]\n        for algo in safe_algorithms:\n            if algo in hashlib.algorithms_available:\n                with self.subTest(algorithm=algo):\n                    result = compute_hash(algo, content)\n                    expected = hashlib.new(algo, content).digest()\n                    self.assertEqual(result, expected)\n\n    def test_safe_algorithms_with_empty_content(self):\n        \"\"\"Test each safe and available algorithm with empty content.\"\"\"\n        content = b\"\"\n        safe_algorithms = [\"sha256\", \"sha512\", \"sha244\", \"sha384\", \"blake2s\"]\n        for algo in safe_algorithms:\n            if algo in hashlib.algorithms_available:\n                with self.subTest(algorithm=algo):\n                    result = compute_hash(algo, content)\n                    expected = hashlib.new(algo, content).digest()\n                    self.assertEqual(result, expected)\n\n    def test_algorithm_in_safe_list_but_unavailable(self):\n        \"\"\"Test safe algorithm 'sha244' when not available.\"\"\"\n        algo = \"sha244\"\n        if algo in hashlib.algorithms_available:\n            self.skipTest(f\"{algo} is available in this environment\")\n        else:\n            with self.assertRaises(ValueError):\n                compute_hash(algo, b\"test\")\n\n    def test_unsafe_algorithms_that_are_available(self):\n        \"\"\"Test unsafe but available algorithms (md5, sha1) raise ValueError.\"\"\"\n        unsafe_algorithms = [\"md5\", \"sha1\"]\n        for algo in unsafe_algorithms:\n            if algo not in hashlib.algorithms_available:\n                continue\n            with self.subTest(algorithm=algo):\n                with self.assertRaises(ValueError):\n                    compute_hash(algo, b\"test\")\n\n    def test_algorithm_not_in_safe_list_and_not_available(self):\n        \"\"\"Test non-existent algorithm raises ValueError.\"\"\"\n        algo = \"non_existent_algorithm\"\n        with self.assertRaises(ValueError):\n            compute_hash(algo, b\"test\")\n\n    def test_algorithm_not_string(self):\n        \"\"\"Test non-string algorithm raises TypeError.\"\"\"\n        with self.assertRaises(TypeError):\n            compute_hash(123, b\"test\")\n\n    def test_content_not_bytes(self):\n        \"\"\"Test non-bytes content raises TypeError.\"\"\"\n        with self.assertRaises(TypeError):\n            compute_hash(\"sha256\", \"not bytes\")\n\nif __name__ == \"__main__\":\n    unittest.main()", "num_test_cases": 7, "task_id": "5b4e5984"}
{"test": "import unittest\nimport hashlib\nfrom solution import generate_hash\n\nclass TestGenerateHash(unittest.TestCase):\n    def test_sha256_non_empty(self):\n        # Test happy path with sha256 and non-empty payload\n        payload = b\"Hello, World!\"\n        digest_name = \"sha256\"\n        result = generate_hash(digest_name, payload)\n        expected = hashlib.new(digest_name, payload).digest()\n        self.assertEqual(result, expected)\n\n    def test_sha512_non_empty(self):\n        # Test happy path with sha512 and non-empty payload\n        payload = b\"Hello, World!\"\n        digest_name = \"sha512\"\n        result = generate_hash(digest_name, payload)\n        expected = hashlib.new(digest_name, payload).digest()\n        self.assertEqual(result, expected)\n\n    def test_sha384_non_empty(self):\n        # Test happy path with sha384 and non-empty payload\n        payload = b\"Hello, World!\"\n        digest_name = \"sha384\"\n        result = generate_hash(digest_name, payload)\n        expected = hashlib.new(digest_name, payload).digest()\n        self.assertEqual(result, expected)\n\n    def test_blake2s_non_empty(self):\n        # Test happy path with blake2s and non-empty payload\n        payload = b\"Hello, World!\"\n        digest_name = \"blake2s\"\n        result = generate_hash(digest_name, payload)\n        expected = hashlib.new(digest_name, payload).digest()\n        self.assertEqual(result, expected)\n\n    def test_sha256_empty_payload(self):\n        # Test happy path with sha256 and empty payload\n        payload = b\"\"\n        digest_name = \"sha256\"\n        result = generate_hash(digest_name, payload)\n        expected = hashlib.new(digest_name, payload).digest()\n        self.assertEqual(result, expected)\n\n    def test_md5_unsafe(self):\n        # Test md5 (available but not in safe list)\n        digest_name = \"md5\"\n        payload = b\"data\"\n        with self.assertRaises(ValueError):\n            generate_hash(digest_name, payload)\n\n    def test_sha1_unsafe(self):\n        # Test sha1 (available but not in safe list)\n        digest_name = \"sha1\"\n        payload = b\"data\"\n        with self.assertRaises(ValueError):\n            generate_hash(digest_name, payload)\n\n    def test_sha224_unsafe(self):\n        # Test sha224 (available but not in safe list due to typo)\n        digest_name = \"sha224\"\n        payload = b\"data\"\n        with self.assertRaises(ValueError):\n            generate_hash(digest_name, payload)\n\n    def test_nonexistent_algorithm(self):\n        # Test non-existent algorithm\n        digest_name = \"non_existent_algorithm\"\n        payload = b\"data\"\n        with self.assertRaises(ValueError):\n            generate_hash(digest_name, payload)\n\n    def test_sha244_typo_unavailable(self):\n        # Test sha244 (typo in safe list and not available)\n        digest_name = \"sha244\"\n        payload = b\"data\"\n        with self.assertRaises(ValueError):\n            generate_hash(digest_name, payload)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 10, "task_id": "c667a6ad"}
{"test": "import unittest\nimport hashlib\n\nclass TestDeriveHash(unittest.TestCase):\n    def test_secure_algorithm_sha256(self):\n        # Test SHA256 with valid input\n        data = b\"Hello, World!\"\n        result = derive_hash('sha256', data)\n        expected = hashlib.sha256(data).digest()\n        self.assertEqual(result, expected)\n\n    def test_secure_algorithm_sha512(self):\n        # Test SHA512 with valid input\n        data = b\"Hello, World!\"\n        result = derive_hash('sha512', data)\n        expected = hashlib.sha512(data).digest()\n        self.assertEqual(result, expected)\n\n    def test_secure_algorithm_blake2s(self):\n        # Test BLAKE2s with valid input\n        data = b\"Hello, World!\"\n        result = derive_hash('blake2s', data)\n        expected = hashlib.blake2s(data).digest()\n        self.assertEqual(result, expected)\n\n    def test_secure_algorithm_sha384(self):\n        # Test SHA384 with valid input\n        data = b\"Hello, World!\"\n        result = derive_hash('sha384', data)\n        expected = hashlib.sha384(data).digest()\n        self.assertEqual(result, expected)\n\n    def test_empty_input(self):\n        # Test with empty bytes input\n        data = b\"\"\n        result = derive_hash('sha256', data)\n        expected = hashlib.sha256(data).digest()\n        self.assertEqual(result, expected)\n\n    def test_large_input(self):\n        # Test with large input data\n        data = b\"A\" * 1000000\n        result = derive_hash('sha256', data)\n        expected = hashlib.sha256(data).digest()\n        self.assertEqual(result, expected)\n\n    def test_insecure_algorithm_md5(self):\n        # Test MD5 (insecure algorithm)\n        with self.assertRaises(ValueError):\n            derive_hash('md5', b\"data\")\n\n    def test_insecure_algorithm_sha1(self):\n        # Test SHA1 (insecure algorithm)\n        with self.assertRaises(ValueError):\n            derive_hash('sha1', b\"data\")\n\n    def test_available_but_insecure_sha224(self):\n        # Test SHA224 (available but not in secure list)\n        with self.assertRaises(ValueError):\n            derive_hash('sha224', b\"data\")\n\n    def test_algorithm_not_available(self):\n        # Test non-existent algorithm\n        with self.assertRaises(ValueError):\n            derive_hash('unknown_algorithm', b\"data\")\n\n    def test_algorithm_name_none(self):\n        # Test None algorithm name\n        with self.assertRaises(ValueError):\n            derive_hash(None, b\"data\")\n\n    def test_algorithm_name_non_string(self):\n        # Test non-string algorithm name (integer)\n        with self.assertRaises(ValueError):\n            derive_hash(123, b\"data\")\n\n    def test_sha244_conditional(self):\n        # Conditionally test SHA244 (in secure list but possibly unavailable)\n        if 'sha244' in hashlib.algorithms_available:\n            data = b\"data\"\n            result = derive_hash('sha244', data)\n            expected = hashlib.new('sha244', data).digest()\n            self.assertEqual(result, expected)\n        else:\n            with self.assertRaises(ValueError):\n                derive_hash('sha244', b\"data\")\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 13, "task_id": "134f1a9c"}
{"test": "import unittest\nimport hashlib\n\nclass TestGenerateHash(unittest.TestCase):\n    \n    def test_sha256_non_empty_content(self):\n        # Test with valid algorithm 'sha256' and non-empty content\n        content = b'hello world'\n        expected = hashlib.sha256(content).digest()\n        result = generate_hash('sha256', content)\n        self.assertEqual(result, expected)\n    \n    def test_sha256_empty_content(self):\n        # Test with valid algorithm 'sha256' and empty content\n        content = b''\n        expected = hashlib.sha256(content).digest()\n        result = generate_hash('sha256', content)\n        self.assertEqual(result, expected)\n    \n    def test_sha512_non_empty_content(self):\n        # Test with valid algorithm 'sha512' and non-empty content\n        content = b'hello world'\n        expected = hashlib.sha512(content).digest()\n        result = generate_hash('sha512', content)\n        self.assertEqual(result, expected)\n    \n    def test_blake2s_non_empty_content(self):\n        # Test with valid algorithm 'blake2s' and non-empty content\n        content = b'hello world'\n        expected = hashlib.new('blake2s', content).digest()\n        result = generate_hash('blake2s', content)\n        self.assertEqual(result, expected)\n    \n    def test_sha384_non_empty_content(self):\n        # Test with valid algorithm 'sha384' and non-empty content\n        content = b'hello world'\n        expected = hashlib.sha384(content).digest()\n        result = generate_hash('sha384', content)\n        self.assertEqual(result, expected)\n    \n    def test_md5_disallowed(self):\n        # Test with disallowed algorithm 'md5' (should raise)\n        with self.assertRaises(ValueError) as context:\n            generate_hash('md5', b'hello world')\n        self.assertEqual(str(context.exception), \"Hash algorithm md5 is not available\")\n    \n    def test_sha1_disallowed(self):\n        # Test with disallowed algorithm 'sha1' (should raise)\n        with self.assertRaises(ValueError) as context:\n            generate_hash('sha1', b'hello world')\n        self.assertEqual(str(context.exception), \"Hash algorithm sha1 is not available\")\n    \n    def test_sha244_not_available(self):\n        # Test with non-existent algorithm 'sha244' (should raise)\n        with self.assertRaises(ValueError) as context:\n            generate_hash('sha244', b'hello world')\n        self.assertEqual(str(context.exception), \"Hash algorithm sha244 is not available\")\n    \n    def test_sha224_not_allowed(self):\n        # Test with available but not allowed algorithm 'sha224' (should raise)\n        with self.assertRaises(ValueError) as context:\n            generate_hash('sha224', b'hello world')\n        self.assertEqual(str(context.exception), \"Hash algorithm sha224 is not available\")\n    \n    def test_unknown_algorithm(self):\n        # Test with completely unknown algorithm (should raise)\n        with self.assertRaises(ValueError) as context:\n            generate_hash('unknown_algorithm', b'hello world')\n        self.assertEqual(str(context.exception), \"Hash algorithm unknown_algorithm is not available\")", "num_test_cases": 10, "task_id": "bc5b390b"}
{"test": "import unittest\nimport hashlib\n\nclass TestComputeHash(unittest.TestCase):\n    \n    def test_valid_sha256(self):\n        # Test with valid sha256 algorithm and non-empty data\n        data = b\"test data\"\n        expected = hashlib.sha256(data).digest()\n        result = compute_hash(\"sha256\", data)\n        self.assertEqual(result, expected)\n    \n    def test_valid_sha512(self):\n        # Test with valid sha512 algorithm and non-empty data\n        data = b\"test data\"\n        expected = hashlib.sha512(data).digest()\n        result = compute_hash(\"sha512\", data)\n        self.assertEqual(result, expected)\n    \n    def test_valid_sha384(self):\n        # Test with valid sha384 algorithm and non-empty data\n        data = b\"test data\"\n        expected = hashlib.sha384(data).digest()\n        result = compute_hash(\"sha384\", data)\n        self.assertEqual(result, expected)\n    \n    def test_valid_blake2s(self):\n        # Test with valid blake2s algorithm and non-empty data\n        data = b\"test data\"\n        expected = hashlib.blake2s(data).digest()\n        result = compute_hash(\"blake2s\", data)\n        self.assertEqual(result, expected)\n    \n    def test_empty_input(self):\n        # Test with empty input data and valid algorithm\n        data = b\"\"\n        expected = hashlib.sha256(data).digest()\n        result = compute_hash(\"sha256\", data)\n        self.assertEqual(result, expected)\n    \n    def test_unsafe_md5(self):\n        # Test with unsafe md5 algorithm (should raise ValueError)\n        with self.assertRaises(ValueError):\n            compute_hash(\"md5\", b\"data\")\n    \n    def test_unsafe_sha1(self):\n        # Test with unsafe sha1 algorithm (should raise ValueError)\n        with self.assertRaises(ValueError):\n            compute_hash(\"sha1\", b\"data\")\n    \n    def test_available_but_unsafe_sha224(self):\n        # Test with available but unsafe sha224 (not in safe list)\n        with self.assertRaises(ValueError):\n            compute_hash(\"sha224\", b\"data\")\n    \n    def test_unavailable_algorithm(self):\n        # Test with non-existent algorithm\n        with self.assertRaises(ValueError):\n            compute_hash(\"non_existent_algorithm\", b\"data\")\n    \n    def test_non_bytes_input(self):\n        # Test with non-bytes input_data (should raise TypeError)\n        with self.assertRaises(TypeError):\n            compute_hash(\"sha256\", \"string data\")\n    \n    def test_non_string_algorithm(self):\n        # Test with non-string algorithm name (should raise TypeError)\n        with self.assertRaises(TypeError):\n            compute_hash(123, b\"data\")", "num_test_cases": 11, "task_id": "215318fb"}
