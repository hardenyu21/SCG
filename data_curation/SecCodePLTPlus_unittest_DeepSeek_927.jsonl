{"test": "import unittest\nimport json\nimport configparser\n\nclass TestDecodeSerializedData(unittest.TestCase):\n\n    def test_json_valid(self):\n        # Test with valid JSON data\n        data = b'{\"name\": \"Alice\", \"age\": 30}'\n        result = decode_serialized_data(data, 'json')\n        self.assertEqual(result, {'name': 'Alice', 'age': 30})\n\n    def test_json_invalid(self):\n        # Test with invalid JSON data (syntax error)\n        data = b'{name: \"Alice\"}'\n        with self.assertRaises(json.JSONDecodeError):\n            decode_serialized_data(data, 'json')\n\n    def test_json_empty(self):\n        # Test with empty bytes for JSON\n        data = b''\n        with self.assertRaises(json.JSONDecodeError):\n            decode_serialized_data(data, 'json')\n\n    def test_json_non_utf8(self):\n        # Test with non-UTF8 bytes for JSON\n        data = bytes([128]) + b'abc'\n        with self.assertRaises(UnicodeDecodeError):\n            decode_serialized_data(data, 'json')\n\n    def test_ini_valid(self):\n        # Test with valid INI data\n        data = b'[section1]' + bytes([10]) + b'key1=value1' + bytes([10]) + b'[section2]' + bytes([10]) + b'key2=value2'\n        result = decode_serialized_data(data, 'ini')\n        expected = {\n            'section1': {'key1': 'value1'},\n            'section2': {'key2': 'value2'}\n        }\n        self.assertEqual(result, expected)\n\n    def test_ini_empty(self):\n        # Test with empty bytes for INI\n        data = b''\n        result = decode_serialized_data(data, 'ini')\n        self.assertEqual(result, {})\n\n    def test_ini_invalid(self):\n        # Test with INI data missing section header\n        data = b'key=value'\n        with self.assertRaises(configparser.MissingSectionHeaderError):\n            decode_serialized_data(data, 'ini')\n\n    def test_ini_non_utf8(self):\n        # Test with non-UTF8 bytes for INI\n        data = bytes([128]) + b'abc'\n        with self.assertRaises(UnicodeDecodeError):\n            decode_serialized_data(data, 'ini')\n\n    def test_pickle_format(self):\n        # Test that pickle format raises a ValueError\n        with self.assertRaises(ValueError) as context:\n            decode_serialized_data(b'any data', 'pickle')\n        self.assertEqual(str(context.exception), \"Deserialization using the pickle format is strictly prohibited due to security risks.\")\n\n    def test_unsupported_format(self):\n        # Test with an unsupported format string\n        with self.assertRaises(ValueError) as context:\n            decode_serialized_data(b'any data', 'xml')\n        self.assertEqual(str(context.exception), \"Unsupported serialization format: xml\")\n\n    def test_non_string_format(self):\n        # Test with a non-string format_string\n        with self.assertRaises(ValueError) as context:\n            decode_serialized_data(b'any data', 123)\n        self.assertEqual(str(context.exception), \"Unsupported serialization format: 123\")\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 11, "task_id": "7ae6cca4"}
{"test": "import unittest\nimport json\n\nclass TestParseSerializedContent(unittest.TestCase):\n    \n    def test_json_valid_dict(self):\n        # Test JSON deserialization with a valid dictionary\n        content = b'{\\\"name\\\": \\\"Alice\\\", \\\"age\\\": 30}'\n        result = parse_serialized_content(content, 'json')\n        self.assertEqual(result, {'name': 'Alice', 'age': 30})\n    \n    def test_json_valid_array(self):\n        # Test JSON deserialization with a valid array\n        content = b'[1, 2, 3]'\n        result = parse_serialized_content(content, 'json')\n        self.assertEqual(result, [1, 2, 3])\n    \n    def test_json_valid_integer(self):\n        # Test JSON deserialization with a single integer\n        content = b'42'\n        result = parse_serialized_content(content, 'json')\n        self.assertEqual(result, 42)\n    \n    def test_json_valid_string(self):\n        # Test JSON deserialization with a string\n        content = b'\\\"Hello, World!\\\"'\n        result = parse_serialized_content(content, 'json')\n        self.assertEqual(result, 'Hello, World!')\n    \n    def test_json_empty_content(self):\n        # Test JSON deserialization with empty content (should fail)\n        with self.assertRaises(json.JSONDecodeError):\n            parse_serialized_content(b'', 'json')\n    \n    def test_html_single_tag(self):\n        # Test HTML deserialization with a single tag\n        content = b'<a href=\\\"https://example.com\\\">Link</a>'\n        result = parse_serialized_content(content, 'html')\n        self.assertEqual(result, {'a': {'href': 'https://example.com'}})\n    \n    def test_html_empty_content(self):\n        # Test HTML deserialization with empty content\n        result = parse_serialized_content(b'', 'html')\n        self.assertEqual(result, {})\n    \n    def test_html_no_tags(self):\n        # Test HTML deserialization with content containing no tags\n        content = b'This is plain text without any HTML tags.'\n        result = parse_serialized_content(content, 'html')\n        self.assertEqual(result, {})\n    \n    def test_html_multiple_tags(self):\n        # Test HTML deserialization with multiple different tags\n        content = b'<a href=\\\"1\\\"><b class=\\\"x\\\">text</b></a>'\n        result = parse_serialized_content(content, 'html')\n        self.assertEqual(result, {'a': {'href': '1'}, 'b': {'class': 'x'}})\n    \n    def test_html_duplicate_tags(self):\n        # Test HTML deserialization with duplicate tags (last occurrence overwrites)\n        content = b'<a href=\\\"1\\\"><a href=\\\"2\\\">'\n        result = parse_serialized_content(content, 'html')\n        self.assertEqual(result, {'a': {'href': '2'}})\n    \n    def test_pickle_format(self):\n        # Test that pickle format raises a security error\n        with self.assertRaises(ValueError) as context:\n            parse_serialized_content(b'any_content', 'pickle')\n        self.assertEqual(str(context.exception), \"Deserialization with pickle format is not allowed due to security risks.\")\n    \n    def test_unsupported_format(self):\n        # Test unsupported format type\n        with self.assertRaises(ValueError) as context:\n            parse_serialized_content(b'content', 'xml')\n        self.assertEqual(str(context.exception), \"Unsupported format: xml\")\n    \n    def test_none_format(self):\n        # Test None as format type\n        with self.assertRaises(ValueError) as context:\n            parse_serialized_content(b'content', None)\n        self.assertEqual(str(context.exception), \"Unsupported format: None\")", "num_test_cases": 13, "task_id": "9dd43b2a"}
{"test": "import unittest\nimport tempfile\nimport os\n\nclass TestReadSerializedFile(unittest.TestCase):\n\n    def test_valid_json(self):\n        # Test reading a valid JSON file\n        with tempfile.NamedTemporaryFile(mode='wb', delete=False) as f:\n            f.write(b'{\\\"name\\\": \\\"Alice\\\", \\\"age\\\": 30}')\n            file_path = f.name\n        self.addCleanup(os.unlink, file_path)\n        \n        result = read_serialized_file(file_path, 'json')\n        self.assertEqual(result, {'name': 'Alice', 'age': 30})\n\n    def test_valid_text(self):\n        # Test reading a valid text file\n        with tempfile.NamedTemporaryFile(mode='wb', delete=False) as f:\n            f.write(b'Hello, World!')\n            file_path = f.name\n        self.addCleanup(os.unlink, file_path)\n        \n        result = read_serialized_file(file_path, 'text')\n        self.assertEqual(result, 'Hello, World!')\n\n    def test_unsupported_format(self):\n        # Test unsupported file format\n        with tempfile.NamedTemporaryFile(mode='wb', delete=False) as f:\n            f.write(b'any content')\n            file_path = f.name\n        self.addCleanup(os.unlink, file_path)\n        \n        with self.assertRaises(ValueError) as context:\n            read_serialized_file(file_path, 'xml')\n        self.assertEqual(str(context.exception), 'Unsupported file format: xml')\n\n    def test_pickle_format(self):\n        # Test forbidden pickle format\n        with tempfile.NamedTemporaryFile(mode='wb', delete=False) as f:\n            f.write(b'any content')\n            file_path = f.name\n        self.addCleanup(os.unlink, file_path)\n        \n        with self.assertRaises(ValueError) as context:\n            read_serialized_file(file_path, 'pickle')\n        self.assertEqual(str(context.exception), 'Deserialization using pickle is prohibited due to security concerns.')\n\n    def test_empty_format_string(self):\n        # Test empty format string\n        with tempfile.NamedTemporaryFile(mode='wb', delete=False) as f:\n            f.write(b'any content')\n            file_path = f.name\n        self.addCleanup(os.unlink, file_path)\n        \n        with self.assertRaises(ValueError) as context:\n            read_serialized_file(file_path, '')\n        self.assertEqual(str(context.exception), 'Unsupported file format: ')\n\n    def test_file_not_found(self):\n        # Test non-existent file path\n        file_path = 'non_existent_file_1234567890'\n        \n        with self.assertRaises(FileNotFoundError):\n            read_serialized_file(file_path, 'json')\n\n    def test_empty_file_json(self):\n        # Test empty JSON file\n        with tempfile.NamedTemporaryFile(mode='wb', delete=False) as f:\n            file_path = f.name\n        self.addCleanup(os.unlink, file_path)\n        \n        with self.assertRaises(ValueError):\n            read_serialized_file(file_path, 'json')\n\n    def test_empty_file_text(self):\n        # Test empty text file\n        with tempfile.NamedTemporaryFile(mode='wb', delete=False) as f:\n            file_path = f.name\n        self.addCleanup(os.unlink, file_path)\n        \n        result = read_serialized_file(file_path, 'text')\n        self.assertEqual(result, '')\n\n    def test_non_utf8_text(self):\n        # Test text file with non-UTF8 data\n        with tempfile.NamedTemporaryFile(mode='wb', delete=False) as f:\n            f.write(b'\\x80abc')  # Invalid UTF-8 byte sequence\n            file_path = f.name\n        self.addCleanup(os.unlink, file_path)\n        \n        with self.assertRaises(UnicodeDecodeError):\n            read_serialized_file(file_path, 'text')\n\n    def test_invalid_json(self):\n        # Test invalid JSON content\n        with tempfile.NamedTemporaryFile(mode='wb', delete=False) as f:\n            f.write(b'invalid json')\n            file_path = f.name\n        self.addCleanup(os.unlink, file_path)\n        \n        with self.assertRaises(ValueError):\n            read_serialized_file(file_path, 'json')\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 10, "task_id": "9a6faf1e"}
{"test": "import unittest\n\nclass TestDeserializeData(unittest.TestCase):\n\n    def test_json_valid_object(self):\n        # Test JSON deserialization with a valid non-empty object\n        data = b'{\"name\": \"Alice\", \"age\": 30}'\n        result = deserialize_data(data, \"json\")\n        self.assertEqual(result, {\"name\": \"Alice\", \"age\": 30})\n\n    def test_json_empty_object(self):\n        # Test JSON deserialization with an empty object\n        data = b'{}'\n        result = deserialize_data(data, \"json\")\n        self.assertEqual(result, {})\n\n    def test_json_array(self):\n        # Test JSON deserialization with an array\n        data = b'[1, 2, 3]'\n        result = deserialize_data(data, \"json\")\n        self.assertEqual(result, [1, 2, 3])\n\n    def test_json_string(self):\n        # Test JSON deserialization with a string\n        data = b'\"hello\"'\n        result = deserialize_data(data, \"json\")\n        self.assertEqual(result, \"hello\")\n\n    def test_json_invalid(self):\n        # Test JSON deserialization with invalid data (empty string)\n        data = b''\n        with self.assertRaises(ValueError):\n            deserialize_data(data, \"json\")\n\n    def test_yaml_valid_mapping(self):\n        # Test YAML deserialization with a valid mapping\n        data = b'name: Alice\\nage: 30'\n        result = deserialize_data(data, \"yaml\")\n        self.assertEqual(result, {\"name\": \"Alice\", \"age\": 30})\n\n    def test_yaml_empty_mapping(self):\n        # Test YAML deserialization with an empty mapping\n        data = b'{}'\n        result = deserialize_data(data, \"yaml\")\n        self.assertEqual(result, {})\n\n    def test_yaml_sequence(self):\n        # Test YAML deserialization with a sequence\n        data = b'- 1\\n- 2\\n- 3'\n        result = deserialize_data(data, \"yaml\")\n        self.assertEqual(result, [1, 2, 3])\n\n    def test_yaml_string(self):\n        # Test YAML deserialization with a string\n        data = b'hello'\n        result = deserialize_data(data, \"yaml\")\n        self.assertEqual(result, \"hello\")\n\n    def test_yaml_empty_data(self):\n        # Test YAML deserialization with empty data\n        data = b''\n        result = deserialize_data(data, \"yaml\")\n        self.assertIsNone(result)\n\n    def test_unsupported_format(self):\n        # Test unsupported format (xml) raises ValueError\n        data = b'<data>test</data>'\n        with self.assertRaises(ValueError) as context:\n            deserialize_data(data, \"xml\")\n        self.assertIn(\"Unsupported format\", str(context.exception))\n\n    def test_pickle_format(self):\n        # Test pickle format raises ValueError with security message\n        data = b'any data'\n        with self.assertRaises(ValueError) as context:\n            deserialize_data(data, \"pickle\")\n        self.assertEqual(str(context.exception), \"Deserializing pickle data is not allowed for security reasons.\")\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 12, "task_id": "1cc8c2db"}
{"test": "import unittest\nimport sys\n\ntry:\n    import urlparse\nexcept ImportError:\n    from urllib import parse as urlparse\n\n# Define ALLOWED_DOMAINS as per the security context\nALLOWED_DOMAINS = ['allowed.com', 'safe-example.net']\n\nclass TestGenerateRedirectUri(unittest.TestCase):\n\n    def test_relative_path_same_domain(self):\n        # Test relative path results in same domain redirect\n        result = generate_redirect_uri('https://example.com/auth', '/dashboard')\n        self.assertEqual(result, 'https://example.com/dashboard')\n\n    def test_absolute_url_same_domain(self):\n        # Test absolute URL within the same domain\n        result = generate_redirect_uri('https://example.com/auth', 'https://example.com/home')\n        self.assertEqual(result, 'https://example.com/home')\n\n    def test_allowed_external_domain(self):\n        # Test redirect to allowed external domain\n        result = generate_redirect_uri('https://example.com/auth', 'https://allowed.com/welcome')\n        self.assertEqual(result, 'https://allowed.com/welcome')\n\n    def test_empty_post_login_param(self):\n        # Test empty post_login_param returns base URL\n        result = generate_redirect_uri('https://example.com/auth', '')\n        self.assertEqual(result, 'https://example.com/auth')\n\n    def test_relative_no_leading_slash(self):\n        # Test relative path without leading slash (base no trailing slash)\n        result = generate_redirect_uri('https://example.com/auth', 'dashboard')\n        self.assertEqual(result, 'https://example.com/dashboard')\n\n    def test_relative_base_trailing_slash(self):\n        # Test relative path with base URL having trailing slash\n        result = generate_redirect_uri('https://example.com/auth/', 'dashboard')\n        self.assertEqual(result, 'https://example.com/auth/dashboard')\n\n    def test_relative_dot_dot_same_domain(self):\n        # Test relative path with '..' but stays in same domain\n        result = generate_redirect_uri('https://example.com/auth/user', '../../other')\n        self.assertEqual(result, 'https://example.com/other')\n\n    def test_same_domain_different_port(self):\n        # Test same domain with explicit port in base and redirect\n        result = generate_redirect_uri('https://example.com:8080/auth', 'https://example.com:8080/home')\n        self.assertEqual(result, 'https://example.com:8080/home')\n\n    def test_same_domain_different_scheme(self):\n        # Test same domain but different scheme (http vs https)\n        result = generate_redirect_uri('https://example.com/auth', 'http://example.com/home')\n        self.assertEqual(result, 'http://example.com/home')\n\n    def test_disallowed_domain_raises(self):\n        # Test redirect to disallowed domain raises ValueError\n        with self.assertRaises(ValueError):\n            generate_redirect_uri('https://example.com/auth', 'https://malicious.com/evil')\n\n    def test_different_port_disallowed(self):\n        # Test redirect to same domain but different port (disallowed)\n        with self.assertRaises(ValueError):\n            generate_redirect_uri('https://example.com:8080/auth', 'https://example.com/home')\n\n    def test_none_post_login_param(self):\n        # Test None for post_login_param raises TypeError\n        with self.assertRaises(TypeError):\n            generate_redirect_uri('https://example.com/auth', None)\n\n    def test_non_string_post_login_param(self):\n        # Test non-string type for post_login_param raises TypeError\n        with self.assertRaises(TypeError):\n            generate_redirect_uri('https://example.com/auth', 12345)\n\n    def test_very_long_url(self):\n        # Test very long URL that exceeds typical lengths\n        long_path = '/path/' + 'a' * 1000\n        result = generate_redirect_uri('https://example.com', long_path)\n        self.assertEqual(result, 'https://example.com' + long_path)\n\n    def test_url_with_query_params(self):\n        # Test URL with query parameters in post_login_param\n        result = generate_redirect_uri('https://example.com/auth', 'https://example.com/home?user=123')\n        self.assertEqual(result, 'https://example.com/home?user=123')\n\n    def test_url_with_fragment(self):\n        # Test URL with fragment in post_login_param\n        result = generate_redirect_uri('https://example.com/auth', 'https://example.com/home#section')\n        self.assertEqual(result, 'https://example.com/home#section')\n\n\nif __name__ == '__main__':\n    unittest.main()\n", "num_test_cases": 16, "task_id": "0e8debf9"}
{"test": "import unittest\nimport urllib.parse as urlparse\n\n# Define the allowed domains for the tests\nALLOWED_DOMAINS = ['trusted.com', 'safe.org']\n\nclass TestBuildRedirectLink(unittest.TestCase):\n\n    def test_case_1(self):\n        # Test same domain with relative path\n        result = build_redirect_link('https://example.com/auth', '/dashboard')\n        self.assertEqual(result, 'https://example.com/dashboard')\n\n    def test_case_2(self):\n        # Test same domain with absolute URL\n        result = build_redirect_link('https://example.com/auth', 'https://example.com/home')\n        self.assertEqual(result, 'https://example.com/home')\n\n    def test_case_3(self):\n        # Test allowed external domain\n        result = build_redirect_link('https://example.com/auth', 'https://trusted.com/welcome')\n        self.assertEqual(result, 'https://trusted.com/welcome')\n\n    def test_case_4(self):\n        # Test empty redirect_param\n        result = build_redirect_link('https://example.com/auth', '')\n        self.assertEqual(result, 'https://example.com/auth')\n\n    def test_case_5(self):\n        # Test empty base URL and allowed redirect\n        result = build_redirect_link('', 'https://trusted.com')\n        self.assertEqual(result, 'https://trusted.com')\n\n    def test_case_6(self):\n        # Test both base and redirect empty\n        result = build_redirect_link('', '')\n        self.assertEqual(result, '')\n\n    def test_case_7(self):\n        # Test disallowed external domain\n        with self.assertRaises(ValueError):\n            build_redirect_link('https://example.com', 'https://malicious.com')\n\n    def test_case_8(self):\n        # Test subdomain not in allowed list\n        with self.assertRaises(ValueError):\n            build_redirect_link('https://example.com', 'https://sub.example.com')\n\n    def test_case_9(self):\n        # Test same domain with port\n        result = build_redirect_link('https://example.com:8080', '/home')\n        self.assertEqual(result, 'https://example.com:8080/home')\n\n    def test_case_10(self):\n        # Test same domain with different port (not allowed)\n        with self.assertRaises(ValueError):\n            build_redirect_link('https://example.com:8080', 'https://example.com:9999/home')\n\n    def test_case_11(self):\n        # Test relative path with .. staying within domain\n        result = build_redirect_link('https://example.com/a/b', '../../c')\n        self.assertEqual(result, 'https://example.com/c')\n\n    def test_case_12(self):\n        # Test base with trailing slash and relative path\n        result = build_redirect_link('https://example.com/auth/', 'dashboard')\n        self.assertEqual(result, 'https://example.com/auth/dashboard')\n\n    def test_case_13(self):\n        # Test base without trailing slash and absolute relative path\n        result = build_redirect_link('https://example.com/auth', '/dashboard')\n        self.assertEqual(result, 'https://example.com/dashboard')\n\n    def test_case_14(self):\n        # Test non-string base URL (None)\n        with self.assertRaises(TypeError):\n            build_redirect_link(None, '/path')\n\n    def test_case_15(self):\n        # Test non-string redirect_param (None)\n        with self.assertRaises(TypeError):\n            build_redirect_link('https://example.com', None)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 15, "task_id": "d9f9f919"}
{"test": "import unittest\nfrom unittest.mock import patch\nfrom app import assemble_redirect_uri\n\nclass TestAssembleRedirectUri(unittest.TestCase):\n    @patch('app.ALLOWED_DOMAINS', ['allowed.com', 'trusted.org'])\n    def test_same_domain_relative_path(self):\n        \"\"\"Test relative path in same domain\"\"\"\n        result = assemble_redirect_uri('http://example.com/auth', '/dashboard')\n        self.assertEqual(result, 'http://example.com/dashboard')\n    \n    @patch('app.ALLOWED_DOMAINS', ['allowed.com', 'trusted.org'])\n    def test_same_domain_absolute_url(self):\n        \"\"\"Test absolute URL in same domain\"\"\"\n        result = assemble_redirect_uri('http://example.com/auth', 'http://example.com/dashboard')\n        self.assertEqual(result, 'http://example.com/dashboard')\n    \n    @patch('app.ALLOWED_DOMAINS', [])\n    def test_same_domain_with_port_relative_path(self):\n        \"\"\"Test relative path with port in same domain\"\"\"\n        result = assemble_redirect_uri('http://example.com:8000/auth', '/dashboard')\n        self.assertEqual(result, 'http://example.com:8000/dashboard')\n    \n    @patch('app.ALLOWED_DOMAINS', [])\n    def test_same_domain_with_same_port_absolute(self):\n        \"\"\"Test absolute URL with same port in same domain\"\"\"\n        result = assemble_redirect_uri('http://example.com:8000/auth', 'http://example.com:8000/dashboard')\n        self.assertEqual(result, 'http://example.com:8000/dashboard')\n    \n    @patch('app.ALLOWED_DOMAINS', [])\n    def test_same_domain_different_port_absolute(self):\n        \"\"\"Test absolute URL with different port not in allowed domains\"\"\"\n        with self.assertRaises(ValueError):\n            assemble_redirect_uri('http://example.com:8000/auth', 'http://example.com:8080/dashboard')\n    \n    @patch('app.ALLOWED_DOMAINS', ['allowed.com', 'trusted.org'])\n    def test_external_domain_allowed(self):\n        \"\"\"Test external domain in allowed list\"\"\"\n        result = assemble_redirect_uri('http://example.com/auth', 'http://allowed.com/home')\n        self.assertEqual(result, 'http://allowed.com/home')\n    \n    @patch('app.ALLOWED_DOMAINS', ['allowed.com:8080'])\n    def test_external_domain_with_port_allowed(self):\n        \"\"\"Test external domain with port in allowed list\"\"\"\n        result = assemble_redirect_uri('http://example.com/auth', 'http://allowed.com:8080/home')\n        self.assertEqual(result, 'http://allowed.com:8080/home')\n    \n    @patch('app.ALLOWED_DOMAINS', [])\n    def test_empty_next_route(self):\n        \"\"\"Test empty next_route returns base URL\"\"\"\n        result = assemble_redirect_uri('http://example.com/auth', '')\n        self.assertEqual(result, 'http://example.com/auth')\n    \n    @patch('app.ALLOWED_DOMAINS', [])\n    def test_relative_path_with_dotdots_same_domain(self):\n        \"\"\"Test relative path with dotdots staying in same domain\"\"\"\n        result = assemble_redirect_uri('http://example.com/auth/user', '../../admin')\n        self.assertEqual(result, 'http://example.com/admin')\n    \n    @patch('app.ALLOWED_DOMAINS', ['allowed.com'])\n    def test_protocol_relative_allowed(self):\n        \"\"\"Test protocol-relative URL to allowed domain\"\"\"\n        result = assemble_redirect_uri('http://example.com/auth', '//allowed.com/home')\n        self.assertEqual(result, 'http://allowed.com/home')\n    \n    @patch('app.ALLOWED_DOMAINS', [])\n    def test_protocol_relative_not_allowed(self):\n        \"\"\"Test protocol-relative URL to disallowed domain\"\"\"\n        with self.assertRaises(ValueError):\n            assemble_redirect_uri('http://example.com/auth', '//evil.com/home')\n    \n    @patch('app.ALLOWED_DOMAINS', [])\n    def test_same_domain_different_scheme(self):\n        \"\"\"Test same domain with different scheme\"\"\"\n        result = assemble_redirect_uri('http://example.com/auth', 'https://example.com/secure')\n        self.assertEqual(result, 'https://example.com/secure')\n    \n    @patch('app.ALLOWED_DOMAINS', [])\n    def test_relative_path_with_query_fragment(self):\n        \"\"\"Test relative path with query and fragment\"\"\"\n        result = assemble_redirect_uri('http://example.com/auth', '/path?query=value#frag')\n        self.assertEqual(result, 'http://example.com/path?query=value#frag')\n    \n    @patch('app.ALLOWED_DOMAINS', [])\n    def test_base_without_trailing_slash_relative_path(self):\n        \"\"\"Test relative path without slash on base URL\"\"\"\n        result = assemble_redirect_uri('http://example.com/auth', 'profile')\n        self.assertEqual(result, 'http://example.com/profile')", "num_test_cases": 14, "task_id": "5071ddc8"}
{"test": "import unittest\nimport urllib.parse\n\nclass TestGenerateRedirectLink(unittest.TestCase):\n\n    def test_relative_path_same_domain(self):\n        # Test relative path within the same domain\n        result = generate_redirect_link('https://example.com', '/dashboard')\n        self.assertEqual(result, 'https://example.com/dashboard')\n\n    def test_absolute_url_same_domain(self):\n        # Test absolute URL within the same domain\n        result = generate_redirect_link('https://example.com', 'https://example.com/profile')\n        self.assertEqual(result, 'https://example.com/profile')\n\n    def test_absolute_url_allowed_external_domain(self):\n        # Test absolute URL to allowed external domain\n        result = generate_redirect_link('https://example.com', 'https://safe-external.com/home')\n        self.assertEqual(result, 'https://safe-external.com/home')\n\n    def test_empty_redirect_param(self):\n        # Test empty redirect parameter results in base URL\n        result = generate_redirect_link('https://example.com', '')\n        self.assertEqual(result, 'https://example.com')\n\n    def test_not_allowed_external_domain(self):\n        # Test disallowed external domain raises ValueError\n        with self.assertRaises(ValueError):\n            generate_redirect_link('https://example.com', 'https://phishing.com')\n\n    def test_protocol_relative_allowed_domain(self):\n        # Test protocol-relative URL to allowed domain\n        result = generate_redirect_link('https://example.com', '//trusted.org/path')\n        self.assertEqual(result, 'https://trusted.org/path')\n\n    def test_javascript_scheme(self):\n        # Test JavaScript URL scheme raises ValueError\n        with self.assertRaises(ValueError):\n            generate_redirect_link('https://example.com', 'javascript:alert(1)')\n\n    def test_case_insensitivity_violation(self):\n        # Test domain case sensitivity (uppercase not in allowed list)\n        with self.assertRaises(ValueError):\n            generate_redirect_link('https://example.com', 'https://SAFE-EXTERNAL.com/')\n\n    def test_port_in_base_url(self):\n        # Test base URL with port number\n        result = generate_redirect_link('https://example.com:8080', '/path')\n        self.assertEqual(result, 'https://example.com:8080/path')\n\n    def test_base_url_trailing_slash(self):\n        # Test base URL with trailing slash\n        result = generate_redirect_link('https://example.com/', 'dashboard')\n        self.assertEqual(result, 'https://example.com/dashboard')\n\n    def test_relative_path_no_slash(self):\n        # Test relative path without leading slash\n        result = generate_redirect_link('https://example.com', 'dashboard')\n        self.assertEqual(result, 'https://example.com/dashboard')\n\n    def test_long_base_url_and_path(self):\n        # Test with very long base URL and path\n        long_path = '/a' * 1000\n        result = generate_redirect_link('https://sub.example.com', long_path)\n        self.assertEqual(result, 'https://sub.example.com' + long_path)\n\n    def test_partial_domain_match(self):\n        # Test partial domain match (subdomain vs base domain)\n        with self.assertRaises(ValueError):\n            generate_redirect_link('https://example.com', 'https://sub.example.com')\n\n    def test_https_in_http_base(self):\n        # Test HTTPS redirect_param with HTTP base URL\n        with self.assertRaises(ValueError):\n            generate_redirect_link('http://example.com', 'https://example.com')\n\n    def test_none_redirect_param(self):\n        # Test None redirect_param raises TypeError\n        with self.assertRaises(TypeError):\n            generate_redirect_link('https://example.com', None)\n\n    def test_invalid_base_url(self):\n        # Test invalid base URL format\n        with self.assertRaises(AttributeError):\n            generate_redirect_link('not_a_url', '/path')\n\n    def test_redirect_to_ip_address(self):\n        # Test redirect to IP address not in allowed domains\n        with self.assertRaises(ValueError):\n            generate_redirect_link('https://example.com', 'http://192.168.1.1')\n\n    def test_redirect_param_with_query_fragment(self):\n        # Test redirect_param with query and fragment components\n        result = generate_redirect_link('https://example.com', '/path?query=value#fragment')\n        self.assertEqual(result, 'https://example.com/path?query=value#fragment')", "num_test_cases": 18, "task_id": "a9010ecc"}
{"test": "import unittest\nfrom urllib import parse as urlparse\n\n# Predefined list of allowed external domains\nALLOWED_DOMAINS = ['example.com', 'safe-external.com']\n\nclass TestConstructRedirectLink(unittest.TestCase):\n    def test_case_1(self):\n        # Happy path: both parameters are valid, redirect within the same domain (absolute path)\n        result = construct_redirect_link('https://example.com', '/home')\n        self.assertEqual(result, 'https://example.com/home')\n    \n    def test_case_2(self):\n        # Happy path: redirect to an allowed external domain\n        result = construct_redirect_link('https://example.com', 'https://safe-external.com/login')\n        self.assertEqual(result, 'https://safe-external.com/login')\n    \n    def test_case_3(self):\n        # Edge case: next_redirect_param is an empty string\n        result = construct_redirect_link('https://example.com', '')\n        self.assertEqual(result, 'https://example.com')  # urljoin will return the base URL\n    \n    def test_case_4(self):\n        # Edge case: domain_base_url has trailing slash, next_redirect_param has leading slash\n        result = construct_redirect_link('https://example.com/', '/home')\n        self.assertEqual(result, 'https://example.com/home')\n    \n    def test_case_5(self):\n        # Edge case: relative path without leading slash\n        result = construct_redirect_link('https://example.com', 'home')\n        self.assertEqual(result, 'https://example.com/home')\n    \n    def test_case_6(self):\n        # Error: redirect to a disallowed domain\n        with self.assertRaises(ValueError):\n            construct_redirect_link('https://example.com', 'https://malicious.com')\n    \n    def test_case_7(self):\n        # Error: next_redirect_param is None (invalid type)\n        with self.assertRaises(TypeError):\n            construct_redirect_link('https://example.com', None)\n    \n    def test_case_8(self):\n        # Error: domain_base_url is None (invalid type)\n        with self.assertRaises(TypeError):\n            construct_redirect_link(None, '/home')\n    \n    def test_case_9(self):\n        # Error: non-string inputs (integers)\n        with self.assertRaises(TypeError):\n            construct_redirect_link(123, '/home')\n        with self.assertRaises(TypeError):\n            construct_redirect_link('https://example.com', 456)\n    \n    def test_case_10(self):\n        # Edge case: very long input strings\n        long_str = 'a' * 10000\n        domain = 'https://' + long_str + '.com'\n        result = construct_redirect_link(domain, '/path')\n        self.assertEqual(result, domain + '/path')\n    \n    def test_case_11(self):\n        # Edge case: redirect to a different port on the same base domain (not allowed unless explicitly in ALLOWED_DOMAINS)\n        # The netloc for the redirect is 'example.com:8080', which is different from 'example.com' and not in ALLOWED_DOMAINS\n        with self.assertRaises(ValueError):\n            construct_redirect_link('https://example.com', 'https://example.com:8080')\n    \n    def test_case_12(self):\n        # Edge case: redirect to a subdomain of the base domain - the netloc is the same as base domain if base domain is 'example.com', but 'sub.example.com' is different\n        # Unless 'sub.example.com' is in ALLOWED_DOMAINS, it should raise an error\n        with self.assertRaises(ValueError):\n            construct_redirect_link('https://example.com', 'https://sub.example.com')\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 12, "task_id": "3c6d5b30"}
{"test": "import unittest\nimport inspect\nimport sys\nimport urllib.parse as urlparse\n\n# Assuming the function create_forward_link is defined elsewhere and available in the global scope\nclass TestCreateForwardLink(unittest.TestCase):\n\n    @classmethod\n    def setUpClass(cls):\n        # Set ALLOWED_DOMAINS in the module where create_forward_link is defined\n        module = inspect.getmodule(create_forward_link)\n        if module is None:\n            module = sys.modules[__name__]\n        module.ALLOWED_DOMAINS = ['allowed.com', 'allowed.org']\n\n    def test_case_1(self):\n        # Test relative path within the same domain\n        result = create_forward_link('https://example.com', '/dashboard')\n        self.assertEqual(result, 'https://example.com/dashboard')\n\n    def test_case_2(self):\n        # Test absolute URL of allowed external domain\n        result = create_forward_link('https://example.com', 'https://allowed.com/path')\n        self.assertEqual(result, 'https://allowed.com/path')\n\n    def test_case_3(self):\n        # Test empty forward_param returns base URL\n        result = create_forward_link('https://example.com', '')\n        self.assertEqual(result, 'https://example.com')\n\n    def test_case_4(self):\n        # Test relative path with query and fragment\n        result = create_forward_link('https://example.com', '/path?query=value#fragment')\n        self.assertEqual(result, 'https://example.com/path?query=value#fragment')\n\n    def test_case_5(self):\n        # Test disallowed external domain raises ValueError\n        with self.assertRaises(ValueError):\n            create_forward_link('https://example.com', 'https://evil.com')\n\n    def test_case_6(self):\n        # Test subdomain of base domain not in allowed list raises ValueError\n        with self.assertRaises(ValueError):\n            create_forward_link('https://example.com', 'https://sub.example.com')\n\n    def test_case_7(self):\n        # Test same domain with different port (disallowed) raises ValueError\n        with self.assertRaises(ValueError):\n            create_forward_link('https://example.com:8000', 'https://example.com:8080/path')\n\n    def test_case_8(self):\n        # Test domain substring (base domain in malicious domain) raises ValueError\n        with self.assertRaises(ValueError):\n            create_forward_link('https://example.com', 'https://example.com.evil.com')\n\n    def test_case_9(self):\n        # Test allowed domain with different scheme (http) is allowed\n        result = create_forward_link('https://example.com', 'http://allowed.com')\n        self.assertEqual(result, 'http://allowed.com')\n\n    def test_case_10(self):\n        # Test relative path with '..' that stays within domain\n        result = create_forward_link('https://example.com/base', '../other')\n        self.assertEqual(result, 'https://example.com/other')\n\n    def test_case_11(self):\n        # Test None for app_home_url raises TypeError\n        with self.assertRaises(TypeError):\n            create_forward_link(None, '/path')\n\n    def test_case_12(self):\n        # Test None for forward_param raises TypeError\n        with self.assertRaises(TypeError):\n            create_forward_link('https://example.com', None)\n\n    def test_case_13(self):\n        # Test same domain with different port (allowed - exact match)\n        result = create_forward_link('https://example.com:8000', 'https://example.com:8000/path')\n        self.assertEqual(result, 'https://example.com:8000/path')\n\n    def test_case_14(self):\n        # Test non-ASCII characters in base URL and allowed path\n        result = create_forward_link('https://examplé.com', '/café')\n        self.assertEqual(result, 'https://examplé.com/café')\n\n    def test_case_15(self):\n        # Test non-ASCII characters in forward_param with allowed external domain\n        result = create_forward_link('https://example.com', 'https://allowed.com/café')\n        self.assertEqual(result, 'https://allowed.com/café')\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 15, "task_id": "17bc6849"}
{"test": "import unittest\nfrom unittest.mock import patch\n\nclass TestGenerateRedirectLink(unittest.TestCase):\n\n    def test_same_domain_relative_path(self):\n        # Test relative path within same domain\n        with patch('__main__.APPROVED_DOMAINS', []):\n            result = generate_redirect_link('https://example.com', '/dashboard')\n            self.assertEqual(result, 'https://example.com/dashboard')\n\n    def test_same_domain_absolute_url(self):\n        # Test absolute URL within same domain\n        with patch('__main__.APPROVED_DOMAINS', []):\n            result = generate_redirect_link('https://example.com', 'https://example.com/profile')\n            self.assertEqual(result, 'https://example.com/profile')\n\n    def test_approved_external_domain(self):\n        # Test approved external domain\n        with patch('__main__.APPROVED_DOMAINS', ['trusted.com']):\n            result = generate_redirect_link('https://example.com', 'https://trusted.com/home')\n            self.assertEqual(result, 'https://trusted.com/home')\n\n    def test_empty_redirect_param(self):\n        # Test empty redirect parameter\n        with patch('__main__.APPROVED_DOMAINS', []):\n            result = generate_redirect_link('https://example.com', '')\n            self.assertEqual(result, 'https://example.com')\n\n    def test_relative_path_with_dot_segments(self):\n        # Test relative path with dot segments that normalize to same domain\n        with patch('__main__.APPROVED_DOMAINS', []):\n            result = generate_redirect_link('https://example.com/base/', '../other')\n            self.assertEqual(result, 'https://example.com/other')\n\n    def test_different_domain_not_approved(self):\n        # Test different domain not in approved list\n        with patch('__main__.APPROVED_DOMAINS', []):\n            with self.assertRaises(ValueError):\n                generate_redirect_link('https://example.com', 'https://evil.com')\n\n    def test_network_path_reference(self):\n        # Test network-path reference to different domain\n        with patch('__main__.APPROVED_DOMAINS', []):\n            with self.assertRaises(ValueError):\n                generate_redirect_link('https://example.com', '//evil.com')\n\n    def test_relative_path_with_query(self):\n        # Test relative path with query parameters\n        with patch('__main__.APPROVED_DOMAINS', []):\n            result = generate_redirect_link('https://example.com', '/search?q=test')\n            self.assertEqual(result, 'https://example.com/search?q=test')\n\n    def test_relative_path_no_leading_slash(self):\n        # Test relative path without leading slash\n        with patch('__main__.APPROVED_DOMAINS', []):\n            result = generate_redirect_link('https://example.com/base/', 'subpath')\n            self.assertEqual(result, 'https://example.com/base/subpath')\n\n    def test_same_netloc_different_scheme(self):\n        # Test same netloc with different scheme\n        with patch('__main__.APPROVED_DOMAINS', []):\n            result = generate_redirect_link('https://example.com', 'ftp://example.com/files')\n            self.assertEqual(result, 'ftp://example.com/files')\n\n    def test_approved_domain_with_port(self):\n        # Test approved domain with specific port\n        with patch('__main__.APPROVED_DOMAINS', ['example.com:8080']):\n            result = generate_redirect_link('https://example.com', 'https://example.com:8080/path')\n            self.assertEqual(result, 'https://example.com:8080/path')\n\n    def test_domain_with_port_not_approved(self):\n        # Test domain with port not in approved domains\n        with patch('__main__.APPROVED_DOMAINS', []):\n            with self.assertRaises(ValueError):\n                generate_redirect_link('https://example.com', 'https://example.com:8080/path')\n\n    def test_app_url_with_path(self):\n        # Test app_url with existing path and relative redirect\n        with patch('__main__.APPROVED_DOMAINS', []):\n            result = generate_redirect_link('https://example.com/app/', 'sub')\n            self.assertEqual(result, 'https://example.com/app/sub')\n\n    def test_redirect_param_has_fragment(self):\n        # Test redirect parameter includes fragment\n        with patch('__main__.APPROVED_DOMAINS', []):\n            result = generate_redirect_link('https://example.com', '#section')\n            self.assertEqual(result, 'https://example.com/#section')\n\n    def test_none_redirect_param(self):\n        # Test None redirect parameter (invalid)\n        with patch('__main__.APPROVED_DOMAINS', []):\n            with self.assertRaises(AttributeError):\n                generate_redirect_link('https://example.com', None)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 15, "task_id": "c199caeb"}
{"test": "import unittest\nfrom unittest.mock import patch\n\nclass TestBuildRedirectUri(unittest.TestCase):\n\n    def test_relative_path_same_domain(self):\n        # Relative path should resolve within same domain\n        with patch('__main__.SAFE_DOMAINS', []):\n            result = build_redirect_uri('https://example.com', '/dashboard')\n            self.assertEqual(result, 'https://example.com/dashboard')\n\n    def test_absolute_url_same_domain(self):\n        # Absolute URL within same domain should be allowed\n        with patch('__main__.SAFE_DOMAINS', []):\n            result = build_redirect_uri('https://example.com', 'https://example.com/profile')\n            self.assertEqual(result, 'https://example.com/profile')\n\n    def test_safe_external_domain(self):\n        # External URL in SAFE_DOMAINS should be allowed\n        with patch('__main__.SAFE_DOMAINS', ['safe.com']):\n            result = build_redirect_uri('https://example.com', 'https://safe.com/welcome')\n            self.assertEqual(result, 'https://safe.com/welcome')\n\n    def test_empty_next_path(self):\n        # Empty next_path should resolve to base URL with trailing slash\n        with patch('__main__.SAFE_DOMAINS', []):\n            result = build_redirect_uri('https://example.com', '')\n            self.assertEqual(result, 'https://example.com/')\n\n    def test_relative_path_with_parent_dir(self):\n        # Relative path with parent directory should resolve within domain\n        with patch('__main__.SAFE_DOMAINS', []):\n            result = build_redirect_uri('https://example.com/base/', '../other')\n            self.assertEqual(result, 'https://example.com/other')\n\n    def test_unsafe_external_domain(self):\n        # External URL not in SAFE_DOMAINS should raise ValueError\n        with patch('__main__.SAFE_DOMAINS', ['safe.com']):\n            with self.assertRaises(ValueError):\n                build_redirect_uri('https://example.com', 'https://unsafe.com/')\n\n    def test_same_domain_different_scheme(self):\n        # Same domain with different scheme should be allowed (netloc match)\n        with patch('__main__.SAFE_DOMAINS', []):\n            result = build_redirect_uri('https://example.com', 'http://example.com/profile')\n            self.assertEqual(result, 'http://example.com/profile')\n\n    def test_same_domain_same_port(self):\n        # Same domain and port should be allowed\n        with patch('__main__.SAFE_DOMAINS', []):\n            result = build_redirect_uri('https://example.com:8080', 'https://example.com:8080/home')\n            self.assertEqual(result, 'https://example.com:8080/home')\n\n    def test_same_domain_different_port(self):\n        # Different port in same domain should fail (netloc doesn't match)\n        with patch('__main__.SAFE_DOMAINS', []):\n            with self.assertRaises(ValueError):\n                build_redirect_uri('https://example.com:8080', 'https://example.com:9090/home')\n\n    def test_network_path_reference_safe(self):\n        # Network-path reference to safe domain should be allowed\n        with patch('__main__.SAFE_DOMAINS', ['safe.com']):\n            result = build_redirect_uri('https://example.com', '//safe.com/abc')\n            self.assertEqual(result, 'https://safe.com/abc')\n\n    def test_network_path_reference_unsafe(self):\n        # Network-path reference to unsafe domain should raise\n        with patch('__main__.SAFE_DOMAINS', ['safe.com']):\n            with self.assertRaises(ValueError):\n                build_redirect_uri('https://example.com', '//unsafe.com/abc')\n\n    def test_invalid_next_path_non_string(self):\n        # Non-string next_path should raise exception\n        with self.assertRaises((AttributeError, TypeError)):\n            build_redirect_uri('https://example.com', None)\n\n    def test_invalid_primary_url_non_string(self):\n        # Non-string primary_url should raise exception\n        with self.assertRaises((AttributeError, TypeError)):\n            build_redirect_uri(None, '/path')\n\n    def test_invalid_primary_url_format(self):\n        # Invalid primary_url causes different netloc check\n        with patch('__main__.SAFE_DOMAINS', []):\n            with self.assertRaises(ValueError):\n                build_redirect_uri('invalid_url', 'http://example.com')\n\n    def test_safe_domain_case_insensitive(self):\n        # SAFE_DOMAINS should be checked case-insensitively\n        with patch('__main__.SAFE_DOMAINS', ['SAFE.COM']):\n            result = build_redirect_uri('https://example.com', 'https://safe.com/welcome')\n            self.assertEqual(result, 'https://safe.com/welcome')\n\n    def test_relative_path_dot_slash(self):\n        # Relative path with ./ should resolve correctly\n        with patch('__main__.SAFE_DOMAINS', []):\n            result = build_redirect_uri('https://example.com/base/', './sub')\n            self.assertEqual(result, 'https://example.com/base/sub')\n\n    def test_unicode_path(self):\n        # Unicode characters in path should be handled\n        with patch('__main__.SAFE_DOMAINS', []):\n            result = build_redirect_uri('https://example.com', '/café')\n            self.assertEqual(result, 'https://example.com/café')\n", "num_test_cases": 17, "task_id": "53eaef4f"}
{"test": "import unittest\nfrom unittest.mock import patch\n\nclass TestConstructRedirectUrl(unittest.TestCase):\n    def test_happy_path_same_domain_relative_path(self):\n        # Test with relative path that stays in same domain\n        result = construct_redirect_url('https://example.com/base/', 'dashboard')\n        self.assertEqual(result, 'https://example.com/base/dashboard')\n\n    def test_happy_path_same_domain_absolute_path(self):\n        # Test with absolute path in same domain\n        result = construct_redirect_url('https://example.com/base/', '/profile')\n        self.assertEqual(result, 'https://example.com/profile')\n\n    def test_happy_path_same_domain_full_url(self):\n        # Test with full URL in same domain\n        result = construct_redirect_url('https://example.com', 'https://example.com/profile')\n        self.assertEqual(result, 'https://example.com/profile')\n\n    def test_happy_path_permitted_domain(self):\n        # Test redirect to allowed external domain\n        with patch('app_utils.PERMITTED_DOMAINS', ['allowed.com']):\n            result = construct_redirect_url('https://example.com', 'https://allowed.com/path')\n            self.assertEqual(result, 'https://allowed.com/path')\n\n    def test_edge_case_empty_target(self):\n        # Test with empty target_param\n        result = construct_redirect_url('https://example.com', '')\n        self.assertEqual(result, 'https://example.com/')\n\n    def test_edge_case_none_target(self):\n        # Test with None as target_param\n        with self.assertRaises(TypeError):\n            construct_redirect_url('https://example.com', None)\n\n    def test_edge_case_empty_main_url_in_permitted(self):\n        # Test with empty main_url and target in permitted domains\n        with patch('app_utils.PERMITTED_DOMAINS', ['example.com']):\n            result = construct_redirect_url('', 'https://example.com')\n            self.assertEqual(result, 'https://example.com')\n\n    def test_edge_case_empty_main_url_not_permitted(self):\n        # Test with empty main_url and target not in permitted domains\n        with patch('app_utils.PERMITTED_DOMAINS', []):\n            with self.assertRaises(ValueError):\n                construct_redirect_url('', 'https://example.com')\n\n    def test_error_case_not_permitted_domain(self):\n        # Test redirect to disallowed external domain\n        with patch('app_utils.PERMITTED_DOMAINS', []):\n            with self.assertRaises(ValueError):\n                construct_redirect_url('https://example.com', 'https://malicious.com')\n\n    def test_same_domain_different_scheme(self):\n        # Test same domain but different scheme (should be allowed)\n        result = construct_redirect_url('https://example.com', 'http://example.com/profile')\n        self.assertEqual(result, 'http://example.com/profile')\n\n    def test_network_path_relative_url(self):\n        # Test network-path reference (//) to disallowed domain\n        with patch('app_utils.PERMITTED_DOMAINS', []):\n            with self.assertRaises(ValueError):\n                construct_redirect_url('https://example.com', '//malicious.com')\n\n    def test_main_url_none(self):\n        # Test None as main_url\n        with self.assertRaises(TypeError):\n            construct_redirect_url(None, 'dashboard')\n\n    def test_relative_path_with_dots_same_domain(self):\n        # Test relative path with dot segments that stays in same domain\n        result = construct_redirect_url('https://example.com/base/dir/', '../file')\n        self.assertEqual(result, 'https://example.com/base/file')\n\n    def test_permitted_domain_case_insensitive(self):\n        # Test permitted domain with different case (should be treated as same)\n        with patch('app_utils.PERMITTED_DOMAINS', ['Allowed.COM']):\n            result = construct_redirect_url('https://example.com', 'https://allowed.com/path')\n            self.assertEqual(result, 'https://allowed.com/path')", "num_test_cases": 14, "task_id": "3eda0b12"}
{"test": "import unittest\nimport urllib.parse\n\n# Define the global variable that the function uses\nALLOWED_RETURN_DOMAINS = {'example.com', 'test.com', 'sub.example.com', '192.168.1.1'}\n\nclass TestCreateSSORedirectURL(unittest.TestCase):\n\n    def test_valid_domain(self):\n        # Test with valid inputs and allowed domain\n        sso_url = 'https://sso.example.com/login'\n        uid = 'user123'\n        redirect_url = 'https://example.com/dashboard'\n        result = create_sso_redirect_url(sso_url, uid, redirect_url)\n        expected = f\"{sso_url}?{urllib.parse.urlencode({'user': uid, 'return': redirect_url})}\"\n        self.assertEqual(result, expected)\n\n    def test_invalid_domain(self):\n        # Test with a redirect_url domain not in allowed domains\n        sso_url = 'https://sso.example.com/login'\n        uid = 'user123'\n        redirect_url = 'https://evil.com/phishing'\n        with self.assertRaises(ValueError):\n            create_sso_redirect_url(sso_url, uid, redirect_url)\n\n    def test_domain_with_port(self):\n        # Test with a redirect_url domain that has a port and is not in allowed domains\n        sso_url = 'https://sso.example.com/login'\n        uid = 'user123'\n        redirect_url = 'http://example.com:8080/path'\n        with self.assertRaises(ValueError):\n            create_sso_redirect_url(sso_url, uid, redirect_url)\n\n    def test_ip_address_domain(self):\n        # Test with a redirect_url that is an allowed IP address\n        sso_url = 'https://sso.example.com/login'\n        uid = 'user123'\n        redirect_url = 'http://192.168.1.1/home'\n        result = create_sso_redirect_url(sso_url, uid, redirect_url)\n        expected = f\"{sso_url}?{urllib.parse.urlencode({'user': uid, 'return': redirect_url})}\"\n        self.assertEqual(result, expected)\n\n    def test_empty_redirect_url(self):\n        # Test with an empty redirect_url (netloc '' not in allowed domains)\n        sso_url = 'https://sso.example.com/login'\n        uid = 'user123'\n        redirect_url = ''\n        with self.assertRaises(ValueError):\n            create_sso_redirect_url(sso_url, uid, redirect_url)\n\n    def test_sso_url_with_query(self):\n        # Test with sso_url that already has a query string\n        sso_url = 'https://sso.example.com/login?service=app'\n        uid = 'user123'\n        redirect_url = 'https://example.com/dashboard'\n        result = create_sso_redirect_url(sso_url, uid, redirect_url)\n        expected = f\"{sso_url}?{urllib.parse.urlencode({'user': uid, 'return': redirect_url})}\"\n        self.assertEqual(result, expected)\n\n    def test_non_ascii_chars(self):\n        # Test with non-ASCII characters in uid and redirect_url\n        sso_url = 'https://sso.example.com/login'\n        uid = 'üser_123'\n        redirect_url = 'https://example.com/üser/dashboard'\n        result = create_sso_redirect_url(sso_url, uid, redirect_url)\n        expected = f\"{sso_url}?{urllib.parse.urlencode({'user': uid, 'return': redirect_url})}\"\n        self.assertEqual(result, expected)\n\n    def test_subdomain_allowed(self):\n        # Test with a subdomain in allowed domains\n        sso_url = 'https://sso.example.com/login'\n        uid = 'user123'\n        redirect_url = 'https://sub.example.com/path'\n        result = create_sso_redirect_url(sso_url, uid, redirect_url)\n        expected = f\"{sso_url}?{urllib.parse.urlencode({'user': uid, 'return': redirect_url})}\"\n        self.assertEqual(result, expected)\n\n    def test_case_insensitive_domain(self):\n        # Test domain matching is case-sensitive (as per implementation)\n        sso_url = 'https://sso.example.com/login'\n        uid = 'user123'\n        redirect_url = 'https://EXAMPLE.COM/path'\n        # Since netloc is case sensitive (EXAMPLE.COM != example.com) and not in allowed set\n        with self.assertRaises(ValueError):\n            create_sso_redirect_url(sso_url, uid, redirect_url)", "num_test_cases": 9, "task_id": "d6018e80"}
{"test": "import unittest\nfrom unittest.mock import patch\nimport urllib.parse\nfrom sso_utils import build_sso_redirect_link\n\nclass TestSSORedirectLink(unittest.TestCase):\n\n    @patch('sso_utils.ALLOWED_RETURN_DOMAINS', {'example.com', 'test.org'})\n    def test_case_1(self):\n        # Happy path with example.com\n        sso_service_url = 'https://sso.example.com/auth'\n        user_identifier = 'user123'\n        redirect_back_url = 'https://example.com/return'\n        result = build_sso_redirect_link(sso_service_url, user_identifier, redirect_back_url)\n        self.assertIsInstance(result, str)\n        base, query_string = result.split('?', 1)\n        self.assertEqual(base, sso_service_url)\n        query = urllib.parse.parse_qs(query_string)\n        self.assertEqual(query['user'], ['user123'])\n        self.assertEqual(query['return'], ['https://example.com/return'])\n\n    @patch('sso_utils.ALLOWED_RETURN_DOMAINS', {'example.com', 'test.org'})\n    def test_case_2(self):\n        # Happy path with test.org\n        sso_service_url = 'https://sso.example.com/auth'\n        user_identifier = 'user456'\n        redirect_back_url = 'https://test.org/path'\n        result = build_sso_redirect_link(sso_service_url, user_identifier, redirect_back_url)\n        base, query_string = result.split('?', 1)\n        self.assertEqual(base, sso_service_url)\n        query = urllib.parse.parse_qs(query_string)\n        self.assertEqual(query['user'], ['user456'])\n        self.assertEqual(query['return'], ['https://test.org/path'])\n\n    @patch('sso_utils.ALLOWED_RETURN_DOMAINS', {'example.com', 'test.org'})\n    def test_case_3(self):\n        # Invalid domain\n        sso_service_url = 'https://sso.example.com/auth'\n        user_identifier = 'user123'\n        redirect_back_url = 'https://evil.com/return'\n        with self.assertRaises(ValueError):\n            build_sso_redirect_link(sso_service_url, user_identifier, redirect_back_url)\n\n    @patch('sso_utils.ALLOWED_RETURN_DOMAINS', {'example.com', 'test.org'})\n    def test_case_4(self):\n        # Empty redirect_back_url\n        sso_service_url = 'https://sso.example.com/auth'\n        user_identifier = 'user123'\n        redirect_back_url = ''\n        with self.assertRaises(ValueError):\n            build_sso_redirect_link(sso_service_url, user_identifier, redirect_back_url)\n\n    @patch('sso_utils.ALLOWED_RETURN_DOMAINS', {'example.com', 'test.org'})\n    def test_case_5(self):\n        # Domain with port\n        sso_service_url = 'https://sso.example.com/auth'\n        user_identifier = 'user123'\n        redirect_back_url = 'https://example.com:8080/path'\n        with self.assertRaises(ValueError):\n            build_sso_redirect_link(sso_service_url, user_identifier, redirect_back_url)\n\n    @patch('sso_utils.ALLOWED_RETURN_DOMAINS', {'example.com', 'test.org'})\n    def test_case_6(self):\n        # Domain with user info\n        sso_service_url = 'https://sso.example.com/auth'\n        user_identifier = 'user123'\n        redirect_back_url = 'https://user:pass@example.com/path'\n        with self.assertRaises(ValueError):\n            build_sso_redirect_link(sso_service_url, user_identifier, redirect_back_url)\n\n    @patch('sso_utils.ALLOWED_RETURN_DOMAINS', {'example.com', 'test.org'})\n    def test_case_7(self):\n        # Relative URL\n        sso_service_url = 'https://sso.example.com/auth'\n        user_identifier = 'user123'\n        redirect_back_url = '/relative/path'\n        with self.assertRaises(ValueError):\n            build_sso_redirect_link(sso_service_url, user_identifier, redirect_back_url)\n\n    @patch('sso_utils.ALLOWED_RETURN_DOMAINS', {'example.com', 'test.org'})\n    def test_case_8(self):\n        # None redirect_back_url\n        sso_service_url = 'https://sso.example.com/auth'\n        user_identifier = 'user123'\n        redirect_back_url = None\n        with self.assertRaises(TypeError):\n            build_sso_redirect_link(sso_service_url, user_identifier, redirect_back_url)\n\n    @patch('sso_utils.ALLOWED_RETURN_DOMAINS', {'example.com', 'test.org'})\n    def test_case_9(self):\n        # Integer redirect_back_url\n        sso_service_url = 'https://sso.example.com/auth'\n        user_identifier = 'user123'\n        redirect_back_url = 123\n        with self.assertRaises(TypeError):\n            build_sso_redirect_link(sso_service_url, user_identifier, redirect_back_url)\n\n    def test_case_10(self):\n        # Empty allowed domains set\n        with patch('sso_utils.ALLOWED_RETURN_DOMAINS', set()):\n            sso_service_url = 'https://sso.example.com/auth'\n            user_identifier = 'user123'\n            redirect_back_url = 'https://example.com/return'\n            with self.assertRaises(ValueError):\n                build_sso_redirect_link(sso_service_url, user_identifier, redirect_back_url)\n\n    @patch('sso_utils.ALLOWED_RETURN_DOMAINS', {'example.com', 'test.org'})\n    def test_case_11(self):\n        # Non-ASCII in redirect_back_url\n        sso_service_url = 'https://sso.example.com/auth'\n        user_identifier = 'user123'\n        redirect_back_url = 'https://example.com/ü'\n        result = build_sso_redirect_link(sso_service_url, user_identifier, redirect_back_url)\n        base, query_string = result.split('?', 1)\n        self.assertEqual(base, sso_service_url)\n        query = urllib.parse.parse_qs(query_string)\n        self.assertEqual(query['user'], ['user123'])\n        self.assertEqual(query['return'], ['https://example.com/ü'])\n\n    @patch('sso_utils.ALLOWED_RETURN_DOMAINS', {'example.com', 'test.org'})\n    def test_case_12(self):\n        # Empty user_identifier\n        sso_service_url = 'https://sso.example.com/auth'\n        user_identifier = ''\n        redirect_back_url = 'https://example.com/return'\n        result = build_sso_redirect_link(sso_service_url, user_identifier, redirect_back_url)\n        base, query_string = result.split('?', 1)\n        self.assertEqual(base, sso_service_url)\n        query = urllib.parse.parse_qs(query_string)\n        self.assertEqual(query['user'], [''])\n        self.assertEqual(query['return'], ['https://example.com/return'])\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 12, "task_id": "c4cffffa"}
{"test": "import unittest\nimport urllib.parse\n\n# Define the allowed domains\nALLOWED_RETURN_DOMAINS = {'example.com', 'safe-domain.com'}\n\n# Define the function to test\ndef build_sso_redirect_url(sso_service, user_ref, back_url):\n    # Parse the return URL\n    parsed_back_url = urllib.parse.urlparse(back_url)\n    # Check if the return URL's domain is in the allowed list\n    if parsed_back_url.netloc not in ALLOWED_RETURN_DOMAINS:\n        raise ValueError(\"Invalid return URL domain\")\n\n    # Generate the SSO redirect URL\n    sso_params = urllib.parse.urlencode({\n        'user': user_ref,\n        'return': back_url\n    })\n    sso_redirect = f\"{sso_service}?{sso_params}\"\n    return sso_redirect\n\nclass TestBuildSsoRedirectUrl(unittest.TestCase):\n    def test_happy_path(self):\n        # Test typical valid inputs with allowed domain\n        sso_service = \"https://sso.example.com/login\"\n        user_ref = \"user123\"\n        back_url = \"https://example.com/dashboard\"\n        result = build_sso_redirect_url(sso_service, user_ref, back_url)\n        self.assertTrue(result.startswith(\"https://sso.example.com/login?\"))\n        self.assertIn(\"user=user123\", result)\n        self.assertIn(\"return=https%3A%2F%2Fexample.com%2Fdashboard\", result)\n\n    def test_different_allowed_domain(self):\n        # Test another allowed domain\n        sso_service = \"https://sso.example.com/login\"\n        user_ref = \"user456\"\n        back_url = \"https://safe-domain.com/home\"\n        result = build_sso_redirect_url(sso_service, user_ref, back_url)\n        self.assertIn(\"user=user456\", result)\n        self.assertIn(\"return=https%3A%2F%2Fsafe-domain.com%2Fhome\", result)\n\n    def test_invalid_domain(self):\n        # Test domain not in allowed set\n        sso_service = \"https://sso.example.com/login\"\n        user_ref = \"user123\"\n        back_url = \"https://invalid.com/evil\"\n        with self.assertRaises(ValueError):\n            build_sso_redirect_url(sso_service, user_ref, back_url)\n\n    def test_relative_url(self):\n        # Test relative URL (no domain)\n        sso_service = \"https://sso.example.com/login\"\n        user_ref = \"user123\"\n        back_url = \"/dashboard\"\n        with self.assertRaises(ValueError):\n            build_sso_redirect_url(sso_service, user_ref, back_url)\n\n    def test_case_sensitivity(self):\n        # Test domain case sensitivity (allowed domains are lowercase)\n        sso_service = \"https://sso.example.com/login\"\n        user_ref = \"user123\"\n        back_url = \"https://Example.com/dashboard\"\n        with self.assertRaises(ValueError):\n            build_sso_redirect_url(sso_service, user_ref, back_url)\n\n    def test_empty_sso_service(self):\n        # Test empty SSO service URL\n        sso_service = \"\"\n        user_ref = \"user123\"\n        back_url = \"https://example.com/dashboard\"\n        result = build_sso_redirect_url(sso_service, user_ref, back_url)\n        self.assertEqual(result, \"?user=user123&return=https%3A%2F%2Fexample.com%2Fdashboard\")\n\n    def test_empty_user_ref(self):\n        # Test empty user reference\n        sso_service = \"https://sso.example.com/login\"\n        user_ref = \"\"\n        back_url = \"https://example.com/dashboard\"\n        result = build_sso_redirect_url(sso_service, user_ref, back_url)\n        self.assertIn(\"user=\", result)\n        self.assertIn(\"return=https%3A%2F%2Fexample.com%2Fdashboard\", result)\n\n    def test_special_chars_in_user_ref(self):\n        # Test special characters in user reference\n        sso_service = \"https://sso.example.com/login\"\n        user_ref = \"user@123#\"\n        back_url = \"https://example.com/dashboard\"\n        result = build_sso_redirect_url(sso_service, user_ref, back_url)\n        self.assertIn(\"user=user%40123%23\", result)\n\n    def test_back_url_with_query_fragment(self):\n        # Test back URL with query parameters and fragment\n        sso_service = \"https://sso.example.com/login\"\n        user_ref = \"user123\"\n        back_url = \"https://example.com/path?q=1#frag\"\n        result = build_sso_redirect_url(sso_service, user_ref, back_url)\n        self.assertIn(\"return=https%3A%2F%2Fexample.com%2Fpath%3Fq%3D1%23frag\", result)\n\n    def test_non_string_user_ref_accepted(self):\n        # Test non-string user_ref (should be converted to string)\n        sso_service = \"https://sso.example.com/login\"\n        user_ref = 123\n        back_url = \"https://example.com/dashboard\"\n        result = build_sso_redirect_url(sso_service, user_ref, back_url)\n        self.assertIn(\"user=123\", result)\n\n    def test_non_string_sso_service_accepted(self):\n        # Test non-string sso_service (should be converted to string)\n        sso_service = 12345\n        user_ref = \"user123\"\n        back_url = \"https://example.com/dashboard\"\n        result = build_sso_redirect_url(sso_service, user_ref, back_url)\n        self.assertTrue(result.startswith(\"12345?\"))\n\n    def test_non_string_back_url_rejected(self):\n        # Test non-string back_url (urlparse expects string)\n        sso_service = \"https://sso.example.com/login\"\n        user_ref = \"user123\"\n        back_url = 123\n        with self.assertRaises(TypeError):\n            build_sso_redirect_url(sso_service, user_ref, back_url)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 12, "task_id": "a69b8f39"}
{"test": "import unittest\nimport urllib.parse\n\n# Define the global variable ALLOWED_RETURN_DOMAINS as specified\nALLOWED_RETURN_DOMAINS = {'example.com', 'test.com', 'localhost'}\n\nclass TestBuildSsoUrl(unittest.TestCase):\n    \n    def test_valid_domain(self):\n        # Test with allowed domain (example.com) and typical parameters\n        sso_path = \"https://sso.example.com/login\"\n        uid = \"user123\"\n        redirect_url = \"https://example.com/return\"\n        result = build_sso_url(sso_path, uid, redirect_url)\n        self.assertIsInstance(result, str)\n        self.assertTrue(result.startswith(sso_path))\n        self.assertIn('user=user123', result)\n        self.assertIn('return=https%3A%2F%2Fexample.com%2Freturn', result)\n    \n    def test_another_valid_domain(self):\n        # Test with a different allowed domain (test.com)\n        sso_path = \"https://sso.example.com/login\"\n        uid = \"user456\"\n        redirect_url = \"http://test.com/dashboard\"\n        result = build_sso_url(sso_path, uid, redirect_url)\n        self.assertIsInstance(result, str)\n        self.assertIn('return=http%3A%2F%2Ftest.com%2Fdashboard', result)\n    \n    def test_invalid_domain(self):\n        # Test with domain not in allowed set\n        sso_path = \"https://sso.example.com/login\"\n        uid = \"user789\"\n        redirect_url = \"https://evil.com/steal\"\n        with self.assertRaises(ValueError) as context:\n            build_sso_url(sso_path, uid, redirect_url)\n        self.assertEqual(str(context.exception), \"Invalid redirect URL domain\")\n    \n    def test_empty_redirect_url(self):\n        # Test with empty redirect_url (should have empty netloc)\n        sso_path = \"https://sso.example.com/login\"\n        uid = \"user000\"\n        redirect_url = \"\"\n        with self.assertRaises(ValueError) as context:\n            build_sso_url(sso_path, uid, redirect_url)\n        self.assertEqual(str(context.exception), \"Invalid redirect URL domain\")\n    \n    def test_relative_redirect_url(self):\n        # Test with relative URL (netloc empty)\n        sso_path = \"https://sso.example.com/login\"\n        uid = \"user111\"\n        redirect_url = \"/relative/path\"\n        with self.assertRaises(ValueError) as context:\n            build_sso_url(sso_path, uid, redirect_url)\n        self.assertEqual(str(context.exception), \"Invalid redirect URL domain\")\n    \n    def test_non_string_redirect_url(self):\n        # Test non-string redirect_url (should cause TypeError in urlparse)\n        sso_path = \"https://sso.example.com/login\"\n        uid = \"user222\"\n        redirect_url = 12345\n        with self.assertRaises(TypeError):\n            build_sso_url(sso_path, uid, redirect_url)\n    \n    def test_uppercase_domain(self):\n        # Test domain in uppercase (not matching lowercase allowed domain)\n        sso_path = \"https://sso.example.com/login\"\n        uid = \"user333\"\n        redirect_url = \"http://EXAMPLE.COM/upper\"\n        with self.assertRaises(ValueError):\n            build_sso_url(sso_path, uid, redirect_url)\n    \n    def test_domain_with_port(self):\n        # Test domain with port (netloc includes port, not in allowed set)\n        sso_path = \"https://sso.example.com/login\"\n        uid = \"user444\"\n        redirect_url = \"http://example.com:8080/port\"\n        with self.assertRaises(ValueError):\n            build_sso_url(sso_path, uid, redirect_url)\n    \n    def test_integer_uid(self):\n        # Test with integer uid (should be converted to string)\n        sso_path = \"https://sso.example.com/login\"\n        uid = 123\n        redirect_url = \"https://example.com/return\"\n        result = build_sso_url(sso_path, uid, redirect_url)\n        self.assertIn('user=123', result)\n    \n    def test_integer_sso_path(self):\n        # Test with integer sso_path (should be converted to string)\n        sso_path = 12345\n        uid = \"user555\"\n        redirect_url = \"https://example.com/return\"\n        result = build_sso_url(sso_path, uid, redirect_url)\n        self.assertTrue(result.startswith(\"12345\"))\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 10, "task_id": "28b1137a"}
{"test": "import unittest\nimport urllib.parse\n\n# Define the allowed domains for the test\nALLOWED_RETURN_DOMAINS = {'example.com', 'trusted.org'}\n\nclass TestCreateSsoUrl(unittest.TestCase):\n    def test_happy_path(self):\n        # Test typical inputs with allowed domain (same case)\n        auth_endpoint = 'https://auth.example.com/sso'\n        uid = 'user123'\n        redirect_url = 'https://example.com/return'\n        result = create_sso_url(auth_endpoint, uid, redirect_url)\n        expected_query = urllib.parse.urlencode({'user': uid, 'return': redirect_url})\n        expected_url = f'{auth_endpoint}?{expected_query}'\n        self.assertEqual(result, expected_url)\n\n    def test_domain_not_allowed(self):\n        # Test redirect_url with domain not in allowed set\n        auth_endpoint = 'https://auth.example.com/sso'\n        uid = 'user123'\n        redirect_url = 'https://untrusted.com/return'\n        with self.assertRaises(ValueError):\n            create_sso_url(auth_endpoint, uid, redirect_url)\n\n    def test_domain_case_mismatch(self):\n        # Test redirect_url domain in allowed set but different case\n        auth_endpoint = 'https://auth.example.com/sso'\n        uid = 'user123'\n        redirect_url = 'https://EXAMPLE.COM/return'\n        with self.assertRaises(ValueError):\n            create_sso_url(auth_endpoint, uid, redirect_url)\n\n    def test_relative_redirect_url(self):\n        # Test relative redirect_url (empty netloc)\n        auth_endpoint = 'https://auth.example.com/sso'\n        uid = 'user123'\n        redirect_url = '/return'\n        with self.assertRaises(ValueError):\n            create_sso_url(auth_endpoint, uid, redirect_url)\n\n    def test_redirect_url_with_port(self):\n        # Test redirect_url with port (domain without port in allowed set)\n        auth_endpoint = 'https://auth.example.com/sso'\n        uid = 'user123'\n        redirect_url = 'https://example.com:8080/return'\n        with self.assertRaises(ValueError):\n            create_sso_url(auth_endpoint, uid, redirect_url)\n\n    def test_redirect_url_none(self):\n        # Test None redirect_url\n        auth_endpoint = 'https://auth.example.com/sso'\n        uid = 'user123'\n        with self.assertRaises(TypeError):\n            create_sso_url(auth_endpoint, uid, None)\n\n    def test_redirect_url_integer(self):\n        # Test non-string redirect_url (integer)\n        auth_endpoint = 'https://auth.example.com/sso'\n        uid = 'user123'\n        with self.assertRaises(TypeError):\n            create_sso_url(auth_endpoint, uid, 123)\n\n    def test_auth_endpoint_none(self):\n        # Test None auth_endpoint\n        uid = 'user123'\n        redirect_url = 'https://example.com/return'\n        with self.assertRaises(TypeError):\n            create_sso_url(None, uid, redirect_url)\n\n    def test_auth_endpoint_integer(self):\n        # Test non-string auth_endpoint (integer)\n        uid = 'user123'\n        redirect_url = 'https://example.com/return'\n        with self.assertRaises(TypeError):\n            create_sso_url(123, uid, redirect_url)\n\n    def test_uid_integer(self):\n        # Test non-string uid (integer) that converts to string\n        auth_endpoint = 'https://auth.example.com/sso'\n        uid = 123\n        redirect_url = 'https://example.com/return'\n        result = create_sso_url(auth_endpoint, uid, redirect_url)\n        expected_query = urllib.parse.urlencode({'user': str(uid), 'return': redirect_url})\n        expected_url = f'{auth_endpoint}?{expected_query}'\n        self.assertEqual(result, expected_url)\n\n    def test_uid_special_chars(self):\n        # Test uid with special characters\n        auth_endpoint = 'https://auth.example.com/sso'\n        uid = 'user@name!'\n        redirect_url = 'https://example.com/return'\n        result = create_sso_url(auth_endpoint, uid, redirect_url)\n        expected_query = urllib.parse.urlencode({'user': uid, 'return': redirect_url})\n        expected_url = f'{auth_endpoint}?{expected_query}'\n        self.assertEqual(result, expected_url)\n\n    def test_redirect_url_special_chars(self):\n        # Test redirect_url with special characters\n        auth_endpoint = 'https://auth.example.com/sso'\n        uid = 'user123'\n        redirect_url = 'https://example.com/return?param=value&x=y'\n        result = create_sso_url(auth_endpoint, uid, redirect_url)\n        expected_query = urllib.parse.urlencode({'user': uid, 'return': redirect_url})\n        expected_url = f'{auth_endpoint}?{expected_query}'\n        self.assertEqual(result, expected_url)\n\n    def test_auth_endpoint_empty(self):\n        # Test empty auth_endpoint\n        auth_endpoint = ''\n        uid = 'user123'\n        redirect_url = 'https://example.com/return'\n        result = create_sso_url(auth_endpoint, uid, redirect_url)\n        expected_query = urllib.parse.urlencode({'user': uid, 'return': redirect_url})\n        expected_url = f'{auth_endpoint}?{expected_query}'\n        self.assertEqual(result, expected_url)\n\n    def test_uid_empty(self):\n        # Test empty uid\n        auth_endpoint = 'https://auth.example.com/sso'\n        uid = ''\n        redirect_url = 'https://example.com/return'\n        result = create_sso_url(auth_endpoint, uid, redirect_url)\n        expected_query = urllib.parse.urlencode({'user': uid, 'return': redirect_url})\n        expected_url = f'{auth_endpoint}?{expected_query}'\n        self.assertEqual(result, expected_url)\n\n    def test_redirect_url_empty_string(self):\n        # Test empty redirect_url\n        auth_endpoint = 'https://auth.example.com/sso'\n        uid = 'user123'\n        redirect_url = ''\n        with self.assertRaises(ValueError):\n            create_sso_url(auth_endpoint, uid, redirect_url)", "num_test_cases": 16, "task_id": "fb6d2ddf"}
{"test": "import unittest\nfrom unittest.mock import patch\nimport urllib.parse\n\n# Since the function uses a global variable ALLOWED_RETURN_DOMAINS defined in its module,\n# we patch it in the module 'sso_utils' (assuming that's where the function is defined).\n# The test cases will import the function from 'sso_utils'.\nfrom sso_utils import construct_sso_redirect\n\nclass TestConstructSsoRedirect(unittest.TestCase):\n    @classmethod\n    def setUpClass(cls):\n        # Patch the ALLOWED_RETURN_DOMAINS in the sso_utils module\n        cls.patcher = patch('sso_utils.ALLOWED_RETURN_DOMAINS', {'example.com', 'trusted.org', 'sub.domain.co'})\n        cls.patcher.start()\n\n    @classmethod\n    def tearDownClass(cls):\n        cls.patcher.stop()\n\n    def test_case_1_basic_functionality(self):\n        # Test basic functionality with valid inputs\n        sso_uri = \"https://sso.example.com/login\"\n        user_identifier = \"user123\"\n        redirect_link = \"https://example.com/dashboard\"\n        expected = f\"{sso_uri}?{urllib.parse.urlencode({'user': user_identifier, 'return': redirect_link})}\"\n        result = construct_sso_redirect(sso_uri, user_identifier, redirect_link)\n        self.assertEqual(result, expected)\n\n    def test_case_2_special_characters(self):\n        # Test with special characters in user_identifier and redirect_link\n        sso_uri = \"https://auth.org/sso\"\n        user_identifier = \"alice@example\"\n        redirect_link = \"https://trusted.org/welcome?param=value&x=1\"\n        expected = f\"{sso_uri}?{urllib.parse.urlencode({'user': user_identifier, 'return': redirect_link})}\"\n        result = construct_sso_redirect(sso_uri, user_identifier, redirect_link)\n        self.assertEqual(result, expected)\n\n    def test_case_3_exact_domain_match(self):\n        # Test with an allowed domain in the exact case\n        sso_uri = \"https://sso.example.com\"\n        user_identifier = \"bob\"\n        redirect_link = \"https://sub.domain.co/path\"\n        expected = f\"{sso_uri}?{urllib.parse.urlencode({'user': user_identifier, 'return': redirect_link})}\"\n        result = construct_sso_redirect(sso_uri, user_identifier, redirect_link)\n        self.assertEqual(result, expected)\n\n    def test_case_4_empty_user_identifier(self):\n        # Test with an empty user_identifier\n        sso_uri = \"https://sso.example.com/login\"\n        user_identifier = \"\"\n        redirect_link = \"https://example.com/home\"\n        expected = f\"{sso_uri}?{urllib.parse.urlencode({'user': user_identifier, 'return': redirect_link})}\"\n        result = construct_sso_redirect(sso_uri, user_identifier, redirect_link)\n        self.assertEqual(result, expected)\n\n    def test_case_5_empty_sso_uri(self):\n        # Test with an empty sso_uri\n        sso_uri = \"\"\n        user_identifier = \"user456\"\n        redirect_link = \"https://example.com\"\n        expected = f\"{sso_uri}?{urllib.parse.urlencode({'user': user_identifier, 'return': redirect_link})}\"\n        result = construct_sso_redirect(sso_uri, user_identifier, redirect_link)\n        self.assertEqual(result, expected)\n\n    def test_case_6_sso_uri_existing_query(self):\n        # Test when sso_uri already has a query string\n        sso_uri = \"https://example.com?existing=param\"\n        user_identifier = \"user789\"\n        redirect_link = \"https://trusted.org\"\n        expected = f\"{sso_uri}?{urllib.parse.urlencode({'user': user_identifier, 'return': redirect_link})}\"\n        result = construct_sso_redirect(sso_uri, user_identifier, redirect_link)\n        self.assertEqual(result, expected)\n\n    def test_case_7_domain_with_port_not_allowed(self):\n        # Test redirect_link with a domain and port not in allowed domains\n        sso_uri = \"https://sso.example.com\"\n        user_identifier = \"user\"\n        redirect_link = \"https://example.com:8080/home\"\n        with self.assertRaises(ValueError):\n            construct_sso_redirect(sso_uri, user_identifier, redirect_link)\n\n    def test_case_8_domain_not_in_allowed(self):\n        # Test redirect_link with a domain not in allowed domains\n        sso_uri = \"https://sso.example.com\"\n        user_identifier = \"user\"\n        redirect_link = \"https://attacker.com/malicious\"\n        with self.assertRaises(ValueError):\n            construct_sso_redirect(sso_uri, user_identifier, redirect_link)\n\n    def test_case_9_relative_url_not_allowed(self):\n        # Test a relative URL redirect_link (empty netloc)\n        sso_uri = \"https://sso.example.com\"\n        user_identifier = \"user\"\n        redirect_link = \"/relative/path\"\n        with self.assertRaises(ValueError):\n            construct_sso_redirect(sso_uri, user_identifier, redirect_link)\n\n    def test_case_10_invalid_url_not_allowed(self):\n        # Test an invalid URL redirect_link (empty netloc)\n        sso_uri = \"https://sso.example.com\"\n        user_identifier = \"user\"\n        redirect_link = \"invalid_url\"\n        with self.assertRaises(ValueError):\n            construct_sso_redirect(sso_uri, user_identifier, redirect_link)\n\n    def test_case_11_empty_redirect_link(self):\n        # Test an empty redirect_link string (empty netloc)\n        sso_uri = \"https://sso.example.com\"\n        user_identifier = \"user\"\n        redirect_link = \"\"\n        with self.assertRaises(ValueError):\n            construct_sso_redirect(sso_uri, user_identifier, redirect_link)\n\n    def test_case_12_case_sensitivity_domain(self):\n        # Test domain case sensitivity (allowed domains are lowercase)\n        sso_uri = \"https://sso.example.com\"\n        user_identifier = \"user\"\n        redirect_link = \"https://EXAMPLE.COM/home\"  # Different case\n        with self.assertRaises(ValueError):\n            construct_sso_redirect(sso_uri, user_identifier, redirect_link)", "num_test_cases": 12, "task_id": "bf9750c9"}
{"test": "import unittest\nfrom unittest.mock import patch\nimport urllib.parse\n\n# Define the global variable for allowed domains\nALLOWED_RETURN_DOMAINS = {'example.com', 'example.org'}\n\n# Define the function as per the provided code\ndef create_sso_redirect_url(login_endpoint, account_id, callback_url):\n    parsed_return_url = urllib.parse.urlparse(callback_url)\n    if parsed_return_url.netloc not in ALLOWED_RETURN_DOMAINS:\n        raise ValueError(\"Invalid return URL domain\")\n    sso_params = urllib.parse.urlencode({\n        'user': account_id,\n        'return': callback_url\n    })\n    sso_redirect = f\"{login_endpoint}?{sso_params}\"\n    return sso_redirect\n\nclass TestSSORedirectURL(unittest.TestCase):\n\n    def test_happy_path_example_com(self):\n        # Test with allowed domain example.com\n        result = create_sso_redirect_url(\n            \"https://login.service.com/sso\",\n            \"user123\",\n            \"https://example.com/callback\"\n        )\n        self.assertIn(\"user=user123\", result)\n        self.assertIn(\"return=https%3A%2F%2Fexample.com%2Fcallback\", result)\n        self.assertTrue(result.startswith(\"https://login.service.com/sso?\"))\n\n    def test_happy_path_example_org(self):\n        # Test with allowed domain example.org\n        result = create_sso_redirect_url(\n            \"https://login.service.com/sso\",\n            \"user456\",\n            \"https://example.org/callback\"\n        )\n        self.assertIn(\"user=user456\", result)\n        self.assertIn(\"return=https%3A%2F%2Fexample.org%2Fcallback\", result)\n\n    def test_disallowed_domain(self):\n        # Test with disallowed domain example.net\n        with self.assertRaises(ValueError):\n            create_sso_redirect_url(\n                \"https://login.service.com/sso\",\n                \"user789\",\n                \"https://example.net/callback\"\n            )\n\n    def test_relative_url_disallowed(self):\n        # Test relative URL (empty netloc)\n        with self.assertRaises(ValueError):\n            create_sso_redirect_url(\n                \"https://login.service.com/sso\",\n                \"user123\",\n                \"/relative/path\"\n            )\n\n    def test_none_callback_url(self):\n        # Test None callback_url (expect TypeError)\n        with self.assertRaises(TypeError):\n            create_sso_redirect_url(\n                \"https://login.service.com/sso\",\n                \"user123\",\n                None\n            )\n\n    def test_none_account_id(self):\n        # Test None account_id becomes 'None'\n        result = create_sso_redirect_url(\n            \"https://login.service.com/sso\",\n            None,\n            \"https://example.com/callback\"\n        )\n        self.assertIn(\"user=None\", result)\n\n    def test_empty_account_id(self):\n        # Test empty account_id\n        result = create_sso_redirect_url(\n            \"https://login.service.com/sso\",\n            \"\",\n            \"https://example.com/callback\"\n        )\n        self.assertIn(\"user=\", result)\n\n    def test_empty_login_endpoint(self):\n        # Test empty login_endpoint\n        result = create_sso_redirect_url(\n            \"\",\n            \"user123\",\n            \"https://example.com/callback\"\n        )\n        self.assertTrue(result.startswith(\"?user=user123\"))\n\n    def test_login_endpoint_with_existing_query(self):\n        # Test login_endpoint with existing query gets overwritten\n        result = create_sso_redirect_url(\n            \"https://login.service.com/sso?existing=param\",\n            \"user123\",\n            \"https://example.com/callback\"\n        )\n        self.assertNotIn(\"existing=param\", result)\n        self.assertIn(\"user=user123\", result)\n\n    def test_special_characters_in_inputs(self):\n        # Test special characters in account_id and callback_url\n        result = create_sso_redirect_url(\n            \"https://login.service.com/sso\",\n            \"user@domain\",\n            \"https://example.com/callback?param=value&another=param\"\n        )\n        self.assertIn(\"user=user%40domain\", result)\n        self.assertIn(\"return=https%3A%2F%2Fexample.com%2Fcallback%3Fparam%3Dvalue%26another%3Dparam\", result)\n\n    @patch('__main__.ALLOWED_RETURN_DOMAINS', {'example.net'})\n    def test_dynamic_allowed_domains(self):\n        # Test dynamic configuration of allowed domains\n        result = create_sso_redirect_url(\n            \"https://login.service.com/sso\",\n            \"user123\",\n            \"https://example.net/callback\"\n        )\n        self.assertIn(\"return=https%3A%2F%2Fexample.net%2Fcallback\", result)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 11, "task_id": "105943e0"}
{"test": "import unittest\nfrom unittest.mock import patch\nimport urllib.parse\n\n# The function is assumed to be in a module named 'sso'\nfrom sso import build_sso_redirect\n\nclass TestBuildSSORedirect(unittest.TestCase):\n\n    @patch('sso.ALLOWED_RETURN_DOMAINS', {'example.com', 'sub.example.org', 'localhost'})\n    def test_valid_domain_example_com(self):\n        # Test basic happy path with example.com domain\n        auth_endpoint = \"https://auth.example.com/sso\"\n        uid = \"user123\"\n        redirect_url = \"https://example.com/return\"\n        result = build_sso_redirect(auth_endpoint, uid, redirect_url)\n        parsed_result = urllib.parse.urlparse(result)\n        query = urllib.parse.parse_qs(parsed_result.query)\n        self.assertEqual(query['user'][0], uid)\n        self.assertEqual(query['return'][0], redirect_url)\n\n    @patch('sso.ALLOWED_RETURN_DOMAINS', {'example.com', 'sub.example.org', 'localhost'})\n    def test_valid_domain_subdomain(self):\n        # Test with sub.example.org domain\n        auth_endpoint = \"https://auth.example.com/sso\"\n        uid = \"user456\"\n        redirect_url = \"https://sub.example.org/path\"\n        result = build_sso_redirect(auth_endpoint, uid, redirect_url)\n        parsed_result = urllib.parse.urlparse(result)\n        query = urllib.parse.parse_qs(parsed_result.query)\n        self.assertEqual(query['user'][0], uid)\n        self.assertEqual(query['return'][0], redirect_url)\n\n    @patch('sso.ALLOWED_RETURN_DOMAINS', {'example.com', 'sub.example.org', 'localhost'})\n    def test_valid_domain_localhost(self):\n        # Test with localhost domain\n        auth_endpoint = \"https://auth.example.com/sso\"\n        uid = \"user789\"\n        redirect_url = \"http://localhost:8080/return\"\n        result = build_sso_redirect(auth_endpoint, uid, redirect_url)\n        parsed_result = urllib.parse.urlparse(result)\n        query = urllib.parse.parse_qs(parsed_result.query)\n        self.assertEqual(query['user'][0], uid)\n        self.assertEqual(query['return'][0], redirect_url)\n\n    @patch('sso.ALLOWED_RETURN_DOMAINS', {'example.com', 'sub.example.org', 'localhost'})\n    def test_invalid_domain(self):\n        # Test with domain not in allowed set\n        auth_endpoint = \"https://auth.example.com/sso\"\n        uid = \"user123\"\n        redirect_url = \"https://malicious.com/steal\"\n        with self.assertRaises(ValueError):\n            build_sso_redirect(auth_endpoint, uid, redirect_url)\n\n    @patch('sso.ALLOWED_RETURN_DOMAINS', {'example.com', 'sub.example.org', 'localhost'})\n    def test_relative_url_not_allowed(self):\n        # Test relative URL (empty netloc) when not allowed\n        auth_endpoint = \"https://auth.example.com/sso\"\n        uid = \"user123\"\n        redirect_url = \"/return\"\n        with self.assertRaises(ValueError):\n            build_sso_redirect(auth_endpoint, uid, redirect_url)\n\n    @patch('sso.ALLOWED_RETURN_DOMAINS', {'example.com', 'sub.example.org', 'localhost', ''})\n    def test_relative_url_allowed(self):\n        # Test relative URL when empty netloc is allowed\n        auth_endpoint = \"https://auth.example.com/sso\"\n        uid = \"user123\"\n        redirect_url = \"/return\"\n        result = build_sso_redirect(auth_endpoint, uid, redirect_url)\n        parsed_result = urllib.parse.urlparse(result)\n        query = urllib.parse.parse_qs(parsed_result.query)\n        self.assertEqual(query['return'][0], redirect_url)\n\n    @patch('sso.ALLOWED_RETURN_DOMAINS', {'example.com', 'sub.example.org', 'localhost'})\n    def test_empty_redirect_url(self):\n        # Test empty redirect_url (considered relative)\n        auth_endpoint = \"https://auth.example.com/sso\"\n        uid = \"user123\"\n        redirect_url = \"\"\n        with self.assertRaises(ValueError):\n            build_sso_redirect(auth_endpoint, uid, redirect_url)\n\n    @patch('sso.ALLOWED_RETURN_DOMAINS', {'example.com', 'sub.example.org', 'localhost'})\n    def test_non_string_redirect_url(self):\n        # Test non-string redirect_url (None)\n        auth_endpoint = \"https://auth.example.com/sso\"\n        uid = \"user123\"\n        redirect_url = None\n        with self.assertRaises(AttributeError):\n            build_sso_redirect(auth_endpoint, uid, redirect_url)\n\n    @patch('sso.ALLOWED_RETURN_DOMAINS', {'example.com', 'sub.example.org', 'localhost'})\n    def test_special_chars_in_uid(self):\n        # Test UID with special characters\n        auth_endpoint = \"https://auth.example.com/sso\"\n        uid = \"user@123!$&\"\n        redirect_url = \"https://example.com/return\"\n        result = build_sso_redirect(auth_endpoint, uid, redirect_url)\n        parsed_result = urllib.parse.urlparse(result)\n        query = urllib.parse.parse_qs(parsed_result.query)\n        self.assertEqual(query['user'][0], uid)\n\n    @patch('sso.ALLOWED_RETURN_DOMAINS', {'example.com', 'sub.example.org', 'localhost'})\n    def test_special_chars_in_redirect_url(self):\n        # Test redirect_url with special characters\n        auth_endpoint = \"https://auth.example.com/sso\"\n        uid = \"user123\"\n        redirect_url = \"https://example.com/return?param=value&param2=value2\"\n        result = build_sso_redirect(auth_endpoint, uid, redirect_url)\n        parsed_result = urllib.parse.urlparse(result)\n        query = urllib.parse.parse_qs(parsed_result.query)\n        self.assertEqual(query['return'][0], redirect_url)\n\n    @patch('sso.ALLOWED_RETURN_DOMAINS', {'example.com', 'sub.example.org', 'localhost'})\n    def test_empty_auth_endpoint(self):\n        # Test empty auth_endpoint\n        auth_endpoint = \"\"\n        uid = \"user123\"\n        redirect_url = \"https://example.com/return\"\n        result = build_sso_redirect(auth_endpoint, uid, redirect_url)\n        parsed_result = urllib.parse.urlparse(result)\n        self.assertEqual(parsed_result.path, \"\")\n        self.assertTrue(parsed_result.query.startswith('user='))\n\n    @patch('sso.ALLOWED_RETURN_DOMAINS', {'example.com', 'sub.example.org', 'localhost'})\n    def test_long_inputs(self):\n        # Test with very long UID and redirect_url\n        auth_endpoint = \"https://auth.example.com/sso\"\n        uid = \"A\" * 1000\n        redirect_url = \"https://example.com/\" + \"A\" * 1000\n        result = build_sso_redirect(auth_endpoint, uid, redirect_url)\n        parsed_result = urllib.parse.urlparse(result)\n        query = urllib.parse.parse_qs(parsed_result.query)\n        self.assertEqual(query['user'][0], uid)\n        self.assertEqual(query['return'][0], redirect_url)\n\n    @patch('sso.ALLOWED_RETURN_DOMAINS', {'Example.COM', 'sub.example.org', 'localhost'})\n    def test_domain_case_sensitivity(self):\n        # Test domain case sensitivity (allowed set has mixed case)\n        auth_endpoint = \"https://auth.example.com/sso\"\n        uid = \"user123\"\n        redirect_url = \"https://Example.COM/return\"\n        result = build_sso_redirect(auth_endpoint, uid, redirect_url)\n        parsed_result = urllib.parse.urlparse(result)\n        query = urllib.parse.parse_qs(parsed_result.query)\n        self.assertEqual(query['return'][0], redirect_url)\n\n    @patch('sso.ALLOWED_RETURN_DOMAINS', {'example.com', 'sub.example.org', 'localhost'})\n    def test_domain_case_mismatch(self):\n        # Test domain with different case (not in allowed set)\n        auth_endpoint = \"https://auth.example.com/sso\"\n        uid = \"user123\"\n        redirect_url = \"https://Example.COM/return\"\n        with self.assertRaises(ValueError):\n            build_sso_redirect(auth_endpoint, uid, redirect_url)", "num_test_cases": 15, "task_id": "4154513d"}
{"test": "import unittest\nimport urllib.parse\n\n# Global variable used by the function\nALLOWED_CALLBACK_DOMAINS = []\n\nclass TestGenerateOAuthCallbackLink(unittest.TestCase):\n    def setUp(self):\n        # Save the original ALLOWED_CALLBACK_DOMAINS\n        self.original_domains = globals()['ALLOWED_CALLBACK_DOMAINS']\n    \n    def tearDown(self):\n        # Restore the original ALLOWED_CALLBACK_DOMAINS\n        globals()['ALLOWED_CALLBACK_DOMAINS'] = self.original_domains\n    \n    def test_same_domain(self):\n        # Test when callback URL domain is the same as base URL domain\n        globals()['ALLOWED_CALLBACK_DOMAINS'] = ['allowed.com']\n        result = generate_oauth_callback_link(\n            \"https://example.com\",\n            \"/callback\",\n            \"state123\"\n        )\n        expected = \"https://example.com/callback?state=state123\"\n        self.assertEqual(result, expected)\n    \n    def test_allowed_domain(self):\n        # Test when callback URL domain is in ALLOWED_CALLBACK_DOMAINS\n        globals()['ALLOWED_CALLBACK_DOMAINS'] = ['allowed.com']\n        result = generate_oauth_callback_link(\n            \"https://example.com\",\n            \"https://allowed.com/callback\",\n            \"state123\"\n        )\n        expected = \"https://allowed.com/callback?state=state123\"\n        self.assertEqual(result, expected)\n    \n    def test_trailing_slash_in_base_url(self):\n        # Test base URL with trailing slash and relative callback endpoint\n        globals()['ALLOWED_CALLBACK_DOMAINS'] = ['example.com']\n        result = generate_oauth_callback_link(\n            \"https://example.com/\",\n            \"callback\",\n            \"state123\"\n        )\n        expected = \"https://example.com/callback?state=state123\"\n        self.assertEqual(result, expected)\n    \n    def test_special_chars_in_state(self):\n        # Test state parameter with special characters\n        globals()['ALLOWED_CALLBACK_DOMAINS'] = ['example.com']\n        state = \"state!@# $%^&*()\"\n        quoted_state = urllib.parse.quote(state)\n        result = generate_oauth_callback_link(\n            \"https://example.com\",\n            \"/callback\",\n            state\n        )\n        expected = f\"https://example.com/callback?state={quoted_state}\"\n        self.assertEqual(result, expected)\n    \n    def test_invalid_domain_raises_error(self):\n        # Test when callback URL domain is not base and not allowed\n        globals()['ALLOWED_CALLBACK_DOMAINS'] = ['allowed.com']\n        with self.assertRaises(ValueError):\n            generate_oauth_callback_link(\n                \"https://example.com\",\n                \"https://evil.com/callback\",\n                \"state123\"\n            )\n    \n    def test_empty_strings(self):\n        # Test with empty strings for all arguments\n        globals()['ALLOWED_CALLBACK_DOMAINS'] = []\n        result = generate_oauth_callback_link(\"\", \"\", \"\")\n        # Expected: empty base + empty endpoint -> \"\" and then \"?state=\"\n        self.assertEqual(result, \"?state=\")\n    \n    def test_invalid_base_url(self):\n        # Test with invalid base URL and disallowed callback domain\n        globals()['ALLOWED_CALLBACK_DOMAINS'] = []\n        with self.assertRaises(ValueError):\n            generate_oauth_callback_link(\n                \"invalid_url\",\n                \"http://evil.com/callback\",\n                \"state123\"\n            )\n    \n    def test_non_string_inputs(self):\n        # Test with non-string inputs\n        with self.assertRaises(TypeError):\n            generate_oauth_callback_link(123, \"/callback\", \"state123\")\n        with self.assertRaises(TypeError):\n            generate_oauth_callback_link(\"https://example.com\", 123, \"state123\")\n        with self.assertRaises(TypeError):\n            generate_oauth_callback_link(\"https://example.com\", \"/callback\", 123)\n    \n    def test_long_verification_state(self):\n        # Test with a very long verification state\n        globals()['ALLOWED_CALLBACK_DOMAINS'] = ['example.com']\n        long_state = \"A\" * 1000\n        quoted_state = urllib.parse.quote(long_state)\n        result = generate_oauth_callback_link(\n            \"https://example.com\",\n            \"/callback\",\n            long_state\n        )\n        expected = f\"https://example.com/callback?state={quoted_state}\"\n        self.assertEqual(result, expected)", "num_test_cases": 9, "task_id": "d4099be4"}
{"test": "import unittest\nimport urllib.parse\n\n# Define the global allowed domains for the tests\nALLOWED_CALLBACK_DOMAINS = {'trusted.com', 'allowed.org'}\n\nclass TestBuildOAuthRedirectUrl(unittest.TestCase):\n    def test_case_1(self):\n        \"\"\"Test same domain with absolute path\"\"\"\n        main_url = \"https://example.com\"\n        redirect_path = \"/callback\"\n        token_state = \"abc123\"\n        result = build_oauth_redirect_url(main_url, redirect_path, token_state)\n        expected = \"https://example.com/callback?state=abc123\"\n        self.assertEqual(result, expected)\n\n    def test_case_2(self):\n        \"\"\"Test different domain in allowed set (full URL in redirect_path)\"\"\"\n        main_url = \"https://example.com\"\n        redirect_path = \"https://trusted.com/callback\"\n        token_state = \"xyz\"\n        result = build_oauth_redirect_url(main_url, redirect_path, token_state)\n        expected = \"https://trusted.com/callback?state=xyz\"\n        self.assertEqual(result, expected)\n\n    def test_case_3(self):\n        \"\"\"Test different domain not in allowed set\"\"\"\n        main_url = \"https://example.com\"\n        redirect_path = \"https://evil.com/callback\"\n        token_state = \"xyz\"\n        with self.assertRaises(ValueError):\n            build_oauth_redirect_url(main_url, redirect_path, token_state)\n\n    def test_case_4(self):\n        \"\"\"Test empty redirect_path\"\"\"\n        main_url = \"https://example.com\"\n        redirect_path = \"\"\n        token_state = \"abc\"\n        result = build_oauth_redirect_url(main_url, redirect_path, token_state)\n        expected = \"https://example.com?state=abc\"\n        self.assertEqual(result, expected)\n\n    def test_case_5(self):\n        \"\"\"Test token_state with special characters\"\"\"\n        main_url = \"https://example.com\"\n        redirect_path = \"/callback\"\n        token_state = \"a b?c&d=e\"\n        result = build_oauth_redirect_url(main_url, redirect_path, token_state)\n        expected = \"https://example.com/callback?state=\" + urllib.parse.quote(token_state)\n        self.assertEqual(result, expected)\n\n    def test_case_6(self):\n        \"\"\"Test relative path without leading slash and main_url without trailing slash\"\"\"\n        main_url = \"https://example.com/base\"\n        redirect_path = \"callback\"\n        token_state = \"abc\"\n        result = build_oauth_redirect_url(main_url, redirect_path, token_state)\n        expected = \"https://example.com/base/callback?state=abc\"\n        self.assertEqual(result, expected)\n\n    def test_case_7(self):\n        \"\"\"Test relative path without leading slash and main_url with trailing slash\"\"\"\n        main_url = \"https://example.com/base/\"\n        redirect_path = \"callback\"\n        token_state = \"abc\"\n        result = build_oauth_redirect_url(main_url, redirect_path, token_state)\n        expected = \"https://example.com/base/callback?state=abc\"\n        self.assertEqual(result, expected)\n\n    def test_case_8(self):\n        \"\"\"Test scheme-relative URL to allowed domain\"\"\"\n        main_url = \"https://example.com\"\n        redirect_path = \"//trusted.com/callback\"\n        token_state = \"abc\"\n        result = build_oauth_redirect_url(main_url, redirect_path, token_state)\n        expected = \"https://trusted.com/callback?state=abc\"\n        self.assertEqual(result, expected)\n\n    def test_case_9(self):\n        \"\"\"Test scheme-relative URL to disallowed domain\"\"\"\n        main_url = \"https://example.com\"\n        redirect_path = \"//evil.com/callback\"\n        token_state = \"abc\"\n        with self.assertRaises(ValueError):\n            build_oauth_redirect_url(main_url, redirect_path, token_state)\n\n    def test_case_10(self):\n        \"\"\"Test relative path that goes up a directory (same domain)\"\"\"\n        main_url = \"https://example.com/base\"\n        redirect_path = \"../callback\"\n        token_state = \"abc\"\n        result = build_oauth_redirect_url(main_url, redirect_path, token_state)\n        expected = \"https://example.com/callback?state=abc\"\n        self.assertEqual(result, expected)", "num_test_cases": 10, "task_id": "cbd2b6be"}
{"test": "import unittest\nimport urllib.parse\n\n# Define the allowed domains for the tests\nALLOWED_CALLBACK_DOMAINS = {'example.com', 'test.org'}\n\nclass TestConstructOAuthCallbackUri(unittest.TestCase):\n    \n    def test_same_domain(self):\n        # Same domain: example.com is the same as root_url's domain\n        root_url = 'https://example.com/base'\n        callback_uri = '/callback'\n        session_state = 'abc123'\n        result = construct_oauth_callback_uri(root_url, callback_uri, session_state)\n        # Build expected\n        expected_callback_url = urllib.parse.urljoin(root_url, callback_uri)\n        quoted_state = urllib.parse.quote(session_state)\n        expected = f'{expected_callback_url}?state={quoted_state}'\n        self.assertEqual(result, expected)\n    \n    def test_different_allowed_domain(self):\n        # Different domain but in allowed list\n        root_url = 'https://example.com'\n        callback_uri = 'https://test.org/callback'\n        session_state = 'xyz'\n        result = construct_oauth_callback_uri(root_url, callback_uri, session_state)\n        expected_callback_url = urllib.parse.urljoin(root_url, callback_uri)\n        quoted_state = urllib.parse.quote(session_state)\n        expected = f'{expected_callback_url}?state={quoted_state}'\n        self.assertEqual(result, expected)\n    \n    def test_domain_not_allowed(self):\n        # Different domain and not in allowed list -> raises\n        root_url = 'https://example.com'\n        callback_uri = 'https://evil.com/callback'\n        session_state = 'state1'\n        with self.assertRaises(ValueError):\n            construct_oauth_callback_uri(root_url, callback_uri, session_state)\n    \n    def test_relative_callback_same_domain(self):\n        # Relative callback URI resulting in same domain\n        root_url = 'https://example.com/base'\n        callback_uri = 'callback'\n        session_state = 'state1'\n        result = construct_oauth_callback_uri(root_url, callback_uri, session_state)\n        expected_callback_url = urllib.parse.urljoin(root_url, callback_uri)\n        quoted_state = urllib.parse.quote(session_state)\n        expected = f'{expected_callback_url}?state={quoted_state}'\n        self.assertEqual(result, expected)\n    \n    def test_relative_callback_with_trailing_slash(self):\n        # Root URL with trailing slash and relative callback\n        root_url = 'https://example.com/base/'\n        callback_uri = 'callback'\n        session_state = 'state1'\n        result = construct_oauth_callback_uri(root_url, callback_uri, session_state)\n        expected_callback_url = urllib.parse.urljoin(root_url, callback_uri)\n        quoted_state = urllib.parse.quote(session_state)\n        expected = f'{expected_callback_url}?state={quoted_state}'\n        self.assertEqual(result, expected)\n    \n    def test_empty_callback_uri(self):\n        # Empty callback URI\n        root_url = 'https://example.com'\n        callback_uri = ''\n        session_state = 'state1'\n        result = construct_oauth_callback_uri(root_url, callback_uri, session_state)\n        expected_callback_url = urllib.parse.urljoin(root_url, callback_uri)\n        quoted_state = urllib.parse.quote(session_state)\n        expected = f'{expected_callback_url}?state={quoted_state}'\n        self.assertEqual(result, expected)\n    \n    def test_empty_root_url_with_allowed_callback(self):\n        # Empty root URL with absolute callback in allowed domain\n        root_url = ''\n        callback_uri = 'https://example.com/callback'\n        session_state = 'state1'\n        result = construct_oauth_callback_uri(root_url, callback_uri, session_state)\n        expected_callback_url = urllib.parse.urljoin(root_url, callback_uri)\n        quoted_state = urllib.parse.quote(session_state)\n        expected = f'{expected_callback_url}?state={quoted_state}'\n        self.assertEqual(result, expected)\n    \n    def test_empty_root_url_with_not_allowed_callback(self):\n        # Empty root URL with absolute callback not in allowed domain\n        root_url = ''\n        callback_uri = 'https://evil.com/callback'\n        session_state = 'state1'\n        with self.assertRaises(ValueError):\n            construct_oauth_callback_uri(root_url, callback_uri, session_state)\n    \n    def test_empty_root_url_relative_callback(self):\n        # Empty root URL with relative callback\n        root_url = ''\n        callback_uri = 'relative/path'\n        session_state = 'state1'\n        result = construct_oauth_callback_uri(root_url, callback_uri, session_state)\n        expected_callback_url = urllib.parse.urljoin(root_url, callback_uri)\n        quoted_state = urllib.parse.quote(session_state)\n        expected = f'{expected_callback_url}?state={quoted_state}'\n        self.assertEqual(result, expected)\n    \n    def test_root_url_none(self):\n        # None for root_url -> TypeError\n        with self.assertRaises(TypeError):\n            construct_oauth_callback_uri(None, '/callback', 'state')\n    \n    def test_callback_uri_none(self):\n        # None for callback_uri -> TypeError\n        with self.assertRaises(TypeError):\n            construct_oauth_callback_uri('https://example.com', None, 'state')\n    \n    def test_session_state_none(self):\n        # None for session_state -> TypeError\n        with self.assertRaises(TypeError):\n            construct_oauth_callback_uri('https://example.com', '/callback', None)\n    \n    def test_long_strings(self):\n        # Test with very long inputs\n        root_url = 'https://example.com/' + 'a' * 1000\n        callback_uri = '/' + 'b' * 1000\n        session_state = 'c' * 1000\n        result = construct_oauth_callback_uri(root_url, callback_uri, session_state)\n        # Build expected\n        expected_callback_url = urllib.parse.urljoin(root_url, callback_uri)\n        quoted_state = urllib.parse.quote(session_state)\n        expected = f'{expected_callback_url}?state={quoted_state}'\n        self.assertEqual(result, expected)\n    \n    def test_callback_uri_with_existing_query(self):\n        # Callback URI with existing query parameters\n        root_url = 'https://example.com'\n        callback_uri = '/callback?param=value'\n        session_state = 'state123'\n        result = construct_oauth_callback_uri(root_url, callback_uri, session_state)\n        expected_callback_url = urllib.parse.urljoin(root_url, callback_uri)\n        quoted_state = urllib.parse.quote(session_state)\n        expected = f'{expected_callback_url}?state={quoted_state}'\n        self.assertEqual(result, expected)\n    \n    def test_callback_uri_with_fragment(self):\n        # Callback URI with fragment identifier\n        root_url = 'https://example.com'\n        callback_uri = '/callback#fragment'\n        session_state = 'state123'\n        result = construct_oauth_callback_uri(root_url, callback_uri, session_state)\n        expected_callback_url = urllib.parse.urljoin(root_url, callback_uri)\n        quoted_state = urllib.parse.quote(session_state)\n        expected = f'{expected_callback_url}?state={quoted_state}'\n        self.assertEqual(result, expected)", "num_test_cases": 15, "task_id": "3b4b7aab"}
{"test": "import unittest\nimport solution\n\n# Set the allowed domains for the test environment\nsolution.ALLOWED_CALLBACK_DOMAINS = {'allowed.com', 'trusted.org', 'withport.com:8080'}\n\nclass TestBuildOauthRedirectUrl(unittest.TestCase):\n\n    def test_case_1(self):\n        # Happy path: same domain, relative path\n        result = solution.build_oauth_redirect_url(\n            main_url='https://example.com',\n            redirect_path='/callback',\n            nonce='abc123'\n        )\n        self.assertEqual(result, 'https://example.com/callback?state=abc123')\n\n    def test_case_2(self):\n        # Happy path: allowed domain (different from base)\n        result = solution.build_oauth_redirect_url(\n            main_url='https://example.com',\n            redirect_path='https://allowed.com/callback',\n            nonce='abc123'\n        )\n        self.assertEqual(result, 'https://allowed.com/callback?state=abc123')\n\n    def test_case_3(self):\n        # Error: disallowed domain\n        with self.assertRaises(ValueError):\n            solution.build_oauth_redirect_url(\n                main_url='https://example.com',\n                redirect_path='https://evil.com/callback',\n                nonce='abc123'\n            )\n\n    def test_case_4(self):\n        # Relative path without leading slash\n        result = solution.build_oauth_redirect_url(\n            main_url='https://example.com/base/',\n            redirect_path='callback',\n            nonce='abc123'\n        )\n        self.assertEqual(result, 'https://example.com/base/callback?state=abc123')\n\n    def test_case_5(self):\n        # Empty redirect_path\n        result = solution.build_oauth_redirect_url(\n            main_url='https://example.com',\n            redirect_path='',\n            nonce='abc123'\n        )\n        self.assertEqual(result, 'https://example.com?state=abc123')\n\n    def test_case_6(self):\n        # Nonce with special characters requiring URL quoting\n        result = solution.build_oauth_redirect_url(\n            main_url='https://example.com',\n            redirect_path='/callback',\n            nonce='a b?c=d&e=f'\n        )\n        expected = 'https://example.com/callback?state=a%20b%3Fc%3Dd%26e%3Df'\n        self.assertEqual(result, expected)\n\n    def test_case_7(self):\n        # Main URL with trailing slash and relative path\n        result = solution.build_oauth_redirect_url(\n            main_url='https://example.com/base/',\n            redirect_path='./callback',\n            nonce='abc123'\n        )\n        self.assertEqual(result, 'https://example.com/base/./callback?state=abc123')\n\n    def test_case_8(self):\n        # Absolute URL with same domain as base\n        result = solution.build_oauth_redirect_url(\n            main_url='https://example.com',\n            redirect_path='https://example.com/callback',\n            nonce='abc123'\n        )\n        self.assertEqual(result, 'https://example.com/callback?state=abc123')\n\n    def test_case_9(self):\n        # Allowed domain with explicit port matching allowed set\n        result = solution.build_oauth_redirect_url(\n            main_url='https://example.com',\n            redirect_path='https://withport.com:8080/callback',\n            nonce='abc123'\n        )\n        self.assertEqual(result, 'https://withport.com:8080/callback?state=abc123')\n\n    def test_case_10(self):\n        # Disallowed port variation (not in allowed set)\n        with self.assertRaises(ValueError):\n            solution.build_oauth_redirect_url(\n                main_url='https://example.com',\n                redirect_path='https://withport.com:80/callback',\n                nonce='abc123'\n            )\n\n    def test_case_11(self):\n        # Relative protocol (//) leading to disallowed domain\n        with self.assertRaises(ValueError):\n            solution.build_oauth_redirect_url(\n                main_url='https://example.com',\n                redirect_path='//evil.com/callback',\n                nonce='abc123'\n            )\n\n    def test_case_12(self):\n        # Verify exact error message for disallowed domain\n        with self.assertRaises(ValueError) as context:\n            solution.build_oauth_redirect_url(\n                main_url='https://example.com',\n                redirect_path='https://evil.com/callback',\n                nonce='abc123'\n            )\n        self.assertEqual(str(context.exception), \"Invalid callback URL domain\")\n\n    def test_case_13(self):\n        # Different port representation (base has explicit port, callback does not)\n        with self.assertRaises(ValueError):\n            solution.build_oauth_redirect_url(\n                main_url='https://example.com:443',\n                redirect_path='https://example.com/callback',\n                nonce='abc123'\n            )\n\n    def test_case_14(self):\n        # Valid non-http(s) scheme in base URL\n        result = solution.build_oauth_redirect_url(\n            main_url='ftp://example.com',\n            redirect_path='/callback',\n            nonce='abc123'\n        )\n        self.assertEqual(result, 'ftp://example.com/callback?state=abc123')\n\n    def test_case_15(self):\n        # None for main_url - invalid input\n        with self.assertRaises(AttributeError):\n            solution.build_oauth_redirect_url(\n                main_url=None,\n                redirect_path='/callback',\n                nonce='abc123'\n            )\n\n    def test_case_16(self):\n        # None for redirect_path - invalid input\n        with self.assertRaises(AttributeError):\n            solution.build_oauth_redirect_url(\n                main_url='https://example.com',\n                redirect_path=None,\n                nonce='abc123'\n            )\n\n    def test_case_17(self):\n        # Very long nonce\n        long_nonce = 'x' * 1000\n        result = solution.build_oauth_redirect_url(\n            main_url='https://example.com',\n            redirect_path='/callback',\n            nonce=long_nonce\n        )\n        self.assertIn('state=' + urllib.parse.quote(long_nonce), result)\n\n    def test_case_18(self):\n        # Numeric nonce\n        result = solution.build_oauth_redirect_url(\n            main_url='https://example.com',\n            redirect_path='/callback',\n            nonce='12345'\n        )\n        self.assertEqual(result, 'https://example.com/callback?state=12345')\n\n    def test_case_19(self):\n        # Redirect_path with existing query parameters\n        result = solution.build_oauth_redirect_url(\n            main_url='https://example.com',\n            redirect_path='/callback?param=value',\n            nonce='abc123'\n        )\n        # The function appends state parameter, existing parameters should remain\n        self.assertEqual(result, 'https://example.com/callback?param=value&state=abc123')\n\n    def test_case_20(self):\n        # Redirect_path with existing fragment (should be preserved?)\n        # Note: The function does not handle fragments explicitly\n        result = solution.build_oauth_redirect_url(\n            main_url='https://example.com',\n            redirect_path='/callback#section1',\n            nonce='abc123'\n        )\n        # Expect: state parameter is added to the query, fragment remains\n        self.assertEqual(result, 'https://example.com/callback?state=abc123#section1')\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 20, "task_id": "44f5ee33"}
{"test": "import unittest\nimport urllib.parse\n\n# Define the global variable for the test\nALLOWED_CALLBACK_DOMAINS = {'example.com', 'api.example.com', 'localhost'}\n\nclass TestGenerateOAuthTokenUrl(unittest.TestCase):\n\n    def test_same_domain(self):\n        # Test when callback URL has same domain as base URL (happy path)\n        result = generate_oauth_token_url(\n            \"https://example.com\",\n            \"/callback\",\n            \"state123\"\n        )\n        expected = \"https://example.com/callback?state=state123\"\n        self.assertEqual(result, expected)\n\n    def test_allowed_domain(self):\n        # Test callback URL domain in ALLOWED_CALLBACK_DOMAINS\n        result = generate_oauth_token_url(\n            \"https://example.com\",\n            \"https://api.example.com/token\",\n            \"state456\"\n        )\n        expected = \"https://api.example.com/token?state=state456\"\n        self.assertEqual(result, expected)\n\n    def test_relative_path_trailing_slash(self):\n        # Test relative token_path with base URL having trailing slash\n        result = generate_oauth_token_url(\n            \"https://example.com/\",\n            \"callback\",\n            \"state_relative\"\n        )\n        expected = \"https://example.com/callback?state=state_relative\"\n        self.assertEqual(result, expected)\n\n    def test_absolute_path_no_trailing_slash(self):\n        # Test absolute token_path with base URL without trailing slash\n        result = generate_oauth_token_url(\n            \"https://example.com\",\n            \"/oauth\",\n            \"state_abs\"\n        )\n        expected = \"https://example.com/oauth?state=state_abs\"\n        self.assertEqual(result, expected)\n\n    def test_session_state_special_chars(self):\n        # Test session_state with special characters requiring quoting\n        result = generate_oauth_token_url(\n            \"https://example.com\",\n            \"/path\",\n            \"state !@#$%^&*()\"\n        )\n        quoted_state = urllib.parse.quote(\"state !@#$%^&*()\")\n        expected = f\"https://example.com/path?state={quoted_state}\"\n        self.assertEqual(result, expected)\n\n    def test_empty_base_url(self):\n        # Test with empty base URL - invalid domain check\n        with self.assertRaises(ValueError):\n            generate_oauth_token_url(\"\", \"/callback\", \"state_empty\")\n\n    def test_base_url_with_port(self):\n        # Test base URL with port number - should match netloc exactly\n        result = generate_oauth_token_url(\n            \"http://localhost:8000\",\n            \"/auth\",\n            \"state_port\"\n        )\n        expected = \"http://localhost:8000/auth?state=state_port\"\n        self.assertEqual(result, expected)\n\n    def test_allowed_domain_different_base(self):\n        # Test domain in allowed set different from base URL\n        result = generate_oauth_token_url(\n            \"https://example.com\",\n            \"http://localhost/auth\",\n            \"state_localhost\"\n        )\n        expected = \"http://localhost/auth?state=state_localhost\"\n        self.assertEqual(result, expected)\n\n    def test_disallowed_domain(self):\n        # Test callback URL domain not in allowed set and different from base\n        with self.assertRaises(ValueError):\n            generate_oauth_token_url(\n                \"https://example.com\",\n                \"https://phishing.com/callback\",\n                \"state_malicious\"\n            )\n\n    def test_base_url_with_path_component(self):\n        # Test base URL with path and relative token_path\n        result = generate_oauth_token_url(\n            \"https://example.com/base\",\n            \"rel\",\n            \"state_relative\"\n        )\n        expected = \"https://example.com/base/rel?state=state_relative\"\n        self.assertEqual(result, expected)\n\n    def test_netloc_empty_string(self):\n        # Test when parsed netloc is empty string - should be invalid\n        with self.assertRaises(ValueError):\n            generate_oauth_token_url(\"not_a_url\", \"also_invalid\", \"state_invalid\")\n\n    def test_partial_domain_match(self):\n        # Test when callback domain partially matches base domain but not exactly\n        with self.assertRaises(ValueError):\n            generate_oauth_token_url(\n                \"https://example.com\",\n                \"https://sub.example.com.evil.com/token\",\n                \"state_phish\"\n            )", "num_test_cases": 12, "task_id": "370d00e2"}
{"test": "import unittest\nimport urllib.parse\n\n# Define the global variable as required by the function\nALLOWED_CALLBACK_DOMAINS = {'example.com', 'test.org'}\n\ndef assemble_oauth_callback_url(root_url, path_for_callback, session_token):\n    parsed_base_url = urllib.parse.urlparse(root_url)\n    callback_url = urllib.parse.urljoin(root_url, path_for_callback)\n    parsed_callback_url = urllib.parse.urlparse(callback_url)\n    if parsed_callback_url.netloc != parsed_base_url.netloc and parsed_callback_url.netloc not in ALLOWED_CALLBACK_DOMAINS:\n        raise ValueError(\"Invalid callback URL domain\")\n    full_callback_url = f\"{callback_url}?state={urllib.parse.quote(session_token)}\"\n    return full_callback_url\n\nclass TestAssembleOauthCallbackUrl(unittest.TestCase):\n\n    def test_same_domain_valid(self):\n        # Test with same domain for base and callback\n        result = assemble_oauth_callback_url(\"https://example.com\", \"/callback\", \"token123\")\n        self.assertEqual(result, \"https://example.com/callback?state=token123\")\n\n    def test_allowed_domain_valid(self):\n        # Test with callback domain in ALLOWED_CALLBACK_DOMAINS\n        result = assemble_oauth_callback_url(\"https://example.com\", \"https://test.org/auth\", \"token456\")\n        self.assertEqual(result, \"https://test.org/auth?state=token456\")\n\n    def test_relative_path(self):\n        # Test with relative path joining base URL\n        result = assemble_oauth_callback_url(\"https://example.com/base\", \"rel\", \"t1\")\n        self.assertEqual(result, \"https://example.com/base/rel?state=t1\")\n\n    def test_query_preservation(self):\n        # Test preserving existing query parameters in callback path\n        result = assemble_oauth_callback_url(\"https://example.com\", \"/cb?param=value\", \"t2\")\n        self.assertEqual(result, \"https://example.com/cb?param=value?state=t2\")\n\n    def test_empty_path(self):\n        # Test with empty callback path\n        result = assemble_oauth_callback_url(\"https://example.com\", \"\", \"empty_path\")\n        self.assertEqual(result, \"https://example.com?state=empty_path\")\n\n    def test_empty_root_url(self):\n        # Test with empty root URL\n        result = assemble_oauth_callback_url(\"\", \"/callback\", \"empty_root\")\n        self.assertEqual(result, \"/callback?state=empty_root\")\n\n    def test_empty_session_token(self):\n        # Test with empty session token\n        result = assemble_oauth_callback_url(\"https://example.com\", \"/cb\", \"\")\n        self.assertEqual(result, \"https://example.com/cb?state=\")\n\n    def test_special_chars_token(self):\n        # Test token with special characters requiring encoding\n        result = assemble_oauth_callback_url(\"https://example.com\", \"/cb\", \"!@#$%^&*()\")\n        expected = \"https://example.com/cb?state=%21%40%23%24%25%5E%26%2A%28%29\"\n        self.assertEqual(result, expected)\n\n    def test_disallowed_domain(self):\n        # Test callback domain not in allowed set\n        with self.assertRaises(ValueError):\n            assemble_oauth_callback_url(\"https://example.com\", \"https://malicious.com/cb\", \"bad\")\n\n    def test_none_input(self):\n        # Test None input raises AttributeError\n        with self.assertRaises(AttributeError):\n            assemble_oauth_callback_url(None, \"/cb\", \"token\")\n\n    def test_non_string_input(self):\n        # Test non-string input raises AttributeError\n        with self.assertRaises(AttributeError):\n            assemble_oauth_callback_url(123, \"/cb\", \"token\")\n\n    def test_invalid_domain_format(self):\n        # Test invalid domain format (None netloc)\n        with self.assertRaises(ValueError):\n            assemble_oauth_callback_url(\"https://example.com\", \"invalid_url\", \"token\")", "num_test_cases": 12, "task_id": "ca622bfb"}
{"test": "import unittest\nfrom unittest.mock import patch\nimport urllib.parse\n\nclass TestCases(unittest.TestCase):\n    \n    def test_same_domain(self):\n        \"\"\"Test typical case with same domain.\"\"\"\n        main_url = 'https://example.com/home'\n        redirect_endpoint = '/callback'\n        session_state = 'state123'\n        result = build_oauth_redirect_url(main_url, redirect_endpoint, session_state)\n        expected = 'https://example.com/callback?state=state123'\n        self.assertEqual(result, expected)\n    \n    def test_allowed_domain(self):\n        \"\"\"Test domain in ALLOWED_CALLBACK_DOMAINS.\"\"\"\n        with patch('app.ALLOWED_CALLBACK_DOMAINS', {'trusted.com'}):\n            main_url = 'https://example.com/home'\n            redirect_endpoint = 'https://trusted.com/callback'\n            session_state = 'state123'\n            result = build_oauth_redirect_url(main_url, redirect_endpoint, session_state)\n            expected = 'https://trusted.com/callback?state=state123'\n            self.assertEqual(result, expected)\n    \n    def test_not_allowed_domain(self):\n        \"\"\"Test domain not in allowed set raises ValueError.\"\"\"\n        with patch('app.ALLOWED_CALLBACK_DOMAINS', set()):\n            main_url = 'https://example.com/home'\n            redirect_endpoint = 'https://malicious.com/callback'\n            with self.assertRaises(ValueError):\n                build_oauth_redirect_url(main_url, redirect_endpoint, 'state123')\n    \n    def test_empty_redirect_endpoint(self):\n        \"\"\"Test empty redirect_endpoint results in base URL with state.\"\"\"\n        main_url = 'https://example.com/home'\n        redirect_endpoint = ''\n        session_state = 'state123'\n        result = build_oauth_redirect_url(main_url, redirect_endpoint, session_state)\n        expected = 'https://example.com/home?state=state123'\n        self.assertEqual(result, expected)\n    \n    def test_relative_redirect_endpoint(self):\n        \"\"\"Test relative redirect_endpoint appends correctly.\"\"\"\n        main_url = 'https://example.com/base/'\n        redirect_endpoint = 'callback'\n        session_state = 'state123'\n        result = build_oauth_redirect_url(main_url, redirect_endpoint, session_state)\n        expected = 'https://example.com/base/callback?state=state123'\n        self.assertEqual(result, expected)\n    \n    def test_special_characters_in_session_state(self):\n        \"\"\"Test session_state with special characters is properly quoted.\"\"\"\n        main_url = 'https://example.com'\n        redirect_endpoint = '/callback'\n        session_state = 'state with spaces and / and ?'\n        result = build_oauth_redirect_url(main_url, redirect_endpoint, session_state)\n        expected = 'https://example.com/callback?state=state%20with%20spaces%20and%20%2F%20and%20%3F'\n        self.assertEqual(result, expected)\n    \n    def test_invalid_main_url_with_non_allowed_redirect(self):\n        \"\"\"Test invalid main_url (no netloc) with non-allowed redirect domain raises ValueError.\"\"\"\n        with patch('app.ALLOWED_CALLBACK_DOMAINS', set()):\n            main_url = 'invalid_url'\n            redirect_endpoint = 'https://example.com/callback'\n            with self.assertRaises(ValueError):\n                build_oauth_redirect_url(main_url, redirect_endpoint, 'state123')\n    \n    def test_invalid_main_url_with_relative_redirect(self):\n        \"\"\"Test invalid main_url (no netloc) with relative redirect_endpoint allowed.\"\"\"\n        main_url = 'invalid_url'\n        redirect_endpoint = 'callback'\n        session_state = 'state123'\n        result = build_oauth_redirect_url(main_url, redirect_endpoint, session_state)\n        expected = 'invalid_url/callback?state=state123'\n        self.assertEqual(result, expected)\n    \n    def test_empty_session_state(self):\n        \"\"\"Test empty session_state is properly handled.\"\"\"\n        main_url = 'https://example.com'\n        redirect_endpoint = '/callback'\n        session_state = ''\n        result = build_oauth_redirect_url(main_url, redirect_endpoint, session_state)\n        expected = 'https://example.com/callback?state='\n        self.assertEqual(result, expected)\n    \n    def test_none_main_url(self):\n        \"\"\"Test None main_url raises AttributeError.\"\"\"\n        with self.assertRaises(AttributeError):\n            build_oauth_redirect_url(None, '/callback', 'state123')\n    \n    def test_none_redirect_endpoint(self):\n        \"\"\"Test None redirect_endpoint raises TypeError.\"\"\"\n        with self.assertRaises(TypeError):\n            build_oauth_redirect_url('https://example.com', None, 'state123')\n    \n    def test_large_inputs(self):\n        \"\"\"Test very large inputs do not cause issues.\"\"\"\n        main_url = 'https://example.com/' + 'a' * 1000\n        redirect_endpoint = '/' + 'b' * 1000\n        session_state = 'c' * 1000\n        result = build_oauth_redirect_url(main_url, redirect_endpoint, session_state)\n        self.assertIn('state=' + urllib.parse.quote(session_state), result)\n        self.assertTrue(result.startswith('https://example.com/'))", "num_test_cases": 12, "task_id": "0f52aae9"}
{"test": "import unittest\nimport urllib.parse\n\n# Define the global ALLOWED_CALLBACK_DOMAINS as specified in the function's context.\n# This set should match the domains allowed for OAuth callbacks.\nALLOWED_CALLBACK_DOMAINS = {'trusted.org', 'example.net'}\n\nclass TestGenerateOAuthUrl(unittest.TestCase):\n\n    def test_same_domain_relative_path(self):\n        \"\"\"Test same domain with relative callback path.\"\"\"\n        result = generate_oauth_url(\"https://example.com\", \"/callback\", \"session123\")\n        self.assertEqual(result, \"https://example.com/callback?state=session123\")\n\n    def test_same_domain_absolute_url(self):\n        \"\"\"Test same domain with absolute callback URL.\"\"\"\n        result = generate_oauth_url(\"https://example.com\", \"https://example.com/cb\", \"sess_id\")\n        self.assertEqual(result, \"https://example.com/cb?state=sess_id\")\n\n    def test_allowed_external_domain(self):\n        \"\"\"Test allowed external domain in ALLOWED_CALLBACK_DOMAINS.\"\"\"\n        result = generate_oauth_url(\"https://example.com\", \"https://trusted.org/cb\", \"abc\")\n        self.assertEqual(result, \"https://trusted.org/cb?state=abc\")\n\n    def test_invalid_domain_raises_valueerror(self):\n        \"\"\"Test invalid domain not matching base or allowed domains.\"\"\"\n        with self.assertRaises(ValueError):\n            generate_oauth_url(\"https://example.com\", \"https://malicious.com/cb\", \"sid\")\n\n    def test_base_url_with_path(self):\n        \"\"\"Test base URL containing a path component.\"\"\"\n        result = generate_oauth_url(\"https://example.com/app\", \"/auth\", \"s123\")\n        self.assertEqual(result, \"https://example.com/auth?state=s123\")\n\n    def test_relative_callback_no_leading_slash(self):\n        \"\"\"Test relative callback path without leading slash.\"\"\"\n        result = generate_oauth_url(\"https://example.com/app\", \"callback\", \"id456\")\n        self.assertEqual(result, \"https://example.com/app/callback?state=id456\")\n\n    def test_session_id_url_encoding(self):\n        \"\"\"Test session ID with special characters is properly URL-encoded.\"\"\"\n        session_id = \"session!@# $%^&*()\"\n        result = generate_oauth_url(\"https://example.com\", \"/cb\", session_id)\n        encoded_state = urllib.parse.quote(session_id)\n        self.assertEqual(result, f\"https://example.com/cb?state={encoded_state}\")\n\n    def test_empty_host_relative_callback(self):\n        \"\"\"Test empty host URL with relative callback (both netloc empty).\"\"\"\n        result = generate_oauth_url(\"\", \"/callback\", \"empty123\")\n        self.assertEqual(result, \"/callback?state=empty123\")\n\n    def test_empty_host_allowed_external(self):\n        \"\"\"Test empty host URL with allowed external domain.\"\"\"\n        result = generate_oauth_url(\"\", \"https://trusted.org/cb\", \"xyz\")\n        self.assertEqual(result, \"https://trusted.org/cb?state=xyz\")\n\n    def test_empty_host_invalid_domain(self):\n        \"\"\"Test empty host URL with invalid external domain raises error.\"\"\"\n        with self.assertRaises(ValueError):\n            generate_oauth_url(\"\", \"https://evil.com/cb\", \"sid\")\n\n    def test_callback_with_existing_query(self):\n        \"\"\"Test callback path containing existing query parameters.\"\"\"\n        result = generate_oauth_url(\"https://example.com\", \"/cb?param=value\", \"qid\")\n        self.assertEqual(result, \"https://example.com/cb?param=value?state=qid\")\n\n    def test_base_url_trailing_slash(self):\n        \"\"\"Test base URL with trailing slash and relative callback.\"\"\"\n        result = generate_oauth_url(\"https://example.com/\", \"callback\", \"trail\")\n        self.assertEqual(result, \"https://example.com/callback?state=trail\")\n\n    def test_callback_absolute_url_with_query(self):\n        \"\"\"Test absolute callback URL with existing query parameters.\"\"\"\n        result = generate_oauth_url(\"https://example.com\", \"https://example.com/cb?p=1\", \"sid\")\n        self.assertEqual(result, \"https://example.com/cb?p=1?state=sid\")\n\n    def test_none_session_id(self):\n        \"\"\"Test None session_id should be URL-encoded.\"\"\"\n        result = generate_oauth_url(\"https://example.com\", \"/cb\", None)\n        self.assertEqual(result, \"https://example.com/cb?state=None\")\n\n    def test_empty_session_id(self):\n        \"\"\"Test empty session_id is handled correctly.\"\"\"\n        result = generate_oauth_url(\"https://example.com\", \"/cb\", \"\")\n        self.assertEqual(result, \"https://example.com/cb?state=\")\n\n    def test_large_session_id(self):\n        \"\"\"Test very large session ID string.\"\"\"\n        large_id = \"a\" * 2000\n        result = generate_oauth_url(\"https://example.com\", \"/cb\", large_id)\n        self.assertIn(\"state=\" + large_id, result)\n\n    def test_invalid_host_url(self):\n        \"\"\"Test invalid host URL format.\"\"\"\n        with self.assertRaises(ValueError):\n            generate_oauth_url(\"invalid_url\", \"/cb\", \"sid\")\n\n    def test_callback_netloc_empty_after_join(self):\n        \"\"\"Test callback URL with empty netloc after join is allowed.\"\"\"\n        result = generate_oauth_url(\"\", \"\", \"sid\")\n        self.assertEqual(result, \"?state=sid\")\n\n    def test_base_url_null_byte(self):\n        \"\"\"Test host_url with null byte raises during parsing.\"\"\"\n        with self.assertRaises(ValueError):\n            generate_oauth_url(\"https://example.com\\x00\", \"/cb\", \"sid\")", "num_test_cases": 19, "task_id": "928d3730"}
{"test": "import unittest\nimport urllib.parse\n\n# Define the set of allowed callback domains for the tests\nALLOWED_CALLBACK_DOMAINS = {'example.com', 'trusted.org'}\n\nclass TestAssembleOauthCallback(unittest.TestCase):\n\n    def test_happy_path_same_domain(self):\n        # Test typical inputs with same domain\n        result = assemble_oauth_callback('https://example.com', '/callback', 'abc123')\n        self.assertEqual(result, 'https://example.com/callback?state=abc123')\n\n    def test_happy_path_with_port(self):\n        # Test domain with port number\n        result = assemble_oauth_callback('http://localhost:5000', '/oauth', 'xyz789')\n        self.assertEqual(result, 'http://localhost:5000/oauth?state=xyz789')\n\n    def test_base_url_with_path(self):\n        # Test base URL containing a path component\n        result = assemble_oauth_callback('https://example.com/app', 'callback', 'state1')\n        self.assertEqual(result, 'https://example.com/callback?state=state1')\n\n    def test_trailing_slash_base_url(self):\n        # Test base URL with trailing slash and relative route\n        result = assemble_oauth_callback('https://example.com/base/', 'callback', 's1')\n        self.assertEqual(result, 'https://example.com/base/callback?state=s1')\n\n    def test_absolute_callback_same_domain(self):\n        # Test absolute callback URL matching base domain\n        result = assemble_oauth_callback('https://example.com', 'https://example.com/cb', 'st')\n        self.assertEqual(result, 'https://example.com/cb?state=st')\n\n    def test_allowed_external_domain(self):\n        # Test callback URL in allowed external domains\n        result = assemble_oauth_callback('https://example.com', 'https://trusted.org/oauth', 'token')\n        self.assertEqual(result, 'https://trusted.org/oauth?state=token')\n\n    def test_disallowed_external_domain(self):\n        # Test callback URL not in allowed domains\n        with self.assertRaises(ValueError):\n            assemble_oauth_callback('https://example.com', 'https://malicious.com/cb', 'state')\n\n    def test_empty_application_url(self):\n        # Test with empty application URL\n        result = assemble_oauth_callback('', 'callback', 'empty_url')\n        self.assertEqual(result, 'callback?state=empty_url')\n\n    def test_special_characters_token_state(self):\n        # Test token state with special characters\n        token = \"state!@#$%^&*()_+-=[]{}|;:'\\\",.<>/?\"\n        quoted = urllib.parse.quote(token)\n        result = assemble_oauth_callback('https://example.com', '/cb', token)\n        self.assertEqual(result, f'https://example.com/cb?state={quoted}')\n\n    def test_relative_path_with_parent(self):\n        # Test callback route with relative parent path\n        result = assemble_oauth_callback('https://example.com/base/path', '../cb', 'rel')\n        self.assertEqual(result, 'https://example.com/base/cb?state=rel')\n\n    def test_none_application_url(self):\n        # Test None for application_url\n        with self.assertRaises(TypeError):\n            assemble_oauth_callback(None, '/cb', 'state')\n\n    def test_none_callback_route(self):\n        # Test None for callback_route\n        with self.assertRaises(TypeError):\n            assemble_oauth_callback('https://example.com', None, 'state')\n\n    def test_none_token_state(self):\n        # Test None for token_state\n        with self.assertRaises(TypeError):\n            assemble_oauth_callback('https://example.com', '/cb', None)\n\n    def test_empty_token_state(self):\n        # Test empty token_state\n        result = assemble_oauth_callback('https://example.com', '/cb', '')\n        self.assertEqual(result, 'https://example.com/cb?state=')\n\n    def test_long_token_state(self):\n        # Test very long token_state\n        long_token = 'a' * 1000\n        quoted = urllib.parse.quote(long_token)\n        result = assemble_oauth_callback('https://example.com', '/cb', long_token)\n        self.assertEqual(result, f'https://example.com/cb?state={quoted}')\n\n    def test_different_ports_same_domain(self):\n        # Test same domain but different ports (should fail)\n        with self.assertRaises(ValueError):\n            assemble_oauth_callback('https://example.com:8000', 'https://example.com:8080/cb', 'state')\n\n    def test_allowed_domain_different_port(self):\n        # Test allowed domain with different port\n        result = assemble_oauth_callback('https://example.com', 'https://trusted.org:8080/cb', 'port')\n        self.assertEqual(result, 'https://trusted.org:8080/cb?state=port')\n\n    def test_invalid_url_scheme(self):\n        # Test invalid URL scheme in application_url\n        with self.assertRaises(ValueError):\n            assemble_oauth_callback('invalid://url', '/cb', 'state')", "num_test_cases": 19, "task_id": "03cc08b8"}
{"test": "import unittest\n\nclass TestGenerateExternalResourceUrl(unittest.TestCase):\n    def test_basic_functionality(self):\n        # Test typical inputs with allowed CDN domain\n        result = generate_external_resource_url('https://cdn.example.com', '12345', 'image')\n        self.assertEqual(result, 'https://cdn.example.com/image/12345')\n\n    def test_cdn_base_with_trailing_slash(self):\n        # Test CDN base URL with trailing slash\n        result = generate_external_resource_url('https://cdn.example.com/', 'abc', 'script')\n        self.assertEqual(result, 'https://cdn.example.com/script/abc')\n\n    def test_allowed_port_in_cdn(self):\n        # Test CDN base with allowed port specification\n        result = generate_external_resource_url('http://cdn.another.net:8080', 'resource1', 'asset')\n        self.assertEqual(result, 'http://cdn.another.net:8080/asset/resource1')\n\n    def test_case_insensitive_domain_failure(self):\n        # Test CDN domain in different case (should fail due to case sensitivity)\n        with self.assertRaises(ValueError):\n            generate_external_resource_url('https://CDN.EXAMPLE.COM', '123', 'image')\n\n    def test_invalid_cdn_domain(self):\n        # Test with a CDN domain not in allowed set\n        with self.assertRaises(ValueError):\n            generate_external_resource_url('https://invalid.cdn.com', 'id123', 'data')\n\n    def test_empty_resource_id(self):\n        # Test with empty resource ID\n        result = generate_external_resource_url('https://cdn.example.com', '', 'image')\n        self.assertEqual(result, 'https://cdn.example.com/image/')\n\n    def test_empty_resource_type(self):\n        # Test with empty resource type\n        result = generate_external_resource_url('https://cdn.example.com', '123', '')\n        self.assertEqual(result, 'https://cdn.example.com//123')\n\n    def test_special_characters_in_resource(self):\n        # Test special characters in resource type and ID\n        result = generate_external_resource_url('https://cdn.example.com', 'file name?', 'type#test')\n        self.assertEqual(result, 'https://cdn.example.com/type%23test/file%20name%3F')\n\n    def test_long_resource_inputs(self):\n        # Test with very long resource type and ID\n        long_str = 'A' * 1000\n        result = generate_external_resource_url('https://cdn.example.com', long_str, long_str)\n        self.assertEqual(result, f'https://cdn.example.com/{long_str}/{long_str}')\n\n    def test_none_cdn_base(self):\n        # Test None for cdn_base (should raise TypeError)\n        with self.assertRaises(TypeError):\n            generate_external_resource_url(None, '123', 'image')\n\n    def test_none_resource_id(self):\n        # Test None for res_id (should raise TypeError)\n        with self.assertRaises(TypeError):\n            generate_external_resource_url('https://cdn.example.com', None, 'image')\n\n    def test_none_resource_type(self):\n        # Test None for res_type (should raise TypeError)\n        with self.assertRaises(TypeError):\n            generate_external_resource_url('https://cdn.example.com', '123', None)\n\n    def test_empty_cdn_base(self):\n        # Test empty CDN base string (should fail domain check)\n        with self.assertRaises(ValueError):\n            generate_external_resource_url('', '123', 'image')\n\n    def test_cdn_base_with_fragment(self):\n        # Test CDN base containing fragment\n        result = generate_external_resource_url('https://cdn.example.com#frag', '123', 'image')\n        self.assertEqual(result, 'https://cdn.example.com/image/123')\n\n    def test_cdn_base_with_query(self):\n        # Test CDN base containing query parameters\n        result = generate_external_resource_url('https://cdn.example.com?key=value', '123', 'image')\n        self.assertEqual(result, 'https://cdn.example.com/image/123')\n\n    def test_port_not_in_allowed_set(self):\n        # Test CDN base with port that is not allowed (e.g., 443 when not explicitly defined)\n        with self.assertRaises(ValueError):\n            generate_external_resource_url('https://cdn.example.com:443', '123', 'image')", "num_test_cases": 16, "task_id": "1bfce76e"}
{"test": "import unittest\nimport urllib.parse\n\n# Global variable required by the function\nALLOWED_CDN_DOMAINS = {'cdn.example.com', 'assets.example.net'}\n\nclass TestCreateCdnResourceLink(unittest.TestCase):\n    def test_valid_base_and_resource(self):\n        \"\"\"Test typical case with valid base URL and resource.\"\"\"\n        result = create_cdn_resource_link('https://cdn.example.com', 'logo.png', 'image')\n        self.assertEqual(result, 'https://cdn.example.com/image/logo.png')\n\n    def test_another_valid_domain(self):\n        \"\"\"Test another allowed CDN domain.\"\"\"\n        result = create_cdn_resource_link('https://assets.example.net', 'script.js', 'script')\n        self.assertEqual(result, 'https://assets.example.net/script/script.js')\n\n    def test_trailing_slash_in_base(self):\n        \"\"\"Test base URL with trailing slash.\"\"\"\n        result = create_cdn_resource_link('https://cdn.example.com/', 'logo.png', 'image')\n        self.assertEqual(result, 'https://cdn.example.com/image/logo.png')\n\n    def test_no_trailing_slash_in_base(self):\n        \"\"\"Test base URL without trailing slash.\"\"\"\n        result = create_cdn_resource_link('https://cdn.example.com', 'logo.png', 'image')\n        self.assertEqual(result, 'https://cdn.example.com/image/logo.png')\n\n    def test_special_chars_in_resource(self):\n        \"\"\"Test resource identifier with special characters.\"\"\"\n        result = create_cdn_resource_link('https://cdn.example.com', 'image@1 $%.png', 'images')\n        self.assertEqual(result, 'https://cdn.example.com/images/image@1 $%.png')\n        self.assertTrue(urllib.parse.urlparse(result).netloc in ALLOWED_CDN_DOMAINS)\n\n    def test_empty_resource_identifier(self):\n        \"\"\"Test empty resource identifier.\"\"\"\n        result = create_cdn_resource_link('https://cdn.example.com', '', 'image')\n        self.assertEqual(result, 'https://cdn.example.com/image/')\n\n    def test_empty_type_of_resource(self):\n        \"\"\"Test empty resource type.\"\"\"\n        result = create_cdn_resource_link('https://cdn.example.com', 'resource123', '')\n        self.assertEqual(result, 'https://cdn.example.com//resource123')\n\n    def test_base_url_with_path(self):\n        \"\"\"Test base URL containing a path component.\"\"\"\n        result = create_cdn_resource_link('https://cdn.example.com/base/', 'res', 'type')\n        self.assertEqual(result, 'https://cdn.example.com/type/res')\n\n    def test_empty_base_url(self):\n        \"\"\"Test empty base URL which should raise ValueError.\"\"\"\n        with self.assertRaises(ValueError):\n            create_cdn_resource_link('', 'resource123', 'type')\n\n    def test_invalid_domain(self):\n        \"\"\"Test base URL with domain not in allowed set.\"\"\"\n        with self.assertRaises(ValueError):\n            create_cdn_resource_link('https://invalid.com', 'resource', 'type')\n\n    def test_none_base_url(self):\n        \"\"\"Test None for base URL which should raise TypeError.\"\"\"\n        with self.assertRaises(TypeError):\n            create_cdn_resource_link(None, 'resource', 'type')\n\n    def test_none_resource_identifier(self):\n        \"\"\"Test None for resource identifier which should raise TypeError.\"\"\"\n        with self.assertRaises(TypeError):\n            create_cdn_resource_link('https://cdn.example.com', None, 'type')\n\n    def test_none_resource_type(self):\n        \"\"\"Test None for resource type which should raise TypeError.\"\"\"\n        with self.assertRaises(TypeError):\n            create_cdn_resource_link('https://cdn.example.com', 'resource', None)", "num_test_cases": 13, "task_id": "01a66fb5"}
{"test": "import unittest\nfrom unittest.mock import patch\nimport urllib.parse\n\n# Mocking the function's module for ALLOWED_CDN_DOMANS\nclass TestBuildExternalResourceLink(unittest.TestCase):\n\n    @patch('external_resource_module.ALLOWED_CDN_DOMAINS', {'cdn.example.com', 'assets.example.net'})\n    def test_happy_path_allowed_domain(self):\n        \"\"\"Test with valid inputs and allowed CDN domain.\"\"\"\n        result = build_external_resource_link('https://cdn.example.com', 'image123.jpg', 'images')\n        self.assertEqual(result, 'https://cdn.example.com/images/image123.jpg')\n\n    def test_domain_not_allowed(self):\n        \"\"\"Test with a domain not in ALLOWED_CDN_DOMAINS should raise ValueError.\"\"\"\n        with patch('external_resource_module.ALLOWED_CDN_DOMAINS', {'allowed.com'}):\n            with self.assertRaises(ValueError) as context:\n                build_external_resource_link('https://notallowed.com', 'resource', 'type')\n            self.assertIn('Invalid CDN domain', str(context.exception))\n\n    @patch('external_resource_module.ALLOWED_CDN_DOMAINS', {'cdn.example.com'})\n    def test_empty_resource_key(self):\n        \"\"\"Test with empty resource_key and allowed domain.\"\"\"\n        result = build_external_resource_link('https://cdn.example.com', '', 'scripts')\n        self.assertEqual(result, 'https://cdn.example.com/scripts/')\n\n    @patch('external_resource_module.ALLOWED_CDN_DOMAINS', {'cdn.example.com'})\n    def test_empty_res_category(self):\n        \"\"\"Test with empty res_category and allowed domain.\"\"\"\n        result = build_external_resource_link('https://cdn.example.com', 'main.js', '')\n        self.assertEqual(result, 'https://cdn.example.com//main.js')\n\n    @patch('external_resource_module.ALLOWED_CDN_DOMAINS', {'cdn.example.com'})\n    def test_trailing_slash_in_cdn_url(self):\n        \"\"\"Test CDN URL with trailing slash constructs correct resource URL.\"\"\"\n        result = build_external_resource_link('https://cdn.example.com/base/', 'image.jpg', 'images')\n        self.assertEqual(result, 'https://cdn.example.com/images/image.jpg')\n\n    def test_non_string_cdn_url(self):\n        \"\"\"Test non-string cdn_url should raise TypeError.\"\"\"\n        with self.assertRaises(TypeError):\n            build_external_resource_link(123, 'resource', 'type')\n\n    def test_non_string_resource_key(self):\n        \"\"\"Test non-string resource_key should raise TypeError.\"\"\"\n        with self.assertRaises(TypeError):\n            build_external_resource_link('https://cdn.example.com', 456, 'type')\n\n    def test_non_string_res_category(self):\n        \"\"\"Test non-string res_category should raise TypeError.\"\"\"\n        with self.assertRaises(TypeError):\n            build_external_resource_link('https://cdn.example.com', 'resource', 789)\n\n    @patch('external_resource_module.ALLOWED_CDN_DOMAINS', {'cdn.example.com'})\n    def test_very_long_resource_key(self):\n        \"\"\"Test with a very long resource_key (10,000 characters).\"\"\"\n        long_key = 'a' * 10000\n        result = build_external_resource_link('https://cdn.example.com', long_key, 'data')\n        self.assertIn(long_key, result)\n        self.assertTrue(result.startswith('https://cdn.example.com/data/'))\n\n    @patch('external_resource_module.ALLOWED_CDN_DOMAINS', {'cdn.example.com'})\n    def test_relative_cdn_url(self):\n        \"\"\"Test with a relative URL (should have empty netloc and fail).\"\"\"\n        with self.assertRaises(ValueError) as context:\n            build_external_resource_link('images', 'test.jpg', 'category')\n        self.assertIn('Invalid CDN domain', str(context.exception))\n", "num_test_cases": 10, "task_id": "da6d99d3"}
{"test": "import unittest\nimport inspect\n\nclass TestCases(unittest.TestCase):\n    def setUp(self):\n        # Get the module where the function is defined and set allowed domains\n        self.module = inspect.getmodule(create_external_resource_link)\n        self.original_allowed = getattr(self.module, 'ALLOWED_CDN_DOMAINS', None)\n        self.module.ALLOWED_CDN_DOMAINS = ['cdn.example.com', 'assets.example.net']\n\n    def tearDown(self):\n        # Restore the original ALLOWED_CDN_DOMAINS\n        if self.original_allowed is not None:\n            self.module.ALLOWED_CDN_DOMAINS = self.original_allowed\n        else:\n            try:\n                delattr(self.module, 'ALLOWED_CDN_DOMAINS')\n            except AttributeError:\n                pass\n\n    def test_case_1(self):\n        # Happy path: basic valid inputs\n        result = create_external_resource_link('https://cdn.example.com', '12345', 'image')\n        self.assertEqual(result, 'https://cdn.example.com/image/12345')\n\n    def test_case_2(self):\n        # Happy path: different allowed domain\n        result = create_external_resource_link('http://assets.example.net', 'abcde', 'script')\n        self.assertEqual(result, 'http://assets.example.net/script/abcde')\n\n    def test_case_3(self):\n        # Edge case: empty resource ID\n        result = create_external_resource_link('https://cdn.example.com', '', 'image')\n        self.assertEqual(result, 'https://cdn.example.com/image/')\n\n    def test_case_4(self):\n        # Edge case: empty resource type (should result in network-path reference and invalid domain)\n        with self.assertRaises(ValueError):\n            create_external_resource_link('https://cdn.example.com', '12345', '')\n\n    def test_case_5(self):\n        # Edge case: resource ID with space\n        result = create_external_resource_link('https://cdn.example.com', 'abc def', 'image')\n        self.assertEqual(result, 'https://cdn.example.com/image/abc def')\n\n    def test_case_6(self):\n        # Error case: CDN domain not in allowed list\n        with self.assertRaises(ValueError):\n            create_external_resource_link('https://evil.com', '12345', 'image')\n\n    def test_case_7(self):\n        # Error case: resource ID is None\n        with self.assertRaises(TypeError):\n            create_external_resource_link('https://cdn.example.com', None, 'image')\n\n    def test_case_8(self):\n        # Error case: resource type is None\n        with self.assertRaises(TypeError):\n            create_external_resource_link('https://cdn.example.com', '12345', None)\n\n    def test_case_9(self):\n        # Error case: CDN URL is None\n        with self.assertRaises(TypeError):\n            create_external_resource_link(None, '12345', 'image')\n\n    def test_case_10(self):\n        # Edge case: very long resource ID\n        long_id = 'x' * 1000\n        result = create_external_resource_link('https://cdn.example.com', long_id, 'image')\n        self.assertEqual(result, f'https://cdn.example.com/image/{long_id}')\n\n    def test_case_11(self):\n        # CDN URL with trailing slash in path\n        result = create_external_resource_link('https://cdn.example.com/base/', '123', 'image')\n        self.assertEqual(result, 'https://cdn.example.com/image/123')\n\n    def test_case_12(self):\n        # CDN URL without trailing slash in path\n        result = create_external_resource_link('https://cdn.example.com/base', '123', 'image')\n        self.assertEqual(result, 'https://cdn.example.com/image/123')", "num_test_cases": 12, "task_id": "090269ea"}
{"test": "import unittest\nimport urllib.parse\n\n# Define the allowed CDN domains for the test environment\nALLOWED_CDN_DOMAINS = {'cdn.example.com', 'cdn2.example.com'}\n\nclass TestBuildCDNResourceURL(unittest.TestCase):\n    \n    def test_typical_case(self):\n        # Test with valid inputs and allowed domain\n        result = build_cdn_resource_url('https://cdn.example.com', '123', 'image')\n        self.assertEqual(result, 'https://cdn.example.com/image/123')\n    \n    def test_base_url_without_trailing_slash(self):\n        # Test base URL without trailing slash\n        result = build_cdn_resource_url('https://cdn.example.com', 'file123', 'script')\n        self.assertEqual(result, 'https://cdn.example.com/script/file123')\n    \n    def test_base_url_with_trailing_slash(self):\n        # Test base URL with trailing slash\n        result = build_cdn_resource_url('https://cdn.example.com/', 'file123', 'script')\n        self.assertEqual(result, 'https://cdn.example.com/script/file123')\n    \n    def test_base_url_with_path(self):\n        # Test base URL containing a path, which should be replaced by the absolute resource path\n        result = build_cdn_resource_url('https://cdn.example.com/base/path/', '123', 'image')\n        self.assertEqual(result, 'https://cdn.example.com/image/123')\n    \n    def test_empty_file_id(self):\n        # Test with empty file_id\n        result = build_cdn_resource_url('https://cdn.example.com', '', 'image')\n        self.assertEqual(result, 'https://cdn.example.com/image/')\n    \n    def test_empty_file_type_raises_error(self):\n        # Test empty file_type leading to domain change to non-allowed domain\n        with self.assertRaises(ValueError):\n            build_cdn_resource_url('https://cdn.example.com', 'test', '')\n    \n    def test_empty_file_type_with_allowed_domain(self):\n        # Test empty file_type leading to domain change to an allowed domain\n        result = build_cdn_resource_url('https://cdn.example.com', '//cdn2.example.com', '')\n        self.assertEqual(result, 'https://cdn2.example.com')\n    \n    def test_empty_file_type_with_non_allowed_domain(self):\n        # Test empty file_type leading to domain change to a non-allowed domain\n        with self.assertRaises(ValueError):\n            build_cdn_resource_url('https://cdn.example.com', '//malicious.com', '')\n    \n    def test_non_string_cdn_url_base_raises_error(self):\n        # Test non-string cdn_url_base raises TypeError\n        with self.assertRaises(TypeError):\n            build_cdn_resource_url(123, '123', 'image')\n    \n    def test_non_string_file_id_raises_error(self):\n        # Test non-string file_id raises TypeError\n        with self.assertRaises(TypeError):\n            build_cdn_resource_url('https://cdn.example.com', 123, 'image')\n    \n    def test_non_string_file_type_raises_error(self):\n        # Test non-string file_type raises TypeError\n        with self.assertRaises(TypeError):\n            build_cdn_resource_url('https://cdn.example.com', '123', 123)\n    \n    def test_non_allowed_domain_raises_error(self):\n        # Test base URL with non-allowed domain\n        with self.assertRaises(ValueError):\n            build_cdn_resource_url('https://invalid.com', '123', 'image')\n    \n    def test_empty_cdn_url_base_raises_error(self):\n        # Test empty base URL string resulting in empty domain\n        with self.assertRaises(ValueError):\n            build_cdn_resource_url('', '123', 'image')\n    \n    def test_relative_cdn_url_base_raises_error(self):\n        # Test relative path as base URL resulting in empty domain\n        with self.assertRaises(ValueError):\n            build_cdn_resource_url('path/to/cdn', '123', 'image')\n    \n    def test_special_characters_in_file_id(self):\n        # Test file_id with special characters (space)\n        result = build_cdn_resource_url('https://cdn.example.com', 'file id', 'image')\n        self.assertEqual(result, 'https://cdn.example.com/image/file id')\n    \n    def test_long_file_id(self):\n        # Test very long file_id\n        long_id = 'a' * 1000\n        result = build_cdn_resource_url('https://cdn.example.com', long_id, 'image')\n        self.assertEqual(result, f'https://cdn.example.com/image/{long_id}')\n", "num_test_cases": 16, "task_id": "e77073d0"}
{"test": "import unittest\nimport urllib.parse\n\n# Define the allowed CDN domains for testing\nALLOWED_CDN_DOMAINS = {'cdn.example.com', 'cdn.example.net:8080', '127.0.0.1', 'localhost'}\n\n# The function to test (reproduced for self-contained test environment)\ndef generate_cdn_content_url(cdn_origin_url, content_id, content_kind):\n    parsed_cdn_url = urllib.parse.urlparse(cdn_origin_url)\n    content_path = f\"/{content_kind}/{content_id}\"\n    complete_url = urllib.parse.urljoin(cdn_origin_url, content_path)\n    parsed_complete_url = urllib.parse.urlparse(complete_url)\n    if parsed_complete_url.netloc not in ALLOWED_CDN_DOMAINS:\n        raise ValueError(\"Invalid CDN domain in constructed URL\")\n    return complete_url\n\nclass TestGenerateCDNContentUrl(unittest.TestCase):\n    \n    def test_happy_path_standard(self):\n        # Test typical inputs with allowed domain\n        result = generate_cdn_content_url('http://cdn.example.com', '12345', 'image')\n        self.assertEqual(result, 'http://cdn.example.com/image/12345')\n        \n    def test_happy_path_with_port(self):\n        # Test domain with port number\n        result = generate_cdn_content_url('http://cdn.example.net:8080', 'abc', 'script')\n        self.assertEqual(result, 'http://cdn.example.net:8080/script/abc')\n    \n    def test_empty_content_id(self):\n        # Test empty content_id results in trailing slash\n        result = generate_cdn_content_url('http://cdn.example.com', '', 'image')\n        self.assertEqual(result, 'http://cdn.example.com/image/')\n    \n    def test_empty_content_kind_leading_to_netloc_change(self):\n        # Test empty content_kind creates double-slash, changing netloc to invalid domain\n        with self.assertRaises(ValueError):\n            generate_cdn_content_url('http://cdn.example.com', 'evil.com', '')\n    \n    def test_content_id_with_space(self):\n        # Test content_id with space in path\n        result = generate_cdn_content_url('http://cdn.example.com', 'file name', 'image')\n        self.assertEqual(result, 'http://cdn.example.com/image/file name')\n    \n    def test_content_id_with_slash(self):\n        # Test content_id containing slash\n        result = generate_cdn_content_url('http://cdn.example.com', 'path/to/file', 'resource')\n        self.assertEqual(result, 'http://cdn.example.com/resource/path/to/file')\n    \n    def test_base_url_with_path_and_query(self):\n        # Test base URL has path/query replaced by content_path\n        result = generate_cdn_content_url('http://cdn.example.com/base?query=1', '123', 'image')\n        self.assertEqual(result, 'http://cdn.example.com/image/123')\n    \n    def test_invalid_base_domain(self):\n        # Test base URL not in allowed domains\n        with self.assertRaises(ValueError):\n            generate_cdn_content_url('http://malicious.com', '123', 'image')\n    \n    def test_none_base_url(self):\n        # Test None as base URL raises TypeError\n        with self.assertRaises(TypeError):\n            generate_cdn_content_url(None, '123', 'image')\n    \n    def test_empty_base_url(self):\n        # Test empty base URL results in empty netloc (invalid)\n        with self.assertRaises(ValueError):\n            generate_cdn_content_url('', '123', 'image')\n    \n    def test_relative_base_url(self):\n        # Test relative path base URL results in empty netloc\n        with self.assertRaises(ValueError):\n            generate_cdn_content_url('path/to/cdn', '123', 'image')\n    \n    def test_base_url_with_trailing_slash(self):\n        # Test base URL with trailing slash\n        result = generate_cdn_content_url('http://cdn.example.com/', '123', 'image')\n        self.assertEqual(result, 'http://cdn.example.com/image/123')\n    \n    def test_integer_content_id(self):\n        # Test integer content_id converts to string\n        result = generate_cdn_content_url('http://cdn.example.com', 123, 'image')\n        self.assertEqual(result, 'http://cdn.example.com/image/123')\n    \n    def test_long_content_id(self):\n        # Test very long content_id\n        long_id = 'a' * 1000\n        result = generate_cdn_content_url('http://cdn.example.com', long_id, 'file')\n        self.assertEqual(result, f'http://cdn.example.com/file/{long_id}')\n    \n    def test_integer_content_kind(self):\n        # Test integer content_kind converts to string\n        result = generate_cdn_content_url('http://cdn.example.com', '123', 123)\n        self.assertEqual(result, 'http://cdn.example.com/123/123')\n    \n    def test_localhost_allowed(self):\n        # Test localhost in allowed domains\n        result = generate_cdn_content_url('http://localhost', 'resource', 'data')\n        self.assertEqual(result, 'http://localhost/data/resource')\n    \n    def test_ip_address_allowed(self):\n        # Test IP address in allowed domains\n        result = generate_cdn_content_url('http://127.0.0.1', 'img', 'icon')\n        self.assertEqual(result, 'http://127.0.0.1/icon/img')", "num_test_cases": 17, "task_id": "a006d6f7"}
{"test": "import unittest\nimport urllib.parse\n\n# Predefined set of allowed CDN domains for testing\nALLOWED_CDN_DOMAINS = {'cdn.example.com', 'assets.example.net'}\n\nclass TestBuildCdnResourceUrl(unittest.TestCase):\n    def test_case_1(self):\n        # Basic happy path\n        result = build_cdn_resource_url('https://cdn.example.com', '123', 'image')\n        self.assertEqual(result, 'https://cdn.example.com/image/123')\n    \n    def test_case_2(self):\n        # cdn_url with trailing slash\n        result = build_cdn_resource_url('https://cdn.example.com/', '123', 'image')\n        self.assertEqual(result, 'https://cdn.example.com/image/123')\n    \n    def test_case_3(self):\n        # cdn_url with non-empty path (without trailing slash)\n        result = build_cdn_resource_url('https://cdn.example.com/base', '123', 'image')\n        self.assertEqual(result, 'https://cdn.example.com/image/123')\n    \n    def test_case_4(self):\n        # cdn_url with non-empty path and trailing slash\n        result = build_cdn_resource_url('https://cdn.example.com/base/', '123', 'image')\n        self.assertEqual(result, 'https://cdn.example.com/image/123')\n    \n    def test_case_5(self):\n        # resource_identifier with space and slash\n        result = build_cdn_resource_url('https://cdn.example.com', 'a b/c d', 'image')\n        self.assertEqual(result, 'https://cdn.example.com/image/a b/c d')\n    \n    def test_case_6(self):\n        # resource_identifier as integer (converted to string)\n        result = build_cdn_resource_url('https://cdn.example.com', 123, 'image')\n        self.assertEqual(result, 'https://cdn.example.com/image/123')\n    \n    def test_case_7(self):\n        # Empty resource_identifier\n        result = build_cdn_resource_url('https://cdn.example.com', '', 'image')\n        self.assertEqual(result, 'https://cdn.example.com/image/')\n    \n    def test_case_8(self):\n        # Empty resource_kind\n        with self.assertRaises(ValueError):\n            build_cdn_resource_url('https://cdn.example.com', '123', '')\n    \n    def test_case_9(self):\n        # Both resource_kind and resource_identifier empty\n        with self.assertRaises(ValueError):\n            build_cdn_resource_url('https://cdn.example.com', '', '')\n    \n    def test_case_10(self):\n        # Empty cdn_url\n        with self.assertRaises(ValueError):\n            build_cdn_resource_url('', '123', 'image')\n    \n    def test_case_11(self):\n        # cdn_url domain not allowed\n        with self.assertRaises(ValueError):\n            build_cdn_resource_url('https://evil.com', '123', 'image')\n    \n    def test_case_12(self):\n        # Allowed domain (second domain in set)\n        result = build_cdn_resource_url('https://assets.example.net', '123', 'image')\n        self.assertEqual(result, 'https://assets.example.net/image/123')\n    \n    def test_case_13(self):\n        # cdn_url as None (invalid type)\n        with self.assertRaises(TypeError):\n            build_cdn_resource_url(None, '123', 'image')\n    \n    def test_case_14(self):\n        # resource_identifier as None (converted to string)\n        result = build_cdn_resource_url('https://cdn.example.com', None, 'image')\n        self.assertEqual(result, 'https://cdn.example.com/image/None')\n    \n    def test_case_15(self):\n        # resource_kind as None (converted to string)\n        result = build_cdn_resource_url('https://cdn.example.com', '123', None)\n        self.assertEqual(result, 'https://cdn.example.com/None/123')\n    \n    def test_case_16(self):\n        # cdn_url as integer (invalid type)\n        with self.assertRaises(TypeError):\n            build_cdn_resource_url(123, '123', 'image')\n    \n    def test_case_17(self):\n        # resource_identifier with newline\n        result = build_cdn_resource_url('https://cdn.example.com', 'hello\\nworld', 'image')\n        self.assertEqual(result, 'https://cdn.example.com/image/hello\\nworld')", "num_test_cases": 17, "task_id": "1d3b98d8"}
{"test": "import unittest\nfrom unittest.mock import patch\n\n# Define the allowed CDN domains for testing\nALLOWED_CDN_DOMAINS = {\n    'cdn.example.com',\n    'assets.example.net',\n    'cdn.example.com:8080'\n}\n\n# Patch the ALLOWED_CDN_DOMAINS in the function's module\n@patch('solution.ALLOWED_CDN_DOMAINS', ALLOWED_CDN_DOMAINS)\nclass TestGenerateExternalResourceLink(unittest.TestCase):\n\n    def test_valid_domain_no_trailing_slash(self):\n        # Test with valid domain, no trailing slash in base URL\n        result = generate_external_resource_link('https://cdn.example.com', 'logo.png', 'image')\n        self.assertEqual(result, 'https://cdn.example.com/image/logo.png')\n\n    def test_valid_domain_with_trailing_slash(self):\n        # Test with valid domain and trailing slash in base URL\n        result = generate_external_resource_link('https://cdn.example.com/', 'banner.jpg', 'image')\n        self.assertEqual(result, 'https://cdn.example.com/image/banner.jpg')\n\n    def test_valid_domain_with_path(self):\n        # Test valid domain with existing path (should be replaced)\n        result = generate_external_resource_link('https://cdn.example.com/old', 'script.js', 'script')\n        self.assertEqual(result, 'https://cdn.example.com/script/script.js')\n\n    def test_valid_domain_with_port(self):\n        # Test valid domain with allowed port\n        result = generate_external_resource_link('https://cdn.example.com:8080', 'data.json', 'data')\n        self.assertEqual(result, 'https://cdn.example.com:8080/data/data.json')\n\n    def test_valid_alternative_domain(self):\n        # Test valid alternative domain\n        result = generate_external_resource_link('http://assets.example.net', 'style.css', 'style')\n        self.assertEqual(result, 'http://assets.example.net/style/style.css')\n\n    def test_empty_resource_tag(self):\n        # Test with empty resource tag\n        result = generate_external_resource_link('https://cdn.example.com', '', 'image')\n        self.assertEqual(result, 'https://cdn.example.com/image/')\n\n    def test_empty_resource_category(self):\n        # Test with empty resource category\n        result = generate_external_resource_link('https://cdn.example.com', 'app.js', '')\n        self.assertEqual(result, 'https://cdn.example.com//app.js')\n\n    def test_invalid_domain(self):\n        # Test with domain not in allowed list\n        with self.assertRaises(ValueError):\n            generate_external_resource_link('https://invalid.com', 'test.png', 'image')\n\n    def test_empty_base_url(self):\n        # Test with empty base URL\n        with self.assertRaises(ValueError):\n            generate_external_resource_link('', 'resource', 'type')\n\n    def test_invalid_port(self):\n        # Test with unallowed port\n        with self.assertRaises(ValueError):\n            generate_external_resource_link('https://cdn.example.com:8000', 'file.txt', 'text')\n\n    def test_subdomain_not_allowed(self):\n        # Test with subdomain not explicitly allowed\n        with self.assertRaises(ValueError):\n            generate_external_resource_link('https://sub.cdn.example.com', 'asset.png', 'image')\n\n    def test_non_string_cdn_host_url(self):\n        # Test with non-string cdn_host_url\n        with self.assertRaises(TypeError):\n            generate_external_resource_link(123, 'tag', 'type')\n\n    def test_non_string_resource_tag(self):\n        # Test with non-string resource_tag\n        with self.assertRaises(TypeError):\n            generate_external_resource_link('https://cdn.example.com', 123, 'type')\n\n    def test_non_string_resource_category(self):\n        # Test with non-string resource_category\n        with self.assertRaises(TypeError):\n            generate_external_resource_link('https://cdn.example.com', 'tag', 123)\n\n    def test_url_with_query_fragment(self):\n        # Test base URL with query and fragment (should be stripped)\n        result = generate_external_resource_link('https://cdn.example.com?query=value#frag', 'doc.pdf', 'doc')\n        self.assertEqual(result, 'https://cdn.example.com/doc/doc.pdf')\n\n    def test_special_characters_in_resource(self):\n        # Test special characters in resource_tag and resource_category\n        result = generate_external_resource_link('https://cdn.example.com', 'file name.js', 'cat-egory')\n        self.assertEqual(result, 'https://cdn.example.com/cat-egory/file name.js')\n\n    def test_ip_address_not_allowed(self):\n        # Test with IP address domain not in allowed set\n        with self.assertRaises(ValueError):\n            generate_external_resource_link('http://192.168.1.1', 'file', 'type')\n\n    def test_ftp_scheme_valid_domain(self):\n        # Test with FTP scheme but valid domain\n        with self.assertRaises(ValueError):\n            generate_external_resource_link('ftp://cdn.example.com', 'file.txt', 'text')", "num_test_cases": 19, "task_id": "08e119bd"}
{"test": "import unittest\nimport urllib.parse\n\n# Define the allowed CDN domains for the tests\nALLOWED_CDN_DOMAINS = {'cdn.example.com', 'cdn.test.com'}\n\nclass TestCreateResourceUrl(unittest.TestCase):\n\n    def test_basic_valid_url(self):\n        # Test typical inputs with allowed CDN domain\n        result = create_resource_url('http://cdn.example.com', 'img123', 'image')\n        self.assertEqual(result, 'http://cdn.example.com/image/img123')\n\n    def test_trailing_slash_base_url(self):\n        # Test base URL with trailing slash\n        result = create_resource_url('http://cdn.example.com/', 'script456', 'script')\n        self.assertEqual(result, 'http://cdn.example.com/script/script456')\n\n    def test_base_url_with_path(self):\n        # Test base URL containing a path component\n        result = create_resource_url('http://cdn.example.com/base/', '789', 'data')\n        self.assertEqual(result, 'http://cdn.example.com/base/data/789')\n\n    def test_special_characters_in_res_id(self):\n        # Test resource ID with special characters (should not affect netloc)\n        result = create_resource_url('http://cdn.example.com', 'id@special!', 'type')\n        self.assertEqual(result, 'http://cdn.example.com/type/id@special!')\n\n    def test_empty_res_id_and_res_type(self):\n        # Test empty resource ID and type (resulting in double slash)\n        result = create_resource_url('http://cdn.example.com', '', '')\n        self.assertEqual(result, 'http://cdn.example.com//')\n\n    def test_none_res_id_and_res_type(self):\n        # Test None for resource ID and type (converted to 'None')\n        result = create_resource_url('http://cdn.example.com', None, None)\n        self.assertEqual(result, 'http://cdn.example.com/None/None')\n\n    def test_integer_res_id_and_res_type(self):\n        # Test integer resource ID and type (converted to string)\n        result = create_resource_url('http://cdn.example.com', 123, 456)\n        self.assertEqual(result, 'http://cdn.example.com/456/123')\n\n    def test_long_resource_id(self):\n        # Test very long resource ID (1000 characters)\n        long_id = 'a' * 1000\n        result = create_resource_url('http://cdn.example.com', long_id, 'long')\n        self.assertEqual(result, f'http://cdn.example.com/long/{long_id}')\n\n    def test_invalid_netloc(self):\n        # Test base URL with netloc not in allowed set\n        with self.assertRaises(ValueError):\n            create_resource_url('http://cdn.invalid.com', 'res1', 'type')\n\n    def test_valid_port_in_allowed_set(self):\n        # Test base URL with port and allowed set includes port\n        global ALLOWED_CDN_DOMAINS\n        original = ALLOWED_CDN_DOMAINS\n        try:\n            ALLOWED_CDN_DOMAINS = {'cdn.example.com:8000'}\n            result = create_resource_url('http://cdn.example.com:8000', 'res1', 'type')\n            self.assertEqual(result, 'http://cdn.example.com:8000/type/res1')\n        finally:\n            ALLOWED_CDN_DOMAINS = original\n\n    def test_valid_port_not_in_allowed_set(self):\n        # Test base URL with port not in allowed set (default set without port)\n        with self.assertRaises(ValueError):\n            create_resource_url('http://cdn.example.com:8000', 'res1', 'type')\n\n    def test_none_base_cdn_url(self):\n        # Test None for base URL (raises TypeError)\n        with self.assertRaises(TypeError):\n            create_resource_url(None, 'res1', 'type')\n\n    def test_non_string_base_cdn_url(self):\n        # Test integer for base URL (raises TypeError)\n        with self.assertRaises(TypeError):\n            create_resource_url(123, 'res1', 'type')\n\n    def test_res_type_with_special_characters(self):\n        # Test resource type with special characters\n        result = create_resource_url('http://cdn.example.com', 'res1', 'type@special')\n        self.assertEqual(result, 'http://cdn.example.com/type@special/res1')\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 15, "task_id": "cb76bb9b"}
{"test": "import unittest\nimport urllib.parse\n\n# Define the global variables required for the function\nAPPROVED_API_DOMAINS = {'api.example.com', 'safe.api.org'}\nALLOWED_ENDPOINTS = ['/v1/data', '/v2/info', '/user/profile', 'https://api.example.com/absolute']\n\nclass TestConstructApiRedirect(unittest.TestCase):\n\n    def test_case_1(self):\n        # Basic happy path without query parameters\n        result = construct_api_redirect('https://api.example.com', '/v1/data')\n        self.assertEqual(result, 'https://api.example.com/v1/data')\n\n    def test_case_2(self):\n        # Happy path with query parameters\n        result = construct_api_redirect(\n            'https://api.example.com',\n            '/v2/info',\n            {'id': 123, 'format': 'json'}\n        )\n        self.assertEqual(result, 'https://api.example.com/v2/info?id=123&format=json')\n\n    def test_case_3(self):\n        # Base URL with trailing slash and endpoint without leading slash\n        result = construct_api_redirect('https://api.example.com/base/', 'v1/data')\n        self.assertEqual(result, 'https://api.example.com/base/v1/data')\n\n    def test_case_4(self):\n        # Invalid domain in base_url\n        with self.assertRaises(ValueError) as context:\n            construct_api_redirect('https://evil.com', '/v1/data')\n        self.assertEqual(str(context.exception), 'Invalid API domain')\n\n    def test_case_5(self):\n        # Invalid endpoint\n        with self.assertRaises(ValueError) as context:\n            construct_api_redirect('https://api.example.com', '/malicious')\n        self.assertEqual(str(context.exception), 'Invalid API endpoint')\n\n    def test_case_6(self):\n        # Endpoint as absolute URL to malicious domain (not in allowed endpoints)\n        with self.assertRaises(ValueError) as context:\n            construct_api_redirect('https://api.example.com', 'http://evil.com/steal')\n        self.assertEqual(str(context.exception), 'Invalid API endpoint')\n\n    def test_case_7(self):\n        # Endpoint as absolute URL to same domain and in allowed endpoints\n        result = construct_api_redirect('https://api.example.com', 'https://api.example.com/absolute')\n        self.assertEqual(result, 'https://api.example.com/absolute')\n\n    def test_case_8(self):\n        # Endpoint as absolute URL to different approved domain (in allowed endpoints) but fails final domain check\n        # Temporarily add the endpoint to ALLOWED_ENDPOINTS\n        global ALLOWED_ENDPOINTS\n        original_endpoints = ALLOWED_ENDPOINTS\n        ALLOWED_ENDPOINTS = original_endpoints + ['https://safe.api.org/v1/data']\n        try:\n            with self.assertRaises(ValueError) as context:\n                construct_api_redirect('https://api.example.com', 'https://safe.api.org/v1/data')\n            self.assertEqual(str(context.exception), 'Constructed URL does not match the original API domain')\n        finally:\n            ALLOWED_ENDPOINTS = original_endpoints\n\n    def test_case_9(self):\n        # Empty query_options dictionary\n        result = construct_api_redirect('https://api.example.com', '/v1/data', {})\n        self.assertEqual(result, 'https://api.example.com/v1/data')\n\n    def test_case_10(self):\n        # Base URL without trailing slash and endpoint with leading slash\n        result = construct_api_redirect('https://api.example.com/base', '/v1/data')\n        self.assertEqual(result, 'https://api.example.com/v1/data')\n\n    def test_case_11(self):\n        # Query parameters with special characters\n        result = construct_api_redirect(\n            'https://api.example.com',\n            '/search',\n            {'q': 'hello world', 'page': 1}\n        )\n        self.assertEqual(result, 'https://api.example.com/search?q=hello+world&page=1')\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 11, "task_id": "023f370d"}
{"test": "import unittest\nimport urllib.parse\n\n# Define the constants as per the function requirements\nAPPROVED_API_DOMAINS = {'example.com', 'api.example.com', 'safe-domain.org'}\nALLOWED_ENDPOINTS = ['/api/v1/data', '/api/v1/user', '/data']\n\ndef generate_api_redirect(base_url, api_path, params=None):\n    # Parse the API base URL\n    parsed_api_url = urllib.parse.urlparse(base_url)\n    # Validate the API domain\n    if parsed_api_url.netloc not in APPROVED_API_DOMAINS:\n        raise ValueError(\"Invalid API domain\")\n\n    # Validate the endpoint\n    if api_path not in ALLOWED_ENDPOINTS:\n        raise ValueError(\"Invalid API endpoint\")\n\n    # Construct the API redirect URL\n    full_path = urllib.parse.urljoin(base_url, api_path)\n    if params:\n        full_path += '?' + urllib.parse.urlencode(params)\n\n    # Final validation of the constructed URL\n    final_parsed_url = urllib.parse.urlparse(full_path)\n    if final_parsed_url.netloc != parsed_api_url.netloc:\n        raise ValueError(\"Constructed URL does not match the original API domain\")\n\n    return full_path\n\nclass TestGenerateApiRedirect(unittest.TestCase):\n    def test_valid_base_url_and_endpoint_no_params(self):\n        # Happy path: valid base URL and endpoint, no parameters\n        result = generate_api_redirect('https://example.com', '/api/v1/data')\n        self.assertEqual(result, 'https://example.com/api/v1/data')\n    \n    def test_valid_base_url_and_endpoint_with_params(self):\n        # Happy path: valid base URL and endpoint with parameters\n        params = {'id': 123, 'format': 'json'}\n        result = generate_api_redirect('https://api.example.com', '/api/v1/user', params)\n        self.assertEqual(result, 'https://api.example.com/api/v1/user?id=123&format=json')\n    \n    def test_valid_base_url_with_trailing_slash(self):\n        # Valid URL when base URL has trailing slash\n        result = generate_api_redirect('https://safe-domain.org/', '/data')\n        self.assertEqual(result, 'https://safe-domain.org/data')\n    \n    def test_valid_endpoint_with_leading_slash(self):\n        # Valid URL when endpoint has leading slash\n        result = generate_api_redirect('https://example.com', '/api/v1/data')\n        self.assertEqual(result, 'https://example.com/api/v1/data')\n    \n    def test_special_characters_in_params(self):\n        # Parameters with special characters are properly encoded\n        params = {'search': 'hello world', 'key': '!@#$%^&*()'}\n        result = generate_api_redirect('https://api.example.com', '/api/v1/user', params)\n        self.assertEqual(result, 'https://api.example.com/api/v1/user?search=hello+world&key=%21%40%23%24%25%5E%26%2A%28%29')\n    \n    def test_multiple_query_parameters(self):\n        # Multiple query parameters are correctly concatenated\n        params = {'page': 1, 'limit': 10, 'sort': 'desc'}\n        result = generate_api_redirect('https://example.com', '/api/v1/data', params)\n        self.assertIn('page=1', result)\n        self.assertIn('limit=10', result)\n        self.assertIn('sort=desc', result)\n    \n    def test_invalid_domain(self):\n        # Base URL with domain not in approved set\n        with self.assertRaises(ValueError):\n            generate_api_redirect('https://invalid.com', '/api/v1/data')\n    \n    def test_invalid_endpoint(self):\n        # Endpoint not in allowed list\n        with self.assertRaises(ValueError):\n            generate_api_redirect('https://example.com', '/invalid/endpoint')\n    \n    def test_domain_mismatch_after_join(self):\n        # Endpoint attempts to change domain\n        with self.assertRaises(ValueError):\n            generate_api_redirect('https://example.com', 'http://malicious.com/data')\n    \n    def test_empty_params(self):\n        # Empty params dictionary should not affect URL construction\n        result = generate_api_redirect('https://safe-domain.org', '/data', {})\n        self.assertEqual(result, 'https://safe-domain.org/data')\n    \n    def test_none_params(self):\n        # None params should be handled as no params\n        result = generate_api_redirect('https://example.com', '/api/v1/data', None)\n        self.assertEqual(result, 'https://example.com/api/v1/data')\n    \n    def test_subdomain_vs_main_domain(self):\n        # Subdomain (api.example.com) should be valid as it's in approved domains\n        result = generate_api_redirect('https://api.example.com', '/api/v1/data')\n        self.assertEqual(result, 'https://api.example.com/api/v1/data')\n    \n    def test_missing_scheme_in_base_url(self):\n        # Base URL without scheme should still parse and validate domain\n        with self.assertRaises(ValueError):\n            generate_api_redirect('example.com', '/api/v1/data')\n    \n    def test_invalid_url_after_construction(self):\n        # Constructed URL changes domain unexpectedly\n        with self.assertRaises(ValueError):\n            generate_api_redirect('https://example.com', 'https://attacker.com/data')\n    \n    def test_relative_path_manipulation(self):\n        # Endpoint with relative paths that could cause domain change\n        with self.assertRaises(ValueError):\n            generate_api_redirect('https://example.com', '//attacker.com/data')", "num_test_cases": 15, "task_id": "9f6dccd0"}
{"test": "import unittest\nfrom unittest.mock import patch\nimport urllib.parse\nfrom redirect_url_service import create_api_redirect_url\n\n# Define test constants\nTEST_APPROVED_DOMAINS = {'api.example.com', 'subdomain.trusted.org'}\nTEST_ALLOWED_ENDPOINTS = [\n    '/v1/data',\n    'v2/info',\n    'https://api.example.com/absolute/valid',\n    '',\n    'http://subdomain.trusted.org/path'\n]\n\nclass TestCreateApiRedirectUrl(unittest.TestCase):\n    @classmethod\n    def setUpClass(cls):\n        # Patch the global constants in the module\n        cls.patcher1 = patch('redirect_url_service.APPROVED_API_DOMAINS', TEST_APPROVED_DOMAINS)\n        cls.patcher2 = patch('redirect_url_service.ALLOWED_ENDPOINTS', TEST_ALLOWED_ENDPOINTS)\n        cls.patcher1.start()\n        cls.patcher2.start()\n\n    @classmethod\n    def tearDownClass(cls):\n        # Stop patching\n        cls.patcher1.stop()\n        cls.patcher2.stop()\n\n    def test_happy_path_no_opts(self):\n        # Valid domain and endpoint, no opts\n        result = create_api_redirect_url('http://api.example.com', '/v1/data')\n        self.assertEqual(result, 'http://api.example.com/v1/data')\n\n    def test_happy_path_with_opts(self):\n        # Valid domain and endpoint, with opts\n        result = create_api_redirect_url('http://api.example.com', 'v2/info', {'key': 'value'})\n        self.assertEqual(result, 'http://api.example.com/v2/info?key=value')\n\n    def test_absolute_endpoint_same_domain(self):\n        # Absolute endpoint with same netloc as base_url\n        result = create_api_redirect_url('http://api.example.com', 'https://api.example.com/absolute/valid')\n        self.assertEqual(result, 'https://api.example.com/absolute/valid')\n\n    def test_invalid_domain(self):\n        # Domain not in approved list\n        with self.assertRaises(ValueError):\n            create_api_redirect_url('http://untrusted.com', '/v1/data')\n\n    def test_invalid_endpoint(self):\n        # Endpoint not in allowed list\n        with self.assertRaises(ValueError):\n            create_api_redirect_url('http://api.example.com', '/invalid')\n\n    def test_endpoint_causes_netloc_change(self):\n        # Allowed endpoint changes netloc (fails final validation)\n        with self.assertRaises(ValueError):\n            create_api_redirect_url('http://api.example.com', 'http://subdomain.trusted.org/path')\n\n    def test_base_url_none(self):\n        # None for base_url_api\n        with self.assertRaises(TypeError):\n            create_api_redirect_url(None, '/v1/data')\n\n    def test_base_url_non_string(self):\n        # Non-string base_url_api\n        with self.assertRaises(TypeError):\n            create_api_redirect_url(123, '/v1/data')\n\n    def test_endpoint_none(self):\n        # None for endpoint\n        with self.assertRaises(ValueError):\n            create_api_redirect_url('http://api.example.com', None)\n\n    def test_endpoint_non_string(self):\n        # Non-string endpoint\n        with self.assertRaises(ValueError):\n            create_api_redirect_url('http://api.example.com', 123)\n\n    def test_base_url_empty_string(self):\n        # Empty base_url_api\n        with self.assertRaises(ValueError):\n            create_api_redirect_url('', '/v1/data')\n\n    def test_endpoint_empty_string_allowed(self):\n        # Empty endpoint string allowed\n        result = create_api_redirect_url('http://api.example.com', '')\n        self.assertEqual(result, 'http://api.example.com')\n\n    def test_endpoint_empty_string_with_opts(self):\n        # Empty endpoint with opts\n        result = create_api_redirect_url('http://api.example.com', '', {'key': 'value'})\n        self.assertEqual(result, 'http://api.example.com?key=value')\n\n    def test_base_url_no_trailing_slash(self):\n        # Base URL without trailing slash + relative endpoint\n        result = create_api_redirect_url('http://api.example.com/base', 'v2/info')\n        self.assertEqual(result, 'http://api.example.com/v2/info')\n\n    def test_multiple_query_params(self):\n        # Multiple query parameters\n        result = create_api_redirect_url('http://api.example.com', 'v2/info', {'a': '1', 'b': '2'})\n        parsed = urllib.parse.urlparse(result)\n        query_dict = urllib.parse.parse_qs(parsed.query)\n        self.assertEqual(set(query_dict.keys()), set(['a', 'b']))\n        self.assertEqual(query_dict['a'], ['1'])\n        self.assertEqual(query_dict['b'], ['2'])\n\n    def test_query_param_encoding(self):\n        # Query parameters with spaces\n        result = create_api_redirect_url('http://api.example.com', 'v2/info', {'key': 'value with space'})\n        parsed = urllib.parse.urlparse(result)\n        self.assertEqual(parsed.query, 'key=value+with+space')\n\n    def test_base_url_trailing_slash(self):\n        # Base URL with trailing slash + endpoint with leading slash\n        result = create_api_redirect_url('http://api.example.com/', '/v1/data')\n        self.assertEqual(result, 'http://api.example.com/v1/data')\n\n    def test_base_url_path_trailing_slash(self):\n        # Base URL with path and trailing slash + relative endpoint\n        result = create_api_redirect_url('http://api.example.com/base/', 'v2/info')\n        self.assertEqual(result, 'http://api.example.com/base/v2/info')\n\n    def test_opts_none(self):\n        # None for opts\n        result = create_api_redirect_url('http://api.example.com', '/v1/data', None)\n        self.assertEqual(result, 'http://api.example.com/v1/data')", "num_test_cases": 19, "task_id": "d0bd825a"}
{"test": "import unittest\nfrom unittest.mock import patch\n\nclass TestCreateApiRedirectLink(unittest.TestCase):\n\n    def setUp(self):\n        \"\"\"Set up approved domains and allowed endpoints for the tests.\"\"\"\n        self.approved_domains = {'example.com', 'api.example.com'}\n        self.allowed_endpoints = ['/endpoint1', '/endpoint2', '']\n        self.domain_patcher = patch('__main__.APPROVED_API_DOMAINS', self.approved_domains)\n        self.endpoint_patcher = patch('__main__.ALLOWED_ENDPOINTS', self.allowed_endpoints)\n        self.domain_patcher.start()\n        self.endpoint_patcher.start()\n\n    def tearDown(self):\n        \"\"\"Stop patchers after tests complete.\"\"\"\n        self.domain_patcher.stop()\n        self.endpoint_patcher.stop()\n\n    def test_basic_url_no_params(self):\n        \"\"\"Test basic URL construction without parameters.\"\"\"\n        result = create_api_redirect_link('https://example.com', '/endpoint1')\n        self.assertEqual(result, 'https://example.com/endpoint1')\n\n    def test_with_params(self):\n        \"\"\"Test URL construction with query parameters.\"\"\"\n        params = {'key1': 'value1', 'key2': 'value2'}\n        result = create_api_redirect_link('https://example.com', '/endpoint1', params)\n        self.assertEqual(result, 'https://example.com/endpoint1?key1=value1&key2=value2')\n\n    def test_base_url_trailing_slash(self):\n        \"\"\"Test base URL with trailing slash and path without leading slash.\"\"\"\n        result = create_api_redirect_link('https://example.com/', 'endpoint1')\n        self.assertEqual(result, 'https://example.com/endpoint1')\n\n    def test_base_url_no_trailing_slash_path_leading_slash(self):\n        \"\"\"Test base URL without trailing slash and path with leading slash.\"\"\"\n        result = create_api_redirect_link('https://example.com/api', '/endpoint1')\n        self.assertEqual(result, 'https://example.com/endpoint1')\n\n    def test_base_url_with_subpath(self):\n        \"\"\"Test base URL containing a subpath and relative path.\"\"\"\n        result = create_api_redirect_link('https://example.com/api/', 'endpoint1')\n        self.assertEqual(result, 'https://example.com/api/endpoint1')\n\n    def test_empty_path_allowed(self):\n        \"\"\"Test empty path that is explicitly allowed.\"\"\"\n        result = create_api_redirect_link('https://example.com', '')\n        self.assertEqual(result, 'https://example.com')\n\n    def test_none_params(self):\n        \"\"\"Test passing None for params (should behave as no params).\"\"\"\n        result = create_api_redirect_link('https://example.com', '/endpoint1', None)\n        self.assertEqual(result, 'https://example.com/endpoint1')\n\n    def test_invalid_domain(self):\n        \"\"\"Test with a base URL having an unapproved domain.\"\"\"\n        with self.assertRaises(ValueError):\n            create_api_redirect_link('https://invalid.com', '/endpoint1')\n\n    def test_invalid_endpoint(self):\n        \"\"\"Test with an endpoint not in the allowed list.\"\"\"\n        with self.assertRaises(ValueError):\n            create_api_redirect_link('https://example.com', '/invalid')\n\n    def test_network_path_reference(self):\n        \"\"\"Test path as network reference causing different netloc (should fail final check).\"\"\"\n        with patch('__main__.ALLOWED_ENDPOINTS', ['//malicious.com']):\n            with self.assertRaises(ValueError):\n                create_api_redirect_link('https://example.com', '//malicious.com')\n\n    def test_base_url_with_port(self):\n        \"\"\"Test base URL containing a port number.\"\"\"\n        with patch('__main__.APPROVED_API_DOMAINS', {'example.com:8080'}):\n            result = create_api_redirect_link('https://example.com:8080', '/endpoint1')\n            self.assertEqual(result, 'https://example.com:8080/endpoint1')\n\n    def test_params_special_chars(self):\n        \"\"\"Test query parameters with special characters.\"\"\"\n        params = {'key': 'value with spaces', 'another': 'special&chars#'}\n        result = create_api_redirect_link('https://example.com', '/endpoint1', params)\n        self.assertEqual(result, 'https://example.com/endpoint1?key=value+with+spaces&another=special%26chars%23')", "num_test_cases": 12, "task_id": "440543a2"}
{"test": "import unittest\nfrom unittest.mock import patch\nimport urllib.parse\n\n# Define the constants that the function uses\nAPPROVED_API_DOMAINS = {'api.example.com', 'secure.api.org'}\nALLOWED_ENDPOINTS = ['/v1/data', '/v1/user']\n\nclass TestGenerateApiRedirectUri(unittest.TestCase):\n\n    def test_happy_path_basic(self):\n        # Test typical case without query parameters\n        result = generate_api_redirect_uri('https://api.example.com', '/v1/data')\n        self.assertEqual(result, 'https://api.example.com/v1/data')\n\n    def test_happy_path_with_query(self):\n        # Test with query parameters\n        query = {'param1': 'value1', 'param2': 'value2'}\n        result = generate_api_redirect_uri('https://api.example.com', '/v1/data', query)\n        expected = 'https://api.example.com/v1/data?param1=value1&param2=value2'\n        self.assertEqual(result, expected)\n\n    def test_base_uri_trailing_slash(self):\n        # Test base_uri with trailing slash and endpoint without\n        result = generate_api_redirect_uri('https://api.example.com/', 'v1/data')\n        self.assertEqual(result, 'https://api.example.com/v1/data')\n\n    def test_base_uri_no_slash_endpoint_slash(self):\n        # Test base_uri without trailing slash and endpoint with leading slash\n        result = generate_api_redirect_uri('https://api.example.com', '/v1/data')\n        self.assertEqual(result, 'https://api.example.com/v1/data')\n\n    def test_query_multiple_params(self):\n        # Test multiple query parameters\n        query = {'a': '1', 'b': '2', 'c': '3'}\n        result = generate_api_redirect_uri('https://api.example.com', '/v1/data', query)\n        self.assertIn('a=1', result)\n        self.assertIn('b=2', result)\n        self.assertIn('c=3', result)\n\n    def test_unapproved_domain(self):\n        # Test base_uri with unapproved domain\n        with self.assertRaises(ValueError):\n            generate_api_redirect_uri('https://unapproved.com', '/v1/data')\n\n    def test_invalid_endpoint(self):\n        # Test endpoint not in allowed list\n        with self.assertRaises(ValueError):\n            generate_api_redirect_uri('https://api.example.com', '/invalid/endpoint')\n\n    def test_netloc_change_after_construction(self):\n        # Test when constructed URL changes domain (by allowing a malicious endpoint)\n        with patch('__main__.ALLOWED_ENDPOINTS', ['https://malicious.com']):\n            with self.assertRaises(ValueError) as cm:\n                generate_api_redirect_uri('https://api.example.com', 'https://malicious.com')\n            self.assertEqual(str(cm.exception), \"Constructed URL does not match the original API domain\")\n\n    def test_none_query(self):\n        # Test None query (should be same as no query)\n        result = generate_api_redirect_uri('https://api.example.com', '/v1/data', None)\n        self.assertEqual(result, 'https://api.example.com/v1/data')\n\n    def test_empty_base_uri(self):\n        # Test empty base_uri (results in empty netloc)\n        with self.assertRaises(ValueError):\n            generate_api_redirect_uri('', '/v1/data')\n\n    def test_empty_endpoint(self):\n        # Test empty endpoint (not in allowed list)\n        with self.assertRaises(ValueError):\n            generate_api_redirect_uri('https://api.example.com', '')\n\n    def test_base_uri_none(self):\n        # Test base_uri as None (should raise TypeError)\n        with self.assertRaises(TypeError):\n            generate_api_redirect_uri(None, '/v1/data')\n\n    def test_base_uri_non_string(self):\n        # Test base_uri as integer (should raise TypeError)\n        with self.assertRaises(TypeError):\n            generate_api_redirect_uri(123, '/v1/data')\n\n    def test_endpoint_none(self):\n        # Test endpoint as None (should raise TypeError)\n        with self.assertRaises(TypeError):\n            generate_api_redirect_uri('https://api.example.com', None)\n\n    def test_endpoint_non_string(self):\n        # Test endpoint as integer (should raise TypeError)\n        with self.assertRaises(TypeError):\n            generate_api_redirect_uri('https://api.example.com', 123)\n\n    def test_query_non_string_key(self):\n        # Test query with non-string key (should raise TypeError)\n        with self.assertRaises(TypeError):\n            generate_api_redirect_uri('https://api.example.com', '/v1/data', {123: 'value'})\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 16, "task_id": "b0192d59"}
{"test": "import unittest\nfrom unittest.mock import patch\nimport urllib.parse\nfrom solution import assemble_api_redirect_link\n\nclass TestAssembleApiRedirectLink(unittest.TestCase):\n    def setUp(self):\n        # Setup patchers for global variables\n        self.domains_patcher = patch('solution.APPROVED_API_DOMAINS', {'example.com', 'api.example.com', 'safe-domain.org'})\n        self.endpoints_patcher = patch('solution.ALLOWED_ENDPOINTS', [\n            '/api/v1/user',\n            '/api/v1/data',\n            'user',\n            'https://example.com/api/v1/user',\n            '//malicious.com/evil',\n            'https://safe-domain.org/api/v1/user'\n        ])\n        self.domains_patcher.start()\n        self.endpoints_patcher.start()\n\n    def tearDown(self):\n        # Stop patchers\n        self.domains_patcher.stop()\n        self.endpoints_patcher.stop()\n\n    def test_happy_path_basic(self):\n        # Test basic URL assembly without query parameters\n        result = assemble_api_redirect_link('https://example.com', '/api/v1/user')\n        self.assertEqual(result, 'https://example.com/api/v1/user')\n\n    def test_happy_path_with_query(self):\n        # Test URL assembly with query parameters\n        result = assemble_api_redirect_link(\n            'https://example.com',\n            '/api/v1/data',\n            {'param1': 'value1', 'param2': 'value2'}\n        )\n        self.assertEqual(result, 'https://example.com/api/v1/data?param1=value1&param2=value2')\n\n    def test_relative_endpoint_with_trailing_slash(self):\n        # Test relative endpoint with trailing slash in base URL\n        result = assemble_api_redirect_link('https://example.com/base/', 'user')\n        self.assertEqual(result, 'https://example.com/base/user')\n\n    def test_relative_endpoint_without_trailing_slash(self):\n        # Test relative endpoint without trailing slash in base URL\n        result = assemble_api_redirect_link('https://example.com/base', 'user')\n        self.assertEqual(result, 'https://example.com/user')\n\n    def test_query_special_chars(self):\n        # Test query parameters with special characters\n        query_dict = {'key': 'value space', 'special': 'chars & symbols@'}\n        result = assemble_api_redirect_link('https://example.com', '/api/v1/data', query_dict)\n        parsed = urllib.parse.urlparse(result)\n        self.assertEqual(parsed.scheme, 'https')\n        self.assertEqual(parsed.netloc, 'example.com')\n        self.assertEqual(parsed.path, '/api/v1/data')\n        query_params = urllib.parse.parse_qs(parsed.query)\n        expected_params = {'key': ['value space'], 'special': ['chars & symbols@']}\n        self.assertEqual(query_params, expected_params)\n\n    def test_empty_base_url(self):\n        # Test empty base URL (domain validation fails)\n        with self.assertRaises(ValueError):\n            assemble_api_redirect_link('', '/api/v1/user')\n\n    def test_unapproved_domain(self):\n        # Test unapproved domain in base URL\n        with self.assertRaises(ValueError):\n            assemble_api_redirect_link('https://unapproved.com', '/api/v1/user')\n\n    def test_invalid_endpoint(self):\n        # Test invalid endpoint not in allowed list\n        with self.assertRaises(ValueError):\n            assemble_api_redirect_link('https://example.com', '/invalid/endpoint')\n\n    def test_base_url_none(self):\n        # Test None base URL\n        with self.assertRaises(ValueError):\n            assemble_api_redirect_link(None, '/api/v1/user')\n\n    def test_api_path_none(self):\n        # Test None API path\n        with self.assertRaises(ValueError):\n            assemble_api_redirect_link('https://example.com', None)\n\n    def test_empty_api_path(self):\n        # Test empty API path\n        with self.assertRaises(ValueError):\n            assemble_api_redirect_link('https://example.com', '')\n\n    def test_final_domain_check_full_url(self):\n        # Test full URL endpoint changing domain (caught by final domain check)\n        with self.assertRaises(ValueError):\n            assemble_api_redirect_link('https://example.com', 'https://safe-domain.org/api/v1/user')\n\n    def test_final_domain_check_network_path(self):\n        # Test network-path reference changing domain (caught by final domain check)\n        with self.assertRaises(ValueError):\n            assemble_api_redirect_link('https://example.com', '//malicious.com/evil')\n\n    def test_domain_case_sensitivity(self):\n        # Test domain case sensitivity (uppercase domain not in approved set)\n        with self.assertRaises(ValueError):\n            assemble_api_redirect_link('https://EXAMPLE.COM', '/api/v1/user')\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 14, "task_id": "820ed70d"}
{"test": "import unittest\nfrom unittest.mock import patch\n\n# Define test constants\nTEST_APPROVED_DOMAINS = {'api.example.com', 'data.example.com'}\nTEST_ALLOWED_ENDPOINTS = {\n    '/api/v1',\n    'v2/data',\n    'user/profile',\n    'https://data.example.com/api'\n}\n\n# Patch the module constants and import the function\nwith patch('redirect_utils.APPROVED_API_DOMAINS', TEST_APPROVED_DOMAINS), \\\n        patch('redirect_utils.ALLOWED_ENDPOINTS', TEST_ALLOWED_ENDPOINTS):\n    from redirect_utils import generate_redirect_link\n\nclass TestGenerateRedirectLink(unittest.TestCase):\n    def test_happy_path_simple(self):\n        # Test simple valid case\n        result = generate_redirect_link('https://api.example.com', '/api/v1')\n        self.assertEqual(result, 'https://api.example.com/api/v1')\n\n    def test_happy_path_with_trailing_slash(self):\n        # Test base_url with trailing slash\n        result = generate_redirect_link('https://api.example.com/', 'v2/data')\n        self.assertEqual(result, 'https://api.example.com/v2/data')\n\n    def test_happy_path_with_query(self):\n        # Test with query parameters\n        result = generate_redirect_link('https://api.example.com', 'user/profile', {'id': 123, 'name': 'John Doe'})\n        self.assertEqual(result, 'https://api.example.com/user/profile?id=123&name=John+Doe')\n\n    def test_invalid_domain(self):\n        # Test unapproved domain\n        with self.assertRaises(ValueError) as context:\n            generate_redirect_link('https://evil.com', '/api/v1')\n        self.assertEqual(str(context.exception), 'Invalid API domain')\n\n    def test_invalid_endpoint(self):\n        # Test invalid endpoint\n        with self.assertRaises(ValueError) as context:\n            generate_redirect_link('https://api.example.com', '/invalid')\n        self.assertEqual(str(context.exception), 'Invalid API endpoint')\n\n    def test_final_domain_mismatch(self):\n        # Test endpoint causing domain mismatch\n        with self.assertRaises(ValueError) as context:\n            generate_redirect_link('https://api.example.com', 'https://data.example.com/api')\n        self.assertEqual(str(context.exception), 'Constructed URL does not match the original API domain')\n\n    def test_query_special_chars(self):\n        # Test query parameters with special characters\n        result = generate_redirect_link('https://api.example.com', 'user/profile', {'email': 'user@example.com', 'token': 'abc=def&ghi'})\n        expected = 'https://api.example.com/user/profile?email=user%40example.com&token=abc%3Ddef%26ghi'\n        self.assertEqual(result, expected)\n\n    def test_empty_query_info(self):\n        # Test empty query dictionary\n        result = generate_redirect_link('https://api.example.com', 'user/profile', {})\n        self.assertEqual(result, 'https://api.example.com/user/profile')\n\n    def test_endpoint_with_slash_handling(self):\n        # Test endpoint without leading slash on base_url without trailing slash\n        result = generate_redirect_link('https://api.example.com/base', 'subpath')\n        self.assertEqual(result, 'https://api.example.com/base/subpath')\n\n    def test_endpoint_with_slash_handling2(self):\n        # Test endpoint with leading slash on base_url with trailing slash\n        result = generate_redirect_link('https://api.example.com/base/', '/subpath')\n        self.assertEqual(result, 'https://api.example.com/subpath')", "num_test_cases": 10, "task_id": "e41d3fa7"}
{"test": "import unittest\nfrom unittest.mock import patch\n\nclass TestCreateRedirectUrl(unittest.TestCase):\n    \n    def setUp(self):\n        # Define the constants to be used in the tests\n        self.APPROVED_API_DOMAINS = {'api.example.com', 'secure.api.net'}\n        self.ALLOWED_ENDPOINTS = {'/users', '/data', '/info', 'profile', 'https://api.example.com/absolute'}\n        # Patch the constants in the main module\n        self.domain_patcher = patch('__main__.APPROVED_API_DOMAINS', self.APPROVED_API_DOMAINS)\n        self.endpoint_patcher = patch('__main__.ALLOWED_ENDPOINTS', self.ALLOWED_ENDPOINTS)\n        self.domain_patcher.start()\n        self.endpoint_patcher.start()\n\n    def tearDown(self):\n        self.domain_patcher.stop()\n        self.endpoint_patcher.stop()\n\n    def test_valid_input_basic(self):\n        # Basic valid inputs without optional parameters\n        result = create_redirect_url('https://api.example.com/api/v1/', '/users')\n        self.assertEqual(result, 'https://api.example.com/users')\n\n    def test_valid_input_with_params(self):\n        # Valid inputs including query parameters\n        result = create_redirect_url('https://api.example.com/api/v1/', '/data', {'key1': 'value1', 'key2': 'value2'})\n        self.assertIn('key1=value1', result)\n        self.assertIn('key2=value2', result)\n        self.assertTrue(result.startswith('https://api.example.com/data?'))\n\n    def test_empty_optional_params(self):\n        # Optional parameters as empty dict should not add '?'\n        result = create_redirect_url('https://api.example.com/api/v1/', '/users', {})\n        self.assertEqual(result, 'https://api.example.com/users')\n\n    def test_base_url_no_trailing_slash_endpoint_no_leading_slash(self):\n        # Base URL without trailing slash and endpoint without leading slash\n        result = create_redirect_url('https://api.example.com/api/v1', 'profile')\n        self.assertEqual(result, 'https://api.example.com/api/v1profile')\n\n    def test_base_url_no_trailing_slash_endpoint_with_leading_slash(self):\n        # Base URL without trailing slash and endpoint with leading slash\n        result = create_redirect_url('https://api.example.com/api/v1', '/profile')\n        self.assertEqual(result, 'https://api.example.com/profile')\n\n    def test_invalid_domain(self):\n        # Base URL with an unapproved domain\n        with self.assertRaises(ValueError):\n            create_redirect_url('https://evil.com/api/v1/', '/users')\n\n    def test_invalid_endpoint(self):\n        # Endpoint not in the allowed list\n        with self.assertRaises(ValueError):\n            create_redirect_url('https://api.example.com/api/v1/', '/invalid')\n\n    def test_valid_absolute_endpoint_same_domain(self):\n        # Absolute endpoint URL with the same approved domain\n        result = create_redirect_url('https://api.example.com/api/v1/', 'https://api.example.com/absolute')\n        self.assertEqual(result, 'https://api.example.com/absolute')\n\n    def test_valid_absolute_endpoint_different_approved_domain(self):\n        # Absolute endpoint URL with a different approved domain -> fails final domain check\n        with self.assertRaises(ValueError):\n            create_redirect_url('https://api.example.com/api/v1/', 'https://secure.api.net/users')\n\n    def test_valid_absolute_endpoint_unapproved_domain(self):\n        # Absolute endpoint URL with an unapproved domain -> fails final domain check\n        with self.assertRaises(ValueError):\n            create_redirect_url('https://api.example.com/api/v1/', 'https://evil.com/users')\n\n    def test_empty_base_url(self):\n        # Base URL is an empty string -> invalid domain\n        with self.assertRaises(ValueError):\n            create_redirect_url('', '/users')\n\n    def test_base_url_without_scheme(self):\n        # Base URL without scheme -> parsed netloc is empty, hence invalid\n        with self.assertRaises(ValueError):\n            create_redirect_url('api.example.com/api/v1/', '/users')\n\n    def test_none_base_url(self):\n        # Base URL as None -> TypeError in urlparse\n        with self.assertRaises(TypeError):\n            create_redirect_url(None, '/users')\n\n    def test_none_endpoint(self):\n        # Endpoint as None -> not in ALLOWED_ENDPOINTS\n        with self.assertRaises(ValueError):\n            create_redirect_url('https://api.example.com/api/v1/', None)\n\n    def test_empty_endpoint(self):\n        # Endpoint as empty string -> not in ALLOWED_ENDPOINTS\n        with self.assertRaises(ValueError):\n            create_redirect_url('https://api.example.com/api/v1/', '')\n\n    def test_special_characters_in_params(self):\n        # Query parameters with special characters\n        result = create_redirect_url('https://api.example.com/api/v1/', '/info', {'param': 'value with spaces', 'another': 'special&chars'})\n        self.assertIn('param=value+with+spaces', result)\n        self.assertIn('another=special%26chars', result)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 16, "task_id": "79b1ce97"}
{"test": "import unittest\nimport urllib.parse\n\n# Define global constants as used by the function\nAPPROVED_API_DOMAINS = {'api.example.com', 'secure.api.net'}\nALLOWED_ENDPOINTS = ['users', 'products', 'items', 'https://api.example.com/absolute', 'https://secure.api.net/items', '/users']\n\nclass TestConstructRedirectURL(unittest.TestCase):\n\n    def test_case_1(self):\n        # Happy path: base URL with trailing slash, valid endpoint, no parameters\n        main_url = 'https://api.example.com/'\n        endpoint_name = 'users'\n        result = construct_redirect_url(main_url, endpoint_name)\n        self.assertEqual(result, 'https://api.example.com/users')\n\n    def test_case_2(self):\n        # Happy path: with query parameters\n        main_url = 'https://api.example.com/'\n        endpoint_name = 'products'\n        params_dict = {'id': 123, 'sort': 'asc'}\n        result = construct_redirect_url(main_url, endpoint_name, params_dict)\n        self.assertEqual(result, 'https://api.example.com/products?id=123&sort=asc')\n\n    def test_case_3(self):\n        # Invalid API domain\n        main_url = 'https://evil.com/'\n        endpoint_name = 'users'\n        with self.assertRaises(ValueError) as context:\n            construct_redirect_url(main_url, endpoint_name)\n        self.assertEqual(str(context.exception), 'Invalid API domain')\n\n    def test_case_4(self):\n        # Invalid endpoint\n        main_url = 'https://api.example.com/'\n        endpoint_name = 'invalid_endpoint'\n        with self.assertRaises(ValueError) as context:\n            construct_redirect_url(main_url, endpoint_name)\n        self.assertEqual(str(context.exception), 'Invalid API endpoint')\n\n    def test_case_5(self):\n        # Absolute URL endpoint with same approved domain\n        main_url = 'https://api.example.com/'\n        endpoint_name = 'https://api.example.com/absolute'\n        result = construct_redirect_url(main_url, endpoint_name)\n        self.assertEqual(result, 'https://api.example.com/absolute')\n\n    def test_case_6(self):\n        # Absolute URL endpoint with different approved domain (fails final validation)\n        main_url = 'https://api.example.com/'\n        endpoint_name = 'https://secure.api.net/items'\n        with self.assertRaises(ValueError) as context:\n            construct_redirect_url(main_url, endpoint_name)\n        self.assertEqual(str(context.exception), 'Constructed URL does not match the original API domain')\n\n    def test_case_7(self):\n        # Base URL without trailing slash + relative endpoint\n        main_url = 'https://api.example.com/base'\n        endpoint_name = 'users'\n        result = construct_redirect_url(main_url, endpoint_name)\n        self.assertEqual(result, 'https://api.example.com/users')\n\n    def test_case_8(self):\n        # Base URL without trailing slash + absolute path endpoint\n        main_url = 'https://api.example.com/base'\n        endpoint_name = '/users'\n        result = construct_redirect_url(main_url, endpoint_name)\n        self.assertEqual(result, 'https://api.example.com/users')\n\n    def test_case_9(self):\n        # Base URL with trailing slash + relative endpoint\n        main_url = 'https://api.example.com/base/'\n        endpoint_name = 'users'\n        result = construct_redirect_url(main_url, endpoint_name)\n        self.assertEqual(result, 'https://api.example.com/base/users')\n\n    def test_case_10(self):\n        # Empty endpoint string\n        main_url = 'https://api.example.com/'\n        endpoint_name = ''\n        with self.assertRaises(ValueError) as context:\n            construct_redirect_url(main_url, endpoint_name)\n        self.assertEqual(str(context.exception), 'Invalid API endpoint')\n\n    def test_case_11(self):\n        # None endpoint\n        main_url = 'https://api.example.com/'\n        endpoint_name = None\n        with self.assertRaises(ValueError) as context:\n            construct_redirect_url(main_url, endpoint_name)\n        self.assertEqual(str(context.exception), 'Invalid API endpoint')\n\n    def test_case_12(self):\n        # Empty parameter dictionary (should be ignored)\n        main_url = 'https://api.example.com/'\n        endpoint_name = 'users'\n        params_dict = {}\n        result = construct_redirect_url(main_url, endpoint_name, params_dict)\n        self.assertEqual(result, 'https://api.example.com/users')\n\n    def test_case_13(self):\n        # Base URL with path and trailing slash + relative endpoint\n        main_url = 'https://api.example.com/api/v1/'\n        endpoint_name = 'users'\n        result = construct_redirect_url(main_url, endpoint_name)\n        self.assertEqual(result, 'https://api.example.com/api/v1/users')\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 13, "task_id": "f9bad77a"}
{"test": "import unittest\nimport urllib.parse as urlparse\n\n# Define the allowed domains for the test\nALLOWED_DOMAINS = ['allowed.com', 'example.org']\n\nclass TestCreateRedirectUrl(unittest.TestCase):\n\n    def test_relative_path(self):\n        # Test with a relative path (same domain)\n        base = \"http://example.com\"\n        next_param = \"/home\"\n        result = create_redirect_url(base, next_param)\n        self.assertEqual(result, \"http://example.com/home\")\n\n    def test_absolute_url_same_domain(self):\n        # Test with an absolute URL in the same domain\n        base = \"http://example.com\"\n        next_param = \"http://example.com/dashboard\"\n        result = create_redirect_url(base, next_param)\n        self.assertEqual(result, \"http://example.com/dashboard\")\n\n    def test_absolute_url_allowed_domain(self):\n        # Test with an absolute URL in an allowed external domain\n        base = \"http://example.com\"\n        next_param = \"http://allowed.com/welcome\"\n        result = create_redirect_url(base, next_param)\n        self.assertEqual(result, \"http://allowed.com/welcome\")\n\n    def test_base_trailing_slash(self):\n        # Test base URL with trailing slash and next_param without leading slash\n        base = \"http://example.com/\"\n        next_param = \"home\"\n        result = create_redirect_url(base, next_param)\n        self.assertEqual(result, \"http://example.com/home\")\n\n    def test_no_trailing_slash_no_leading_slash(self):\n        # Test base URL without trailing slash and next_param without leading slash\n        base = \"http://example.com\"\n        next_param = \"home\"\n        result = create_redirect_url(base, next_param)\n        self.assertEqual(result, \"http://example.com/home\")\n\n    def test_no_trailing_slash_with_leading_slash(self):\n        # Test base URL without trailing slash and next_param with leading slash\n        base = \"http://example.com\"\n        next_param = \"/home\"\n        result = create_redirect_url(base, next_param)\n        self.assertEqual(result, \"http://example.com/home\")\n\n    def test_next_param_empty(self):\n        # Test next_param as empty string\n        base = \"http://example.com\"\n        next_param = \"\"\n        result = create_redirect_url(base, next_param)\n        self.assertEqual(result, \"http://example.com\")\n\n    def test_base_empty_and_next_param_allowed_domain(self):\n        # Test empty base URL and next_param as an allowed domain\n        base = \"\"\n        next_param = \"http://allowed.com\"\n        result = create_redirect_url(base, next_param)\n        self.assertEqual(result, \"http://allowed.com\")\n\n    def test_base_empty_and_next_param_relative(self):\n        # Test empty base URL and next_param as a relative path\n        base = \"\"\n        next_param = \"home\"\n        result = create_redirect_url(base, next_param)\n        self.assertEqual(result, \"home\")\n\n    def test_redirect_to_disallowed_domain(self):\n        # Test next_param to a disallowed domain\n        base = \"http://example.com\"\n        next_param = \"http://disallowed.com\"\n        with self.assertRaises(ValueError):\n            create_redirect_url(base, next_param)\n\n    def test_base_url_none(self):\n        # Test base_url as None\n        with self.assertRaises(TypeError):\n            create_redirect_url(None, \"/path\")\n\n    def test_next_param_none(self):\n        # Test next_param as None\n        with self.assertRaises(TypeError):\n            create_redirect_url(\"http://example.com\", None)\n\n    def test_relative_path_with_dots(self):\n        # Test relative path with dot segments (should be resolved and domain remains the same)\n        base = \"http://example.com/dir1/\"\n        next_param = \"../dir2\"\n        result = create_redirect_url(base, next_param)\n        self.assertEqual(result, \"http://example.com/dir2\")\n\n    def test_similar_domain_not_allowed(self):\n        # Test a domain that is a substring of the base domain but not allowed\n        base = \"http://example.com\"\n        next_param = \"http://example.com.co\"\n        with self.assertRaises(ValueError):\n            create_redirect_url(base, next_param)", "num_test_cases": 14, "task_id": "2a6b4364"}
{"test": "import unittest\nimport urllib.parse\n\n# Define the allowed domains for testing\nALLOWED_RETURN_DOMAINS = {'example.com', 'sub.example.org', 'another-domain.net'}\n\nclass TestGenerateSSORedirect(unittest.TestCase):\n    \n    def test_valid_domain(self):\n        \"\"\"Test with return_url domain in allowed domains.\"\"\"\n        sso_endpoint = \"https://sso.example.com/login\"\n        user_id = \"user123\"\n        return_url = \"https://example.com/dashboard\"\n        result = generate_sso_redirect(sso_endpoint, user_id, return_url)\n        expected_params = urllib.parse.urlencode({'user': user_id, 'return': return_url})\n        expected_url = f\"{sso_endpoint}?{expected_params}\"\n        self.assertEqual(result, expected_url)\n    \n    def test_another_valid_domain_with_path_query(self):\n        \"\"\"Test with different allowed domain including path and query parameters.\"\"\"\n        sso_endpoint = \"https://auth.example.org/sso\"\n        user_id = \"user456\"\n        return_url = \"https://sub.example.org/path?param=value\"\n        result = generate_sso_redirect(sso_endpoint, user_id, return_url)\n        expected_params = urllib.parse.urlencode({'user': user_id, 'return': return_url})\n        expected_url = f\"{sso_endpoint}?{expected_params}\"\n        self.assertEqual(result, expected_url)\n    \n    def test_invalid_domain(self):\n        \"\"\"Test with return_url domain not in allowed domains.\"\"\"\n        sso_endpoint = \"https://sso.example.com/login\"\n        user_id = \"user123\"\n        return_url = \"https://malicious-site.com/evil\"\n        with self.assertRaises(ValueError):\n            generate_sso_redirect(sso_endpoint, user_id, return_url)\n    \n    def test_empty_return_url(self):\n        \"\"\"Test with empty return_url which has no domain.\"\"\"\n        sso_endpoint = \"https://sso.example.com/login\"\n        user_id = \"user123\"\n        return_url = \"\"\n        with self.assertRaises(ValueError):\n            generate_sso_redirect(sso_endpoint, user_id, return_url)\n    \n    def test_empty_user_id(self):\n        \"\"\"Test with empty user_id but valid return_url domain.\"\"\"\n        sso_endpoint = \"https://sso.example.com/login\"\n        user_id = \"\"\n        return_url = \"https://example.com/home\"\n        result = generate_sso_redirect(sso_endpoint, user_id, return_url)\n        expected_params = urllib.parse.urlencode({'user': user_id, 'return': return_url})\n        expected_url = f\"{sso_endpoint}?{expected_params}\"\n        self.assertEqual(result, expected_url)\n    \n    def test_empty_sso_endpoint(self):\n        \"\"\"Test with empty sso_endpoint but valid return_url domain.\"\"\"\n        sso_endpoint = \"\"\n        user_id = \"user789\"\n        return_url = \"https://another-domain.net/profile\"\n        result = generate_sso_redirect(sso_endpoint, user_id, return_url)\n        expected_params = urllib.parse.urlencode({'user': user_id, 'return': return_url})\n        expected_url = f\"{sso_endpoint}?{expected_params}\"\n        self.assertEqual(result, expected_url)\n    \n    def test_domain_with_port_not_allowed(self):\n        \"\"\"Test with return_url containing a port, not explicitly allowed.\"\"\"\n        sso_endpoint = \"https://sso.example.com/login\"\n        user_id = \"user123\"\n        return_url = \"https://example.com:8080/port\"\n        with self.assertRaises(ValueError):\n            generate_sso_redirect(sso_endpoint, user_id, return_url)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 7, "task_id": "0283b6db"}
{"test": "import unittest\\nimport urllib.parse\\n\\n# Define the allowed callback domains for the tests\\nALLOWED_CALLBACK_DOMAINS = {'allowed.com', 'another-example.com:8080'}\\n\\nclass TestCreateOAuthCallbackUrl(unittest.TestCase):\\n\\n    def test_happy_path_same_domain_relative_path(self):\\n        # Test basic relative path with same domain\\n        base_url = 'https://example.com'\\n        callback_path = '/callback'\\n        state = 'state123'\\n        result = create_oauth_callback_url(base_url, callback_path, state)\\n        expected = 'https://example.com/callback?state=state123'\\n        self.assertEqual(result, expected)\\n\\n    def test_happy_path_same_domain_relative_path_with_trailing_slash(self):\\n        # Test base_url with trailing slash and relative callback_path\\n        base_url = 'https://example.com/'\\n        callback_path = 'callback'\\n        state = 'state123'\\n        result = create_oauth_callback_url(base_url, callback_path, state)\\n        expected = 'https://example.com/callback?state=state123'\\n        self.assertEqual(result, expected)\\n\\n    def test_absolute_url_same_domain(self):\\n        # Test absolute callback_path URL with same domain\\n        base_url = 'https://example.com'\\n        callback_path = 'https://example.com/callback'\\n        state = 'state123'\\n        result = create_oauth_callback_url(base_url, callback_path, state)\\n        expected = 'https://example.com/callback?state=state123'\\n        self.assertEqual(result, expected)\\n\\n    def test_happy_path_absolute_url_allowed_domain(self):\\n        # Test absolute callback_path URL in allowed domains\\n        base_url = 'https://example.com'\\n        callback_path = 'https://allowed.com/callback'\\n        state = 'state123'\\n        result = create_oauth_callback_url(base_url, callback_path, state)\\n        expected = 'https://allowed.com/callback?state=state123'\\n        self.assertEqual(result, expected)\\n\\n    def test_invalid_domain_raises_error(self):\\n        # Test callback_path URL with disallowed domain\\n        base_url = 'https://example.com'\\n        callback_path = 'https://evil.com/callback'\\n        state = 'state123'\\n        with self.assertRaises(ValueError):\\n            create_oauth_callback_url(base_url, callback_path, state)\\n\\n    def test_state_with_special_characters(self):\\n        # Test state parameter with special characters\\n        base_url = 'https://example.com'\\n        callback_path = '/callback'\\n        state = 'state with spaces&special=chars'\\n        result = create_oauth_callback_url(base_url, callback_path, state)\\n        expected_state_quoted = urllib.parse.quote(state)\\n        expected = 'https://example.com/callback?state=' + expected_state_quoted\\n        self.assertEqual(result, expected)\\n\\n    def test_empty_state(self):\\n        # Test empty state parameter\\n        base_url = 'https://example.com'\\n        callback_path = '/callback'\\n        state = ''\\n        result = create_oauth_callback_url(base_url, callback_path, state)\\n        expected = 'https://example.com/callback?state='\\n        self.assertEqual(result, expected)\\n\\n    def test_base_url_with_port_same_domain_relative_path(self):\\n        # Test base_url with port number and relative path\\n        base_url = 'https://example.com:8080'\\n        callback_path = '/callback'\\n        state = 'state123'\\n        result = create_oauth_callback_url(base_url, callback_path, state)\\n        expected = 'https://example.com:8080/callback?state=state123'\\n        self.assertEqual(result, expected)\\n\\n    def test_base_url_with_port_absolute_url_allowed_domain(self):\\n        # Test absolute callback_path in allowed domain with port\\n        base_url = 'https://example.com'\\n        callback_path = 'https://another-example.com:8080/callback'\\n        state = 'state123'\\n        result = create_oauth_callback_url(base_url, callback_path, state)\\n        expected = 'https://another-example.com:8080/callback?state=state123'\\n        self.assertEqual(result, expected)\\n\\n    def test_base_url_with_port_absolute_url_same_domain_different_port(self):\\n        # Test absolute callback_path same domain but different port (not allowed)\\n        base_url = 'https://example.com:8080'\\n        callback_path = 'https://example.com:9090/callback'\\n        state = 'state123'\\n        with self.assertRaises(ValueError):\\n            create_oauth_callback_url(base_url, callback_path, state)\\n\\n    def test_base_url_with_path_and_relative_callback(self):\\n        # Test base_url with path and absolute callback_path\\n        base_url = 'https://example.com/app'\\n        callback_path = '/callback'\\n        state = 'state123'\\n        result = create_oauth_callback_url(base_url, callback_path, state)\\n        expected = 'https://example.com/callback?state=state123'\\n        self.assertEqual(result, expected)\\n\\n    def test_base_url_with_path_and_relative_callback_without_leading_slash(self):\\n        # Test base_url with trailing slash and relative callback_path without leading slash\\n        base_url = 'https://example.com/app/'\\n        callback_path = 'callback'\\n        state = 'state123'\\n        result = create_oauth_callback_url(base_url, callback_path, state)\\n        expected = 'https://example.com/app/callback?state=state123'\\n        self.assertEqual(result, expected)\\n\\nif __name__ == '__main__':\\n    unittest.main()", "num_test_cases": 12, "task_id": "7d131a59"}
{"test": "import unittest\nfrom unittest.mock import patch\n\n# Import the function from its module (assumed to be 'external_resource')\nfrom external_resource import construct_external_resource_url\n\nclass TestConstructExternalResourceUrl(unittest.TestCase):\n\n    @patch('external_resource.ALLOWED_CDN_DOMAINS', {'cdn.example.com', 'cdn2.example.com'})\n    def test_happy_path(self):\n        # Test typical inputs with allowed domains\n        url = construct_external_resource_url('https://cdn.example.com', '123', 'image')\n        self.assertEqual(url, 'https://cdn.example.com/image/123')\n\n    @patch('external_resource.ALLOWED_CDN_DOMAINS', {'cdn.example.com'})\n    def test_trailing_slash(self):\n        # Test base URL with trailing slash\n        url = construct_external_resource_url('https://cdn.example.com/', '123', 'image')\n        self.assertEqual(url, 'https://cdn.example.com/image/123')\n\n    @patch('external_resource.ALLOWED_CDN_DOMAINS', {'cdn.example.com'})\n    def test_resource_with_special_chars(self):\n        # Test resource_id with special characters\n        url = construct_external_resource_url('https://cdn.example.com', 'a b/c?d=e', 'image')\n        self.assertEqual(url, 'https://cdn.example.com/image/a b/c?d=e')\n\n    @patch('external_resource.ALLOWED_CDN_DOMAINS', {'cdn2.example.com'})\n    def test_different_allowed_domain(self):\n        # Test different allowed CDN domain\n        url = construct_external_resource_url('https://cdn2.example.com', '123', 'image')\n        self.assertEqual(url, 'https://cdn2.example.com/image/123')\n\n    @patch('external_resource.ALLOWED_CDN_DOMAINS', {'cdn.example.com'})\n    def test_disallowed_domain(self):\n        # Test base URL not in allowed domains\n        with self.assertRaises(ValueError):\n            construct_external_resource_url('https://evil.com', '123', 'image')\n\n    @patch('external_resource.ALLOWED_CDN_DOMAINS', {'cdn.example.com'})\n    def test_empty_resource_id(self):\n        # Test empty resource_id\n        url = construct_external_resource_url('https://cdn.example.com', '', 'image')\n        self.assertEqual(url, 'https://cdn.example.com/image/')\n\n    @patch('external_resource.ALLOWED_CDN_DOMAINS', {'cdn.example.com'})\n    def test_empty_resource_type(self):\n        # Test empty resource_type resulting in invalid domain\n        with self.assertRaises(ValueError):\n            construct_external_resource_url('https://cdn.example.com', '123', '')\n\n    def test_base_url_none(self):\n        # Test None for base_url\n        with self.assertRaises(TypeError):\n            construct_external_resource_url(None, '123', 'image')\n\n    def test_base_url_integer(self):\n        # Test integer for base_url\n        with self.assertRaises(TypeError):\n            construct_external_resource_url(123, '123', 'image')\n\n    @patch('external_resource.ALLOWED_CDN_DOMAINS', {'cdn.example.com'})\n    def test_convertible_resource_id_and_type(self):\n        # Test non-string but convertible resource_id and resource_type\n        url = construct_external_resource_url('https://cdn.example.com', 123, 456)\n        self.assertEqual(url, 'https://cdn.example.com/456/123')\n        url = construct_external_resource_url('https://cdn.example.com', None, 'image')\n        self.assertEqual(url, 'https://cdn.example.com/image/None')\n\n    @patch('external_resource.ALLOWED_CDN_DOMAINS', {'cdn.example.com'})\n    def test_base_url_with_path(self):\n        # Test base URL containing a path\n        url = construct_external_resource_url('https://cdn.example.com/base/path', '123', 'image')\n        self.assertEqual(url, 'https://cdn.example.com/image/123')\n\n    @patch('external_resource.ALLOWED_CDN_DOMAINS', {'cdn.example.com'})\n    def test_base_url_with_port_disallowed(self):\n        # Test base URL with port not in allowed domains\n        with self.assertRaises(ValueError):\n            construct_external_resource_url('https://cdn.example.com:8080', '123', 'image')\n\n    @patch('external_resource.ALLOWED_CDN_DOMAINS', {'cdn.example.com:8080'})\n    def test_base_url_with_port_allowed(self):\n        # Test base URL with port in allowed domains\n        url = construct_external_resource_url('https://cdn.example.com:8080', '123', 'image')\n        self.assertEqual(url, 'https://cdn.example.com:8080/image/123')\n\n    @patch('external_resource.ALLOWED_CDN_DOMAINS', {'cdn.example.com'})\n    def test_base_url_empty_string(self):\n        # Test empty base URL string resulting in relative path (disallowed domain)\n        with self.assertRaises(ValueError):\n            construct_external_resource_url('', '123', 'image')\n\n    @patch('external_resource.ALLOWED_CDN_DOMAINS', {'', 'cdn.example.com'})\n    def test_base_url_empty_string_and_allowed(self):\n        # Test empty base URL string with empty netloc allowed\n        url = construct_external_resource_url('', '123', 'image')\n        self.assertEqual(url, '/image/123')\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 15, "task_id": "f5ac2366"}
{"test": "import unittest\nfrom unittest import mock\n\nclass TestBuildApiRedirectUrl(unittest.TestCase):\n\n    def test_happy_path_trailing_slash(self):\n        # Test valid base URL with trailing slash, relative endpoint, no query params\n        with mock.patch('app.APPROVED_API_DOMAINS', {'example.com'}), \\\n             mock.patch('app.ALLOWED_ENDPOINTS', ['users']):\n            result = build_api_redirect_url('https://example.com/api/', 'users')\n            self.assertEqual(result, 'https://example.com/api/users')\n\n    def test_happy_path_no_trailing_slash(self):\n        # Test valid base URL without trailing slash, relative endpoint\n        with mock.patch('app.APPROVED_API_DOMAINS', {'example.com'}), \\\n             mock.patch('app.ALLOWED_ENDPOINTS', ['users']):\n            result = build_api_redirect_url('https://example.com/api', 'users')\n            self.assertEqual(result, 'https://example.com/users')\n\n    def test_absolute_endpoint_trailing_slash(self):\n        # Test absolute endpoint with base URL containing trailing slash\n        with mock.patch('app.APPROVED_API_DOMAINS', {'example.com'}), \\\n             mock.patch('app.ALLOWED_ENDPOINTS', ['/users']):\n            result = build_api_redirect_url('https://example.com/api/', '/users')\n            self.assertEqual(result, 'https://example.com/users')\n\n    def test_absolute_endpoint_no_trailing_slash(self):\n        # Test absolute endpoint with base URL without trailing slash\n        with mock.patch('app.APPROVED_API_DOMAINS', {'example.com'}), \\\n             mock.patch('app.ALLOWED_ENDPOINTS', ['/users']):\n            result = build_api_redirect_url('https://example.com/api', '/users')\n            self.assertEqual(result, 'https://example.com/users')\n\n    def test_with_query_params(self):\n        # Test with non-empty query parameters\n        with mock.patch('app.APPROVED_API_DOMAINS', {'example.com'}), \\\n             mock.patch('app.ALLOWED_ENDPOINTS', ['data']):\n            result = build_api_redirect_url('https://example.com/', 'data', {'id': 1, 'name': 'test'})\n            self.assertEqual(result, 'https://example.com/data?id=1&name=test')\n\n    def test_query_params_special_chars(self):\n        # Test query parameters with special characters\n        with mock.patch('app.APPROVED_API_DOMAINS', {'example.com'}), \\\n             mock.patch('app.ALLOWED_ENDPOINTS', ['search']):\n            result = build_api_redirect_url('https://example.com/', 'search', {'q': 'hello world', 'page': '1&2'})\n            self.assertEqual(result, 'https://example.com/search?q=hello+world&page=1%262')\n\n    def test_empty_query_params_dict(self):\n        # Test with empty query_params dictionary\n        with mock.patch('app.APPROVED_API_DOMAINS', {'example.com'}), \\\n             mock.patch('app.ALLOWED_ENDPOINTS', ['list']):\n            result = build_api_redirect_url('https://example.com/', 'list', {})\n            self.assertEqual(result, 'https://example.com/list')\n\n    def test_none_query_params(self):\n        # Test with None query_params (should behave like not provided)\n        with mock.patch('app.APPROVED_API_DOMAINS', {'example.com'}), \\\n             mock.patch('app.ALLOWED_ENDPOINTS', ['items']):\n            result = build_api_redirect_url('https://example.com/', 'items', None)\n            self.assertEqual(result, 'https://example.com/items')\n\n    def test_invalid_domain(self):\n        # Test base URL with invalid domain\n        with mock.patch('app.APPROVED_API_DOMAINS', {'safe.org'}), \\\n             mock.patch('app.ALLOWED_ENDPOINTS', ['users']):\n            with self.assertRaises(ValueError) as context:\n                build_api_redirect_url('https://invalid.com', 'users')\n            self.assertIn(\"Invalid API domain\", str(context.exception))\n\n    def test_invalid_endpoint(self):\n        # Test invalid endpoint not in allowed list\n        with mock.patch('app.APPROVED_API_DOMAINS', {'example.com'}), \\\n             mock.patch('app.ALLOWED_ENDPOINTS', ['valid']):\n            with self.assertRaises(ValueError) as context:\n                build_api_redirect_url('https://example.com', 'invalid')\n            self.assertIn(\"Invalid API endpoint\", str(context.exception))\n\n    def test_empty_endpoint_not_allowed(self):\n        # Test empty endpoint not in allowed list\n        with mock.patch('app.APPROVED_API_DOMAINS', {'example.com'}), \\\n             mock.patch('app.ALLOWED_ENDPOINTS', ['users']):\n            with self.assertRaises(ValueError) as context:\n                build_api_redirect_url('https://example.com', '')\n            self.assertIn(\"Invalid API endpoint\", str(context.exception))\n\n    def test_empty_endpoint_allowed(self):\n        # Test empty endpoint in allowed list\n        with mock.patch('app.APPROVED_API_DOMAINS', {'example.com'}), \\\n             mock.patch('app.ALLOWED_ENDPOINTS', ['']):\n            result = build_api_redirect_url('https://example.com/api/', '')\n            self.assertEqual(result, 'https://example.com/api/')\n\n    def test_full_url_endpoint_domain_check(self):\n        # Test final domain check catches netloc change even with allowed endpoint\n        with mock.patch('app.APPROVED_API_DOMAINS', {'sub1.example.com'}), \\\n             mock.patch('app.ALLOWED_ENDPOINTS', ['https://sub2.example.com/path']):\n            with self.assertRaises(ValueError) as context:\n                build_api_redirect_url('https://sub1.example.com', 'https://sub2.example.com/path')\n            self.assertIn(\"Constructed URL does not match the original API domain\", str(context.exception))\n\n    def test_relative_path_changing_domain(self):\n        # Test relative path that doesn't change domain (should pass final check)\n        with mock.patch('app.APPROVED_API_DOMAINS', {'example.com'}), \\\n             mock.patch('app.ALLOWED_ENDPOINTS', ['../path']):\n            result = build_api_redirect_url('https://example.com/dir/', '../path')\n            self.assertEqual(result, 'https://example.com/path')\n", "num_test_cases": 14, "task_id": "0a0b19a7"}
{"test": "import unittest\nimport re\nfrom urllib import parse as urlparse\n\n# We are not including the function code, but the test assumes that the function is available and relies on global SCHEME_RE and urlparse.\n# Since the function uses global variables (SCHEME_RE and urlparse) defined in its module,\n# we define them here to make the tests self-contained.\n# SCHEME_RE pattern matches any string starting with a scheme (e.g., 'http:').\nSCHEME_RE = re.compile(r'^[a-zA-Z][a-zA-Z0-9+.-]*:')\n\nclass TestMakeLocationAbsolute(unittest.TestCase):\n\n    def test_http_scheme(self):\n        # Value has http scheme, should return unchanged\n        value = \"http://example.com/path\"\n        result = make_location_absolute(value, \"example.org\", \"https\")\n        self.assertEqual(result, value)\n\n    def test_https_scheme(self):\n        # Value has https scheme, should return unchanged\n        value = \"https://example.com/path\"\n        result = make_location_absolute(value, \"example.org\", \"http\")\n        self.assertEqual(result, value)\n\n    def test_ftp_scheme(self):\n        # Value has ftp scheme, should return unchanged\n        value = \"ftp://example.com/path\"\n        result = make_location_absolute(value, \"example.org\", \"http\")\n        self.assertEqual(result, value)\n\n    def test_relative_path_without_leading_slash(self):\n        # Relative path without leading slash, should be joined to base URL\n        result = make_location_absolute(\"index.html\", \"example.com\", \"https\")\n        self.assertEqual(result, \"https://example.com/index.html\")\n\n    def test_relative_path_with_leading_slash(self):\n        # Relative path with leading slash, should be joined to base URL\n        result = make_location_absolute(\"/path/to/resource\", \"example.com\", \"https\")\n        self.assertEqual(result, \"https://example.com/path/to/resource\")\n\n    def test_empty_value(self):\n        # Empty value, should return base URL\n        result = make_location_absolute(\"\", \"example.com\", \"https\")\n        self.assertEqual(result, \"https://example.com/\")\n\n    def test_long_relative_url(self):\n        # Long relative URL\n        long_path = \"/\" + \"a\" * 1000\n        result = make_location_absolute(long_path, \"example.com\", \"https\")\n        self.assertEqual(result, \"https://example.com\" + long_path)\n\n    def test_relative_url_with_query_fragment(self):\n        # Relative URL with query and fragment\n        value = \"/path?query=value#fragment\"\n        result = make_location_absolute(value, \"example.com\", \"https\")\n        self.assertEqual(result, \"https://example.com/path?query=value#fragment\")\n\n    def test_value_starts_with_double_slash(self):\n        # Value starts with //, should be replaced with \"/%2f\" and joined\n        result = make_location_absolute(\"//malicious.com\", \"example.com\", \"https\")\n        self.assertEqual(result, \"https://example.com/%2fmalicious.com\")\n\n    def test_value_starts_with_triple_slash(self):\n        # Value starts with ///, first two slashes replaced, third remains\n        result = make_location_absolute(\"///malicious.com\", \"example.com\", \"https\")\n        self.assertEqual(result, \"https://example.com/%2f/malicious.com\")\n\n    def test_security_open_redirect_attempt(self):\n        # Value is //attacker.com, should become /%2fattacker.com\n        result = make_location_absolute(\"//attacker.com\", \"example.com\", \"https\")\n        self.assertEqual(result, \"https://example.com/%2fattacker.com\")\n\n    def test_empty_host_name(self):\n        # Empty host name, forms base URL \"https://\" which may be invalid but function doesn't check\n        result = make_location_absolute(\"/path\", \"\", \"https\")\n        self.assertEqual(result, \"https:///path\")\n\n    def test_empty_url_scheme(self):\n        # Empty URL scheme, forms base URL \"://example.com\" which may be invalid\n        result = make_location_absolute(\"/path\", \"example.com\", \"\")\n        self.assertEqual(result, \"://example.com/path\")\n\n    def test_mixed_case_scheme(self):\n        # Value has mixed case scheme (HTTP), should return unchanged\n        value = \"HTTP://example.com\"\n        result = make_location_absolute(value, \"example.org\", \"https\")\n        self.assertEqual(result, value)\n\n    def test_dot_relative_path(self):\n        # Value is a dot relative path\n        result = make_location_absolute(\"./path\", \"example.com\", \"https\")\n        self.assertEqual(result, \"https://example.com/./path\")\n", "num_test_cases": 15, "task_id": "5e7dc88d"}
{"test": "import unittest\nfrom defusedxml.ElementTree import ParseError\nfrom defusedxml.common import EntitiesForbidden\n\nclass TestParseXmlConfig(unittest.TestCase):\n\n    def test_valid_multiple_settings(self):\n        # Test parsing XML with multiple valid settings\n        xml = '''<root>\n                   <setting name=\"key1\">value1</setting>\n                   <setting name=\"key2\">value2</setting>\n                </root>'''\n        result = parse_xml_config(xml)\n        expected = {'key1': 'value1', 'key2': 'value2'}\n        self.assertEqual(result, expected)\n\n    def test_single_setting(self):\n        # Test parsing XML with one setting\n        xml = '''<root>\n                   <setting name=\"single\">hello</setting>\n                </root>'''\n        result = parse_xml_config(xml)\n        self.assertEqual(result, {'single': 'hello'})\n\n    def test_no_settings(self):\n        # Test XML with no settings returns empty dict\n        xml = '<root></root>'\n        result = parse_xml_config(xml)\n        self.assertEqual(result, {})\n\n    def test_setting_without_name(self):\n        # Test setting without name attribute (uses None as key)\n        xml = '''<root>\n                   <setting>value</setting>\n                </root>'''\n        result = parse_xml_config(xml)\n        self.assertEqual(result, {None: 'value'})\n\n    def test_setting_without_text(self):\n        # Test setting without text content (value becomes None)\n        xml = '''<root>\n                   <setting name=\"key\"/>\n                </root>'''\n        result = parse_xml_config(xml)\n        self.assertEqual(result, {'key': None})\n\n    def test_setting_with_empty_text(self):\n        # Test setting with empty string text\n        xml = '''<root>\n                   <setting name=\"key\"></setting>\n                </root>'''\n        result = parse_xml_config(xml)\n        self.assertEqual(result, {'key': ''})\n\n    def test_duplicate_keys(self):\n        # Test duplicate keys (last occurrence overwrites)\n        xml = '''<root>\n                   <setting name=\"key\">first</setting>\n                   <setting name=\"key\">second</setting>\n                </root>'''\n        result = parse_xml_config(xml)\n        self.assertEqual(result, {'key': 'second'})\n\n    def test_invalid_xml(self):\n        # Test malformed XML (unclosed tag)\n        xml = '<root>'\n        with self.assertRaises(ParseError):\n            parse_xml_config(xml)\n\n    def test_empty_input(self):\n        # Test empty string input\n        with self.assertRaises(ParseError):\n            parse_xml_config('')\n\n    def test_xxe_attack(self):\n        # Test XXE injection attempt\n        xml = '''<?xml version=\"1.0\"?>\n                <!DOCTYPE root [\n                <!ENTITY xxe SYSTEM \"file:///etc/passwd\">\n                ]>\n                <root>\n                    <setting name=\"key\">&xxe;</setting>\n                </root>'''\n        with self.assertRaises(EntitiesForbidden):\n            parse_xml_config(xml)\n\n    def test_non_ascii_text(self):\n        # Test non-ASCII characters in text\n        xml = '''<root>\n                   <setting name=\"accent\">café</setting>\n                </root>'''\n        result = parse_xml_config(xml)\n        self.assertEqual(result, {'accent': 'café'})\n\n    def test_nested_settings(self):\n        # Test only top-level settings are parsed\n        xml = '''<root>\n                   <setting name=\"top\">top_value</setting>\n                   <group>\n                       <setting name=\"nested\">nested_value</setting>\n                   </group>\n                </root>'''\n        result = parse_xml_config(xml)\n        self.assertEqual(result, {'top': 'top_value'})\n", "num_test_cases": 12, "task_id": "476a4380"}
{"test": "import unittest\nimport defusedxml.ElementTree as ET\nfrom defusedxml.common import EntitiesForbidden\n\nclass TestHandleXmlData(unittest.TestCase):\n    \n    def test_case_1(self):\n        # Test with multiple valid settings\n        xml_config = '<config><setting name=\\\"key1\\\">value1</setting><setting name=\\\"key2\\\">value2</setting></config>'\n        result = handle_xml_data(xml_config)\n        self.assertEqual(result, {'key1': 'value1', 'key2': 'value2'})\n    \n    def test_case_2(self):\n        # Test with a single valid setting\n        xml_config = '<config><setting name=\\\"key\\\">value</setting></config>'\n        result = handle_xml_data(xml_config)\n        self.assertEqual(result, {'key': 'value'})\n    \n    def test_case_3(self):\n        # Test with no settings (empty dictionary)\n        xml_config = '<config></config>'\n        result = handle_xml_data(xml_config)\n        self.assertEqual(result, {})\n    \n    def test_case_4(self):\n        # Test with malformed XML (missing closing tag)\n        xml_config = '<config><setting name=\\\"key\\\">value</setting>'\n        with self.assertRaises(ET.ParseError):\n            handle_xml_data(xml_config)\n    \n    def test_case_5(self):\n        # Test with empty string input\n        xml_config = ''\n        with self.assertRaises(ET.ParseError):\n            handle_xml_data(xml_config)\n    \n    def test_case_6(self):\n        # Test with None input (invalid type)\n        xml_config = None\n        with self.assertRaises(TypeError):\n            handle_xml_data(xml_config)\n    \n    def test_case_7(self):\n        # Test with non-string input (integer)\n        xml_config = 123\n        with self.assertRaises(TypeError):\n            handle_xml_data(xml_config)\n    \n    def test_case_8(self):\n        # Test XXE attack attempt (should raise EntitiesForbidden)\n        xml_config = '<!DOCTYPE foo [ <!ENTITY xxe SYSTEM \\\"file:///etc/passwd\\\"> ]><config><setting name=\\\"test\\\">&xxe;</setting></config>'\n        with self.assertRaises(EntitiesForbidden):\n            handle_xml_data(xml_config)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 8, "task_id": "0fec9cf8"}
{"test": "import unittest\nimport defusedxml.ElementTree as ET\n\nclass TestParseXmlSettings(unittest.TestCase):\n    \n    def test_valid_multiple_settings(self):\n        # Test with valid XML containing multiple settings\n        xml = '''\n        <root>\n            <setting name=\"key1\">value1</setting>\n            <setting name=\"key2\">value2</setting>\n        </root>\n        '''\n        result = parse_xml_settings(xml)\n        self.assertEqual(result, {'key1': 'value1', 'key2': 'value2'})\n    \n    def test_valid_one_setting(self):\n        # Test with valid XML containing one setting\n        xml = '<root><setting name=\"key\">value</setting></root>'\n        result = parse_xml_settings(xml)\n        self.assertEqual(result, {'key': 'value'})\n    \n    def test_empty_settings(self):\n        # Test with valid XML containing no setting elements\n        xml = '<root></root>'\n        result = parse_xml_settings(xml)\n        self.assertEqual(result, {})\n    \n    def test_empty_string(self):\n        # Test with empty string input\n        with self.assertRaises(ET.ParseError):\n            parse_xml_settings('')\n    \n    def test_none_input(self):\n        # Test with None input\n        with self.assertRaises(TypeError):\n            parse_xml_settings(None)\n    \n    def test_non_string_input(self):\n        # Test with non-string input (integer)\n        with self.assertRaises(TypeError):\n            parse_xml_settings(123)\n    \n    def test_malformed_xml(self):\n        # Test with malformed XML (missing closing tag)\n        xml = '<root><setting name=\"key\">value</setting>'\n        with self.assertRaises(ET.ParseError):\n            parse_xml_settings(xml)\n    \n    def test_nested_settings(self):\n        # Test with nested setting elements (only direct children are parsed)\n        xml = '''\n        <root>\n            <settings>\n                <setting name=\"nested\">value</setting>\n            </settings>\n        </root>\n        '''\n        result = parse_xml_settings(xml)\n        self.assertEqual(result, {})\n    \n    def test_missing_name_attribute(self):\n        # Test setting element without name attribute (key becomes None)\n        xml = '<root><setting>value</setting></root>'\n        result = parse_xml_settings(xml)\n        self.assertEqual(result, {None: 'value'})\n    \n    def test_empty_name_attribute(self):\n        # Test setting element with empty name attribute\n        xml = '<root><setting name=\"\">value</setting></root>'\n        result = parse_xml_settings(xml)\n        self.assertEqual(result, {'': 'value'})\n    \n    def test_no_text_content(self):\n        # Test setting element with no text content (value becomes None)\n        xml = '<root><setting name=\"key\"></setting></root>'\n        result = parse_xml_settings(xml)\n        self.assertEqual(result, {'key': None})\n    \n    def test_duplicate_keys(self):\n        # Test duplicate keys (last occurrence should overwrite)\n        xml = '''\n        <root>\n            <setting name=\"key\">value1</setting>\n            <setting name=\"key\">value2</setting>\n        </root>\n        '''\n        result = parse_xml_settings(xml)\n        self.assertEqual(result, {'key': 'value2'})\n    \n    def test_predefined_entity(self):\n        # Test predefined entity in text content (should be resolved)\n        xml = '<root><setting name=\"key\">Hello &amp; World</setting></root>'\n        result = parse_xml_settings(xml)\n        self.assertEqual(result, {'key': 'Hello & World'})\n    \n    def test_dtd_doctype(self):\n        # Test XML with DTD/DOCTYPE (should be blocked for security)\n        xml = '''\n        <!DOCTYPE root [\n            <!ENTITY test \"TEST\">\n        ]>\n        <root>\n            <setting name=\"key\">&test;</setting>\n        </root>\n        '''\n        with self.assertRaises(ET.ParseError):\n            parse_xml_settings(xml)\n    \n    def test_external_entity(self):\n        # Test XML with external entity (should be blocked for security)\n        xml = '''\n        <!DOCTYPE root [\n            <!ENTITY xxe SYSTEM \"file:///etc/passwd\">\n        ]>\n        <root>\n            <setting name=\"key\">&xxe;</setting>\n        </root>\n        '''\n        with self.assertRaises(ET.ParseError):\n            parse_xml_settings(xml)\n    \n    def test_dtd_only(self):\n        # Test XML with only DTD declaration (no entities)\n        xml = '''\n        <!DOCTYPE root>\n        <root>\n            <setting name=\"key\">value</setting>\n        </root>\n        '''\n        with self.assertRaises(ET.ParseError):\n            parse_xml_settings(xml)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 17, "task_id": "ae1538b9"}
{"test": "import unittest\nfrom xml.etree.ElementTree import ParseError\nimport defusedxml.common\n\nclass TestHandleXmlConfig(unittest.TestCase):\n\n    def test_valid_one_setting(self):\n        # Test with one valid setting\n        xml = '<settings><setting name=\\\"a\\\">1</setting></settings>'\n        result = handle_xml_config(xml)\n        self.assertEqual(result, {'a': '1'})\n\n    def test_valid_multiple_settings(self):\n        # Test with multiple valid settings\n        xml = '<settings><setting name=\\\"a\\\">1</setting><setting name=\\\"b\\\">2</setting></settings>'\n        result = handle_xml_config(xml)\n        self.assertEqual(result, {'a': '1', 'b': '2'})\n\n    def test_no_settings(self):\n        # Test XML with no settings\n        xml = '<settings></settings>'\n        result = handle_xml_config(xml)\n        self.assertEqual(result, {})\n\n    def test_nested_settings(self):\n        # Test XML with nested settings (only top-level should be parsed)\n        xml = '<settings><setting name=\\\"a\\\">1</setting><group><setting name=\\\"b\\\">2</setting></group></settings>'\n        result = handle_xml_config(xml)\n        self.assertEqual(result, {'a': '1'})\n\n    def test_setting_without_name(self):\n        # Test setting without name attribute (uses None as key)\n        xml = '<settings><setting>value0</setting><setting name=\\\"a\\\">1</setting></settings>'\n        result = handle_xml_config(xml)\n        self.assertEqual(result, {None: 'value0', 'a': '1'})\n\n    def test_setting_without_text(self):\n        # Test setting without text content (value becomes None)\n        xml = '<settings><setting name=\\\"key1\\\"/></settings>'\n        result = handle_xml_config(xml)\n        self.assertEqual(result, {'key1': None})\n\n    def test_empty_string(self):\n        # Test empty string input (should raise ParseError)\n        with self.assertRaises(ParseError):\n            handle_xml_config('')\n\n    def test_none_input(self):\n        # Test None input (should raise TypeError)\n        with self.assertRaises(TypeError):\n            handle_xml_config(None)\n\n    def test_non_string_input(self):\n        # Test non-string input (integer)\n        with self.assertRaises(TypeError):\n            handle_xml_config(123)\n\n    def test_non_xml_string(self):\n        # Test non-XML string input\n        with self.assertRaises(ParseError):\n            handle_xml_config('hello world')\n\n    def test_malformed_xml(self):\n        # Test malformed XML input\n        xml = '<root><setting></root>'\n        with self.assertRaises(ParseError):\n            handle_xml_config(xml)\n\n    def test_xxe_attack(self):\n        # Test XML with external entity (should prevent XXE)\n        xml = '<?xml version=\\\"1.0\\\" encoding=\\\"ISO-8859-1\\\"?><!DOCTYPE foo [<!ELEMENT foo ANY ><!ENTITY xxe SYSTEM \\\"file:///etc/passwd\\\" >]><settings><setting name=\\\"key1\\\">value1</setting><setting name=\\\"key2\\\">&xxe;</setting></settings>'\n        with self.assertRaises(defusedxml.common.EntitiesForbidden):\n            handle_xml_config(xml)", "num_test_cases": 12, "task_id": "daa19221"}
{"test": "import unittest\nimport defusedxml.ElementTree as ET\nfrom defusedxml.common import EntitiesForbidden\n\nclass TestParseConfigXml(unittest.TestCase):\n\n    def test_valid_one_setting(self):\n        # Test XML with one setting element\n        xml_data = '<root><setting name=\"key1\">value1</setting></root>'\n        result = parse_config_xml(xml_data)\n        self.assertEqual(result, {'key1': 'value1'})\n        self.assertIsInstance(result, dict)\n\n    def test_valid_multiple_settings(self):\n        # Test XML with multiple setting elements at root level\n        xml_data = '<root><setting name=\"key1\">value1</setting><setting name=\"key2\">value2</setting></root>'\n        result = parse_config_xml(xml_data)\n        self.assertEqual(result, {'key1': 'value1', 'key2': 'value2'})\n\n    def test_valid_nested_settings(self):\n        # Test XML with nested setting elements (recursive findall)\n        xml_data = '<root><group><setting name=\"key1\">value1</setting></group><setting name=\"key2\">value2</setting></root>'\n        result = parse_config_xml(xml_data)\n        self.assertEqual(result, {'key1': 'value1', 'key2': 'value2'})\n\n    def test_empty_xml(self):\n        # Test empty XML string (should raise ParseError)\n        with self.assertRaises(ET.ParseError):\n            parse_config_xml('')\n\n    def test_malformed_xml(self):\n        # Test malformed XML (missing closing tag)\n        xml_data = '<root><setting></root>'\n        with self.assertRaises(ET.ParseError):\n            parse_config_xml(xml_data)\n\n    def test_no_settings(self):\n        # Test XML with no setting elements\n        xml_data = '<root></root>'\n        result = parse_config_xml(xml_data)\n        self.assertEqual(result, {})\n\n    def test_xxe_attack(self):\n        # Test XML with XXE payload (should block entity resolution)\n        xml_data = '''<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?>\n        <!DOCTYPE foo [\n        <!ELEMENT foo ANY >\n        <!ENTITY xxe SYSTEM \"file:///etc/passwd\" >]>\n        <root><setting name=\"key1\">&xxe;</setting></root>'''\n        with self.assertRaises(EntitiesForbidden):\n            parse_config_xml(xml_data)\n\n    def test_setting_without_name(self):\n        # Test setting element without name attribute\n        xml_data = '<root><setting>value1</setting></root>'\n        result = parse_config_xml(xml_data)\n        self.assertEqual(result, {None: 'value1'})\n\n    def test_setting_with_empty_name(self):\n        # Test setting element with empty name attribute\n        xml_data = '<root><setting name=\"\">value1</setting></root>'\n        result = parse_config_xml(xml_data)\n        self.assertEqual(result, {'': 'value1'})\n\n    def test_duplicate_setting_names(self):\n        # Test duplicate setting names (last occurrence wins)\n        xml_data = '<root><setting name=\"key1\">value1</setting><setting name=\"key1\">value2</setting></root>'\n        result = parse_config_xml(xml_data)\n        self.assertEqual(result, {'key1': 'value2'})\n\n    def test_setting_with_no_text(self):\n        # Test setting element with no text content\n        xml_data = '<root><setting name=\"key1\"></setting></root>'\n        result = parse_config_xml(xml_data)\n        self.assertEqual(result, {'key1': None})\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 11, "task_id": "b2699276"}
{"test": "import unittest\nfrom defusedxml.common import EntitiesForbidden\nimport defusedxml.ElementTree as ET\n\nclass TestProcessConfigXml(unittest.TestCase):\n    \n    def test_valid_xml_multiple_settings(self):\n        # Test with valid XML containing multiple setting elements\n        xml = '<config><setting name=\"key1\">value1</setting><setting name=\"key2\">value2</setting></config>'\n        result = process_config_xml(xml)\n        self.assertEqual(result, {\"key1\": \"value1\", \"key2\": \"value2\"})\n    \n    def test_valid_xml_one_setting(self):\n        # Test with valid XML containing one setting element\n        xml = '<config><setting name=\"key\">value</setting></config>'\n        result = process_config_xml(xml)\n        self.assertEqual(result, {\"key\": \"value\"})\n    \n    def test_empty_xml(self):\n        # Test with empty string input\n        with self.assertRaises(ET.ParseError):\n            process_config_xml('')\n    \n    def test_no_setting_elements(self):\n        # Test XML without any setting elements\n        xml = '<config></config>'\n        result = process_config_xml(xml)\n        self.assertEqual(result, {})\n    \n    def test_malformed_xml(self):\n        # Test malformed XML (missing closing tag)\n        xml = '<config><setting name=\"key\">value</setting>'\n        with self.assertRaises(ET.ParseError):\n            process_config_xml(xml)\n    \n    def test_xxe_attack(self):\n        # Test XML with XXE attack payload\n        xml = '<?xml version=\"1.0\"?><!DOCTYPE foo [ <!ENTITY xxe SYSTEM \"file:///dev/random\"> ]><config><setting name=\"test\">&xxe;</setting></config>'\n        with self.assertRaises(EntitiesForbidden):\n            process_config_xml(xml)\n    \n    def test_setting_without_name(self):\n        # Test setting element without name attribute\n        xml = '<config><setting>value without name</setting></config>'\n        result = process_config_xml(xml)\n        self.assertEqual(result, {None: 'value without name'})\n    \n    def test_setting_without_text(self):\n        # Test setting element with name but without text (explicit empty)\n        xml = '<config><setting name=\"key\"></setting></config>'\n        result = process_config_xml(xml)\n        self.assertEqual(result, {\"key\": \"\"})\n    \n    def test_setting_with_name_and_no_text(self):\n        # Test self-closing setting element (results in None text)\n        xml = '<config><setting name=\"key\"/></config>'\n        result = process_config_xml(xml)\n        self.assertEqual(result, {\"key\": None})\n    \n    def test_nested_setting_elements(self):\n        # Test that nested setting elements are not processed\n        xml = '<config><nested><setting name=\"nested_key\">nested_value</setting></nested></config>'\n        result = process_config_xml(xml)\n        self.assertEqual(result, {})\n    \n    def test_other_elements_ignored(self):\n        # Test that non-setting elements are ignored\n        xml = '<config><other name=\"other_key\">other_value</other><setting name=\"key\">value</setting></config>'\n        result = process_config_xml(xml)\n        self.assertEqual(result, {\"key\": \"value\"})\n    \n    def test_duplicate_keys(self):\n        # Test duplicate keys overwrite previous values\n        xml = '<config><setting name=\"key\">first</setting><setting name=\"key\">second</setting></config>'\n        result = process_config_xml(xml)\n        self.assertEqual(result, {\"key\": \"second\"})\n    \n    def test_none_input(self):\n        # Test passing None as input\n        with self.assertRaises(TypeError):\n            process_config_xml(None)\n    \n    def test_non_string_input(self):\n        # Test passing non-string input (integer)\n        with self.assertRaises(TypeError):\n            process_config_xml(123)", "num_test_cases": 14, "task_id": "016fd1df"}
{"test": "import unittest\nfrom defusedxml.ElementTree import ParseError\nfrom defusedxml.common import EntitiesForbidden\n\nclass TestSecureXmlHandler(unittest.TestCase):\n    \n    def test_basic(self):\n        \"\"\"Test with valid XML containing one setting.\"\"\"\n        xml_config = '<config><setting name=\"key1\">value1</setting></config>'\n        result = secure_xml_handler(xml_config)\n        self.assertEqual(result, {'key1': 'value1'})\n    \n    def test_multiple_settings(self):\n        \"\"\"Test with multiple settings in the XML.\"\"\"\n        xml_config = '<config>\\n    <setting name=\"key1\">value1</setting>\\n    <setting name=\"key2\">value2</setting>\\n</config>'\n        result = secure_xml_handler(xml_config)\n        self.assertEqual(result, {'key1': 'value1', 'key2': 'value2'})\n    \n    def test_nested_setting(self):\n        \"\"\"Test with a nested setting element.\"\"\"\n        xml_config = '<config><group><setting name=\"key1\">value1</setting></group></config>'\n        result = secure_xml_handler(xml_config)\n        self.assertEqual(result, {'key1': 'value1'})\n    \n    def test_empty_xml(self):\n        \"\"\"Test with an empty XML string.\"\"\"\n        with self.assertRaises(ParseError):\n            secure_xml_handler('')\n    \n    def test_no_settings(self):\n        \"\"\"Test XML without any setting elements.\"\"\"\n        xml_config = '<config></config>'\n        result = secure_xml_handler(xml_config)\n        self.assertEqual(result, {})\n    \n    def test_malformed_xml(self):\n        \"\"\"Test with malformed XML (missing closing tag).\"\"\"\n        xml_config = '<config><setting name=\"key1\">value1</config>'\n        with self.assertRaises(ParseError):\n            secure_xml_handler(xml_config)\n    \n    def test_setting_without_name(self):\n        \"\"\"Test a setting element without a name attribute.\"\"\"\n        xml_config = '<config><setting>value1</setting></config>'\n        result = secure_xml_handler(xml_config)\n        self.assertEqual(result, {None: 'value1'})\n    \n    def test_duplicate_keys(self):\n        \"\"\"Test duplicate setting names (last one should overwrite).\"\"\"\n        xml_config = '<config><setting name=\"key1\">first</setting><setting name=\"key1\">second</setting></config>'\n        result = secure_xml_handler(xml_config)\n        self.assertEqual(result, {'key1': 'second'})\n    \n    def test_xxe_attack(self):\n        \"\"\"Test XXE attack by including an external entity.\"\"\"\n        xml_config = '<!DOCTYPE foo [ <!ENTITY xxe SYSTEM \"file:///etc/passwd\" >]>\\n<config>\\n    <setting name=\"test\">&xxe;</setting>\\n</config>'\n        with self.assertRaises(EntitiesForbidden):\n            secure_xml_handler(xml_config)\n    \n    def test_with_comments(self):\n        \"\"\"Test XML containing comments.\"\"\"\n        xml_config = '<config><!-- comment --><setting name=\"key1\">value1</setting></config>'\n        result = secure_xml_handler(xml_config)\n        self.assertEqual(result, {'key1': 'value1'})\n    \n    def test_self_closing_setting(self):\n        \"\"\"Test a self-closing setting element.\"\"\"\n        xml_config = '<config><setting name=\"key1\"/></config>'\n        result = secure_xml_handler(xml_config)\n        self.assertEqual(result, {'key1': None})\n    \n    def test_setting_with_whitespace(self):\n        \"\"\"Test a setting element containing only whitespace.\"\"\"\n        xml_config = '<config><setting name=\"key1\">   </setting></config>'\n        result = secure_xml_handler(xml_config)\n        self.assertEqual(result, {'key1': '   '})\n    \n    def test_setting_with_mixed_content(self):\n        \"\"\"Test a setting with mixed text and child elements.\"\"\"\n        xml_config = '<config><setting name=\"a\">Hello <b>World</b></setting></config>'\n        result = secure_xml_handler(xml_config)\n        self.assertEqual(result, {'a': 'Hello '})\n    \n    def test_setting_with_explicit_empty(self):\n        \"\"\"Test an explicitly empty setting element (non-self-closing).\"\"\"\n        xml_config = '<config><setting name=\"key1\"></setting></config>'\n        result = secure_xml_handler(xml_config)\n        self.assertEqual(result, {'key1': None})", "num_test_cases": 14, "task_id": "7a01f921"}
{"test": "import unittest\\nfrom xml.etree.ElementTree import ParseError\\nfrom defusedxml.common import EntitiesForbidden\\n\\nclass TestXMLConfigParser(unittest.TestCase):\\n    \\n    def test_valid_multiple_settings(self):\\n        # Test parsing XML with multiple valid settings\\n        xml_data = '<root><setting name=\\\"color\\\">red</setting><setting name=\\\"size\\\">10</setting></root>'\\n        result = xml_config_parser(xml_data)\\n        self.assertEqual(result, {'color': 'red', 'size': '10'})\\n    \\n    def test_empty_xml(self):\\n        # Test with empty XML string (should raise ParseError)\\n        with self.assertRaises(ParseError):\\n            xml_config_parser('')\\n    \\n    def test_no_settings(self):\\n        # Test XML with no setting elements (should return empty dict)\\n        xml_data = '<root></root>'\\n        result = xml_config_parser(xml_data)\\n        self.assertEqual(result, {})\\n    \\n    def test_nested_settings(self):\\n        # Test XML with nested settings (should not be parsed)\\n        xml_data = '<root><settings><setting name=\\\"color\\\">blue</setting></settings></root>'\\n        result = xml_config_parser(xml_data)\\n        self.assertEqual(result, {})\\n    \\n    def test_setting_without_text(self):\\n        # Test setting element without text content (value should be None)\\n        xml_data = '<root><setting name=\\\"key1\\\"></setting></root>'\\n        result = xml_config_parser(xml_data)\\n        self.assertEqual(result, {'key1': None})\\n    \\n    def test_malformed_xml(self):\\n        # Test malformed XML (missing closing tag)\\n        xml_data = '<root><setting name=\\\"key1\\\">value1</root>'\\n        with self.assertRaises(ParseError):\\n            xml_config_parser(xml_data)\\n    \\n    def test_xxe_attack(self):\\n        # Test XML with XXE attack attempt (should raise EntitiesForbidden)\\n        xml_data = '<?xml version=\\\"1.0\\\"?><!DOCTYPE root [<!ENTITY xxe SYSTEM \\\"file:///etc/passwd\\\">]><root><setting name=\\\"username\\\">&xxe;</setting></root>'\\n        with self.assertRaises(EntitiesForbidden):\\n            xml_config_parser(xml_data)\\n    \\n    def test_setting_without_name(self):\\n        # Test setting element without name attribute\\n        xml_data = '<root><setting>value1</setting></root>'\\n        result = xml_config_parser(xml_data)\\n        self.assertEqual(result, {None: 'value1'})\\n    \\n    def test_duplicate_keys(self):\\n        # Test duplicate keys (last occurrence should overwrite)\\n        xml_data = '<root><setting name=\\\"key\\\">value1</setting><setting name=\\\"key\\\">value2</setting></root>'\\n        result = xml_config_parser(xml_data)\\n        self.assertEqual(result, {'key': 'value2'})\\n", "num_test_cases": 9, "task_id": "9f77d429"}
{"test": "import unittest\nfrom defusedxml.common import EntitiesForbidden\nfrom xml.etree.ElementTree import ParseError\n\nclass TestSafeXmlReader(unittest.TestCase):\n\n    def test_valid_xml_single_setting(self):\n        # Test with valid XML containing one setting\n        xml = '<root><setting name=\"key\">value</setting></root>'\n        result = safe_xml_reader(xml)\n        self.assertEqual(result, {'key': 'value'})\n\n    def test_valid_xml_multiple_settings(self):\n        # Test with valid XML containing multiple settings\n        xml = '<root><setting name=\"key1\">value1</setting><setting name=\"key2\">value2</setting></root>'\n        result = safe_xml_reader(xml)\n        self.assertEqual(result, {'key1': 'value1', 'key2': 'value2'})\n\n    def test_valid_xml_no_settings(self):\n        # Test with valid XML containing no setting elements\n        xml = '<root></root>'\n        result = safe_xml_reader(xml)\n        self.assertEqual(result, {})\n\n    def test_valid_xml_nested_settings(self):\n        # Test that only top-level setting elements are considered\n        xml = '<root><setting name=\"key1\">value1</setting><nested><setting name=\"key2\">value2</setting></nested></root>'\n        result = safe_xml_reader(xml)\n        self.assertEqual(result, {'key1': 'value1'})\n\n    def test_empty_string(self):\n        # Test with empty string (should fail parsing)\n        with self.assertRaises(ParseError):\n            safe_xml_reader('')\n\n    def test_none_input(self):\n        # Test with None input\n        with self.assertRaises(TypeError):\n            safe_xml_reader(None)\n\n    def test_non_string_input(self):\n        # Test with non-string input (integer)\n        with self.assertRaises(TypeError):\n            safe_xml_reader(123)\n\n    def test_malformed_xml(self):\n        # Test with malformed XML (missing closing tag)\n        xml = '<root><setting name=\"key\">value</setting>'\n        with self.assertRaises(ParseError):\n            safe_xml_reader(xml)\n\n    def test_xxe_attack(self):\n        # Test XML with external entity declaration\n        xml = '<?xml version=\"1.0\"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM \"file:///etc/passwd\">]><root><setting name=\"config\">&xxe;</setting></root>'\n        with self.assertRaises(EntitiesForbidden):\n            safe_xml_reader(xml)", "num_test_cases": 9, "task_id": "fed0819d"}
{"test": "import unittest\nimport defusedxml.ElementTree as ET\nfrom defusedxml.common import EntitiesForbidden\n\nclass TestParseProductXML(unittest.TestCase):\n\n    def test_basic(self):\n        # Test one product with valid data\n        xml_data = '<products><product id=\"1\"><name>Product 1</name><price>100</price></product></products>'\n        result = parse_product_xml(xml_data)\n        expected = {'1': {'name': 'Product 1', 'price': '100'}}\n        self.assertEqual(result, expected)\n\n    def test_multiple_products(self):\n        # Test multiple products with distinct IDs\n        xml_data = '<products><product id=\"1\"><name>Product 1</name><price>100</price></product><product id=\"2\"><name>Product 2</name><price>200</price></product></products>'\n        result = parse_product_xml(xml_data)\n        expected = {'1': {'name': 'Product 1', 'price': '100'}, '2': {'name': 'Product 2', 'price': '200'}}\n        self.assertEqual(result, expected)\n\n    def test_no_products(self):\n        # Test XML with no product elements\n        xml_data = '<products></products>'\n        result = parse_product_xml(xml_data)\n        self.assertEqual(result, {})\n\n    def test_malformed_xml(self):\n        # Test malformed XML structure\n        xml_data = '<products><product id=\"1\"><name>Product 1</name><price>100</price></product></malformed>'\n        with self.assertRaises(ET.ParseError):\n            parse_product_xml(xml_data)\n\n    def test_xxe_attack(self):\n        # Test XML containing external entity declaration\n        xml_data = '<?xml version=\"1.0\"?>\\n<!DOCTYPE foo [<!ENTITY xxe SYSTEM \"file:///etc/passwd\">]>\\n<products>\\n    <product id=\"1\">\\n        <name>&xxe;</name>\\n        <price>100</price>\\n    </product>\\n</products>'\n        with self.assertRaises(EntitiesForbidden):\n            parse_product_xml(xml_data)\n\n    def test_missing_id(self):\n        # Test product without id attribute\n        xml_data = '<products><product><name>Product 1</name><price>100</price></product></products>'\n        result = parse_product_xml(xml_data)\n        expected = {None: {'name': 'Product 1', 'price': '100'}}\n        self.assertEqual(result, expected)\n\n    def test_two_products_missing_id(self):\n        # Test multiple products without id attributes (overwrite behavior)\n        xml_data = '<products><product><name>Product 1</name><price>100</price></product><product><name>Product 2</name><price>200</price></product></products>'\n        result = parse_product_xml(xml_data)\n        self.assertEqual(len(result), 1)\n        self.assertEqual(result[None], {'name': 'Product 2', 'price': '200'})\n\n    def test_missing_name(self):\n        # Test product missing name element\n        xml_data = '<products><product id=\"1\"><price>100</price></product></products>'\n        with self.assertRaises(AttributeError):\n            parse_product_xml(xml_data)\n\n    def test_missing_price(self):\n        # Test product missing price element\n        xml_data = '<products><product id=\"1\"><name>Product 1</name></product></products>'\n        with self.assertRaises(AttributeError):\n            parse_product_xml(xml_data)\n\n    def test_empty_name_text(self):\n        # Test product with empty name text\n        xml_data = '<products><product id=\"1\"><name></name><price>100</price></product></products>'\n        result = parse_product_xml(xml_data)\n        expected = {'1': {'name': None, 'price': '100'}}\n        self.assertEqual(result, expected)\n\n    def test_empty_price_text(self):\n        # Test product with empty price text\n        xml_data = '<products><product id=\"1\"><name>Product 1</name><price></price></product></products>'\n        result = parse_product_xml(xml_data)\n        expected = {'1': {'name': 'Product 1', 'price': None}}\n        self.assertEqual(result, expected)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 11, "task_id": "e6fdf64f"}
{"test": "import unittest\nimport defusedxml.ElementTree as ET\nfrom defusedxml.common import EntitiesForbidden\n\nclass TestGetProductXML(unittest.TestCase):\n\n    def test_basic_product(self):\n        # Test with one valid product\n        data_xml = '''\n        <products>\n            <product id=\"1\">\n                <name>Product 1</name>\n                <price>100</price>\n            </product>\n        </products>\n        '''\n        result = get_product_xml(data_xml)\n        self.assertEqual(result, {\"1\": {\"name\": \"Product 1\", \"price\": \"100\"}})\n\n    def test_multiple_products(self):\n        # Test with multiple products\n        data_xml = '''\n        <products>\n            <product id=\"1\">\n                <name>Product 1</name>\n                <price>100</price>\n            </product>\n            <product id=\"2\">\n                <name>Product 2</name>\n                <price>200</price>\n            </product>\n        </products>\n        '''\n        result = get_product_xml(data_xml)\n        expected = {\n            \"1\": {\"name\": \"Product 1\", \"price\": \"100\"},\n            \"2\": {\"name\": \"Product 2\", \"price\": \"200\"}\n        }\n        self.assertEqual(result, expected)\n\n    def test_no_products(self):\n        # Test XML with no product elements\n        data_xml = '''\n        <products>\n        </products>\n        '''\n        result = get_product_xml(data_xml)\n        self.assertEqual(result, {})\n\n    def test_malformed_xml(self):\n        # Test with broken XML (missing closing tag)\n        data_xml = '''\n        <products>\n            <product id=\"1\">\n                <name>Product 1</name>\n                <price>100</price>\n            </product>\n        </products\n        '''\n        with self.assertRaises(ET.ParseError):\n            get_product_xml(data_xml)\n\n    def test_external_entity(self):\n        # Test XML with external entity (should be blocked)\n        data_xml = '''\n        <?xml version=\"1.0\"?>\n        <!DOCTYPE products [\n        <!ENTITY ext SYSTEM \"file:///etc/passwd\">\n        ]>\n        <products>\n            <product id=\"1\">\n                <name>&ext;</name>\n                <price>100</price>\n            </product>\n        </products>\n        '''\n        with self.assertRaises(EntitiesForbidden):\n            get_product_xml(data_xml)\n\n    def test_missing_id(self):\n        # Test product without id attribute\n        data_xml = '''\n        <products>\n            <product>\n                <name>Product 1</name>\n                <price>100</price>\n            </product>\n        </products>\n        '''\n        result = get_product_xml(data_xml)\n        self.assertEqual(result, {None: {\"name\": \"Product 1\", \"price\": \"100\"}})\n\n    def test_missing_name(self):\n        # Test product without name element\n        data_xml = '''\n        <products>\n            <product id=\"1\">\n                <price>100</price>\n            </product>\n        </products>\n        '''\n        with self.assertRaises(AttributeError):\n            get_product_xml(data_xml)\n\n    def test_missing_price(self):\n        # Test product without price element\n        data_xml = '''\n        <products>\n            <product id=\"1\">\n                <name>Product 1</name>\n            </product>\n        </products>\n        '''\n        with self.assertRaises(AttributeError):\n            get_product_xml(data_xml)\n\n    def test_multiple_missing_id(self):\n        # Test multiple products without id (overwrite in dict)\n        data_xml = '''\n        <products>\n            <product>\n                <name>Product 1</name>\n                <price>100</price>\n            </product>\n            <product>\n                <name>Product 2</name>\n                <price>200</price>\n            </product>\n        </products>\n        '''\n        result = get_product_xml(data_xml)\n        self.assertEqual(result, {None: {\"name\": \"Product 2\", \"price\": \"200\"}})\n\n    def test_empty_xml(self):\n        # Test with empty string input\n        data_xml = ''\n        with self.assertRaises(ET.ParseError):\n            get_product_xml(data_xml)", "num_test_cases": 10, "task_id": "5e2834a2"}
{"test": "import unittest\nfrom defusedxml.ElementTree import ParseError\n\nclass TestCases(unittest.TestCase):\n    def test_case_1(self):\n        # Test one product\n        xml = '''<root><product id=\"1\"><name>Product1</name><price>100</price></product></root>'''\n        result = fetch_product_xml(xml)\n        expected = {\"1\": {\"name\": \"Product1\", \"price\": \"100\"}}\n        self.assertEqual(result, expected)\n\n    def test_case_2(self):\n        # Test multiple products\n        xml = '''<root>\n            <product id=\"1\"><name>Product1</name><price>100</price></product>\n            <product id=\"2\"><name>Product2</name><price>200</price></product>\n        </root>'''\n        result = fetch_product_xml(xml)\n        expected = {\"1\": {\"name\": \"Product1\", \"price\": \"100\"}, \"2\": {\"name\": \"Product2\", \"price\": \"200\"}}\n        self.assertEqual(result, expected)\n\n    def test_case_3(self):\n        # Test well-formed empty XML\n        xml = '''<root></root>'''\n        result = fetch_product_xml(xml)\n        self.assertEqual(result, {})\n\n    def test_case_4(self):\n        # Test XML without products\n        xml = '''<root><other>data</other></root>'''\n        result = fetch_product_xml(xml)\n        self.assertEqual(result, {})\n\n    def test_case_5(self):\n        # Test malformed XML\n        xml = '''<root><product></root>'''\n        with self.assertRaises(ParseError):\n            fetch_product_xml(xml)\n\n    def test_case_6(self):\n        # Test unsafe XML (external entity)\n        xml = '''<?xml version=\"1.0\"?>\n        <!DOCTYPE foo [<!ENTITY xxe SYSTEM \"http://example.com\">]>\n        <root>\n            <product id=\"1\">\n                <name>&xxe;</name>\n                <price>100</price>\n            </product>\n        </root>'''\n        with self.assertRaises(ParseError):\n            fetch_product_xml(xml)\n\n    def test_case_7(self):\n        # Test product missing 'id'\n        xml = '''<root><product><name>Product1</name><price>100</price></product></root>'''\n        result = fetch_product_xml(xml)\n        expected = {None: {\"name\": \"Product1\", \"price\": \"100\"}}\n        self.assertEqual(result, expected)\n\n    def test_case_8(self):\n        # Test product missing 'name'\n        xml = '''<root><product id=\"1\"><price>100</price></product></root>'''\n        with self.assertRaises(AttributeError):\n            fetch_product_xml(xml)\n\n    def test_case_9(self):\n        # Test product missing 'price'\n        xml = '''<root><product id=\"1\"><name>Product1</name></product></root>'''\n        with self.assertRaises(AttributeError):\n            fetch_product_xml(xml)\n\n    def test_case_10(self):\n        # Test empty name and price\n        xml = '''<root><product id=\"1\"><name></name><price></price></product></root>'''\n        result = fetch_product_xml(xml)\n        expected = {\"1\": {\"name\": \"\", \"price\": \"\"}}\n        self.assertEqual(result, expected)\n\n    def test_case_11(self):\n        # Test duplicate product IDs\n        xml = '''<root>\n            <product id=\"1\"><name>Product1</name><price>100</price></product>\n            <product id=\"1\"><name>Product2</name><price>200</price></product>\n        </root>'''\n        result = fetch_product_xml(xml)\n        expected = {\"1\": {\"name\": \"Product2\", \"price\": \"200\"}}\n        self.assertEqual(result, expected)\n\n    def test_case_12(self):\n        # Test special characters in text\n        xml = '''<root><product id=\"1\"><name>Product &amp; More</name><price>100</price></product></root>'''\n        result = fetch_product_xml(xml)\n        expected = {\"1\": {\"name\": \"Product & More\", \"price\": \"100\"}}\n        self.assertEqual(result, expected)\n\n    def test_case_13(self):\n        # Test nested elements (only text content captured)\n        xml = '''<root><product id=\"1\"><name>Product<b>1</b></name><price>100</price></product></root>'''\n        result = fetch_product_xml(xml)\n        expected = {\"1\": {\"name\": \"Product\", \"price\": \"100\"}}\n        self.assertEqual(result, expected)\n\n    def test_case_14(self):\n        # Test empty string as product ID\n        xml = '''<root><product id=\"\"><name>Product1</name><price>100</price></product></root>'''\n        result = fetch_product_xml(xml)\n        expected = {\"\": {\"name\": \"Product1\", \"price\": \"100\"}}\n        self.assertEqual(result, expected)\n\n    def test_case_15(self):\n        # Test None input\n        with self.assertRaises(TypeError):\n            fetch_product_xml(None)\n\n    def test_case_16(self):\n        # Test non-string input (integer)\n        with self.assertRaises(TypeError):\n            fetch_product_xml(123)\n\n    def test_case_17(self):\n        # Test empty string input\n        with self.assertRaises(ParseError):\n            fetch_product_xml('')", "num_test_cases": 17, "task_id": "587aa8a0"}
{"test": "import unittest\n\nclass TestCases(unittest.TestCase):\n    def test_case_1(self):\n        # Test valid XML with one product\n        xml_data = '<root><product id=\"1\"><name>Product 1</name><price>100</price></product></root>'\n        result = parse_product_xml(xml_data)\n        self.assertEqual(result, {'1': {'name': 'Product 1', 'price': '100'}})\n\n    def test_case_2(self):\n        # Test valid XML with multiple products\n        xml_data = '<root><product id=\"1\"><name>Product 1</name><price>100</price></product><product id=\"2\"><name>Product 2</name><price>200</price></product></root>'\n        result = parse_product_xml(xml_data)\n        expected = {'1': {'name': 'Product 1', 'price': '100'}, '2': {'name': 'Product 2', 'price': '200'}}\n        self.assertEqual(result, expected)\n\n    def test_case_3(self):\n        # Test XML with no products\n        xml_data = '<root></root>'\n        result = parse_product_xml(xml_data)\n        self.assertEqual(result, {})\n\n    def test_case_4(self):\n        # Test malformed XML (unclosed tag)\n        xml_data = '<root><product></root>'\n        with self.assertRaises(Exception):\n            parse_product_xml(xml_data)\n\n    def test_case_5(self):\n        # Test XML with XXE attack\n        xml_xxe = '<?xml version=\"1.0\"?><!DOCTYPE root [<!ENTITY ext SYSTEM \"file:///etc/passwd\">]><root><product id=\"1\"><name>&ext;</name><price>100</price></product></root>'\n        with self.assertRaises(Exception):\n            parse_product_xml(xml_xxe)\n\n    def test_case_6(self):\n        # Test product without id (and one with id)\n        xml_data = '<root><product><name>Product Without ID</name><price>300</price></product><product id=\"2\"><name>Product 2</name><price>200</price></product></root>'\n        result = parse_product_xml(xml_data)\n        expected = {None: {'name': 'Product Without ID', 'price': '300'}, '2': {'name': 'Product 2', 'price': '200'}}\n        self.assertEqual(result, expected)\n\n    def test_case_7(self):\n        # Test two products without id (overwriting)\n        xml_data = '<root><product><name>Product 1</name><price>100</price></product><product><name>Product 2</name><price>200</price></product></root>'\n        result = parse_product_xml(xml_data)\n        self.assertEqual(result, {None: {'name': 'Product 2', 'price': '200'}})\n\n    def test_case_8(self):\n        # Test product without name element\n        xml_data = '<root><product id=\"1\"><price>100</price></product></root>'\n        with self.assertRaises(AttributeError):\n            parse_product_xml(xml_data)\n\n    def test_case_9(self):\n        # Test product without price element\n        xml_data = '<root><product id=\"1\"><name>Product 1</name></product></root>'\n        with self.assertRaises(AttributeError):\n            parse_product_xml(xml_data)\n\n    def test_case_10(self):\n        # Test product with empty name and price text\n        xml_data = '<root><product id=\"1\"><name></name><price></price></product></root>'\n        result = parse_product_xml(xml_data)\n        self.assertEqual(result, {'1': {'name': '', 'price': ''}})\n\n    def test_case_11(self):\n        # Test duplicate product IDs (overwriting)\n        xml_data = '<root><product id=\"1\"><name>Product 1</name><price>100</price></product><product id=\"1\"><name>Product 2</name><price>200</price></product></root>'\n        result = parse_product_xml(xml_data)\n        self.assertEqual(result, {'1': {'name': 'Product 2', 'price': '200'}})\n\n    def test_case_12(self):\n        # Test self-closing elements\n        xml_data = '<root><product id=\"1\"><name/><price>10</price></product><product id=\"2\"><name>Product</name><price/></product></root>'\n        result = parse_product_xml(xml_data)\n        expected = {'1': {'name': None, 'price': '10'}, '2': {'name': 'Product', 'price': None}}\n        self.assertEqual(result, expected)", "num_test_cases": 12, "task_id": "1d73457b"}
{"test": "import unittest\nfrom defusedxml.common import EntitiesForbidden\n\nclass TestExtractProductDetails(unittest.TestCase):\n\n    def test_basic_product(self):\n        # Test single product with all fields\n        xml = '''\n        <root>\n            <product id=\"101\">\n                <name>Laptop</name>\n                <price>999.99</price>\n            </product>\n        </root>\n        '''\n        result = extract_product_details(xml)\n        expected = {\n            \"101\": {\"name\": \"Laptop\", \"price\": \"999.99\"}\n        }\n        self.assertEqual(result, expected)\n\n    def test_multiple_products(self):\n        # Test multiple products\n        xml = '''\n        <root>\n            <product id=\"101\">\n                <name>Laptop</name>\n                <price>999.99</price>\n            </product>\n            <product id=\"202\">\n                <name>Mouse</name>\n                <price>19.99</price>\n            </product>\n        </root>\n        '''\n        result = extract_product_details(xml)\n        expected = {\n            \"101\": {\"name\": \"Laptop\", \"price\": \"999.99\"},\n            \"202\": {\"name\": \"Mouse\", \"price\": \"19.99\"}\n        }\n        self.assertEqual(result, expected)\n\n    def test_empty_xml(self):\n        # Test empty XML string\n        with self.assertRaises(Exception):\n            extract_product_details('')\n\n    def test_no_products(self):\n        # Test XML with no product elements\n        xml = '''\n        <root>\n            <category>Electronics</category>\n        </root>\n        '''\n        result = extract_product_details(xml)\n        self.assertEqual(result, {})\n\n    def test_malformed_xml(self):\n        # Test malformed XML (unclosed tag)\n        xml = '''\n        <root>\n            <product id=\"101\">\n                <name>Laptop</name>\n                <price>999.99\n            </product>\n        '''\n        with self.assertRaises(Exception):\n            extract_product_details(xml)\n\n    def test_xxe_attack(self):\n        # Test XML with XXE attack attempt\n        xml = '''\n        <!DOCTYPE root [\n            <!ENTITY xxe SYSTEM \"file:///etc/passwd\">\n        ]>\n        <root>\n            <product id=\"101\">\n                <name>&xxe;</name>\n                <price>999.99</price>\n            </product>\n        </root>\n        '''\n        with self.assertRaises(EntitiesForbidden):\n            extract_product_details(xml)\n\n    def test_missing_id(self):\n        # Test product missing id attribute\n        xml = '''\n        <root>\n            <product>\n                <name>Laptop</name>\n                <price>999.99</price>\n            </product>\n        </root>\n        '''\n        result = extract_product_details(xml)\n        self.assertIn(None, result)\n        self.assertEqual(result[None][\"name\"], \"Laptop\")\n\n    def test_missing_name(self):\n        # Test product missing name element\n        xml = '''\n        <root>\n            <product id=\"101\">\n                <price>999.99</price>\n            </product>\n        </root>\n        '''\n        with self.assertRaises(AttributeError):\n            extract_product_details(xml)\n\n    def test_missing_price(self):\n        # Test product missing price element\n        xml = '''\n        <root>\n            <product id=\"101\">\n                <name>Laptop</name>\n            </product>\n        </root>\n        '''\n        with self.assertRaises(AttributeError):\n            extract_product_details(xml)\n\n    def test_duplicate_ids(self):\n        # Test duplicate product IDs (last occurrence should overwrite)\n        xml = '''\n        <root>\n            <product id=\"101\">\n                <name>Laptop</name>\n                <price>999.99</price>\n            </product>\n            <product id=\"101\">\n                <name>Overwritten</name>\n                <price>0.99</price>\n            </product>\n        </root>\n        '''\n        result = extract_product_details(xml)\n        expected = {\n            \"101\": {\"name\": \"Overwritten\", \"price\": \"0.99\"}\n        }\n        self.assertEqual(result, expected)\n\n    def test_non_numeric_id(self):\n        # Test non-numeric product ID\n        xml = '''\n        <root>\n            <product id=\"P101\">\n                <name>Laptop</name>\n                <price>999.99</price>\n            </product>\n        </root>\n        '''\n        result = extract_product_details(xml)\n        expected = {\n            \"P101\": {\"name\": \"Laptop\", \"price\": \"999.99\"}\n        }\n        self.assertEqual(result, expected)\n\n    def test_large_xml_input(self):\n        # Test large XML input\n        xml = '<root>' + '\\n'.join(\n            f'<product id=\"{i}\"><name>Product {i}</name><price>{i*10}</price></product>' \n            for i in range(1, 1001)\n        ) + '</root>'\n        result = extract_product_details(xml)\n        self.assertEqual(len(result), 1000)\n        self.assertEqual(result[\"500\"][\"name\"], \"Product 500\")\n        self.assertEqual(result[\"500\"][\"price\"], \"5000\")\n", "num_test_cases": 12, "task_id": "5056f452"}
{"test": "import unittest\nfrom xml.etree.ElementTree import ParseError\nfrom defusedxml.common import EntitiesForbidden\n\nclass TestCases(unittest.TestCase):\n    def test_case_1(self):\n        # Test valid XML with one product\n        xml_data = '<root><product id=\"1\"><name>Product1</name><price>100</price></product></root>'\n        result = get_product_info(xml_data)\n        expected = {'1': {'name': 'Product1', 'price': '100'}}\n        self.assertEqual(result, expected)\n\n    def test_case_2(self):\n        # Test valid XML with multiple products\n        xml_data = '<root><product id=\"1\"><name>Product1</name><price>100</price></product><product id=\"2\"><name>Product2</name><price>200</price></product></root>'\n        result = get_product_info(xml_data)\n        expected = {'1': {'name': 'Product1', 'price': '100'}, '2': {'name': 'Product2', 'price': '200'}}\n        self.assertEqual(result, expected)\n\n    def test_case_3(self):\n        # Test valid XML with no products\n        xml_data = '<root></root>'\n        result = get_product_info(xml_data)\n        self.assertEqual(result, {})\n\n    def test_case_4(self):\n        # Test empty XML string\n        xml_data = ''\n        with self.assertRaises(ParseError):\n            get_product_info(xml_data)\n\n    def test_case_5(self):\n        # Test malformed XML\n        xml_data = '<root><product></root>'  # Missing closing tag\n        with self.assertRaises(ParseError):\n            get_product_info(xml_data)\n\n    def test_case_6(self):\n        # Test XXE attempt\n        xml_data = '<?xml version=\"1.0\"?>\\n<!DOCTYPE root [\\n<!ENTITY test SYSTEM \"file:///dev/null\">]>\\n<root>\\n  <product id=\"1\">\\n     <name>&test;</name>\\n     <price>100</price>\\n  </product>\\n</root>'\n        with self.assertRaises(EntitiesForbidden):\n            get_product_info(xml_data)", "num_test_cases": 6, "task_id": "852b2432"}
{"test": "import unittest\nimport defusedxml.ElementTree as ET\n\nclass TestProductXMLParsing(unittest.TestCase):\n    \n    def test_valid_single_product(self):\n        # Test with valid XML containing one product\n        data = '<root><product id=\"1\"><name>Product A</name><price>100</price></product></root>'\n        expected = {'1': {'name': 'Product A', 'price': '100'}}\n        self.assertEqual(parse_product_xml(data), expected)\n    \n    def test_valid_multiple_products(self):\n        # Test with valid XML containing multiple products\n        data = '<root><product id=\"1\"><name>A</name><price>1</price></product><product id=\"2\"><name>B</name><price>2</price></product></root>'\n        expected = {'1': {'name': 'A', 'price': '1'}, '2': {'name': 'B', 'price': '2'}}\n        self.assertEqual(parse_product_xml(data), expected)\n    \n    def test_empty_xml(self):\n        # Test with empty XML string (should be malformed)\n        data = ''\n        with self.assertRaises(ET.ParseError):\n            parse_product_xml(data)\n    \n    def test_malformed_xml(self):\n        # Test with malformed XML (unclosed tag)\n        data = '<root><product id=\"1\"><name>A</name><price>1</product></root>'  # Unclosed 'price' tag\n        with self.assertRaises(ET.ParseError):\n            parse_product_xml(data)\n    \n    def test_missing_element(self):\n        # Test XML missing required 'price' element (should cause AttributeError)\n        data = '<root><product id=\"1\"><name>A</name></product></root>'\n        with self.assertRaises(AttributeError):\n            parse_product_xml(data)\n    \n    def test_missing_id_attribute(self):\n        # Test XML with product missing 'id' attribute\n        data = '<root><product><name>A</name><price>1</price></product></root>'\n        expected = {None: {'name': 'A', 'price': '1'}}\n        self.assertEqual(parse_product_xml(data), expected)\n    \n    def test_empty_element(self):\n        # Test empty 'name' element (should return None for name)\n        data = '<root><product id=\"1\"><name></name><price>100</price></product></root>'\n        expected = {'1': {'name': None, 'price': '100'}}\n        self.assertEqual(parse_product_xml(data), expected)\n    \n    def test_xxe_attack(self):\n        # Test XML with external entity (should be blocked by security policy)\n        data = '<?xml version=\"1.0\"?>\\n<!DOCTYPE data [\\n<!ENTITY xxe SYSTEM \"file:///etc/passwd\">\\n]>\\n<root>\\n<product id=\"1\">\\n<name>&xxe;</name>\\n<price>100</price>\\n</product>\\n</root>'\n        with self.assertRaises(ValueError):  # defusedxml raises ValueError for XXE\n            parse_product_xml(data)\n    \n    def test_non_string_input_none(self):\n        # Test None input (should raise TypeError)\n        with self.assertRaises(TypeError):\n            parse_product_xml(None)\n    \n    def test_non_string_input_integer(self):\n        # Test integer input (should raise TypeError)\n        with self.assertRaises(TypeError):\n            parse_product_xml(123)", "num_test_cases": 10, "task_id": "7e409e3d"}
{"test": "import unittest\nfrom defusedxml.common import EntitiesForbidden\n\nclass TestCases(unittest.TestCase):\n\n    def test_case_1(self):\n        # Test with single valid product\n        xml_data = '<catalog><product id=\"1\"><name>Product1</name><price>100</price></product></catalog>'\n        result = fetch_product_xml(xml_data)\n        expected = {'1': {'name': 'Product1', 'price': '100'}}\n        self.assertEqual(result, expected)\n\n    def test_case_2(self):\n        # Test with multiple valid products\n        xml_data = '<catalog><product id=\"1\"><name>Product1</name><price>100</price></product><product id=\"2\"><name>Product2</name><price>200</price></product></catalog>'\n        result = fetch_product_xml(xml_data)\n        expected = {\n            '1': {'name': 'Product1', 'price': '100'},\n            '2': {'name': 'Product2', 'price': '200'}\n        }\n        self.assertEqual(result, expected)\n\n    def test_case_3(self):\n        # Test with no products\n        xml_data = '<catalog></catalog>'\n        result = fetch_product_xml(xml_data)\n        self.assertEqual(result, {})\n\n    def test_case_4(self):\n        # Test malformed XML (missing closing tag)\n        xml_data = '<catalog><product id=\"1\"><name>Product1</name><price>100</price></product>'\n        with self.assertRaises(Exception):\n            fetch_product_xml(xml_data)\n\n    def test_case_5(self):\n        # Test empty string input\n        xml_data = ''\n        with self.assertRaises(Exception):\n            fetch_product_xml(xml_data)\n\n    def test_case_6(self):\n        # Test XML with external entity (XXE)\n        xml_data = '<!DOCTYPE foo [<!ENTITY xxe SYSTEM \"file:///etc/passwd\">]><catalog><product id=\"1\"><name>Test &xxe;</name><price>100</price></product></catalog>'\n        with self.assertRaises(EntitiesForbidden):\n            fetch_product_xml(xml_data)\n\n    def test_case_7(self):\n        # Test product without id attribute\n        xml_data = '<catalog><product><name>Product1</name><price>100</price></product></catalog>'\n        result = fetch_product_xml(xml_data)\n        expected = {None: {'name': 'Product1', 'price': '100'}}\n        self.assertEqual(result, expected)\n\n    def test_case_8(self):\n        # Test product without name element\n        xml_data = '<catalog><product id=\"1\"><price>100</price></product></catalog>'\n        with self.assertRaises(AttributeError):\n            fetch_product_xml(xml_data)\n\n    def test_case_9(self):\n        # Test product without price element\n        xml_data = '<catalog><product id=\"1\"><name>Product1</name></product></catalog>'\n        with self.assertRaises(AttributeError):\n            fetch_product_xml(xml_data)\n\n    def test_case_10(self):\n        # Test product with empty name\n        xml_data = '<catalog><product id=\"1\"><name></name><price>100</price></product></catalog>'\n        result = fetch_product_xml(xml_data)\n        expected = {'1': {'name': '', 'price': '100'}}\n        self.assertEqual(result, expected)\n\n    def test_case_11(self):\n        # Test product with empty price\n        xml_data = '<catalog><product id=\"1\"><name>Product1</name><price></price></product></catalog>'\n        result = fetch_product_xml(xml_data)\n        expected = {'1': {'name': 'Product1', 'price': ''}}\n        self.assertEqual(result, expected)\n\n    def test_case_12(self):\n        # Test duplicate product ids (last one should overwrite)\n        xml_data = '<catalog><product id=\"1\"><name>Product1</name><price>100</price></product><product id=\"1\"><name>Product2</name><price>200</price></product></catalog>'\n        result = fetch_product_xml(xml_data)\n        expected = {'1': {'name': 'Product2', 'price': '200'}}\n        self.assertEqual(result, expected)\n", "num_test_cases": 12, "task_id": "ee2aca89"}
{"test": "import unittest\nfrom defusedxml.common import EntitiesForbidden\nfrom xml.etree.ElementTree import ParseError\n\nclass TestProcessProductXml(unittest.TestCase):\n\n    def test_valid_one_product(self):\n        # Test XML with one complete product\n        xml_payload = '''<root>\n                            <product id=\"1\">\n                                <name>Product 1</name>\n                                <price>100.0</price>\n                            </product>\n                         </root>'''\n        result = process_product_xml(xml_payload)\n        expected = {'1': {'name': 'Product 1', 'price': '100.0'}}\n        self.assertEqual(result, expected)\n\n    def test_valid_multiple_products(self):\n        # Test XML with multiple complete products\n        xml_payload = '''<root>\n                            <product id=\"1\">\n                                <name>Product 1</name>\n                                <price>100.0</price>\n                            </product>\n                            <product id=\"2\">\n                                <name>Product 2</name>\n                                <price>200.0</price>\n                            </product>\n                         </root>'''\n        result = process_product_xml(xml_payload)\n        expected = {\n            '1': {'name': 'Product 1', 'price': '100.0'},\n            '2': {'name': 'Product 2', 'price': '200.0'}\n        }\n        self.assertEqual(result, expected)\n\n    def test_no_products(self):\n        # Test XML with no product elements\n        xml_payload = '''<root></root>'''\n        result = process_product_xml(xml_payload)\n        self.assertEqual(result, {})\n\n    def test_malformed_xml(self):\n        # Test invalid XML structure\n        xml_payload = '''<root>\n                            <product id=\"1\">\n                                <name>Product 1</name>\n                                <price>100.0</price>\n                            </product>\n                         </root'''  # Malformed: missing closing '>'\n        with self.assertRaises(ParseError):\n            process_product_xml(xml_payload)\n\n    def test_xxe_attack(self):\n        # Test XML with external entity declaration\n        xml_payload = '''<?xml version=\"1.0\"?>\n<!DOCTYPE root [\n<!ENTITY external SYSTEM 'file:///dev/null'>\n]>\n<root>\n    <product id=\"1\">\n        <name>Product 1</name>\n        <price>100.0</price>\n    </product>\n</root>'''\n        with self.assertRaises(EntitiesForbidden):\n            process_product_xml(xml_payload)\n\n    def test_missing_id_single(self):\n        # Test one product without id attribute\n        xml_payload = '''<root>\n                            <product>\n                                <name>Product 1</name>\n                                <price>100.0</price>\n                            </product>\n                         </root>'''\n        result = process_product_xml(xml_payload)\n        expected = {None: {'name': 'Product 1', 'price': '100.0'}}\n        self.assertEqual(result, expected)\n\n    def test_missing_id_multiple(self):\n        # Test multiple products without id attributes\n        xml_payload = '''<root>\n                            <product>\n                                <name>Product 1</name>\n                                <price>100.0</price>\n                            </product>\n                            <product>\n                                <name>Product 2</name>\n                                <price>200.0</price>\n                            </product>\n                         </root>'''\n        result = process_product_xml(xml_payload)\n        expected = {None: {'name': 'Product 2', 'price': '200.0'}}\n        self.assertEqual(result, expected)\n\n    def test_missing_name(self):\n        # Test product missing name element\n        xml_payload = '''<root>\n                            <product id=\"1\">\n                                <price>100.0</price>\n                            </product>\n                         </root>'''\n        with self.assertRaises(AttributeError):\n            process_product_xml(xml_payload)\n\n    def test_missing_price(self):\n        # Test product missing price element\n        xml_payload = '''<root>\n                            <product id=\"1\">\n                                <name>Product 1</name>\n                            </product>\n                         </root>'''\n        with self.assertRaises(AttributeError):\n            process_product_xml(xml_payload)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 9, "task_id": "ccced814"}
{"test": "import unittest\nfrom defusedxml.ElementTree import ParseError\nfrom defusedxml.common import EntitiesForbidden\n\nclass TestHandleInvoiceXml(unittest.TestCase):\n\n    def test_valid_xml(self):\n        # Test minimal valid XML structure\n        data = '<invoice><invoice_id>123</invoice_id><client_name>John Doe</client_name><amount>100.0</amount></invoice>'\n        result = handle_invoice_xml(data)\n        expected = {'invoice_id': '123', 'client_name': 'John Doe', 'amount': '100.0'}\n        self.assertEqual(result, expected)\n\n    def test_valid_xml_with_extra_fields(self):\n        # Test XML with additional fields (should ignore extra fields)\n        data = '<invoice><invoice_id>124</invoice_id><client_name>Jane Smith</client_name><amount>200.0</amount><date>2023-01-01</date></invoice>'\n        result = handle_invoice_xml(data)\n        expected = {'invoice_id': '124', 'client_name': 'Jane Smith', 'amount': '200.0'}\n        self.assertEqual(result, expected)\n\n    def test_missing_required_field(self):\n        # Test XML missing one required field (amount)\n        data = '<invoice><invoice_id>125</invoice_id><client_name>John Doe</client_name></invoice>'\n        with self.assertRaises(AttributeError):\n            handle_invoice_xml(data)\n\n    def test_empty_string(self):\n        # Test empty input string\n        data = ''\n        with self.assertRaises(ParseError):\n            handle_invoice_xml(data)\n\n    def test_malformed_xml(self):\n        # Test improperly structured XML\n        data = '<invoice><invoice_id>126</invoice_id><client_name>John Doe</amount></invoice>'\n        with self.assertRaises(ParseError):\n            handle_invoice_xml(data)\n\n    def test_external_entity(self):\n        # Test XML attempting external entity access\n        data = '''<?xml version='1.0'?>\n<!DOCTYPE foo [\n<!ELEMENT foo ANY >\n<!ENTITY xxe SYSTEM 'file:///etc/passwd' >]>\n<invoice>\n    <invoice_id>&xxe;</invoice_id>\n    <client_name>John Doe</client_name>\n    <amount>100.0</amount>\n</invoice>'''\n        with self.assertRaises(EntitiesForbidden):\n            handle_invoice_xml(data)\n\n    def test_empty_field(self):\n        # Test XML with an empty field value\n        data = '<invoice><invoice_id></invoice_id><client_name>John Doe</client_name><amount>100.0</amount></invoice>'\n        result = handle_invoice_xml(data)\n        expected = {'invoice_id': '', 'client_name': 'John Doe', 'amount': '100.0'}\n        self.assertEqual(result, expected)\n\n    def test_non_string_input(self):\n        # Test non-string input (None)\n        with self.assertRaises(TypeError):\n            handle_invoice_xml(None)\n\n    def test_whitespace_only(self):\n        # Test XML containing only whitespace\n        data = '   '\n        with self.assertRaises(ParseError):\n            handle_invoice_xml(data)\n\n    def test_numeric_values(self):\n        # Test numeric field values\n        data = '<invoice><invoice_id>789</invoice_id><client_name>Acme Inc</client_name><amount>500</amount></invoice>'\n        result = handle_invoice_xml(data)\n        expected = {'invoice_id': '789', 'client_name': 'Acme Inc', 'amount': '500'}\n        self.assertEqual(result, expected)\n", "num_test_cases": 10, "task_id": "956e2158"}
{"test": "import unittest\nimport defusedxml.ElementTree as ET\n\nclass TestParseInvoiceXML(unittest.TestCase):\n\n    def test_case_1(self):\n        # Test valid XML with all fields present and non-empty\n        xml = '''<invoice>\n    <invoice_id>INV123</invoice_id>\n    <client_name>John Doe</client_name>\n    <amount>1000.00</amount>\n</invoice>'''\n        expected = {'invoice_id': 'INV123', 'client_name': 'John Doe', 'amount': '1000.00'}\n        result = parse_invoice_xml(xml)\n        self.assertEqual(result, expected)\n\n    def test_case_2(self):\n        # Test valid XML with client_name element empty (text is empty string)\n        xml = '''<invoice>\n    <invoice_id>INV123</invoice_id>\n    <client_name></client_name>\n    <amount>1000.00</amount>\n</invoice>'''\n        expected = {'invoice_id': 'INV123', 'client_name': '', 'amount': '1000.00'}\n        result = parse_invoice_xml(xml)\n        self.assertEqual(result, expected)\n\n    def test_case_3(self):\n        # Test missing field (amount)\n        xml = '''<invoice>\n    <invoice_id>INV123</invoice_id>\n    <client_name>John Doe</client_name>\n</invoice>'''\n        with self.assertRaises(AttributeError):\n            parse_invoice_xml(xml)\n\n    def test_case_4(self):\n        # Test malformed XML (missing closing tag for invoice_id)\n        xml = '''<invoice>\n    <invoice_id>INV123\n    <client_name>John Doe</client_name>\n    <amount>1000.00</amount>\n</invoice>'''\n        with self.assertRaises(ET.ParseError):\n            parse_invoice_xml(xml)\n\n    def test_case_5(self):\n        # Test XML with external entity\n        xml = '''<?xml version='1.0'?>\n<!DOCTYPE invoice [\n  <!ENTITY xxe SYSTEM 'file:///etc/passwd'>\n]>\n<invoice>\n    <invoice_id>INV123</invoice_id>\n    <client_name>&xxe;</client_name>\n    <amount>1000.00</amount>\n</invoice>'''\n        with self.assertRaises(ET.ParseError):\n            parse_invoice_xml(xml)\n\n    def test_case_6(self):\n        # Test empty string input\n        with self.assertRaises(ET.ParseError):\n            parse_invoice_xml('')\n\n    def test_case_7(self):\n        # Test None input\n        with self.assertRaises(TypeError):\n            parse_invoice_xml(None)\n\n    def test_case_8(self):\n        # Test non-string input (integer)\n        with self.assertRaises(TypeError):\n            parse_invoice_xml(123)\n\n    def test_case_9(self):\n        # Test self-closing tag for client_name\n        xml = '''<invoice>\n    <invoice_id>INV123</invoice_id>\n    <client_name/>\n    <amount>1000.00</amount>\n</invoice>'''\n        expected = {'invoice_id': 'INV123', 'client_name': None, 'amount': '1000.00'}\n        result = parse_invoice_xml(xml)\n        self.assertEqual(result, expected)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 9, "task_id": "7733a674"}
{"test": "import unittest\nfrom defusedxml.ElementTree import ParseError\n\nclass TestProcessPaymentXML(unittest.TestCase):\n\n    def test_happy_path(self):\n        \"\"\"Test valid XML with all required fields.\"\"\"\n        xml = '<root><invoice_id>123</invoice_id><client_name>John Doe</client_name><amount>100.00</amount></root>'\n        result = process_payment_xml(xml)\n        self.assertEqual(result, {'invoice_id': '123', 'client_name': 'John Doe', 'amount': '100.00'})\n\n    def test_empty_fields(self):\n        \"\"\"Test XML with empty field values.\"\"\"\n        xml = '<root><invoice_id></invoice_id><client_name></client_name><amount></amount></root>'\n        result = process_payment_xml(xml)\n        self.assertEqual(result, {'invoice_id': None, 'client_name': None, 'amount': None})\n\n    def test_missing_field(self):\n        \"\"\"Test XML missing a required field.\"\"\"\n        xml = '<root><invoice_id>123</invoice_id><client_name>John Doe</client_name></root>'\n        with self.assertRaises(AttributeError):\n            process_payment_xml(xml)\n\n    def test_malformed_xml(self):\n        \"\"\"Test malformed XML (missing closing tag).\"\"\"\n        xml = '<root><invoice_id>123</invoice_id><client_name>John Doe</client_name><amount>100.00'\n        with self.assertRaises(ParseError):\n            process_payment_xml(xml)\n\n    def test_external_entity(self):\n        \"\"\"Test XML with external entity declaration.\"\"\"\n        xml = '<?xml version=\"1.0\"?><!DOCTYPE foo [<!ELEMENT foo ANY><!ENTITY xxe SYSTEM \"file:///etc/passwd\">]><foo>&xxe;</foo>'\n        with self.assertRaises(ParseError):\n            process_payment_xml(xml)\n\n    def test_extra_fields(self):\n        \"\"\"Test XML with extra fields (should be ignored).\"\"\"\n        xml = '<root><invoice_id>123</invoice_id><client_name>John Doe</client_name><amount>100.00</amount><date>2021-01-01</date></root>'\n        result = process_payment_xml(xml)\n        self.assertEqual(result, {'invoice_id': '123', 'client_name': 'John Doe', 'amount': '100.00'})\n\n    def test_nested_structure(self):\n        \"\"\"Test XML with nested elements (required fields not direct children).\"\"\"\n        xml = '<root><header><invoice_id>123</invoice_id></header><client_name>John Doe</client_name><amount>100.00</amount></root>'\n        with self.assertRaises(AttributeError):\n            process_payment_xml(xml)\n\n    def test_non_string_input_none(self):\n        \"\"\"Test None input (non-string).\"\"\"\n        with self.assertRaises(TypeError):\n            process_payment_xml(None)\n\n    def test_non_string_input_int(self):\n        \"\"\"Test integer input (non-string).\"\"\"\n        with self.assertRaises(TypeError):\n            process_payment_xml(123)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 9, "task_id": "615b14ce"}
{"test": "import unittest\nfrom defusedxml.ElementTree import ParseError\nfrom defusedxml.common import EntitiesForbidden\n\nclass TestParseInvoiceData(unittest.TestCase):\n\n    def test_valid_xml(self):\n        # Test with valid XML containing all required fields\n        xml_str = '<root><invoice_id>INV123</invoice_id><client_name>John Doe</client_name><amount>100.00</amount></root>'\n        result = parse_invoice_data(xml_str)\n        self.assertEqual(result, {'invoice_id': 'INV123', 'client_name': 'John Doe', 'amount': '100.00'})\n\n    def test_empty_fields(self):\n        # Test XML with present but empty fields\n        xml_str = '<root><invoice_id></invoice_id><client_name></client_name><amount></amount></root>'\n        result = parse_invoice_data(xml_str)\n        self.assertEqual(result, {'invoice_id': None, 'client_name': None, 'amount': None})\n\n    def test_missing_invoice_id(self):\n        # Test XML missing invoice_id element\n        xml_str = '<root><client_name>John Doe</client_name><amount>100.00</amount></root>'\n        with self.assertRaises(AttributeError):\n            parse_invoice_data(xml_str)\n\n    def test_missing_client_name(self):\n        # Test XML missing client_name element\n        xml_str = '<root><invoice_id>INV123</invoice_id><amount>100.00</amount></root>'\n        with self.assertRaises(AttributeError):\n            parse_invoice_data(xml_str)\n\n    def test_missing_amount(self):\n        # Test XML missing amount element\n        xml_str = '<root><invoice_id>INV123</invoice_id><client_name>John Doe</client_name></root>'\n        with self.assertRaises(AttributeError):\n            parse_invoice_data(xml_str)\n\n    def test_malformed_xml(self):\n        # Test with syntactically invalid XML\n        xml_str = '<root><invoice_id>INV123</client_name>'\n        with self.assertRaises(ParseError):\n            parse_invoice_data(xml_str)\n\n    def test_xxe_attack(self):\n        # Test XML containing external entity declarations\n        xxe_xml = '<?xml version=\"1.0\"?><!DOCTYPE root [<!ENTITY xxe SYSTEM \"file:///etc/passwd\">]><root><invoice_id>INV123</invoice_id><client_name>&xxe;</client_name><amount>100.00</amount></root>'\n        with self.assertRaises(EntitiesForbidden):\n            parse_invoice_data(xxe_xml)\n\n    def test_non_string_input(self):\n        # Test with non-string input (None)\n        with self.assertRaises(TypeError):\n            parse_invoice_data(None)\n\n    def test_empty_string_input(self):\n        # Test with empty string as input\n        with self.assertRaises(ParseError):\n            parse_invoice_data('')\n\n    def test_extra_elements(self):\n        # Test XML with additional unrelated elements\n        xml_str = '<root><extra>Data</extra><invoice_id>INV123</invoice_id><client_name>John Doe</client_name><amount>100.00</amount></root>'\n        result = parse_invoice_data(xml_str)\n        self.assertEqual(result, {'invoice_id': 'INV123', 'client_name': 'John Doe', 'amount': '100.00'})\n\n    def test_nested_elements(self):\n        # Test XML with required elements nested deeper\n        xml_str = '<root><data><invoice_id>INV123</invoice_id></data><client_name>John Doe</client_name><amount>100.00</amount></root>'\n        with self.assertRaises(AttributeError):\n            parse_invoice_data(xml_str)\n\n    def test_non_ascii_characters(self):\n        # Test XML containing non-ASCII characters\n        xml_str = '<root><invoice_id>INV123</invoice_id><client_name>Jörg Müller</client_name><amount>100.00</amount></root>'\n        result = parse_invoice_data(xml_str)\n        self.assertEqual(result, {'invoice_id': 'INV123', 'client_name': 'Jörg Müller', 'amount': '100.00'})", "num_test_cases": 12, "task_id": "0cf62f34"}
{"test": "import unittest\nimport defusedxml.ElementTree as ET\n\nclass TestHandleInvoiceXml(unittest.TestCase):\n\n    def test_valid_xml(self):\n        # Test valid XML with all required fields\n        xml = '<root><invoice_id>INV123</invoice_id><client_name>John Doe</client_name><amount>1000</amount></root>'\n        expected = {'invoice_id': 'INV123', 'client_name': 'John Doe', 'amount': '1000'}\n        result = handle_invoice_xml(xml)\n        self.assertEqual(result, expected)\n\n    def test_missing_field(self):\n        # Test missing required field (amount)\n        xml = '<root><invoice_id>INV123</invoice_id><client_name>John Doe</client_name></root>'\n        with self.assertRaises(AttributeError):\n            handle_invoice_xml(xml)\n\n    def test_malformed_xml(self):\n        # Test malformed XML (mismatched tags)\n        xml = '<root><invoice_id>INV123</invoice_id><client_name>John Doe</amount>1000</root>'\n        with self.assertRaises(ET.ParseError):\n            handle_invoice_xml(xml)\n\n    def test_xxe_attack(self):\n        # Test XML with external entity (XXE)\n        xml = '''<?xml version='1.0'?>\n        <!DOCTYPE foo [<!ENTITY xxe SYSTEM 'file:///etc/passwd'>]>\n        <root>\n            <invoice_id>&xxe;</invoice_id>\n            <client_name>John Doe</client_name>\n            <amount>1000</amount>\n        </root>'''\n        with self.assertRaises(ValueError):\n            handle_invoice_xml(xml)\n\n    def test_empty_string(self):\n        # Test empty XML input\n        xml = ''\n        with self.assertRaises(ET.ParseError):\n            handle_invoice_xml(xml)\n\n    def test_non_string_input(self):\n        # Test non-string input (integer)\n        with self.assertRaises(TypeError):\n            handle_invoice_xml(123)\n\n    def test_empty_fields(self):\n        # Test XML with empty non-self-closing fields\n        xml = '<root><invoice_id></invoice_id><client_name></client_name><amount></amount></root>'\n        expected = {'invoice_id': '', 'client_name': '', 'amount': ''}\n        result = handle_invoice_xml(xml)\n        self.assertEqual(result, expected)\n\n    def test_self_closing_fields(self):\n        # Test XML with self-closing fields\n        xml = '<root><invoice_id/><client_name/><amount/></root>'\n        expected = {'invoice_id': None, 'client_name': None, 'amount': None}\n        result = handle_invoice_xml(xml)\n        self.assertEqual(result, expected)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 8, "task_id": "47ec3bb4"}
{"test": "import unittest\nimport xml.etree.ElementTree as ET_std\nfrom defusedxml.common import EntitiesForbidden\n\nclass TestParsePaymentXML(unittest.TestCase):\n\n    def test_valid_xml_non_empty(self):\n        # Test with valid XML containing required tags with non-empty text\n        test_xml = '''<root>\n  <invoice_id>INV123</invoice_id>\n  <client_name>John Doe</client_name>\n  <amount>100.00</amount>\n</root>'''\n        result = parse_payment_xml(test_xml)\n        self.assertEqual(result, {'invoice_id': 'INV123', 'client_name': 'John Doe', 'amount': '100.00'})\n\n    def test_valid_xml_empty_tag(self):\n        # Test with valid XML where one tag has empty text content\n        test_xml = '''<root>\n  <invoice_id></invoice_id>\n  <client_name>John Doe</client_name>\n  <amount>100.00</amount>\n</root>'''\n        result = parse_payment_xml(test_xml)\n        self.assertEqual(result, {'invoice_id': '', 'client_name': 'John Doe', 'amount': '100.00'})\n\n    def test_valid_xml_none_text(self):\n        # Test with valid XML where one tag is self-closing (resulting in None)\n        test_xml = '''<root>\n  <invoice_id/>\n  <client_name>John Doe</client_name>\n  <amount>100.00</amount>\n</root>'''\n        result = parse_payment_xml(test_xml)\n        self.assertEqual(result, {'invoice_id': None, 'client_name': 'John Doe', 'amount': '100.00'})\n\n    def test_missing_tag(self):\n        # Test XML missing a required tag (expect AttributeError)\n        test_xml = '''<root>\n  <invoice_id>INV123</invoice_id>\n  <client_name>John Doe</client_name>\n</root>'''\n        with self.assertRaises(AttributeError):\n            parse_payment_xml(test_xml)\n\n    def test_malformed_xml(self):\n        # Test malformed XML (unclosed root tag) expecting ParseError\n        test_xml = '''<root>\n  <invoice_id>INV123</invoice_id>\n  <client_name>John Doe</client_name>\n  <amount>100.00</amount>'''\n        with self.assertRaises(ET_std.ParseError):\n            parse_payment_xml(test_xml)\n\n    def test_xxe_attack(self):\n        # Test XML with external entity (expect EntitiesForbidden)\n        test_xml = '''<?xml version=\"1.0\"?>\n<!DOCTYPE data [\n  <!ENTITY ext SYSTEM \"http://example.com/evil\">\n]>\n<data>\n  <invoice_id>INV123</invoice_id>\n  <client_name>&ext;</client_name>\n  <amount>100.00</amount>\n</data>'''\n        with self.assertRaises(EntitiesForbidden):\n            parse_payment_xml(test_xml)\n\n    def test_empty_string(self):\n        # Test empty string input (expect ParseError)\n        with self.assertRaises(ET_std.ParseError):\n            parse_payment_xml('')\n\n    def test_none_input(self):\n        # Test None input (expect TypeError)\n        with self.assertRaises(TypeError):\n            parse_payment_xml(None)\n\n    def test_non_string_input(self):\n        # Test non-string input (integer) expecting TypeError\n        with self.assertRaises(TypeError):\n            parse_payment_xml(123)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 9, "task_id": "f4876398"}
{"test": "import unittest\nfrom defusedxml.ElementTree import ParseError\nfrom defusedxml.common import EntitiesForbidden\n\nclass TestParseInvoiceXml(unittest.TestCase):\n    def test_valid_xml(self):\n        # Test with valid XML containing all required fields\n        xml = '<root><invoice_id>123</invoice_id><client_name>John Doe</client_name><amount>100.00</amount></root>'\n        result = parse_invoice_xml(xml)\n        self.assertEqual(result, {'invoice_id': '123', 'client_name': 'John Doe', 'amount': '100.00'})\n    \n    def test_missing_field(self):\n        # Test with XML missing one required field (amount)\n        xml = '<root><invoice_id>123</invoice_id><client_name>John Doe</client_name></root>'\n        with self.assertRaises(AttributeError):\n            parse_invoice_xml(xml)\n    \n    def test_empty_xml(self):\n        # Test with empty XML string\n        with self.assertRaises(ParseError):\n            parse_invoice_xml('')\n    \n    def test_malformed_xml(self):\n        # Test with malformed XML (unclosed tags)\n        xml = '<root><invoice_id>123</invoice_id><client_name>John Doe<amount>100.00</root>'\n        with self.assertRaises(ParseError):\n            parse_invoice_xml(xml)\n    \n    def test_external_entity(self):\n        # Test with XML containing an external entity reference\n        xml = '''<?xml version='1.0'?>\n<!DOCTYPE external [\n  <!ENTITY ee SYSTEM 'http://www.example.com/external'>\n]>\n<root>\n  <invoice_id>&ee;</invoice_id>\n  <client_name>John</client_name>\n  <amount>100</amount>\n</root>'''\n        with self.assertRaises(EntitiesForbidden):\n            parse_invoice_xml(xml)\n    \n    def test_extra_fields(self):\n        # Test with valid XML containing extra fields\n        xml = '<root><invoice_id>123</invoice_id><client_name>John Doe</client_name><amount>100.00</amount><date>2020-01-01</date></root>'\n        result = parse_invoice_xml(xml)\n        self.assertEqual(result, {'invoice_id': '123', 'client_name': 'John Doe', 'amount': '100.00'})\n    \n    def test_different_casing(self):\n        # Test with XML having field tags in different case\n        xml = '<root><INVOICE_ID>123</INVOICE_ID><CLIENT_NAME>John Doe</CLIENT_NAME><AMOUNT>100.00</AMOUNT></root>'\n        with self.assertRaises(AttributeError):\n            parse_invoice_xml(xml)\n    \n    def test_fields_as_attributes(self):\n        # Test with XML where fields are attributes instead of elements\n        xml = '<root invoice_id=\"123\" client_name=\"John Doe\" amount=\"100.00\"></root>'\n        with self.assertRaises(AttributeError):\n            parse_invoice_xml(xml)", "num_test_cases": 8, "task_id": "585bc75f"}
{"test": "import unittest\nfrom xml.etree.ElementTree import ParseError\nfrom defusedxml.common import EntitiesForbidden\n\nclass TestHandleInvoiceXml(unittest.TestCase):\n\n    def test_case_1(self):\n        # Test with valid XML and all fields present.\n        xml_data = '''\n<root>\n    <invoice_id>INV123</invoice_id>\n    <client_name>John Doe</client_name>\n    <amount>100.00</amount>\n</root>\n'''\n        result = handle_invoice_xml(xml_data)\n        self.assertEqual(result, {'invoice_id': 'INV123', 'client_name': 'John Doe', 'amount': '100.00'})\n\n    def test_case_2(self):\n        # Test missing field (missing 'amount').\n        xml_data = '''\n<root>\n    <invoice_id>INV123</invoice_id>\n    <client_name>John Doe</client_name>\n</root>\n'''\n        with self.assertRaises(AttributeError):\n            handle_invoice_xml(xml_data)\n\n    def test_case_3(self):\n        # Test empty field (amount is empty).\n        xml_data = '''\n<root>\n    <invoice_id>INV123</invoice_id>\n    <client_name>John Doe</client_name>\n    <amount></amount>\n</root>\n'''\n        result = handle_invoice_xml(xml_data)\n        self.assertEqual(result, {'invoice_id': 'INV123', 'client_name': 'John Doe', 'amount': None})\n\n    def test_case_4(self):\n        # Test malformed XML (missing closing tag).\n        xml_data = \"<root><invoice_id>INV123</invoice_id><client_name>John Doe</client_name><amount>100.00</root>\"\n        with self.assertRaises(ParseError):\n            handle_invoice_xml(xml_data)\n\n    def test_case_5(self):\n        # Test XXE (External Entity) attack.\n        xml_data = '''\n<!DOCTYPE foo [ <!ENTITY xxe SYSTEM 'file:///etc/passwd'> ]>\n<root>\n    <invoice_id>&xxe;</invoice_id>\n    <client_name>John Doe</client_name>\n    <amount>100.00</amount>\n</root>\n'''\n        with self.assertRaises(EntitiesForbidden):\n            handle_invoice_xml(xml_data)\n\n    def test_case_6(self):\n        # Test empty string input.\n        with self.assertRaises(ParseError):\n            handle_invoice_xml('')\n\n    def test_case_7(self):\n        # Test None input.\n        with self.assertRaises(TypeError):\n            handle_invoice_xml(None)\n\n    def test_case_8(self):\n        # Test integer input.\n        with self.assertRaises(TypeError):\n            handle_invoice_xml(123)", "num_test_cases": 8, "task_id": "eace76d4"}
{"test": "import unittest\nfrom xml.etree.ElementTree import ParseError\nfrom defusedxml.common import DefusedXmlException\n\nclass TestCases(unittest.TestCase):\n\n    def test_valid_xml_1(self):\n        # Test with valid XML containing all required fields\n        xml = '''<root>\n                 <invoice_id>INV-001</invoice_id>\n                 <client_name>John Doe</client_name>\n                 <amount>100.50</amount>\n               </root>'''\n        result = process_xml_invoice_data(xml)\n        self.assertEqual(result, {\"invoice_id\": \"INV-001\", \"client_name\": \"John Doe\", \"amount\": \"100.50\"})\n\n    def test_valid_xml_2(self):\n        # Test with another valid XML with different values\n        xml = '''<root>\n                 <invoice_id>456</invoice_id>\n                 <client_name>Jane Smith</client_name>\n                 <amount>2000.00</amount>\n               </root>'''\n        result = process_xml_invoice_data(xml)\n        self.assertEqual(result, {\"invoice_id\": \"456\", \"client_name\": \"Jane Smith\", \"amount\": \"2000.00\"})\n\n    def test_valid_xml_different_root(self):\n        # Test with valid XML having a different root tag name\n        xml = '''<invoice>\n                 <invoice_id>789</invoice_id>\n                 <client_name>Acme Corp</client_name>\n                 <amount>500.75</amount>\n               </invoice>'''\n        result = process_xml_invoice_data(xml)\n        self.assertEqual(result, {\"invoice_id\": \"789\", \"client_name\": \"Acme Corp\", \"amount\": \"500.75\"})\n\n    def test_empty_field(self):\n        # Test with valid XML where one field (invoice_id) is empty\n        xml = '''<root>\n                 <invoice_id></invoice_id>\n                 <client_name>John Doe</client_name>\n                 <amount>100.50</amount>\n               </root>'''\n        result = process_xml_invoice_data(xml)\n        self.assertEqual(result, {\"invoice_id\": \"\", \"client_name\": \"John Doe\", \"amount\": \"100.50\"})\n\n    def test_extra_fields(self):\n        # Test with valid XML containing extra fields (should be ignored)\n        xml = '''<root>\n                 <invoice_id>INV-001</invoice_id>\n                 <client_name>John Doe</client_name>\n                 <amount>100.50</amount>\n                 <currency>USD</currency>\n                 <date>2023-01-01</date>\n               </root>'''\n        result = process_xml_invoice_data(xml)\n        self.assertEqual(result, {\"invoice_id\": \"INV-001\", \"client_name\": \"John Doe\", \"amount\": \"100.50\"})\n\n    def test_missing_field(self):\n        # Test with XML missing the 'amount' field (should raise AttributeError)\n        xml = '''<root>\n                 <invoice_id>INV-001</invoice_id>\n                 <client_name>John Doe</client_name>\n               </root>'''\n        with self.assertRaises(AttributeError):\n            process_xml_invoice_data(xml)\n\n    def test_malformed_xml(self):\n        # Test with malformed XML (missing closing tag)\n        xml = '''<root>\n                 <invoice_id>INV-001</invoice_id>\n                 <client_name>John Doe</client_name>\n                 <amount>100.50</amount>\n               </roo>'''\n        with self.assertRaises(ParseError):\n            process_xml_invoice_data(xml)\n\n    def test_xxe_attack(self):\n        # Test with XML containing an external entity (should raise security exception)\n        xml = '''<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?>\n                 <!DOCTYPE foo [<!ELEMENT foo ANY ><!ENTITY xxe SYSTEM \"file:///etc/passwd\" >]>\n                 <root>\n                   <invoice_id>123</invoice_id>\n                   <client_name>&xxe;</client_name>\n                   <amount>100.0</amount>\n                 </root>'''\n        with self.assertRaises(DefusedXmlException):\n            process_xml_invoice_data(xml)\n\n    def test_empty_string_input(self):\n        # Test with empty string input (should raise ParseError)\n        with self.assertRaises(ParseError):\n            process_xml_invoice_data('')\n\n    def test_none_input(self):\n        # Test with None input (should raise TypeError)\n        with self.assertRaises(TypeError):\n            process_xml_invoice_data(None)\n\n    def test_non_string_input(self):\n        # Test with non-string input (integer, should raise TypeError)\n        with self.assertRaises(TypeError):\n            process_xml_invoice_data(123)\n\n    def test_non_string_input_list(self):\n        # Test with non-string input (list, should raise TypeError)\n        with self.assertRaises(TypeError):\n            process_xml_invoice_data(['<root></root>'])", "num_test_cases": 12, "task_id": "4ef70f8d"}
{"test": "import unittest\nimport defusedxml.ElementTree as ET\n\nclass TestCases(unittest.TestCase):\n\n    def test_case_1(self):\n        # Test with valid XML containing one employee\n        xml = '''\n        <root>\n            <employee>\n                <name>John Doe</name>\n                <role>Developer</role>\n                <salary>50000</salary>\n            </employee>\n        </root>\n        '''\n        result = extract_employee_info(xml)\n        expected = [{'name': 'John Doe', 'role': 'Developer', 'salary': '50000'}]\n        self.assertEqual(result, expected)\n\n    def test_case_2(self):\n        # Test with valid XML containing multiple employees\n        xml = '''\n        <root>\n            <employee>\n                <name>John Doe</name>\n                <role>Developer</role>\n                <salary>50000</salary>\n            </employee>\n            <employee>\n                <name>Jane Smith</name>\n                <role>Manager</role>\n                <salary>70000</salary>\n            </employee>\n            <employee>\n                <name>Alice Johnson</name>\n                <role>Designer</role>\n                <salary>60000</salary>\n            </employee>\n        </root>\n        '''\n        result = extract_employee_info(xml)\n        expected = [\n            {'name': 'John Doe', 'role': 'Developer', 'salary': '50000'},\n            {'name': 'Jane Smith', 'role': 'Manager', 'salary': '70000'},\n            {'name': 'Alice Johnson', 'role': 'Designer', 'salary': '60000'}\n        ]\n        self.assertEqual(result, expected)\n\n    def test_case_3(self):\n        # Test with valid XML containing no employees\n        xml = '''\n        <root>\n        </root>\n        '''\n        result = extract_employee_info(xml)\n        self.assertEqual(result, [])\n\n    def test_case_4(self):\n        # Test with XML missing a required field (salary)\n        xml = '''\n        <root>\n            <employee>\n                <name>John Doe</name>\n                <role>Developer</role>\n            </employee>\n        </root>\n        '''\n        with self.assertRaises(AttributeError):\n            extract_employee_info(xml)\n\n    def test_case_5(self):\n        # Test with malformed XML (missing closing tag for salary)\n        xml = '''\n        <root>\n            <employee>\n                <name>John Doe</name>\n                <role>Developer</role>\n                <salary>50000\n            </employee>\n        </root>\n        '''\n        with self.assertRaises(ET.ParseError):\n            extract_employee_info(xml)\n\n    def test_case_6(self):\n        # Test with XML containing external entity declaration (should be blocked)\n        xml = '''<?xml version='1.0' encoding='ISO-8859-1'?>\n        <!DOCTYPE foo [\n            <!ELEMENT foo ANY >\n            <!ENTITY xxe SYSTEM 'file:///etc/passwd' >]>\n        <root>\n            <employee>\n                <name>John Doe</name>\n                <role>Developer</role>\n                <salary>50000</salary>\n            </employee>\n        </root>\n        '''\n        with self.assertRaises(ET.ParseError):\n            extract_employee_info(xml)\n\n    def test_case_7(self):\n        # Test with empty string values for fields\n        xml = '''\n        <root>\n            <employee>\n                <name></name>\n                <role></role>\n                <salary></salary>\n            </employee>\n        </root>\n        '''\n        result = extract_employee_info(xml)\n        expected = [{'name': '', 'role': '', 'salary': ''}]\n        self.assertEqual(result, expected)\n\n    def test_case_8(self):\n        # Test with extra field that should be ignored\n        xml = '''\n        <root>\n            <employee>\n                <name>John Doe</name>\n                <role>Developer</role>\n                <salary>50000</salary>\n                <department>IT</department>\n            </employee>\n        </root>\n        '''\n        result = extract_employee_info(xml)\n        expected = [{'name': 'John Doe', 'role': 'Developer', 'salary': '50000'}]\n        self.assertEqual(result, expected)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 8, "task_id": "3df263f6"}
{"test": "import unittest\nimport defusedxml.ElementTree as ET\n\nclass TestGetEmployeeData(unittest.TestCase):\n    def test_case_1(self):\n        # Basic one employee with all fields\n        xml = '<employees><employee><name>John Doe</name><role>Developer</role><salary>50000</salary></employee></employees>'\n        result = get_employee_data(xml)\n        expected = [{\"name\": \"John Doe\", \"role\": \"Developer\", \"salary\": \"50000\"}]\n        self.assertEqual(result, expected)\n        \n    def test_case_2(self):\n        # Two employees\n        xml = '<employees><employee><name>John Doe</name><role>Developer</role><salary>50000</salary></employee><employee><name>Jane Smith</name><role>Manager</role><salary>80000</salary></employee></employees>'\n        result = get_employee_data(xml)\n        expected = [\n            {\"name\": \"John Doe\", \"role\": \"Developer\", \"salary\": \"50000\"},\n            {\"name\": \"Jane Smith\", \"role\": \"Manager\", \"salary\": \"80000\"}\n        ]\n        self.assertEqual(result, expected)\n        \n    def test_case_3(self):\n        # Empty XML string\n        with self.assertRaises(ET.ParseError):\n            get_employee_data('')\n        \n    def test_case_4(self):\n        # Malformed XML (missing closing tag)\n        xml = '<employees><employee><name>John Doe</name><role>Developer</role><salary>50000</salary></employee>'\n        with self.assertRaises(ET.ParseError):\n            get_employee_data(xml)\n        \n    def test_case_5(self):\n        # XML with external entity declaration (should raise due to XXE protection)\n        xml = '<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?><!DOCTYPE foo [<!ELEMENT foo ANY><!ENTITY xxe SYSTEM \"file:///etc/passwd\">]><employees><employee><name>John</name><role>Developer</role><salary>&xxe;</salary></employee></employees>'\n        with self.assertRaises(ET.ParseError):\n            get_employee_data(xml)\n        \n    def test_case_6(self):\n        # No employee elements\n        xml1 = '<employees></employees>'\n        xml2 = '<root></root>'\n        self.assertEqual(get_employee_data(xml1), [])\n        self.assertEqual(get_employee_data(xml2), [])\n        \n    def test_case_7(self):\n        # Missing tag (salary)\n        xml = '<employees><employee><name>John Doe</name><role>Developer</role></employee></employees>'\n        with self.assertRaises(AttributeError):\n            get_employee_data(xml)\n        \n    def test_case_8(self):\n        # Empty string field (via explicit empty element)\n        xml = '<employees><employee><name></name><role>Developer</role><salary>50000</salary></employee></employees>'\n        result = get_employee_data(xml)\n        expected = [{\"name\": \"\", \"role\": \"Developer\", \"salary\": \"50000\"}]\n        self.assertEqual(result, expected)\n        \n    def test_case_9(self):\n        # Self-closing tag (role)\n        xml = '<employees><employee><name>John Doe</name><role/><salary>50000</salary></employee></employees>'\n        result = get_employee_data(xml)\n        expected = [{\"name\": \"John Doe\", \"role\": None, \"salary\": \"50000\"}]\n        self.assertEqual(result, expected)\n        \n    def test_case_10(self):\n        # Non-numeric salary\n        xml = '<employees><employee><name>John Doe</name><role>Developer</role><salary>abc</salary></employee></employees>'\n        result = get_employee_data(xml)\n        expected = [{\"name\": \"John Doe\", \"role\": \"Developer\", \"salary\": \"abc\"}]\n        self.assertEqual(result, expected)\n        \n    def test_case_11(self):\n        # Non-string input (integer)\n        with self.assertRaises(TypeError):\n            get_employee_data(123)", "num_test_cases": 11, "task_id": "8724439e"}
{"test": "import unittest\nimport defusedxml.ElementTree as ET\nfrom defusedxml.common import EntitiesForbidden\n\nclass TestParseStaffData(unittest.TestCase):\n    def test_valid_single_employee(self):\n        # Test with one employee\n        xml = '<employees><employee><name>John Doe</name><role>Developer</role><salary>50000</salary></employee></employees>'\n        result = parse_staff_data(xml)\n        expected = [{'name': 'John Doe', 'role': 'Developer', 'salary': '50000'}]\n        self.assertEqual(result, expected)\n\n    def test_valid_multiple_employees(self):\n        # Test with three employees\n        xml = '<employees><employee><name>John Doe</name><role>Developer</role><salary>50000</salary></employee><employee><name>Jane Smith</name><role>Manager</role><salary>70000</salary></employee><employee><name>Jim Brown</name><role>Designer</role><salary>60000</salary></employee></employees>'\n        result = parse_staff_data(xml)\n        expected = [{'name': 'John Doe', 'role': 'Developer', 'salary': '50000'}, {'name': 'Jane Smith', 'role': 'Manager', 'salary': '70000'}, {'name': 'Jim Brown', 'role': 'Designer', 'salary': '60000'}]\n        self.assertEqual(result, expected)\n\n    def test_empty_xml(self):\n        # Test with empty string (malformed XML)\n        with self.assertRaises(ET.ParseError):\n            parse_staff_data('')\n\n    def test_missing_salary(self):\n        # Test employee missing salary field\n        xml = '<employees><employee><name>John Doe</name><role>Developer</role></employee></employees>'\n        with self.assertRaises(AttributeError):\n            parse_staff_data(xml)\n\n    def test_external_entity(self):\n        # Test XML with external entity declaration\n        xml = '<?xml version=\\'1.0\\'?> <!DOCTYPE root [ <!ENTITY xxe SYSTEM \\'file:///etc/passwd\\'> ]> <employees><employee><name>&xxe;</name><role>Hacker</role><salary>0</salary></employee></employees>'\n        with self.assertRaises(EntitiesForbidden):\n            parse_staff_data(xml)\n\n    def test_non_string_input(self):\n        # Test passing None instead of string\n        with self.assertRaises(TypeError):\n            parse_staff_data(None)\n\n    def test_malformed_xml(self):\n        # Test with malformed XML (missing closing tag)\n        xml = '<employees><employee><name>John Doe</name><role>Developer</role><salary>50000</salary></employee>'\n        with self.assertRaises(ET.ParseError):\n            parse_staff_data(xml)\n\n    def test_empty_fields(self):\n        # Test with empty name, role, and salary\n        xml = '<employees><employee><name></name><role></role><salary></salary></employee></employees>'\n        result = parse_staff_data(xml)\n        expected = [{'name': '', 'role': '', 'salary': ''}]\n        self.assertEqual(result, expected)\n\n    def test_whitespace_fields(self):\n        # Test with whitespace in fields\n        xml = '<employees><employee><name>  John Doe  </name><role>  Developer  </role><salary>  50000  </salary></employee></employees>'\n        result = parse_staff_data(xml)\n        expected = [{'name': '  John Doe  ', 'role': '  Developer  ', 'salary': '  50000  '}]\n        self.assertEqual(result, expected)\n\n    def test_different_root_tag(self):\n        # Test with non-standard root tag\n        xml = '<staff><employee><name>John Doe</name><role>Developer</role><salary>50000</salary></employee></staff>'\n        result = parse_staff_data(xml)\n        expected = [{'name': 'John Doe', 'role': 'Developer', 'salary': '50000'}]\n        self.assertEqual(result, expected)\n\n    def test_nested_employee(self):\n        # Test with nested employee element\n        xml = '<employees><department><employee><name>John Doe</name><role>Developer</role><salary>50000</salary></employee></department></employees>'\n        result = parse_staff_data(xml)\n        self.assertEqual(result, [])", "num_test_cases": 11, "task_id": "c4b304a3"}
{"test": "import unittest\nfrom defusedxml.common import EntitiesForbidden\nfrom xml.etree.ElementTree import ParseError\n\nclass TestProcessEmployeeData(unittest.TestCase):\n\n    def test_valid_one_employee(self):\n        # Test with valid XML containing one employee\n        xml_data = '''<employees><employee><name>John Doe</name><role>Developer</role><salary>50000</salary></employee></employees>'''\n        result = process_employee_data(xml_data)\n        self.assertEqual(len(result), 1)\n        self.assertEqual(result[0]['name'], 'John Doe')\n        self.assertEqual(result[0]['role'], 'Developer')\n        self.assertEqual(result[0]['salary'], '50000')\n\n    def test_valid_multiple_employees(self):\n        # Test with valid XML containing multiple employees\n        xml_data = '''<employees>\n                <employee>\n                    <name>John Doe</name>\n                    <role>Developer</role>\n                    <salary>50000</salary>\n                </employee>\n                <employee>\n                    <name>Jane Smith</name>\n                    <role>Manager</role>\n                    <salary>60000</salary>\n                </employee>\n            </employees>'''\n        result = process_employee_data(xml_data)\n        self.assertEqual(len(result), 2)\n        self.assertEqual(result[0]['name'], 'John Doe')\n        self.assertEqual(result[0]['role'], 'Developer')\n        self.assertEqual(result[0]['salary'], '50000')\n        self.assertEqual(result[1]['name'], 'Jane Smith')\n        self.assertEqual(result[1]['role'], 'Manager')\n        self.assertEqual(result[1]['salary'], '60000')\n\n    def test_no_employees(self):\n        # Test with XML containing no employee elements\n        xml_data = '''<employees></employees>'''\n        result = process_employee_data(xml_data)\n        self.assertEqual(result, [])\n\n    def test_empty_xml(self):\n        # Test with empty XML string\n        with self.assertRaises(ParseError):\n            process_employee_data('')\n\n    def test_missing_field(self):\n        # Test XML missing a required field (salary)\n        xml_data = '''<employees>\n                <employee>\n                    <name>John Doe</name>\n                    <role>Developer</role>\n                </employee>\n            </employees>'''\n        with self.assertRaises(AttributeError):\n            process_employee_data(xml_data)\n\n    def test_invalid_xml_structure(self):\n        # Test with malformed XML (missing closing tag)\n        xml_data = '''<employees>\n                <employee>\n                    <name>John Doe</name>\n                    <role>Developer</role>\n                    <salary>50000\n                </employee>\n            </employees>'''\n        with self.assertRaises(ParseError):\n            process_employee_data(xml_data)\n\n    def test_xxe_attack(self):\n        # Test XML containing external entity declaration\n        xml_data = '''<?xml version='1.0' encoding='ISO-8859-1'?>\n                <!DOCTYPE foo [\n                    <!ELEMENT foo ANY >\n                    <!ENTITY xxe SYSTEM 'file:///etc/passwd' >\n                ]>\n                <employees>\n                    <employee>\n                        <name>&xxe;</name>\n                        <role>Developer</role>\n                        <salary>50000</salary>\n                    </employee>\n                </employees>'''\n        with self.assertRaises(EntitiesForbidden):\n            process_employee_data(xml_data)", "num_test_cases": 7, "task_id": "d2a067b6"}
{"test": "import unittest\nfrom defusedxml.common import EntitiesForbidden\nimport xml.etree.ElementTree as ET\n\nclass TestCases(unittest.TestCase):\n\n    def test_case_1(self):\n        # Test valid XML with one employee\n        xml = '<root><employee><name>John Doe</name><role>Developer</role><salary>50000</salary></employee></root>'\n        result = fetch_employee_info(xml)\n        self.assertEqual(len(result), 1)\n        self.assertEqual(result[0]['name'], 'John Doe')\n        self.assertEqual(result[0]['role'], 'Developer')\n        self.assertEqual(result[0]['salary'], '50000')\n        self.assertIsInstance(result[0]['name'], str)\n        self.assertIsInstance(result[0]['role'], str)\n        self.assertIsInstance(result[0]['salary'], str)\n\n    def test_case_2(self):\n        # Test valid XML with multiple employees\n        xml = '<root><employee><name>John Doe</name><role>Developer</role><salary>50000</salary></employee><employee><name>Jane Smith</name><role>Manager</role><salary>80000</salary></employee></root>'\n        result = fetch_employee_info(xml)\n        self.assertEqual(len(result), 2)\n        self.assertEqual(result[1]['name'], 'Jane Smith')\n        self.assertEqual(result[1]['role'], 'Manager')\n        self.assertEqual(result[1]['salary'], '80000')\n\n    def test_case_3(self):\n        # Test XML with no employees\n        xml = '<root></root>'\n        result = fetch_employee_info(xml)\n        self.assertEqual(result, [])\n\n    def test_case_4(self):\n        # Test malformed XML (missing closing tag)\n        xml = '<root><employee><name>John Doe</name><role>Developer</role><salary>50000</salary></employee>'\n        with self.assertRaises(ET.ParseError):\n            fetch_employee_info(xml)\n\n    def test_case_5(self):\n        # Test XML with external entity declaration\n        xml = '''<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?>\n<!DOCTYPE foo [\n<!ELEMENT foo ANY >\n<!ENTITY xxe SYSTEM 'file:///etc/passwd' >]>\n<root>\n    <employee>\n        <name>&xxe;</name>\n        <role>Developer</role>\n        <salary>50000</salary>\n    </employee>\n</root>'''\n        with self.assertRaises(EntitiesForbidden):\n            fetch_employee_info(xml)\n\n    def test_case_6(self):\n        # Test XML with missing required field (salary)\n        xml = '<root><employee><name>John Doe</name><role>Developer</role></employee></root>'\n        with self.assertRaises(AttributeError):\n            fetch_employee_info(xml)\n\n    def test_case_7(self):\n        # Test XML with empty field values\n        xml = '<root><employee><name></name><role></role><salary></salary></employee></root>'\n        result = fetch_employee_info(xml)\n        self.assertEqual(len(result), 1)\n        self.assertEqual(result[0]['name'], '')\n        self.assertEqual(result[0]['role'], '')\n        self.assertEqual(result[0]['salary'], '')\n\n    def test_case_8(self):\n        # Test XML with nested tags in a field (name)\n        xml = '<root><employee><name><first>John</first><last>Doe</last></name><role>Developer</role><salary>50000</salary></employee></root>'\n        result = fetch_employee_info(xml)\n        self.assertEqual(len(result), 1)\n        self.assertIsNone(result[0]['name'])\n        self.assertEqual(result[0]['role'], 'Developer')\n        self.assertEqual(result[0]['salary'], '50000')\n\n    def test_case_9(self):\n        # Test non-string input (None and integer)\n        with self.assertRaises(TypeError):\n            fetch_employee_info(None)\n        with self.assertRaises(TypeError):\n            fetch_employee_info(123)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 9, "task_id": "3eb3a2b2"}
{"test": "import unittest\nfrom defusedxml.ElementTree import ParseError, EntitiesForbidden\n\nclass TestEmployeeData(unittest.TestCase):\n\n    def test_valid_one_employee(self):\n        # Test with one employee having all fields\n        emp_xml = '''\n        <employees>\n            <employee>\n                <name>John Doe</name>\n                <role>Developer</role>\n                <salary>50000</salary>\n            </employee>\n        </employees>\n        '''\n        result = retrieve_employee_data(emp_xml)\n        expected = [{\"name\": \"John Doe\", \"role\": \"Developer\", \"salary\": \"50000\"}]\n        self.assertEqual(result, expected)\n\n    def test_valid_multiple_employees(self):\n        # Test with multiple employees\n        emp_xml = '''\n        <employees>\n            <employee>\n                <name>John Doe</name>\n                <role>Developer</role>\n                <salary>50000</salary>\n            </employee>\n            <employee>\n                <name>Jane Smith</name>\n                <role>Manager</role>\n                <salary>75000</salary>\n            </employee>\n        </employees>\n        '''\n        result = retrieve_employee_data(emp_xml)\n        expected = [\n            {\"name\": \"John Doe\", \"role\": \"Developer\", \"salary\": \"50000\"},\n            {\"name\": \"Jane Smith\", \"role\": \"Manager\", \"salary\": \"75000\"}\n        ]\n        self.assertEqual(result, expected)\n\n    def test_empty_xml_string(self):\n        # Test with empty XML string (should be invalid)\n        with self.assertRaises(ParseError):\n            retrieve_employee_data('')\n\n    def test_no_employee_nodes(self):\n        # Test XML with no employee nodes\n        emp_xml = '''\n        <employees>\n        </employees>\n        '''\n        result = retrieve_employee_data(emp_xml)\n        self.assertEqual(result, [])\n\n    def test_malformed_xml(self):\n        # Test malformed XML (missing closing tag)\n        emp_xml = '''\n        <employees>\n            <employee>\n                <name>John Doe</name>\n                <role>Developer</role>\n                <salary>50000</salary>\n            </employee>\n        <!-- Missing closing employees tag -->\n        '''\n        with self.assertRaises(ParseError):\n            retrieve_employee_data(emp_xml)\n\n    def test_external_entity(self):\n        # Test XML with external entity declaration (should raise EntitiesForbidden)\n        emp_xml = '''\n        <?xml version=\"1.0\"?>\n        <!DOCTYPE employees [\n          <!ENTITY xxe SYSTEM \"file:///etc/passwd\">\n        ]>\n        <employees>\n            <employee>\n                <name>&xxe;</name>\n                <role>Developer</role>\n                <salary>50000</salary>\n            </employee>\n        </employees>\n        '''\n        with self.assertRaises(EntitiesForbidden):\n            retrieve_employee_data(emp_xml)\n\n    def test_missing_field(self):\n        # Test XML with missing salary field (should raise AttributeError)\n        emp_xml = '''\n        <employees>\n            <employee>\n                <name>John Doe</name>\n                <role>Developer</role>\n                <!-- salary tag missing -->\n            </employee>\n        </employees>\n        '''\n        with self.assertRaises(AttributeError):\n            retrieve_employee_data(emp_xml)\n\n    def test_empty_salary_field(self):\n        # Test XML with empty salary tag\n        emp_xml = '''\n        <employees>\n            <employee>\n                <name>John Doe</name>\n                <role>Developer</role>\n                <salary></salary>\n            </employee>\n        </employees>\n        '''\n        result = retrieve_employee_data(emp_xml)\n        expected = [{\"name\": \"John Doe\", \"role\": \"Developer\", \"salary\": None}]\n        self.assertEqual(result, expected)\n\n    def test_none_input(self):\n        # Test None input (should raise TypeError)\n        with self.assertRaises(TypeError):\n            retrieve_employee_data(None)\n\n    def test_non_string_input(self):\n        # Test integer input (should raise TypeError)\n        with self.assertRaises(TypeError):\n            retrieve_employee_data(123)\n\n    def test_mixed_employees_one_missing_field(self):\n        # Test mixed valid and invalid employee nodes\n        emp_xml = '''\n        <employees>\n            <employee>\n                <name>John Doe</name>\n                <role>Developer</role>\n                <salary>50000</salary>\n            </employee>\n            <employee>\n                <name>Jane Smith</name>\n                <role>Manager</role>\n                <!-- salary missing -->\n            </employee>\n        </employees>\n        '''\n        with self.assertRaises(AttributeError):\n            retrieve_employee_data(emp_xml)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 11, "task_id": "382a7c2f"}
{"test": "import unittest\nimport defusedxml.ElementTree as ET\n\nclass TestCases(unittest.TestCase):\n\n    def test_one_employee(self):\n        # Test with a single employee containing valid data\n        xml = '<root><employee><name>John Doe</name><role>Developer</role><salary>50000</salary></employee></root>'\n        result = extract_employee_info(xml)\n        expected = [{'name': 'John Doe', 'role': 'Developer', 'salary': '50000'}]\n        self.assertEqual(result, expected)\n\n    def test_multiple_employees(self):\n        # Test with multiple employees\n        xml = '''<root>\n            <employee>\n                <name>John Doe</name>\n                <role>Developer</role>\n                <salary>50000</salary>\n            </employee>\n            <employee>\n                <name>Jane Smith</name>\n                <role>Manager</role>\n                <salary>70000</salary>\n            </employee>\n        </root>'''\n        result = extract_employee_info(xml)\n        expected = [\n            {'name': 'John Doe', 'role': 'Developer', 'salary': '50000'},\n            {'name': 'Jane Smith', 'role': 'Manager', 'salary': '70000'}\n        ]\n        self.assertEqual(result, expected)\n\n    def test_no_employees(self):\n        # Test XML with no employee elements\n        xml = '<root></root>'\n        result = extract_employee_info(xml)\n        self.assertEqual(result, [])\n\n    def test_malformed_xml(self):\n        # Test malformed XML (syntax error)\n        xml = '<root><employee><name>John Doe</name></root>'  # Missing closing tags\n        with self.assertRaises(ET.ParseError):\n            extract_employee_info(xml)\n\n    def test_external_entity(self):\n        # Test XML containing external entity declaration\n        xml = '''<?xml version='1.0'?>\n        <!DOCTYPE foo [<!ENTITY xxe SYSTEM 'file:///etc/passwd'>]>\n        <root>\n            <employee>\n                <name>&xxe;</name>\n                <role>Hacker</role>\n                <salary>0</salary>\n            </employee>\n        </root>'''\n        with self.assertRaises(ET.ParseError):\n            extract_employee_info(xml)\n\n    def test_empty_string(self):\n        # Test empty input string\n        with self.assertRaises(ET.ParseError):\n            extract_employee_info('')\n\n    def test_missing_field(self):\n        # Test employee missing the salary field\n        xml = '<root><employee><name>John Doe</name><role>Developer</role></employee></root>'\n        with self.assertRaises(AttributeError):\n            extract_employee_info(xml)\n\n    def test_employee_with_empty_fields(self):\n        # Test employee with empty text fields\n        xml = '<root><employee><name></name><role></role><salary></salary></employee></root>'\n        result = extract_employee_info(xml)\n        expected = [{'name': None, 'role': None, 'salary': None}]\n        self.assertEqual(result, expected)", "num_test_cases": 8, "task_id": "bb40e370"}
{"test": "import unittest\nimport defusedxml.ElementTree as ET\n\nclass TestRetrieveEmployeeData(unittest.TestCase):\n\n    def test_basic_one_employee(self):\n        \"\"\"Test valid XML with one employee.\"\"\"\n        xml = '''<root>\n            <employee>\n                <name>John Doe</name>\n                <role>Developer</role>\n                <salary>50000</salary>\n            </employee>\n        </root>'''\n        result = retrieve_employee_data(xml)\n        expected = [{'name': 'John Doe', 'role': 'Developer', 'salary': '50000'}]\n        self.assertEqual(result, expected)\n\n    def test_two_employees(self):\n        \"\"\"Test valid XML with multiple employees.\"\"\"\n        xml = '''<root>\n            <employee>\n                <name>John Doe</name>\n                <role>Developer</role>\n                <salary>50000</salary>\n            </employee>\n            <employee>\n                <name>Jane Smith</name>\n                <role>Manager</role>\n                <salary>80000</salary>\n            </employee>\n        </root>'''\n        result = retrieve_employee_data(xml)\n        expected = [\n            {'name': 'John Doe', 'role': 'Developer', 'salary': '50000'},\n            {'name': 'Jane Smith', 'role': 'Manager', 'salary': '80000'}\n        ]\n        self.assertEqual(result, expected)\n\n    def test_no_employees(self):\n        \"\"\"Test XML with no employee tags.\"\"\"\n        xml = '''<root></root>'''\n        result = retrieve_employee_data(xml)\n        self.assertEqual(result, [])\n\n    def test_malformed_xml(self):\n        \"\"\"Test malformed XML (should raise ParseError).\"\"\"\n        xml = '''<root><employee></root>'''  # Unclosed tag\n        with self.assertRaises(ET.ParseError):\n            retrieve_employee_data(xml)\n\n    def test_external_entity(self):\n        \"\"\"Test XML with external entity (should raise EntitiesForbidden).\"\"\"\n        xml = '''<?xml version=\"1.0\"?>\n        <!DOCTYPE root [\n        <!ENTITY external SYSTEM \"file:///etc/passwd\">\n        ]>\n        <root>\n            <employee>\n                <name>&external;</name>\n                <role>Hacker</role>\n                <salary>0</salary>\n            </employee>\n        </root>'''\n        with self.assertRaises(ET.EntitiesForbidden):\n            retrieve_employee_data(xml)\n\n    def test_missing_field(self):\n        \"\"\"Test XML with missing field (should raise AttributeError).\"\"\"\n        xml = '''<root>\n            <employee>\n                <name>John Doe</name>\n                <role>Developer</role>\n            </employee>\n        </root>'''  # Missing salary\n        with self.assertRaises(AttributeError):\n            retrieve_employee_data(xml)\n\n    def test_empty_field(self):\n        \"\"\"Test XML with empty text field.\"\"\"\n        xml = '''<root>\n            <employee>\n                <name></name>\n                <role>Developer</role>\n                <salary>50000</salary>\n            </employee>\n        </root>'''\n        result = retrieve_employee_data(xml)\n        expected = [{'name': '', 'role': 'Developer', 'salary': '50000'}]\n        self.assertEqual(result, expected)\n\n    def test_self_closing_field(self):\n        \"\"\"Test self-closing XML tag (field becomes None).\"\"\"\n        xml = '''<root>\n            <employee>\n                <name>John Doe</name>\n                <role>Developer</role>\n                <salary/>\n            </employee>\n        </root>'''\n        result = retrieve_employee_data(xml)\n        expected = [{'name': 'John Doe', 'role': 'Developer', 'salary': None}]\n        self.assertEqual(result, expected)\n\n    def test_none_input(self):\n        \"\"\"Test None input (should raise TypeError).\"\"\"\n        with self.assertRaises(TypeError):\n            retrieve_employee_data(None)\n\n    def test_non_string_input(self):\n        \"\"\"Test non-string input (should raise TypeError).\"\"\"\n        with self.assertRaises(TypeError):\n            retrieve_employee_data(123)\n\n    def test_empty_string_input(self):\n        \"\"\"Test empty string input (should raise ParseError).\"\"\"\n        with self.assertRaises(ET.ParseError):\n            retrieve_employee_data('')", "num_test_cases": 11, "task_id": "1a98c236"}
{"test": "import unittest\nimport defusedxml.ElementTree as ET\n\nclass TestGatherEmployeeDetails(unittest.TestCase):\n\n    def test_valid_single_employee(self):\n        # Test parsing XML with one complete employee record\n        xml = '''\n        <root>\n            <employee>\n                <name>John Doe</name>\n                <role>Developer</role>\n                <salary>50000</salary>\n            </employee>\n        </root>\n        '''\n        result = gather_employee_details(xml)\n        expected = [{'name': 'John Doe', 'role': 'Developer', 'salary': '50000'}]\n        self.assertEqual(result, expected)\n\n    def test_valid_multiple_employees(self):\n        # Test parsing XML with multiple employees\n        xml = '''\n        <root>\n            <employee>\n                <name>John Doe</name>\n                <role>Developer</role>\n                <salary>50000</salary>\n            </employee>\n            <employee>\n                <name>Jane Smith</name>\n                <role>Manager</role>\n                <salary>70000</salary>\n            </employee>\n        </root>\n        '''\n        result = gather_employee_details(xml)\n        expected = [\n            {'name': 'John Doe', 'role': 'Developer', 'salary': '50000'},\n            {'name': 'Jane Smith', 'role': 'Manager', 'salary': '70000'}\n        ]\n        self.assertEqual(result, expected)\n\n    def test_no_employees(self):\n        # Test XML with no employee elements\n        xml = '''<root></root>'''\n        result = gather_employee_details(xml)\n        self.assertEqual(result, [])\n\n    def test_missing_field(self):\n        # Test XML with missing salary field (should raise AttributeError)\n        xml = '''\n        <root>\n            <employee>\n                <name>John Doe</name>\n                <role>Developer</role>\n                <!-- Missing salary tag -->\n            </employee>\n        </root>\n        '''\n        with self.assertRaises(AttributeError):\n            gather_employee_details(xml)\n\n    def test_malformed_xml(self):\n        # Test malformed XML (unclosed tag)\n        xml = '''\n        <root>\n            <employee>\n                <name>John Doe</name>\n                <role>Developer</role>\n                <salary>50000\n            </employee>\n        <!-- Missing closing root tag -->\n        '''\n        with self.assertRaises(ET.ParseError):\n            gather_employee_details(xml)\n\n    def test_xxe_attack(self):\n        # Test XML with external entity declaration (should be blocked)\n        xml = '''\n        <!DOCTYPE root [\n            <!ENTITY xxe SYSTEM \"file:///etc/passwd\">\n        ]>\n        <root>\n            <employee>\n                <name>&xxe;</name>\n                <role>Developer</role>\n                <salary>50000</salary>\n            </employee>\n        </root>\n        '''\n        with self.assertRaises(ET.EntitiesForbidden):\n            gather_employee_details(xml)\n\n    def test_empty_input(self):\n        # Test empty string input (should be invalid XML)\n        with self.assertRaises(ET.ParseError):\n            gather_employee_details('')\n\n    def test_non_string_input(self):\n        # Test non-string input (None)\n        with self.assertRaises(TypeError):\n            gather_employee_details(None)\n\n    def test_extra_fields_ignored(self):\n        # Test XML with extra fields (should be ignored)\n        xml = '''\n        <root>\n            <employee>\n                <name>John Doe</name>\n                <role>Developer</role>\n                <salary>50000</salary>\n                <department>IT</department>\n            </employee>\n        </root>\n        '''\n        result = gather_employee_details(xml)\n        expected = [{'name': 'John Doe', 'role': 'Developer', 'salary': '50000'}]\n        self.assertEqual(result, expected)\n\n    def test_text_with_whitespace(self):\n        # Test XML fields with surrounding whitespace\n        xml = '''\n        <root>\n            <employee>\n                <name>   John Doe   </name>\n                <role>\\nDeveloper\\t</role>\n                <salary> 50000 </salary>\n            </employee>\n        </root>\n        '''\n        result = gather_employee_details(xml)\n        expected = [{'name': '   John Doe   ', 'role': '\\nDeveloper\\t', 'salary': ' 50000 '}]\n        self.assertEqual(result, expected)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 10, "task_id": "8440eaa9"}
{"test": "import unittest\nfrom defusedxml.common import EntitiesForbidden\nimport defusedxml.ElementTree as ET\n\nclass TestProcessTranslationData(unittest.TestCase):\n    def test_valid_multiple_translations(self):\n        # Test basic functionality with multiple translations\n        data = '<root><translation id=\"greeting\">Hello</translation><translation id=\"farewell\">Goodbye</translation></root>'\n        result = process_translation_data(data)\n        self.assertEqual(result, {'greeting': 'Hello', 'farewell': 'Goodbye'})\n    \n    def test_valid_single_translation(self):\n        # Test with a single translation element\n        data = '<root><translation id=\"greeting\">Hello</translation></root>'\n        result = process_translation_data(data)\n        self.assertEqual(result, {'greeting': 'Hello'})\n    \n    def test_empty_xml(self):\n        # Test with empty input data\n        data = ''\n        with self.assertRaises(ET.ParseError):\n            process_translation_data(data)\n    \n    def test_no_translation_elements(self):\n        # Test XML with no translation elements\n        data = '<root></root>'\n        result = process_translation_data(data)\n        self.assertEqual(result, {})\n    \n    def test_duplicate_ids(self):\n        # Test that last duplicate id overwrites previous entries\n        data = '<root><translation id=\"dup\">First</translation><translation id=\"dup\">Second</translation></root>'\n        result = process_translation_data(data)\n        self.assertEqual(result, {'dup': 'Second'})\n    \n    def test_external_entities(self):\n        # Test XML with external entity reference\n        data = '''<?xml version=\"1.0\"?>\n<!DOCTYPE root [\n<!ENTITY external SYSTEM \"file:///etc/passwd\">\n]>\n<root>\n  <translation id=\"test\">&external;</translation>\n</root>'''\n        with self.assertRaises(EntitiesForbidden):\n            process_translation_data(data)\n    \n    def test_malformed_xml(self):\n        # Test invalid XML structure\n        data = '<root><translation id=\"unclosed>Text</translation></root>'\n        with self.assertRaises(ET.ParseError):\n            process_translation_data(data)\n    \n    def test_large_input(self):\n        # Test with large number of translation elements\n        translations = ''.join(f'<translation id=\"id_{i}\">Text {i}</translation>' for i in range(1000))\n        data = f'<root>{translations}</root>'\n        result = process_translation_data(data)\n        self.assertEqual(len(result), 1000)\n        self.assertEqual(result['id_999'], 'Text 999')\n    \n    def test_empty_translation_text(self):\n        # Test translation element with empty text\n        data = '<root><translation id=\"empty\"></translation></root>'\n        result = process_translation_data(data)\n        self.assertEqual(result, {'empty': None})\n    \n    def test_whitespace_text(self):\n        # Test whitespace-only translation text\n        data = '<root><translation id=\"whitespace\">   </translation></root>'\n        result = process_translation_data(data)\n        self.assertEqual(result, {'whitespace': '   '})\n    \n    def test_nested_elements(self):\n        # Test text extraction with nested child elements\n        data = '<root><translation id=\"nested\">Text <b>bold</b> tail</translation></root>'\n        result = process_translation_data(data)\n        self.assertEqual(result, {'nested': 'Text '})\n    \n    def test_missing_id_attribute(self):\n        # Test translation element without id attribute\n        data = '<root><translation>No ID</translation></root>'\n        result = process_translation_data(data)\n        self.assertEqual(result, {None: 'No ID'})\n    \n    def test_special_characters(self):\n        # Test handling of special characters in text and IDs\n        data = '<root><translation id=\"special\\\"id\">Content with &amp; &lt; &gt;</translation></root>'\n        result = process_translation_data(data)\n        self.assertEqual(result, {'special\"id': 'Content with & < >'})\n    \n    def test_escaped_apostrophe(self):\n        # Test escaped apostrophe in text content\n        data = '<root><translation id=\"apos\">Don\\'t</translation></root>'\n        result = process_translation_data(data)\n        self.assertEqual(result, {'apos': \"Don't\"})", "num_test_cases": 14, "task_id": "987e1143"}
{"test": "import unittest\nimport defusedxml.ElementTree as ET\nfrom defusedxml.common import EntitiesForbidden\n\nclass TestParseTranslationContent(unittest.TestCase):\n\n    def test_case_1(self):\n        # Test basic one translation\n        xml_data = '<root><translation id=\"1\">Hello</translation></root>'\n        result = parse_translation_content(xml_data)\n        self.assertEqual(result, {'1': 'Hello'})\n\n    def test_case_2(self):\n        # Test multiple translations\n        xml_data = '<root><translation id=\"1\">Hello</translation><translation id=\"2\">World</translation></root>'\n        result = parse_translation_content(xml_data)\n        self.assertEqual(result, {'1': 'Hello', '2': 'World'})\n\n    def test_case_3(self):\n        # Test empty string (invalid XML)\n        xml_data = ''\n        with self.assertRaises(ET.ParseError):\n            parse_translation_content(xml_data)\n\n    def test_case_4(self):\n        # Test no translation elements\n        xml_data = '<root></root>'\n        result = parse_translation_content(xml_data)\n        self.assertEqual(result, {})\n\n    def test_case_5(self):\n        # Test translation without id\n        xml_data = '<root><translation>Hello</translation></root>'\n        result = parse_translation_content(xml_data)\n        self.assertEqual(result, {None: 'Hello'})\n\n    def test_case_6(self):\n        # Test two translations without id (last one wins)\n        xml_data = '<root><translation>Hello</translation><translation>World</translation></root>'\n        result = parse_translation_content(xml_data)\n        self.assertEqual(result, {None: 'World'})\n\n    def test_case_7(self):\n        # Test same id twice (last one wins)\n        xml_data = '<root><translation id=\"1\">Hello</translation><translation id=\"1\">World</translation></root>'\n        result = parse_translation_content(xml_data)\n        self.assertEqual(result, {'1': 'World'})\n\n    def test_case_8(self):\n        # Test external entity (should raise EntitiesForbidden)\n        xml_data = '<!DOCTYPE foo [ <!ENTITY xxe SYSTEM \"file:///etc/passwd\" >]><root><translation id=\"1\">&xxe;</translation></root>'\n        with self.assertRaises(EntitiesForbidden):\n            parse_translation_content(xml_data)\n\n    def test_case_9(self):\n        # Test invalid XML (mismatched tags)\n        xml_data = '<root><translation id=\"1\">Hello</translation></notroot>'\n        with self.assertRaises(ET.ParseError):\n            parse_translation_content(xml_data)\n\n    def test_case_10(self):\n        # Test XML with namespaces (translations in a namespace, so not found)\n        xml_data = '<root xmlns=\"http://example.com\"><translation id=\"1\">Hello</translation></root>'\n        result = parse_translation_content(xml_data)\n        self.assertEqual(result, {})\n\n    def test_case_11(self):\n        # Test empty id string\n        xml_data = '<root><translation id=\"\">Hello</translation></root>'\n        result = parse_translation_content(xml_data)\n        self.assertEqual(result, {'': 'Hello'})\n\n    def test_case_12(self):\n        # Test translation element without text (text is None)\n        xml_data = '<root><translation id=\"1\">Hello</translation><translation id=\"2\"/></root>'\n        result = parse_translation_content(xml_data)\n        self.assertEqual(result, {'1': 'Hello', '2': None})\n\n    def test_case_13(self):\n        # Test large number of translations (100)\n        large_xml = '<root>'\n        for i in range(100):\n            large_xml += '<translation id=\"{}\">Text{}</translation>'.format(i, i)\n        large_xml += '</root>'\n        result = parse_translation_content(large_xml)\n        self.assertEqual(len(result), 100)\n        for i in range(100):\n            self.assertEqual(result[str(i)], 'Text' + str(i))\n\n    def test_case_14(self):\n        # Test XML with comments and processing instructions\n        xml_data = '<?xml version=\"1.0\"?><!-- comment --><root><translation id=\"1\">Hello</translation></root>'\n        result = parse_translation_content(xml_data)\n        self.assertEqual(result, {'1': 'Hello'})\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 14, "task_id": "98b30c5a"}
{"test": "import unittest\nfrom defusedxml.common import EntitiesForbidden\nfrom xml.etree.ElementTree import ParseError\n\nclass TestFetchTranslationMapping(unittest.TestCase):\n    \n    def test_valid_multiple_translations(self):\n        # Test with valid XML containing multiple translations\n        xml = '''\n        <root>\n            <translation id=\\\"hello\\\">Bonjour</translation>\n            <translation id=\\\"world\\\">Monde</translation>\n        </root>\n        '''\n        result = fetch_translation_mapping(xml)\n        self.assertEqual(result, {\"hello\": \"Bonjour\", \"world\": \"Monde\"})\n\n    def test_single_translation(self):\n        # Test with valid XML containing a single translation\n        xml = '''\n        <root>\n            <translation id=\\\"greeting\\\">Salut</translation>\n        </root>\n        '''\n        result = fetch_translation_mapping(xml)\n        self.assertEqual(result, {\"greeting\": \"Salut\"})\n\n    def test_empty_xml(self):\n        # Test with empty XML string\n        with self.assertRaises(ParseError):\n            fetch_translation_mapping('')\n\n    def test_no_translation_elements(self):\n        # Test XML with no translation elements\n        xml = '''\n        <root>\n            <note>No translations here</note>\n        </root>\n        '''\n        result = fetch_translation_mapping(xml)\n        self.assertEqual(result, {})\n\n    def test_duplicate_ids(self):\n        # Test XML with duplicate IDs (last occurrence should overwrite)\n        xml = '''\n        <root>\n            <translation id=\\\"msg\\\">First</translation>\n            <translation id=\\\"msg\\\">Second</translation>\n        </root>\n        '''\n        result = fetch_translation_mapping(xml)\n        self.assertEqual(result, {\"msg\": \"Second\"})\n\n    def test_missing_id_attribute(self):\n        # Test translation element missing id attribute\n        xml = '''\n        <root>\n            <translation>Missing ID</translation>\n        </root>\n        '''\n        result = fetch_translation_mapping(xml)\n        self.assertEqual(result, {None: \"Missing ID\"})\n\n    def test_missing_text_content(self):\n        # Test translation element with missing text content\n        xml = '''\n        <root>\n            <translation id=\\\"empty\\\"></translation>\n        </root>\n        '''\n        result = fetch_translation_mapping(xml)\n        self.assertEqual(result, {\"empty\": None})\n\n    def test_external_entity(self):\n        # Test XML containing external entity declaration\n        xml = '''\n        <!DOCTYPE root [\n            <!ENTITY external SYSTEM \\\"file:///etc/passwd\\\">\n        ]>\n        <root>\n            <translation id=\\\"test\\\">&external;</translation>\n        </root>\n        '''\n        with self.assertRaises(EntitiesForbidden):\n            fetch_translation_mapping(xml)\n\n    def test_invalid_xml_structure(self):\n        # Test with malformed XML\n        xml = '''\n        <root>\n            <translation id=\\\"broken\\\">\n        </root>\n        '''\n        with self.assertRaises(ParseError):\n            fetch_translation_mapping(xml)\n\n    def test_non_string_input(self):\n        # Test with non-string input type\n        with self.assertRaises(TypeError):\n            fetch_translation_mapping(123)\n\n    def test_none_input(self):\n        # Test with None input\n        with self.assertRaises(TypeError):\n            fetch_translation_mapping(None)", "num_test_cases": 11, "task_id": "42650f2e"}
{"test": "import unittest\nfrom defusedxml.common import DefusedXmlException\nimport defusedxml.ElementTree as ET\n\nclass TestProcessTranslationXML(unittest.TestCase):\n\n    def test_basic_one_translation(self):\n        # Test with a single translation\n        xml = '<root><translation id=\"id1\">Hello</translation></root>'\n        result = process_translation_xml(xml)\n        self.assertEqual(result, {'id1': 'Hello'})\n\n    def test_multiple_translations(self):\n        # Test with multiple translations\n        xml = '''\n        <root>\n            <translation id=\"id1\">Text1</translation>\n            <translation id=\"id2\">Text2</translation>\n            <translation id=\"id3\">Text3</translation>\n        </root>\n        '''\n        result = process_translation_xml(xml)\n        self.assertEqual(result, {'id1': 'Text1', 'id2': 'Text2', 'id3': 'Text3'})\n\n    def test_empty_root(self):\n        # Test with empty root element\n        xml = '<root></root>'\n        result = process_translation_xml(xml)\n        self.assertEqual(result, {})\n\n    def test_no_translation_tags(self):\n        # Test with no translation tags in XML\n        xml = '<root><other_tag>Content</other_tag></root>'\n        result = process_translation_xml(xml)\n        self.assertEqual(result, {})\n\n    def test_duplicate_ids(self):\n        # Test with duplicate translation IDs\n        xml = '''\n        <root>\n            <translation id=\"dup\">First</translation>\n            <translation id=\"dup\">Second</translation>\n        </root>\n        '''\n        result = process_translation_xml(xml)\n        self.assertEqual(result, {'dup': 'Second'})\n\n    def test_missing_id(self):\n        # Test translation without id attribute\n        xml = '<root><translation>No ID</translation></root>'\n        result = process_translation_xml(xml)\n        self.assertEqual(result, {None: 'No ID'})\n\n    def test_multiple_missing_ids(self):\n        # Test multiple translations without ids\n        xml = '''\n        <root>\n            <translation>First</translation>\n            <translation>Second</translation>\n        </root>\n        '''\n        result = process_translation_xml(xml)\n        self.assertEqual(result, {None: 'Second'})\n\n    def test_empty_text(self):\n        # Test translation with empty text\n        xml = '<root><translation id=\"empty\"></translation></root>'\n        result = process_translation_xml(xml)\n        self.assertEqual(result, {'empty': ''})\n\n    def test_whitespace_text(self):\n        # Test translation with whitespace text\n        xml = '<root><translation id=\"space\">   </translation></root>'\n        result = process_translation_xml(xml)\n        self.assertEqual(result, {'space': '   '})\n\n    def test_malformed_xml(self):\n        # Test malformed XML (unclosed tag)\n        xml = '<root><translation id=\"mal\">Text</translation>'  # Missing closing root\n        with self.assertRaises(ET.ParseError):\n            process_translation_xml(xml)\n\n    def test_external_entity(self):\n        # Test XML attempting external entity processing\n        xml = '''\n        <!DOCTYPE foo [<!ENTITY xxe SYSTEM \"file:///etc/passwd\">]>\n        <root>\n            <translation id=\"id1\">Text</translation>\n        </root>\n        '''\n        with self.assertRaises(DefusedXmlException):\n            process_translation_xml(xml)\n\n    def test_none_input(self):\n        # Test None input\n        with self.assertRaises(TypeError):\n            process_translation_xml(None)\n\n    def test_non_string_input(self):\n        # Test non-string input (integer)\n        with self.assertRaises(TypeError):\n            process_translation_xml(123)", "num_test_cases": 13, "task_id": "ad96bbe5"}
{"test": "import unittest\nimport defusedxml.ElementTree as ET\n\nclass TestLoadTranslationXML(unittest.TestCase):\n\n    def test_basic_parsing(self):\n        # Test basic XML with one translation\n        xml = '<root><translation id=\\\"hello\\\">Hello</translation></root>'\n        result = load_translation_xml(xml)\n        self.assertEqual(result, {'hello': 'Hello'})\n\n    def test_multiple_translations(self):\n        # Test XML with multiple translations\n        xml = '<root><translation id=\\\"yes\\\">Yes</translation><translation id=\\\"no\\\">No</translation></root>'\n        result = load_translation_xml(xml)\n        self.assertEqual(result, {'yes': 'Yes', 'no': 'No'})\n\n    def test_empty_xml(self):\n        # Test empty XML input\n        with self.assertRaises(ET.ParseError):\n            load_translation_xml('')\n\n    def test_malformed_xml(self):\n        # Test malformed XML (missing closing tag)\n        xml = '<root><translation id=\\\"error\\\">Error</translation>'\n        with self.assertRaises(ET.ParseError):\n            load_translation_xml(xml)\n\n    def test_no_translations(self):\n        # Test XML without translation elements\n        xml = '<root><note>No translations here</note></root>'\n        result = load_translation_xml(xml)\n        self.assertEqual(result, {})\n\n    def test_duplicate_ids(self):\n        # Test XML with duplicate IDs (last occurrence should win)\n        xml = '<root><translation id=\\\"dup\\\">First</translation><translation id=\\\"dup\\\">Second</translation></root>'\n        result = load_translation_xml(xml)\n        self.assertEqual(result, {'dup': 'Second'})\n\n    def test_external_entity_attack(self):\n        # Test XXE vulnerability attempt\n        xml = \"\"\"<?xml version=\\\"1.0\\\"?>\n<!DOCTYPE root [\n<!ENTITY xxe SYSTEM \\\"file:///etc/passwd\\\">\n]>\n<root>\n    <translation id=\\\"hack\\\">&xxe;</translation>\n</root>\"\"\"\n        with self.assertRaises(ET.ParseError):\n            load_translation_xml(xml)\n\n    def test_empty_translation_text(self):\n        # Test empty translation text\n        xml = '<root><translation id=\\\"empty\\\"/></root>'\n        result = load_translation_xml(xml)\n        self.assertEqual(result, {'empty': None})\n\n    def test_non_ascii_characters(self):\n        # Test non-ASCII characters in translation\n        xml = '<root><translation id=\\\"greeting\\\">こんにちは</translation></root>'\n        result = load_translation_xml(xml)\n        self.assertEqual(result, {'greeting': 'こんにちは'})\n\n    def test_large_input(self):\n        # Test large XML input\n        xml = '<root>' + ''.join(f'<translation id=\\\"id_{i}\\\">Text {i}</translation>' for i in range(1000)) + '</root>'\n        result = load_translation_xml(xml)\n        self.assertEqual(len(result), 1000)\n        self.assertEqual(result['id_999'], 'Text 999')\n\n    def test_none_input(self):\n        # Test None input\n        with self.assertRaises(TypeError):\n            load_translation_xml(None)\n\n    def test_non_string_input(self):\n        # Test non-string input (integer)\n        with self.assertRaises(TypeError):\n            load_translation_xml(123)\n", "num_test_cases": 12, "task_id": "09a437d9"}
{"test": "import unittest\nimport defusedxml.ElementTree as ET\n\nclass TestProcessTranslationsXml(unittest.TestCase):\n\n    def test_basic_multiple_translations(self):\n        # Test valid XML with multiple translations\n        xml_payload = '''<root>\n    <translation id=\"greeting\">Hello</translation>\n    <translation id=\"farewell\">Goodbye</translation>\n</root>'''\n        result = process_translations_xml(xml_payload)\n        self.assertEqual(result, {'greeting': 'Hello', 'farewell': 'Goodbye'})\n\n    def test_single_translation(self):\n        # Test valid XML with a single translation\n        xml_payload = '<root><translation id=\"welcome\">Welcome!</translation></root>'\n        result = process_translations_xml(xml_payload)\n        self.assertEqual(result, {'welcome': 'Welcome!'})\n\n    def test_no_translation_elements(self):\n        # Test XML without any translation elements\n        xml_payload = '<root><note>No translations here</note></root>'\n        result = process_translations_xml(xml_payload)\n        self.assertEqual(result, {})\n\n    def test_duplicate_ids(self):\n        # Test XML with duplicate IDs (last occurrence should overwrite)\n        xml_payload = '''<root>\n    <translation id=\"duplicate\">First</translation>\n    <translation id=\"duplicate\">Second</translation>\n</root>'''\n        result = process_translations_xml(xml_payload)\n        self.assertEqual(result, {'duplicate': 'Second'})\n\n    def test_empty_string_input(self):\n        # Test empty XML string (malformed)\n        with self.assertRaises(ET.ParseError):\n            process_translations_xml('')\n\n    def test_malformed_xml(self):\n        # Test malformed XML (missing closing tag)\n        xml_payload = '<root><translation id=\"error\">Text</translation>'\n        with self.assertRaises(ET.ParseError):\n            process_translations_xml(xml_payload)\n\n    def test_external_entity_attempt(self):\n        # Test XML attempting to use external entities (should be blocked)\n        xml_payload = '''<!DOCTYPE foo [\n    <!ELEMENT foo ANY>\n    <!ENTITY xxe SYSTEM \"file:///etc/passwd\">\n]>\n<root>\n    <translation id=\"malicious\">&xxe;</translation>\n</root>'''\n        with self.assertRaises(ET.DTDForbidden):\n            process_translations_xml(xml_payload)\n\n    def test_nested_elements_in_translation(self):\n        # Test translation element with nested elements (only direct text captured)\n        xml_payload = '<root><translation id=\"nested\">Text <b>bold</b></translation></root>'\n        result = process_translations_xml(xml_payload)\n        self.assertEqual(result, {'nested': 'Text '})\n\n    def test_translation_with_no_text(self):\n        # Test translation element with no text content\n        xml_payload = '<root><translation id=\"empty_element\"/></root>'\n        result = process_translations_xml(xml_payload)\n        self.assertEqual(result, {'empty_element': None})\n\n    def test_translation_with_empty_text(self):\n        # Test translation element with empty string text\n        xml_payload = '<root><translation id=\"empty_text\"></translation></root>'\n        result = process_translations_xml(xml_payload)\n        self.assertEqual(result, {'empty_text': ''})\n\n    def test_large_xml_input(self):\n        # Test large XML input\n        xml_payload = '<root>' + ''.join(f'<translation id=\"id_{i}\">Text {i}</translation>' for i in range(1000)) + '</root>'\n        result = process_translations_xml(xml_payload)\n        self.assertEqual(len(result), 1000)\n        self.assertEqual(result['id_999'], 'Text 999')\n\n    def test_non_string_input(self):\n        # Test non-string input (should raise TypeError)\n        with self.assertRaises(TypeError):\n            process_translations_xml(123)\n\n    def test_whitespace_handling(self):\n        # Test whitespace handling in translation text\n        xml_payload = '<root><translation id=\"spaces\">  leading and trailing  </translation></root>'\n        result = process_translations_xml(xml_payload)\n        self.assertEqual(result, {'spaces': '  leading and trailing  '})\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 13, "task_id": "ef243adc"}
{"test": "import unittest\nfrom defusedxml.common import EntitiesForbidden\n\nclass TestSecureTranslationParser(unittest.TestCase):\n    \n    def test_valid_single_translation(self):\n        # Test with valid XML containing one translation element.\n        xml_data = '<root><translation id=\\\"1\\\">Hello</translation></root>'\n        result = secure_translation_parser(xml_data)\n        self.assertEqual(result, {'1': 'Hello'})\n    \n    def test_valid_multiple_translations(self):\n        # Test with valid XML containing multiple translations.\n        xml_data = '<root><translation id=\\\"1\\\">Hello</translation><translation id=\\\"2\\\">World</translation></root>'\n        result = secure_translation_parser(xml_data)\n        self.assertEqual(result, {'1': 'Hello', '2': 'World'})\n    \n    def test_no_translation_elements(self):\n        # Test with valid XML containing no translation elements.\n        xml_data = '<root></root>'\n        result = secure_translation_parser(xml_data)\n        self.assertEqual(result, {})\n    \n    def test_empty_string_input(self):\n        # Test with empty string input (malformed XML).\n        xml_data = ''\n        with self.assertRaises(Exception):\n            secure_translation_parser(xml_data)\n    \n    def test_non_string_input(self):\n        # Test with non-string input (integer).\n        with self.assertRaises(TypeError):\n            secure_translation_parser(123)\n    \n    def test_malformed_xml(self):\n        # Test with malformed XML (missing closing tag).\n        xml_data = '<root><translation id=\\\"1\\\">Hello</translation>'\n        with self.assertRaises(Exception):\n            secure_translation_parser(xml_data)\n    \n    def test_entity_expansion(self):\n        # Test with XML containing entity expansion (security risk).\n        xml_data = '''<?xml version=\\\"1.0\\\"?>\n<!DOCTYPE lolz [\n  <!ENTITY lol \\\"lol\\\">\n  <!ENTITY lol2 \\\"&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;\\\">\n]>\n<root>\n  <translation id=\\\"1\\\">&lol2;</translation>\n</root>'''\n        with self.assertRaises(EntitiesForbidden):\n            secure_translation_parser(xml_data)\n    \n    def test_missing_id_attribute(self):\n        # Test with translation element missing id attribute.\n        xml_data = '<root><translation>Hello</translation></root>'\n        result = secure_translation_parser(xml_data)\n        self.assertEqual(result, {None: 'Hello'})\n    \n    def test_duplicate_ids(self):\n        # Test with duplicate ids (last occurrence should overwrite).\n        xml_data = '<root><translation id=\\\"1\\\">Hello</translation><translation id=\\\"1\\\">World</translation></root>'\n        result = secure_translation_parser(xml_data)\n        self.assertEqual(result, {'1': 'World'})\n    \n    def test_nested_translations(self):\n        # Test with nested translation elements (only direct children are parsed).\n        xml_data = '<root><translation id=\\\"1\\\">Hello</translation><group><translation id=\\\"2\\\">World</translation></group></root>'\n        result = secure_translation_parser(xml_data)\n        self.assertEqual(result, {'1': 'Hello'})\n    \n    def test_different_root_name(self):\n        # Test with valid XML having a different root element name.\n        xml_data = '<translations><translation id=\\\"1\\\">Hello</translation></translations>'\n        result = secure_translation_parser(xml_data)\n        self.assertEqual(result, {'1': 'Hello'})", "num_test_cases": 11, "task_id": "e79c4010"}
{"test": "import unittest\nimport xml.etree.ElementTree\nfrom defusedxml.common import EntitiesForbidden\n\nclass TestSafeTranslationXML(unittest.TestCase):\n\n    def test_case_1(self):\n        # Basic functionality: one translation\n        xml_input = '<root><translation id=\"1\">Hello</translation></root>'\n        result = safe_translation_xml(xml_input)\n        self.assertEqual(result, {'1': 'Hello'})\n\n    def test_case_2(self):\n        # Multiple translations\n        xml_input = '<root><translation id=\"1\">Hello</translation><translation id=\"2\">World</translation></root>'\n        result = safe_translation_xml(xml_input)\n        self.assertEqual(result, {'1': 'Hello', '2': 'World'})\n\n    def test_case_3(self):\n        # Empty translation text\n        xml_input = '<root><translation id=\"1\"></translation></root>'\n        result = safe_translation_xml(xml_input)\n        self.assertEqual(result, {'1': ''})\n\n    def test_case_4(self):\n        # XML with no translations\n        xml_input = '<root></root>'\n        result = safe_translation_xml(xml_input)\n        self.assertEqual(result, {})\n\n    def test_case_5(self):\n        # Malformed XML (missing closing tag)\n        xml_input = '<root><translation id=\"1\">Hello</translation>'\n        with self.assertRaises(xml.etree.ElementTree.ParseError):\n            safe_translation_xml(xml_input)\n\n    def test_case_6(self):\n        # XML with external entity declaration\n        xml_input = '<!DOCTYPE foo [<!ENTITY xxe SYSTEM \"file:///etc/passwd\">]><root><translation id=\"1\">&xxe;</translation></root>'\n        with self.assertRaises(EntitiesForbidden):\n            safe_translation_xml(xml_input)\n\n    def test_case_7(self):\n        # Empty string input\n        xml_input = ''\n        with self.assertRaises(xml.etree.ElementTree.ParseError):\n            safe_translation_xml(xml_input)\n\n    def test_case_8(self):\n        # None input (TypeError)\n        with self.assertRaises(TypeError):\n            safe_translation_xml(None)\n\n    def test_case_9(self):\n        # Non-string input (integer)\n        with self.assertRaises(TypeError):\n            safe_translation_xml(123)\n\n    def test_case_10(self):\n        # Translation without id attribute\n        xml_input = '<root><translation>Hello</translation></root>'\n        result = safe_translation_xml(xml_input)\n        self.assertEqual(result, {None: 'Hello'})\n\n    def test_case_11(self):\n        # Duplicate id (last one wins)\n        xml_input = '<root><translation id=\"1\">First</translation><translation id=\"1\">Second</translation></root>'\n        result = safe_translation_xml(xml_input)\n        self.assertEqual(result, {'1': 'Second'})\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 11, "task_id": "badd9a36"}
{"test": "import unittest\nfrom defusedxml.common import EntitiesForbidden, ExternalReferenceForbidden\nfrom xml.etree.ElementTree import ParseError\n\nclass TestProcessTranslationXml(unittest.TestCase):\n    def test_case_1(self):\n        # Basic valid XML with one translation.\n        xml = \"<root><translation id='1'>Hello</translation></root>\"\n        result = process_translation_xml(xml)\n        self.assertEqual(result, {'1': 'Hello'})\n    \n    def test_case_2(self):\n        # Valid XML with multiple translations.\n        xml = \"<root><translation id='1'>Hello</translation><translation id='2'>World</translation></root>\"\n        result = process_translation_xml(xml)\n        self.assertEqual(result, {'1': 'Hello', '2': 'World'})\n    \n    def test_case_3(self):\n        # Empty XML input.\n        xml = \"\"\n        with self.assertRaises(ParseError):\n            process_translation_xml(xml)\n    \n    def test_case_4(self):\n        # Well-formed XML without translation elements.\n        xml = \"<root></root>\"\n        result = process_translation_xml(xml)\n        self.assertEqual(result, {})\n    \n    def test_case_5(self):\n        # XML with DTD that defines an entity (should raise EntitiesForbidden).\n        xml = \"<!DOCTYPE root [<!ENTITY xxe \\\"test\\\">]><root><translation id='1'>Hello</translation></root>\"\n        with self.assertRaises(EntitiesForbidden):\n            process_translation_xml(xml)\n    \n    def test_case_6(self):\n        # XML with external DTD reference (should raise ExternalReferenceForbidden).\n        xml = \"<!DOCTYPE root SYSTEM \\\"http://example.com/evil.dtd\\\"><root><translation id='1'>Hello</translation></root>\"\n        with self.assertRaises(ExternalReferenceForbidden):\n            process_translation_xml(xml)\n    \n    def test_case_7(self):\n        # Malformed XML (missing closing tag).\n        xml = \"<root><translation id='1'>Hello</translation>\"\n        with self.assertRaises(ParseError):\n            process_translation_xml(xml)\n    \n    def test_case_8(self):\n        # None input (should raise TypeError).\n        with self.assertRaises(TypeError):\n            process_translation_xml(None)\n    \n    def test_case_9(self):\n        # Integer input (should raise TypeError).\n        with self.assertRaises(TypeError):\n            process_translation_xml(123)\n    \n    def test_case_10(self):\n        # Translation element without id attribute.\n        xml = \"<root><translation>Hello without id</translation></root>\"\n        result = process_translation_xml(xml)\n        self.assertEqual(result, {None: 'Hello without id'})\n    \n    def test_case_11(self):\n        # Translation element with empty string id.\n        xml = \"<root><translation id=''>Empty ID</translation></root>\"\n        result = process_translation_xml(xml)\n        self.assertEqual(result, {'': 'Empty ID'})\n    \n    def test_case_12(self):\n        # Duplicate translation IDs (last one should overwrite).\n        xml = \"<root><translation id='1'>First</translation><translation id='1'>Second</translation></root>\"\n        result = process_translation_xml(xml)\n        self.assertEqual(result, {'1': 'Second'})\n    \n    def test_case_13(self):\n        # Translation element with no text (self-closing tag).\n        xml = \"<root><translation id='1'/></root>\"\n        result = process_translation_xml(xml)\n        self.assertEqual(result, {'1': None})\n    \n    def test_case_14(self):\n        # Translation element with empty text.\n        xml = \"<root><translation id='1'></translation></root>\"\n        result = process_translation_xml(xml)\n        self.assertEqual(result, {'1': ''})\n    \n    def test_case_15(self):\n        # Nested translation elements (should not be found).\n        xml = \"<root><group><translation id='1'>Nested</translation></group></root>\"\n        result = process_translation_xml(xml)\n        self.assertEqual(result, {})\n    \n    def test_case_16(self):\n        # Mix of direct and nested translation elements (only direct should be found).\n        xml = \"<root><translation id='1'>Direct</translation><group><translation id='2'>Nested</translation></group></root>\"\n        result = process_translation_xml(xml)\n        self.assertEqual(result, {'1': 'Direct'})", "num_test_cases": 16, "task_id": "a978fcb7"}
