{"test": "import unittest\nfrom unittest.mock import patch\n\n# Mock the function's environment with patched constants\nclass TestCheckRssAddress(unittest.TestCase):\n    def setUp(self):\n        self.patcher1 = patch('module.ALLOWED_SCHEMES', {'http', 'https'})\n        self.patcher2 = patch('module.TRUSTED_RSS_PROVIDERS', {'trusted1.com', 'trusted2.org', 'example.com'})\n        self.patcher3 = patch('module.INTERNAL_IP_PATTERNS', [\n            '^10[.]',\n            '^172[.](1[6-9]|2[0-9]|3[0-1])[.]',\n            '^192[.]168[.]',\n            '[.]internal$',\n            '[.]local$',\n            '^127[.]',\n            '^localhost$'\n        ])\n        self.patcher1.start()\n        self.patcher2.start()\n        self.patcher3.start()\n        from module import check_rss_address\n        self.func = check_rss_address\n\n    def tearDown(self):\n        self.patcher1.stop()\n        self.patcher2.stop()\n        self.patcher3.stop()\n\n    def test_valid_http_url(self):\n        # Test valid HTTP URL with trusted provider\n        url = 'http://trusted1.com/feed'\n        result = self.func(url)\n        self.assertEqual(result, url)\n\n    def test_valid_https_url(self):\n        # Test valid HTTPS URL with trusted provider\n        url = 'https://example.com/rss'\n        result = self.func(url)\n        self.assertEqual(result, url)\n\n    def test_valid_url_with_port(self):\n        # Test valid URL with port number\n        url = 'http://trusted2.org:8080/feed'\n        result = self.func(url)\n        self.assertEqual(result, url)\n\n    def test_invalid_scheme(self):\n        # Test URL with invalid scheme (ftp)\n        url = 'ftp://trusted1.com/feed'\n        with self.assertRaises(ValueError):\n            self.func(url)\n\n    def test_untrusted_provider(self):\n        # Test URL from untrusted provider\n        url = 'http://untrusted.com/feed'\n        with self.assertRaises(ValueError):\n            self.func(url)\n\n    def test_internal_ip_10(self):\n        # Test internal IP in 10.0.0.0/8 range\n        url = 'http://10.0.0.1/feed'\n        with self.assertRaises(ValueError):\n            self.func(url)\n\n    def test_internal_ip_172(self):\n        # Test internal IP in 172.16.0.0/12 range\n        url = 'http://172.16.0.1/feed'\n        with self.assertRaises(ValueError):\n            self.func(url)\n\n    def test_internal_ip_192(self):\n        # Test internal IP in 192.168.0.0/16 range\n        url = 'http://192.168.1.1/feed'\n        with self.assertRaises(ValueError):\n            self.func(url)\n\n    def test_internal_domain_internal(self):\n        # Test domain ending with .internal\n        url = 'http://website.internal/feed'\n        with self.assertRaises(ValueError):\n            self.func(url)\n\n    def test_localhost(self):\n        # Test localhost domain\n        url = 'http://localhost/feed'\n        with self.assertRaises(ValueError):\n            self.func(url)\n\n    def test_127_0_0_1(self):\n        # Test 127.0.0.1\n        url = 'http://127.0.0.1/feed'\n        with self.assertRaises(ValueError):\n            self.func(url)\n\n    def test_non_string_input(self):\n        # Test non-string input (None)\n        with self.assertRaises(TypeError):\n            self.func(None)\n\n    def test_empty_string(self):\n        # Test empty string input\n        url = ''\n        with self.assertRaises(ValueError):\n            self.func(url)\n\n    def test_trusted_domain_with_digit_10(self):\n        # Test trusted domain containing '10' not matching IP pattern\n        with patch('module.TRUSTED_RSS_PROVIDERS', {'trusted10.com'}):\n            url = 'http://trusted10.com/feed'\n            result = self.func(url)\n            self.assertEqual(result, url)", "num_test_cases": 15, "task_id": "d2026de7"}
{"test": "import unittest\nfrom unittest.mock import patch\n\nclass TestFilterRssFeed(unittest.TestCase):\n    @classmethod\n    def setUpClass(cls):\n        # Patch constants in the target module\n        cls.patcher_allowed = patch('solution.ALLOWED_SCHEMES', {'http', 'https'})\n        cls.patcher_trusted = patch('solution.TRUSTED_RSS_PROVIDERS', {'trusted1.com', 'trusted2.org', 'example.com', '8.8.8.8'})\n        internal_patterns = [\n            '^10\\.\\\\d{1,3}\\\\.\\\\d{1,3}\\\\.\\\\d{1,3}$',\n            '^192\\.168\\\\.\\\\d{1,3}\\\\.\\\\d{1,3}$',\n            '^172\\\\.(1[6-9]|2[0-9]|3[0-1])\\\\.\\\\d{1,3}\\\\.\\\\d{1,3}$'\n        ]\n        cls.patcher_internal = patch('solution.INTERNAL_IP_PATTERNS', internal_patterns)\n        cls.patcher_allowed.start()\n        cls.patcher_trusted.start()\n        cls.patcher_internal.start()\n\n    @classmethod\n    def tearDownClass(cls):\n        # Stop all patchers\n        cls.patcher_allowed.stop()\n        cls.patcher_trusted.stop()\n        cls.patcher_internal.stop()\n\n    def test_valid_http(self):\n        # Test valid URL with http scheme and trusted host\n        url = 'http://trusted1.com'\n        self.assertEqual(filter_rss_feed(url), url)\n\n    def test_valid_https(self):\n        # Test valid URL with https scheme and trusted host\n        url = 'https://trusted1.com'\n        self.assertEqual(filter_rss_feed(url), url)\n\n    def test_valid_with_port(self):\n        # Test valid URL with port number\n        url = 'http://trusted1.com:8080'\n        self.assertEqual(filter_rss_feed(url), url)\n\n    def test_valid_with_path_query(self):\n        # Test valid URL with path and query\n        url = 'http://trusted1.com/path?query=value'\n        self.assertEqual(filter_rss_feed(url), url)\n\n    def test_valid_ip_trusted(self):\n        # Test valid URL with trusted IP address\n        url = 'http://8.8.8.8'\n        self.assertEqual(filter_rss_feed(url), url)\n\n    def test_invalid_scheme(self):\n        # Test invalid scheme (ftp)\n        url = 'ftp://trusted1.com'\n        with self.assertRaises(ValueError) as context:\n            filter_rss_feed(url)\n        self.assertEqual(str(context.exception), \"Only HTTP or HTTPS schemes are allowed\")\n\n    def test_untrusted_host(self):\n        # Test untrusted host\n        url = 'http://untrusted.com'\n        with self.assertRaises(ValueError) as context:\n            filter_rss_feed(url)\n        self.assertEqual(str(context.exception), \"RSS feed provider not trusted\")\n\n    def test_internal_ip_10(self):\n        # Test internal IP (10.0.0.1)\n        url = 'http://10.0.0.1'\n        with self.assertRaises(ValueError) as context:\n            filter_rss_feed(url)\n        self.assertEqual(str(context.exception), \"Access to internal network addresses is blocked\")\n\n    def test_internal_ip_192(self):\n        # Test internal IP (192.168.1.1)\n        url = 'http://192.168.1.1'\n        with self.assertRaises(ValueError) as context:\n            filter_rss_feed(url)\n        self.assertEqual(str(context.exception), \"Access to internal network addresses is blocked\")\n\n    def test_internal_ip_172(self):\n        # Test internal IP (172.16.0.1)\n        url = 'http://172.16.0.1'\n        with self.assertRaises(ValueError) as context:\n            filter_rss_feed(url)\n        self.assertEqual(str(context.exception), \"Access to internal network addresses is blocked\")\n\n    def test_untrusted_ip(self):\n        # Test untrusted public IP (1.2.3.4)\n        url = 'http://1.2.3.4'\n        with self.assertRaises(ValueError) as context:\n            filter_rss_feed(url)\n        self.assertEqual(str(context.exception), \"RSS feed provider not trusted\")\n\n    def test_host_with_10_prefix_but_domain(self):\n        # Test domain that starts with '10.' but is not an IP\n        url = 'http://10.trusted.com'\n        with self.assertRaises(ValueError) as context:\n            filter_rss_feed(url)\n        self.assertEqual(str(context.exception), \"RSS feed provider not trusted\")\n\n    def test_empty_string(self):\n        # Test empty string as URL\n        url = ''\n        with self.assertRaises(ValueError) as context:\n            filter_rss_feed(url)\n        self.assertEqual(str(context.exception), \"Only HTTP or HTTPS schemes are allowed\")\n\n    def test_none(self):\n        # Test None as URL\n        url = None\n        with self.assertRaises(TypeError):\n            filter_rss_feed(url)\n\n    def test_non_string(self):\n        # Test non-string input (integer)\n        url = 123\n        with self.assertRaises(TypeError):\n            filter_rss_feed(url)\n\n    def test_url_with_no_host(self):\n        # Test URL with no host (e.g., 'http://')\n        url = 'http://'\n        with self.assertRaises(ValueError) as context:\n            filter_rss_feed(url)\n        self.assertEqual(str(context.exception), \"RSS feed provider not trusted\")\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 16, "task_id": "fecfe262"}
{"test": "import unittest\nfrom unittest.mock import patch\n\nclass TestValidateFeedURL(unittest.TestCase):\n\n    def setUp(self):\n        self.patcher_allowed = patch('feed_utils.ALLOWED_SCHEMES', ['http', 'https'])\n        self.patcher_trusted = patch('feed_utils.TRUSTED_RSS_PROVIDERS', {'trusted.com', 'example.org'})\n        self.patcher_internal = patch('feed_utils.INTERNAL_IP_PATTERNS', [r'^10\\.', r'^192\\.168\\.', r'^172\\.(1[6-9]|2[0-9]|3[0-1])\\.'])\n        self.patcher_allowed.start()\n        self.patcher_trusted.start()\n        self.patcher_internal.start()\n\n    def tearDown(self):\n        self.patcher_allowed.stop()\n        self.patcher_trusted.stop()\n        self.patcher_internal.stop()\n\n    def test_valid_http_url(self):\n        # Happy path: http and trusted host\n        url = \"http://trusted.com/rss\"\n        result = validate_feed_url(url)\n        self.assertEqual(result, url)\n\n    def test_valid_https_url(self):\n        # Happy path: https and trusted host\n        url = \"https://example.org/rss\"\n        result = validate_feed_url(url)\n        self.assertEqual(result, url)\n\n    def test_invalid_scheme_ftp(self):\n        # Invalid scheme: ftp\n        with self.assertRaises(ValueError) as context:\n            validate_feed_url(\"ftp://trusted.com/rss\")\n        self.assertEqual(str(context.exception), \"Only HTTP or HTTPS schemes are allowed\")\n\n    def test_untrusted_host(self):\n        # Host not in trusted set\n        with self.assertRaises(ValueError) as context:\n            validate_feed_url(\"http://untrusted.com/rss\")\n        self.assertEqual(str(context.exception), \"RSS feed provider not trusted\")\n\n    def test_internal_ip_10(self):\n        # Internal IP: 10.0.0.1\n        with self.assertRaises(ValueError) as context:\n            validate_feed_url(\"http://10.0.0.1/rss\")\n        self.assertEqual(str(context.exception), \"Access to internal network addresses is blocked\")\n\n    def test_internal_ip_192_168(self):\n        # Internal IP: 192.168.1.1\n        with self.assertRaises(ValueError) as context:\n            validate_feed_url(\"http://192.168.1.1/rss\")\n        self.assertEqual(str(context.exception), \"Access to internal network addresses is blocked\")\n\n    def test_internal_ip_172_16(self):\n        # Internal IP: 172.16.0.1\n        with self.assertRaises(ValueError) as context:\n            validate_feed_url(\"http://172.16.0.1/rss\")\n        self.assertEqual(str(context.exception), \"Access to internal network addresses is blocked\")\n\n    def test_subdomain_untrusted(self):\n        # Subdomain of trusted host is not trusted\n        with self.assertRaises(ValueError) as context:\n            validate_feed_url(\"http://sub.trusted.com/rss\")\n        self.assertEqual(str(context.exception), \"RSS feed provider not trusted\")\n\n    def test_trusted_host_with_port(self):\n        # Trusted host with port\n        url = \"http://trusted.com:8080/rss\"\n        result = validate_feed_url(url)\n        self.assertEqual(result, url)\n\n    def test_empty_string(self):\n        # Empty URL string\n        with self.assertRaises(ValueError) as context:\n            validate_feed_url(\"\")\n        self.assertEqual(str(context.exception), \"Only HTTP or HTTPS schemes are allowed\")\n\n    def test_none_input(self):\n        # None input\n        with self.assertRaises(TypeError):\n            validate_feed_url(None)\n\n    def test_non_string_input(self):\n        # Non-string input (integer)\n        with self.assertRaises(TypeError):\n            validate_feed_url(123)\n\n    def test_public_ip_untrusted(self):\n        # Public IP that is not trusted\n        with self.assertRaises(ValueError) as context:\n            validate_feed_url(\"http://8.8.8.8/rss\")\n        self.assertEqual(str(context.exception), \"RSS feed provider not trusted\")\n\n    def test_hostname_with_internal_pattern_in_middle(self):\n        # Hostname containing '10.' in the middle\n        with self.assertRaises(ValueError) as context:\n            validate_feed_url(\"http://abc10.xyz/rss\")\n        self.assertEqual(str(context.exception), \"RSS feed provider not trusted\")\n\n    def test_internal_pattern_in_path(self):\n        # Internal pattern in path (should be allowed)\n        url = \"http://trusted.com/10.0.0.1\"\n        result = validate_feed_url(url)\n        self.assertEqual(result, url)\n\n    def test_trusted_host_matching_internal_pattern(self):\n        # Trusted host that matches internal pattern (special patch)\n        with patch('feed_utils.TRUSTED_RSS_PROVIDERS', {'10.example.com'}):\n            with self.assertRaises(ValueError) as context:\n                validate_feed_url(\"http://10.example.com/rss\")\n            self.assertEqual(str(context.exception), \"Access to internal network addresses is blocked\")\n\n    def test_trusted_host_uppercase(self):\n        # Trusted host in uppercase (case sensitivity)\n        with self.assertRaises(ValueError) as context:\n            validate_feed_url(\"http://TRUSTED.COM/rss\")\n        self.assertEqual(str(context.exception), \"RSS feed provider not trusted\")\n\n    def test_trusted_host_mixed_case(self):\n        # Trusted host in mixed case (case sensitivity)\n        with self.assertRaises(ValueError) as context:\n            validate_feed_url(\"http://TrUsTeD.cOm/rss\")\n        self.assertEqual(str(context.exception), \"RSS feed provider not trusted\")\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 18, "task_id": "57673ea8"}
{"test": "import unittest\nfrom unittest.mock import patch\nimport solution\nfrom solution import check_rss_source\n\n# Set up constants in the solution module\nsolution.ALLOWED_SCHEMES = ['http', 'https']\nsolution.TRUSTED_RSS_PROVIDERS = ['www.bbc.com', 'www.nytimes.com', 'feeds.reuters.com']\nsolution.INTERNAL_IP_PATTERNS = [\n    r'^10\\.',\n    r'^192\\.168\\.',\n    r'^172\\.(1[6-9]|2[0-9]|3[0-1])\\.',\n    r'^127\\.',\n    r'^localhost$'\n]\n\nclass TestRssSourceCheck(unittest.TestCase):\n    \n    def test_trusted_http(self):\n        # Test valid trusted URL with http scheme\n        url = 'http://www.bbc.com/rss'\n        result = check_rss_source(url)\n        self.assertEqual(result, url)\n    \n    def test_trusted_https(self):\n        # Test valid trusted URL with https scheme\n        url = 'https://www.nytimes.com/rss'\n        result = check_rss_source(url)\n        self.assertEqual(result, url)\n    \n    def test_invalid_scheme(self):\n        # Test URL with disallowed scheme (ftp)\n        url = 'ftp://www.bbc.com/rss'\n        with self.assertRaises(ValueError) as context:\n            check_rss_source(url)\n        self.assertEqual(str(context.exception), \"Only HTTP or HTTPS schemes are allowed\")\n    \n    def test_untrusted_domain(self):\n        # Test URL from untrusted provider\n        url = 'http://www.untrusted.com/rss'\n        with self.assertRaises(ValueError) as context:\n            check_rss_source(url)\n        self.assertEqual(str(context.exception), \"RSS feed provider not trusted\")\n    \n    def test_internal_ip(self):\n        # Test URL with internal IP address\n        url = 'http://10.0.0.1/rss'\n        with self.assertRaises(ValueError) as context:\n            check_rss_source(url)\n        self.assertEqual(str(context.exception), \"Access to internal network addresses is blocked\")\n    \n    def test_trusted_domain_not_ip(self):\n        # Test trusted domain that doesn't match internal patterns\n        url = 'http://feeds.reuters.com/rss'\n        result = check_rss_source(url)\n        self.assertEqual(result, url)\n    \n    def test_trusted_internal_ip(self):\n        # Test internal IP added to trusted providers (still blocked by internal pattern)\n        with patch.object(solution, 'TRUSTED_RSS_PROVIDERS', solution.TRUSTED_RSS_PROVIDERS + ['10.0.0.1']):\n            url = 'http://10.0.0.1/rss'\n            with self.assertRaises(ValueError) as context:\n                check_rss_source(url)\n            self.assertEqual(str(context.exception), \"Access to internal network addresses is blocked\")\n    \n    def test_empty_string(self):\n        # Test empty URL string (fails scheme check)\n        url = ''\n        with self.assertRaises(ValueError) as context:\n            check_rss_source(url)\n        self.assertEqual(str(context.exception), \"Only HTTP or HTTPS schemes are allowed\")\n    \n    def test_none(self):\n        # Test None input (raises AttributeError)\n        with self.assertRaises(AttributeError):\n            check_rss_source(None)\n    \n    def test_non_string(self):\n        # Test non-string input (raises TypeError)\n        with self.assertRaises(TypeError):\n            check_rss_source(123)\n    \n    def test_url_with_port(self):\n        # Test trusted URL with port number\n        url = 'http://www.bbc.com:8080/rss'\n        result = check_rss_source(url)\n        self.assertEqual(result, url)\n    \n    def test_untrusted_ip(self):\n        # Test untrusted external IP address\n        url = 'http://142.251.32.46/rss'\n        with self.assertRaises(ValueError) as context:\n            check_rss_source(url)\n        self.assertEqual(str(context.exception), \"RSS feed provider not trusted\")\n    \n    def test_internal_domain_pattern(self):\n        # Test domain starting with internal IP pattern\n        url = 'http://10.trusted.com/rss'\n        with self.assertRaises(ValueError) as context:\n            check_rss_source(url)\n        self.assertEqual(str(context.exception), \"Access to internal network addresses is blocked\")\n    \n    def test_domain_with_internal_pattern_in_middle(self):\n        # Test trusted domain containing internal pattern (not at start)\n        with patch.object(solution, 'TRUSTED_RSS_PROVIDERS', solution.TRUSTED_RSS_PROVIDERS + ['sub.10.trusted.com']):\n            url = 'http://sub.10.trusted.com/rss'\n            result = check_rss_source(url)\n            self.assertEqual(result, url)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 14, "task_id": "2c4f4f0b"}
{"test": "import unittest\nfrom urllib.parse import urlparse\nimport re\n\n# Define constants as per the function's requirements\nALLOWED_SCHEMES = {'http', 'https'}\nTRUSTED_RSS_PROVIDERS = {\n    'www.bbc.com',\n    'rss.cnn.com',\n    'feeds.feedburner.com',\n    'www.nytimes.com',\n    'www.reuters.com',\n    '8.8.8.8',        # Public IPv4 for testing\n    '2001:db8::1',    # Public IPv6 for testing\n    '10.0.0.1',       # Internal IPv4 for testing (trusted but blocked)\n    'fe80::1'         # Internal IPv6 for testing (trusted but blocked)\n}\nINTERNAL_IP_PATTERNS = [\n    '^10\\\\.',         # Match internal IPv4 (10.0.0.0/8)\n    '^192\\\\.168\\\\.',  # Match internal IPv4 (192.168.0.0/16)\n    '^172\\\\.(1[6-9]|2[0-9]|3[0-1])\\\\.',  # Match internal IPv4 (172.16.0.0/12)\n    '^127\\\\.0\\\\.0\\\\.1$',  # Loopback IPv4\n    '^::1$',          # Loopback IPv6\n    '^fc00:',         # Match internal IPv6 (fc00::/7)\n    '^fe80:'          # Match link-local IPv6 (fe80::/10)\n]\n\ndef clean_feed_link(rss_link: str):\n    # Parse the provided feed URL\n    parsed_url = urlparse(rss_link)\n    # Ensure the URL uses an allowed scheme (http or https)\n    if parsed_url.scheme not in ALLOWED_SCHEMES:\n        raise ValueError(\"Only HTTP or HTTPS schemes are allowed\")\n    \n    # Ensure the domain belongs to a trusted RSS feed provider\n    if parsed_url.hostname not in TRUSTED_RSS_PROVIDERS:\n        raise ValueError(\"RSS feed provider not trusted\")\n    \n    # Check if the domain or IP address matches internal network patterns\n    for pattern in INTERNAL_IP_PATTERNS:\n        if re.match(pattern, parsed_url.hostname):\n            raise ValueError(\"Access to internal network addresses is blocked\")\n    \n    return parsed_url.geturl()\n\nclass TestCleanFeedLink(unittest.TestCase):\n\n    def test_valid_http_trusted_domain(self):\n        # Test valid URL with http and trusted domain\n        result = clean_feed_link('http://www.bbc.com')\n        self.assertEqual(result, 'http://www.bbc.com')\n\n    def test_valid_https_trusted_domain(self):\n        # Test valid URL with https and trusted domain\n        result = clean_feed_link('https://www.bbc.com')\n        self.assertEqual(result, 'https://www.bbc.com')\n\n    def test_valid_url_with_port(self):\n        # Test valid URL with port number\n        result = clean_feed_link('http://www.bbc.com:8080')\n        self.assertEqual(result, 'http://www.bbc.com:8080')\n\n    def test_valid_url_with_path_query(self):\n        # Test valid URL with path and query parameters\n        result = clean_feed_link('http://www.bbc.com/news?q=abc')\n        self.assertEqual(result, 'http://www.bbc.com/news?q=abc')\n\n    def test_valid_public_ipv4_trusted(self):\n        # Test valid URL with trusted public IPv4\n        result = clean_feed_link('http://8.8.8.8')\n        self.assertEqual(result, 'http://8.8.8.8')\n\n    def test_invalid_scheme_ftp(self):\n        # Test URL with invalid scheme (ftp)\n        with self.assertRaises(ValueError) as context:\n            clean_feed_link('ftp://www.bbc.com')\n        self.assertEqual(str(context.exception), \"Only HTTP or HTTPS schemes are allowed\")\n\n    def test_untrusted_host(self):\n        # Test URL with untrusted host\n        with self.assertRaises(ValueError) as context:\n            clean_feed_link('http://www.example.com')\n        self.assertEqual(str(context.exception), \"RSS feed provider not trusted\")\n\n    def test_trusted_host_internal_ipv4_blocked(self):\n        # Test trusted host that is an internal IPv4 (blocked by internal pattern)\n        with self.assertRaises(ValueError) as context:\n            clean_feed_link('http://10.0.0.1')\n        self.assertEqual(str(context.exception), \"Access to internal network addresses is blocked\")\n\n    def test_internal_ipv4_untrusted(self):\n        # Test internal IPv4 that is not trusted\n        with self.assertRaises(ValueError) as context:\n            clean_feed_link('http://192.168.1.1')\n        self.assertEqual(str(context.exception), \"RSS feed provider not trusted\")\n\n    def test_empty_string(self):\n        # Test empty string as input\n        with self.assertRaises(ValueError) as context:\n            clean_feed_link('')\n        self.assertEqual(str(context.exception), \"Only HTTP or HTTPS schemes are allowed\")\n\n    def test_none_input(self):\n        # Test None input (expected to raise AttributeError)\n        with self.assertRaises(AttributeError):\n            clean_feed_link(None)\n\n    def test_trusted_host_mixed_case(self):\n        # Test trusted host in mixed case (not in trusted set due to case sensitivity)\n        with self.assertRaises(ValueError) as context:\n            clean_feed_link('http://WWW.BBC.COM')\n        self.assertEqual(str(context.exception), \"RSS feed provider not trusted\")\n\n    def test_trusted_host_trailing_dot(self):\n        # Test trusted host with trailing dot (not in trusted set)\n        with self.assertRaises(ValueError) as context:\n            clean_feed_link('http://www.bbc.com.')\n        self.assertEqual(str(context.exception), \"RSS feed provider not trusted\")\n\n    def test_valid_public_ipv6(self):\n        # Test valid URL with trusted public IPv6\n        result = clean_feed_link('http://[2001:db8::1]')\n        self.assertEqual(result, 'http://[2001:db8::1]')\n\n    def test_trusted_host_internal_ipv6_blocked(self):\n        # Test trusted host that is an internal IPv6 (blocked by internal pattern)\n        with self.assertRaises(ValueError) as context:\n            clean_feed_link('http://[fe80::1]')\n        self.assertEqual(str(context.exception), \"Access to internal network addresses is blocked\")\n\n    def test_internal_ipv6_untrusted(self):\n        # Test internal IPv6 that is not trusted\n        with self.assertRaises(ValueError) as context:\n            clean_feed_link('http://[fc00::1]')\n        self.assertEqual(str(context.exception), \"RSS feed provider not trusted\")\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 16, "task_id": "b8be0b55"}
{"test": "import unittest\nfrom unittest.mock import patch\n\nclass TestResolveImageUrl(unittest.TestCase):\n    def test_valid_http_trusted_domain(self):\n        # Test with valid HTTP URL and trusted domain\n        with patch('image_utils.ALLOWED_SCHEMES', {'http', 'https'}), \\\n             patch('image_utils.TRUSTED_IMAGE_HOSTS', {'trusted1.com', 'trusted2.org'}):\n            url = 'http://trusted1.com/image.jpg'\n            result = resolve_image_url(url)\n            self.assertEqual(result, url)\n    \n    def test_valid_https_trusted_domain(self):\n        # Test with valid HTTPS URL and trusted domain\n        with patch('image_utils.ALLOWED_SCHEMES', {'http', 'https'}), \\\n             patch('image_utils.TRUSTED_IMAGE_HOSTS', {'trusted1.com', 'trusted2.org'}):\n            url = 'https://trusted2.org/pic.png'\n            result = resolve_image_url(url)\n            self.assertEqual(result, url)\n    \n    def test_invalid_scheme_ftp(self):\n        # Test with invalid scheme (FTP) but trusted domain\n        with patch('image_utils.ALLOWED_SCHEMES', {'http', 'https'}), \\\n             patch('image_utils.TRUSTED_IMAGE_HOSTS', {'trusted1.com', 'trusted2.org'}):\n            with self.assertRaises(ValueError):\n                resolve_image_url('ftp://trusted1.com/file.jpg')\n    \n    def test_untrusted_domain(self):\n        # Test with allowed scheme but untrusted domain\n        with patch('image_utils.ALLOWED_SCHEMES', {'http', 'https'}), \\\n             patch('image_utils.TRUSTED_IMAGE_HOSTS', {'trusted1.com', 'trusted2.org'}):\n            with self.assertRaises(ValueError):\n                resolve_image_url('http://untrusted.com/photo.png')\n    \n    def test_empty_string(self):\n        # Test with empty URL string\n        with patch('image_utils.ALLOWED_SCHEMES', {'http', 'https'}), \\\n             patch('image_utils.TRUSTED_IMAGE_HOSTS', {'trusted1.com', 'trusted2.org'}):\n            with self.assertRaises(ValueError):\n                resolve_image_url('')\n    \n    def test_none_input(self):\n        # Test with None input (invalid type)\n        with patch('image_utils.ALLOWED_SCHEMES', {'http', 'https'}), \\\n             patch('image_utils.TRUSTED_IMAGE_HOSTS', {'trusted1.com', 'trusted2.org'}):\n            with self.assertRaises(TypeError):\n                resolve_image_url(None)\n    \n    def test_non_string_input(self):\n        # Test with non-string input (integer)\n        with patch('image_utils.ALLOWED_SCHEMES', {'http', 'https'}), \\\n             patch('image_utils.TRUSTED_IMAGE_HOSTS', {'trusted1.com', 'trusted2.org'}):\n            with self.assertRaises(TypeError):\n                resolve_image_url(123)\n    \n    def test_valid_url_with_port(self):\n        # Test URL with port number and trusted domain\n        with patch('image_utils.ALLOWED_SCHEMES', {'http', 'https'}), \\\n             patch('image_utils.TRUSTED_IMAGE_HOSTS', {'trusted1.com', 'trusted2.org'}):\n            url = 'http://trusted1.com:8080/images/pic.jpg'\n            result = resolve_image_url(url)\n            self.assertEqual(result, url)\n    \n    def test_complex_url_components(self):\n        # Test URL with path, query, and fragment\n        with patch('image_utils.ALLOWED_SCHEMES', {'http', 'https'}), \\\n             patch('image_utils.TRUSTED_IMAGE_HOSTS', {'trusted1.com', 'trusted2.org'}):\n            url = 'https://trusted2.org/path/to/img?width=200&format=jpeg#main'\n            result = resolve_image_url(url)\n            self.assertEqual(result, url)\n    \n    def test_case_sensitive_domain(self):\n        # Test trusted domain with case mismatch\n        with patch('image_utils.ALLOWED_SCHEMES', {'http', 'https'}), \\\n             patch('image_utils.TRUSTED_IMAGE_HOSTS', {'trusted1.com', 'trusted2.org'}):\n            with self.assertRaises(ValueError):\n                resolve_image_url('http://TRUSTED1.COM/image.png')\n    \n    def test_invalid_url_format(self):\n        # Test invalid URL string format\n        with patch('image_utils.ALLOWED_SCHEMES', {'http', 'https'}), \\\n             patch('image_utils.TRUSTED_IMAGE_HOSTS', {'trusted1.com', 'trusted2.org'}):\n            with self.assertRaises(ValueError):\n                resolve_image_url('not a valid url')\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 11, "task_id": "bf4e9bf5"}
{"test": "import unittest\nfrom urllib.parse import urlparse\nfrom unittest.mock import patch\n\n# Define the global variables for the test environment\nAPPROVED_API_DOMAINS = ['api.example.com', 'webhook.service.com']\nINTERNAL_IP_RANGES = ['10.', '192.168.', '172.16.', '172.17.', '172.18.', '172.19.', '172.20.', '172.21.', '172.22.', '172.23.', '172.24.', '172.25.', '172.26.', '172.27.', '172.28.', '172.29.', '172.30.', '172.31.', '127.0.0.']\n\n# Define the function as per the provided code snippet\ndef process_webhook(webhook_url: str):\n    parsed_url = urlparse(webhook_url)\n    if parsed_url.hostname not in APPROVED_API_DOMAINS:\n        raise ValueError(\"Webhook URL not from an approved API domain\")\n    if parsed_url.hostname == \"localhost\" or any(parsed_url.hostname.startswith(ip) for ip in INTERNAL_IP_RANGES):\n        raise ValueError(\"Access to internal addresses is blocked\")\n    return parsed_url.geturl()\n\nclass TestProcessWebhook(unittest.TestCase):\n\n    def test_case_1(self):\n        # Happy path: valid approved domain (api.example.com)\n        url = \"https://api.example.com/api\"\n        self.assertEqual(process_webhook(url), url)\n\n    def test_case_2(self):\n        # Happy path: valid approved domain (webhook.service.com)\n        url = \"https://webhook.service.com/webhook\"\n        self.assertEqual(process_webhook(url), url)\n\n    def test_case_3(self):\n        # Domain not in approved list\n        url = \"https://unapproved.com\"\n        with self.assertRaises(ValueError) as context:\n            process_webhook(url)\n        self.assertEqual(str(context.exception), \"Webhook URL not from an approved API domain\")\n\n    def test_case_4(self):\n        # Empty string input\n        with self.assertRaises(ValueError) as context:\n            process_webhook(\"\")\n        self.assertEqual(str(context.exception), \"Webhook URL not from an approved API domain\")\n\n    def test_case_5(self):\n        # None input (invalid type)\n        with self.assertRaises(TypeError):\n            process_webhook(None)\n\n    def test_case_6(self):\n        # Integer input (invalid type)\n        with self.assertRaises(TypeError):\n            process_webhook(123)\n\n    def test_case_7(self):\n        # Mixed case domain (not in approved list)\n        url = \"https://API.example.com\"\n        with self.assertRaises(ValueError) as context:\n            process_webhook(url)\n        self.assertEqual(str(context.exception), \"Webhook URL not from an approved API domain\")\n\n    def test_case_8(self):\n        # Very long URL with approved domain\n        long_path = '/'.join(['path'] * 1000)\n        url = f\"https://api.example.com/{long_path}\"\n        self.assertEqual(process_webhook(url), url)\n\n    def test_case_9(self):\n        # Approved domain with internal IP in path (should pass)\n        url = \"https://api.example.com/10.0.0.1\"\n        self.assertEqual(process_webhook(url), url)\n\n    def test_case_10(self):\n        # Localhost (not approved)\n        with self.assertRaises(ValueError) as context:\n            process_webhook(\"http://localhost\")\n        self.assertEqual(str(context.exception), \"Webhook URL not from an approved API domain\")\n\n    def test_case_11(self):\n        # Internal IP (10.0.0.1) not approved\n        with self.assertRaises(ValueError) as context:\n            process_webhook(\"http://10.0.0.1\")\n        self.assertEqual(str(context.exception), \"Webhook URL not from an approved API domain\")\n\n    def test_case_12(self):\n        # Internal IP (192.168.1.1) not approved\n        with self.assertRaises(ValueError) as context:\n            process_webhook(\"http://192.168.1.1\")\n        self.assertEqual(str(context.exception), \"Webhook URL not from an approved API domain\")\n\n    def test_case_13(self):\n        # Internal IP (127.0.0.1) not approved\n        with self.assertRaises(ValueError) as context:\n            process_webhook(\"http://127.0.0.1\")\n        self.assertEqual(str(context.exception), \"Webhook URL not from an approved API domain\")\n\n    def test_case_14(self):\n        # Approved domain 'localhost' blocked by internal check\n        with patch('__main__.APPROVED_API_DOMAINS', ['localhost']):\n            with self.assertRaises(ValueError) as context:\n                process_webhook(\"http://localhost\")\n            self.assertEqual(str(context.exception), \"Access to internal addresses is blocked\")\n\n    def test_case_15(self):\n        # Approved domain starting with '10.' blocked by internal check\n        with patch('__main__.APPROVED_API_DOMAINS', ['10.approved.com']):\n            with self.assertRaises(ValueError) as context:\n                process_webhook(\"http://10.approved.com\")\n            self.assertEqual(str(context.exception), \"Access to internal addresses is blocked\")\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 15, "task_id": "9c352ad2"}
{"test": "import unittest\nimport solution\n\n# Setting global variables for the solution module\nsolution.ALLOWED_API_DOMAINS = {'api.example.com', 'trusted-api.org', '8.8.8.8', '10.0.0.1'}\nsolution.INTERNAL_IP_PATTERNS = [\n    r'^10\\.',\n    r'^192\\.168\\.',\n    r'^172\\.(1[6-9]|2[0-9]|3[0-1])\\.',\n    r'^127\\.0\\.0\\.1',\n    r'^localhost$'\n]\n\nfrom solution import validate_api_endpoint\n\nclass TestValidateAPIEndpoint(unittest.TestCase):\n\n    def test_basic_allowed_domain(self):\n        # Test a basic allowed domain without any path or parameters\n        url = 'https://api.example.com'\n        self.assertEqual(validate_api_endpoint(url), url)\n\n    def test_allowed_domain_with_path_query(self):\n        # Test an allowed domain with path and query parameters\n        url = 'https://trusted-api.org/v1/users?query=test'\n        self.assertEqual(validate_api_endpoint(url), url)\n\n    def test_allowed_public_ip_address(self):\n        # Test a public IP address that is in the allowed domains\n        url = 'http://8.8.8.8'\n        self.assertEqual(validate_api_endpoint(url), url)\n\n    def test_untrusted_domain(self):\n        # Test a domain not in the allowed list\n        url = 'https://untrusted.com'\n        with self.assertRaises(ValueError):\n            validate_api_endpoint(url)\n\n    def test_internal_ip_10_block(self):\n        # Test an internal IP in the 10.0.0.0/8 range\n        url = 'http://10.0.0.1'\n        with self.assertRaises(ValueError):\n            validate_api_endpoint(url)\n\n    def test_localhost_blocked(self):\n        # Test that localhost is blocked\n        url = 'http://localhost'\n        with self.assertRaises(ValueError):\n            validate_api_endpoint(url)\n\n    def test_internal_ip_172_block(self):\n        # Test an internal IP in the 172.16.0.0/12 range\n        url = 'http://172.16.0.1'\n        with self.assertRaises(ValueError):\n            validate_api_endpoint(url)\n\n    def test_internal_ip_192_block(self):\n        # Test an internal IP in the 192.168.0.0/16 range\n        url = 'http://192.168.1.1'\n        with self.assertRaises(ValueError):\n            validate_api_endpoint(url)\n\n    def test_allowed_domain_but_internal_ip(self):\n        # Test a URL that is in allowed domains but is an internal IP (should still be blocked)\n        url = 'http://10.0.0.1'\n        with self.assertRaises(ValueError):\n            validate_api_endpoint(url)\n\n    def test_empty_url(self):\n        # Test an empty URL string\n        url = ''\n        with self.assertRaises(ValueError):\n            validate_api_endpoint(url)\n\n    def test_none_url(self):\n        # Test None input (invalid type)\n        url = None\n        with self.assertRaises(TypeError):\n            validate_api_endpoint(url)\n\n    def test_url_with_user_password(self):\n        # Test a URL with user:password in an allowed domain\n        url = 'https://user:pass@api.example.com'\n        self.assertEqual(validate_api_endpoint(url), url)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 12, "task_id": "ece9c209"}
{"test": "import unittest\nfrom unittest.mock import patch\nimport re\n\nclass TestSanitizeFeedUrl(unittest.TestCase):\n\n    def test_valid_http_trusted_domain(self):\n        # Test HTTP URL with trusted domain\n        with patch('rss_utils.ALLOWED_SCHEMES', {'http', 'https'}), \\\n             patch('rss_utils.TRUSTED_RSS_PROVIDERS', {'trusted.com'}), \\\n             patch('rss_utils.INTERNAL_IP_PATTERNS', [r'^10\\.', r'^192\\.168\\.', r'^172\\.(1[6-9]|2[0-9]|3[0-1])\\.', r'^127\\.', r'^localhost$']):\n            from rss_utils import sanitize_feed_url\n            url = 'http://trusted.com/feed'\n            self.assertEqual(sanitize_feed_url(url), url)\n\n    def test_valid_https_trusted_domain(self):\n        # Test HTTPS URL with trusted domain\n        with patch('rss_utils.ALLOWED_SCHEMES', {'http', 'https'}), \\\n             patch('rss_utils.TRUSTED_RSS_PROVIDERS', {'example.org'}), \\\n             patch('rss_utils.INTERNAL_IP_PATTERNS', [r'^10\\.', r'^192\\.168\\.', r'^172\\.(1[6-9]|2[0-9]|3[0-1])\\.', r'^127\\.', r'^localhost$']):\n            from rss_utils import sanitize_feed_url\n            url = 'https://example.org/rss'\n            self.assertEqual(sanitize_feed_url(url), url)\n\n    def test_valid_http_with_port(self):\n        # Test HTTP URL with port number and trusted domain\n        with patch('rss_utils.ALLOWED_SCHEMES', {'http', 'https'}), \\\n             patch('rss_utils.TRUSTED_RSS_PROVIDERS', {'trusted.com'}), \\\n             patch('rss_utils.INTERNAL_IP_PATTERNS', [r'^10\\.', r'^192\\.168\\.', r'^172\\.(1[6-9]|2[0-9]|3[0-1])\\.', r'^127\\.', r'^localhost$']):\n            from rss_utils import sanitize_feed_url\n            url = 'http://trusted.com:8080/feed'\n            self.assertEqual(sanitize_feed_url(url), url)\n\n    def test_valid_https_with_query(self):\n        # Test HTTPS URL with query parameters and trusted domain\n        with patch('rss_utils.ALLOWED_SCHEMES', {'http', 'https'}), \\\n             patch('rss_utils.TRUSTED_RSS_PROVIDERS', {'example.org'}), \\\n             patch('rss_utils.INTERNAL_IP_PATTERNS', [r'^10\\.', r'^192\\.168\\.', r'^172\\.(1[6-9]|2[0-9]|3[0-1])\\.', r'^127\\.', r'^localhost$']):\n            from rss_utils import sanitize_feed_url\n            url = 'https://example.org/rss?param=value'\n            self.assertEqual(sanitize_feed_url(url), url)\n\n    def test_invalid_scheme_ftp(self):\n        # Test URL with invalid FTP scheme\n        with patch('rss_utils.ALLOWED_SCHEMES', {'http', 'https'}), \\\n             patch('rss_utils.TRUSTED_RSS_PROVIDERS', {'trusted.com'}), \\\n             patch('rss_utils.INTERNAL_IP_PATTERNS', [r'^10\\.', r'^192\\.168\\.', r'^172\\.(1[6-9]|2[0-9]|3[0-1])\\.', r'^127\\.', r'^localhost$']):\n            from rss_utils import sanitize_feed_url\n            with self.assertRaises(ValueError, msg=\"Only HTTP or HTTPS schemes are allowed\"):\n                sanitize_feed_url('ftp://trusted.com/feed')\n\n    def test_invalid_scheme_mailto(self):\n        # Test URL with invalid mailto scheme\n        with patch('rss_utils.ALLOWED_SCHEMES', {'http', 'https'}), \\\n             patch('rss_utils.TRUSTED_RSS_PROVIDERS', {'trusted.com'}), \\\n             patch('rss_utils.INTERNAL_IP_PATTERNS', [r'^10\\.', r'^192\\.168\\.', r'^172\\.(1[6-9]|2[0-9]|3[0-1])\\.', r'^127\\.', r'^localhost$']):\n            from rss_utils import sanitize_feed_url\n            with self.assertRaises(ValueError, msg=\"Only HTTP or HTTPS schemes are allowed\"):\n                sanitize_feed_url('mailto:test@trusted.com')\n\n    def test_untrusted_domain(self):\n        # Test URL with untrusted domain\n        with patch('rss_utils.ALLOWED_SCHEMES', {'http', 'https'}), \\\n             patch('rss_utils.TRUSTED_RSS_PROVIDERS', {'trusted.com'}), \\\n             patch('rss_utils.INTERNAL_IP_PATTERNS', [r'^10\\.', r'^192\\.168\\.', r'^172\\.(1[6-9]|2[0-9]|3[0-1])\\.', r'^127\\.', r'^localhost$']):\n            from rss_utils import sanitize_feed_url\n            with self.assertRaises(ValueError, msg=\"RSS feed provider not trusted\"):\n                sanitize_feed_url('http://untrusted.com/feed')\n\n    def test_internal_ip_10(self):\n        # Test URL with internal IP address (10.0.0.1)\n        with patch('rss_utils.ALLOWED_SCHEMES', {'http', 'https'}), \\\n             patch('rss_utils.TRUSTED_RSS_PROVIDERS', {'trusted.com'}), \\\n             patch('rss_utils.INTERNAL_IP_PATTERNS', [r'^10\\.', r'^192\\.168\\.', r'^172\\.(1[6-9]|2[0-9]|3[0-1])\\.', r'^127\\.', r'^localhost$']):\n            from rss_utils import sanitize_feed_url\n            with self.assertRaises(ValueError, msg=\"Access to internal network addresses is blocked\"):\n                sanitize_feed_url('http://10.0.0.1/feed')\n\n    def test_internal_ip_192(self):\n        # Test URL with internal IP address (192.168.1.1)\n        with patch('rss_utils.ALLOWED_SCHEMES', {'http', 'https'}), \\\n             patch('rss_utils.TRUSTED_RSS_PROVIDERS', {'trusted.com'}), \\\n             patch('rss_utils.INTERNAL_IP_PATTERNS', [r'^10\\.', r'^192\\.168\\.', r'^172\\.(1[6-9]|2[0-9]|3[0-1])\\.', r'^127\\.', r'^localhost$']):\n            from rss_utils import sanitize_feed_url\n            with self.assertRaises(ValueError, msg=\"Access to internal network addresses is blocked\"):\n                sanitize_feed_url('http://192.168.1.1/feed')\n\n    def test_internal_ip_172(self):\n        # Test URL with internal IP address (172.16.0.1)\n        with patch('rss_utils.ALLOWED_SCHEMES', {'http', 'https'}), \\\n             patch('rss_utils.TRUSTED_RSS_PROVIDERS', {'trusted.com'}), \\\n             patch('rss_utils.INTERNAL_IP_PATTERNS', [r'^10\\.', r'^192\\.168\\.', r'^172\\.(1[6-9]|2[0-9]|3[0-1])\\.', r'^127\\.', r'^localhost$']):\n            from rss_utils import sanitize_feed_url\n            with self.assertRaises(ValueError, msg=\"Access to internal network addresses is blocked\"):\n                sanitize_feed_url('http://172.16.0.1/feed')\n\n    def test_internal_ip_127(self):\n        # Test URL with internal IP address (127.0.0.1)\n        with patch('rss_utils.ALLOWED_SCHEMES', {'http', 'https'}), \\\n             patch('rss_utils.TRUSTED_RSS_PROVIDERS', {'trusted.com'}), \\\n             patch('rss_utils.INTERNAL_IP_PATTERNS', [r'^10\\.', r'^192\\.168\\.', r'^172\\.(1[6-9]|2[0-9]|3[0-1])\\.', r'^127\\.', r'^localhost$']):\n            from rss_utils import sanitize_feed_url\n            with self.assertRaises(ValueError, msg=\"Access to internal network addresses is blocked\"):\n                sanitize_feed_url('http://127.0.0.1/feed')\n\n    def test_localhost(self):\n        # Test URL with localhost\n        with patch('rss_utils.ALLOWED_SCHEMES', {'http', 'https'}), \\\n             patch('rss_utils.TRUSTED_RSS_PROVIDERS', {'trusted.com'}), \\\n             patch('rss_utils.INTERNAL_IP_PATTERNS', [r'^10\\.', r'^192\\.168\\.', r'^172\\.(1[6-9]|2[0-9]|3[0-1])\\.', r'^127\\.', r'^localhost$']):\n            from rss_utils import sanitize_feed_url\n            with self.assertRaises(ValueError, msg=\"Access to internal network addresses is blocked\"):\n                sanitize_feed_url('http://localhost/feed')\n\n    def test_empty_string(self):\n        # Test empty URL string\n        with patch('rss_utils.ALLOWED_SCHEMES', {'http', 'https'}), \\\n             patch('rss_utils.TRUSTED_RSS_PROVIDERS', {'trusted.com'}), \\\n             patch('rss_utils.INTERNAL_IP_PATTERNS', [r'^10\\.', r'^192\\.168\\.', r'^172\\.(1[6-9]|2[0-9]|3[0-1])\\.', r'^127\\.', r'^localhost$']):\n            from rss_utils import sanitize_feed_url\n            with self.assertRaises(ValueError, msg=\"Only HTTP or HTTPS schemes are allowed\"):\n                sanitize_feed_url('')\n\n    def test_none_input(self):\n        # Test None input\n        with patch('rss_utils.ALLOWED_SCHEMES', {'http', 'https'}), \\\n             patch('rss_utils.TRUSTED_RSS_PROVIDERS', {'trusted.com'}), \\\n             patch('rss_utils.INTERNAL_IP_PATTERNS', [r'^10\\.', r'^192\\.168\\.', r'^172\\.(1[6-9]|2[0-9]|3[0-1])\\.', r'^127\\.', r'^localhost$']):\n            from rss_utils import sanitize_feed_url\n            with self.assertRaises(TypeError):\n                sanitize_feed_url(None)\n\n    def test_non_string_input(self):\n        # Test non-string input (integer)\n        with patch('rss_utils.ALLOWED_SCHEMES', {'http', 'https'}), \\\n             patch('rss_utils.TRUSTED_RSS_PROVIDERS', {'trusted.com'}), \\\n             patch('rss_utils.INTERNAL_IP_PATTERNS', [r'^10\\.', r'^192\\.168\\.', r'^172\\.(1[6-9]|2[0-9]|3[0-1])\\.', r'^127\\.', r'^localhost$']):\n            from rss_utils import sanitize_feed_url\n            with self.assertRaises(TypeError):\n                sanitize_feed_url(123)\n\n    def test_trusted_domain_matching_internal_pattern(self):\n        # Test trusted domain that matches internal IP pattern (10.trusted.com)\n        with patch('rss_utils.ALLOWED_SCHEMES', {'http', 'https'}), \\\n             patch('rss_utils.TRUSTED_RSS_PROVIDERS', {'10.trusted.com'}), \\\n             patch('rss_utils.INTERNAL_IP_PATTERNS', [r'^10\\.', r'^192\\.168\\.', r'^172\\.(1[6-9]|2[0-9]|3[0-1])\\.', r'^127\\.', r'^localhost$']):\n            from rss_utils import sanitize_feed_url\n            with self.assertRaises(ValueError, msg=\"Access to internal network addresses is blocked\"):\n                sanitize_feed_url('http://10.trusted.com/feed')\n\n    def test_trusted_internal_ip_blocked(self):\n        # Test trusted internal IP (10.0.0.1) blocked by pattern\n        with patch('rss_utils.ALLOWED_SCHEMES', {'http', 'https'}), \\\n             patch('rss_utils.TRUSTED_RSS_PROVIDERS', {'10.0.0.1'}), \\\n             patch('rss_utils.INTERNAL_IP_PATTERNS', [r'^10\\.', r'^192\\.168\\.', r'^172\\.(1[6-9]|2[0-9]|3[0-1])\\.', r'^127\\.', r'^localhost$']):\n            from rss_utils import sanitize_feed_url\n            with self.assertRaises(ValueError, msg=\"Access to internal network addresses is blocked\"):\n                sanitize_feed_url('http://10.0.0.1/feed')\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 17, "task_id": "dd13dcec"}
{"test": "import unittest\nfrom urllib.parse import urlparse\n\n# Predefined allowed schemes and domains\nALLOWED_SCHEMES = {'http', 'https'}\nALLOWED_DOMAINS = {'example.com', 'safe.org'}\n\ndef parse_url(url: str):\n    \"\"\"Parse and validate the URL.\"\"\"\n    parsed_url = urlparse(url)\n    if parsed_url.scheme not in ALLOWED_SCHEMES or parsed_url.hostname not in ALLOWED_DOMAINS:\n        raise ValueError(\"URL scheme or domain not allowed\")\n    return parsed_url\n\nclass TestParseUrl(unittest.TestCase):\n    \n    def test_valid_http_example_com(self):\n        # Test valid URL with http and example.com\n        url = \"http://example.com\"\n        parsed = parse_url(url)\n        self.assertEqual(parsed.scheme, \"http\")\n        self.assertEqual(parsed.hostname, \"example.com\")\n    \n    def test_valid_https_safe_org(self):\n        # Test valid URL with https and safe.org including path and query\n        url = \"https://safe.org/path?query=param\"\n        parsed = parse_url(url)\n        self.assertEqual(parsed.scheme, \"https\")\n        self.assertEqual(parsed.hostname, \"safe.org\")\n    \n    def test_invalid_scheme_ftp(self):\n        # Test URL with disallowed scheme (ftp)\n        url = \"ftp://example.com\"\n        with self.assertRaises(ValueError):\n            parse_url(url)\n    \n    def test_invalid_domain(self):\n        # Test URL with disallowed domain (evil.com)\n        url = \"http://evil.com\"\n        with self.assertRaises(ValueError):\n            parse_url(url)\n    \n    def test_empty_string(self):\n        # Test empty URL string\n        url = \"\"\n        with self.assertRaises(ValueError):\n            parse_url(url)\n    \n    def test_none_input(self):\n        # Test None input\n        url = None\n        with self.assertRaises(TypeError):\n            parse_url(url)\n    \n    def test_non_string_input(self):\n        # Test non-string input (integer)\n        url = 123\n        with self.assertRaises(TypeError):\n            parse_url(url)\n    \n    def test_missing_scheme(self):\n        # Test URL without a scheme\n        url = \"example.com\"\n        with self.assertRaises(ValueError):\n            parse_url(url)\n    \n    def test_valid_with_port(self):\n        # Test valid URL with port number\n        url = \"http://example.com:8080\"\n        parsed = parse_url(url)\n        self.assertEqual(parsed.scheme, \"http\")\n        self.assertEqual(parsed.hostname, \"example.com\")\n        self.assertEqual(parsed.port, 8080)\n    \n    def test_valid_with_user_password(self):\n        # Test valid URL with user and password\n        url = \"http://user:pass@example.com\"\n        parsed = parse_url(url)\n        self.assertEqual(parsed.scheme, \"http\")\n        self.assertEqual(parsed.hostname, \"example.com\")\n        self.assertEqual(parsed.username, \"user\")\n        self.assertEqual(parsed.password, \"pass\")\n    \n    def test_invalid_subdomain(self):\n        # Test URL with disallowed subdomain (www.example.com)\n        url = \"http://www.example.com\"\n        with self.assertRaises(ValueError):\n            parse_url(url)\n    \n    def test_invalid_domain_substring(self):\n        # Test URL where domain contains allowed domain as substring (safe.org.evil.com)\n        url = \"http://safe.org.evil.com\"\n        with self.assertRaises(ValueError):\n            parse_url(url)\n", "num_test_cases": 12, "task_id": "9a4d6c63"}
{"test": "import unittest\n\nclass TestGetEmailDomain(unittest.TestCase):\n    \n    def test_valid_standard_email(self):\n        # Test standard valid email\n        email = 'user@example.com'\n        self.assertEqual(get_email_domain(email), 'example.com')\n    \n    def test_valid_subdomain_email(self):\n        # Test email with subdomain\n        email = 'user@sub.example.com'\n        self.assertEqual(get_email_domain(email), 'sub.example.com')\n    \n    def test_valid_email_with_numbers(self):\n        # Test email with numbers in domain\n        email = 'user123@example123.com'\n        self.assertEqual(get_email_domain(email), 'example123.com')\n    \n    def test_valid_email_special_chars_domain(self):\n        # Test domain with special characters (hyphens)\n        email = 'user@ex-ample.com'\n        self.assertEqual(get_email_domain(email), 'ex-ample.com')\n    \n    def test_valid_international_domain(self):\n        # Test internationalized domain name\n        email = 'user@例子.测试'\n        self.assertEqual(get_email_domain(email), '例子.测试')\n    \n    def test_valid_email_plus_local(self):\n        # Test email with '+' in local part\n        email = 'user+name@domain.com'\n        self.assertEqual(get_email_domain(email), 'domain.com')\n    \n    def test_long_valid_email(self):\n        # Test very long valid email\n        local_part = 'a' * 10000\n        domain_part = 'b' * 10000\n        email = f'{local_part}@{domain_part}'\n        self.assertEqual(get_email_domain(email), domain_part)\n    \n    def test_invalid_empty_string(self):\n        # Test empty string input\n        self.assertIsNone(get_email_domain(''))\n    \n    def test_invalid_no_at_symbol(self):\n        # Test email missing '@' symbol\n        self.assertIsNone(get_email_domain('user.domain.com'))\n    \n    def test_invalid_two_at_symbols(self):\n        # Test email with multiple '@' symbols\n        self.assertIsNone(get_email_domain('user@domain@example.com'))\n    \n    def test_invalid_only_at_symbol(self):\n        # Test input with only '@'\n        self.assertIsNone(get_email_domain('@'))\n    \n    def test_invalid_starts_with_at(self):\n        # Test input starting with '@'\n        self.assertIsNone(get_email_domain('@domain.com'))\n    \n    def test_invalid_ends_with_at(self):\n        # Test input ending with '@'\n        self.assertIsNone(get_email_domain('user@'))\n    \n    def test_invalid_only_spaces(self):\n        # Test input with only whitespace\n        self.assertIsNone(get_email_domain('   '))\n    \n    def test_invalid_double_at(self):\n        # Test input with double '@' and no other characters\n        self.assertIsNone(get_email_domain('@@'))\n    \n    def test_long_invalid_email(self):\n        # Test very long invalid email (no '@')\n        long_string = 'a' * 20000\n        self.assertIsNone(get_email_domain(long_string))\n    \n    def test_invalid_trailing_newline(self):\n        # Test email with trailing newline character\n        email = 'user@domain.com\\n'\n        self.assertIsNone(get_email_domain(email))\n    \n    def test_invalid_domain_with_at(self):\n        # Test domain containing '@' symbol\n        self.assertIsNone(get_email_domain('user@domain@part.com'))\n    \n    def test_valid_single_char_domain(self):\n        # Test valid email with single-character domain\n        email = 'user@a.com'\n        self.assertEqual(get_email_domain(email), 'a.com')", "num_test_cases": 19, "task_id": "8b4675f7"}
{"test": "import unittest\n\nclass TestFetchEmailDomain(unittest.TestCase):\n\n    def test_valid_basic(self):\n        # Test a basic valid email address\n        self.assertEqual(fetch_email_domain('test@example.com'), 'example.com')\n\n    def test_valid_subdomain(self):\n        # Test email with subdomain\n        self.assertEqual(fetch_email_domain('user@sub.example.com'), 'sub.example.com')\n\n    def test_valid_numbers_in_local(self):\n        # Test email with numbers and special chars in local part\n        self.assertEqual(fetch_email_domain('user123.!#$%&\\'*+-/=?^_`{|}~@domain.com'), 'domain.com')\n\n    def test_valid_dash_in_domain(self):\n        # Test email with dash in domain\n        self.assertEqual(fetch_email_domain('test@my-domain.com'), 'my-domain.com')\n\n    def test_valid_multiple_tlds(self):\n        # Test email with multiple TLDs\n        self.assertEqual(fetch_email_domain('user@example.co.uk'), 'example.co.uk')\n\n    def test_valid_leading_space_in_local(self):\n        # Test email with leading space in local part\n        self.assertEqual(fetch_email_domain('  user@example.com'), 'example.com')\n\n    def test_valid_trailing_space_in_domain(self):\n        # Test email with trailing space in domain\n        self.assertEqual(fetch_email_domain('test@example.com  '), 'example.com  ')\n\n    def test_valid_domain_starts_with_dot(self):\n        # Test email with domain starting with dot\n        self.assertEqual(fetch_email_domain('test@.example.com'), '.example.com')\n\n    def test_valid_domain_ends_with_dot(self):\n        # Test email with domain ending with dot\n        self.assertEqual(fetch_email_domain('test@example.com.'), 'example.com.')\n\n    def test_valid_domain_with_space(self):\n        # Test email with space in domain\n        self.assertEqual(fetch_email_domain('test@exa mple.com'), 'exa mple.com')\n\n    def test_valid_domain_with_newline(self):\n        # Test email with newline in domain\n        self.assertEqual(fetch_email_domain('test@exa\\nmple.com'), 'exa\\nmple.com')\n\n    def test_valid_non_ascii_domain(self):\n        # Test email with non-ASCII domain\n        self.assertEqual(fetch_email_domain('test@exämple.com'), 'exämple.com')\n\n    def test_valid_non_ascii_local(self):\n        # Test email with non-ASCII local part\n        self.assertEqual(fetch_email_domain('täst@example.com'), 'example.com')\n\n    def test_invalid_no_at(self):\n        # Test email without '@' symbol\n        self.assertIsNone(fetch_email_domain('invalidemail.com'))\n\n    def test_invalid_two_ats(self):\n        # Test email with two '@' symbols\n        self.assertIsNone(fetch_email_domain('user@invalid@example.com'))\n\n    def test_invalid_only_at(self):\n        # Test email containing only '@'\n        self.assertIsNone(fetch_email_domain('@'))\n\n    def test_invalid_empty_string(self):\n        # Test empty email string\n        self.assertIsNone(fetch_email_domain(''))\n\n    def test_invalid_missing_local(self):\n        # Test email missing local part\n        self.assertIsNone(fetch_email_domain('@example.com'))\n\n    def test_invalid_missing_domain(self):\n        # Test email missing domain part\n        self.assertIsNone(fetch_email_domain('test@'))\n\n    def test_long_valid_email(self):\n        # Test very long valid email\n        long_local = 'a' * 1000\n        long_domain = 'b' * 1000\n        email = f'{long_local}@{long_domain}'\n        self.assertEqual(fetch_email_domain(email), long_domain)\n\n    def test_long_invalid_email(self):\n        # Test very long string without '@'\n        long_string = 'a' * 10000\n        self.assertIsNone(fetch_email_domain(long_string))\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 21, "task_id": "f37ce0b1"}
{"test": "import unittest\n\nclass TestCases(unittest.TestCase):\n    def test_case_1(self):\n        # Test valid email with standard domain\n        email = 'user@example.com'\n        expected = 'example.com'\n        result = retrieve_email_domain(email)\n        self.assertEqual(result, expected)\n\n    def test_case_2(self):\n        # Test valid email with subdomains\n        email = 'name@mail.sub.example.org'\n        expected = 'mail.sub.example.org'\n        result = retrieve_email_domain(email)\n        self.assertEqual(result, expected)\n\n    def test_case_3(self):\n        # Test valid email with numbers in domain\n        email = 'test123@domain456.net'\n        expected = 'domain456.net'\n        result = retrieve_email_domain(email)\n        self.assertEqual(result, expected)\n\n    def test_case_4(self):\n        # Test valid email with special characters in local part\n        email = 'user.name+tag@domain.com'\n        expected = 'domain.com'\n        result = retrieve_email_domain(email)\n        self.assertEqual(result, expected)\n\n    def test_case_5(self):\n        # Test valid email with dash in domain\n        email = 'contact@ex-ample.co.uk'\n        expected = 'ex-ample.co.uk'\n        result = retrieve_email_domain(email)\n        self.assertEqual(result, expected)\n\n    def test_case_6(self):\n        # Test valid email with space in domain (regex allows)\n        email = 'user@ex ample.org'\n        expected = 'ex ample.org'\n        result = retrieve_email_domain(email)\n        self.assertEqual(result, expected)\n\n    def test_case_7(self):\n        # Test valid email with long domain\n        domain = 'b' * 1000\n        email = f'a@{domain}'\n        result = retrieve_email_domain(email)\n        self.assertEqual(result, domain)\n\n    def test_case_8(self):\n        # Test invalid email: missing '@'\n        email = 'invalidemail.com'\n        result = retrieve_email_domain(email)\n        self.assertIsNone(result)\n\n    def test_case_9(self):\n        # Test invalid email: multiple '@' symbols\n        email = 'user@name@domain.com'\n        result = retrieve_email_domain(email)\n        self.assertIsNone(result)\n\n    def test_case_10(self):\n        # Test invalid email: starts with '@'\n        email = '@domain.com'\n        result = retrieve_email_domain(email)\n        self.assertIsNone(result)\n\n    def test_case_11(self):\n        # Test invalid email: ends with '@'\n        email = 'user@'\n        result = retrieve_email_domain(email)\n        self.assertIsNone(result)\n\n    def test_case_12(self):\n        # Test invalid email: empty string\n        email = ''\n        result = retrieve_email_domain(email)\n        self.assertIsNone(result)\n\n    def test_case_13(self):\n        # Test invalid email: only '@' symbol\n        email = '@'\n        result = retrieve_email_domain(email)\n        self.assertIsNone(result)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 13, "task_id": "d99cc9e1"}
{"test": "import unittest\n\nclass TestGetEmailDomain(unittest.TestCase):\n    \n    def test_valid_standard_email(self):\n        # Test standard email format\n        self.assertEqual(get_email_domain('user@example.com'), 'example.com')\n    \n    def test_valid_subdomain_email(self):\n        # Test email with subdomains\n        self.assertEqual(get_email_domain('user@mail.sub.example.co.uk'), 'mail.sub.example.co.uk')\n    \n    def test_valid_minimal_email(self):\n        # Test minimal valid email\n        self.assertEqual(get_email_domain('a@b'), 'b')\n    \n    def test_valid_underscore_domain(self):\n        # Test domain with underscore\n        self.assertEqual(get_email_domain('user@ex_ample.com'), 'ex_ample.com')\n    \n    def test_valid_hyphen_domain(self):\n        # Test domain with hyphens\n        self.assertEqual(get_email_domain('user@ex-am.ple.com'), 'ex-am.ple.com')\n    \n    def test_valid_space_in_local(self):\n        # Test space in local part\n        self.assertEqual(get_email_domain('user name@example.com'), 'example.com')\n    \n    def test_valid_space_in_domain(self):\n        # Test space in domain part\n        self.assertEqual(get_email_domain('user@ex ample.com'), 'ex ample.com')\n    \n    def test_valid_non_ascii(self):\n        # Test non-ASCII characters\n        self.assertEqual(get_email_domain('üser@müller.de'), 'müller.de')\n    \n    def test_invalid_empty_string(self):\n        # Test empty string\n        self.assertIsNone(get_email_domain(''))\n    \n    def test_invalid_no_at_symbol(self):\n        # Test email without '@'\n        self.assertIsNone(get_email_domain('invalid.email.com'))\n    \n    def test_invalid_multiple_at_symbols(self):\n        # Test multiple '@' symbols\n        self.assertIsNone(get_email_domain('invalid@email@domain.com'))\n    \n    def test_invalid_missing_local(self):\n        # Test missing local part\n        self.assertIsNone(get_email_domain('@domain.com'))\n    \n    def test_invalid_missing_domain(self):\n        # Test missing domain part\n        self.assertIsNone(get_email_domain('user@'))\n    \n    def test_invalid_only_at_symbol(self):\n        # Test only '@' symbol\n        self.assertIsNone(get_email_domain('@'))\n    \n    def test_invalid_whitespace_around(self):\n        # Test whitespace around email\n        self.assertIsNone(get_email_domain(' user@example.com '))\n    \nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 15, "task_id": "89e39d3e"}
{"test": "import unittest\n\nclass TestCases(unittest.TestCase):\n    def test_valid_standard_email(self):\n        # Valid email with standard format\n        result = fetch_email_domain(\"user@example.com\")\n        self.assertEqual(result, \"example.com\")\n\n    def test_valid_subdomain_email(self):\n        # Valid email with subdomain\n        result = fetch_email_domain(\"user@mail.example.com\")\n        self.assertEqual(result, \"mail.example.com\")\n\n    def test_valid_special_chars_local(self):\n        # Valid email with special characters in local part\n        result = fetch_email_domain(\"user123!-+@special.domain\")\n        self.assertEqual(result, \"special.domain\")\n\n    def test_valid_space_in_local(self):\n        # Valid email with space in local part\n        result = fetch_email_domain(\"first last@space.com\")\n        self.assertEqual(result, \"space.com\")\n\n    def test_valid_leading_space(self):\n        # Valid email with leading space\n        result = fetch_email_domain(\"  user@example.com\")\n        self.assertEqual(result, \"example.com\")\n\n    def test_valid_trailing_space(self):\n        # Valid email with trailing space (domain includes space)\n        result = fetch_email_domain(\"user@example.com  \")\n        self.assertEqual(result, \"example.com  \")\n\n    def test_valid_dot_ending_domain(self):\n        # Valid email with domain ending in dot\n        result = fetch_email_domain(\"user@example.\")\n        self.assertEqual(result, \"example.\")\n\n    def test_valid_long_email(self):\n        # Valid email with long domain\n        domain = \"a\" * 100 + \".com\"\n        result = fetch_email_domain(f\"long@{domain}\")\n        self.assertEqual(result, domain)\n\n    def test_invalid_empty_string(self):\n        # Empty string input\n        result = fetch_email_domain(\"\")\n        self.assertIsNone(result)\n\n    def test_invalid_no_at_symbol(self):\n        # Missing '@' character\n        result = fetch_email_domain(\"invalid-email.com\")\n        self.assertIsNone(result)\n\n    def test_invalid_multiple_ats(self):\n        # Multiple '@' characters\n        result = fetch_email_domain(\"user@domain@example.com\")\n        self.assertIsNone(result)\n\n    def test_invalid_starts_with_at(self):\n        # Starts with '@'\n        result = fetch_email_domain(\"@example.com\")\n        self.assertIsNone(result)\n\n    def test_invalid_ends_with_at(self):\n        # Ends with '@'\n        result = fetch_email_domain(\"user@\")\n        self.assertIsNone(result)\n\n    def test_invalid_single_at(self):\n        # Only '@' character\n        result = fetch_email_domain(\"@\")\n        self.assertIsNone(result)\n\n    def test_invalid_long_no_at(self):\n        # Long string without '@'\n        result = fetch_email_domain(\"a\" * 1000)\n        self.assertIsNone(result)\n\n    def test_invalid_space_after_at(self):\n        # Space after '@' in domain\n        result = fetch_email_domain(\"user@ example.com\")\n        self.assertIsNone(result)\n\n    def test_invalid_consecutive_ats(self):\n        # Consecutive '@' characters\n        result = fetch_email_domain(\"user@@example.com\")\n        self.assertIsNone(result)\n\n    def test_invalid_domain_space_before_at(self):\n        # Space before '@' in local part\n        result = fetch_email_domain(\"user name@example.com\")\n        self.assertEqual(result, \"example.com\")\n\n    def test_invalid_domain_space_after_at(self):\n        # Space after '@' (invalid per pattern)\n        result = fetch_email_domain(\"user@ example.com\")\n        self.assertIsNone(result)", "num_test_cases": 20, "task_id": "56a56e93"}
{"test": "import unittest\n\nclass TestRetrieveDomainFromEmail(unittest.TestCase):\n    \n    def test_basic_valid(self):\n        # Test a basic valid email\n        email = 'user@example.com'\n        result = retrieve_domain_from_email(email)\n        self.assertEqual(result, 'example.com')\n    \n    def test_valid_subdomain(self):\n        # Test valid email with subdomains\n        email = 'user@mail.sub.example.com'\n        result = retrieve_domain_from_email(email)\n        self.assertEqual(result, 'mail.sub.example.com')\n    \n    def test_valid_numbers_and_symbols_in_local(self):\n        # Test valid email with numbers and symbols in local part\n        email = 'user_123+test@example.com'\n        result = retrieve_domain_from_email(email)\n        self.assertEqual(result, 'example.com')\n    \n    def test_valid_space_in_local(self):\n        # Test valid email with space in local part\n        email = 'user name@example.com'\n        result = retrieve_domain_from_email(email)\n        self.assertEqual(result, 'example.com')\n    \n    def test_valid_space_in_domain(self):\n        # Test valid email with space in domain part\n        email = 'user@exa mple.com'\n        result = retrieve_domain_from_email(email)\n        self.assertEqual(result, 'exa mple.com')\n    \n    def test_valid_special_chars_in_local(self):\n        # Test valid email with special characters in local part\n        email = \"!#$%&'*+-/=?^_`{|}~@example.com\"\n        result = retrieve_domain_from_email(email)\n        self.assertEqual(result, 'example.com')\n    \n    def test_long_email(self):\n        # Test a very long email\n        local_part = 'a' * 1000\n        domain_part = 'b' * 1000\n        email = f\"{local_part}@{domain_part}\"\n        result = retrieve_domain_from_email(email)\n        self.assertEqual(result, domain_part)\n    \n    def test_valid_newline_in_local(self):\n        # Test valid email with newline in local part\n        email = 'user\\nname@example.com'\n        result = retrieve_domain_from_email(email)\n        self.assertEqual(result, 'example.com')\n    \n    def test_valid_non_ascii(self):\n        # Test valid email with non-ASCII characters\n        email = '\\u00FCser@d\\u00F6main.com'  # üser@dömain.com\n        result = retrieve_domain_from_email(email)\n        self.assertEqual(result, 'd\\u00F6main.com')\n    \n    def test_invalid_empty(self):\n        # Test empty string\n        email = ''\n        result = retrieve_domain_from_email(email)\n        self.assertIsNone(result)\n    \n    def test_invalid_no_at(self):\n        # Test string without '@'\n        email = 'plainaddress'\n        result = retrieve_domain_from_email(email)\n        self.assertIsNone(result)\n    \n    def test_invalid_two_at(self):\n        # Test string with two '@'\n        email = 'invalid@email@address'\n        result = retrieve_domain_from_email(email)\n        self.assertIsNone(result)\n    \n    def test_invalid_only_local(self):\n        # Test string that ends with '@' (no domain)\n        email = 'user@'\n        result = retrieve_domain_from_email(email)\n        self.assertIsNone(result)\n    \n    def test_invalid_only_domain(self):\n        # Test string that starts with '@' (no local part)\n        email = '@example.com'\n        result = retrieve_domain_from_email(email)\n        self.assertIsNone(result)\n    \n    def test_invalid_only_at(self):\n        # Test string with only '@'\n        email = '@'\n        result = retrieve_domain_from_email(email)\n        self.assertIsNone(result)\n    \n    def test_invalid_leading_whitespace(self):\n        # Test email with leading whitespace\n        email = ' user@example.com'\n        result = retrieve_domain_from_email(email)\n        self.assertIsNone(result)\n    \n    def test_invalid_trailing_whitespace(self):\n        # Test email with trailing whitespace\n        email = 'user@example.com '\n        result = retrieve_domain_from_email(email)\n        self.assertIsNone(result)\n    \n    def test_invalid_at_in_domain(self):\n        # Test email with '@' in the domain part\n        email = 'user@ex@mple.com'\n        result = retrieve_domain_from_email(email)\n        self.assertIsNone(result)\n    \n    def test_non_string_inputs(self):\n        # Test non-string inputs: None, integer, list\n        invalid_inputs = [None, 123, ['user@example.com']]\n        for inp in invalid_inputs:\n            with self.subTest(invalid_input=inp):\n                with self.assertRaises(TypeError):\n                    retrieve_domain_from_email(inp)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 19, "task_id": "c9a9d4af"}
{"test": "import unittest\nimport re\n\nclass TestGetEmailDomain(unittest.TestCase):\n\n    def test_case_1(self):\n        # Valid email with a simple domain.\n        self.assertEqual(get_email_domain('user@example.com'), 'example.com')\n\n    def test_case_2(self):\n        # Valid email with subdomain.\n        self.assertEqual(get_email_domain('user@sub.example.com'), 'sub.example.com')\n\n    def test_case_3(self):\n        # Valid email with numeric domain.\n        self.assertEqual(get_email_domain('user@123.com'), '123.com')\n\n    def test_case_4(self):\n        # Valid email with hyphen in domain.\n        self.assertEqual(get_email_domain('user@ex-ample.com'), 'ex-ample.com')\n\n    def test_case_5(self):\n        # Valid email with multipart TLD.\n        self.assertEqual(get_email_domain('user@example.co.uk'), 'example.co.uk')\n\n    def test_case_6(self):\n        # Invalid email: missing '@'\n        self.assertIsNone(get_email_domain('userexample.com'))\n\n    def test_case_7(self):\n        # Invalid email: multiple '@'\n        self.assertIsNone(get_email_domain('user@name@example.com'))\n\n    def test_case_8(self):\n        # Invalid email: empty string\n        self.assertIsNone(get_email_domain(''))\n\n    def test_case_9(self):\n        # Invalid email: only '@'\n        self.assertIsNone(get_email_domain('@'))\n\n    def test_case_10(self):\n        # Invalid email: no domain (only local part and '@')\n        self.assertIsNone(get_email_domain('user@'))\n\n    def test_case_11(self):\n        # Invalid email: no local part\n        self.assertIsNone(get_email_domain('@example.com'))\n\n    def test_case_12(self):\n        # Valid email: local part with special characters (., +)\n        self.assertEqual(get_email_domain('u.s.e.r+tag@example.com'), 'example.com')\n\n    def test_case_13(self):\n        # Valid email: domain with trailing dot\n        self.assertEqual(get_email_domain('user@example.com.'), 'example.com.')\n\n    def test_case_14(self):\n        # Valid email: domain with uppercase letters\n        self.assertEqual(get_email_domain('user@EXAMPLE.COM'), 'EXAMPLE.COM')\n\n    def test_case_15(self):\n        # Valid email: long domain name\n        long_domain = 'a' * 63 + '.com'\n        email = f'user@{long_domain}'\n        self.assertEqual(get_email_domain(email), long_domain)\n\n    def test_case_16(self):\n        # Invalid email: domain starts with a hyphen\n        self.assertIsNone(get_email_domain('user@-example.com'))\n\n    def test_case_17(self):\n        # Invalid email: contains spaces\n        self.assertIsNone(get_email_domain('user name@example.com'))", "num_test_cases": 17, "task_id": "876304f2"}
{"test": "import unittest\n\nclass TestRetrieveEmailDomain(unittest.TestCase):\n    def test_valid_email(self):\n        # Test with a standard valid email address\n        result = retrieve_email_domain('user@example.com')\n        self.assertEqual(result, 'example.com')\n\n    def test_valid_subdomain(self):\n        # Test with a domain containing multiple subdomains\n        result = retrieve_email_domain('name@sub.domain.co.uk')\n        self.assertEqual(result, 'sub.domain.co.uk')\n\n    def test_valid_with_numbers(self):\n        # Test with numbers in both local and domain parts\n        result = retrieve_email_domain('user123@domain456.com')\n        self.assertEqual(result, 'domain456.com')\n\n    def test_valid_special_chars_in_local(self):\n        # Test with special characters in local part (allowed by regex)\n        result = retrieve_email_domain('user.name+tag@domain.com')\n        self.assertEqual(result, 'domain.com')\n\n    def test_no_at_symbol(self):\n        # Test email address missing '@' symbol\n        result = retrieve_email_domain('invalidemail.com')\n        self.assertIsNone(result)\n\n    def test_empty_string(self):\n        # Test with empty input\n        result = retrieve_email_domain('')\n        self.assertIsNone(result)\n\n    def test_multiple_at_symbols(self):\n        # Test with multiple '@' symbols (invalid format)\n        result = retrieve_email_domain('user@name@domain.com')\n        self.assertIsNone(result)\n\n    def test_domain_contains_at(self):\n        # Test where domain part contains '@' (invalid per regex)\n        result = retrieve_email_domain('user@domain@part.com')\n        self.assertIsNone(result)\n\n    def test_starts_with_at(self):\n        # Test email starting with '@' (invalid)\n        result = retrieve_email_domain('@domain.com')\n        self.assertIsNone(result)\n\n    def test_ends_with_at(self):\n        # Test email ending with '@' (invalid domain part)\n        result = retrieve_email_domain('user@')\n        self.assertIsNone(result)\n\n    def test_non_ascii_domain(self):\n        # Test with non-ASCII characters in domain\n        result = retrieve_email_domain('user@exämple.com')\n        self.assertEqual(result, 'exämple.com')\n\n    def test_only_at_symbol(self):\n        # Test input containing only '@' symbol\n        result = retrieve_email_domain('@')\n        self.assertIsNone(result)\n\n    def test_whitespace_in_domain(self):\n        # Test with whitespace in domain part (invalid)\n        result = retrieve_email_domain('user@exa mple.com')\n        self.assertIsNone(result)\n\n    def test_whitespace_in_local(self):\n        # Test with whitespace in local part (invalid per regex)\n        result = retrieve_email_domain('us er@example.com')\n        self.assertIsNone(result)\n\n    def test_long_valid_email(self):\n        # Test with a long valid domain\n        domain = 'a' * 100 + '.com'\n        email = f'user@{domain}'\n        result = retrieve_email_domain(email)\n        self.assertEqual(result, domain)\n\n    def test_long_invalid_email(self):\n        # Test with long string containing no '@'\n        email = 'a' * 1000\n        result = retrieve_email_domain(email)\n        self.assertIsNone(result)\n", "num_test_cases": 16, "task_id": "aa820973"}
{"test": "import unittest\n\nclass TestFetchEmailDomain(unittest.TestCase):\n    def test_valid_email_basic(self):\n        # Basic valid email\n        email = \"user@example.com\"\n        result = fetch_email_domain(email)\n        self.assertEqual(result, \"example.com\")\n\n    def test_valid_email_subdomain(self):\n        # Valid with subdomain\n        email = \"user@sub.example.com\"\n        result = fetch_email_domain(email)\n        self.assertEqual(result, \"sub.example.com\")\n\n    def test_valid_email_numbers(self):\n        # Valid with numbers in local and domain\n        email = \"user123@example123.com\"\n        result = fetch_email_domain(email)\n        self.assertEqual(result, \"example123.com\")\n\n    def test_valid_email_special_chars(self):\n        # Valid with special characters in local part\n        email = \"user.name+tag@example.com\"\n        result = fetch_email_domain(email)\n        self.assertEqual(result, \"example.com\")\n\n    def test_invalid_email_missing_at(self):\n        # Missing '@' character\n        email = \"userexample.com\"\n        result = fetch_email_domain(email)\n        self.assertIsNone(result)\n\n    def test_invalid_email_two_ats(self):\n        # Multiple '@' characters\n        email = \"user@name@example.com\"\n        result = fetch_email_domain(email)\n        self.assertIsNone(result)\n\n    def test_invalid_email_domain_missing(self):\n        # Domain part missing after '@'\n        email = \"user@\"\n        result = fetch_email_domain(email)\n        self.assertIsNone(result)\n\n    def test_invalid_email_local_missing(self):\n        # Local part missing before '@'\n        email = \"@example.com\"\n        result = fetch_email_domain(email)\n        self.assertIsNone(result)\n\n    def test_empty_string(self):\n        # Empty email string\n        email = \"\"\n        result = fetch_email_domain(email)\n        self.assertIsNone(result)\n\n    def test_none_input(self):\n        # None input (non-string)\n        with self.assertRaises(TypeError):\n            fetch_email_domain(None)\n\n    def test_non_string_input(self):\n        # Integer input (non-string)\n        with self.assertRaises(TypeError):\n            fetch_email_domain(123)\n\n    def test_long_email(self):\n        # Very long email address\n        local_part = 'a' * 1000\n        domain = 'b' * 1000\n        email = f\"{local_part}@{domain}\"\n        result = fetch_email_domain(email)\n        self.assertEqual(result, domain)\n\n    def test_email_with_newline(self):\n        # Newline at end of email\n        email = \"user@example.com\\n\"\n        result = fetch_email_domain(email)\n        self.assertIsNone(result)\n\n    def test_email_leading_space(self):\n        # Leading whitespace\n        email = \" user@example.com\"\n        result = fetch_email_domain(email)\n        self.assertIsNone(result)\n\n    def test_email_trailing_space(self):\n        # Trailing whitespace\n        email = \"user@example.com \"\n        result = fetch_email_domain(email)\n        self.assertIsNone(result)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 15, "task_id": "5d9af8fa"}
{"test": "import unittest\nimport re\n\nclass TestCheckPathValidity(unittest.TestCase):\n\n    def test_valid_http_url(self):\n        # Test standard HTTP URL\n        self.assertTrue(check_path_validity('http://example.com'))\n    \n    def test_valid_https_url(self):\n        # Test standard HTTPS URL\n        self.assertTrue(check_path_validity('https://example.com'))\n    \n    def test_valid_url_without_scheme(self):\n        # Test valid URL without http/https scheme\n        self.assertTrue(check_path_validity('example.com'))\n    \n    def test_valid_url_with_path(self):\n        # Test URL with a simple path\n        self.assertTrue(check_path_validity('https://example.com/path'))\n    \n    def test_valid_url_with_subdomain(self):\n        # Test URL with subdomain\n        self.assertTrue(check_path_validity('https://sub.example.com'))\n    \n    def test_valid_url_with_numbers_in_domain(self):\n        # Test domain containing numbers\n        self.assertTrue(check_path_validity('http://ex4mple.com'))\n    \n    def test_valid_url_with_hyphen_in_domain(self):\n        # Test domain containing hyphens\n        self.assertTrue(check_path_validity('http://ex-ample.com'))\n    \n    def test_valid_url_with_2char_tld(self):\n        # Test 2-character TLD\n        self.assertTrue(check_path_validity('http://example.co'))\n    \n    def test_valid_url_with_6char_tld(self):\n        # Test 6-character TLD\n        self.assertTrue(check_path_validity('http://example.museum'))\n    \n    def test_valid_url_with_trailing_slash(self):\n        # Test URL with trailing slash\n        self.assertTrue(check_path_validity('http://example.com/'))\n    \n    def test_valid_url_with_max_path_length(self):\n        # Test path at maximum allowed length (300 chars)\n        long_path = '/a' * 150  # 300 characters\n        self.assertTrue(check_path_validity(f'http://example.com{long_path}'))\n    \n    def test_empty_string(self):\n        # Test empty input string\n        self.assertFalse(check_path_validity(''))\n    \n    def test_whitespace_string(self):\n        # Test input with only whitespace\n        self.assertFalse(check_path_validity('   '))\n    \n    def test_invalid_scheme(self):\n        # Test invalid scheme (ftp)\n        self.assertFalse(check_path_validity('ftp://example.com'))\n    \n    def test_tld_too_short(self):\n        # Test TLD shorter than 2 characters\n        self.assertFalse(check_path_validity('http://example.a'))\n    \n    def test_tld_too_long(self):\n        # Test TLD longer than 6 characters\n        self.assertFalse(check_path_validity('http://example.abcdefg'))\n    \n    def test_path_too_long(self):\n        # Test path exceeding 300 characters\n        long_path = '/a' * 151  # 302 characters\n        self.assertFalse(check_path_validity(f'http://example.com{long_path}'))\n    \n    def test_domain_with_underscore(self):\n        # Test invalid underscore in domain\n        self.assertFalse(check_path_validity('http://ex_ample.com'))\n    \n    def test_domain_with_space(self):\n        # Test invalid space in domain\n        self.assertFalse(check_path_validity('http://ex ample.com'))\n    \n    def test_url_with_port(self):\n        # Test URL containing port number (invalid per regex)\n        self.assertFalse(check_path_validity('http://example.com:8080'))\n    \n    def test_url_with_query_string(self):\n        # Test URL with query parameters (invalid per regex)\n        self.assertFalse(check_path_validity('http://example.com?query=test'))\n    \n    def test_path_with_invalid_character(self):\n        # Test path containing invalid character (@)\n        self.assertFalse(check_path_validity('http://example.com/path@test'))\n    \n    def test_missing_domain(self):\n        # Test missing domain name\n        self.assertFalse(check_path_validity('http://.com'))\n    \n    def test_domain_starting_with_hyphen(self):\n        # Test domain starting with hyphen (invalid)\n        self.assertFalse(check_path_validity('http://-example.com'))\n    \n    def test_domain_ending_with_hyphen(self):\n        # Test domain ending with hyphen (invalid)\n        self.assertFalse(check_path_validity('http://example-.com'))\n\n    def test_valid_url_with_dot_in_tld(self):\n        # Test valid multi-part TLD (like co.uk)\n        self.assertTrue(check_path_validity('http://example.co.uk'))\n\n    def test_valid_url_with_dash_in_path(self):\n        # Test valid path containing dash\n        self.assertTrue(check_path_validity('http://example.com/my-path'))\n\n    def test_valid_url_with_underscore_in_path(self):\n        # Test valid path containing underscore\n        self.assertTrue(check_path_validity('http://example.com/my_path'))\n\n    def test_valid_url_with_space_in_path(self):\n        # Test valid path containing encoded space\n        self.assertTrue(check_path_validity('http://example.com/my%20path'))", "num_test_cases": 30, "task_id": "454a6237"}
{"test": "import unittest\n\nclass TestVerifyPathFormat(unittest.TestCase):\n\n    def test_valid_http_url(self):\n        # Test standard HTTP URL\n        self.assertTrue(verify_path_format(\"http://example.com\"))\n\n    def test_valid_https_url(self):\n        # Test standard HTTPS URL\n        self.assertTrue(verify_path_format(\"https://example.com\"))\n\n    def test_valid_no_scheme(self):\n        # Test valid URL without scheme\n        self.assertTrue(verify_path_format(\"example.com\"))\n\n    def test_valid_subdomain(self):\n        # Test URL with subdomain\n        self.assertTrue(verify_path_format(\"www.sub.example.com\"))\n\n    def test_valid_path_with_space(self):\n        # Test URL path containing space\n        self.assertTrue(verify_path_format(\"example.com/path with space\"))\n\n    def test_valid_path_with_underscore(self):\n        # Test URL path containing underscore\n        self.assertTrue(verify_path_format(\"example.com/path_with_underscore\"))\n\n    def test_valid_path_with_hyphen(self):\n        # Test URL path containing hyphen\n        self.assertTrue(verify_path_format(\"example.com/path-with-hyphen\"))\n\n    def test_valid_path_exactly_300_chars(self):\n        # Test path part exactly 300 characters (no trailing slash)\n        address = \"example.com\" + ('a' * 300)\n        self.assertTrue(verify_path_format(address))\n\n    def test_valid_path_300_chars_with_trailing_slash(self):\n        # Test path part exactly 300 characters with trailing slash\n        address = \"example.com\" + ('a' * 300) + '/'\n        self.assertTrue(verify_path_format(address))\n\n    def test_invalid_path_301_chars(self):\n        # Test path part exceeding 301 characters\n        address = \"example.com\" + ('a' * 301)\n        self.assertFalse(verify_path_format(address))\n\n    def test_invalid_empty_string(self):\n        # Test empty input string\n        self.assertFalse(verify_path_format(\"\"))\n\n    def test_invalid_only_scheme(self):\n        # Test only scheme without domain\n        self.assertFalse(verify_path_format(\"http://\"))\n\n    def test_invalid_missing_tld(self):\n        # Test missing top-level domain\n        self.assertFalse(verify_path_format(\"example\"))\n\n    def test_invalid_tld_too_short(self):\n        # Test TLD too short (1 character)\n        self.assertFalse(verify_path_format(\"example.a\"))\n\n    def test_invalid_tld_too_long(self):\n        # Test TLD too long (7 characters)\n        self.assertFalse(verify_path_format(\"example.abcdefg\"))\n\n    def test_invalid_character_in_path(self):\n        # Test invalid character '!' in path\n        self.assertFalse(verify_path_format(\"example.com/!\"))\n\n    def test_valid_multi_level_tld(self):\n        # Test multi-level TLD (e.g., co.uk)\n        self.assertTrue(verify_path_format(\"example.co.uk\"))\n\n    def test_valid_domain_with_consecutive_dots(self):\n        # Test domain with consecutive dots\n        self.assertTrue(verify_path_format(\"example..com\"))\n\n    def test_valid_http_url_with_long_path(self):\n        # Test HTTP URL with long path (300 chars)\n        address = \"http://example.com\" + ('a' * 300)\n        self.assertTrue(verify_path_format(address))\n\n    def test_invalid_port_inclusion(self):\n        # Test inclusion of port number (invalid per pattern)\n        self.assertFalse(verify_path_format(\"example.com:8080\"))\n\n    def test_valid_long_tld(self):\n        # Test TLD with maximum allowed length (6 chars)\n        self.assertTrue(verify_path_format(\"example.abcdef\"))\n\n    def test_invalid_tld_with_digit(self):\n        # Test TLD containing invalid digit\n        self.assertFalse(verify_path_format(\"example.123\"))\n\n    def test_valid_with_trailing_slash(self):\n        # Test valid URL with trailing slash\n        self.assertTrue(verify_path_format(\"example.com/\"))", "num_test_cases": 23, "task_id": "5d0175fc"}
{"test": "import unittest\n\nclass TestCases(unittest.TestCase):\n    def test_case_1(self):\n        # Valid URL with http scheme\n        self.assertTrue(check_url_format('http://example.com'))\n    \n    def test_case_2(self):\n        # Valid URL with https scheme\n        self.assertTrue(check_url_format('https://example.com'))\n    \n    def test_case_3(self):\n        # Valid URL without scheme\n        self.assertTrue(check_url_format('example.com'))\n    \n    def test_case_4(self):\n        # Valid URL with subdomain\n        self.assertTrue(check_url_format('sub.example.com'))\n    \n    def test_case_5(self):\n        # Valid URL with TLD containing multiple dots (co.uk)\n        self.assertTrue(check_url_format('example.co.uk'))\n    \n    def test_case_6(self):\n        # Valid URL with path\n        self.assertTrue(check_url_format('example.com/path'))\n    \n    def test_case_7(self):\n        # Valid URL with space in path\n        self.assertTrue(check_url_format('example.com/path with space'))\n    \n    def test_case_8(self):\n        # Valid URL with path exactly 300 characters\n        long_path = 'a' * 300\n        url = 'example.com' + long_path\n        self.assertTrue(check_url_format(url))\n    \n    def test_case_9(self):\n        # Empty string\n        self.assertFalse(check_url_format(''))\n    \n    def test_case_10(self):\n        # Missing TLD (only domain)\n        self.assertFalse(check_url_format('example'))\n    \n    def test_case_11(self):\n        # TLD too short (1 character)\n        self.assertFalse(check_url_format('example.c'))\n    \n    def test_case_12(self):\n        # TLD too long (7 characters)\n        self.assertFalse(check_url_format('example.abcdefg'))\n    \n    def test_case_13(self):\n        # Invalid scheme (ftp)\n        self.assertFalse(check_url_format('ftp://example.com'))\n    \n    def test_case_14(self):\n        # Port number\n        self.assertFalse(check_url_format('example.com:80'))\n    \n    def test_case_15(self):\n        # Query string\n        self.assertFalse(check_url_format('example.com?query=param'))\n    \n    def test_case_16(self):\n        # Fragment\n        self.assertFalse(check_url_format('example.com#fragment'))\n    \n    def test_case_17(self):\n        # Uppercase in domain\n        self.assertFalse(check_url_format('Example.com'))\n    \n    def test_case_18(self):\n        # Uppercase in TLD\n        self.assertFalse(check_url_format('example.COM'))\n    \n    def test_case_19(self):\n        # Invalid character in domain\n        self.assertFalse(check_url_format('exa$mple.com'))\n    \n    def test_case_20(self):\n        # Invalid character in path\n        self.assertFalse(check_url_format('example.com/pa$th'))\n    \n    def test_case_21(self):\n        # Path too long (301 characters)\n        long_path = 'a' * 301\n        url = 'example.com' + long_path\n        self.assertFalse(check_url_format(url))\n    \n    def test_case_22(self):\n        # Domain with space\n        self.assertFalse(check_url_format('exa mple.com'))\n    \n    def test_case_23(self):\n        # Only scheme\n        self.assertFalse(check_url_format('http://'))\n    \n    def test_case_24(self):\n        # TLD with 2 characters\n        self.assertTrue(check_url_format('example.co'))\n    \n    def test_case_25(self):\n        # TLD with 6 characters\n        self.assertTrue(check_url_format('example.abcdef'))\n    \n    def test_case_26(self):\n        # Trailing slash\n        self.assertTrue(check_url_format('example.com/'))\n    \n    def test_case_27(self):\n        # Trailing slash after path\n        self.assertTrue(check_url_format('example.com/path/'))\n    \n    def test_case_28(self):\n        # Domain with dash\n        self.assertTrue(check_url_format('exa-mple.com'))", "num_test_cases": 28, "task_id": "3d67a3ba"}
{"test": "import unittest\n\nclass TestCases(unittest.TestCase):\n\n    def test_case_1(self):\n        # Valid http URL with path\n        self.assertTrue(check_path('http://example.com/path/to/resource'))\n\n    def test_case_2(self):\n        # Valid https URL with path\n        self.assertTrue(check_path('https://example.com/path'))\n\n    def test_case_3(self):\n        # Valid URL without scheme\n        self.assertTrue(check_path('example.com/path'))\n\n    def test_case_4(self):\n        # Valid URL with trailing slash\n        self.assertTrue(check_path('https://example.com/path/'))\n\n    def test_case_5(self):\n        # Valid URL without trailing slash\n        self.assertTrue(check_path('https://example.com'))\n\n    def test_case_6(self):\n        # Valid URL with multi-label domain\n        self.assertTrue(check_path('sub.example.co.uk'))\n\n    def test_case_7(self):\n        # Valid URL with 2-character TLD\n        self.assertTrue(check_path('example.aa'))\n\n    def test_case_8(self):\n        # Valid URL with 6-character TLD\n        self.assertTrue(check_path('example.abcdef'))\n\n    def test_case_9(self):\n        # Valid URL with space in path\n        self.assertTrue(check_path('example.com/path with space'))\n\n    def test_case_10(self):\n        # Valid URL with exactly 300-character path\n        long_path = '/a' * 150  # 300 characters (150 repetitions of '/a')\n        self.assertTrue(check_path(f'example.com{long_path}'))\n\n    def test_case_11(self):\n        # Empty string\n        self.assertFalse(check_path(''))\n\n    def test_case_12(self):\n        # Whitespace only\n        self.assertFalse(check_path('   '))\n\n    def test_case_13(self):\n        # TLD too short (1 character)\n        self.assertFalse(check_path('example.a'))\n\n    def test_case_14(self):\n        # TLD too long (7 characters)\n        self.assertFalse(check_path('example.abcdefg'))\n\n    def test_case_15(self):\n        # Invalid character (underscore) in domain\n        self.assertFalse(check_path('ex_ample.com'))\n\n    def test_case_16(self):\n        # Invalid character (hash) in path\n        self.assertFalse(check_path('example.com/path#section'))\n\n    def test_case_17(self):\n        # Path too long (301 characters)\n        long_path = '/a' * 150 + 'b'  # 301 characters\n        self.assertFalse(check_path(f'example.com{long_path}'))\n\n    def test_case_18(self):\n        # Missing TLD\n        self.assertFalse(check_path('example'))\n\n    def test_case_19(self):\n        # Uppercase character in domain\n        self.assertFalse(check_path('Example.com'))\n\n    def test_case_20(self):\n        # URL with port number\n        self.assertFalse(check_path('http://example.com:8080'))\n\n    def test_case_21(self):\n        # Domain starting with hyphen\n        self.assertTrue(check_path('-example.com'))\n\n    def test_case_22(self):\n        # Domain ending with hyphen\n        self.assertTrue(check_path('example-.com'))\n\n    def test_case_23(self):\n        # Domain with consecutive dots\n        self.assertTrue(check_path('ex..ample.com'))\n\n    def test_case_24(self):\n        # Valid URL with IP address (invalid per regex due to TLD constraints)\n        self.assertFalse(check_path('http://192.168.1.1'))\n\n    def test_case_25(self):\n        # URL with query parameters (invalid character ?)\n        self.assertFalse(check_path('example.com/path?param=value'))", "num_test_cases": 25, "task_id": "63e278c1"}
{"test": "import unittest\n\nclass TestPathVerification(unittest.TestCase):\n    def test_valid_http(self):\n        # Test valid http URL\n        self.assertTrue(path_verification(\"http://example.com\"))\n    \n    def test_valid_https(self):\n        # Test valid https URL\n        self.assertTrue(path_verification(\"https://example.com\"))\n    \n    def test_valid_no_scheme(self):\n        # Test valid URL without scheme\n        self.assertTrue(path_verification(\"example.com\"))\n    \n    def test_valid_subdomain(self):\n        # Test valid URL with subdomain\n        self.assertTrue(path_verification(\"http://sub.example.com\"))\n    \n    def test_valid_with_path(self):\n        # Test valid URL with path\n        self.assertTrue(path_verification(\"http://example.com/path/to/resource\"))\n    \n    def test_valid_long_path(self):\n        # Test valid URL with long path (exactly 300 chars in path component)\n        long_path = \"http://example.com/\" + 'a' * 299\n        self.assertTrue(path_verification(long_path))\n    \n    def test_valid_trailing_slash(self):\n        # Test valid URL with trailing slash\n        self.assertTrue(path_verification(\"http://example.com/\"))\n    \n    def test_valid_space_in_path(self):\n        # Test valid URL with space in path\n        self.assertTrue(path_verification(\"http://example.com/path with space\"))\n    \n    def test_valid_hyphen_in_domain(self):\n        # Test valid URL with hyphen in domain\n        self.assertTrue(path_verification(\"http://ex-ample.com\"))\n    \n    def test_invalid_scheme(self):\n        # Test invalid scheme (ftp)\n        self.assertFalse(path_verification(\"ftp://example.com\"))\n    \n    def test_invalid_domain_underscore(self):\n        # Test invalid domain with underscore\n        self.assertFalse(path_verification(\"http://ex_ample.com\"))\n    \n    def test_invalid_tld_too_long(self):\n        # Test invalid TLD (8 characters)\n        self.assertFalse(path_verification(\"http://example.abcdefgh\"))\n    \n    def test_invalid_tld_too_short(self):\n        # Test invalid TLD (1 character)\n        self.assertFalse(path_verification(\"http://example.a\"))\n    \n    def test_invalid_empty_string(self):\n        # Test empty string input\n        self.assertFalse(path_verification(\"\"))\n    \n    def test_invalid_path_too_long(self):\n        # Test invalid path (301 chars in path component)\n        long_path = \"http://example.com/\" + 'a' * 300\n        self.assertFalse(path_verification(long_path))\n    \n    def test_invalid_character_in_path(self):\n        # Test invalid character (?) in path\n        self.assertFalse(path_verification(\"http://example.com/path?query=123\"))\n    \n    def test_none_input(self):\n        # Test None input (should return False without raising)\n        try:\n            result = path_verification(None)\n        except Exception as e:\n            self.fail(f\"Function raised {e} for None input\")\n        self.assertFalse(result)\n    \n    def test_integer_input(self):\n        # Test integer 0 input (should return False without raising)\n        try:\n            result = path_verification(0)\n        except Exception as e:\n            self.fail(f\"Function raised {e} for integer 0 input\")\n        self.assertFalse(result)", "num_test_cases": 18, "task_id": "2ead2c68"}
{"test": "import unittest\nfrom solution import path_check\n\nclass TestPathCheck(unittest.TestCase):\n\n    def test_valid_http_url(self):\n        # Test valid URL with http scheme\n        self.assertTrue(path_check(\"http://example.com\"))\n\n    def test_valid_https_url(self):\n        # Test valid URL with https scheme\n        self.assertTrue(path_check(\"https://example.com\"))\n\n    def test_valid_no_scheme(self):\n        # Test valid URL without scheme\n        self.assertTrue(path_check(\"example.com\"))\n\n    def test_valid_subdomain(self):\n        # Test valid URL with subdomain\n        self.assertTrue(path_check(\"http://sub.example.com\"))\n\n    def test_valid_path(self):\n        # Test valid URL with path\n        self.assertTrue(path_check(\"http://example.com/path/to/resource\"))\n\n    def test_valid_trailing_slash(self):\n        # Test valid URL with trailing slash\n        self.assertTrue(path_check(\"http://example.com/\"))\n\n    def test_valid_tld_min_length(self):\n        # Test valid URL with TLD of minimum length (2 chars)\n        self.assertTrue(path_check(\"http://example.ab\"))\n\n    def test_valid_tld_max_length(self):\n        # Test valid URL with TLD of maximum length (6 chars)\n        self.assertTrue(path_check(\"http://example.abcdef\"))\n\n    def test_valid_domain_hyphen(self):\n        # Test valid URL with hyphen in domain\n        self.assertTrue(path_check(\"http://my-example.com\"))\n\n    def test_valid_domain_digit(self):\n        # Test valid URL with digits in domain\n        self.assertTrue(path_check(\"http://123example.com\"))\n\n    def test_valid_consecutive_dots_domain(self):\n        # Test valid URL with consecutive dots in domain\n        self.assertTrue(path_check(\"http://ex..ample.com\"))\n\n    def test_valid_all_dots_domain(self):\n        # Test valid URL with all dots in domain\n        self.assertTrue(path_check(\"http://...com\"))\n\n    def test_valid_domain_starting_dash(self):\n        # Test valid URL with domain starting with dash\n        self.assertTrue(path_check(\"http://-example.com\"))\n\n    def test_valid_tld_all_dots(self):\n        # Test valid URL with all dots in TLD\n        self.assertTrue(path_check(\"http://example..\"))\n\n    def test_valid_path_space(self):\n        # Test valid URL with space in path\n        self.assertTrue(path_check(\"http://example.com/path with space\"))\n\n    def test_valid_path_dot_dash(self):\n        # Test valid URL with dot and dash in path\n        self.assertTrue(path_check(\"http://example.com/path.-/file\"))\n\n    def test_valid_path_300_chars(self):\n        # Test valid URL with path length exactly 300 chars\n        url = \"http://example.com/\" + 'a' * 299  # Total path part = 300 chars\n        self.assertTrue(path_check(url))\n\n    def test_invalid_scheme_ftp(self):\n        # Test invalid scheme (ftp)\n        self.assertFalse(path_check(\"ftp://example.com\"))\n\n    def test_invalid_domain_uppercase(self):\n        # Test invalid domain with uppercase letters\n        self.assertFalse(path_check(\"http://Example.com\"))\n\n    def test_invalid_tld_short(self):\n        # Test invalid TLD too short (1 char)\n        self.assertFalse(path_check(\"http://example.a\"))\n\n    def test_invalid_tld_long(self):\n        # Test invalid TLD too long (7 chars)\n        self.assertFalse(path_check(\"http://example.abcdefg\"))\n\n    def test_invalid_tld_digit(self):\n        # Test invalid TLD with digit\n        self.assertFalse(path_check(\"http://example.abc1\"))\n\n    def test_invalid_path_301_chars(self):\n        # Test invalid URL with path length 301 chars\n        url = \"http://example.com/\" + 'a' * 300  # Total path part = 301 chars\n        self.assertFalse(path_check(url))\n\n    def test_invalid_path_query(self):\n        # Test invalid URL with query string (contains '?')\n        self.assertFalse(path_check(\"http://example.com/path?query=value\"))\n\n    def test_invalid_empty_string(self):\n        # Test empty string input\n        self.assertFalse(path_check(\"\"))\n\n    def test_invalid_none(self):\n        # Test None input, should not raise exception\n        try:\n            result = path_check(None)\n            self.assertFalse(result)\n        except Exception as e:\n            self.fail(f\"Function raised {e} unexpectedly for None input\")\n\n    def test_invalid_integer(self):\n        # Test integer input, should not raise exception\n        try:\n            result = path_check(123)\n            self.assertFalse(result)\n        except Exception as e:\n            self.fail(f\"Function raised {e} unexpectedly for integer input\")\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 27, "task_id": "1bdcd59f"}
{"test": "import unittest\n\nclass TestCheckPath(unittest.TestCase):\n    \n    def test_valid_http(self):\n        # Standard HTTP URL with domain and no path\n        self.assertTrue(check_path('http://example.com'))\n    \n    def test_valid_https(self):\n        # Standard HTTPS URL with domain and no path\n        self.assertTrue(check_path('https://example.com'))\n    \n    def test_valid_without_scheme(self):\n        # Valid domain without http/https scheme\n        self.assertTrue(check_path('example.com'))\n    \n    def test_valid_with_subdomain(self):\n        # URL with subdomain\n        self.assertTrue(check_path('http://sub.example.com'))\n    \n    def test_valid_with_path(self):\n        # URL with a simple path\n        self.assertTrue(check_path('http://example.com/path'))\n    \n    def test_valid_with_long_path_within_limit(self):\n        # Path exactly at 300 characters limit\n        long_path = '/a' * 150  # 300 characters total\n        self.assertTrue(check_path('http://example.com' + long_path))\n    \n    def test_valid_with_trailing_slash(self):\n        # URL ending with a slash\n        self.assertTrue(check_path('http://example.com/'))\n    \n    def test_valid_with_digits_in_domain(self):\n        # Domain containing digits\n        self.assertTrue(check_path('http://123example.com'))\n    \n    def test_valid_with_hyphen_in_domain(self):\n        # Domain containing hyphens\n        self.assertTrue(check_path('http://exa-mple.com'))\n    \n    def test_valid_with_dot_in_domain(self):\n        # Domain with multiple subdomains\n        self.assertTrue(check_path('http://sub.sub.example.com'))\n    \n    def test_valid_with_uppercase_in_path(self):\n        # Path containing uppercase letters (allowed)\n        self.assertTrue(check_path('http://example.com/Path'))\n    \n    def test_valid_with_dot_in_path(self):\n        # Path containing dots\n        self.assertTrue(check_path('http://example.com/path.with.dots'))\n    \n    def test_valid_with_space_in_path(self):\n        # Path containing spaces (explicitly allowed by pattern)\n        self.assertTrue(check_path('http://example.com/path with spaces'))\n    \n    def test_valid_complex_tld(self):\n        # TLD with dot (multi-level TLD)\n        self.assertTrue(check_path('http://example.co.uk'))\n    \n    def test_valid_nested_path(self):\n        # Path with multiple nested segments\n        self.assertTrue(check_path('http://example.com/path/to/resource'))\n    \n    def test_invalid_empty_string(self):\n        # Empty input string\n        self.assertFalse(check_path(''))\n    \n    def test_invalid_scheme_only(self):\n        # Only scheme without domain\n        self.assertFalse(check_path('http://'))\n    \n    def test_invalid_domain_without_tld(self):\n        # Domain without TLD\n        self.assertFalse(check_path('http://example'))\n    \n    def test_invalid_tld_too_short(self):\n        # TLD less than 2 characters\n        self.assertFalse(check_path('http://example.a'))\n    \n    def test_invalid_tld_too_long(self):\n        # TLD more than 6 characters\n        self.assertFalse(check_path('http://example.abcdefg'))\n    \n    def test_invalid_uppercase_in_domain(self):\n        # Uppercase in domain (not allowed)\n        self.assertFalse(check_path('http://Example.com'))\n    \n    def test_invalid_uppercase_in_tld(self):\n        # Uppercase in TLD (not allowed)\n        self.assertFalse(check_path('http://example.COM'))\n    \n    def test_invalid_path_too_long(self):\n        # Path exceeding 300 characters\n        long_path = '/a' * 151  # 302 characters total\n        self.assertFalse(check_path('http://example.com' + long_path))\n    \n    def test_invalid_underscore_in_domain(self):\n        # Underscore in domain (not allowed)\n        self.assertFalse(check_path('http://exa_mple.com'))\n    \n    def test_invalid_digit_in_tld(self):\n        # Digit in TLD (not allowed)\n        self.assertFalse(check_path('http://example.c0m'))\n    \n    def test_invalid_special_char_in_path(self):\n        # Special character in path (not in allowed set)\n        self.assertFalse(check_path('http://example.com/path$'))\n    \n    def test_invalid_missing_dot_before_tld(self):\n        # Missing dot between domain and TLD\n        self.assertFalse(check_path('http://examplecom'))\n    \n    def test_invalid_domain_starting_with_hyphen(self):\n        # Domain starting with hyphen\n        self.assertFalse(check_path('http://-example.com'))\n    \n    def test_invalid_domain_ending_with_hyphen(self):\n        # Domain ending with hyphen\n        self.assertFalse(check_path('http://example-.com'))\n    \n    def test_invalid_query_parameters(self):\n        # URL with query parameters (not allowed)\n        self.assertFalse(check_path('http://example.com?query=param'))\n\ndef load_tests(loader, tests, pattern):\n    suite = unittest.TestSuite()\n    suite.addTests(loader.loadTestsFromTestCase(TestCheckPath))\n    return suite\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 21, "task_id": "70ac9c72"}
{"test": "import unittest\n\nclass TestVerifyLink(unittest.TestCase):\n    \n    def test_case_1(self):\n        # Valid http URL with scheme\n        self.assertTrue(verify_link('http://example.com'))\n    \n    def test_case_2(self):\n        # Valid https URL\n        self.assertTrue(verify_link('https://example.com'))\n    \n    def test_case_3(self):\n        # Valid without scheme\n        self.assertTrue(verify_link('example.com'))\n    \n    def test_case_4(self):\n        # Valid with path\n        self.assertTrue(verify_link('example.com/path'))\n    \n    def test_case_5(self):\n        # Valid with trailing slash\n        self.assertTrue(verify_link('example.com/path/'))\n    \n    def test_case_6(self):\n        # Valid with multi-level subdomain\n        self.assertTrue(verify_link('sub.example.com'))\n    \n    def test_case_7(self):\n        # Valid with international TLD\n        self.assertTrue(verify_link('example.co.uk'))\n    \n    def test_case_8(self):\n        # Valid with space in path\n        self.assertTrue(verify_link('example.com/my page'))\n    \n    def test_case_9(self):\n        # Valid with dots in path\n        self.assertTrue(verify_link('example.com/..'))\n    \n    def test_case_10(self):\n        # Valid with maximum path length (300 chars)\n        self.assertTrue(verify_link('example.com/' + 'a' * 300))\n    \n    def test_case_11(self):\n        # Valid with uppercase in path\n        self.assertTrue(verify_link('example.com/Path'))\n    \n    def test_case_12(self):\n        # Valid with dotted TLD at max length (6 chars)\n        self.assertTrue(verify_link('example.a.bcde'))  # TLD 'a.bcde' is 6 chars\n    \n    def test_case_13(self):\n        # Empty string\n        self.assertFalse(verify_link(''))\n    \n    def test_case_14(self):\n        # Only scheme\n        self.assertFalse(verify_link('http://'))\n    \n    def test_case_15(self):\n        # Invalid scheme\n        self.assertFalse(verify_link('ftp://example.com'))\n    \n    def test_case_16(self):\n        # Domain without TLD\n        self.assertFalse(verify_link('example'))\n    \n    def test_case_17(self):\n        # TLD too short (1 char)\n        self.assertFalse(verify_link('example.a'))\n    \n    def test_case_18(self):\n        # TLD too long without dot (7 chars)\n        self.assertFalse(verify_link('example.abcdefg'))\n    \n    def test_case_19(self):\n        # Path too long (301 chars)\n        self.assertFalse(verify_link('example.com/' + 'a' * 301))\n    \n    def test_case_20(self):\n        # Invalid character in domain\n        self.assertFalse(verify_link('ex@mple.com'))\n    \n    def test_case_21(self):\n        # Invalid character in TLD\n        self.assertFalse(verify_link('example.c*m'))\n    \n    def test_case_22(self):\n        # Query string (invalid character)\n        self.assertFalse(verify_link('example.com/path?query'))\n    \n    def test_case_23(self):\n        # Uppercase in domain\n        self.assertFalse(verify_link('EXAMPLE.com'))\n    \n    def test_case_24(self):\n        # TLD too long with dot (7 chars)\n        self.assertFalse(verify_link('example.a.bcdef'))  # TLD 'a.bcdef' is 7 chars\n    \n    def test_case_25(self):\n        # Non-string input (integer)\n        with self.assertRaises(TypeError):\n            verify_link(123)\n    \n    def test_case_26(self):\n        # None input\n        with self.assertRaises(TypeError):\n            verify_link(None)", "num_test_cases": 26, "task_id": "e86755c2"}
{"test": "import unittest\n\nclass TestIsValidPath(unittest.TestCase):\n    \n    def test_valid_http(self):\n        # Valid HTTP URL\n        self.assertTrue(is_valid_path('http://example.com'))\n    \n    def test_valid_https(self):\n        # Valid HTTPS URL\n        self.assertTrue(is_valid_path('https://example.com'))\n    \n    def test_valid_without_scheme(self):\n        # Valid URL without scheme\n        self.assertTrue(is_valid_path('example.com'))\n    \n    def test_valid_subdomain(self):\n        # Valid URL with subdomain\n        self.assertTrue(is_valid_path('www.example.com'))\n    \n    def test_valid_multi_level_subdomain(self):\n        # Valid URL with multi-level subdomain\n        self.assertTrue(is_valid_path('sub.example.com'))\n    \n    def test_valid_tld_with_dot(self):\n        # Valid URL with TLD containing dot (e.g., co.uk)\n        self.assertTrue(is_valid_path('example.co.uk'))\n    \n    def test_valid_path_slash(self):\n        # Valid URL with path\n        self.assertTrue(is_valid_path('example.com/path'))\n    \n    def test_valid_multi_path(self):\n        # Valid URL with multi-segment path\n        self.assertTrue(is_valid_path('example.com/path/to/something'))\n    \n    def test_valid_path_with_space(self):\n        # Valid URL with space in path\n        self.assertTrue(is_valid_path('example.com/path with space'))\n    \n    def test_valid_path_with_dots(self):\n        # Valid URL with dots in path\n        self.assertTrue(is_valid_path('example.com/path.with.dots'))\n    \n    def test_valid_path_with_hyphens(self):\n        # Valid URL with hyphens in path\n        self.assertTrue(is_valid_path('example.com/path-with-hyphens'))\n    \n    def test_valid_path_with_underscores(self):\n        # Valid URL with underscores in path\n        self.assertTrue(is_valid_path('example.com/path_with_underscores'))\n    \n    def test_valid_path_with_digits(self):\n        # Valid URL with digits in path\n        self.assertTrue(is_valid_path('example.com/123'))\n    \n    def test_valid_trailing_slash(self):\n        # Valid URL with trailing slash\n        self.assertTrue(is_valid_path('example.com/'))\n    \n    def test_valid_short_tld(self):\n        # Valid URL with short TLD (2 characters)\n        self.assertTrue(is_valid_path('a.io'))\n    \n    def test_valid_long_tld(self):\n        # Valid URL with long TLD (6 characters)\n        self.assertTrue(is_valid_path('example.abcdef'))\n    \n    def test_valid_hyphen_in_domain(self):\n        # Valid URL with hyphens in domain\n        self.assertTrue(is_valid_path('valid-hyphens.com'))\n    \n    def test_valid_leading_hyphen_in_domain(self):\n        # Valid URL with leading hyphen in domain\n        self.assertTrue(is_valid_path('-starts-with-hyphen.com'))\n    \n    def test_valid_trailing_hyphen_in_domain(self):\n        # Valid URL with trailing hyphen in domain\n        self.assertTrue(is_valid_path('ends-with-hyphen-.com'))\n    \n    def test_valid_consecutive_dots_in_domain(self):\n        # Valid URL with consecutive dots in domain\n        self.assertTrue(is_valid_path('dots..inside.com'))\n    \n    def test_valid_long_path(self):\n        # Valid URL with path of exactly 300 characters\n        long_path = 'a' * 300\n        self.assertTrue(is_valid_path('example.com/' + long_path))\n    \n    def test_invalid_empty_string(self):\n        # Empty string\n        self.assertFalse(is_valid_path(''))\n    \n    def test_invalid_no_dot(self):\n        # Missing dot in domain\n        self.assertFalse(is_valid_path('example'))\n    \n    def test_invalid_missing_domain(self):\n        # Missing domain and TLD\n        self.assertFalse(is_valid_path('http://'))\n    \n    def test_invalid_empty_domain(self):\n        # Empty domain part\n        self.assertFalse(is_valid_path('http://.com'))\n    \n    def test_invalid_missing_tld(self):\n        # Missing TLD\n        self.assertFalse(is_valid_path('example.'))\n    \n    def test_invalid_short_tld(self):\n        # TLD too short (1 character)\n        self.assertFalse(is_valid_path('example.a'))\n    \n    def test_invalid_long_tld(self):\n        # TLD too long (7 characters)\n        self.assertFalse(is_valid_path('example.abcdefg'))\n    \n    def test_invalid_char_in_domain(self):\n        # Invalid character in domain\n        self.assertFalse(is_valid_path('https://exa$mple.com'))\n    \n    def test_invalid_scheme(self):\n        # Invalid scheme (ftp)\n        self.assertFalse(is_valid_path('ftp://example.com'))\n    \n    def test_invalid_char_in_path(self):\n        # Invalid character in path (#)\n        self.assertFalse(is_valid_path('example.com/path#fragment'))\n    \n    def test_invalid_long_path(self):\n        # Path too long (301 characters)\n        long_path = 'a' * 301\n        self.assertFalse(is_valid_path('example.com/' + long_path))\n    \n    def test_invalid_port(self):\n        # Port not allowed\n        self.assertFalse(is_valid_path('http://example.com:80'))\n    \n    def test_invalid_query_string(self):\n        # Query string not allowed\n        self.assertFalse(is_valid_path('example.com?query=param'))\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 34, "task_id": "2f1844f4"}
{"test": "import unittest\n\nclass TestExtractHtmlElements(unittest.TestCase):\n\n    def test_simple_tag(self):\n        # Test with a simple HTML tag\n        document = '<div>'\n        result = extract_html_elements(document)\n        self.assertEqual(result, ['div'])\n\n    def test_multiple_tags(self):\n        # Test with multiple consecutive tags\n        document = '<div><p>'\n        result = extract_html_elements(document)\n        self.assertEqual(result, ['div', 'p'])\n\n    def test_tag_with_attributes(self):\n        # Test tag with attributes\n        document = '<a href=\\\"https://example.com\\\">'\n        result = extract_html_elements(document)\n        self.assertEqual(result, ['a href=\\\"https://example.com\\\"'])\n\n    def test_tag_with_gt_in_attribute(self):\n        # Test tag containing '>' in attribute\n        document = '<a href=\\\">\\\">'\n        result = extract_html_elements(document)\n        self.assertEqual(result, ['a href=\\\"', '\\\"'])\n\n    def test_empty_string(self):\n        # Test empty input string\n        document = ''\n        result = extract_html_elements(document)\n        self.assertEqual(result, [])\n\n    def test_no_tags(self):\n        # Test string with no HTML tags\n        document = 'Hello, World!'\n        result = extract_html_elements(document)\n        self.assertEqual(result, [])\n\n    def test_incomplete_tag_only_open(self):\n        # Test string with only '<' character\n        document = '<'\n        result = extract_html_elements(document)\n        self.assertEqual(result, [])\n\n    def test_incomplete_tag_no_close(self):\n        # Test tag missing closing '>'\n        document = '<div'\n        result = extract_html_elements(document)\n        self.assertEqual(result, [])\n\n    def test_tag_100_chars(self):\n        # Test tag with exactly 100 characters inside\n        inner = 'a' * 100\n        document = '<' + inner + '>'\n        result = extract_html_elements(document)\n        self.assertEqual(result, [inner])\n\n    def test_tag_101_chars(self):\n        # Test tag with 101 characters (exceeds pattern limit)\n        inner = 'a' * 101\n        document = '<' + inner + '>'\n        result = extract_html_elements(document)\n        self.assertEqual(result, [])\n\n    def test_nested_tags(self):\n        # Test nested HTML tags\n        document = '<html><body><div class=\\\"container\\\">Content</div></body></html>'\n        result = extract_html_elements(document)\n        expected = ['html', 'body', 'div class=\\\"container\\\"', '/div', '/body', '/html']\n        self.assertEqual(result, expected)\n\n    def test_mixed_tags_and_text(self):\n        # Test string with mixed tags and text\n        document = '<h1>Title</h1><p>Paragraph</p>'\n        result = extract_html_elements(document)\n        expected = ['h1', '/h1', 'p', '/p']\n        self.assertEqual(result, expected)\n\n    def test_self_closing_tag(self):\n        # Test self-closing tag\n        document = '<br />'\n        result = extract_html_elements(document)\n        self.assertEqual(result, ['br /'])\n\n    def test_tag_with_newline(self):\n        # Test tag spanning multiple lines\n        document = '<div\\\\nclass=\\\"test\\\">'\n        result = extract_html_elements(document)\n        self.assertEqual(result, ['div\\\\nclass=\\\"test\\\"'])\n\n    def test_large_input(self):\n        # Test large input with many tags\n        document = '<a>' * 10000\n        result = extract_html_elements(document)\n        self.assertEqual(result, ['a'] * 10000)\n\n    def test_none_input(self):\n        # Test None input (invalid type)\n        with self.assertRaises(TypeError):\n            extract_html_elements(None)\n\n    def test_integer_input(self):\n        # Test integer input (invalid type)\n        with self.assertRaises(TypeError):\n            extract_html_elements(0)\n\n    def test_negative_integer_input(self):\n        # Test negative integer input (invalid type)\n        with self.assertRaises(TypeError):\n            extract_html_elements(-1)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 19, "task_id": "49574c4d"}
{"test": "import unittest\n\nclass TestFindHtmlTags(unittest.TestCase):\n    \n    def test_case_1(self):\n        # Test simple tag without attributes\n        html = '<div>'\n        result = find_html_tags(html)\n        self.assertEqual(result, ['div'])\n    \n    def test_case_2(self):\n        # Test tag with attributes\n        html = '<a href=\"example.com\">'\n        result = find_html_tags(html)\n        self.assertEqual(result, ['a href=\"example.com\"'])\n    \n    def test_case_3(self):\n        # Test self-closing tag\n        html = '<img src=\"image.jpg\" />'\n        result = find_html_tags(html)\n        self.assertEqual(result, ['img src=\"image.jpg\" /'])\n    \n    def test_case_4(self):\n        # Test multiple tags in the same string\n        html = '<div><p>Hello</p></div>'\n        result = find_html_tags(html)\n        self.assertEqual(result, ['div', 'p', '/p', '/div'])\n    \n    def test_case_5(self):\n        # Test empty string\n        html = ''\n        result = find_html_tags(html)\n        self.assertEqual(result, [])\n    \n    def test_case_6(self):\n        # Test string with no tags\n        html = 'This is a text without tags.'\n        result = find_html_tags(html)\n        self.assertEqual(result, [])\n    \n    def test_case_7(self):\n        # Test tag with exactly 100 characters\n        html = '<' + 'a' * 100 + '>'\n        result = find_html_tags(html)\n        self.assertEqual(result, ['a' * 100])\n    \n    def test_case_8(self):\n        # Test tag with 101 characters (exceeding pattern limit)\n        html = '<' + 'a' * 101 + '>'\n        result = find_html_tags(html)\n        self.assertEqual(result, [])\n    \n    def test_case_9(self):\n        # Test tag containing a newline\n        html = '<a\\nhref>'\n        result = find_html_tags(html)\n        self.assertEqual(result, ['a\\nhref'])\n    \n    def test_case_10(self):\n        # Test tag with '>' in attribute value (pattern breaks at first '>')\n        html = '<div title=\"some>thing\">'\n        result = find_html_tags(html)\n        self.assertEqual(result, ['div title=\"some'])\n    \n    def test_case_11(self):\n        # Test unclosed tag (no '>')\n        html = '<div'\n        result = find_html_tags(html)\n        self.assertEqual(result, [])\n    \n    def test_case_12(self):\n        # Test single-character tag\n        html = '<a>'\n        result = find_html_tags(html)\n        self.assertEqual(result, ['a'])\n    \n    def test_case_13(self):\n        # Test multiple tags including one exceeding length limit\n        html = '<tag1> <' + 'a' * 101 + '> <tag2>'\n        result = find_html_tags(html)\n        self.assertEqual(result, ['tag1', 'tag2'])\n    \n    def test_case_14(self):\n        # Test multi-line tag with attributes\n        html = \"\"\"<div\nclass=\"example\"\nid=\"test\">\"\"\"\n        result = find_html_tags(html)\n        self.assertEqual(result, ['div\\nclass=\"example\"\\nid=\"test\"'])\n", "num_test_cases": 14, "task_id": "87c1f587"}
{"test": "import unittest\nfrom solution import detect_html_tags\n\nclass TestDetectHtmlTags(unittest.TestCase):\n\n    def test_simple_tag(self):\n        # Test a single simple tag\n        html = '<div>'\n        result = detect_html_tags(html)\n        self.assertEqual(result, ['div'])\n\n    def test_tag_with_attributes(self):\n        # Test a tag with attributes\n        html = '<a href=\"https://example.com\">'\n        result = detect_html_tags(html)\n        self.assertEqual(result, ['a href=\"https://example.com\"'])\n\n    def test_self_closing_tag(self):\n        # Test a self-closing tag\n        html = '<img src=\"image.jpg\" />'\n        result = detect_html_tags(html)\n        self.assertEqual(result, ['img src=\"image.jpg\" /'])\n\n    def test_multiple_tags(self):\n        # Test multiple tags (nested and adjacent)\n        html = '<html><body><h1>Title</h1><p>Paragraph</p></body></html>'\n        result = detect_html_tags(html)\n        self.assertEqual(result, ['html', 'body', 'h1', '/h1', 'p', '/p', '/body', '/html'])\n\n    def test_no_tags(self):\n        # Test a string with no HTML tags\n        html = 'This is plain text without any HTML tags.'\n        result = detect_html_tags(html)\n        self.assertEqual(result, [])\n\n    def test_empty_string(self):\n        # Test an empty input string\n        html = ''\n        result = detect_html_tags(html)\n        self.assertEqual(result, [])\n\n    def test_tag_with_newline(self):\n        # Test a tag that spans multiple lines\n        html = '<div\\nclass=\"container\"\\nid=\"main\">'\n        result = detect_html_tags(html)\n        self.assertEqual(result, ['div\\nclass=\"container\"\\nid=\"main\"'])\n\n    def test_tag_with_100_chars(self):\n        # Test a tag with exactly 100 characters inside\n        inner = 'a' * 100\n        html = f'<{inner}>'\n        result = detect_html_tags(html)\n        self.assertEqual(result, [inner])\n\n    def test_tag_with_101_chars(self):\n        # Test a tag with 101 characters inside (should not match)\n        inner = 'a' * 101\n        html = f'<{inner}>'\n        result = detect_html_tags(html)\n        self.assertEqual(result, [])\n\n    def test_unclosed_tag(self):\n        # Test an unclosed tag (should not match)\n        html = '<div'\n        result = detect_html_tags(html)\n        self.assertEqual(result, [])\n\n    def test_quoted_gt(self):\n        # Test a tag containing quoted '>' (should break at first '>')\n        html = '<div class=\">\">'\n        result = detect_html_tags(html)\n        self.assertEqual(result, ['div class=\"'])\n\n    def test_comment_and_doctype(self):\n        # Test comment and doctype (should be captured as tags)\n        html = '<!-- comment --><!DOCTYPE html>'\n        result = detect_html_tags(html)\n        self.assertEqual(result, ['!-- comment --', '!DOCTYPE html'])", "num_test_cases": 12, "task_id": "3ee24789"}
{"test": "import unittest\nimport re\n\nclass TestCases(unittest.TestCase):\n    def test_basic_tag(self):\n        # Test with a single basic HTML tag.\n        result = extract_html_tags('<div>')\n        self.assertEqual(result, ['div'])\n\n    def test_multiple_tags(self):\n        # Test with multiple HTML tags.\n        result = extract_html_tags('<div><span>hello</span></div>')\n        self.assertEqual(result, ['div', 'span', '/span', '/div'])\n\n    def test_tag_with_attributes(self):\n        # Test with a tag containing attributes.\n        result = extract_html_tags('<a href=\"example.com\">')\n        self.assertEqual(result, ['a href=\"example.com\"'])\n\n    def test_tag_with_gt_in_attribute(self):\n        # Test a tag with '>' in an attribute value (should stop at first '>').\n        result = extract_html_tags('<a href=\"index.php?p=1>2\">')\n        self.assertEqual(result, ['a href=\"index.php?p=1'])\n\n    def test_self_closing_tag(self):\n        # Test a self-closing tag.\n        result = extract_html_tags('<br/>')\n        self.assertEqual(result, ['br/'])\n\n    def test_empty_string(self):\n        # Test with an empty input string.\n        result = extract_html_tags('')\n        self.assertEqual(result, [])\n\n    def test_no_tags(self):\n        # Test a string with no HTML tags.\n        result = extract_html_tags('This is plain text.')\n        self.assertEqual(result, [])\n\n    def test_tag_with_100_chars(self):\n        # Test a tag with exactly 100 characters inside.\n        tag_content = 'a' * 100\n        html = f'<{tag_content}>'\n        result = extract_html_tags(html)\n        self.assertEqual(result, [tag_content])\n\n    def test_tag_with_101_chars(self):\n        # Test a tag exceeding 100 characters (should not match).\n        tag_content = 'a' * 101\n        html = f'<{tag_content}>'\n        result = extract_html_tags(html)\n        self.assertEqual(result, [])\n\n    def test_comment_tag(self):\n        # Test with an HTML comment (captures only the opening part).\n        result = extract_html_tags('<!-- comment -->')\n        self.assertEqual(result, ['!--'])\n\n    def test_multiline_tag(self):\n        # Test a tag spanning multiple lines.\n        html = \"\"\"<div \nclass=\"example\">\"\"\"\n        result = extract_html_tags(html)\n        self.assertEqual(result, ['div \\nclass=\"example\"'])\n\n    def test_tag_with_single_char(self):\n        # Test the smallest valid tag (one character inside).\n        result = extract_html_tags('<a>')\n        self.assertEqual(result, ['a'])\n\n    def test_mixed_valid_invalid_tags(self):\n        # Test mixed valid tags and invalid patterns.\n        result = extract_html_tags('<a>invalid tag: <<>> <c>')\n        self.assertEqual(result, ['a', '<', 'c'])\n\n    def test_tag_with_unquoted_attribute(self):\n        # Test a tag with an unquoted attribute.\n        result = extract_html_tags('<div class=example>')\n        self.assertEqual(result, ['div class=example'])", "num_test_cases": 14, "task_id": "5f8aad5b"}
{"test": "import unittest\n\nclass TestFindHtmlTags(unittest.TestCase):\n    \n    def test_simple_tag(self):\n        # Test a single simple HTML tag\n        html = '<div>'\n        result = find_html_tags(html)\n        self.assertEqual(result, ['div'])\n    \n    def test_self_closing_tag(self):\n        # Test self-closing tag\n        html = '<br />'\n        result = find_html_tags(html)\n        self.assertEqual(result, ['br /'])\n    \n    def test_multiple_tags(self):\n        # Test multiple tags in sequence\n        html = '<div><p><a>'\n        result = find_html_tags(html)\n        self.assertEqual(result, ['div', 'p', 'a'])\n    \n    def test_nested_tags(self):\n        # Test nested tags\n        html = '<div><p>Hello</p></div>'\n        result = find_html_tags(html)\n        self.assertEqual(result, ['div', 'p', '/p', '/div'])\n    \n    def test_tags_with_attributes(self):\n        # Test tags with attributes\n        html = '<a href=\\\"example.com\\\"> <img src=\\\"image.jpg\\\"/>'\n        result = find_html_tags(html)\n        self.assertEqual(result, ['a href=\\\"example.com\\\"', 'img src=\\\"image.jpg\\\"/'])\n    \n    def test_empty_string(self):\n        # Test empty input string\n        html = ''\n        result = find_html_tags(html)\n        self.assertEqual(result, [])\n    \n    def test_no_tags(self):\n        # Test string with no HTML tags\n        html = 'This is plain text.'\n        result = find_html_tags(html)\n        self.assertEqual(result, [])\n    \n    def test_tag_with_newline(self):\n        # Test tag containing newline characters\n        html = '<div\\nclass=\\\"example\\\">'\n        result = find_html_tags(html)\n        self.assertEqual(result, ['div\\nclass=\\\"example\\\"'])\n    \n    def test_tag_with_quoted_gt(self):\n        # Test tag containing quoted '>' character\n        html = '<a href=\\\">\\\">'\n        result = find_html_tags(html)\n        self.assertEqual(result, ['a href=\\\">'])\n    \n    def test_tag_max_length(self):\n        # Test tag with exactly 100 characters inside\n        tag_content = 'a' * 100\n        html = '<' + tag_content + '>'\n        result = find_html_tags(html)\n        self.assertEqual(result, [tag_content])\n    \n    def test_tag_exceeds_max_length(self):\n        # Test tag exceeding 100 characters inside\n        tag_content = 'a' * 101\n        html = '<' + tag_content + '>'\n        result = find_html_tags(html)\n        self.assertEqual(result, [])\n    \n    def test_comment_tag(self):\n        # Test HTML comment\n        html = '<!-- comment -->'\n        result = find_html_tags(html)\n        self.assertEqual(result, ['!--'])\n    \n    def test_doctype(self):\n        # Test DOCTYPE declaration\n        html = '<!DOCTYPE html>'\n        result = find_html_tags(html)\n        self.assertEqual(result, ['!DOCTYPE html'])\n    \n    def test_incomplete_tag(self):\n        # Test incomplete tag (no closing '>')\n        html = '<div'\n        result = find_html_tags(html)\n        self.assertEqual(result, [])\n    \n    def test_mixed_content(self):\n        # Test mixed content with text and tags\n        html = 'Text<div>More <b>text</b></div>'\n        result = find_html_tags(html)\n        self.assertEqual(result, ['div', 'b', '/b', '/div'])\n    \n    def test_non_string_input_int(self):\n        # Test non-string input (integer)\n        with self.assertRaises(TypeError):\n            find_html_tags(123)\n    \n    def test_non_string_input_none(self):\n        # Test non-string input (None)\n        with self.assertRaises(TypeError):\n            find_html_tags(None)\n    \n    def test_non_string_input_list(self):\n        # Test non-string input (list)\n        with self.assertRaises(TypeError):\n            find_html_tags(['<div>'])\n    \n    def test_tag_with_special_chars(self):\n        # Test tag with special characters\n        html = '<tag with=\\\"special@chars.com\\\">'\n        result = find_html_tags(html)\n        self.assertEqual(result, ['tag with=\\\"special@chars.com\\\"'])\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 20, "task_id": "9f79f75e"}
{"test": "import unittest\nimport re\n\nclass TestGetHtmlTags(unittest.TestCase):\n\n    def test_simple_tag(self):\n        # Test with a single basic tag.\n        html = '<div>'\n        result = get_html_tags(html)\n        self.assertEqual(result, ['div'])\n\n    def test_multiple_tags(self):\n        # Test with multiple tags in sequence.\n        html = '<div><p>hello</p></div>'\n        result = get_html_tags(html)\n        self.assertEqual(result, ['div', 'p', '/p', '/div'])\n\n    def test_tag_with_attributes(self):\n        # Test with a tag containing attributes.\n        html = '<a href=\"example.com\">'\n        result = get_html_tags(html)\n        self.assertEqual(result, ['a href=\"example.com\"'])\n\n    def test_self_closing_tag(self):\n        # Test with a self-closing tag.\n        html = '<br />'\n        result = get_html_tags(html)\n        self.assertEqual(result, ['br /'])\n\n    def test_no_tags(self):\n        # Test with input containing no tags.\n        html = 'Hello, World!'\n        result = get_html_tags(html)\n        self.assertEqual(result, [])\n\n    def test_empty_string(self):\n        # Test with empty input string.\n        html = ''\n        result = get_html_tags(html)\n        self.assertEqual(result, [])\n\n    def test_tag_with_newline(self):\n        # Test with a tag containing a newline character.\n        html = '<div\\nclass=\"example\">'\n        result = get_html_tags(html)\n        self.assertEqual(result, ['div\\nclass=\"example\"'])\n\n    def test_comment_and_doctype(self):\n        # Test with comment and doctype tags.\n        html = '<!-- comment --><!DOCTYPE html>'\n        result = get_html_tags(html)\n        self.assertEqual(result, ['!-- comment --', '!DOCTYPE html'])\n\n    def test_tag_exactly_100_chars(self):\n        # Test with a tag containing exactly 100 characters.\n        tag_content = 'a' * 100\n        html = f'<{tag_content}>'\n        result = get_html_tags(html)\n        self.assertEqual(result, [tag_content])\n\n    def test_tag_101_chars(self):\n        # Test with a tag containing 101 characters (should not match).\n        tag_content = 'a' * 101\n        html = f'<{tag_content}>'\n        result = get_html_tags(html)\n        self.assertEqual(result, [])\n\n    def test_tag_with_gt_inside(self):\n        # Test with a tag containing '>' inside (invalid HTML).\n        html = '<div class=\">\">'\n        result = get_html_tags(html)\n        self.assertEqual(result, ['div class=\"'])\n\n    def test_tag_with_special_characters(self):\n        # Test with non-ASCII characters in tag.\n        html = '<日本語>'\n        result = get_html_tags(html)\n        self.assertEqual(result, ['日本語'])\n\n    def test_tag_with_exactly_one_char(self):\n        # Test with a single-character tag.\n        html = '<a>'\n        result = get_html_tags(html)\n        self.assertEqual(result, ['a'])\n\n    def test_tag_with_zero_char(self):\n        # Test with an empty tag (should not match).\n        html = '<>'\n        result = get_html_tags(html)\n        self.assertEqual(result, [])\n\n    def test_nested_tags(self):\n        # Test with nested tags.\n        html = '<div><span>Text</span></div>'\n        result = get_html_tags(html)\n        self.assertEqual(result, ['div', 'span', '/span', '/div'])\n\n    def test_multiple_tags_with_invalid(self):\n        # Test with valid and invalid (too long) tags.\n        tag_content = 'a' * 101\n        html = f'<div></div><{tag_content}>'\n        result = get_html_tags(html)\n        self.assertEqual(result, ['div', '/div'])", "num_test_cases": 16, "task_id": "f08a151e"}
{"test": "import unittest\n\nclass TestExtractHtmlTags(unittest.TestCase):\n    def test_basic_tags(self):\n        \"\"\"Test with a string containing multiple basic tags.\"\"\"\n        html_string = '<html><body><p>Hello</p></body></html>'\n        expected = ['html', 'body', 'p', '/p', '/body', '/html']\n        self.assertEqual(extract_html_tags(html_string), expected)\n\n    def test_empty_string(self):\n        \"\"\"Test with an empty string.\"\"\"\n        self.assertEqual(extract_html_tags(''), [])\n\n    def test_no_tags(self):\n        \"\"\"Test with a string that contains no HTML tags.\"\"\"\n        self.assertEqual(extract_html_tags('Hello, World!'), [])\n\n    def test_self_closing_tag(self):\n        \"\"\"Test with a self-closing tag.\"\"\"\n        html_string = '<img src=\"image.jpg\" />'\n        expected = ['img src=\"image.jpg\" /']\n        self.assertEqual(extract_html_tags(html_string), expected)\n\n    def test_tag_with_attributes(self):\n        \"\"\"Test with a tag containing attributes.\"\"\"\n        html_string = '<a href=\"http://example.com\">Link</a>'\n        expected = ['a href=\"http://example.com\"', '/a']\n        self.assertEqual(extract_html_tags(html_string), expected)\n\n    def test_max_length_tag(self):\n        \"\"\"Test with a tag containing exactly 100 non-'>' characters.\"\"\"\n        inner_content = 'a' * 100\n        html_string = f'<{inner_content}>'\n        self.assertEqual(extract_html_tags(html_string), [inner_content])\n\n    def test_exceed_max_length_tag(self):\n        \"\"\"Test with a tag exceeding 100 non-'>' characters.\"\"\"\n        inner_content = 'a' * 101\n        html_string = f'<{inner_content}>'\n        self.assertEqual(extract_html_tags(html_string), [])\n\n    def test_mixed_valid_invalid_tags(self):\n        \"\"\"Test with a mix of valid tags and an invalid (too long) tag.\"\"\"\n        html_string = '<div>Hello</div><' + 'a'*101 + '>'\n        expected = ['div', '/div']\n        self.assertEqual(extract_html_tags(html_string), expected)\n\n    def test_tag_with_newlines(self):\n        \"\"\"Test with a tag containing newline characters.\"\"\"\n        html_string = '<div\\nclass=\"example\"\\n>'\n        expected = ['div\\nclass=\"example\"\\n']\n        self.assertEqual(extract_html_tags(html_string), expected)\n\n    def test_multiple_tags_with_text(self):\n        \"\"\"Test with multiple tags and text content.\"\"\"\n        html_string = '<h1>Title</h1><p>Paragraph</p>'\n        expected = ['h1', '/h1', 'p', '/p']\n        self.assertEqual(extract_html_tags(html_string), expected)\n\n    def test_none_input(self):\n        \"\"\"Test with None input (invalid type).\"\"\"\n        with self.assertRaises(TypeError):\n            extract_html_tags(None)\n\n    def test_non_string_input(self):\n        \"\"\"Test with non-string input (integer).\"\"\"\n        with self.assertRaises(TypeError):\n            extract_html_tags(123)\n\n    def test_large_input_string(self):\n        \"\"\"Test with a very large input string containing valid tags.\"\"\"\n        long_content = 'a' * 1000000\n        html_string = f'<div>{long_content}</div>'\n        expected = ['div', '/div']\n        self.assertEqual(extract_html_tags(html_string), expected)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 13, "task_id": "4fac0074"}
{"test": "import unittest\n\nclass TestIdentifyHtmlTags(unittest.TestCase):\n    \n    def test_simple_tag(self):\n        # Test with a simple tag\n        content = \"<div>\"\n        expected = ['div']\n        self.assertEqual(identify_html_tags(content), expected)\n    \n    def test_multiple_tags(self):\n        # Test with multiple tags\n        content = \"<div><p>Hello</p></div>\"\n        expected = ['div', 'p', '/p', '/div']\n        self.assertEqual(identify_html_tags(content), expected)\n    \n    def test_tag_with_attributes(self):\n        # Test tag with attributes\n        content = '<a href=\"example.com\">Link</a>'\n        expected = ['a href=\"example.com\"', '/a']\n        self.assertEqual(identify_html_tags(content), expected)\n    \n    def test_self_closing_tag(self):\n        # Test self-closing tag\n        content = '<br />'\n        expected = ['br /']\n        self.assertEqual(identify_html_tags(content), expected)\n    \n    def test_empty_content(self):\n        # Test empty content\n        content = ''\n        expected = []\n        self.assertEqual(identify_html_tags(content), expected)\n    \n    def test_content_with_no_tags(self):\n        # Test content with no tags\n        content = 'Hello, World!'\n        expected = []\n        self.assertEqual(identify_html_tags(content), expected)\n    \n    def test_tag_with_newline(self):\n        # Test tag with newline\n        content = '<div\\nclass=\"container\">'\n        expected = ['div\\nclass=\"container\"']\n        self.assertEqual(identify_html_tags(content), expected)\n    \n    def test_tag_with_100_characters(self):\n        # Test tag with exactly 100 characters inside\n        content = '<' + ('a' * 100) + '>'\n        expected = ['a' * 100]\n        self.assertEqual(identify_html_tags(content), expected)\n    \n    def test_tag_with_101_characters(self):\n        # Test tag with 101 characters inside (should not match)\n        content = '<' + ('a' * 101) + '>'\n        expected = []\n        self.assertEqual(identify_html_tags(content), expected)\n    \n    def test_unclosed_tag(self):\n        # Test unclosed tag (no '>')\n        content = '<div'\n        expected = []\n        self.assertEqual(identify_html_tags(content), expected)\n    \n    def test_malformed_tag_with_extra_bracket(self):\n        # Test malformed tag: only closing bracket, no opening\n        content = 'div>'\n        expected = []\n        self.assertEqual(identify_html_tags(content), expected)\n    \n    def test_mixed_text_and_tags(self):\n        # Test mixed text and tags\n        content = 'This is a <b>bold</b> statement.'\n        expected = ['b', '/b']\n        self.assertEqual(identify_html_tags(content), expected)\n    \n    def test_comment_tag(self):\n        # Test comment tag\n        content = '<!-- comment -->'\n        expected = ['!-- comment --']\n        self.assertEqual(identify_html_tags(content), expected)\n    \n    def test_cdata_section(self):\n        # Test CDATA section (which contains a tag inside)\n        content = '<![CDATA[<foo>]]>'\n        expected = ['![CDATA[<foo']\n        self.assertEqual(identify_html_tags(content), expected)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 14, "task_id": "bf57155c"}
{"test": "import unittest\n\nclass TestCases(unittest.TestCase):\n    def test_case_1(self):\n        # Test with empty string\n        self.assertEqual(grab_html_tags(''), [])\n\n    def test_case_2(self):\n        # Test with no tags\n        self.assertEqual(grab_html_tags('Hello, World!'), [])\n\n    def test_case_3(self):\n        # Test with a simple tag\n        self.assertEqual(grab_html_tags('<div>'), ['div'])\n\n    def test_case_4(self):\n        # Test with a closing tag\n        self.assertEqual(grab_html_tags('</div>'), ['/div'])\n\n    def test_case_5(self):\n        # Test with a self-closing tag\n        self.assertEqual(grab_html_tags('<br/>'), ['br/'])\n\n    def test_case_6(self):\n        # Test with a tag containing attributes\n        self.assertEqual(grab_html_tags('<a href=\"#\">'), ['a href=\"#'])\n\n    def test_case_7(self):\n        # Test with a tag containing a newline\n        self.assertEqual(grab_html_tags('<div\\n>'), ['div\\n'])\n\n    def test_case_8(self):\n        # Test with an HTML comment\n        self.assertEqual(grab_html_tags('<!-- comment -->'), ['!-- comment --'])\n\n    def test_case_9(self):\n        # Test with a script tag containing '<' character\n        html = '<script>if (a< b) {}</script>'\n        self.assertEqual(grab_html_tags(html), ['script', ' b) {}</script'])\n\n    def test_case_10(self):\n        # Test with a tag of exactly 100 characters\n        inner = 'a' * 100\n        self.assertEqual(grab_html_tags('<' + inner + '>'), [inner])\n\n    def test_case_11(self):\n        # Test with a tag of 101 characters\n        inner = 'a' * 101\n        self.assertEqual(grab_html_tags('<' + inner + '>'), [])\n\n    def test_case_12(self):\n        # Test with None input (non-string)\n        with self.assertRaises(TypeError):\n            grab_html_tags(None)\n\n    def test_case_13(self):\n        # Test with integer input (non-string)\n        with self.assertRaises(TypeError):\n            grab_html_tags(123)\n\n    def test_case_14(self):\n        # Test with unclosed tag\n        self.assertEqual(grab_html_tags('<div'), [])\n\n    def test_case_15(self):\n        # Test with multiple nested tags\n        html = '<div><p>hello</p></div>'\n        self.assertEqual(grab_html_tags(html), ['div', 'p', '/p', '/div'])\n\n    def test_case_16(self):\n        # Test with mixed case tag\n        self.assertEqual(grab_html_tags('<DIV>'), ['DIV'])\n\n    def test_case_17(self):\n        # Test with tag containing spaces\n        self.assertEqual(grab_html_tags('<   >'), ['   '])\n\n    def test_case_18(self):\n        # Test with doctype declaration\n        self.assertEqual(grab_html_tags('<!DOCTYPE html>'), ['!DOCTYPE html'])\n\n    def test_case_19(self):\n        # Test with attribute containing '>'\n        self.assertEqual(grab_html_tags('<a title=\">\">'), ['a title=\"'])\n\n    def test_case_20(self):\n        # Test with non-tag '<' and '>'\n        self.assertEqual(grab_html_tags('a < b > c'), [' b '])", "num_test_cases": 20, "task_id": "4d5d343b"}
{"test": "import unittest\n\nclass TestCases(unittest.TestCase):\n\n    def test_case_1(self):\n        # Valid typical log entry\n        log_text = 'INFO[2023-01-01T12:00:00] : User logged in'\n        expected = ('INFO', '2023-01-01T12:00:00', 'User logged in')\n        self.assertEqual(extract_log_data(log_text), expected)\n\n    def test_case_2(self):\n        # Valid with empty message\n        log_text = 'WARN[2023-01-01T12:00:00] : '\n        expected = ('WARN', '2023-01-01T12:00:00', '')\n        self.assertEqual(extract_log_data(log_text), expected)\n\n    def test_case_3(self):\n        # Valid with spaces in log_level and message\n        log_text = '   INFO   [2023-01-01] :   message   '\n        expected = ('   INFO   ', '2023-01-01', '  message   ')\n        self.assertEqual(extract_log_data(log_text), expected)\n\n    def test_case_4(self):\n        # Valid with special characters in log_level\n        log_text = 'INFO!@#[timestamp] : message'\n        expected = ('INFO!@#', 'timestamp', 'message')\n        self.assertEqual(extract_log_data(log_text), expected)\n\n    def test_case_5(self):\n        # Valid with space in timestamp\n        log_text = 'INFO[2023-01-01 12:00:00] : message'\n        expected = ('INFO', '2023-01-01 12:00:00', 'message')\n        self.assertEqual(extract_log_data(log_text), expected)\n\n    def test_case_6(self):\n        # Valid with newline in message\n        log_text = 'INFO[2023-01-01] : line1\\nline2'\n        expected = ('INFO', '2023-01-01', 'line1\\nline2')\n        self.assertEqual(extract_log_data(log_text), expected)\n\n    def test_case_7(self):\n        # Valid with log_level consisting of spaces\n        log_text = '   [2023-01-01] : message'\n        expected = ('   ', '2023-01-01', 'message')\n        self.assertEqual(extract_log_data(log_text), expected)\n\n    def test_case_8(self):\n        # Valid with empty timestamp\n        log_text = 'INFO[] : message'\n        expected = ('INFO', '', 'message')\n        self.assertEqual(extract_log_data(log_text), expected)\n\n    def test_case_9(self):\n        # Valid with inner bracket in timestamp\n        log_text = 'INFO[2023-01-01 [inner]] : message'\n        expected = ('INFO', '2023-01-01 [inner', 'message')\n        self.assertEqual(extract_log_data(log_text), expected)\n\n    def test_case_10(self):\n        # Invalid: log_level missing (starts with '[')\n        log_text = '[2023-01-01] : message'\n        self.assertIsNone(extract_log_data(log_text))\n\n    def test_case_11(self):\n        # Invalid: missing opening bracket\n        log_text = 'INFO2023-01-01] : message'\n        self.assertIsNone(extract_log_data(log_text))\n\n    def test_case_12(self):\n        # Invalid: missing closing bracket\n        log_text = 'INFO[2023-01-01 : message'\n        self.assertIsNone(extract_log_data(log_text))\n\n    def test_case_13(self):\n        # Invalid: missing colon\n        log_text = 'INFO[2023-01-01] message'\n        self.assertIsNone(extract_log_data(log_text))\n\n    def test_case_14(self):\n        # Invalid: empty string\n        log_text = ''\n        self.assertIsNone(extract_log_data(log_text))\n\n    def test_case_15(self):\n        # Invalid: None (non-string input)\n        with self.assertRaises(TypeError):\n            extract_log_data(None)\n\n    def test_case_16(self):\n        # Invalid: integer input (non-string)\n        with self.assertRaises(TypeError):\n            extract_log_data(123)\n\n    def test_case_17(self):\n        # Invalid: multiple colons in message\n        log_text = 'INFO[2023-01-01] : message : with : colons'\n        expected = ('INFO', '2023-01-01', 'message : with : colons')\n        self.assertEqual(extract_log_data(log_text), expected)\n\n    def test_case_18(self):\n        # Invalid: extra spaces around colon\n        log_text = 'INFO[2023-01-01]   :   message'\n        expected = ('INFO', '2023-01-01', '  message')\n        self.assertEqual(extract_log_data(log_text), expected)\n", "num_test_cases": 18, "task_id": "bd204a3d"}
{"test": "import unittest\n\nclass TestAnalyzeLogEntry(unittest.TestCase):\n    def test_valid_minimal(self):\n        \"\"\"Test minimal valid log entry.\"\"\"\n        entry = \"[t] L: m\"\n        self.assertEqual(analyze_log_entry(entry), ('t', 'L', 'm'))\n\n    def test_valid_maximal_lengths(self):\n        \"\"\"Test valid entry with max timestamp (23), log_level (10), message (1000).\"\"\"\n        timestamp = 'a' * 23\n        log_level = 'b' * 10\n        message = 'c' * 1000\n        entry = f\"[{timestamp}] {log_level}: {message}\"\n        self.assertEqual(analyze_log_entry(entry), (timestamp, log_level, message))\n\n    def test_valid_typical(self):\n        \"\"\"Test typical valid log entry.\"\"\"\n        entry = \"[2021-01-01 12:00:00] INFO: Application started\"\n        self.assertEqual(analyze_log_entry(entry), ('2021-01-01 12:00:00', 'INFO', 'Application started'))\n\n    def test_timestamp_too_long(self):\n        \"\"\"Test timestamp exceeding 23 characters.\"\"\"\n        entry = \"[\" + 'a' * 24 + \"] L: m\"\n        self.assertIsNone(analyze_log_entry(entry))\n\n    def test_timestamp_empty(self):\n        \"\"\"Test empty timestamp.\"\"\"\n        entry = \"[] L: m\"\n        self.assertIsNone(analyze_log_entry(entry))\n\n    def test_log_level_too_long(self):\n        \"\"\"Test log_level exceeding 10 characters.\"\"\"\n        entry = \"[ts] \" + 'b' * 11 + \": m\"\n        self.assertIsNone(analyze_log_entry(entry))\n\n    def test_log_level_empty(self):\n        \"\"\"Test empty log_level.\"\"\"\n        entry = \"[ts] : m\"\n        self.assertIsNone(analyze_log_entry(entry))\n\n    def test_message_1001_chars(self):\n        \"\"\"Test message exceeding 1000 characters - should truncate to 1000.\"\"\"\n        entry = \"[ts] L: \" + 'c' * 1001\n        self.assertEqual(analyze_log_entry(entry), ('ts', 'L', 'c' * 1000))\n\n    def test_message_empty(self):\n        \"\"\"Test empty message.\"\"\"\n        entry = \"[ts] L: \"\n        self.assertIsNone(analyze_log_entry(entry))\n\n    def test_empty_entry(self):\n        \"\"\"Test empty log entry.\"\"\"\n        entry = \"\"\n        self.assertIsNone(analyze_log_entry(entry))\n\n    def test_missing_opening_bracket(self):\n        \"\"\"Test entry without opening bracket.\"\"\"\n        entry = \"ts] L: m\"\n        self.assertIsNone(analyze_log_entry(entry))\n\n    def test_missing_colon_after_level(self):\n        \"\"\"Test missing colon after log_level.\"\"\"\n        entry = \"[ts] L m\"\n        self.assertIsNone(analyze_log_entry(entry))\n\n    def test_missing_space_after_colon(self):\n        \"\"\"Test missing space after colon.\"\"\"\n        entry = \"[ts] L:m\"\n        self.assertIsNone(analyze_log_entry(entry))\n\n    def test_tab_after_colon(self):\n        \"\"\"Test tab instead of space after colon.\"\"\"\n        entry = \"[ts] L:\\tm\"\n        self.assertIsNone(analyze_log_entry(entry))\n\n    def test_log_level_with_space(self):\n        \"\"\"Test log_level containing space.\"\"\"\n        entry = \"[ts] LOG LEVEL: m\"\n        self.assertEqual(analyze_log_entry(entry), ('ts', 'LOG LEVEL', 'm'))\n\n    def test_log_level_with_newline(self):\n        \"\"\"Test log_level containing newline.\"\"\"\n        entry = \"[ts] LOG\\nLEVEL: m\"\n        self.assertEqual(analyze_log_entry(entry), ('ts', 'LOG\\nLEVEL', 'm'))\n\n    def test_timestamp_with_newline(self):\n        \"\"\"Test timestamp containing newline.\"\"\"\n        entry = \"[t\\ns] L: m\"\n        self.assertEqual(analyze_log_entry(entry), ('t\\ns', 'L', 'm'))\n\n    def test_message_with_newline(self):\n        \"\"\"Test message containing newline - captures until newline.\"\"\"\n        entry = \"[ts] L: m1\\nm2\"\n        self.assertEqual(analyze_log_entry(entry), ('ts', 'L', 'm1'))\n\n    def test_extra_text_after_message(self):\n        \"\"\"Test extra text after message - captured as part of message.\"\"\"\n        entry = \"[ts] L: message extra\"\n        self.assertEqual(analyze_log_entry(entry), ('ts', 'L', 'message extra'))\n\n    def test_non_printable_chars(self):\n        \"\"\"Test non-printable characters in all parts.\"\"\"\n        entry = \"[\\x00] \\x01: \\x02\"\n        self.assertEqual(analyze_log_entry(entry), ('\\x00', '\\x01', '\\x02'))\n\n    def test_timestamp_with_brackets(self):\n        \"\"\"Test timestamp containing brackets (non-closing bracket chars).\"\"\"\n        entry = \"[[a]] L: m\"\n        self.assertEqual(analyze_log_entry(entry), ('[a', 'L', 'm'))\n\n    def test_log_level_with_colon(self):\n        \"\"\"Test log_level containing colon - should fail.\"\"\"\n        entry = \"[ts] IN:FO: m\"\n        self.assertIsNone(analyze_log_entry(entry))", "num_test_cases": 22, "task_id": "71e14bc6"}
{"test": "import unittest\n\nclass TestExtractLogData(unittest.TestCase):\n\n    def test_valid_standard(self):\n        \"\"\"Test a standard log line with valid components.\"\"\"\n        log_line = \"[2020-01-01 12:00:00] INFO: User logged in\"\n        expected = (\"2020-01-01 12:00:00\", \"INFO\", \"User logged in\")\n        self.assertEqual(extract_log_data(log_line), expected)\n\n    def test_valid_min_timestamp(self):\n        \"\"\"Test timestamp at minimum length (1 character).\"\"\"\n        log_line = \"[a] B: c\"\n        expected = (\"a\", \"B\", \"c\")\n        self.assertEqual(extract_log_data(log_line), expected)\n\n    def test_valid_max_timestamp(self):\n        \"\"\"Test timestamp at maximum length (23 characters).\"\"\"\n        timestamp = 'a' * 23\n        log_line = f\"[{timestamp}] B: c\"\n        expected = (timestamp, \"B\", \"c\")\n        self.assertEqual(extract_log_data(log_line), expected)\n\n    def test_valid_min_log_level(self):\n        \"\"\"Test log level at minimum length (1 character).\"\"\"\n        log_line = \"[ts] l: msg\"\n        expected = (\"ts\", \"l\", \"msg\")\n        self.assertEqual(extract_log_data(log_line), expected)\n\n    def test_valid_max_log_level(self):\n        \"\"\"Test log level at maximum length (10 characters).\"\"\"\n        log_level = 'a' * 10\n        log_line = f\"[ts] {log_level}: msg\"\n        expected = (\"ts\", log_level, \"msg\")\n        self.assertEqual(extract_log_data(log_line), expected)\n\n    def test_valid_min_message(self):\n        \"\"\"Test message at minimum length (1 character).\"\"\"\n        log_line = \"[ts] l: m\"\n        expected = (\"ts\", \"l\", \"m\")\n        self.assertEqual(extract_log_data(log_line), expected)\n\n    def test_valid_max_message(self):\n        \"\"\"Test message at maximum length (1000 characters).\"\"\"\n        message = 'a' * 1000\n        log_line = f\"[ts] l: {message}\"\n        expected = (\"ts\", \"l\", message)\n        self.assertEqual(extract_log_data(log_line), expected)\n\n    def test_valid_message_with_newline(self):\n        \"\"\"Test message containing a newline (pattern stops at newline).\"\"\"\n        log_line = \"[ts] l: hello\\nworld\"\n        expected = (\"ts\", \"l\", \"hello\")\n        self.assertEqual(extract_log_data(log_line), expected)\n\n    def test_valid_message_with_special_chars(self):\n        \"\"\"Test message with special characters (colon, bracket).\"\"\"\n        log_line = \"[ts] l: This: is a {message} with ] special chars\"\n        expected = (\"ts\", \"l\", \"This: is a {message} with ] special chars\")\n        self.assertEqual(extract_log_data(log_line), expected)\n\n    def test_empty_string(self):\n        \"\"\"Test empty log line returns None.\"\"\"\n        self.assertIsNone(extract_log_data(\"\"))\n\n    def test_missing_opening_bracket(self):\n        \"\"\"Test missing opening bracket returns None.\"\"\"\n        log_line = \"2020-01-01 12:00:00] INFO: User logged in\"\n        self.assertIsNone(extract_log_data(log_line))\n\n    def test_missing_closing_bracket(self):\n        \"\"\"Test missing closing bracket returns None.\"\"\"\n        log_line = \"[2020-01-01 12:00:00 INFO: User logged in\"\n        self.assertIsNone(extract_log_data(log_line))\n\n    def test_missing_colon_after_log_level(self):\n        \"\"\"Test missing colon after log level returns None.\"\"\"\n        log_line = \"[2020-01-01 12:00:00] INFO User logged in\"\n        self.assertIsNone(extract_log_data(log_line))\n\n    def test_timestamp_too_long(self):\n        \"\"\"Test timestamp exceeding 23 characters returns None.\"\"\"\n        timestamp = 'a' * 24\n        log_line = f\"[{timestamp}] l: msg\"\n        self.assertIsNone(extract_log_data(log_line))\n\n    def test_log_level_too_long(self):\n        \"\"\"Test log level exceeding 10 characters returns None.\"\"\"\n        log_level = 'a' * 11\n        log_line = f\"[ts] {log_level}: msg\"\n        self.assertIsNone(extract_log_data(log_line))\n\n    def test_message_too_long(self):\n        \"\"\"Test message exceeding 1000 characters returns None.\"\"\"\n        message = 'a' * 1001\n        log_line = f\"[ts] l: {message}\"\n        self.assertIsNone(extract_log_data(log_line))\n\n    def test_message_too_short(self):\n        \"\"\"Test empty message (after colon) returns None.\"\"\"\n        log_line = \"[ts] l: \"\n        self.assertIsNone(extract_log_data(log_line))\n\n    def test_log_level_containing_colon(self):\n        \"\"\"Test log level containing colon returns None.\"\"\"\n        log_line = \"[ts] l:v: msg\"\n        self.assertIsNone(extract_log_data(log_line))\n\n    def test_extra_text_after_message(self):\n        \"\"\"Test extra text after message is included in the message group.\"\"\"\n        log_line = \"[ts] l: msg extra\"\n        expected = (\"ts\", \"l\", \"msg extra\")\n        self.assertEqual(extract_log_data(log_line), expected)\n\n    def test_timestamp_with_opening_bracket(self):\n        \"\"\"Test timestamp containing opening bracket (allowed).\"\"\"\n        log_line = \"[in[valid] l: msg\"\n        expected = (\"in[valid\", \"l\", \"msg\")\n        self.assertEqual(extract_log_data(log_line), expected)\n\n    def test_timestamp_containing_closing_bracket(self):\n        \"\"\"Test timestamp containing closing bracket (invalid, breaks pattern).\"\"\"\n        log_line = \"[invalid]timestamp] l: msg\"\n        self.assertIsNone(extract_log_data(log_line))\n\n    def test_log_level_with_space(self):\n        \"\"\"Test log level containing space (allowed).\"\"\"\n        log_line = \"[ts] lo g: msg\"\n        expected = (\"ts\", \"lo g\", \"msg\")\n        self.assertEqual(extract_log_data(log_line), expected)\n\n    def test_non_string_inputs(self):\n        \"\"\"Test non-string inputs raise TypeError.\"\"\"\n        invalid_inputs = [None, 123, 0, -1]\n        for inp in invalid_inputs:\n            with self.subTest(input=inp):\n                with self.assertRaises(TypeError):\n                    extract_log_data(inp)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 23, "task_id": "f8056028"}
{"test": "import unittest\n\nclass TestAnalyzeLogData(unittest.TestCase):\n    def test_valid_standard_entry(self):\n        # Basic valid log entry with standard format\n        s = \"[2023-01-01 12:00:00] INFO: This is a message\"\n        self.assertEqual(analyze_log_data(s), (\"2023-01-01 12:00:00\", \"INFO\", \"This is a message\"))\n    \n    def test_valid_max_lengths(self):\n        # Valid entry with max length timestamp (23), log level (10), and message (1000)\n        timestamp = 'a' * 23\n        log_level = 'b' * 10\n        message = 'c' * 1000\n        s = f\"[{timestamp}] {log_level}: {message}\"\n        self.assertEqual(analyze_log_data(s), (timestamp, log_level, message))\n    \n    def test_valid_min_lengths(self):\n        # Valid entry with min length (1 char) for all parts\n        s = \"[a] b: c\"\n        self.assertEqual(analyze_log_data(s), (\"a\", \"b\", \"c\"))\n    \n    def test_empty_string(self):\n        # Empty input string should return None\n        self.assertIsNone(analyze_log_data(\"\"))\n    \n    def test_timestamp_too_long(self):\n        # Timestamp longer than 23 chars should return None\n        s = \"[\" + 'a' * 24 + \"] INFO: message\"\n        self.assertIsNone(analyze_log_data(s))\n    \n    def test_log_level_too_long(self):\n        # Log level longer than 10 chars should return None\n        s = \"[ts] \" + 'b' * 11 + \": message\"\n        self.assertIsNone(analyze_log_data(s))\n    \n    def test_empty_message(self):\n        # Missing message content (0 chars) should return None\n        s = \"[ts] level: \"\n        self.assertIsNone(analyze_log_data(s))\n    \n    def test_empty_log_level(self):\n        # Missing log level (0 chars) should return None\n        s = \"[ts] : message\"\n        self.assertIsNone(analyze_log_data(s))\n    \n    def test_empty_timestamp(self):\n        # Missing timestamp content (0 chars) should return None\n        s = \"[] level: message\"\n        self.assertIsNone(analyze_log_data(s))\n    \n    def test_message_extra_text(self):\n        # Message with extra text beyond 1000 chars - captures first 1000 chars\n        timestamp = \"ts\"\n        log_level = \"level\"\n        message_part = 'c' * 1000\n        extra = \"extra\"\n        s = f\"[{timestamp}] {log_level}: {message_part}{extra}\"\n        self.assertEqual(analyze_log_data(s), (timestamp, log_level, message_part))\n    \n    def test_colon_in_log_level(self):\n        # Colon in log level part should break parsing and return None\n        s = \"[ts] log:level: message\"\n        self.assertIsNone(analyze_log_data(s))\n    \n    def test_missing_timestamp_space(self):\n        # Missing space after timestamp bracket should return None\n        s = \"[ts]level: message\"\n        self.assertIsNone(analyze_log_data(s))\n    \n    def test_missing_colon_space(self):\n        # Missing space after colon should return None\n        s = \"[ts] level:message\"\n        self.assertIsNone(analyze_log_data(s))\n    \n    def test_bracket_in_timestamp(self):\n        # Closing bracket inside timestamp content should return None\n        s = \"[a]b] level: message\"\n        self.assertIsNone(analyze_log_data(s))\n    \n    def test_log_level_with_space(self):\n        # Log level containing spaces should parse correctly\n        s = \"[ts] log level: message\"\n        self.assertEqual(analyze_log_data(s), (\"ts\", \"log level\", \"message\"))\n    \n    def test_message_with_newline(self):\n        # Message with newline - captures only until newline\n        s = \"[ts] level: line1\\nline2\"\n        self.assertEqual(analyze_log_data(s), (\"ts\", \"level\", \"line1\"))\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 16, "task_id": "70cb5e12"}
{"test": "import unittest\n\nclass TestExtractEmailDomain(unittest.TestCase):\n    \n    def test_valid_email_simple(self):\n        # Test valid email with simple domain\n        email = \"user@example.com\"\n        expected = \"example.com\"\n        self.assertEqual(extract_email_domain(email), expected)\n        \n    def test_valid_email_with_subdomain(self):\n        # Test valid email with subdomain\n        email = \"user@sub.example.com\"\n        expected = \"sub.example.com\"\n        self.assertEqual(extract_email_domain(email), expected)\n        \n    def test_email_without_at(self):\n        # Test email missing '@' symbol\n        email = \"userexample.com\"\n        self.assertIsNone(extract_email_domain(email))\n        \n    def test_email_with_multiple_ats(self):\n        # Test email containing multiple '@' symbols\n        email = \"user@name@example.com\"\n        self.assertIsNone(extract_email_domain(email))\n        \n    def test_email_empty_string(self):\n        # Test empty email string\n        email = \"\"\n        self.assertIsNone(extract_email_domain(email))\n        \n    def test_email_only_at(self):\n        # Test email containing only '@' symbol\n        email = \"@\"\n        self.assertIsNone(extract_email_domain(email))\n        \n    def test_email_domain_only(self):\n        # Test email missing local part (only domain)\n        email = \"@example.com\"\n        self.assertIsNone(extract_email_domain(email))\n        \n    def test_email_local_only(self):\n        # Test email missing domain part (only local)\n        email = \"user@\"\n        self.assertIsNone(extract_email_domain(email))\n        \n    def test_email_with_spaces_in_local(self):\n        # Test valid email with spaces in local part\n        email = \"user name@example.com\"\n        expected = \"example.com\"\n        self.assertEqual(extract_email_domain(email), expected)\n        \n    def test_email_with_spaces_in_domain(self):\n        # Test valid email with spaces in domain part\n        email = \"user@exa mple.com\"\n        expected = \"exa mple.com\"\n        self.assertEqual(extract_email_domain(email), expected)\n        \n    def test_email_with_special_chars_local(self):\n        # Test valid email with special characters in local part\n        email = \"!#$%^&*()@domain.com\"\n        expected = \"domain.com\"\n        self.assertEqual(extract_email_domain(email), expected)\n        \n    def test_email_with_special_chars_domain(self):\n        # Test valid email with special characters in domain part\n        email = \"user@!#$%^&*().com\"\n        expected = \"!#$%^&*().com\"\n        self.assertEqual(extract_email_domain(email), expected)\n        \n    def test_email_with_non_ascii(self):\n        # Test valid email with non-ASCII characters\n        email = \"üñîçøđé@exämple.com\"\n        expected = \"exämple.com\"\n        self.assertEqual(extract_email_domain(email), expected)\n        \n    def test_long_email(self):\n        # Test very long email (efficiency and correctness)\n        long_local = \"a\" * 10000\n        long_domain = \"b\" * 10000\n        email = long_local + \"@\" + long_domain\n        expected = long_domain\n        self.assertEqual(extract_email_domain(email), expected)\n        \n    def test_non_string_input_none(self):\n        # Test None input (non-string)\n        with self.assertRaises(TypeError):\n            extract_email_domain(None)\n            \n    def test_non_string_input_integer(self):\n        # Test integer input (non-string)\n        with self.assertRaises(TypeError):\n            extract_email_domain(123)", "num_test_cases": 16, "task_id": "f7361e99"}
{"test": "import unittest\n\nclass TestCases(unittest.TestCase):\n    \n    def test_case_1(self):\n        # Valid http URL with domain and TLD\n        self.assertTrue(validate_path(\"http://example.com\"))\n    \n    def test_case_2(self):\n        # Valid https URL with domain and TLD\n        self.assertTrue(validate_path(\"https://example.com\"))\n    \n    def test_case_3(self):\n        # Valid without scheme\n        self.assertTrue(validate_path(\"example.com\"))\n    \n    def test_case_4(self):\n        # Valid with path\n        self.assertTrue(validate_path(\"http://example.com/path/to/resource\"))\n    \n    def test_case_5(self):\n        # Valid with long path (300 characters in path part)\n        base = \"http://example.com\"\n        long_path = \"/\" + \"a\" * 299\n        url = base + long_path\n        self.assertTrue(validate_path(url))\n    \n    def test_case_6(self):\n        # Invalid: path part too long (301 characters)\n        base = \"http://example.com\"\n        long_path = \"/\" + \"a\" * 300\n        url = base + long_path\n        self.assertFalse(validate_path(url))\n    \n    def test_case_7(self):\n        # Valid with trailing slash\n        self.assertTrue(validate_path(\"http://example.com/path/\"))\n    \n    def test_case_8(self):\n        # Valid with subdomain\n        self.assertTrue(validate_path(\"http://sub.example.com\"))\n    \n    def test_case_9(self):\n        # Valid with TLD of 2 characters\n        self.assertTrue(validate_path(\"http://example.uk\"))\n    \n    def test_case_10(self):\n        # Valid with TLD of 6 characters\n        self.assertTrue(validate_path(\"http://example.museum\"))\n    \n    def test_case_11(self):\n        # Valid with TLD containing dot (ccTLD)\n        self.assertTrue(validate_path(\"http://example.co.uk\"))\n    \n    def test_case_12(self):\n        # Valid with domain starting with dot\n        self.assertTrue(validate_path(\"http://.example.com\"))\n    \n    def test_case_13(self):\n        # Valid with consecutive dots in domain\n        self.assertTrue(validate_path(\"http://ex..ample.com\"))\n    \n    def test_case_14(self):\n        # Valid with domain starting with hyphen\n        self.assertTrue(validate_path(\"http://-example.com\"))\n    \n    def test_case_15(self):\n        # Invalid: ftp scheme\n        self.assertFalse(validate_path(\"ftp://example.com\"))\n    \n    def test_case_16(self):\n        # Invalid: underscore in domain\n        self.assertFalse(validate_path(\"http://ex_ample.com\"))\n    \n    def test_case_17(self):\n        # Invalid: missing TLD\n        self.assertFalse(validate_path(\"http://example\"))\n    \n    def test_case_18(self):\n        # Invalid: TLD too short (1 char)\n        self.assertFalse(validate_path(\"http://example.a\"))\n    \n    def test_case_19(self):\n        # Invalid: TLD too long (7 chars)\n        self.assertFalse(validate_path(\"http://example.abcdefg\"))\n    \n    def test_case_20(self):\n        # Invalid: empty string\n        self.assertFalse(validate_path(\"\"))\n    \n    def test_case_21(self):\n        # Invalid: None input\n        self.assertFalse(validate_path(None))\n    \n    def test_case_22(self):\n        # Invalid: non-string input (integer)\n        self.assertFalse(validate_path(123))\n    \n    def test_case_23(self):\n        # Invalid: port number\n        self.assertFalse(validate_path(\"http://example.com:8080\"))\n    \n    def test_case_24(self):\n        # Invalid: query string\n        self.assertFalse(validate_path(\"http://example.com?query=value\"))\n    \n    def test_case_25(self):\n        # Valid: spaces in path\n        self.assertTrue(validate_path(\"http://example.com/path with space\"))\n    \n    def test_case_26(self):\n        # Invalid: spaces in domain\n        self.assertFalse(validate_path(\"http://exa mple.com\"))\n    \n    def test_case_27(self):\n        # Invalid: hyphen in TLD\n        self.assertFalse(validate_path(\"http://example.-com\"))\n    \n    def test_case_28(self):\n        # Valid: domain is dot and TLD with dot\n        self.assertTrue(validate_path(\"http://..com\"))\n    \n    def test_case_29(self):\n        # Invalid: disallowed character in path (#)\n        self.assertFalse(validate_path(\"http://example.com/path#fragment\"))\n    \n    def test_case_30(self):\n        # Valid: path with allowed special characters\n        self.assertTrue(validate_path(\"http://example.com/._- \"))\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 30, "task_id": "35f348c2"}
{"test": "import unittest\n\nclass TestCases(unittest.TestCase):\n    def test_case_1(self):\n        # Test basic tags: multiple tags\n        html = '<div><p>Hello</p></div>'\n        expected = ['div', 'p', '/p', '/div']\n        self.assertEqual(parse_html_tags(html), expected)\n\n    def test_case_2(self):\n        # Test self-closing tag\n        html = '<br />'\n        expected = ['br /']\n        self.assertEqual(parse_html_tags(html), expected)\n\n    def test_case_3(self):\n        # Test tag with attributes\n        html = '<a href=\"example.com\">Link</a>'\n        expected = ['a href=\"example.com\"', '/a']\n        self.assertEqual(parse_html_tags(html), expected)\n\n    def test_case_4(self):\n        # Test empty string\n        html = ''\n        expected = []\n        self.assertEqual(parse_html_tags(html), expected)\n\n    def test_case_5(self):\n        # Test string with no tags\n        html = 'This is plain text.'\n        expected = []\n        self.assertEqual(parse_html_tags(html), expected)\n\n    def test_case_6(self):\n        # Test one tag\n        html = '<head>'\n        expected = ['head']\n        self.assertEqual(parse_html_tags(html), expected)\n\n    def test_case_7(self):\n        # Test unclosed tag (missing '>')\n        html = '<div'\n        expected = []\n        self.assertEqual(parse_html_tags(html), expected)\n\n    def test_case_8(self):\n        # Test tag with exactly 100 characters inside\n        inner = 'a' * 100\n        html = f'<{inner}>'\n        expected = [inner]\n        self.assertEqual(parse_html_tags(html), expected)\n\n    def test_case_9(self):\n        # Test tag with 101 characters inside (should not match)\n        inner = 'a' * 101\n        html = f'<{inner}>'\n        expected = []\n        self.assertEqual(parse_html_tags(html), expected)\n\n    def test_case_10(self):\n        # Test comment\n        html = '<!-- comment -->'\n        expected = ['!-- comment --']\n        self.assertEqual(parse_html_tags(html), expected)\n\n    def test_case_11(self):\n        # Test tag with newline in attributes\n        html = '<div\\nclass=\"test\">'\n        expected = ['div\\nclass=\"test\"']\n        self.assertEqual(parse_html_tags(html), expected)\n\n    def test_case_12(self):\n        # Test non-string input (None)\n        with self.assertRaises(TypeError):\n            parse_html_tags(None)\n\n    def test_case_13(self):\n        # Test non-string input (integer)\n        with self.assertRaises(TypeError):\n            parse_html_tags(123)\n\n    def test_case_14(self):\n        # Test consecutive tags\n        html = '<a><b></b></a>'\n        expected = ['a', 'b', '/b', '/a']\n        self.assertEqual(parse_html_tags(html), expected)\n\n    def test_case_15(self):\n        # Test tag with attribute containing '>'\n        html = '<a href=\">\">'\n        expected = ['a href=\"']\n        self.assertEqual(parse_html_tags(html), expected)\n\n    def test_case_16(self):\n        # Test empty tag (like '<>')\n        html = '<>'\n        expected = []\n        self.assertEqual(parse_html_tags(html), expected)", "num_test_cases": 16, "task_id": "bcccae35"}
{"test": "import unittest\n\nclass TestParseLogEntry(unittest.TestCase):\n    def test_case_1(self):\n        # Test with a basic valid log entry\n        log_entry = 'INFO[2023-01-01] : Application started'\n        result = parse_log_entry(log_entry)\n        self.assertEqual(result, ('INFO', '2023-01-01', 'Application started'))\n\n    def test_case_2(self):\n        # Test with empty message\n        log_entry = 'WARN[2023-01-01 12:00:00] : '\n        result = parse_log_entry(log_entry)\n        self.assertEqual(result, ('WARN', '2023-01-01 12:00:00', ''))\n\n    def test_case_3(self):\n        # Test with message containing special characters\n        log_entry = 'ERROR[2023-01-01] : Failed to connect to database: error 404'\n        result = parse_log_entry(log_entry)\n        self.assertEqual(result, ('ERROR', '2023-01-01', 'Failed to connect to database: error 404'))\n\n    def test_case_4(self):\n        # Test with empty timestamp\n        log_entry = 'DEBUG[] : This is a debug message'\n        result = parse_log_entry(log_entry)\n        self.assertEqual(result, ('DEBUG', '', 'This is a debug message'))\n\n    def test_case_5(self):\n        # Test with log level containing hyphen\n        log_entry = 'DEBUG-1[2023-01-01] : Message'\n        result = parse_log_entry(log_entry)\n        self.assertEqual(result, ('DEBUG-1', '2023-01-01', 'Message'))\n\n    def test_case_6(self):\n        # Test missing colon (invalid format)\n        log_entry = 'INFO[2023-01-01] Message without colon'\n        result = parse_log_entry(log_entry)\n        self.assertIsNone(result)\n\n    def test_case_7(self):\n        # Test with leading/trailing spaces\n        log_entry = '  INFO  [2023-01-01] :   message with spaces   '\n        result = parse_log_entry(log_entry)\n        self.assertEqual(result, ('  INFO  ', '2023-01-01', '  message with spaces   '))\n\n    def test_case_8(self):\n        # Test with missing closing bracket (invalid)\n        log_entry = 'INFO[2023-01-01 : This is a message'\n        result = parse_log_entry(log_entry)\n        self.assertIsNone(result)\n\n    def test_case_9(self):\n        # Test empty string input\n        log_entry = ''\n        result = parse_log_entry(log_entry)\n        self.assertIsNone(result)\n\n    def test_case_10(self):\n        # Test very long log entry\n        long_str = 'A' * 1000\n        log_entry = f'LONG[{long_str}] : {long_str}'\n        result = parse_log_entry(log_entry)\n        self.assertEqual(result, ('LONG', long_str, long_str))\n\n    def test_case_11(self):\n        # Test log level with newline\n        log_entry = 'INFO\\n[2023-01-01] : message'\n        result = parse_log_entry(log_entry)\n        self.assertEqual(result, ('INFO\\n', '2023-01-01', 'message'))\n\n    def test_case_12(self):\n        # Test message containing brackets\n        log_entry = 'INFO[2023-01-01] : This is a [message] with brackets'\n        result = parse_log_entry(log_entry)\n        self.assertEqual(result, ('INFO', '2023-01-01', 'This is a [message] with brackets'))\n\n    def test_case_13(self):\n        # Test missing space after colon (invalid)\n        log_entry = 'INFO[2023-01-01]: message without space'\n        result = parse_log_entry(log_entry)\n        self.assertIsNone(result)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 13, "task_id": "1644d9ef"}
{"test": "import unittest\n\nclass TestMatchStrings(unittest.TestCase):\n\n    def test_basic(self):\n        # Test basic case with one set of parentheses\n        self.assertEqual(match_strings(\"abc(def)\"), (\"abc\", \"def\"))\n\n    def test_nested(self):\n        # Test nested parentheses\n        self.assertEqual(match_strings(\"abc(def(ghi))\"), (\"abc\", \"def(ghi)\"))\n\n    def test_multiple_parentheses(self):\n        # Test multiple parentheses in the string\n        self.assertEqual(match_strings(\"abc(def)xyz(uvw)\"), (\"abc\", \"def)xyz(uvw\"))\n\n    def test_text_after_parentheses(self):\n        # Test text after the parentheses\n        self.assertEqual(match_strings(\"abc(def)ghi\"), (\"abc\", \"def\"))\n\n    def test_nested_and_text_after(self):\n        # Test nested parentheses with text after\n        self.assertEqual(match_strings(\"abc(def(ghi))jkl\"), (\"abc\", \"def(ghi)\"))\n\n    def test_empty_string(self):\n        # Test empty string input\n        self.assertIsNone(match_strings(\"\"))\n\n    def test_no_parentheses(self):\n        # Test string without parentheses\n        self.assertIsNone(match_strings(\"abc\"))\n\n    def test_only_parentheses(self):\n        # Test string with only parentheses\n        self.assertIsNone(match_strings(\"()\"))\n\n    def test_only_opening_parenthesis(self):\n        # Test string with only an opening parenthesis\n        self.assertIsNone(match_strings(\"abc(\"))\n\n    def test_only_closing_parenthesis(self):\n        # Test string with only a closing parenthesis\n        self.assertIsNone(match_strings(\"abc)\"))\n\n    def test_newlines(self):\n        # Test string with newline inside parentheses\n        self.assertEqual(match_strings(\"abc(def\\nghi)\"), (\"abc\", \"def\\nghi\"))\n\n    def test_inside_empty(self):\n        # Test empty inside parentheses\n        self.assertEqual(match_strings(\"abc()\"), (\"abc\", \"\"))\n\n    def test_special_characters(self):\n        # Test string with special characters\n        self.assertEqual(match_strings(\"a!@#$%^&*()_+ (b)\"), (\"a!@#$%^&*\", \")_+ (b\"))", "num_test_cases": 13, "task_id": "fbc32825"}
