{"test": "import unittest\nimport shlex\n\n# Define base_command as per the function's requirement\nbase_command = 'echo Hello, {user_name}!'\n\n# Define the function under test\ndef generate_greeting_command(user_name: str) -> str:\n    import shlex\n    safe_user_name = shlex.quote(user_name)\n    return base_command.format(user_name=safe_user_name)\n\nclass TestGenerateGreetingCommand(unittest.TestCase):\n    \n    def test_normal_name(self):\n        # Test with a normal name without special characters\n        user_name = \"Alice\"\n        expected = base_command.format(user_name=shlex.quote(user_name))\n        result = generate_greeting_command(user_name)\n        self.assertEqual(result, expected)\n    \n    def test_name_with_space(self):\n        # Test a name containing a space\n        user_name = \"Alice Smith\"\n        expected = base_command.format(user_name=shlex.quote(user_name))\n        result = generate_greeting_command(user_name)\n        self.assertEqual(result, expected)\n    \n    def test_name_with_single_quote(self):\n        # Test a name containing a single quote\n        user_name = \"O'Conner\"\n        expected = base_command.format(user_name=shlex.quote(user_name))\n        result = generate_greeting_command(user_name)\n        self.assertEqual(result, expected)\n    \n    def test_name_with_double_quote(self):\n        # Test a name containing a double quote\n        user_name = 'He said \"Hello\"'\n        expected = base_command.format(user_name=shlex.quote(user_name))\n        result = generate_greeting_command(user_name)\n        self.assertEqual(result, expected)\n    \n    def test_name_with_newline(self):\n        # Test a name containing a newline character\n        user_name = \"Alice\\nSmith\"\n        expected = base_command.format(user_name=shlex.quote(user_name))\n        result = generate_greeting_command(user_name)\n        self.assertEqual(result, expected)\n    \n    def test_special_characters(self):\n        # Test a name containing various special characters\n        user_name = \"!@#$%^&*()\"\n        expected = base_command.format(user_name=shlex.quote(user_name))\n        result = generate_greeting_command(user_name)\n        self.assertEqual(result, expected)\n    \n    def test_empty_string(self):\n        # Test an empty string as input\n        user_name = \"\"\n        expected = base_command.format(user_name=shlex.quote(user_name))\n        result = generate_greeting_command(user_name)\n        self.assertEqual(result, expected)\n    \n    def test_long_string(self):\n        # Test a very long name\n        user_name = \"A\" * 1000\n        expected = base_command.format(user_name=shlex.quote(user_name))\n        result = generate_greeting_command(user_name)\n        self.assertEqual(result, expected)\n    \n    def test_non_string_int(self):\n        # Test non-string input (integer)\n        with self.assertRaises(TypeError):\n            generate_greeting_command(123)\n    \n    def test_non_string_none(self):\n        # Test non-string input (None)\n        with self.assertRaises(TypeError):\n            generate_greeting_command(None)\n    \n    def test_non_string_list(self):\n        # Test non-string input (list)\n        with self.assertRaises(TypeError):\n            generate_greeting_command([\"Alice\"])\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 11, "task_id": "9ebf86f0"}
{"test": "import unittest\n\nclass TestCases(unittest.TestCase):\n    def test_basic_message(self):\n        # Test with a basic message without special characters\n        result = generate_xml_response('Hello, World!')\n        self.assertEqual(result, '<response><content>Hello, World!</content></response>')\n        \n    def test_escape_required_chars(self):\n        # Test escaping of XML special characters: &, <, >\n        result = generate_xml_response('a & b < c > d')\n        self.assertEqual(result, '<response><content>a &amp; b &lt; c &gt; d</content></response>')\n        \n    def test_empty_input(self):\n        # Test with empty string input\n        result = generate_xml_response('')\n        self.assertEqual(result, '<response><content></content></response>')\n        \n    def test_quotes_in_content(self):\n        # Test that quotes are not escaped (default saxutils behavior)\n        result = generate_xml_response('\"quote\" \\'single_quote\\'')\n        self.assertEqual(result, '<response><content>\"quote\" \\'single_quote\\'</content></response>')\n        \n    def test_non_ascii_chars(self):\n        # Test with non-ASCII characters\n        result = generate_xml_response('àèìòù')\n        self.assertEqual(result, '<response><content>àèìòù</content></response>')\n        \n    def test_long_string_with_escaping(self):\n        # Test long string requiring escaping\n        long_str = \"A&\" * 500  # 1000 characters with escaping\n        result = generate_xml_response(long_str)\n        expected = '<response><content>' + \"A&amp;\" * 500 + '</content></response>'\n        self.assertEqual(result, expected)\n        \n    def test_integer_input(self):\n        # Test non-string input (integer)\n        with self.assertRaises(TypeError):\n            generate_xml_response(123)\n            \n    def test_none_input(self):\n        # Test None input\n        with self.assertRaises(TypeError):\n            generate_xml_response(None)", "num_test_cases": 8, "task_id": "b4acf106"}
{"test": "import unittest\nfrom solution import is_javascript_scheme\n\nclass TestCases(unittest.TestCase):\n    def test_javascript_scheme(self):\n        # Test typical javascript scheme\n        self.assertTrue(is_javascript_scheme('javascript:alert(1)'))\n    \n    def test_jscript_scheme(self):\n        # Test jscript scheme\n        self.assertTrue(is_javascript_scheme('jscript:alert(1)'))\n    \n    def test_livescript_scheme(self):\n        # Test livescript scheme\n        self.assertTrue(is_javascript_scheme('livescript:alert(1)'))\n    \n    def test_vbscript_scheme(self):\n        # Test vbscript scheme\n        self.assertTrue(is_javascript_scheme('vbscript:alert(1)'))\n    \n    def test_data_scheme(self):\n        # Test data scheme (not image data URL)\n        self.assertTrue(is_javascript_scheme('data:text/html,<script>alert(1)</script>'))\n    \n    def test_about_scheme(self):\n        # Test about scheme\n        self.assertTrue(is_javascript_scheme('about:config'))\n    \n    def test_mocha_scheme(self):\n        # Test mocha scheme\n        self.assertTrue(is_javascript_scheme('mocha:alert(1)'))\n    \n    def test_safe_scheme(self):\n        # Test non-malicious scheme (http)\n        self.assertFalse(is_javascript_scheme('http://example.com'))\n    \n    def test_safe_image_data_url(self):\n        # Test safe image data URL\n        self.assertFalse(is_javascript_scheme('data:image/png;base64,abc123'))\n    \n    def test_unsafe_svg_image(self):\n        # Test unsafe SVG image data URL\n        self.assertTrue(is_javascript_scheme('data:image/svg+xml;base64,abc123'))\n    \n    def test_unsafe_xml_image(self):\n        # Test unsafe XML image data URL\n        self.assertTrue(is_javascript_scheme('data:image/xml;base64,abc123'))\n    \n    def test_safe_image_with_unsafe_content(self):\n        # Test safe image type with malicious content should be safe\n        self.assertFalse(is_javascript_scheme('data:image/png;base64,javascript:alert(1)'))\n    \n    def test_malicious_after_image(self):\n        # Test malicious scheme after image data URL\n        self.assertFalse(is_javascript_scheme('data:image/png;base64,abc123 javascript:alert(1)'))\n    \n    def test_malicious_before_image(self):\n        # Test malicious scheme before image data URL\n        self.assertTrue(is_javascript_scheme('javascript:alert(1) data:image/png;base64,abc123'))\n    \n    def test_case_insensitive_malicious(self):\n        # Test case insensitivity for malicious scheme\n        self.assertTrue(is_javascript_scheme('JavAsCrIpT:alert(1)'))\n    \n    def test_case_insensitive_unsafe_image(self):\n        # Test case insensitivity for unsafe image type\n        self.assertTrue(is_javascript_scheme('data:image/SvG;base64,abc123'))\n    \n    def test_data_url_without_base64(self):\n        # Test data URL without base64 part\n        self.assertTrue(is_javascript_scheme('data:image/png,abc123'))\n    \n    def test_empty_string(self):\n        # Test empty string input\n        self.assertFalse(is_javascript_scheme(''))\n    \n    def test_none_input(self):\n        # Test None input\n        with self.assertRaises(TypeError):\n            is_javascript_scheme(None)\n    \n    def test_non_string_input(self):\n        # Test integer input\n        with self.assertRaises(TypeError):\n            is_javascript_scheme(123)\n    \n    def test_unsafe_image_without_base64(self):\n        # Test unsafe image type without base64\n        self.assertTrue(is_javascript_scheme('data:image/svg,abc123'))\n    \n    def test_multiple_schemes(self):\n        # Test multiple schemes (first is safe image, second malicious)\n        self.assertFalse(is_javascript_scheme('data:image/png;base64,abc123 data:text/html,<script>alert(1)</script>'))\n    \n    def test_long_string(self):\n        # Test very long input string\n        long_str = 'x' * 10000\n        self.assertFalse(is_javascript_scheme(long_str))\n    \n    def test_long_malicious_string(self):\n        # Test very long malicious string\n        long_str = 'javascript:' + ('x' * 10000)\n        self.assertTrue(is_javascript_scheme(long_str))\n    \n    def test_whitespace_in_scheme(self):\n        # Test scheme with whitespace\n        self.assertTrue(is_javascript_scheme('  javascript:alert(1)'))\n    \n    def test_multiline_string(self):\n        # Test multiline string input\n        self.assertFalse(is_javascript_scheme('data:image/png;base64,\\nABC'))\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 25, "task_id": "747d30e2"}
{"test": "import unittest\n\nclass TestRunUserQuery(unittest.TestCase):\n    def setUp(self):\n        # Common dataset for multiple tests\n        self.dataset = [\n            {'name': 'Alice', 'age': 30, 'city': 'NewYork'},\n            {'name': 'Bob', 'age': 25, 'city': 'Chicago'},\n            {'name': 'Charlie', 'age': 35, 'city': 'Boston'},\n            {'name': 'David', 'age': 40, 'city': 'NewYork'}\n        ]\n\n    def test_basic_query(self):\n        # Test basic SELECT with WHERE and ORDER BY\n        query = \"SELECT name, age FROM data WHERE city = NewYork ORDER BY age\"\n        result = run_user_query(self.dataset, query)\n        expected = [\n            {'name': 'Alice', 'age': 30},\n            {'name': 'David', 'age': 40}\n        ]\n        self.assertEqual(result, expected)\n\n    def test_multiple_conditions(self):\n        # Test multiple AND conditions\n        query = \"SELECT name, city FROM data WHERE city = NewYork AND age > 30 ORDER BY name\"\n        result = run_user_query(self.dataset, query)\n        expected = [\n            {'name': 'David', 'city': 'NewYork'}\n        ]\n        self.assertEqual(result, expected)\n\n    def test_no_matching_records(self):\n        # Test WHERE condition that matches no records\n        query = \"SELECT name FROM data WHERE city = LosAngeles ORDER BY name\"\n        result = run_user_query(self.dataset, query)\n        self.assertEqual(result, [])\n\n    def test_order_by_string_field(self):\n        # Test ORDER BY on a string field\n        query = \"SELECT name, city FROM data WHERE age >= 25 ORDER BY city\"\n        result = run_user_query(self.dataset, query)\n        expected = [\n            {'name': 'Charlie', 'city': 'Boston'},\n            {'name': 'Bob', 'city': 'Chicago'},\n            {'name': 'Alice', 'city': 'NewYork'},\n            {'name': 'David', 'city': 'NewYork'}\n        ]\n        self.assertEqual(result, expected)\n\n    def test_empty_dataset(self):\n        # Test with an empty dataset\n        query = \"SELECT name FROM data WHERE age > 20 ORDER BY name\"\n        result = run_user_query([], query)\n        self.assertEqual(result, [])\n\n    def test_single_matching_record(self):\n        # Test with a dataset of one matching record\n        query = \"SELECT name FROM data WHERE city = Boston ORDER BY name\"\n        single_dataset = [{'name': 'Charlie', 'age': 35, 'city': 'Boston'}]\n        result = run_user_query(single_dataset, query)\n        self.assertEqual(result, [{'name': 'Charlie'}])\n\n    def test_single_non_matching_record(self):\n        # Test with a dataset of one non-matching record\n        query = \"SELECT name FROM data WHERE city = Seattle ORDER BY name\"\n        single_dataset = [{'name': 'Eve', 'age': 28, 'city': 'Portland'}]\n        result = run_user_query(single_dataset, query)\n        self.assertEqual(result, [])\n\n    def test_missing_field_in_condition(self):\n        # Test condition on a field missing in some records\n        dataset = [\n            {'name': 'Alice', 'age': 30},\n            {'name': 'Bob'},  # Missing 'age'\n            {'name': 'Charlie', 'age': 35}\n        ]\n        query = \"SELECT name FROM data WHERE age > 25 ORDER BY name\"\n        with self.assertRaises(ValueError):\n            run_user_query(dataset, query)\n\n    def test_invalid_condition_format(self):\n        # Test condition with space in value (invalid pattern)\n        query = \"SELECT name FROM data WHERE city = New York ORDER BY name\"\n        with self.assertRaises(ValueError):\n            run_user_query(self.dataset, query)\n\n    def test_unsupported_operator(self):\n        # Test condition with unsupported operator (!=)\n        query = \"SELECT name FROM data WHERE age != 30 ORDER BY name\"\n        with self.assertRaises(ValueError):\n            run_user_query(self.dataset, query)\n\n    def test_type_conversion_error(self):\n        # Test condition with value that can't convert to field's type\n        query = \"SELECT name FROM data WHERE age = thirty ORDER BY name\"\n        with self.assertRaises(ValueError):\n            run_user_query(self.dataset, query)\n\n    def test_missing_order_by_field(self):\n        # Test ORDER BY on a field missing in a record\n        dataset = [\n            {'name': 'Alice', 'age': 30},\n            {'name': 'Bob'},  # Missing 'age'\n            {'name': 'Charlie', 'age': 35}\n        ]\n        query = \"SELECT name FROM data WHERE name != '' ORDER BY age\"\n        with self.assertRaises(ValueError):\n            run_user_query(dataset, query)\n\n    def test_wildcard_select(self):\n        # Test SELECT * (not supported, expects KeyError)\n        query = \"SELECT * FROM data WHERE city = NewYork ORDER BY age\"\n        with self.assertRaises(ValueError):\n            run_user_query(self.dataset, query)\n\n    def test_case_insensitivity(self):\n        # Test case insensitivity in query keywords\n        query = \"select name, age from data where city = NewYork order by age\"\n        result = run_user_query(self.dataset, query)\n        expected = [\n            {'name': 'Alice', 'age': 30},\n            {'name': 'David', 'age': 40}\n        ]\n        self.assertEqual(result, expected)\n\n    def test_invalid_table_name(self):\n        # Test with non-'data' table name in FROM clause\n        query = \"SELECT name FROM dataset WHERE city = NewYork ORDER BY age\"\n        with self.assertRaises(ValueError):\n            run_user_query(self.dataset, query)\n", "num_test_cases": 15, "task_id": "18e86efe"}
{"test": "import unittest\nimport re\nimport operator\nimport functools\n\nclass TestExecuteUserQuery(unittest.TestCase):\n    def setUp(self):\n        # Common test dataset\n        self.records = [\n            {'name': 'Alice', 'age': 30, 'city': 'New York'},\n            {'name': 'Bob', 'age': 25, 'city': 'Chicago'},\n            {'name': 'Charlie', 'age': 35, 'city': 'New York'},\n            {'name': 'David', 'age': 40, 'city': 'Los Angeles'}\n        ]\n\n    def test_valid_query_single_condition(self):\n        # Test basic query with one condition\n        query = \"SELECT name, age FROM data WHERE age > 30 ORDER BY age\"\n        result = execute_user_query(self.records, query)\n        expected = [\n            {'name': 'Charlie', 'age': 35},\n            {'name': 'David', 'age': 40}\n        ]\n        self.assertEqual(result, expected)\n\n    def test_valid_query_multiple_conditions(self):\n        # Test query with multiple AND conditions\n        query = \"SELECT name, city FROM data WHERE city = 'New York' AND age < 40 ORDER BY name\"\n        result = execute_user_query(self.records, query)\n        expected = [\n            {'name': 'Alice', 'city': 'New York'},\n            {'name': 'Charlie', 'city': 'New York'}\n        ]\n        self.assertEqual(result, expected)\n\n    def test_empty_records(self):\n        # Test query on empty records list\n        query = \"SELECT name FROM data WHERE age > 30 ORDER BY name\"\n        result = execute_user_query([], query)\n        self.assertEqual(result, [])\n\n    def test_no_matching_records(self):\n        # Test condition that returns no results\n        query = \"SELECT name FROM data WHERE age > 100 ORDER BY name\"\n        result = execute_user_query(self.records, query)\n        self.assertEqual(result, [])\n\n    def test_invalid_query_format(self):\n        # Test invalid query structure (missing clauses)\n        query = \"SELECT name FROM data\"\n        with self.assertRaises(ValueError):\n            execute_user_query(self.records, query)\n\n    def test_missing_select_field(self):\n        # Test non-existent field in SELECT clause\n        query = \"SELECT invalid_field FROM data WHERE age > 30 ORDER BY name\"\n        result = execute_user_query(self.records, query)\n        expected = [{'invalid_field': None}, {'invalid_field': None}]\n        self.assertEqual(result, expected)\n\n    def test_invalid_where_operator(self):\n        # Test unsupported operator in WHERE condition\n        query = \"SELECT name FROM data WHERE age != 30 ORDER BY name\"\n        with self.assertRaises(ValueError):\n            execute_user_query(self.records, query)\n\n    def test_missing_where_field(self):\n        # Test non-existent field in WHERE condition\n        query = \"SELECT name FROM data WHERE invalid_field = 30 ORDER BY name\"\n        with self.assertRaises(ValueError):\n            execute_user_query(self.records, query)\n\n    def test_missing_order_by_field(self):\n        # Test non-existent field in ORDER BY\n        query = \"SELECT name FROM data WHERE age > 30 ORDER BY invalid_field\"\n        with self.assertRaises(ValueError):\n            execute_user_query(self.records, query)\n\n    def test_type_mismatch_in_condition(self):\n        # Test type conversion error during condition evaluation\n        query = \"SELECT name FROM data WHERE name = 123 ORDER BY name\"\n        with self.assertRaises(ValueError):\n            execute_user_query(self.records, query)\n\n    def test_order_by_numeric(self):\n        # Test correct numeric ordering\n        query = \"SELECT name, age FROM data WHERE age > 20 ORDER BY age\"\n        result = execute_user_query(self.records, query)\n        ages = [item['age'] for item in result]\n        self.assertEqual(ages, [25, 30, 35, 40])\n\n    def test_order_by_string(self):\n        # Test correct string ordering\n        query = \"SELECT name FROM data WHERE age > 20 ORDER BY name\"\n        result = execute_user_query(self.records, query)\n        names = [item['name'] for item in result]\n        self.assertEqual(names, ['Alice', 'Bob', 'Charlie', 'David'])\n\n    def test_case_insensitive_query(self):\n        # Test case insensitivity in query keywords\n        query = \"select name from data where age > 30 order by age\"\n        result = execute_user_query(self.records, query)\n        expected = [\n            {'name': 'Charlie', 'age': 35},\n            {'name': 'David', 'age': 40}\n        ]\n        self.assertEqual(result, expected)\n\n    def test_invalid_condition_format(self):\n        # Test malformed WHERE condition\n        query = \"SELECT name FROM data WHERE age= ORDER BY name\"\n        with self.assertRaises(ValueError):\n            execute_user_query(self.records, query)\n", "num_test_cases": 14, "task_id": "c87b99af"}
{"test": "import unittest\n\nclass TestCustomQuery(unittest.TestCase):\n    \n    def test_basic_query(self):\n        # Basic happy path with one condition and one field\n        dataset = [\n            {\"name\": \"Alice\", \"age\": 30, \"city\": \"London\"},\n            {\"name\": \"Bob\", \"age\": 25, \"city\": \"Paris\"},\n            {\"name\": \"Charlie\", \"age\": 35, \"city\": \"London\"}\n        ]\n        query = \"SELECT name, age FROM data WHERE city = London ORDER BY age\"\n        result = run_custom_query(dataset, query)\n        expected = [\n            {\"name\": \"Alice\", \"age\": 30},\n            {\"name\": \"Charlie\", \"age\": 35}\n        ]\n        self.assertEqual(result, expected)\n\n    def test_multiple_conditions(self):\n        # Multiple conditions in WHERE clause\n        dataset = [\n            {\"name\": \"Alice\", \"age\": 30, \"city\": \"London\", \"score\": 85},\n            {\"name\": \"Bob\", \"age\": 25, \"city\": \"Paris\", \"score\": 90},\n            {\"name\": \"Charlie\", \"age\": 35, \"city\": \"London\", \"score\": 80}\n        ]\n        query = \"SELECT name, city FROM data WHERE city = London AND score >= 80 ORDER BY name\"\n        result = run_custom_query(dataset, query)\n        expected = [\n            {\"name\": \"Alice\", \"city\": \"London\"},\n            {\"name\": \"Charlie\", \"city\": \"London\"}\n        ]\n        self.assertEqual(result, expected)\n\n    def test_numeric_operations(self):\n        # Numeric comparisons and float values\n        dataset = [\n            {\"product\": \"A\", \"price\": 15.99, \"quantity\": 100},\n            {\"product\": \"B\", \"price\": 23.50, \"quantity\": 75},\n            {\"product\": \"C\", \"price\": 10.00, \"quantity\": 120}\n        ]\n        query = \"SELECT product, price FROM data WHERE price > 12.00 AND quantity <= 100 ORDER BY price\"\n        result = run_custom_query(dataset, query)\n        expected = [\n            {\"product\": \"A\", \"price\": 15.99},\n            {\"product\": \"B\", \"price\": 23.50}\n        ]\n        self.assertEqual(result, expected)\n\n    def test_empty_dataset(self):\n        # Empty dataset should return empty list\n        dataset = []\n        query = \"SELECT name FROM data WHERE age > 20 ORDER BY name\"\n        result = run_custom_query(dataset, query)\n        self.assertEqual(result, [])\n\n    def test_no_matching_rows(self):\n        # Query with conditions that match no rows\n        dataset = [\n            {\"name\": \"Alice\", \"age\": 30},\n            {\"name\": \"Bob\", \"age\": 25}\n        ]\n        query = \"SELECT name FROM data WHERE age > 40 ORDER BY name\"\n        result = run_custom_query(dataset, query)\n        self.assertEqual(result, [])\n\n    def test_invalid_query_format(self):\n        # Query that doesn't match the expected regex\n        dataset = [{\"name\": \"Alice\"}]\n        query = \"INVALID QUERY FORMAT\"\n        with self.assertRaises(ValueError):\n            run_custom_query(dataset, query)\n\n    def test_invalid_operator(self):\n        # Condition with an unsupported operator\n        dataset = [{\"name\": \"Alice\", \"age\": 30}]\n        query = \"SELECT name FROM data WHERE age <> 30 ORDER BY name\"\n        with self.assertRaises(ValueError):\n            run_custom_query(dataset, query)\n\n    def test_nonexistent_field_condition(self):\n        # Condition references a non-existent field\n        dataset = [{\"name\": \"Alice\", \"age\": 30}]\n        query = \"SELECT name FROM data WHERE invalid_field = value ORDER BY name\"\n        with self.assertRaises(ValueError):\n            run_custom_query(dataset, query)\n\n    def test_nonexistent_orderby_field(self):\n        # ORDER BY references a non-existent field\n        dataset = [{\"name\": \"Alice\"}]\n        query = \"SELECT name FROM data WHERE name = Alice ORDER BY age\"\n        with self.assertRaises(ValueError):\n            run_custom_query(dataset, query)\n\n    def test_type_mismatch_in_condition(self):\n        # Condition compares incompatible types\n        dataset = [{\"name\": \"Alice\", \"age\": 30}]\n        query = \"SELECT name FROM data WHERE age = thirty ORDER BY name\"\n        with self.assertRaises(ValueError):\n            run_custom_query(dataset, query)\n\n    def test_select_all_fields(self):\n        # Using '*' in SELECT clause (currently unsupported)\n        dataset = [{\"name\": \"Alice\", \"age\": 30}]\n        query = \"SELECT * FROM data WHERE name = Alice ORDER BY age\"\n        with self.assertRaises(ValueError):\n            run_custom_query(dataset, query)\n\n    def test_invalid_value_format(self):\n        # Condition value with spaces (unsupported by regex)\n        dataset = [{\"name\": \"Alice Smith\", \"age\": 30}]\n        query = \"SELECT name FROM data WHERE name = Alice Smith ORDER BY age\"\n        with self.assertRaises(ValueError):\n            run_custom_query(dataset, query)\n", "num_test_cases": 12, "task_id": "9c23e2bf"}
{"test": "import unittest\n\nclass TestExecuteQueryCmd(unittest.TestCase):\n    def test_basic_query(self):\n        # Happy path: basic query with integer condition and sorting\n        dataset = [\n            {\"name\": \"Alice\", \"age\": 30},\n            {\"name\": \"Bob\", \"age\": 25}\n        ]\n        query = \"SELECT name, age FROM data WHERE age >= 25 ORDER BY age\"\n        expected = [\n            {\"name\": \"Bob\", \"age\": 25},\n            {\"name\": \"Alice\", \"age\": 30}\n        ]\n        result = execute_query_cmd(dataset, query)\n        self.assertEqual(result, expected)\n\n    def test_multiple_conditions(self):\n        # Happy path: multiple WHERE conditions and single SELECT field\n        dataset = [\n            {\"name\": \"Alice\", \"age\": 30},\n            {\"name\": \"Bob\", \"age\": 25},\n            {\"name\": \"Charlie\", \"age\": 30}\n        ]\n        query = \"SELECT name FROM data WHERE age = 30 AND name = 'Alice' ORDER BY name\"\n        expected = [{\"name\": \"Alice\"}]\n        result = execute_query_cmd(dataset, query)\n        self.assertEqual(result, expected)\n\n    def test_empty_dataset(self):\n        # Edge case: empty dataset\n        dataset = []\n        query = \"SELECT name FROM data WHERE age >= 25 ORDER BY age\"\n        result = execute_query_cmd(dataset, query)\n        self.assertEqual(result, [])\n\n    def test_no_matching_records(self):\n        # Edge case: condition filters out all records\n        dataset = [{\"name\": \"Alice\", \"age\": 30}]\n        query = \"SELECT name FROM data WHERE age < 25 ORDER BY name\"\n        result = execute_query_cmd(dataset, query)\n        self.assertEqual(result, [])\n\n    def test_non_existing_field_in_condition(self):\n        # Error: non-existing field in WHERE condition\n        dataset = [{\"name\": \"Alice\", \"age\": 30}]\n        query = \"SELECT name FROM data WHERE non_exist = 10 ORDER BY name\"\n        with self.assertRaises(ValueError):\n            execute_query_cmd(dataset, query)\n\n    def test_invalid_operator_in_condition(self):\n        # Error: invalid operator in WHERE condition\n        dataset = [{\"name\": \"Alice\", \"age\": 30}]\n        query = \"SELECT name FROM data WHERE age >> 25 ORDER BY name\"\n        with self.assertRaises(ValueError):\n            execute_query_cmd(dataset, query)\n\n    def test_non_existing_field_in_select(self):\n        # Error: non-existing field in SELECT clause\n        dataset = [{\"name\": \"Alice\", \"age\": 30}]\n        query = \"SELECT non_exist FROM data WHERE age = 30 ORDER BY age\"\n        with self.assertRaises(ValueError):\n            execute_query_cmd(dataset, query)\n\n    def test_non_existing_field_in_order_by(self):\n        # Error: non-existing field in ORDER BY clause\n        dataset = [{\"name\": \"Alice\", \"age\": 30}]\n        query = \"SELECT name FROM data WHERE age = 30 ORDER BY non_exist\"\n        with self.assertRaises(ValueError):\n            execute_query_cmd(dataset, query)\n\n    def test_string_with_space_in_condition(self):\n        # Error: string with space in condition value (fails regex parsing)\n        dataset = [{\"name\": \"Alice Smith\", \"age\": 30}]\n        query = \"SELECT name FROM data WHERE name = 'Alice Smith' ORDER BY age\"\n        with self.assertRaises(ValueError):\n            execute_query_cmd(dataset, query)\n\n    def test_type_mismatch_in_condition(self):\n        # Error: condition value cannot be cast to field's type\n        dataset = [{\"name\": \"Alice\", \"age\": \"thirty\"}]\n        query = \"SELECT name FROM data WHERE age = 30 ORDER BY name\"\n        with self.assertRaises(ValueError):\n            execute_query_cmd(dataset, query)\n\n    def test_float_value_in_condition(self):\n        # Happy path: float value in condition\n        dataset = [\n            {\"product\": \"A\", \"price\": 10.5},\n            {\"product\": \"B\", \"price\": 20.0}\n        ]\n        query = \"SELECT product FROM data WHERE price > 15.5 ORDER BY price\"\n        expected = [{\"product\": \"B\"}]\n        result = execute_query_cmd(dataset, query)\n        self.assertEqual(result, expected)\n\nif __name__ == \"__main__\":\n    unittest.main()", "num_test_cases": 11, "task_id": "372e7fce"}
{"test": "import unittest\n\nclass TestRunSqlQuery(unittest.TestCase):\n    \n    def setUp(self):\n        \"\"\"Setup a sample dataset for testing.\"\"\"\n        self.records = [\n            {'name': 'Alice', 'age': 30, 'city': 'NY', 'height': 165.5},\n            {'name': 'Bob', 'age': 25, 'city': 'Chicago', 'height': 180.0},\n            {'name': 'Charlie', 'age': 35, 'city': 'NY', 'height': 175.3},\n            {'name': 'David', 'age': 40, 'city': 'LA', 'height': 170.2}\n        ]\n    \n    def test_basic_query(self):\n        \"\"\"Test basic query with one condition and one field.\"\"\"\n        command = 'SELECT name, age FROM data WHERE city = NY ORDER BY age'\n        result = run_sql_query(self.records, command)\n        expected = [\n            {'name': 'Alice', 'age': 30},\n            {'name': 'Charlie', 'age': 35}\n        ]\n        self.assertEqual(result, expected)\n    \n    def test_multiple_conditions(self):\n        \"\"\"Test query with multiple WHERE conditions.\"\"\"\n        command = 'SELECT name FROM data WHERE city = NY AND age > 30 ORDER BY name'\n        result = run_sql_query(self.records, command)\n        expected = [{'name': 'Charlie'}]\n        self.assertEqual(result, expected)\n    \n    def test_order_by_ascending(self):\n        \"\"\"Test ORDER BY sorts records in ascending order.\"\"\"\n        command = 'SELECT name, age FROM data WHERE city = NY ORDER BY age'\n        result = run_sql_query(self.records, command)\n        ages = [item['age'] for item in result]\n        self.assertEqual(ages, [30, 35])\n    \n    def test_empty_records(self):\n        \"\"\"Test query on empty records list.\"\"\"\n        command = 'SELECT name FROM data WHERE city = NY ORDER BY age'\n        result = run_sql_query([], command)\n        self.assertEqual(result, [])\n    \n    def test_missing_field_in_condition(self):\n        \"\"\"Test condition with non-existent field raises error.\"\"\"\n        command = 'SELECT name FROM data WHERE nonexistent = value ORDER BY name'\n        with self.assertRaises(ValueError):\n            run_sql_query(self.records, command)\n    \n    def test_missing_field_in_select(self):\n        \"\"\"Test SELECT with non-existent field raises error.\"\"\"\n        command = 'SELECT nonexistent FROM data WHERE city = NY ORDER BY age'\n        with self.assertRaises(ValueError):\n            run_sql_query(self.records, command)\n    \n    def test_invalid_query_format(self):\n        \"\"\"Test invalid query format raises error.\"\"\"\n        commands = [\n            'INVALID COMMAND',\n            'SELECT name FROM data',  # Missing WHERE and ORDER BY\n            'SELECT name FROM data ORDER BY age',  # Missing WHERE\n            'SELECT name FROM data WHERE city = NY'  # Missing ORDER BY\n        ]\n        for command in commands:\n            with self.subTest(command=command):\n                with self.assertRaises(ValueError):\n                    run_sql_query(self.records, command)\n    \n    def test_invalid_operator(self):\n        \"\"\"Test condition with invalid operator raises error.\"\"\"\n        command = 'SELECT name FROM data WHERE age == 30 ORDER BY name'\n        with self.assertRaises(ValueError):\n            run_sql_query(self.records, command)\n    \n    def test_condition_value_with_space(self):\n        \"\"\"Test condition value with space raises parsing error.\"\"\"\n        command = \"SELECT name FROM data WHERE city = 'New York' ORDER BY name\"\n        with self.assertRaises(ValueError):\n            run_sql_query(self.records, command)\n    \n    def test_order_by_missing_field(self):\n        \"\"\"Test ORDER BY non-existent field raises error.\"\"\"\n        command = 'SELECT name FROM data WHERE city = NY ORDER BY nonexistent'\n        with self.assertRaises(ValueError):\n            run_sql_query(self.records, command)\n    \n    def test_condition_with_integer(self):\n        \"\"\"Test condition with integer field and value.\"\"\"\n        command = 'SELECT name FROM data WHERE age = 30 ORDER BY name'\n        result = run_sql_query(self.records, command)\n        self.assertEqual(result, [{'name': 'Alice'}])\n    \n    def test_condition_with_float(self):\n        \"\"\"Test condition with float field and value.\"\"\"\n        command = 'SELECT name FROM data WHERE height > 170.0 ORDER BY name'\n        result = run_sql_query(self.records, command)\n        names = [item['name'] for item in result]\n        self.assertEqual(names, ['Bob', 'Charlie', 'David'])\n    \n    def test_multiple_order_by_fields(self):\n        \"\"\"Test ORDER BY multiple fields raises error (unsupported).\"\"\"\n        command = 'SELECT name FROM data WHERE city = NY ORDER BY age, name'\n        with self.assertRaises(ValueError):\n            run_sql_query(self.records, command)\n    \n    def test_missing_field_float_conversion(self):\n        \"\"\"Test missing field in float condition raises error.\"\"\"\n        command = 'SELECT name FROM data WHERE weight > 50.0 ORDER BY name'\n        with self.assertRaises(ValueError):\n            run_sql_query(self.records, command)", "num_test_cases": 14, "task_id": "63b0efb6"}
{"test": "import unittest\n\nclass TestHandleSqlQuery(unittest.TestCase):\n\n    def test_basic_functionality(self):\n        # Test typical query with SELECT, WHERE, and ORDER BY\n        records = [{'name': 'Alice', 'age': 30}, {'name': 'Bob', 'age': 25}]\n        query = \"SELECT name, age FROM data WHERE age >= 25 ORDER BY age\"\n        result = handle_sql_query(records, query)\n        expected = [{'name': 'Bob', 'age': 25}, {'name': 'Alice', 'age': 30}]\n        self.assertEqual(result, expected)\n\n    def test_multiple_conditions(self):\n        # Test multiple AND conditions in WHERE clause\n        records = [\n            {'name': 'Alice', 'age': 30, 'city': 'NY'},\n            {'name': 'Bob', 'age': 25, 'city': 'LA'},\n            {'name': 'Charlie', 'age': 35, 'city': 'NY'}\n        ]\n        query = \"SELECT name, city FROM data WHERE age >= 25 AND city = NY ORDER BY name\"\n        result = handle_sql_query(records, query)\n        expected = [\n            {'name': 'Alice', 'city': 'NY'},\n            {'name': 'Charlie', 'city': 'NY'}\n        ]\n        self.assertEqual(result, expected)\n\n    def test_no_matching_records(self):\n        # Test WHERE condition that filters out all records\n        records = [{'name': 'Alice', 'age': 30}, {'name': 'Bob', 'age': 25}]\n        query = \"SELECT name FROM data WHERE age > 100 ORDER BY name\"\n        result = handle_sql_query(records, query)\n        self.assertEqual(result, [])\n\n    def test_empty_records(self):\n        # Test with empty records list\n        records = []\n        query = \"SELECT name FROM data WHERE age > 20 ORDER BY name\"\n        result = handle_sql_query(records, query)\n        self.assertEqual(result, [])\n\n    def test_malformed_query(self):\n        # Test query that doesn't match the expected pattern\n        records = [{'name': 'Alice', 'age': 30}]\n        query = \"INVALID QUERY FORMAT\"\n        with self.assertRaises(ValueError):\n            handle_sql_query(records, query)\n\n    def test_invalid_operator(self):\n        # Test condition with invalid comparison operator\n        records = [{'name': 'Alice', 'age': 30}]\n        query = \"SELECT name FROM data WHERE age <> 30 ORDER BY name\"\n        with self.assertRaises(ValueError):\n            handle_sql_query(records, query)\n\n    def test_non_existent_field_in_condition(self):\n        # Test condition referencing a field that doesn't exist in records\n        records = [{'name': 'Alice', 'age': 30}]\n        query = \"SELECT name FROM data WHERE salary > 50000 ORDER BY name\"\n        with self.assertRaises(ValueError):\n            handle_sql_query(records, query)\n\n    def test_type_conversion_failure_in_condition(self):\n        # Test condition with value that can't be converted to field type\n        records = [{'name': 'Alice', 'age': 30}]\n        query = \"SELECT name FROM data WHERE age = abc ORDER BY name\"\n        with self.assertRaises(ValueError):\n            handle_sql_query(records, query)\n\n    def test_string_condition_success(self):\n        # Test string condition with matching value\n        records = [{'name': 'Alice', 'status': 'active'}, {'name': 'Bob', 'status': 'inactive'}]\n        query = \"SELECT name FROM data WHERE status = active ORDER BY name\"\n        result = handle_sql_query(records, query)\n        expected = [{'name': 'Alice'}]\n        self.assertEqual(result, expected)\n\n    def test_string_condition_failure(self):\n        # Test string condition with non-matching value\n        records = [{'name': 'Alice', 'status': 'active'}, {'name': 'Bob', 'status': 'inactive'}]\n        query = \"SELECT name FROM data WHERE status = pending ORDER BY name\"\n        result = handle_sql_query(records, query)\n        self.assertEqual(result, [])\n\n    def test_nonexistent_order_by_field(self):\n        # Test ORDER BY referencing a non-existent field\n        records = [{'name': 'Alice', 'age': 30}]\n        query = \"SELECT name FROM data WHERE age = 30 ORDER BY salary\"\n        with self.assertRaises(ValueError):\n            handle_sql_query(records, query)\n\n    def test_nonexistent_select_field(self):\n        # Test SELECT referencing a non-existent field\n        records = [{'name': 'Alice', 'age': 30}]\n        query = \"SELECT email FROM data WHERE age = 30 ORDER BY name\"\n        with self.assertRaises(ValueError):\n            handle_sql_query(records, query)\n\n    def test_case_insensitive_query(self):\n        # Test case insensitivity of SQL keywords\n        records = [{'name': 'Alice', 'age': 30}, {'name': 'Bob', 'age': 25}]\n        query = \"select name, age from data where age >= 25 order by age\"\n        result = handle_sql_query(records, query)\n        expected = [{'name': 'Bob', 'age': 25}, {'name': 'Alice', 'age': 30}]\n        self.assertEqual(result, expected)\n\n    def test_float_condition(self):\n        # Test condition with float value\n        records = [{'product': 'A', 'price': 19.99}, {'product': 'B', 'price': 29.99}]\n        query = \"SELECT product FROM data WHERE price > 20.0 ORDER BY product\"\n        result = handle_sql_query(records, query)\n        expected = [{'product': 'B'}]\n        self.assertEqual(result, expected)\n\n    def test_negative_number_condition(self):\n        # Test condition with negative number\n        records = [{'id': 1, 'temp': -5}, {'id': 2, 'temp': 10}]\n        query = \"SELECT id FROM data WHERE temp < 0 ORDER BY id\"\n        result = handle_sql_query(records, query)\n        expected = [{'id': 1}]\n        self.assertEqual(result, expected)\n\n    def test_mixed_record_fields(self):\n        # Test with records missing condition field\n        records = [{'name': 'Alice', 'age': 30}, {'name': 'Bob'}]\n        query = \"SELECT name FROM data WHERE age > 25 ORDER BY name\"\n        with self.assertRaises(ValueError):\n            handle_sql_query(records, query)", "num_test_cases": 16, "task_id": "0fe544c5"}
{"test": "import unittest\nimport ast\n\nclass TestEvaluateExpressionSafely(unittest.TestCase):\n\n    def test_basic_addition(self):\n        # Test basic addition with numbers only\n        result = evaluate_expression_safely('2 + 3', {})\n        self.assertEqual(result, '5')\n\n    def test_basic_with_variables(self):\n        # Test addition using variables\n        result = evaluate_expression_safely('x + y', {'x': 2, 'y': 3})\n        self.assertEqual(result, '5')\n\n    def test_multiple_operations(self):\n        # Test expression with multiple operations\n        result = evaluate_expression_safely('x * y + 2', {'x': 3, 'y': 4})\n        self.assertEqual(result, '14')\n\n    def test_division(self):\n        # Test division operation\n        result = evaluate_expression_safely('x / y', {'x': 10, 'y': 2})\n        self.assertEqual(result, '5.0')\n\n    def test_empty_expression(self):\n        # Test empty expression\n        with self.assertRaises(ValueError):\n            evaluate_expression_safely('', {})\n\n    def test_single_number(self):\n        # Test expression with single number\n        result = evaluate_expression_safely('42', {})\n        self.assertEqual(result, '42')\n\n    def test_single_variable(self):\n        # Test expression with single variable\n        result = evaluate_expression_safely('x', {'x': 42})\n        self.assertEqual(result, '42')\n\n    def test_division_by_zero(self):\n        # Test division by zero\n        with self.assertRaises(ValueError):\n            evaluate_expression_safely('5 / 0', {})\n\n    def test_unsupported_operation_exponentiation(self):\n        # Test unsupported exponentiation operation\n        with self.assertRaises(ValueError):\n            evaluate_expression_safely('2 ** 3', {})\n\n    def test_overlapping_variable_names(self):\n        # Test overlapping variable names causing parse error\n        with self.assertRaises(ValueError):\n            evaluate_expression_safely('aa + b', {'a': '1', 'aa': '2'})\n\n    def test_missing_variable(self):\n        # Test expression with missing variable in mapping\n        with self.assertRaises(ValueError):\n            evaluate_expression_safely('x + y', {'x': 1})\n\n    def test_unary_minus(self):\n        # Test unsupported unary operation\n        with self.assertRaises(ValueError):\n            evaluate_expression_safely('-5', {})\n\n    def test_parentheses(self):\n        # Test expression with parentheses\n        result = evaluate_expression_safely('2 * (3 + 4)', {})\n        self.assertEqual(result, '14')\n\n    def test_parentheses_with_variables(self):\n        # Test parentheses with variables\n        result = evaluate_expression_safely('(x + y) * z', {'x': 2, 'y': 3, 'z': 4})\n        self.assertEqual(result, '20')\n\n    def test_operator_precedence(self):\n        # Test operator precedence\n        result = evaluate_expression_safely('2 + 3 * 4', {})\n        self.assertEqual(result, '14')\n\n    def test_float_literals(self):\n        # Test expression with float literals\n        result = evaluate_expression_safely('2.5 + 3.5', {})\n        self.assertEqual(result, '6.0')\n\n    def test_float_variables(self):\n        # Test expression with float variables\n        result = evaluate_expression_safely('x + y', {'x': 2.5, 'y': 3.5})\n        self.assertEqual(result, '6.0')\n\n    def test_invalid_operator_modulo(self):\n        # Test unsupported modulo operation\n        with self.assertRaises(ValueError):\n            evaluate_expression_safely('5 % 3', {})\n\n    def test_incomplete_expression(self):\n        # Test incomplete expression\n        with self.assertRaises(ValueError):\n            evaluate_expression_safely('2 +', {})\n\n    def test_non_string_expression(self):\n        # Test non-string expression input\n        with self.assertRaises(ValueError):\n            evaluate_expression_safely(123, {})\n\n    def test_non_dict_variable_mapping(self):\n        # Test non-dict variable_mapping\n        with self.assertRaises(ValueError):\n            evaluate_expression_safely('2 + 3', 'not_a_dict')\n\n    def test_variable_name_same_as_digit(self):\n        # Test variable name that matches a digit\n        result = evaluate_expression_safely('1', {'1': 5})\n        self.assertEqual(result, '5')\n\n    def test_variable_name_operator(self):\n        # Test variable name that is an operator\n        with self.assertRaises(ValueError):\n            evaluate_expression_safely('3 + 1', {'+': 2})\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 24, "task_id": "ff9191a0"}
{"test": "import unittest\n\nclass TestExecuteCalculationString(unittest.TestCase):\n\n    def test_simple_addition(self):\n        # Happy path: simple addition without variables\n        result = execute_calculation_string('2 + 3', {})\n        self.assertEqual(result, '5')\n\n    def test_simple_subtraction(self):\n        # Happy path: simple subtraction\n        result = execute_calculation_string('5 - 3', {})\n        self.assertEqual(result, '2')\n\n    def test_simple_multiplication(self):\n        # Happy path: simple multiplication\n        result = execute_calculation_string('2 * 3', {})\n        self.assertEqual(result, '6')\n\n    def test_simple_division(self):\n        # Happy path: simple division\n        result = execute_calculation_string('6 / 3', {})\n        self.assertEqual(result, '2.0')\n\n    def test_division_float_result(self):\n        # Division resulting in float\n        result = execute_calculation_string('5 / 2', {})\n        self.assertEqual(result, '2.5')\n\n    def test_with_variables(self):\n        # Expression with variable substitution\n        result = execute_calculation_string('a + b', {'a': 2, 'b': 3})\n        self.assertEqual(result, '5')\n\n    def test_operator_precedence(self):\n        # Operator precedence (multiplication before addition)\n        result = execute_calculation_string('2 + 3 * 4', {})\n        self.assertEqual(result, '14')\n\n    def test_parentheses(self):\n        # Parentheses changing precedence\n        result = execute_calculation_string('(2 + 3) * 4', {})\n        self.assertEqual(result, '20')\n\n    def test_multiple_variables_complex(self):\n        # Complex expression with multiple variables\n        result = execute_calculation_string('a * (b + c)', {'a': 2, 'b': 3, 'c': 4})\n        self.assertEqual(result, '14')\n\n    def test_whitespace_handling(self):\n        # Expression with whitespace\n        result = execute_calculation_string(' 2 + 3 ', {})\n        self.assertEqual(result, '5')\n\n    def test_long_expression(self):\n        # Longer expression without variables\n        expr = '1+2+3+4+5+6+7+8+9+10'\n        result = execute_calculation_string(expr, {})\n        self.assertEqual(result, '55')\n\n    def test_empty_expression(self):\n        # Edge case: empty expression\n        with self.assertRaises(ValueError):\n            execute_calculation_string('', {})\n\n    def test_division_by_zero(self):\n        # Error case: division by zero\n        with self.assertRaises(ValueError):\n            execute_calculation_string('5 / 0', {})\n\n    def test_invalid_expression(self):\n        # Error case: invalid expression syntax\n        with self.assertRaises(ValueError):\n            execute_calculation_string('2 +', {})\n\n    def test_missing_variable(self):\n        # Error case: missing variable in dictionary\n        with self.assertRaises(ValueError):\n            execute_calculation_string('a + b', {'a': 2})\n\n    def test_negative_constant(self):\n        # Error case: negative constant (unsupported unary operation)\n        with self.assertRaises(ValueError):\n            execute_calculation_string('-5', {})\n\n    def test_negative_variable(self):\n        # Error case: negative variable value (unsupported unary operation)\n        with self.assertRaises(ValueError):\n            execute_calculation_string('a', {'a': -5})\n\n    def test_non_string_expression(self):\n        # Error case: non-string expression input\n        with self.assertRaises(ValueError):\n            execute_calculation_string(123, {})\n\n    def test_non_string_dict_key(self):\n        # Error case: non-string key in var_dict\n        with self.assertRaises(ValueError):\n            execute_calculation_string('a', {123: 5})\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 20, "task_id": "58e460b5"}
{"test": "import unittest\n\nclass TestCases(unittest.TestCase):\n    \n    def test_case_1(self):\n        # Basic expression without variables\n        result = calculate_expression_securely(\"2+3*4\", {})\n        self.assertEqual(result, \"14\")\n    \n    def test_case_2(self):\n        # Expression with variables\n        result = calculate_expression_securely(\"a+b\", {'a':2, 'b':3})\n        self.assertEqual(result, \"5\")\n    \n    def test_case_3(self):\n        # Expression with parentheses\n        result = calculate_expression_securely(\"(2+3)*4\", {})\n        self.assertEqual(result, \"20\")\n    \n    def test_case_4(self):\n        # Division operation\n        result = calculate_expression_securely(\"10/2\", {})\n        self.assertEqual(result, \"5.0\")\n    \n    def test_case_5(self):\n        # Division by zero\n        with self.assertRaises(ValueError):\n            calculate_expression_securely(\"1/a\", {'a':0})\n    \n    def test_case_6(self):\n        # Invalid expression syntax\n        with self.assertRaises(ValueError):\n            calculate_expression_securely(\"2++3\", {})\n    \n    def test_case_7(self):\n        # Unsupported operation (exponentiation)\n        with self.assertRaises(ValueError):\n            calculate_expression_securely(\"2**3\", {})\n    \n    def test_case_8(self):\n        # Empty expression\n        with self.assertRaises(ValueError):\n            calculate_expression_securely(\"\", {})\n    \n    def test_case_9(self):\n        # Expression with spaces\n        result = calculate_expression_securely(\" 2 + 3 \", {})\n        self.assertEqual(result, \"5\")\n    \n    def test_case_10(self):\n        # Missing variable substitution\n        with self.assertRaises(ValueError):\n            calculate_expression_securely(\"a + b\", {'a':1})\n    \n    def test_case_11(self):\n        # Non-string expression input\n        with self.assertRaises(ValueError):\n            calculate_expression_securely(123, {})\n    \n    def test_case_12(self):\n        # Negative variable causing unary op (unsupported)\n        with self.assertRaises(ValueError):\n            calculate_expression_securely(\"a\", {'a':-1})\n    \n    def test_case_13(self):\n        # Negative result from subtraction\n        result = calculate_expression_securely(\"1-2\", {})\n        self.assertEqual(result, \"-1\")\n    \n    def test_case_14(self):\n        # Multiple variables\n        result = calculate_expression_securely(\"a*b - c\", {'a':2, 'b':3, 'c':4})\n        self.assertEqual(result, \"2\")\n    \n    def test_case_15(self):\n        # Float variable\n        result = calculate_expression_securely(\"a + 1\", {'a':0.5})\n        self.assertEqual(result, \"1.5\")\n    \n    def test_case_16(self):\n        # Mixed integer and float\n        result = calculate_expression_securely(\"a * 2\", {'a':0.5})\n        self.assertEqual(result, \"1.0\")\n    \n    def test_case_17(self):\n        # Variable substitution order (longer first)\n        var_substitute = {'aa': 2, 'a': 1}\n        result = calculate_expression_securely(\"a + aa\", var_substitute)\n        self.assertEqual(result, \"3\")\n    \n    def test_case_18(self):\n        # Variable substitution order (shorter first causing error)\n        var_substitute = {'a': 1, 'aa': 2}\n        with self.assertRaises(ValueError):\n            calculate_expression_securely(\"a + aa\", var_substitute)\n", "num_test_cases": 18, "task_id": "5cf42722"}
{"test": "import unittest\n\nclass TestCases(unittest.TestCase):\n    def test_basic_addition(self):\n        # Test basic addition without variables\n        result = evaluate_math_expression('2+3', {})\n        self.assertEqual(result, '5')\n\n    def test_addition_with_variables(self):\n        # Test addition with variables\n        result = evaluate_math_expression('a+b', {'a': 2, 'b': 3})\n        self.assertEqual(result, '5')\n\n    def test_multiplication(self):\n        # Test multiplication\n        result = evaluate_math_expression('2*3', {})\n        self.assertEqual(result, '6')\n\n    def test_division(self):\n        # Test division\n        result = evaluate_math_expression('6/2', {})\n        self.assertEqual(result, '3.0')\n\n    def test_subtraction(self):\n        # Test subtraction\n        result = evaluate_math_expression('5-2', {})\n        self.assertEqual(result, '3')\n\n    def test_whitespace(self):\n        # Test expression with whitespace\n        result = evaluate_math_expression(' 2 + 3 ', {})\n        self.assertEqual(result, '5')\n\n    def test_division_by_zero(self):\n        # Test division by zero\n        with self.assertRaises(ValueError):\n            evaluate_math_expression('1/0', {})\n\n    def test_undefined_variable(self):\n        # Test expression with undefined variable\n        with self.assertRaises(ValueError):\n            evaluate_math_expression('a + b', {'a': 1})\n\n    def test_invalid_expression(self):\n        # Test invalid expression syntax\n        with self.assertRaises(ValueError):\n            evaluate_math_expression('2 +', {})\n\n    def test_unsupported_operation(self):\n        # Test unsupported operation (exponentiation)\n        with self.assertRaises(ValueError):\n            evaluate_math_expression('2**3', {})\n\n    def test_parentheses(self):\n        # Test expression with parentheses\n        result = evaluate_math_expression('(2+3)*4', {})\n        self.assertEqual(result, '20')\n\n    def test_unary_negative_in_expression(self):\n        # Test unary negative in expression (not supported)\n        with self.assertRaises(ValueError):\n            evaluate_math_expression('-1', {})\n\n    def test_non_numeric_variable_value(self):\n        # Test variable with non-numeric value\n        with self.assertRaises(ValueError):\n            evaluate_math_expression('a', {'a': 'abc'})\n\n    def test_empty_formula(self):\n        # Test empty formula string\n        with self.assertRaises(ValueError):\n            evaluate_math_expression('', {})\n\n    def test_formula_as_single_variable(self):\n        # Test formula as single variable\n        result = evaluate_math_expression('a', {'a': 42})\n        self.assertEqual(result, '42')\n\n    def test_formula_as_float(self):\n        # Test float literal\n        result = evaluate_math_expression('3.14', {})\n        self.assertEqual(result, '3.14')\n\n    def test_float_variable(self):\n        # Test variable with float value\n        result = evaluate_math_expression('a', {'a': 3.14})\n        self.assertEqual(result, '3.14')\n\n    def test_complex_expression(self):\n        # Test complex expression\n        result = evaluate_math_expression('2*(3+4)/2', {})\n        self.assertEqual(result, '7.0')\n\n    def test_multi_letter_variables(self):\n        # Test multi-letter variables\n        result = evaluate_math_expression('alpha + beta', {'alpha': 1, 'beta': 2})\n        self.assertEqual(result, '3')\n\n    def test_variable_with_negative_value(self):\n        # Test variable with negative value (unary not supported)\n        with self.assertRaises(ValueError):\n            evaluate_math_expression('a', {'a': -1})", "num_test_cases": 20, "task_id": "13db34f9"}
{"test": "import unittest\n\nclass TestComputeExpressionResult(unittest.TestCase):\n\n    def test_basic_addition(self):\n        # Test simple addition without variables\n        result = compute_expression_result(\"1 + 2\", {})\n        self.assertEqual(result, \"3\")\n\n    def test_with_variables(self):\n        # Test expression with variables substitution\n        result = compute_expression_result(\"a + b\", {'a': 10, 'b': 20})\n        self.assertEqual(result, \"30\")\n\n    def test_division(self):\n        # Test division operation\n        result = compute_expression_result(\"10 / 2\", {})\n        self.assertEqual(result, \"5.0\")\n\n    def test_division_by_zero(self):\n        # Test division by zero\n        with self.assertRaises(ValueError):\n            compute_expression_result(\"1 / 0\", {})\n\n    def test_unsupported_operation_exponentiation(self):\n        # Test unsupported exponentiation operation\n        with self.assertRaises(ValueError):\n            compute_expression_result(\"2 ** 3\", {})\n\n    def test_missing_variable(self):\n        # Test expression with missing variable\n        with self.assertRaises(ValueError):\n            compute_expression_result(\"a + b\", {'a': 1})\n\n    def test_with_parentheses(self):\n        # Test expression with parentheses\n        result = compute_expression_result(\"(10 - 2) * 3\", {})\n        self.assertEqual(result, \"24\")\n\n    def test_unary_operation_unsupported(self):\n        # Test unsupported unary operation (negative number)\n        with self.assertRaises(ValueError):\n            compute_expression_result(\"-5\", {})\n\n    def test_invalid_syntax(self):\n        # Test expression with invalid syntax\n        with self.assertRaises(ValueError):\n            compute_expression_result(\"2 + \", {})\n\n    def test_empty_expression(self):\n        # Test empty expression string\n        with self.assertRaises(ValueError):\n            compute_expression_result(\"\", {})\n\n    def test_whitespace_removal(self):\n        # Test expression with whitespace is handled correctly\n        result = compute_expression_result(\"  2  +  3  \", {})\n        self.assertEqual(result, \"5\")\n\n    def test_multiple_uses_of_same_variable(self):\n        # Test multiple uses of the same variable\n        result = compute_expression_result(\"a + a\", {'a': 5})\n        self.assertEqual(result, \"10\")\n\n    def test_float_values(self):\n        # Test expression with floating point numbers\n        result = compute_expression_result(\"3.14 * 2\", {})\n        self.assertEqual(result, \"6.28\")", "num_test_cases": 13, "task_id": "cca54cf9"}
{"test": "import unittest\n\nclass TestSimplifyMathExpression(unittest.TestCase):\n\n    def test_basic_addition(self):\n        # Test basic addition without variables\n        result = simplify_math_expression(\"1 + 1\", {})\n        self.assertEqual(result, \"2\")\n\n    def test_with_variables(self):\n        # Test expression with variables\n        result = simplify_math_expression(\"a + b\", {'a': 1, 'b': 2})\n        self.assertEqual(result, \"3\")\n\n    def test_multiplication_division(self):\n        # Test multiplication and division\n        result = simplify_math_expression(\"10 * 2 / 5\", {})\n        self.assertEqual(result, \"4.0\")\n\n    def test_negative_result(self):\n        # Test expression resulting in negative number\n        result = simplify_math_expression(\"5 - 10\", {})\n        self.assertEqual(result, \"-5\")\n\n    def test_division_by_zero(self):\n        # Test division by zero\n        with self.assertRaises(ValueError):\n            simplify_math_expression(\"10 / 0\", {})\n\n    def test_missing_variable(self):\n        # Test expression with undefined variable\n        with self.assertRaises(ValueError):\n            simplify_math_expression(\"a + b\", {'a': 1})\n\n    def test_whitespace_removal(self):\n        # Test removal of whitespace\n        result = simplify_math_expression(\"  a   +   b  \", {'a': 1, 'b': 2})\n        self.assertEqual(result, \"3\")\n\n    def test_repeated_variable(self):\n        # Test repeated variable usage\n        result = simplify_math_expression(\"a + a + a\", {'a': 1})\n        self.assertEqual(result, \"3\")\n\n    def test_large_numbers(self):\n        # Test with very large numbers\n        result = simplify_math_expression(\"1000000 * 1000000\", {})\n        self.assertEqual(result, \"1000000000000\")\n\n    def test_decimal_result(self):\n        # Test decimal division result\n        result = simplify_math_expression(\"1 / 2\", {})\n        self.assertEqual(result, \"0.5\")\n\n    def test_unsupported_operator_modulo(self):\n        # Test unsupported modulo operation\n        with self.assertRaises(ValueError):\n            simplify_math_expression(\"5 % 2\", {})\n\n    def test_malformed_expression(self):\n        # Test malformed expression\n        with self.assertRaises(ValueError):\n            simplify_math_expression(\"2 +\", {})\n\n    def test_unary_negative(self):\n        # Test unary negative operator (unsupported)\n        with self.assertRaises(ValueError):\n            simplify_math_expression(\"-a\", {'a': 5})\n\n    def test_empty_expression(self):\n        # Test empty expression string\n        with self.assertRaises(ValueError):\n            simplify_math_expression(\"\", {})\n\n    def test_complex_expression(self):\n        # Test complex expression with parentheses\n        result = simplify_math_expression(\"2 * (3 + 4)\", {})\n        self.assertEqual(result, \"14\")\n", "num_test_cases": 15, "task_id": "a3fae648"}
{"test": "import unittest\n\nclass TestEvaluateExpression(unittest.TestCase):\n\n    def test_basic_addition(self):\n        # Test simple addition\n        result = evaluate_expression('2+3', {})\n        self.assertEqual(result, '5')\n\n    def test_basic_subtraction(self):\n        # Test simple subtraction\n        result = evaluate_expression('5-3', {})\n        self.assertEqual(result, '2')\n\n    def test_basic_multiplication(self):\n        # Test simple multiplication\n        result = evaluate_expression('2*3', {})\n        self.assertEqual(result, '6')\n\n    def test_basic_division(self):\n        # Test simple division\n        result = evaluate_expression('8/2', {})\n        self.assertEqual(result, '4.0')\n\n    def test_division_float(self):\n        # Test division resulting in float\n        result = evaluate_expression('5/2', {})\n        self.assertEqual(result, '2.5')\n\n    def test_with_variables(self):\n        # Test expression with variables\n        result = evaluate_expression('x + y', {'x': 2, 'y': 3})\n        self.assertEqual(result, '5')\n\n    def test_expression_with_spaces(self):\n        # Test expression with spaces\n        result = evaluate_expression(' 2 + 3 * 4 ', {})\n        self.assertEqual(result, '14')\n\n    def test_division_by_zero(self):\n        # Test division by zero\n        with self.assertRaises(ValueError):\n            evaluate_expression('5/0', {})\n\n    def test_invalid_expression_syntax(self):\n        # Test invalid expression syntax\n        with self.assertRaises(ValueError):\n            evaluate_expression('5 +', {})\n\n    def test_unmapped_variable(self):\n        # Test expression with unmapped variable\n        with self.assertRaises(ValueError):\n            evaluate_expression('x + 5', {})\n\n    def test_unsupported_operation(self):\n        # Test unsupported operation (exponentiation)\n        with self.assertRaises(ValueError):\n            evaluate_expression('2 ** 3', {})\n\n    def test_negative_number_unary(self):\n        # Test unary negative number (unsupported)\n        with self.assertRaises(ValueError):\n            evaluate_expression('-5', {})\n\n    def test_negative_after_substitution(self):\n        # Test negative number via substitution\n        with self.assertRaises(ValueError):\n            evaluate_expression('x', {'x': '-5'})\n\n    def test_float_arithmetic(self):\n        # Test float arithmetic\n        result = evaluate_expression('5.5 + 4.5', {})\n        self.assertEqual(result, '10.0')\n\n    def test_mixed_integer_float(self):\n        # Test mixed integer and float\n        result = evaluate_expression('5 + 2.5', {})\n        self.assertEqual(result, '7.5')\n\n    def test_empty_string(self):\n        # Test empty expression string\n        with self.assertRaises(ValueError):\n            evaluate_expression('', {})\n\n    def test_with_parentheses(self):\n        # Test expression with parentheses\n        result = evaluate_expression('2*(3+4)', {})\n        self.assertEqual(result, '14')\n\n    def test_nested_parentheses(self):\n        # Test expression with nested parentheses\n        result = evaluate_expression('2*(3+(4*2))', {})\n        self.assertEqual(result, '22')\n\n    def test_invalid_token(self):\n        # Test expression with invalid token\n        with self.assertRaises(ValueError):\n            evaluate_expression('5 # 3', {})\n\n    def test_variable_substitution_order_success(self):\n        # Test variable substitution order (longer first - valid)\n        result = evaluate_expression('a + ab', {'ab': '2', 'a': '1'})\n        self.assertEqual(result, '3')\n\n    def test_variable_substitution_order_failure(self):\n        # Test variable substitution order (shorter first - invalid)\n        with self.assertRaises(ValueError):\n            evaluate_expression('a + ab', {'a': '1', 'ab': '2'})\n\n    def test_variable_name_contains_digit(self):\n        # Test variable name with digits\n        result = evaluate_expression('a1 + 3', {'a1': 5})\n        self.assertEqual(result, '8')\n\n    def test_variable_name_numeric(self):\n        # Test numeric variable name substitution\n        result = evaluate_expression('123 + 456', {'123': 999})\n        self.assertEqual(result, '1455')\n\n    def test_non_numeric_variable_value(self):\n        # Test non-numeric variable value\n        with self.assertRaises(ValueError):\n            evaluate_expression('x', {'x': 'abc'})\n\n    def test_large_numbers(self):\n        # Test with large numbers\n        result = evaluate_expression('1000000 * 1000000', {})\n        self.assertEqual(result, '1000000000000')\n\n    def test_complex_expression(self):\n        # Test complex expression with multiple operations\n        result = evaluate_expression('2 * 3 + 4 / 2 - 1', {})\n        self.assertEqual(result, '7.0')", "num_test_cases": 27, "task_id": "eaa4c75a"}
{"test": "import unittest\n\nclass TestSimplifyMathExpr(unittest.TestCase):\n    \n    def test_case_1(self):\n        # Basic expression without variables\n        result = simplify_math_expr(\"2+3*4\", {})\n        self.assertEqual(result, \"14\")\n    \n    def test_case_2(self):\n        # Expression with variables\n        result = simplify_math_expr(\"x + y\", {'x': 2, 'y': 3})\n        self.assertEqual(result, \"5\")\n    \n    def test_case_3(self):\n        # Division without variables\n        result = simplify_math_expr(\"10/2\", {})\n        self.assertEqual(result, \"5.0\")\n    \n    def test_case_4(self):\n        # Division with variables\n        result = simplify_math_expr(\"a / b\", {'a':10, 'b':2})\n        self.assertEqual(result, \"5.0\")\n    \n    def test_case_5(self):\n        # Expression with parentheses\n        result = simplify_math_expr(\"2*(3+4)\", {})\n        self.assertEqual(result, \"14\")\n    \n    def test_case_6(self):\n        # Empty expression\n        with self.assertRaises(ValueError):\n            simplify_math_expr(\"\", {})\n    \n    def test_case_7(self):\n        # Expression with whitespace\n        result = simplify_math_expr(\"  2  +  3  \", {})\n        self.assertEqual(result, \"5\")\n    \n    def test_case_8(self):\n        # Expression with missing variable\n        with self.assertRaises(ValueError):\n            simplify_math_expr(\"a + 1\", {})\n    \n    def test_case_9(self):\n        # Unsupported operator (exponentiation)\n        with self.assertRaises(ValueError):\n            simplify_math_expr(\"2**3\", {})\n    \n    def test_case_10(self):\n        # Division by zero\n        with self.assertRaises(ValueError):\n            simplify_math_expr(\"1/0\", {})\n    \n    def test_case_11(self):\n        # Multiple same variables\n        result = simplify_math_expr(\"a + a + a\", {'a': 1})\n        self.assertEqual(result, \"3\")\n    \n    def test_case_12(self):\n        # Variables that are substrings, longer replaced first\n        result = simplify_math_expr(\"aa + a\", {'aa': 2, 'a': 1})\n        self.assertEqual(result, \"3\")\n    \n    def test_case_13(self):\n        # Variables that are substrings, shorter replaced first\n        with self.assertRaises(ValueError):\n            simplify_math_expr(\"aa + a\", {'a': 1, 'aa': 2})\n    \n    def test_case_14(self):\n        # Variable with non-numeric string value\n        with self.assertRaises(ValueError):\n            simplify_math_expr(\"a + 1\", {'a': 'b'})\n    \n    def test_case_15(self):\n        # Variable with numeric string value\n        result = simplify_math_expr(\"a + 1\", {'a': '2'})\n        self.assertEqual(result, \"3\")\n    \n    def test_case_16(self):\n        # Variable with non-scalar value (list)\n        with self.assertRaises(ValueError):\n            simplify_math_expr(\"a\", {'a': [1,2]})\n    \n    def test_case_17(self):\n        # Negative constant\n        with self.assertRaises(ValueError):\n            simplify_math_expr(\"-1\", {})\n    \n    def test_case_18(self):\n        # Negative variable used alone\n        with self.assertRaises(ValueError):\n            simplify_math_expr(\"a\", {'a': -1})\n    \n    def test_case_19(self):\n        # Negative variable in a binary operation\n        with self.assertRaises(ValueError):\n            simplify_math_expr(\"a + 2\", {'a': -1})\n    \n    def test_case_20(self):\n        # Complex expression with parentheses and multiple operations\n        result = simplify_math_expr(\"3*(4+5)/2\", {})\n        self.assertEqual(result, \"13.5\")", "num_test_cases": 20, "task_id": "fcb2ebc1"}
{"test": "import unittest\n\nclass TestEvaluateMathExpr(unittest.TestCase):\n    \n    def test_case_1(self):\n        # Simple expression without variables\n        result = evaluate_math_expr(\"2 + 3 * 4\", {})\n        self.assertEqual(result, \"14\")\n        \n    def test_case_2(self):\n        # Expression with variables\n        result = evaluate_math_expr(\"a + b * c\", {'a': 1, 'b': 2, 'c': 3})\n        self.assertEqual(result, \"7\")\n        \n    def test_case_3(self):\n        # Overlapping variables: short names replaced first (invalid result)\n        with self.assertRaises(ValueError):\n            evaluate_math_expr(\"aa + a\", {'a': 1, 'aa': 2})\n        \n    def test_case_4(self):\n        # Overlapping variables: long names replaced first (valid result)\n        result = evaluate_math_expr(\"aa + a\", {'aa': 2, 'a': 1})\n        self.assertEqual(result, \"3\")\n        \n    def test_case_5(self):\n        # Unary minus (unsupported operation)\n        with self.assertRaises(ValueError):\n            evaluate_math_expr(\"5 * -1\", {})\n        \n    def test_case_6(self):\n        # Division by zero\n        with self.assertRaises(ValueError):\n            evaluate_math_expr(\"1 / 0\", {})\n        \n    def test_case_7(self):\n        # Unsupported operation (exponentiation)\n        with self.assertRaises(ValueError):\n            evaluate_math_expr(\"2 ** 3\", {})\n        \n    def test_case_8(self):\n        # Parentheses (nested operations)\n        result = evaluate_math_expr(\"2 * (3 + 4)\", {})\n        self.assertEqual(result, \"14\")\n        \n    def test_case_9(self):\n        # Expression is just a number\n        result = evaluate_math_expr(\"42\", {})\n        self.assertEqual(result, \"42\")\n        \n    def test_case_10(self):\n        # Expression is a single variable\n        result = evaluate_math_expr(\"x\", {'x': 42})\n        self.assertEqual(result, \"42\")\n        \n    def test_case_11(self):\n        # Variable not in mapping\n        with self.assertRaises(ValueError):\n            evaluate_math_expr(\"x\", {})\n        \n    def test_case_12(self):\n        # Invalid expression syntax\n        with self.assertRaises(ValueError):\n            evaluate_math_expr(\"1 + \", {})\n        \n    def test_case_13(self):\n        # Variable value is non-numeric\n        with self.assertRaises(ValueError):\n            evaluate_math_expr(\"a\", {'a': 'abc'})\n        \n    def test_case_14(self):\n        # Float variable value\n        result = evaluate_math_expr(\"a\", {'a': 1.5})\n        self.assertEqual(result, \"1.5\")\n        \n    def test_case_15(self):\n        # Float operation result\n        result = evaluate_math_expr(\"1.5 * 2\", {})\n        self.assertEqual(result, \"3.0\")\n        \n    def test_case_16(self):\n        # Mixed operations resulting in float\n        result = evaluate_math_expr(\"a + b * c / d\", {'a': 10, 'b': 20, 'c': 30, 'd': 2})\n        self.assertEqual(result, \"310.0\")\n        \n    def test_case_17(self):\n        # Mixed operations resulting in integer\n        result = evaluate_math_expr(\"a + b * c\", {'a': 10, 'b': 20, 'c': 30})\n        self.assertEqual(result, \"610\")\n        \n    def test_case_18(self):\n        # Expression with spaces (should be removed)\n        result = evaluate_math_expr(\" 2   + 3  \", {})\n        self.assertEqual(result, \"5\")\n        \n    def test_case_19(self):\n        # Complex nested expression\n        result = evaluate_math_expr(\"( (10 - 2) * 3 ) / 2\", {})\n        self.assertEqual(result, \"12.0\")\n        \n    def test_case_20(self):\n        # Multiple variables with same value\n        result = evaluate_math_expr(\"a + b + c\", {'a': 5, 'b': 5, 'c': 5})\n        self.assertEqual(result, \"15\")\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 20, "task_id": "e226345b"}
{"test": "import unittest\n\nclass TestCreateHtmlTemplate(unittest.TestCase):\n\n    def test_basic_replacement(self):\n        \"\"\"Test replacement of a single placeholder.\"\"\"\n        template = \"Hello, {{name}}!\"\n        user_values = {'name': 'Alice'}\n        result = create_html_template(template, user_values)\n        self.assertEqual(result, \"Hello, Alice!\")\n\n    def test_multiple_placeholders(self):\n        \"\"\"Test replacement of multiple distinct placeholders.\"\"\"\n        template = \"{{greeting}}, {{name}}! Welcome to {{location}}.\"\n        user_values = {'greeting': 'Hello', 'name': 'Bob', 'location': 'Paris'}\n        result = create_html_template(template, user_values)\n        self.assertEqual(result, \"Hello, Bob! Welcome to Paris.\")\n\n    def test_repeated_placeholder(self):\n        \"\"\"Test replacement of a placeholder that appears multiple times.\"\"\"\n        template = \"{{word}} {{word}} {{word}}\"\n        user_values = {'word': 'repeat'}\n        result = create_html_template(template, user_values)\n        self.assertEqual(result, \"repeat repeat repeat\")\n\n    def test_no_placeholders(self):\n        \"\"\"Test template with no placeholders.\"\"\"\n        template = \"This is a static template with no placeholders.\"\n        user_values = {'unused': 'value'}\n        result = create_html_template(template, user_values)\n        self.assertEqual(result, template)\n\n    def test_empty_template(self):\n        \"\"\"Test with an empty template string.\"\"\"\n        result = create_html_template('', {'key': 'value'})\n        self.assertEqual(result, \"\")\n\n    def test_missing_placeholder(self):\n        \"\"\"Test missing placeholder in user_values raises ValueError.\"\"\"\n        template = \"Hello, {{name}}!\"\n        user_values = {'age': 30}\n        with self.assertRaises(ValueError) as context:\n            create_html_template(template, user_values)\n        self.assertIn(\"Missing values for placeholders: name\", str(context.exception))\n\n    def test_html_escaping(self):\n        \"\"\"Test that user input is properly HTML-escaped.\"\"\"\n        template = \"<div>{{content}}</div>\"\n        user_values = {'content': '<script>alert(\\'xss\\');</script>'}\n        result = create_html_template(template, user_values)\n        expected = \"<div>&lt;script&gt;alert(&#x27;xss&#x27;);&lt;/script&gt;</div>\"\n        self.assertEqual(result, expected)\n\n    def test_non_string_values(self):\n        \"\"\"Test non-string user values (converted to string and escaped).\"\"\"\n        test_cases = [\n            (42, \"42\"),\n            (3.14, \"3.14\"),\n            (None, \"None\"),\n            (True, \"True\")\n        ]\n        for value, expected_str in test_cases:\n            with self.subTest(value=value, expected_str=expected_str):\n                template = \"{{value}}\"\n                user_values = {'value': value}\n                result = create_html_template(template, user_values)\n                self.assertEqual(result, expected_str)\n\n    def test_non_matching_placeholders(self):\n        \"\"\"Test placeholders with non-alphanumeric names are left untouched.\"\"\"\n        template = \"{{valid}} {{!invalid}} {{123}} {{@#}}\"\n        user_values = {'valid': 'OK'}\n        result = create_html_template(template, user_values)\n        self.assertEqual(result, \"OK {{!invalid}} {{123}} {{@#}}\")\n\n    def test_extra_user_values(self):\n        \"\"\"Test extra keys in user_values (should be ignored).\"\"\"\n        template = \"{{a}}\"\n        user_values = {'a': 'A', 'b': 'B', 'c': 'C'}\n        result = create_html_template(template, user_values)\n        self.assertEqual(result, \"A\")\n\n    def test_multiple_missing_placeholders(self):\n        \"\"\"Test multiple missing placeholders in user_values.\"\"\"\n        template = \"{{first}} {{second}} {{third}}\"\n        user_values = {'first': '1'}\n        with self.assertRaises(ValueError) as context:\n            create_html_template(template, user_values)\n        exception_message = str(context.exception)\n        self.assertIn(\"Missing values for placeholders\", exception_message)\n        self.assertIn(\"second\", exception_message)\n        self.assertIn(\"third\", exception_message)\n\n    def test_empty_user_values_with_placeholders(self):\n        \"\"\"Test empty user_values when placeholders exist.\"\"\"\n        template = \"{{a}}{{b}}{{c}}\"\n        user_values = {}\n        with self.assertRaises(ValueError) as context:\n            create_html_template(template, user_values)\n        self.assertIn(\"Missing values for placeholders\", str(context.exception))\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 12, "task_id": "ab9b5699"}
{"test": "import unittest\nimport re\nimport html\nfrom collections import OrderedDict\n\nclass TestBuildHtmlContent(unittest.TestCase):\n\n    def test_basic_replacement(self):\n        # Test simple placeholder replacement\n        template = \"<p>Hello, {{name}}!</p>\"\n        values = {'name': 'Alice'}\n        expected = \"<p>Hello, Alice!</p>\"\n        result = build_html_content(template, values)\n        self.assertEqual(result, expected)\n\n    def test_multiple_occurrences(self):\n        # Test multiple occurrences of the same placeholder\n        template = \"<p>{{greeting}}, {{name}}! {{greeting}} again.</p>\"\n        values = {'greeting': 'Hi', 'name': 'Bob'}\n        expected = \"<p>Hi, Bob! Hi again.</p>\"\n        result = build_html_content(template, values)\n        self.assertEqual(result, expected)\n\n    def test_placeholder_in_attribute(self):\n        # Test placeholder within an HTML attribute\n        template = '<img alt=\"{{alt_text}}\" src=\"{{image_url}}\">'\n        values = {'alt_text': 'A cat', 'image_url': 'cat.jpg'}\n        expected = '<img alt=\"A cat\" src=\"cat.jpg\">'\n        result = build_html_content(template, values)\n        self.assertEqual(result, expected)\n\n    def test_escaping_html_special_chars(self):\n        # Test escaping of HTML special characters in values\n        template = \"<div>{{content}}</div>\"\n        values = {'content': '<script>alert(\\\"xss\\\")</script>'}\n        expected = \"<div>&lt;script&gt;alert(&quot;xss&quot;)&lt;/script&gt;</div>\"\n        result = build_html_content(template, values)\n        self.assertEqual(result, expected)\n\n    def test_no_placeholders(self):\n        # Test template with no placeholders and extra values\n        template = \"<h1>Static Content</h1>\"\n        values = {'extra': 'value'}\n        expected = \"<h1>Static Content</h1>\"\n        result = build_html_content(template, values)\n        self.assertEqual(result, expected)\n\n    def test_empty_template(self):\n        # Test with an empty template string\n        template = \"\"\n        values = {'key': 'value'}\n        expected = \"\"\n        result = build_html_content(template, values)\n        self.assertEqual(result, expected)\n\n    def test_missing_placeholder(self):\n        # Test missing placeholder in dictionary\n        template = \"{{missing}}\"\n        values = {}\n        with self.assertRaises(ValueError) as context:\n            build_html_content(template, values)\n        self.assertIn(\"Missing values for placeholders: missing\", str(context.exception))\n\n    def test_missing_one_of_many_placeholders(self):\n        # Test one missing placeholder among many\n        template = \"{{a}}{{b}}\"\n        values = {'a': 'A'}\n        with self.assertRaises(ValueError) as context:\n            build_html_content(template, values)\n        self.assertIn(\"Missing values for placeholders: b\", str(context.exception))\n\n    def test_non_string_values(self):\n        # Test non-string values (int, float, bool)\n        template = \"{{int_val}}, {{float_val}}, {{bool_val}}\"\n        values = {'int_val': 42, 'float_val': 3.14, 'bool_val': True}\n        expected = \"42, 3.14, True\"\n        result = build_html_content(template, values)\n        self.assertEqual(result, expected)\n\n    def test_extra_keys(self):\n        # Test dictionary with extra keys not in template\n        template = \"{{a}}\"\n        values = {'a': 'A', 'b': 'B'}\n        expected = \"A\"\n        result = build_html_content(template, values)\n        self.assertEqual(result, expected)\n\n    def test_placeholder_with_space(self):\n        # Test placeholder with space (should not be matched by regex)\n        template = \"{{first name}}\"\n        values = {'first name': 'Alice'}\n        expected = \"{{first name}}\"\n        result = build_html_content(template, values)\n        self.assertEqual(result, expected)\n\n    def test_template_none(self):\n        # Test None as template\n        with self.assertRaises(ValueError):\n            build_html_content(None, {'key': 'value'})\n\n    def test_values_dict_none(self):\n        # Test None as values_dict\n        with self.assertRaises(ValueError):\n            build_html_content(\"template\", None)\n\n    def test_recursive_replacement(self):\n        # Test recursive replacement behavior with OrderedDict\n        template = \"{{a}}\"\n        \n        # Case 1: 'a' then 'b'\n        values1 = OrderedDict([('a', '{{b}}'), ('b', 'B')])\n        result1 = build_html_content(template, values1)\n        self.assertEqual(result1, \"B\")\n        \n        # Case 2: 'b' then 'a'\n        values2 = OrderedDict([('b', 'B'), ('a', '{{b}}')])\n        result2 = build_html_content(template, values2)\n        self.assertEqual(result2, \"{{b}}\")\n\n    def test_placeholder_with_underscore_and_numbers(self):\n        # Test placeholder with underscores and numbers\n        template = \"{{user_1}}\"\n        values = {'user_1': 'Alice123'}\n        expected = \"Alice123\"\n        result = build_html_content(template, values)\n        self.assertEqual(result, expected)\n\n    def test_value_none(self):\n        # Test None as value in dictionary\n        template = \"{{value}}\"\n        values = {'value': None}\n        expected = \"None\"\n        result = build_html_content(template, values)\n        self.assertEqual(result, expected)\n\n    def test_long_string(self):\n        # Test with a very long placeholder value\n        template = \"{{long}}\"\n        long_value = 'A' * 1000\n        values = {'long': long_value}\n        expected = long_value\n        result = build_html_content(template, values)\n        self.assertEqual(result, expected)\n\n    def test_multiple_placeholders_with_special_chars(self):\n        # Test multiple placeholders with special characters\n        template = \"<div>{{title}}</div><p>{{description}}</p>\"\n        values = {\n            'title': \"<b>Hello</b>\",\n            'description': 'Line1\\nLine2 & special chars: &<>\"\\''\n        }\n        expected = \"<div>&lt;b&gt;Hello&lt;/b&gt;</div><p>Line1\\nLine2 &amp; special chars: &amp;&lt;&gt;&quot;'</p>\"\n        result = build_html_content(template, values)\n        self.assertEqual(result, expected)\n", "num_test_cases": 19, "task_id": "ed51911d"}
{"test": "import unittest\nimport re\nimport html\n\nclass TestRenderHtmlContent(unittest.TestCase):\n    \n    def test_basic_replacement(self):\n        # Test basic placeholder replacement\n        template = \"Hello, {{name}}!\"\n        mapping = {'name': 'Alice'}\n        result = render_html_content(template, mapping)\n        self.assertEqual(result, \"Hello, Alice!\")\n    \n    def test_multiple_placeholders(self):\n        # Test multiple distinct placeholders\n        template = \"{{greeting}}, {{name}}!\"\n        mapping = {'greeting': 'Hello', 'name': 'Bob'}\n        result = render_html_content(template, mapping)\n        self.assertEqual(result, \"Hello, Bob!\")\n    \n    def test_repeated_placeholder(self):\n        # Test same placeholder multiple times\n        template = \"{{word}} {{word}} {{word}}\"\n        mapping = {'word': 'repeat'}\n        result = render_html_content(template, mapping)\n        self.assertEqual(result, \"repeat repeat repeat\")\n    \n    def test_empty_template(self):\n        # Test empty template\n        template = \"\"\n        mapping = {}\n        result = render_html_content(template, mapping)\n        self.assertEqual(result, \"\")\n    \n    def test_no_placeholders(self):\n        # Test template with no placeholders\n        template = \"This is a static template.\"\n        mapping = {}\n        result = render_html_content(template, mapping)\n        self.assertEqual(result, \"This is a static template.\")\n    \n    def test_missing_placeholder(self):\n        # Test missing placeholder in mapping\n        template = \"{{name}}\"\n        mapping = {}\n        with self.assertRaises(ValueError) as context:\n            render_html_content(template, mapping)\n        self.assertIn(\"Missing values for placeholders: name\", str(context.exception))\n    \n    def test_non_word_placeholder(self):\n        # Test placeholder with non-word characters (should not be captured by regex)\n        template = \"Hello, {{first name}}!\"\n        mapping = {}\n        result = render_html_content(template, mapping)\n        self.assertEqual(result, \"Hello, {{first name}}!\")\n    \n    def test_html_escaping(self):\n        # Test HTML escaping of user inputs\n        template = \"<p>{{content}}</p>\"\n        mapping = {'content': '<script>alert(\\\"xss\\\");</script>'}\n        result = render_html_content(template, mapping)\n        expected = \"<p>&lt;script&gt;alert(&quot;xss&quot;);&lt;/script&gt;</p>\"\n        self.assertEqual(result, expected)\n    \n    def test_integer_value(self):\n        # Test integer value in mapping\n        template = \"{{number}}\"\n        mapping = {'number': 42}\n        result = render_html_content(template, mapping)\n        self.assertEqual(result, \"42\")\n    \n    def test_boolean_value(self):\n        # Test boolean value in mapping\n        template = \"{{flag}}\"\n        mapping = {'flag': True}\n        result = render_html_content(template, mapping)\n        self.assertEqual(result, \"True\")\n    \n    def test_none_value(self):\n        # Test None value in mapping\n        template = \"{{value}}\"\n        mapping = {'value': None}\n        result = render_html_content(template, mapping)\n        self.assertEqual(result, \"None\")\n    \n    def test_extra_key_not_in_template(self):\n        # Test extra key in mapping that doesn't appear in template\n        template = \"Hello\"\n        mapping = {'extra': 'value'}\n        result = render_html_content(template, mapping)\n        self.assertEqual(result, \"Hello\")\n    \n    def test_non_regex_placeholder_replacement(self):\n        # Test non-regex placeholder replaced by extra key\n        template = \"Hello {{ex tra}}\"\n        mapping = {'ex tra': 'there'}\n        result = render_html_content(template, mapping)\n        self.assertEqual(result, \"Hello there\")\n    \n    def test_mixed_regex_and_non_regex_placeholders(self):\n        # Test both regex-captured and non-captured placeholders\n        template = \"{{name}} {{first-name}}\"\n        mapping = {'name': 'John', 'first-name': 'Doe'}\n        result = render_html_content(template, mapping)\n        self.assertEqual(result, \"John Doe\")\n    \n    def test_none_template(self):\n        # Test None as html_template\n        with self.assertRaises(ValueError):\n            render_html_content(None, {'key': 'value'})\n    \n    def test_none_mapping(self):\n        # Test None as user_mapping\n        with self.assertRaises(ValueError):\n            render_html_content(\"template\", None)\n    \n    def test_non_dict_mapping(self):\n        # Test non-dictionary user_mapping\n        with self.assertRaises(ValueError):\n            render_html_content(\"template\", [\"not a dict\"])\n    \n    def test_multiple_missing_placeholders(self):\n        # Test multiple missing placeholders\n        template = \"{{name}} {{age}} {{city}}\"\n        mapping = {'name': 'Alice'}\n        with self.assertRaises(ValueError) as context:\n            render_html_content(template, mapping)\n        self.assertIn(\"Missing values for placeholders: age, city\", str(context.exception))", "num_test_cases": 18, "task_id": "c11baeaa"}
{"test": "import unittest\n\nclass TestCreateHtmlFromTemplate(unittest.TestCase):\n\n    def test_basic_replacement(self):\n        # Test basic replacement with one placeholder\n        template = \"Hello, {{name}}!\"\n        data_mapping = {\"name\": \"Alice\"}\n        result = create_html_from_template(template, data_mapping)\n        self.assertEqual(result, \"Hello, Alice!\")\n\n    def test_multiple_placeholders(self):\n        # Test replacement with multiple placeholders\n        template = \"Name: {{name}}, Age: {{age}}\"\n        data_mapping = {\"name\": \"Bob\", \"age\": 30}\n        result = create_html_from_template(template, data_mapping)\n        self.assertEqual(result, \"Name: Bob, Age: 30\")\n\n    def test_repeated_placeholder(self):\n        # Test placeholder appearing multiple times\n        template = \"{{greet}}, {{name}}! {{greet}} again!\"\n        data_mapping = {\"greet\": \"Hello\", \"name\": \"Charlie\"}\n        result = create_html_from_template(template, data_mapping)\n        self.assertEqual(result, \"Hello, Charlie! Hello again!\")\n\n    def test_empty_template(self):\n        # Test empty template string\n        template = \"\"\n        data_mapping = {\"key\": \"value\"}\n        result = create_html_from_template(template, data_mapping)\n        self.assertEqual(result, \"\")\n\n    def test_no_placeholders(self):\n        # Test template with no placeholders\n        template = \"Static content without placeholders\"\n        data_mapping = {\"unused\": \"value\"}\n        result = create_html_from_template(template, data_mapping)\n        self.assertEqual(result, \"Static content without placeholders\")\n\n    def test_extra_keys(self):\n        # Test data_mapping with extra keys not in template\n        template = \"{{key1}}\"\n        data_mapping = {\"key1\": \"value1\", \"key2\": \"value2\"}\n        result = create_html_from_template(template, data_mapping)\n        self.assertEqual(result, \"value1\")\n\n    def test_missing_placeholder(self):\n        # Test missing placeholder in data_mapping\n        template = \"{{name}} and {{age}}\"\n        data_mapping = {\"name\": \"Alice\"}\n        with self.assertRaises(ValueError) as context:\n            create_html_from_template(template, data_mapping)\n        self.assertIn(\"Missing values for placeholders: age\", str(context.exception))\n\n    def test_html_escaping(self):\n        # Test proper HTML escaping of values\n        template = \"{{content}}\"\n        data_mapping = {\"content\": \"<script>alert('xss');</script>\"}\n        result = create_html_from_template(template, data_mapping)\n        expected = \"&lt;script&gt;alert(&#x27;xss&#x27;);&lt;/script&gt;\"\n        self.assertEqual(result, expected)\n\n    def test_non_string_value(self):\n        # Test non-string value conversion and escaping\n        template = \"{{num}}\"\n        data_mapping = {\"num\": 42}\n        result = create_html_from_template(template, data_mapping)\n        self.assertEqual(result, \"42\")\n\n    def test_placeholder_substring(self):\n        # Test placeholders that are substrings of others\n        template = \"{{a}} and {{ab}}\"\n        data_mapping = {\"a\": \"A\", \"ab\": \"AB\"}\n        result = create_html_from_template(template, data_mapping)\n        self.assertEqual(result, \"A and AB\")\n\n    def test_placeholder_injection(self):\n        # Test placeholder injection via values (order-dependent)\n        template = \"{{a}} and {{b}}\"\n        data_mapping = {\"a\": \"{{b}}\", \"b\": \"B\"}\n        result = create_html_from_template(template, data_mapping)\n        self.assertEqual(result, \"B and B\")\n\n    def test_invalid_template_type(self):\n        # Test invalid template type (None)\n        with self.assertRaises(ValueError):\n            create_html_from_template(None, {\"key\": \"value\"})\n\n    def test_invalid_data_mapping_type(self):\n        # Test invalid data_mapping type (None)\n        with self.assertRaises(ValueError):\n            create_html_from_template(\"template\", None)\n\n    def test_placeholder_with_space(self):\n        # Test placeholder with space not matched by regex\n        template = \"Hello, {{first name}}!\"\n        data_mapping = {\"first name\": \"Alice\"}\n        result = create_html_from_template(template, data_mapping)\n        self.assertEqual(result, \"Hello, {{first name}}!\")\n\n    def test_case_sensitivity(self):\n        # Test case sensitivity of placeholder names\n        template = \"{{Name}}\"\n        data_mapping = {\"name\": \"alice\"}\n        with self.assertRaises(ValueError) as context:\n            create_html_from_template(template, data_mapping)\n        self.assertIn(\"Missing values for placeholders: Name\", str(context.exception))\n\n    def test_unicode_placeholder(self):\n        # Test unicode placeholder names\n        template = \"Hello, {{\\u540d\\u524d}}!\"\n        data_mapping = {\"\\u540d\\u524d\": \"Alice\"}\n        result = create_html_from_template(template, data_mapping)\n        self.assertEqual(result, \"Hello, Alice!\")\n\n    def test_large_template(self):\n        # Test large template and data mapping\n        template = \"{{start}}\" + \"A\" * 10000 + \"{{end}}\"\n        data_mapping = {\"start\": \"Begin\", \"end\": \"End\"}\n        result = create_html_from_template(template, data_mapping)\n        self.assertEqual(result, \"Begin\" + \"A\" * 10000 + \"End\")", "num_test_cases": 17, "task_id": "1df692a1"}
{"test": "import unittest\n\nclass TestBuildDynamicHTML(unittest.TestCase):\n\n    def test_basic_replacement(self):\n        # Test replacing a single placeholder\n        layout = '<p>{{name}}</p>'\n        user_data = {'name': 'Alice'}\n        result = build_dynamic_html(layout, user_data)\n        self.assertEqual(result, '<p>Alice</p>')\n\n    def test_multiple_placeholders(self):\n        # Test replacing multiple distinct placeholders\n        layout = '<div>{{name}} - {{age}}</div>'\n        user_data = {'name': 'Bob', 'age': '30'}\n        result = build_dynamic_html(layout, user_data)\n        self.assertEqual(result, '<div>Bob - 30</div>')\n\n    def test_repeated_placeholder(self):\n        # Test replacing the same placeholder multiple times\n        layout = '<p>{{word}} {{word}} {{word}}</p>'\n        user_data = {'word': 'hello'}\n        result = build_dynamic_html(layout, user_data)\n        self.assertEqual(result, '<p>hello hello hello</p>')\n\n    def test_missing_key_raises_error(self):\n        # Test missing key raises ValueError with message\n        layout = '<p>{{first}} {{last}}</p>'\n        user_data = {'first': 'John'}\n        with self.assertRaises(ValueError) as context:\n            build_dynamic_html(layout, user_data)\n        self.assertIn('Missing values for placeholders: last', str(context.exception))\n\n    def test_extra_keys_ignored(self):\n        # Test extra keys in user_data are ignored\n        layout = '<p>{{title}}</p>'\n        user_data = {'title': 'CEO', 'department': 'HR'}\n        result = build_dynamic_html(layout, user_data)\n        self.assertEqual(result, '<p>CEO</p>')\n\n    def test_empty_layout(self):\n        # Test empty layout returns empty string\n        layout = ''\n        user_data = {'key': 'value'}\n        result = build_dynamic_html(layout, user_data)\n        self.assertEqual(result, '')\n\n    def test_empty_user_data_with_placeholders(self):\n        # Test empty user_data with placeholders raises error\n        layout = '{{greeting}} world!'\n        user_data = {}\n        with self.assertRaises(ValueError) as context:\n            build_dynamic_html(layout, user_data)\n        self.assertIn('Missing values for placeholders: greeting', str(context.exception))\n\n    def test_non_string_values_converted_and_escaped(self):\n        # Test non-string values are converted to strings and escaped\n        layout = '{{int}} {{bool}} {{float}}'\n        user_data = {'int': 42, 'bool': True, 'float': 3.14}\n        result = build_dynamic_html(layout, user_data)\n        self.assertEqual(result, '42 True 3.14')\n\n    def test_html_escaping(self):\n        # Test special characters in user_data are HTML escaped\n        layout = '<p>{{content}}</p>'\n        user_data = {'content': '<script>alert(\\'xss\\')</script>'}\n        result = build_dynamic_html(layout, user_data)\n        self.assertEqual(result, '<p>&lt;script&gt;alert(&#x27;xss&#x27;)&lt;/script&gt;</p>')\n\n    def test_no_placeholders_returns_original(self):\n        # Test layout without placeholders returns unchanged\n        layout = '<h1>Static Content</h1>'\n        user_data = {'unused': 'value'}\n        result = build_dynamic_html(layout, user_data)\n        self.assertEqual(result, '<h1>Static Content</h1>')\n\n    def test_non_word_placeholder_not_replaced(self):\n        # Test placeholder with hyphen not replaced (regex only matches word chars)\n        layout = '<p>{{first-name}}</p>'\n        user_data = {'first-name': 'Jane'}\n        result = build_dynamic_html(layout, user_data)\n        self.assertEqual(result, '<p>{{first-name}}</p>')\n\n    def test_spaced_placeholder_not_replaced(self):\n        # Test placeholder with spaces not replaced\n        layout = '<p>{{ full name }}</p>'\n        user_data = {'full name': 'John Doe'}\n        result = build_dynamic_html(layout, user_data)\n        self.assertEqual(result, '<p>{{ full name }}</p>')\n\n    def test_non_string_layout_raises_error(self):\n        # Test non-string layout raises ValueError\n        layout = 123\n        user_data = {'key': 'value'}\n        with self.assertRaises(ValueError):\n            build_dynamic_html(layout, user_data)\n\n    def test_non_dict_user_data_raises_error(self):\n        # Test non-dict user_data raises ValueError\n        layout = '{{key}}'\n        user_data = ['key', 'value']\n        with self.assertRaises(ValueError):\n            build_dynamic_html(layout, user_data)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 14, "task_id": "0c24069c"}
{"test": "import unittest\nimport html\n\nclass TestConstructHtmlFromBlueprint(unittest.TestCase):\n    def test_basic_replacement(self):\n        \"\"\"Test replacement of a single placeholder.\"\"\"\n        blueprint = '<div>{{name}}</div>'\n        mappings = {'name': 'John'}\n        result = construct_html_from_blueprint(blueprint, mappings)\n        self.assertEqual(result, '<div>John</div>')\n\n    def test_multiple_occurrences(self):\n        \"\"\"Test multiple occurrences of the same placeholder.\"\"\"\n        blueprint = '<p>{{word}}</p><p>{{word}}</p>'\n        mappings = {'word': 'Hello'}\n        result = construct_html_from_blueprint(blueprint, mappings)\n        self.assertEqual(result, '<p>Hello</p><p>Hello</p>')\n\n    def test_multiple_placeholders(self):\n        \"\"\"Test different placeholders in the template.\"\"\"\n        blueprint = '<div>{{name}} - {{age}}</div>'\n        mappings = {'name': 'Alice', 'age': 30}\n        result = construct_html_from_blueprint(blueprint, mappings)\n        self.assertEqual(result, '<div>Alice - 30</div>')\n\n    def test_no_placeholders(self):\n        \"\"\"Test template without any placeholders.\"\"\"\n        blueprint = '<h1>Static Content</h1>'\n        mappings = {'unused': 'value'}\n        result = construct_html_from_blueprint(blueprint, mappings)\n        self.assertEqual(result, '<h1>Static Content</h1>')\n\n    def test_empty_template(self):\n        \"\"\"Test with an empty template string.\"\"\"\n        blueprint = ''\n        mappings = {'key': 'value'}\n        result = construct_html_from_blueprint(blueprint, mappings)\n        self.assertEqual(result, '')\n\n    def test_missing_key(self):\n        \"\"\"Test missing key in mappings triggers ValueError.\"\"\"\n        blueprint = '<div>{{name}}</div>'\n        mappings = {'wrong_key': 'John'}\n        with self.assertRaises(ValueError):\n            construct_html_from_blueprint(blueprint, mappings)\n\n    def test_extra_key_in_mappings(self):\n        \"\"\"Test extra keys in mappings that aren't in the template.\"\"\"\n        blueprint = '<div>{{key1}}</div>'\n        mappings = {'key1': 'value1', 'key2': 'value2'}\n        result = construct_html_from_blueprint(blueprint, mappings)\n        self.assertEqual(result, '<div>value1</div>')\n\n    def test_non_string_values(self):\n        \"\"\"Test non-string values converted to string and escaped.\"\"\"\n        blueprint = '<div>{{num}}</div>'\n        mappings = {'num': 42}\n        result = construct_html_from_blueprint(blueprint, mappings)\n        self.assertEqual(result, '<div>42</div>')\n\n    def test_escaping(self):\n        \"\"\"Test escaping of HTML special characters.\"\"\"\n        blueprint = '<div>{{content}}</div>'\n        mappings = {'content': '<script>alert(\\'xss\\')</script>'}\n        result = construct_html_from_blueprint(blueprint, mappings)\n        expected = '<div>&lt;script&gt;alert(&#x27;xss&#x27;)&lt;/script&gt;</div>'\n        self.assertEqual(result, expected)\n\n    def test_non_string_blueprint(self):\n        \"\"\"Test non-string blueprint triggers ValueError.\"\"\"\n        mappings = {'key': 'value'}\n        with self.assertRaises(ValueError):\n            construct_html_from_blueprint(123, mappings)\n\n    def test_non_dict_mappings(self):\n        \"\"\"Test non-dict mappings triggers ValueError.\"\"\"\n        blueprint = '<div>{{key}}</div>'\n        with self.assertRaises(ValueError):\n            construct_html_from_blueprint(blueprint, 'not_a_dict')\n\n    def test_empty_mappings(self):\n        \"\"\"Test empty mappings when template has placeholders.\"\"\"\n        blueprint = '<div>{{key}}</div>'\n        mappings = {}\n        with self.assertRaises(ValueError):\n            construct_html_from_blueprint(blueprint, mappings)\n\n    def test_mappings_none(self):\n        \"\"\"Test None as mappings triggers ValueError.\"\"\"\n        blueprint = '<div>{{key}}</div>'\n        with self.assertRaises(ValueError):\n            construct_html_from_blueprint(blueprint, None)\n\n    def test_placeholder_in_attribute(self):\n        \"\"\"Test placeholder within an HTML attribute.\"\"\"\n        blueprint = '<a href=\\\"{{link}}\\\">Click</a>'\n        mappings = {'link': 'https://example.com/?a=1&b=2'}\n        result = construct_html_from_blueprint(blueprint, mappings)\n        expected = '<a href=\\\"https://example.com/?a=1&amp;b=2\\\">Click</a>'\n        self.assertEqual(result, expected)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 14, "task_id": "fe2df7db"}
{"test": "import unittest\nimport re\nimport html\n\nclass TestCreateDynamicTemplate(unittest.TestCase):\n\n    def test_basic_placeholder(self):\n        \"\"\"Test basic functionality with one placeholder.\"\"\"\n        template = \"<p>{{name}}</p>\"\n        placeholders = {\"name\": \"John Doe\"}\n        result = create_dynamic_template(template, placeholders)\n        expected = \"<p>John Doe</p>\"\n        self.assertEqual(result, expected)\n\n    def test_multiple_placeholders(self):\n        \"\"\"Test replacement of multiple placeholders.\"\"\"\n        template = \"<div><h1>{{title}}</h1><p>{{content}}</p></div>\"\n        placeholders = {\"title\": \"Welcome\", \"content\": \"Hello, World!\"}\n        result = create_dynamic_template(template, placeholders)\n        expected = \"<div><h1>Welcome</h1><p>Hello, World!</p></div>\"\n        self.assertEqual(result, expected)\n\n    def test_special_characters_escaping(self):\n        \"\"\"Test escaping of special HTML characters in placeholder values.\"\"\"\n        template = \"<script>var str = '{{value}}';</script>\"\n        placeholders = {\"value\": \"<script>alert('xss')</script>\"}\n        result = create_dynamic_template(template, placeholders)\n        escaped_value = \"&lt;script&gt;alert(&#x27;xss&#x27;)&lt;/script&gt;\"\n        expected = f\"<script>var str = '{escaped_value}';</script>\"\n        self.assertEqual(result, expected)\n\n    def test_non_string_value_conversion(self):\n        \"\"\"Test conversion and escaping of non-string placeholder values.\"\"\"\n        template = \"<p>Value: {{num}}</p>\"\n        placeholders = {\"num\": 42}\n        result = create_dynamic_template(template, placeholders)\n        expected = \"<p>Value: 42</p>\"\n        self.assertEqual(result, expected)\n\n    def test_empty_template(self):\n        \"\"\"Test empty template string.\"\"\"\n        template = \"\"\n        placeholders = {\"key\": \"value\"}\n        result = create_dynamic_template(template, placeholders)\n        self.assertEqual(result, \"\")\n\n    def test_no_placeholders(self):\n        \"\"\"Test template with no placeholders.\"\"\"\n        template = \"<html><body>Hello</body></html>\"\n        placeholders = {\"key\": \"value\"}\n        result = create_dynamic_template(template, placeholders)\n        self.assertEqual(result, template)\n\n    def test_empty_placeholders_with_placeholders_in_template(self):\n        \"\"\"Test empty placeholders_input when template has placeholders - should raise ValueError.\"\"\"\n        template = \"<p>{{name}}</p>\"\n        placeholders = {}\n        with self.assertRaises(ValueError) as context:\n            create_dynamic_template(template, placeholders)\n        self.assertIn(\"Missing values for placeholders\", str(context.exception))\n\n    def test_extra_placeholders_in_input(self):\n        \"\"\"Test extra keys in placeholders_input that are not in the template.\"\"\"\n        template = \"<p>{{name}}</p>\"\n        placeholders = {\"name\": \"Alice\", \"age\": \"30\"}\n        result = create_dynamic_template(template, placeholders)\n        expected = \"<p>Alice</p>\"\n        self.assertEqual(result, expected)\n\n    def test_missing_single_placeholder(self):\n        \"\"\"Test missing one placeholder in input - should raise ValueError.\"\"\"\n        template = \"<p>{{first}} {{last}}</p>\"\n        placeholders = {\"first\": \"John\"}\n        with self.assertRaises(ValueError) as context:\n            create_dynamic_template(template, placeholders)\n        self.assertIn(\"Missing values for placeholders\", str(context.exception))\n        self.assertIn(\"last\", str(context.exception))\n\n    def test_missing_multiple_placeholders(self):\n        \"\"\"Test missing multiple placeholders in input - should raise ValueError.\"\"\"\n        template = \"<p>{{a}}{{b}}{{c}}</p>\"\n        placeholders = {\"a\": \"A\"}\n        with self.assertRaises(ValueError) as context:\n            create_dynamic_template(template, placeholders)\n        self.assertIn(\"Missing values for placeholders\", str(context.exception))\n        self.assertIn(\"b\", str(context.exception))\n        self.assertIn(\"c\", str(context.exception))\n\n    def test_empty_string_value(self):\n        \"\"\"Test placeholder value is an empty string.\"\"\"\n        template = \"<p>{{msg}}</p>\"\n        placeholders = {\"msg\": \"\"}\n        result = create_dynamic_template(template, placeholders)\n        expected = \"<p></p>\"\n        self.assertEqual(result, expected)\n\n    def test_value_without_escaping_needed(self):\n        \"\"\"Test placeholder value that doesn't require escaping.\"\"\"\n        template = \"<p>{{text}}</p>\"\n        placeholders = {\"text\": \"This is safe & harmless\"}\n        result = create_dynamic_template(template, placeholders)\n        expected = \"<p>This is safe &amp; harmless</p>\"\n        self.assertEqual(result, expected)\n\n    def test_none_template(self):\n        \"\"\"Test when html_template is None - should raise ValueError.\"\"\"\n        template = None\n        placeholders = {\"key\": \"value\"}\n        with self.assertRaises(ValueError):\n            create_dynamic_template(template, placeholders)\n\n    def test_non_dict_placeholders_input(self):\n        \"\"\"Test when placeholders_input is not a dictionary - should raise ValueError.\"\"\"\n        template = \"<p>{{key}}</p>\"\n        placeholders = [(\"key\", \"value\")]\n        with self.assertRaises(ValueError):\n            create_dynamic_template(template, placeholders)\n\n    def test_value_conversion_error(self):\n        \"\"\"Test placeholder value that raises exception during string conversion - should raise ValueError.\"\"\"\n        class BadStr:\n            def __str__(self):\n                raise RuntimeError(\"Conversion error\")\n        \n        template = \"<p>{{bad}}</p>\"\n        placeholders = {\"bad\": BadStr()}\n        with self.assertRaises(ValueError):\n            create_dynamic_template(template, placeholders)\n", "num_test_cases": 15, "task_id": "5466ff21"}
{"test": "import unittest\nimport re\nimport html\n\nclass TestBuildHtmlContent(unittest.TestCase):\n\n    def test_basic_replacement(self):\n        # Test basic replacement with one placeholder\n        template = \"Hello, {{name}}!\"\n        values = {'name': 'Alice'}\n        result = build_html_content(template, values)\n        self.assertEqual(result, \"Hello, Alice!\")\n\n    def test_multiple_placeholders(self):\n        # Test multiple placeholders\n        template = \"Name: {{name}}, Age: {{age}}\"\n        values = {'name': 'Bob', 'age': 30}\n        result = build_html_content(template, values)\n        self.assertEqual(result, \"Name: Bob, Age: 30\")\n\n    def test_html_escaping(self):\n        # Test escaping of HTML special characters\n        template = \"<div>{{content}}</div>\"\n        values = {'content': '<script>alert(\\\"xss\\\")</script>'}\n        result = build_html_content(template, values)\n        expected = \"<div>&lt;script&gt;alert(&quot;xss&quot;)&lt;/script&gt;</div>\"\n        self.assertEqual(result, expected)\n\n    def test_empty_template(self):\n        # Test empty template\n        result = build_html_content(\"\", {})\n        self.assertEqual(result, \"\")\n\n    def test_no_placeholders(self):\n        # Test template without placeholders\n        template = \"This is a static template.\"\n        values = {'name': 'Carol'}\n        result = build_html_content(template, values)\n        self.assertEqual(result, template)\n\n    def test_missing_placeholder(self):\n        # Test missing placeholder in user_values\n        template = \"Hello, {{first}} {{last}}!\"\n        values = {'first': 'David'}\n        with self.assertRaises(ValueError) as context:\n            build_html_content(template, values)\n        self.assertIn(\"Missing values for placeholders: last\", str(context.exception))\n\n    def test_extra_placeholder_in_dict(self):\n        # Test extra key in user_values not in template\n        template = \"{{greeting}}\"\n        values = {'greeting': 'Hi', 'name': 'Eve'}\n        result = build_html_content(template, values)\n        self.assertEqual(result, \"Hi\")\n\n    def test_non_string_value(self):\n        # Test non-string value conversion and escaping\n        template = \"Number: {{num}}\"\n        values = {'num': 42}\n        result = build_html_content(template, values)\n        self.assertEqual(result, \"Number: 42\")\n\n    def test_special_characters_escaping(self):\n        # Test escaping of all HTML special characters\n        special_chars = '&<>\\\"\\''\n        template = \"{{chars}}\"\n        values = {'chars': special_chars}\n        result = build_html_content(template, values)\n        expected = \"&amp;&lt;&gt;&quot;&#x27;\"\n        self.assertEqual(result, expected)\n\n    def test_placeholder_in_value_not_in_dict(self):\n        # Test placeholder in value not present in user_values\n        template = \"{{a}}\"\n        values = {'a': '{{b}}'}\n        result = build_html_content(template, values)\n        self.assertEqual(result, \"{{b}}\")\n\n    def test_non_string_template(self):\n        # Test non-string template input\n        with self.assertRaises(ValueError):\n            build_html_content(123, {'key': 'value'})\n\n    def test_string_key_matching_placeholder(self):\n        # Test numeric placeholder with string key\n        template = \"{{123}}\"\n        values = {'123': 'numeric_key'}\n        result = build_html_content(template, values)\n        self.assertEqual(result, \"numeric_key\")\n\n    def test_non_string_key_mismatch(self):\n        # Test integer key mismatch with string placeholder\n        template = \"{{123}}\"\n        values = {123: 'value'}\n        with self.assertRaises(ValueError) as context:\n            build_html_content(template, values)\n        self.assertIn(\"Missing values for placeholders: 123\", str(context.exception))\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 13, "task_id": "5ab7fdcd"}
{"test": "import unittest\n\nclass TestRenderHtmlTemplate(unittest.TestCase):\n\n    def test_simple_replacement(self):\n        \"\"\"Test basic placeholder replacement.\"\"\"\n        template = 'Hello, {{name}}!'\n        input_map = {'name': 'Alice'}\n        result = render_html_template(template, input_map)\n        self.assertEqual(result, 'Hello, Alice!')\n\n    def test_multiple_placeholders(self):\n        \"\"\"Test replacement of multiple placeholders.\"\"\"\n        template = '{{greeting}}, {{name}}!'\n        input_map = {'greeting': 'Hello', 'name': 'Bob'}\n        result = render_html_template(template, input_map)\n        self.assertEqual(result, 'Hello, Bob!')\n\n    def test_empty_template(self):\n        \"\"\"Test empty template returns empty string.\"\"\"\n        template = ''\n        input_map = {'key': 'value'}\n        result = render_html_template(template, input_map)\n        self.assertEqual(result, '')\n\n    def test_missing_placeholder(self):\n        \"\"\"Test missing placeholder raises ValueError.\"\"\"\n        template = '{{name}} {{age}}'\n        input_map = {'name': 'Alice'}\n        with self.assertRaises(ValueError) as context:\n            render_html_template(template, input_map)\n        self.assertIn('Missing values for placeholders', str(context.exception))\n        self.assertIn('age', str(context.exception))\n\n    def test_html_escaping(self):\n        \"\"\"Test HTML special characters are escaped.\"\"\"\n        template = '<div>{{content}}</div>'\n        input_map = {'content': '<script>alert(1)</script>'}\n        expected = '<div>&lt;script&gt;alert(1)&lt;/script&gt;</div>'\n        result = render_html_template(template, input_map)\n        self.assertEqual(result, expected)\n\n    def test_repeated_placeholder(self):\n        \"\"\"Test placeholder appearing multiple times.\"\"\"\n        template = '{{word}} {{word}} {{word}}'\n        input_map = {'word': 'test'}\n        result = render_html_template(template, input_map)\n        self.assertEqual(result, 'test test test')\n\n    def test_non_string_value(self):\n        \"\"\"Test non-string values are converted and escaped.\"\"\"\n        template = '{{int}} {{float}} {{bool}} {{none}}'\n        input_map = {'int': 42, 'float': 3.14, 'bool': True, 'none': None}\n        result = render_html_template(template, input_map)\n        self.assertEqual(result, '42 3.14 True None')\n\n    def test_no_placeholders(self):\n        \"\"\"Test template without placeholders returns unchanged.\"\"\"\n        template = 'Static content'\n        input_map = {'key': 'value'}\n        result = render_html_template(template, input_map)\n        self.assertEqual(result, 'Static content')\n\n    def test_empty_input_map_valid(self):\n        \"\"\"Test empty input_map with no placeholders.\"\"\"\n        template = 'No placeholders here'\n        input_map = {}\n        result = render_html_template(template, input_map)\n        self.assertEqual(result, template)\n\n    def test_empty_input_map_invalid(self):\n        \"\"\"Test empty input_map with placeholders raises error.\"\"\"\n        template = '{{placeholder}}'\n        input_map = {}\n        with self.assertRaises(ValueError) as context:\n            render_html_template(template, input_map)\n        self.assertIn('Missing values for placeholders', str(context.exception))\n\n    def test_non_string_template(self):\n        \"\"\"Test non-string template raises ValueError.\"\"\"\n        template = None\n        input_map = {'key': 'value'}\n        with self.assertRaises(ValueError):\n            render_html_template(template, input_map)\n\n    def test_non_dict_input_map(self):\n        \"\"\"Test non-dict input_map raises ValueError.\"\"\"\n        template = '{{key}}'\n        input_map = ['not', 'a', 'dict']\n        with self.assertRaises(ValueError):\n            render_html_template(template, input_map)\n\n    def test_extra_keys_in_input_map(self):\n        \"\"\"Test extra keys in input_map are ignored.\"\"\"\n        template = '{{key}}'\n        input_map = {'key': 'value', 'extra': 'ignored'}\n        result = render_html_template(template, input_map)\n        self.assertEqual(result, 'value')\n\n    def test_special_placeholder_names(self):\n        \"\"\"Test placeholders with non-alphanumeric names.\"\"\"\n        template = '{{name_with_underscore}} {{NameWithCaps}} {{name123}}'\n        input_map = {\n            'name_with_underscore': 'val1',\n            'NameWithCaps': 'val2',\n            'name123': 'val3'\n        }\n        expected = 'val1 val2 val3'\n        result = render_html_template(template, input_map)\n        self.assertEqual(result, expected)\n\n    def test_large_input(self):\n        \"\"\"Test with large template and input_map.\"\"\"\n        template = '{{key}}' * 1000\n        input_map = {'key': 'value'}\n        result = render_html_template(template, input_map)\n        self.assertEqual(result, 'value' * 1000)\n\n    def test_nested_placeholders(self):\n        \"\"\"Test template with adjacent placeholders.\"\"\"\n        template = '{{a}}{{b}}{{c}}'\n        input_map = {'a': 'A', 'b': 'B', 'c': 'C'}\n        result = render_html_template(template, input_map)\n        self.assertEqual(result, 'ABC')", "num_test_cases": 17, "task_id": "be5927bf"}
{"test": "import unittest\nfrom unittest.mock import patch, MagicMock\nimport subprocess\n\nclass TestRunShellCommand(unittest.TestCase):\n\n    def test_successful_command(self):\n        \"\"\"Test running a command with valid arguments successfully.\"\"\"\n        with patch('subprocess.check_output') as mock_check_output:\n            mock_check_output.return_value = \"Command output\"\n            result = run_shell_command(\"echo\", [\"Hello\"])\n            self.assertEqual(result, \"Command output\")\n\n    def test_successful_command_empty_output(self):\n        \"\"\"Test running a command that returns an empty string.\"\"\"\n        with patch('subprocess.check_output') as mock_check_output:\n            mock_check_output.return_value = \"\"\n            result = run_shell_command(\"echo\", [])\n            self.assertEqual(result, \"\")\n\n    def test_successful_command_whitespace_output(self):\n        \"\"\"Test command output with leading/trailing whitespace is properly stripped.\"\"\"\n        with patch('subprocess.check_output') as mock_check_output:\n            mock_check_output.return_value = \"  Output with spaces  \\n\"\n            result = run_shell_command(\"echo\", [\"test\"])\n            self.assertEqual(result, \"Output with spaces\")\n\n    def test_command_with_arguments(self):\n        \"\"\"Test running a command with multiple arguments.\"\"\"\n        with patch('subprocess.check_output') as mock_check_output:\n            mock_check_output.return_value = \"args output\"\n            result = run_shell_command(\"command\", [\"arg1\", \"arg2\"])\n            self.assertEqual(result, \"args output\")\n\n    def test_empty_arguments_list(self):\n        \"\"\"Test running a command with an empty arguments list.\"\"\"\n        with patch('subprocess.check_output') as mock_check_output:\n            mock_check_output.return_value = \"empty args\"\n            result = run_shell_command(\"ls\", [])\n            self.assertEqual(result, \"empty args\")\n\n    def test_command_failure_called_process_error(self):\n        \"\"\"Test command that returns non-zero exit status raises ValueError.\"\"\"\n        with patch('subprocess.check_output') as mock_check_output:\n            mock_check_output.side_effect = subprocess.CalledProcessError(\n                returncode=1, \n                cmd=\"cmd\", \n                output=b\"Error\",\n                stderr=b\"\"\n            )\n            with self.assertRaises(ValueError):\n                run_shell_command(\"invalid_cmd\", [\"arg\"])\n\n    def test_command_not_found(self):\n        \"\"\"Test non-existent command raises ValueError.\"\"\"\n        with patch('subprocess.check_output') as mock_check_output:\n            mock_check_output.side_effect = FileNotFoundError(\"Command not found\")\n            with self.assertRaises(ValueError):\n                run_shell_command(\"non_existent_command\", [])\n\n    def test_cmd_none(self):\n        \"\"\"Test passing None as command raises ValueError.\"\"\"\n        with self.assertRaises(ValueError):\n            run_shell_command(None, [\"arg\"])\n\n    def test_arguments_containing_non_string(self):\n        \"\"\"Test non-string argument in list raises ValueError.\"\"\"\n        with self.assertRaises(ValueError):\n            run_shell_command(\"echo\", [123])\n\n    def test_arguments_containing_none(self):\n        \"\"\"Test None in arguments list raises ValueError.\"\"\"\n        with self.assertRaises(ValueError):\n            run_shell_command(\"echo\", [None])\n\n    def test_empty_cmd_string(self):\n        \"\"\"Test empty command string raises ValueError.\"\"\"\n        with patch('subprocess.check_output') as mock_check_output:\n            mock_check_output.side_effect = FileNotFoundError()\n            with self.assertRaises(ValueError):\n                run_shell_command(\"\", [\"arg\"])\n\n    def test_other_exception_during_execution(self):\n        \"\"\"Test other exceptions during execution are caught and re-raised as ValueError.\"\"\"\n        with patch('subprocess.check_output') as mock_check_output:\n            mock_check_output.side_effect = PermissionError(\"Permission denied\")\n            with self.assertRaises(ValueError):\n                run_shell_command(\"restricted_command\", [])\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 12, "task_id": "ed1bfed2"}
{"test": "import unittest\nimport sys\n\nclass TestRunCommandWithArgs(unittest.TestCase):\n    def test_successful_command(self):\n        \"\"\"Test successful command execution with output.\"\"\"\n        result = run_command_with_args(sys.executable, ['-c', 'print(\"Hello, World!\")'])\n        self.assertEqual(result, \"Hello, World!\")\n    \n    def test_empty_parameters(self):\n        \"\"\"Test command with empty parameters list.\"\"\"\n        result = run_command_with_args(sys.executable, ['-c', 'print(\"OK\")'])\n        self.assertEqual(result, \"OK\")\n    \n    def test_multi_line_output(self):\n        \"\"\"Test command producing multi-line output.\"\"\"\n        result = run_command_with_args(sys.executable, ['-c', 'print(\"Line1\\\\nLine2\")'])\n        self.assertEqual(result, \"Line1\\nLine2\")\n    \n    def test_command_failure(self):\n        \"\"\"Test command that returns non-zero exit code.\"\"\"\n        with self.assertRaises(ValueError):\n            run_command_with_args(sys.executable, ['-c', 'import sys; sys.exit(1)'])\n    \n    def test_invalid_base_command(self):\n        \"\"\"Test non-existent base command.\"\"\"\n        with self.assertRaises(ValueError):\n            run_command_with_args(\"non_existent_command_xyz\", [])\n    \n    def test_empty_base_command(self):\n        \"\"\"Test empty string as base command.\"\"\"\n        with self.assertRaises(ValueError):\n            run_command_with_args(\"\", [])\n    \n    def test_non_string_base_command(self):\n        \"\"\"Test non-string type for base command.\"\"\"\n        with self.assertRaises(ValueError):\n            run_command_with_args(123, [])\n    \n    def test_non_string_parameter(self):\n        \"\"\"Test non-string type in parameters list.\"\"\"\n        with self.assertRaises(ValueError):\n            run_command_with_args(sys.executable, [123])", "num_test_cases": 8, "task_id": "c322ae23"}
{"test": "import unittest\nimport sys\n\nclass TestCallSystemCommand(unittest.TestCase):\n    \n    def test_simple_command(self):\n        # Test a basic command that produces expected output.\n        result = call_system_command(sys.executable, ['-c', 'print(\\\"hello\\\")'])\n        self.assertEqual(result, 'hello')\n    \n    def test_multiple_arguments(self):\n        # Test a command with multiple arguments.\n        result = call_system_command(sys.executable, ['-c', 'import sys; print(sys.argv[1] + \\\" \\\" + sys.argv[2])', 'hello', 'world'])\n        self.assertEqual(result, 'hello world')\n    \n    def test_non_zero_exit(self):\n        # Test a command that returns a non-zero exit code.\n        with self.assertRaises(ValueError):\n            call_system_command(sys.executable, ['-c', 'import sys; sys.exit(1)'])\n    \n    def test_non_existent_command(self):\n        # Test with a non-existent base command.\n        with self.assertRaises(ValueError):\n            call_system_command('non_existent_command', [])\n    \n    def test_empty_command_string(self):\n        # Test with an empty base command string.\n        with self.assertRaises(ValueError):\n            call_system_command('', [])\n    \n    def test_empty_params(self):\n        # Test with an empty parameters list.\n        result = call_system_command(sys.executable, ['-c', ''])\n        self.assertEqual(result, '')\n    \n    def test_special_characters_in_arguments(self):\n        # Test arguments containing special characters.\n        special_arg = 'hello; echo \\\"injection\\\"; rm -rf /'\n        result = call_system_command(sys.executable, ['-c', 'import sys; print(sys.argv[1])', special_arg])\n        self.assertEqual(result, special_arg)\n    \n    def test_non_string_param(self):\n        # Test non-string parameter in the arguments list.\n        with self.assertRaises(ValueError):\n            call_system_command('echo', [123])\n    \n    def test_non_string_command(self):\n        # Test non-string base command.\n        with self.assertRaises(ValueError):\n            call_system_command(456, ['arg'])", "num_test_cases": 9, "task_id": "08772571"}
{"test": "import unittest\nfrom unittest.mock import patch\nimport shlex\nimport subprocess\nfrom solution import run_shell_cmd\n\nclass TestRunShellCmd(unittest.TestCase):\n\n    @patch('subprocess.check_output')\n    def test_echo_single_arg(self, mock_check_output):\n        \"\"\"Test command with single argument returns expected output.\"\"\"\n        mock_check_output.return_value = \"hello\\n\"\n        result = run_shell_cmd('echo', ['hello'])\n        self.assertEqual(result, \"hello\")\n\n    @patch('subprocess.check_output')\n    def test_echo_multiple_args(self, mock_check_output):\n        \"\"\"Test command with multiple arguments returns combined output.\"\"\"\n        mock_check_output.return_value = \"hello world\\n\"\n        result = run_shell_cmd('echo', ['hello', 'world'])\n        self.assertEqual(result, \"hello world\")\n\n    @patch('subprocess.check_output')\n    def test_no_arguments(self, mock_check_output):\n        \"\"\"Test command with no arguments returns empty output.\"\"\"\n        mock_check_output.return_value = \"\\n\"\n        result = run_shell_cmd('echo', [])\n        self.assertEqual(result, \"\")\n\n    @patch('subprocess.check_output')\n    def test_command_with_special_chars(self, mock_check_output):\n        \"\"\"Test command with special characters in arguments.\"\"\"\n        mock_check_output.return_value = \"safe output\\n\"\n        args = [\"arg;with&special|chars\", \"'quoted'\"]\n        result = run_shell_cmd('echo', args)\n        self.assertEqual(result, \"safe output\")\n        # Verify arguments were properly sanitized\n        call_args = mock_check_output.call_args[0][0]\n        expected_args = ['echo'] + [shlex.quote(arg) for arg in args]\n        self.assertEqual(call_args, expected_args)\n\n    @patch('subprocess.check_output')\n    def test_empty_command_name(self, mock_check_output):\n        \"\"\"Test empty command name raises ValueError.\"\"\"\n        mock_check_output.side_effect = FileNotFoundError(\"Command not found\")\n        with self.assertRaises(ValueError):\n            run_shell_cmd('', ['arg'])\n\n    @patch('subprocess.check_output')\n    def test_command_not_found(self, mock_check_output):\n        \"\"\"Test non-existent command raises ValueError.\"\"\"\n        mock_check_output.side_effect = FileNotFoundError(\"Command not found\")\n        with self.assertRaises(ValueError) as context:\n            run_shell_cmd('nonexistent_command', [])\n        self.assertIn(\"Command not found\", str(context.exception))\n\n    @patch('subprocess.check_output')\n    def test_command_failure(self, mock_check_output):\n        \"\"\"Test command returning non-zero exit raises ValueError.\"\"\"\n        mock_check_output.side_effect = subprocess.CalledProcessError(1, 'cmd', \"error\")\n        with self.assertRaises(ValueError) as context:\n            run_shell_cmd('failing_command', [])\n        self.assertIn(\"Command execution failed\", str(context.exception))\n\n    @patch('subprocess.check_output')\n    def test_other_exception(self, mock_check_output):\n        \"\"\"Test other exceptions during execution raise ValueError.\"\"\"\n        mock_check_output.side_effect = OSError(13, \"Permission denied\")\n        with self.assertRaises(ValueError) as context:\n            run_shell_cmd('restricted_command', [])\n        self.assertIn(\"Error executing command\", str(context.exception))", "num_test_cases": 8, "task_id": "08885c8c"}
{"test": "import unittest\nimport shlex\nfrom unittest.mock import patch, MagicMock\n\nclass TestRunCommand(unittest.TestCase):\n\n    def test_basic_command_success(self):\n        \"\"\"Test successful execution with basic command and arguments.\"\"\"\n        with patch('subprocess.check_output') as mock_check_output:\n            mock_check_output.return_value = \"Hello, World!\"\n            result = run_command('echo', ['Hello,', 'World!'])\n            self.assertEqual(result, \"Hello, World!\")\n            expected_cmd = ['echo', shlex.quote('Hello,'), shlex.quote('World!')]\n            mock_check_output.assert_called_once_with(expected_cmd, text=True)\n\n    def test_command_no_arguments(self):\n        \"\"\"Test command execution with no arguments.\"\"\"\n        with patch('subprocess.check_output') as mock_check_output:\n            mock_check_output.return_value = \"output\"\n            result = run_command('pwd', [])\n            self.assertEqual(result, \"output\")\n            mock_check_output.assert_called_once_with(['pwd'], text=True)\n\n    def test_command_with_special_characters(self):\n        \"\"\"Test arguments containing special characters are properly quoted.\"\"\"\n        with patch('subprocess.check_output') as mock_check_output:\n            mock_check_output.return_value = \"special output\"\n            args = [\"hello; echo world\", \"$PATH\", \"'single'\\\"double\\\"\"]\n            result = run_command('echo', args)\n            self.assertEqual(result, \"special output\")\n            expected_cmd = ['echo'] + [shlex.quote(arg) for arg in args]\n            mock_check_output.assert_called_once_with(expected_cmd, text=True)\n\n    def test_empty_command_string(self):\n        \"\"\"Test empty command string raises ValueError.\"\"\"\n        with patch('subprocess.check_output') as mock_check_output:\n            mock_check_output.side_effect = FileNotFoundError(\"Command not found\")\n            with self.assertRaises(ValueError):\n                run_command('', ['arg1'])\n\n    def test_non_existent_command(self):\n        \"\"\"Test non-existent command raises ValueError.\"\"\"\n        with patch('subprocess.check_output') as mock_check_output:\n            mock_check_output.side_effect = FileNotFoundError(\"Command not found\")\n            with self.assertRaises(ValueError):\n                run_command('nonexistent_command', [])\n\n    def test_command_failure_raises_value_error(self):\n        \"\"\"Test command returning non-zero exit status raises ValueError.\"\"\"\n        with patch('subprocess.check_output') as mock_check_output:\n            mock_check_output.side_effect = subprocess.CalledProcessError(1, 'cmd')\n            with self.assertRaises(ValueError):\n                run_command('ls', ['/nonexistent'])\n\n    def test_output_stripping(self):\n        \"\"\"Test that output is properly stripped of surrounding whitespace.\"\"\"\n        with patch('subprocess.check_output') as mock_check_output:\n            mock_check_output.return_value = \"  output with spaces  \\n\"\n            result = run_command('echo', ['test'])\n            self.assertEqual(result, \"output with spaces\")\n\n    def test_empty_argument(self):\n        \"\"\"Test handling of empty string argument.\"\"\"\n        with patch('subprocess.check_output') as mock_check_output:\n            mock_check_output.return_value = \"output\"\n            result = run_command('echo', [''])\n            self.assertEqual(result, \"output\")\n            expected_cmd = ['echo', shlex.quote('')]\n            mock_check_output.assert_called_once_with(expected_cmd, text=True)\n\n    def test_multiple_arguments(self):\n        \"\"\"Test command with multiple arguments including flags.\"\"\"\n        with patch('subprocess.check_output') as mock_check_output:\n            mock_check_output.return_value = \"output\"\n            args = ['-l', '-a', '/path']\n            result = run_command('ls', args)\n            self.assertEqual(result, \"output\")\n            expected_cmd = ['ls'] + [shlex.quote(arg) for arg in args]\n            mock_check_output.assert_called_once_with(expected_cmd, text=True)\n\n    def test_unexpected_exception_handling(self):\n        \"\"\"Test any unexpected exception is caught and re-raised as ValueError.\"\"\"\n        with patch('subprocess.check_output') as mock_check_output:\n            mock_check_output.side_effect = RuntimeError(\"Unexpected error\")\n            with self.assertRaises(ValueError):\n                run_command('valid_cmd', [])\n\nif __name__ == '__main__':\n    unittest.main()\n", "num_test_cases": 10, "task_id": "b0cbc92c"}
{"test": "import unittest\nfrom unittest.mock import patch\nimport subprocess\nimport shlex\n\nclass TestExecuteCommand(unittest.TestCase):\n\n    @patch('subprocess.check_output')\n    def test_basic_command(self, mock_check_output):\n        # Test basic command with parameters\n        mock_check_output.return_value = 'hello world\\n'\n        result = execute_command('echo', ['hello', 'world'])\n        self.assertEqual(result, 'hello world')\n        mock_check_output.assert_called_with(['echo', 'hello', 'world'], text=True)\n\n    @patch('subprocess.check_output')\n    def test_empty_parameters(self, mock_check_output):\n        # Test command with no parameters\n        mock_check_output.return_value = 'file1\\nfile2\\n'\n        result = execute_command('ls', [])\n        self.assertEqual(result, 'file1\\nfile2')\n        mock_check_output.assert_called_with(['ls'], text=True)\n\n    @patch('subprocess.check_output')\n    def test_empty_output(self, mock_check_output):\n        # Test command producing empty output\n        mock_check_output.return_value = ''\n        result = execute_command('echo', ['-n'])\n        self.assertEqual(result, '')\n        mock_check_output.assert_called_with(['echo', '-n'], text=True)\n\n    @patch('subprocess.check_output')\n    def test_multi_line_output(self, mock_check_output):\n        # Test command with multi-line output\n        mock_check_output.return_value = 'line1\\nline2\\n'\n        result = execute_command('cat', ['file.txt'])\n        self.assertEqual(result, 'line1\\nline2')\n        mock_check_output.assert_called_with(['cat', 'file.txt'], text=True)\n\n    @patch('subprocess.check_output')\n    def test_called_process_error(self, mock_check_output):\n        # Test command returning non-zero exit status\n        mock_check_output.side_effect = subprocess.CalledProcessError(returncode=1, cmd='echo', output='error')\n        with self.assertRaises(ValueError) as context:\n            execute_command('echo', ['error'])\n        self.assertIn('Command execution failed', str(context.exception))\n\n    @patch('subprocess.check_output')\n    def test_file_not_found(self, mock_check_output):\n        # Test non-existent command\n        mock_check_output.side_effect = FileNotFoundError('command not found')\n        with self.assertRaises(ValueError) as context:\n            execute_command('nonexistent_command', [])\n        self.assertIn('Error executing command', str(context.exception))\n\n    @patch('subprocess.check_output')\n    def test_non_string_base_command(self, mock_check_output):\n        # Test base_command as non-string (integer)\n        mock_check_output.side_effect = TypeError(\"expected str, bytes or os.PathLike object, not int\")\n        with self.assertRaises(ValueError) as context:\n            execute_command(123, ['a', 'b'])\n        self.assertIn('Error executing command', str(context.exception))\n\n    @patch('subprocess.check_output')\n    def test_non_string_parameter(self, mock_check_output):\n        # Test parameter as non-string (integer)\n        with self.assertRaises(ValueError) as context:\n            execute_command('echo', [123])\n        mock_check_output.assert_not_called()\n        self.assertIn('Error executing command', str(context.exception))\n\n    @patch('subprocess.check_output')\n    def test_os_error(self, mock_check_output):\n        # Test OSError (permission denied)\n        mock_check_output.side_effect = OSError(13, 'Permission denied')\n        with self.assertRaises(ValueError) as context:\n            execute_command('restricted_command', [])\n        self.assertIn('Error executing command', str(context.exception))\n\n    @patch('subprocess.check_output')\n    def test_parameter_with_space(self, mock_check_output):\n        # Test parameter with space (check quoting)\n        mock_check_output.return_value = 'hello world\\n'\n        result = execute_command('echo', ['hello world'])\n        self.assertEqual(result, 'hello world')\n        expected_command = ['echo', shlex.quote('hello world')]\n        mock_check_output.assert_called_with(expected_command, text=True)", "num_test_cases": 10, "task_id": "ffc6ada9"}
{"test": "import unittest\nfrom unittest.mock import patch\nimport subprocess\nimport shlex\n\nclass TestRunShellCmd(unittest.TestCase):\n\n    @patch('subprocess.check_output')\n    def test_simple_command(self, mock_check_output):\n        # Test basic command with parameters returns expected output\n        mock_check_output.return_value = \"hello world\"\n        result = run_shell_cmd(\"echo\", [\"hello\", \"world\"])\n        self.assertEqual(result, \"hello world\")\n\n    @patch('subprocess.check_output')\n    def test_no_parameters(self, mock_check_output):\n        # Test command with empty parameters list\n        mock_check_output.return_value = \"\\n\"\n        result = run_shell_cmd(\"echo\", [])\n        self.assertEqual(result, \"\")\n\n    @patch('subprocess.check_output')\n    def test_quoted_parameters_output(self, mock_check_output):\n        # Test parameters requiring quoting return expected output\n        mock_check_output.return_value = \"hello world\"\n        result = run_shell_cmd(\"echo\", [\"hello world\"])\n        self.assertEqual(result, \"hello world\")\n\n    @patch('subprocess.check_output')\n    def test_command_building_simple(self, mock_check_output):\n        # Test command building with standard parameters\n        run_shell_cmd(\"echo\", [\"a\", \"b\"])\n        expected = ['echo', 'a', 'b']\n        mock_check_output.assert_called_with(expected, text=True)\n\n    @patch('subprocess.check_output')\n    def test_command_building_with_space(self, mock_check_output):\n        # Test parameters with spaces are properly quoted\n        run_shell_cmd(\"echo\", [\"a b\", \"c\"])\n        expected = ['echo', shlex.quote(\"a b\"), 'c']\n        mock_check_output.assert_called_with(expected, text=True)\n\n    @patch('subprocess.check_output')\n    def test_command_fails_with_called_process_error(self, mock_check_output):\n        # Test non-zero exit status raises ValueError\n        mock_check_output.side_effect = subprocess.CalledProcessError(returncode=1, cmd='echo', output='error')\n        with self.assertRaises(ValueError) as context:\n            run_shell_cmd(\"echo\", [\"hello\"])\n        self.assertIn(\"Command execution failed\", str(context.exception))\n\n    @patch('subprocess.check_output')\n    def test_command_fails_with_file_not_found(self, mock_check_output):\n        # Test invalid command raises ValueError\n        mock_check_output.side_effect = FileNotFoundError(\"command not found\")\n        with self.assertRaises(ValueError) as context:\n            run_shell_cmd(\"nonexistent\", [])\n        self.assertIn(\"Error executing command\", str(context.exception))\n\n    @patch('subprocess.check_output')\n    def test_command_fails_with_generic_exception(self, mock_check_output):\n        # Test unexpected exceptions raise ValueError\n        mock_check_output.side_effect = Exception(\"generic error\")\n        with self.assertRaises(ValueError) as context:\n            run_shell_cmd(\"echo\", [])\n        self.assertIn(\"Error executing command\", str(context.exception))\n\n    def test_params_none(self):\n        # Test None as parameters raises ValueError\n        with self.assertRaises(ValueError) as context:\n            run_shell_cmd(\"echo\", None)\n        self.assertIn(\"Error executing command\", str(context.exception))\n\n    @patch('subprocess.check_output')\n    def test_empty_cmd_string(self, mock_check_output):\n        # Test empty command string raises ValueError\n        mock_check_output.side_effect = FileNotFoundError(\"command not found\")\n        with self.assertRaises(ValueError) as context:\n            run_shell_cmd(\"\", [])\n        self.assertIn(\"Error executing command\", str(context.exception))\n\n    @patch('subprocess.check_output')\n    def test_params_with_empty_string(self, mock_check_output):\n        # Test empty string parameter is properly handled\n        mock_check_output.return_value = \"output\"\n        result = run_shell_cmd(\"echo\", [\"\"])\n        self.assertEqual(result, \"output\")\n        expected = ['echo', \"''\"]\n        mock_check_output.assert_called_with(expected, text=True)\n\n    @patch('subprocess.check_output')\n    def test_output_stripping(self, mock_check_output):\n        # Test output is stripped of whitespace\n        mock_check_output.return_value = \"  hello world  \\n\"\n        result = run_shell_cmd(\"echo\", [])\n        self.assertEqual(result, \"hello world\")\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 12, "task_id": "e74f521e"}
{"test": "import unittest\nimport shlex\nimport subprocess\nimport sys\n\nclass TestCases(unittest.TestCase):\n    def test_case_1(self):\n        \"\"\"Test command without arguments that succeeds and produces no output.\"\"\"\n        # Using 'true' which should succeed without output\n        result = execute_command('true', [])\n        self.assertEqual(result, '')\n    \n    def test_case_2(self):\n        \"\"\"Test command with a single argument.\"\"\"\n        # Using 'echo' with one word, expecting the quoted output\n        arg = 'hello'\n        quoted_arg = shlex.quote(arg)\n        result = execute_command('echo', [arg])\n        self.assertEqual(result, quoted_arg)\n    \n    def test_case_3(self):\n        \"\"\"Test command with an argument containing a space.\"\"\"\n        # Using 'echo' with two words, expecting the quoted output\n        arg = 'hello world'\n        quoted_arg = shlex.quote(arg)\n        result = execute_command('echo', [arg])\n        self.assertEqual(result, quoted_arg)\n    \n    def test_case_4(self):\n        \"\"\"Test command that returns non-zero exit status.\"\"\"\n        # Using 'false' which should fail\n        with self.assertRaises(ValueError):\n            execute_command('false', [])\n    \n    def test_case_5(self):\n        \"\"\"Test non-existent command.\"\"\"\n        with self.assertRaises(ValueError):\n            execute_command('non_existent_command_xyz', [])\n    \n    def test_case_6(self):\n        \"\"\"Test empty command string.\"\"\"\n        with self.assertRaises(ValueError):\n            execute_command('', [])\n    \n    def test_case_7(self):\n        \"\"\"Test command with empty string argument.\"\"\"\n        arg = ''\n        quoted_arg = shlex.quote(arg)\n        result = execute_command('echo', [arg])\n        self.assertEqual(result, quoted_arg)\n    \n    def test_case_8(self):\n        \"\"\"Test command that fails due to invalid arguments with expected quoting issue.\"\"\"\n        # This test expects failure because the function's quoting breaks option handling\n        with self.assertRaises(ValueError):\n            execute_command(sys.executable, ['-c', 'print(123)'])\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 8, "task_id": "7b940cab"}
{"test": "import unittest\nimport shlex\nfrom unittest.mock import patch\nimport subprocess\n\nclass TestRunShellCommand(unittest.TestCase):\n\n    def test_simple_command(self):\n        # Test with safe parameters (no special characters)\n        with patch('subprocess.check_output') as mock_check:\n            mock_check.return_value = 'expected output'\n            result = run_shell_command('echo', ['hello', 'world'])\n            mock_check.assert_called_with(['echo', 'hello', 'world'], text=True)\n            self.assertEqual(result, 'expected output')\n\n    def test_unsafe_parameter(self):\n        # Test with parameter containing special characters (space)\n        with patch('subprocess.check_output') as mock_check:\n            mock_check.return_value = 'expected output'\n            param = 'hello world'\n            result = run_shell_command('echo', [param])\n            expected_arg = shlex.quote(param)\n            mock_check.assert_called_with(['echo', expected_arg], text=True)\n            self.assertEqual(result, 'expected output')\n\n    def test_empty_parameters(self):\n        # Test with empty parameters list\n        with patch('subprocess.check_output') as mock_check:\n            mock_check.return_value = 'expected output'\n            result = run_shell_command('echo', [])\n            mock_check.assert_called_with(['echo'], text=True)\n            self.assertEqual(result, 'expected output')\n\n    def test_failure_called_process_error(self):\n        # Test handling of CalledProcessError\n        with patch('subprocess.check_output') as mock_check:\n            mock_check.side_effect = subprocess.CalledProcessError(1, 'cmd')\n            with self.assertRaises(ValueError):\n                run_shell_command('invalid_cmd', ['arg'])\n\n    def test_failure_file_not_found(self):\n        # Test handling of FileNotFoundError\n        with patch('subprocess.check_output') as mock_check:\n            mock_check.side_effect = FileNotFoundError('command not found')\n            with self.assertRaises(ValueError):\n                run_shell_command('nonexistent', ['arg'])\n\n    def test_failure_generic_exception(self):\n        # Test handling of generic exception\n        with patch('subprocess.check_output') as mock_check:\n            mock_check.side_effect = Exception('generic error')\n            with self.assertRaises(ValueError):\n                run_shell_command('echo', ['arg'])\n\n    def test_empty_shell_command(self):\n        # Test with empty string as shell_command\n        with patch('subprocess.check_output') as mock_check:\n            mock_check.return_value = 'output'\n            result = run_shell_command('', [])\n            mock_check.assert_called_with([''], text=True)\n            self.assertEqual(result, 'output')\n\n    def test_shell_command_none(self):\n        # Test None as shell_command (invalid input)\n        with self.assertRaises(ValueError):\n            run_shell_command(None, [])\n\n    def test_parameters_not_list_but_string(self):\n        # Test parameters passed as string instead of list\n        with patch('subprocess.check_output') as mock_check:\n            mock_check.return_value = 'output'\n            result = run_shell_command('echo', 'hello')\n            expected_args = ['echo'] + [shlex.quote(c) for c in 'hello']\n            mock_check.assert_called_with(expected_args, text=True)\n            self.assertEqual(result, 'output')\n\n    def test_parameters_none(self):\n        # Test None as parameters (invalid input)\n        with self.assertRaises(ValueError):\n            run_shell_command('echo', None)\n\n    def test_parameters_containing_non_string(self):\n        # Test parameters containing non-string value\n        with self.assertRaises(ValueError):\n            run_shell_command('echo', [123])\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 11, "task_id": "f87c3c68"}
{"test": "import unittest\nfrom unittest.mock import patch\nfrom solution import restricted_command_executor\n\nclass TestRestrictedCommandExecutor(unittest.TestCase):\n\n    @patch('solution.os.popen')\n    def test_happy_path(self, mock_popen):\n        \"\"\"Test basic allowed command with expected output.\"\"\"\n        mock_popen.return_value.read.return_value = \"hello\\n\"\n        result = restricted_command_executor(\"echo hello\", ['echo', 'hello'])\n        self.assertEqual(result, \"hello\\n\")\n\n    @patch('solution.os.popen')\n    def test_multiple_parts(self, mock_popen):\n        \"\"\"Test command with multiple allowed parts.\"\"\"\n        mock_popen.return_value.read.return_value = \"hello world\\n\"\n        result = restricted_command_executor(\"echo hello world\", ['echo', 'hello', 'world'])\n        self.assertEqual(result, \"hello world\\n\")\n\n    def test_disallowed_part(self):\n        \"\"\"Test command with one disallowed part.\"\"\"\n        result = restricted_command_executor(\"echo forbidden\", ['echo'])\n        self.assertEqual(result, \"Disallowed command or subcommand.\")\n\n    def test_disallowed_base_command(self):\n        \"\"\"Test command with disallowed base command.\"\"\"\n        result = restricted_command_executor(\"forbidden hello\", ['hello'])\n        self.assertEqual(result, \"Disallowed command or subcommand.\")\n\n    def test_empty_command(self):\n        \"\"\"Test empty command string.\"\"\"\n        result = restricted_command_executor(\"\", ['echo'])\n        self.assertEqual(result, \"Disallowed command or subcommand.\")\n\n    @patch('solution.os.popen')\n    def test_quoted_command(self, mock_popen):\n        \"\"\"Test quoted command that tokenizes to allowed parts.\"\"\"\n        mock_popen.return_value.read.return_value = \"hello\\n\"\n        result = restricted_command_executor('echo \"hello\"', ['echo', 'hello'])\n        self.assertEqual(result, \"hello\\n\")\n\n    def test_empty_whitelist(self):\n        \"\"\"Test non-empty command with empty whitelist.\"\"\"\n        result = restricted_command_executor(\"echo hello\", [])\n        self.assertEqual(result, \"Disallowed command or subcommand.\")\n\n    @patch('solution.os.popen')\n    def test_empty_string_part(self, mock_popen):\n        \"\"\"Test command containing empty string part that is whitelisted.\"\"\"\n        mock_popen.return_value.read.return_value = \"\\n\"\n        result = restricted_command_executor(\"echo ''\", ['echo', ''])\n        self.assertEqual(result, \"\\n\")\n\n    @patch('solution.os.popen')\n    def test_command_with_only_empty_string(self, mock_popen):\n        \"\"\"Test command consisting solely of whitelisted empty string.\"\"\"\n        mock_popen.return_value.read.return_value = \"\"\n        result = restricted_command_executor(\"''\", [''])\n        self.assertEqual(result, \"\")\n\n    @patch('solution.os.popen')\n    def test_os_popen_raises_exception(self, mock_popen):\n        \"\"\"Test behavior when os.popen raises an exception.\"\"\"\n        mock_popen.side_effect = OSError\n        result = restricted_command_executor(\"echo hello\", ['echo','hello'])\n        self.assertEqual(result, \"Disallowed command or subcommand.\")\n\n    def test_whitelist_substring_not_allowed(self):\n        \"\"\"Test that substring of whitelist command is rejected.\"\"\"\n        result = restricted_command_executor(\"ech\", ['echo'])\n        self.assertEqual(result, \"Disallowed command or subcommand.\")\n\n    def test_whitelist_superstring_not_allowed(self):\n        \"\"\"Test that superstring of whitelist command is rejected.\"\"\"\n        result = restricted_command_executor(\"echoo\", ['echo'])\n        self.assertEqual(result, \"Disallowed command or subcommand.\")\n\n    def test_partial_command_match(self):\n        \"\"\"Test command where only some parts are allowed.\"\"\"\n        result = restricted_command_executor(\"echo hello world\", ['echo', 'hello'])\n        self.assertEqual(result, \"Disallowed command or subcommand.\")\n\n    @patch('solution.os.popen')\n    def test_repeated_whitelist_parts(self, mock_popen):\n        \"\"\"Test command with repeated allowed parts.\"\"\"\n        mock_popen.return_value.read.return_value = \"echo\\n\"\n        result = restricted_command_executor(\"echo echo\", ['echo'])\n        self.assertEqual(result, \"echo\\n\")\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 15, "task_id": "84e8ca35"}
{"test": "import unittest\nfrom unittest.mock import patch\n\nclass TestExecutePermittedCommand(unittest.TestCase):\n\n    def test_single_allowed_command(self):\n        # Test one allowed token with mocked successful output\n        with patch('os.popen') as mock_popen:\n            mock_popen.return_value.read.return_value = \"success\"\n            result = execute_permitted_command(\"ls\", [\"ls\"])\n            self.assertEqual(result, \"success\")\n\n    def test_multiple_allowed_commands(self):\n        # Test multiple allowed tokens with mocked successful output\n        with patch('os.popen') as mock_popen:\n            mock_popen.return_value.read.return_value = \"success\"\n            result = execute_permitted_command(\"ls -l\", [\"ls\", \"-l\"])\n            self.assertEqual(result, \"success\")\n\n    def test_single_disallowed_command(self):\n        # Test one token not in approved commands\n        result = execute_permitted_command(\"rm\", [\"ls\"])\n        self.assertEqual(result, \"Disallowed command or subcommand.\")\n\n    def test_partially_disallowed_command(self):\n        # Test multiple tokens with one not in approved commands\n        result = execute_permitted_command(\"ls -R\", [\"ls\", \"-l\"])\n        self.assertEqual(result, \"Disallowed command or subcommand.\")\n\n    def test_empty_command(self):\n        # Test empty command string\n        result = execute_permitted_command(\"\", [\"ls\"])\n        self.assertEqual(result, \"Disallowed command or subcommand.\")\n\n    def test_execution_failure(self):\n        # Test allowed command that fails during execution (mocked OSError)\n        with patch('os.popen') as mock_popen:\n            mock_popen.return_value.read.side_effect = OSError(\"command not found\")\n            result = execute_permitted_command(\"fail_command\", [\"fail_command\"])\n            self.assertEqual(result, \"Disallowed command or subcommand.\")\n\n    def test_empty_token_in_command(self):\n        # Test command containing empty string token\n        with patch('os.popen') as mock_popen:\n            mock_popen.return_value.read.return_value = \"success\"\n            result = execute_permitted_command(\"ls ''\", [\"ls\", \"\"])\n            self.assertEqual(result, \"success\")\n\n    def test_quoted_space_in_command(self):\n        # Test quoted token with space\n        with patch('os.popen') as mock_popen:\n            mock_popen.return_value.read.return_value = \"success\"\n            result = execute_permitted_command('ls \"my file\"', [\"ls\", \"my file\"])\n            self.assertEqual(result, \"success\")\n\n    def test_empty_approved_commands(self):\n        # Test non-empty command with empty approved commands list\n        result = execute_permitted_command(\"any_command\", [])\n        self.assertEqual(result, \"Disallowed command or subcommand.\")\n\n    def test_long_command_token(self):\n        # Test very long token in command\n        long_token = \"A\" * 1000\n        with patch('os.popen') as mock_popen:\n            mock_popen.return_value.read.return_value = \"success\"\n            result = execute_permitted_command(long_token, [long_token])\n            self.assertEqual(result, \"success\")\n\n    def test_whitespace_only_command(self):\n        # Test command with only whitespace characters\n        result = execute_permitted_command(\"   \", [\"ls\"])\n        self.assertEqual(result, \"Disallowed command or subcommand.\")\n\n    def test_non_string_command(self):\n        # Test invalid non-string input_command\n        with self.assertRaises(TypeError):\n            execute_permitted_command(123, [\"ls\"])\n\n    def test_non_list_approved_commands(self):\n        # Test invalid non-list approved_commands\n        with self.assertRaises(TypeError):\n            execute_permitted_command(\"ls\", \"not_a_list\")\n\n    def test_none_command(self):\n        # Test None as input_command\n        with self.assertRaises(TypeError):\n            execute_permitted_command(None, [\"ls\"])\n\n    def test_none_approved_commands(self):\n        # Test None as approved_commands\n        with self.assertRaises(TypeError):\n            execute_permitted_command(\"ls\", None)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 15, "task_id": "61d0f240"}
{"test": "import unittest\nfrom unittest.mock import patch\n\nclass TestCases(unittest.TestCase):\n\n    @patch('os.popen')\n    def test_case_1(self, mock_popen):\n        # Test simple command (one part) that is approved\n        mock_popen.return_value.read.return_value = \"success\"\n        result = execute_command_with_restrictions(\"echo\", [\"echo\"])\n        self.assertEqual(result, \"success\")\n        mock_popen.assert_called_once_with(\"echo\")\n\n    @patch('os.popen')\n    def test_case_2(self, mock_popen):\n        # Test two-part command that is approved\n        mock_popen.return_value.read.return_value = \"hello world\"\n        approved = [\"echo\", \"hello\"]\n        result = execute_command_with_restrictions(\"echo hello\", approved)\n        self.assertEqual(result, \"hello world\")\n        mock_popen.assert_called_once_with(\"echo hello\")\n\n    def test_case_3(self):\n        # Test disallowed main command (one part)\n        approved = [\"ls\", \"cat\"]\n        result = execute_command_with_restrictions(\"echo\", approved)\n        self.assertEqual(result, \"Disallowed command or subcommand.\")\n\n    def test_case_4(self):\n        # Test disallowed subcommand in a two-part command\n        approved = [\"echo\", \"allowed\"]\n        result = execute_command_with_restrictions(\"echo disallowed\", approved)\n        self.assertEqual(result, \"Disallowed command or subcommand.\")\n\n    def test_case_5(self):\n        # Test empty command string\n        result = execute_command_with_restrictions(\"\", [\"any\"])\n        self.assertEqual(result, \"Disallowed command or subcommand.\")\n\n    @patch('os.popen')\n    def test_case_6(self, mock_popen):\n        # Test command that causes OSError during read\n        mock_popen.return_value.read.side_effect = OSError(\"error\")\n        result = execute_command_with_restrictions(\"echo\", [\"echo\"])\n        self.assertEqual(result, \"Disallowed command or subcommand.\")\n\n    def test_case_7(self):\n        # Test non-string command input\n        result = execute_command_with_restrictions(123, [\"echo\"])\n        self.assertEqual(result, \"Disallowed command or subcommand.\")\n\n    def test_case_8(self):\n        # Test empty approved_subcommands list\n        result = execute_command_with_restrictions(\"echo\", [])\n        self.assertEqual(result, \"Disallowed command or subcommand.\")\n\n    @patch('os.popen')\n    def test_case_9(self, mock_popen):\n        # Test command with quoted string that is approved\n        mock_popen.return_value.read.return_value = \"quoted output\"\n        cmd = 'echo \"hello world\"'\n        approved = [\"echo\", \"hello world\"]\n        result = execute_command_with_restrictions(cmd, approved)\n        self.assertEqual(result, \"quoted output\")\n        mock_popen.assert_called_once_with('echo \"hello world\"')\n\n    def test_case_10(self):\n        # Test command with quoted string that is not approved\n        cmd = 'echo \"hello\"'\n        approved = [\"echo\", \"different\"]\n        result = execute_command_with_restrictions(cmd, approved)\n        self.assertEqual(result, \"Disallowed command or subcommand.\")\n", "num_test_cases": 10, "task_id": "e2f8645e"}
{"test": "import unittest\nfrom unittest.mock import patch\n\nclass TestCases(unittest.TestCase):\n    @patch('os.popen')\n    def test_valid_single_command(self, mock_popen):\n        \"\"\"Tests a valid command with a single token.\"\"\"\n        mock_popen.return_value.read.return_value = \"output\"\n        result = validate_and_execute_command(\"ls\", [\"ls\"])\n        self.assertEqual(result, \"output\")\n        mock_popen.assert_called_once_with(\"ls\")\n\n    @patch('os.popen')\n    def test_valid_multiple_commands(self, mock_popen):\n        \"\"\"Tests a valid command with multiple tokens.\"\"\"\n        mock_popen.return_value.read.return_value = \"output\"\n        result = validate_and_execute_command(\"ls -l\", [\"ls\", \"-l\"])\n        self.assertEqual(result, \"output\")\n        mock_popen.assert_called_once_with(\"ls -l\")\n\n    @patch('os.popen')\n    def test_disallowed_subcommand(self, mock_popen):\n        \"\"\"Tests a command with a disallowed subcommand.\"\"\"\n        result = validate_and_execute_command(\"ls -a\", [\"ls\"])\n        self.assertEqual(result, \"Disallowed command or subcommand.\")\n        mock_popen.assert_not_called()\n\n    @patch('os.popen')\n    def test_empty_command(self, mock_popen):\n        \"\"\"Tests an empty command string.\"\"\"\n        result = validate_and_execute_command(\"\", [\"ls\"])\n        self.assertEqual(result, \"Disallowed command or subcommand.\")\n        mock_popen.assert_not_called()\n\n    @patch('os.popen')\n    def test_command_with_empty_token(self, mock_popen):\n        \"\"\"Tests a command containing an empty token not in safe list.\"\"\"\n        result = validate_and_execute_command('ls \"\"', [\"ls\"])\n        self.assertEqual(result, \"Disallowed command or subcommand.\")\n        mock_popen.assert_not_called()\n\n    @patch('os.popen')\n    def test_safe_subcommands_none(self, mock_popen):\n        \"\"\"Tests when safe_subcommands is None.\"\"\"\n        result = validate_and_execute_command(\"ls\", None)\n        self.assertEqual(result, \"Disallowed command or subcommand.\")\n        mock_popen.assert_not_called()\n\n    @patch('os.popen')\n    def test_safe_subcommands_non_string(self, mock_popen):\n        \"\"\"Tests safe_subcommands containing non-string items.\"\"\"\n        result = validate_and_execute_command(\"ls\", [123])\n        self.assertEqual(result, \"Disallowed command or subcommand.\")\n        mock_popen.assert_not_called()\n\n    @patch('os.popen')\n    def test_command_with_quoted_argument(self, mock_popen):\n        \"\"\"Tests a command with quoted argument tokens in safe list.\"\"\"\n        mock_popen.return_value.read.return_value = \"output\"\n        result = validate_and_execute_command('echo \"hello\"', [\"echo\", \"hello\"])\n        self.assertEqual(result, \"output\")\n        mock_popen.assert_called_once_with(\"echo hello\")\n\n    @patch('os.popen')\n    def test_command_with_numeric_token(self, mock_popen):\n        \"\"\"Tests a command with numeric tokens in safe list.\"\"\"\n        mock_popen.return_value.read.return_value = \"output\"\n        result = validate_and_execute_command(\"echo 123\", [\"echo\", \"123\"])\n        self.assertEqual(result, \"output\")\n        mock_popen.assert_called_once_with(\"echo 123\")", "num_test_cases": 9, "task_id": "7bf964b6"}
{"test": "import unittest\nimport os\n\nclass TestFilterAndRunCommand(unittest.TestCase):\n\n    def test_happy_path_simple(self):\n        # Test a simple allowed command\n        result = filter_and_run_command('echo hello', ['echo', 'hello'])\n        self.assertEqual(result.strip(), 'hello')\n\n    def test_happy_path_multiple_tokens(self):\n        # Test a command with multiple allowed tokens\n        result = filter_and_run_command('echo testing multiple tokens', ['echo', 'testing', 'multiple', 'tokens'])\n        self.assertEqual(result.strip(), 'testing multiple tokens')\n\n    def test_quoted_argument(self):\n        # Test a command with a quoted argument token\n        result = filter_and_run_command('echo \"hello world\"', ['echo', 'hello world'])\n        self.assertEqual(result.strip(), 'hello world')\n\n    def test_empty_command(self):\n        # Test an empty command string\n        result = filter_and_run_command('', ['echo'])\n        self.assertEqual(result, \"Disallowed command or subcommand.\")\n\n    def test_disallowed_token(self):\n        # Test a command with a token not in permitted list\n        result = filter_and_run_command('echo hello', ['echo'])\n        self.assertEqual(result, \"Disallowed command or subcommand.\")\n\n    def test_disallowed_primary_command(self):\n        # Test a command with primary command not in permitted list\n        result = filter_and_run_command('invalid_cmd', ['echo'])\n        self.assertEqual(result, \"Disallowed command or subcommand.\")\n\n    def test_empty_token_allowed(self):\n        # Test a command with empty token where permitted includes empty string\n        result = filter_and_run_command('echo \"\"', ['echo', ''])\n        self.assertEqual(result, os.linesep)\n\n    def test_empty_token_disallowed(self):\n        # Test a command with empty token not in permitted list\n        result = filter_and_run_command('echo \"\"', ['echo'])\n        self.assertEqual(result, \"Disallowed command or subcommand.\")\n\n    def test_non_string_cmd_input(self):\n        # Test non-string cmd_input (None)\n        result = filter_and_run_command(None, ['echo'])\n        self.assertEqual(result, \"Disallowed command or subcommand.\")\n\n    def test_non_list_permitted_subcommands(self):\n        # Test permitted_subcommands as a string (non-list) causing false validation\n        result = filter_and_run_command('echo hello', 'echo')\n        self.assertEqual(result, \"Disallowed command or subcommand.\")\n\n    def test_empty_permitted_list(self):\n        # Test with empty permitted_subcommands list\n        result = filter_and_run_command('echo hello', [])\n        self.assertEqual(result, \"Disallowed command or subcommand.\")\n\n    def test_command_with_numbers(self):\n        # Test command containing numeric tokens\n        result = filter_and_run_command('echo 123', ['echo', '123'])\n        self.assertEqual(result.strip(), '123')\n\n    def test_single_quoted_argument(self):\n        # Test command with single-quoted argument\n        result = filter_and_run_command(\"echo 'hello world'\", ['echo', 'hello world'])\n        self.assertEqual(result.strip(), 'hello world')\n\n    def test_command_with_special_characters(self):\n        # Test command with special characters in token\n        result = filter_and_run_command('echo \"$pecial@chars\"', ['echo', '$pecial@chars'])\n        self.assertEqual(result.strip(), '$pecial@chars')\n\n    def test_long_command(self):\n        # Test a long command with many tokens\n        long_cmd = 'echo ' + 'a' * 100\n        permitted = ['echo'] + ['a' * 100]\n        result = filter_and_run_command(long_cmd, permitted)\n        self.assertEqual(result.strip(), 'a' * 100)", "num_test_cases": 15, "task_id": "5558b75d"}
{"test": "import unittest\nfrom unittest.mock import patch\n\nclass TestCases(unittest.TestCase):\n    @patch('os.popen')\n    def test_basic_command(self, mock_popen):\n        \"\"\"Test a command with one permitted token.\"\"\"\n        mock_popen.return_value.read.return_value = 'success'\n        result = validate_and_execute_command('ls', ['ls'])\n        self.assertEqual(result, 'success')\n        mock_popen.assert_called_once_with('ls')\n\n    @patch('os.popen')\n    def test_multiple_permitted_tokens(self, mock_popen):\n        \"\"\"Test a command with multiple permitted tokens.\"\"\"\n        mock_popen.return_value.read.return_value = 'success'\n        result = validate_and_execute_command('ls -l', ['ls', '-l'])\n        self.assertEqual(result, 'success')\n        mock_popen.assert_called_once_with('ls -l')\n\n    def test_disallowed_token_raises_value_error(self):\n        \"\"\"Test a command with a disallowed token raises ValueError.\"\"\"\n        with patch('os.popen') as mock_popen:\n            with self.assertRaises(ValueError):\n                validate_and_execute_command('echo', ['ls'])\n            mock_popen.assert_not_called()\n\n    def test_disallowed_token_in_multi_token_command(self):\n        \"\"\"Test a multi-token command with one disallowed token raises ValueError.\"\"\"\n        with patch('os.popen') as mock_popen:\n            with self.assertRaises(ValueError):\n                validate_and_execute_command('ls -a', ['ls', '-l'])\n            mock_popen.assert_not_called()\n\n    @patch('os.popen')\n    def test_empty_command(self, mock_popen):\n        \"\"\"Test an empty command string.\"\"\"\n        mock_popen.return_value.read.return_value = ''\n        result = validate_and_execute_command('', [])\n        self.assertEqual(result, '')\n        mock_popen.assert_called_once_with('')\n\n    @patch('os.popen')\n    def test_quoted_token_allowed(self, mock_popen):\n        \"\"\"Test a command with quoted token that is permitted.\"\"\"\n        mock_popen.return_value.read.return_value = 'hello world'\n        result = validate_and_execute_command('echo \"hello world\"', ['echo', 'hello world'])\n        self.assertEqual(result, 'hello world')\n        mock_popen.assert_called_once_with('echo hello world')\n\n    @patch('os.popen')\n    def test_extra_spaces_in_command(self, mock_popen):\n        \"\"\"Test command with extra spaces splits correctly.\"\"\"\n        mock_popen.return_value.read.return_value = 'success'\n        result = validate_and_execute_command('   ls   -l   ', ['ls', '-l'])\n        self.assertEqual(result, 'success')\n        mock_popen.assert_called_once_with('ls -l')\n\n    @patch('os.popen')\n    def test_special_characters_in_token(self, mock_popen):\n        \"\"\"Test tokens with special characters that are permitted.\"\"\"\n        mock_popen.return_value.read.return_value = 'success'\n        permitted = ['*', 'file.txt']\n        result = validate_and_execute_command('* file.txt', permitted)\n        self.assertEqual(result, 'success')\n        mock_popen.assert_called_once_with('* file.txt')\n\n    @patch('os.popen')\n    def test_command_with_quoted_disallowed_token(self, mock_popen):\n        \"\"\"Test command with a quoted token not in permitted list raises.\"\"\"\n        with self.assertRaises(ValueError):\n            validate_and_execute_command('echo \"disallowed\"', ['echo', 'allowed'])\n        mock_popen.assert_not_called()\n\n    @patch('os.popen')\n    def test_large_number_of_tokens(self, mock_popen):\n        \"\"\"Test command with large number of permitted tokens.\"\"\"\n        mock_popen.return_value.read.return_value = 'success'\n        tokens = ['cmd'] + [str(i) for i in range(100)]\n        command = ' '.join(tokens)\n        result = validate_and_execute_command(command, tokens)\n        self.assertEqual(result, 'success')\n        mock_popen.assert_called_once_with(command)\n\n    @patch('os.popen')\n    def test_command_order_preserved(self, mock_popen):\n        \"\"\"Test token order is preserved in executed command.\"\"\"\n        mock_popen.return_value.read.return_value = 'success'\n        result = validate_and_execute_command('echo hello world', ['echo', 'hello', 'world'])\n        self.assertEqual(result, 'success')\n        mock_popen.assert_called_once_with('echo hello world')\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 11, "task_id": "e23758c2"}
{"test": "import os\\nimport unittest\\nfrom unittest.mock import patch\\n\\nclass TestValidateAndExecuteCommand(unittest.TestCase):\\n\\n    @patch('os.popen')\\n    def test_happy_path(self, mock_popen):\\n        # Test valid command with permitted subcommands\\n        mock_popen.return_value.read.return_value = 'output'\\n        result = validate_and_execute_command('ls -l', ['ls', '-l'])\\n        self.assertEqual(result, 'output')\\n\\n    def test_disallowed_subcommand(self):\\n        # Test command with a token not in permitted list\\n        result = validate_and_execute_command('ls /', ['ls'])\\n        self.assertEqual(result, 'Disallowed command or subcommand.')\\n\\n    def test_empty_command(self):\\n        # Test empty command string\\n        result = validate_and_execute_command('', ['ls', '-l'])\\n        self.assertEqual(result, 'Disallowed command or subcommand.')\\n\\n    def test_case_sensitivity(self):\\n        # Test case sensitivity in command validation\\n        result = validate_and_execute_command('LS', ['ls'])\\n        self.assertEqual(result, 'Disallowed command or subcommand.')\\n\\n    def test_substring_not_allowed(self):\\n        # Test token that is a substring of permitted token\\n        result = validate_and_execute_command('lsh', ['ls'])\\n        self.assertEqual(result, 'Disallowed command or subcommand.')\\n\\n    def test_permitted_subcommands_empty(self):\\n        # Test with empty permitted subcommands list\\n        result = validate_and_execute_command('ls', [])\\n        self.assertEqual(result, 'Disallowed command or subcommand.')\\n\\n    @patch('os.popen')\\n    def test_command_with_whitespace(self, mock_popen):\\n        # Test command with extra whitespace\\n        mock_popen.return_value.read.return_value = 'output'\\n        result = validate_and_execute_command('  ls   -l  ', ['ls', '-l'])\\n        self.assertEqual(result, 'output')\\n\\n    @patch('os.popen')\\n    def test_command_with_quotes(self, mock_popen):\\n        # Test quoted argument that is permitted\\n        mock_popen.return_value.read.return_value = 'output'\\n        result = validate_and_execute_command('echo \\\\'hello world\\\\'', ['echo', 'hello world'])\\n        self.assertEqual(result, 'output')\\n\\n    def test_command_with_quotes_disallowed(self):\\n        # Test quoted argument not in permitted list\\n        result = validate_and_execute_command('echo \\\\'hello\\\\'', ['echo', 'hello world'])\\n        self.assertEqual(result, 'Disallowed command or subcommand.')\\n\\n    def test_unbalanced_quotes(self):\\n        # Test command with unbalanced quotes\\n        result = validate_and_execute_command('echo \\\\'hello', ['echo'])\\n        self.assertEqual(result, 'Disallowed command or subcommand.')\\n\\n    def test_base_command_not_permitted(self):\\n        # Test when base command is not permitted\\n        result = validate_and_execute_command('rm file', ['ls'])\\n        self.assertEqual(result, 'Disallowed command or subcommand.')\\n\\n    @patch('os.popen')\\n    def test_multi_part_command(self, mock_popen):\\n        # Test multi-part command with all permitted tokens\\n        mock_popen.return_value.read.return_value = 'output'\\n        result = validate_and_execute_command('git log --oneline', ['git', 'log', '--oneline'])\\n        self.assertEqual(result, 'output')\\n\\n    def test_non_string_command(self):\\n        # Test non-string input command\\n        with self.assertRaises(TypeError):\\n            validate_and_execute_command(123, ['ls'])\\n\\nif __name__ == '__main__':\\n    unittest.main()", "num_test_cases": 13, "task_id": "28d45217"}
{"test": "import unittest\nfrom unittest.mock import patch\nfrom solution import filter_and_run_os_command\n\nclass TestFilterAndRunOsCommand(unittest.TestCase):\n\n    @patch('solution.os.popen')\n    def test_basic_allowed_command(self, mock_popen):\n        \"\"\"Test a basic command with all allowed parts.\"\"\"\n        mock_read = mock_popen.return_value\n        mock_read.read.return_value = \"hello\"\n        result = filter_and_run_os_command(\"echo hello\", [\"echo\", \"hello\"])\n        self.assertEqual(result, \"hello\")\n        mock_popen.assert_called_once_with('echo hello')\n\n    @patch('solution.os.popen')\n    def test_disallowed_subcommand(self, mock_popen):\n        \"\"\"Test command with a disallowed subcommand.\"\"\"\n        result = filter_and_run_os_command(\"echo world\", [\"echo\"])\n        self.assertEqual(result, \"Disallowed command or subcommand.\")\n        mock_popen.assert_not_called()\n\n    def test_empty_command(self):\n        \"\"\"Test empty command string.\"\"\"\n        result = filter_and_run_os_command(\"\", [\"echo\"])\n        self.assertEqual(result, \"Disallowed command or subcommand.\")\n\n    @patch('solution.os.popen')\n    def test_os_popen_exception(self, mock_popen):\n        \"\"\"Test command that causes OSError during execution.\"\"\"\n        mock_popen.side_effect = OSError(\"command not found\")\n        result = filter_and_run_os_command(\"echo hello\", [\"echo\", \"hello\"])\n        self.assertEqual(result, \"Disallowed command or subcommand.\")\n\n    def test_non_string_command(self):\n        \"\"\"Test non-string command input.\"\"\"\n        result = filter_and_run_os_command(123, [\"echo\"])\n        self.assertEqual(result, \"Disallowed command or subcommand.\")\n\n    @patch('solution.os.popen')\n    def test_quoted_string_allowed(self, mock_popen):\n        \"\"\"Test quoted string that matches whitelist.\"\"\"\n        mock_read = mock_popen.return_value\n        mock_read.read.return_value = \"hello world\"\n        result = filter_and_run_os_command('echo \"hello world\"', [\"echo\", \"hello world\"])\n        self.assertEqual(result, \"hello world\")\n        mock_popen.assert_called_once_with('echo hello world')\n\n    @patch('solution.os.popen')\n    def test_quoted_string_disallowed(self, mock_popen):\n        \"\"\"Test quoted string not in whitelist.\"\"\"\n        result = filter_and_run_os_command('echo \"hello world\"', [\"echo\"])\n        self.assertEqual(result, \"Disallowed command or subcommand.\")\n        mock_popen.assert_not_called()\n\n    @patch('solution.os.popen')\n    def test_empty_whitelist(self, mock_popen):\n        \"\"\"Test command against an empty whitelist.\"\"\"\n        result = filter_and_run_os_command(\"echo hello\", [])\n        self.assertEqual(result, \"Disallowed command or subcommand.\")\n        mock_popen.assert_not_called()\n\n    @patch('solution.os.popen')\n    def test_multiple_allowed_tokens(self, mock_popen):\n        \"\"\"Test command with multiple allowed tokens.\"\"\"\n        mock_read = mock_popen.return_value\n        mock_read.read.return_value = \"one two three\"\n        result = filter_and_run_os_command(\"echo one two three\", [\"echo\", \"one\", \"two\", \"three\"])\n        self.assertEqual(result, \"one two three\")\n        mock_popen.assert_called_once_with('echo one two three')\n\n    @patch('solution.os.popen')\n    def test_case_sensitivity_same(self, mock_popen):\n        \"\"\"Test case sensitivity with matching case.\"\"\"\n        mock_read = mock_popen.return_value\n        mock_read.read.return_value = \"hello\"\n        result = filter_and_run_os_command(\"ECHO hello\", [\"ECHO\", \"hello\"])\n        self.assertEqual(result, \"hello\")\n        mock_popen.assert_called_once_with('ECHO hello')\n\n    @patch('solution.os.popen')\n    def test_case_sensitivity_different(self, mock_popen):\n        \"\"\"Test case sensitivity with different case.\"\"\"\n        result = filter_and_run_os_command(\"echo hello\", [\"ECHO\", \"HELLO\"])\n        self.assertEqual(result, \"Disallowed command or subcommand.\")\n        mock_popen.assert_not_called()\n\n    @patch('solution.os.popen')\n    def test_extra_token_disallowed(self, mock_popen):\n        \"\"\"Test command with extra disallowed token.\"\"\"\n        result = filter_and_run_os_command(\"echo hello world\", [\"echo\", \"hello\"])\n        self.assertEqual(result, \"Disallowed command or subcommand.\")\n        mock_popen.assert_not_called()", "num_test_cases": 12, "task_id": "8cbd978b"}
{"test": "import unittest\n\nclass TestExecuteCustomQuery(unittest.TestCase):\n\n    def test_basic_query(self):\n        \"\"\"Test basic query with one condition and one field.\"\"\"\n        data = [\n            {\"name\": \"Alice\", \"age\": 30, \"city\": \"NY\"},\n            {\"name\": \"Bob\", \"age\": 25, \"city\": \"CHI\"},\n            {\"name\": \"Charlie\", \"age\": 35, \"city\": \"NY\"}\n        ]\n        query = \"SELECT name, age FROM data WHERE city = NY ORDER BY age\"\n        expected = [\n            {\"name\": \"Alice\", \"age\": 30},\n            {\"name\": \"Charlie\", \"age\": 35}\n        ]\n        result = execute_custom_query(data, query)\n        self.assertEqual(result, expected)\n\n    def test_multiple_conditions(self):\n        \"\"\"Test query with multiple conditions in WHERE clause.\"\"\"\n        data = [\n            {\"id\": 1, \"name\": \"Alice\", \"age\": 30, \"height\": 165.5},\n            {\"id\": 2, \"name\": \"Bob\", \"age\": 25, \"height\": 180.0},\n            {\"id\": 3, \"name\": \"Charlie\", \"age\": 35, \"height\": 170.5},\n            {\"id\": 4, \"name\": \"David\", \"age\": 30, \"height\": 175.0}\n        ]\n        query = \"SELECT id, name FROM data WHERE age >= 30 AND height < 175.0 ORDER BY name\"\n        expected = [\n            {\"id\": 1, \"name\": \"Alice\"},\n            {\"id\": 3, \"name\": \"Charlie\"}\n        ]\n        result = execute_custom_query(data, query)\n        self.assertEqual(result, expected)\n\n    def test_empty_data(self):\n        \"\"\"Test with empty data list.\"\"\"\n        data = []\n        query = \"SELECT name FROM data WHERE age > 25 ORDER BY name\"\n        result = execute_custom_query(data, query)\n        self.assertEqual(result, [])\n\n    def test_no_matching_records(self):\n        \"\"\"Test condition that matches no records.\"\"\"\n        data = [\n            {\"name\": \"Alice\", \"age\": 30},\n            {\"name\": \"Bob\", \"age\": 25}\n        ]\n        query = \"SELECT name FROM data WHERE age > 100 ORDER BY age\"\n        result = execute_custom_query(data, query)\n        self.assertEqual(result, [])\n\n    def test_case_insensitivity(self):\n        \"\"\"Test case insensitivity in query keywords.\"\"\"\n        data = [\n            {\"name\": \"Alice\", \"age\": 30, \"city\": \"NY\"},\n            {\"name\": \"Bob\", \"age\": 25, \"city\": \"CHI\"},\n            {\"name\": \"Charlie\", \"age\": 35, \"city\": \"NY\"}\n        ]\n        query = \"sElEcT name FrOm data WhErE city = NY oRdEr bY age\"\n        expected = [\n            {\"name\": \"Alice\"},\n            {\"name\": \"Charlie\"}\n        ]\n        result = execute_custom_query(data, query)\n        self.assertEqual(result, expected)\n\n    def test_float_condition(self):\n        \"\"\"Test condition with float value.\"\"\"\n        data = [\n            {\"name\": \"Alice\", \"height\": 165.5},\n            {\"name\": \"Bob\", \"height\": 180.0},\n            {\"name\": \"Charlie\", \"height\": 170.5}\n        ]\n        query = \"SELECT name FROM data WHERE height > 170.0 ORDER BY name\"\n        expected = [\n            {\"name\": \"Bob\"},\n            {\"name\": \"Charlie\"}\n        ]\n        result = execute_custom_query(data, query)\n        self.assertEqual(result, expected)\n\n    def test_invalid_query_format(self):\n        \"\"\"Test invalid query format (missing ORDER BY).\"\"\"\n        data = [{\"name\": \"Alice\", \"age\": 30}]\n        query = \"SELECT name FROM data WHERE age > 25\"\n        with self.assertRaises(ValueError):\n            execute_custom_query(data, query)\n\n    def test_invalid_operator(self):\n        \"\"\"Test condition with invalid operator.\"\"\"\n        data = [{\"name\": \"Alice\", \"age\": 30}]\n        query = \"SELECT name FROM data WHERE age != 30 ORDER BY name\"\n        with self.assertRaises(ValueError):\n            execute_custom_query(data, query)\n\n    def test_nonexistent_field_where(self):\n        \"\"\"Test condition with non-existent field in WHERE clause.\"\"\"\n        data = [{\"name\": \"Alice\", \"age\": 30}]\n        query = \"SELECT name FROM data WHERE salary > 50000 ORDER BY name\"\n        with self.assertRaises(ValueError):\n            execute_custom_query(data, query)\n\n    def test_type_conversion_error(self):\n        \"\"\"Test condition value that cannot be converted to field type.\"\"\"\n        data = [{\"name\": \"Alice\", \"age\": 30}]\n        query = \"SELECT name FROM data WHERE age > abc ORDER BY name\"\n        with self.assertRaises(ValueError):\n            execute_custom_query(data, query)\n\n    def test_order_by_nonexistent_field(self):\n        \"\"\"Test ordering by a non-existent field.\"\"\"\n        data = [{\"name\": \"Alice\", \"age\": 30}]\n        query = \"SELECT name FROM data WHERE age > 25 ORDER BY salary\"\n        with self.assertRaises(ValueError):\n            execute_custom_query(data, query)\n\n    def test_inconsistent_data_fields(self):\n        \"\"\"Test data with inconsistent fields in WHERE condition.\"\"\"\n        data = [\n            {\"name\": \"Alice\", \"age\": 30},\n            {\"name\": \"Bob\", \"age\": 25, \"city\": \"NY\"}\n        ]\n        query = \"SELECT name FROM data WHERE city = NY ORDER BY age\"\n        with self.assertRaises(ValueError):\n            execute_custom_query(data, query)\n\n    def test_condition_value_with_space(self):\n        \"\"\"Test condition value containing space (invalid pattern).\"\"\"\n        data = [{\"name\": \"Alice\", \"city\": \"New York\"}]\n        query = \"SELECT name FROM data WHERE city = New York ORDER BY name\"\n        with self.assertRaises(ValueError):\n            execute_custom_query(data, query)\n\n    def test_float_value_for_int_field(self):\n        \"\"\"Test float value condition for integer field.\"\"\"\n        data = [{\"name\": \"Alice\", \"age\": 30}]\n        query = \"SELECT name FROM data WHERE age > 25.5 ORDER BY name\"\n        with self.assertRaises(ValueError):\n            execute_custom_query(data, query)\n\n    def test_projection_selected_fields(self):\n        \"\"\"Test projection returns only selected fields.\"\"\"\n        data = [\n            {\"name\": \"Alice\", \"age\": 30, \"city\": \"NY\"},\n            {\"name\": \"Bob\", \"age\": 25, \"city\": \"CHI\"}\n        ]\n        query = \"SELECT name FROM data WHERE age > 20 ORDER BY name\"\n        result = execute_custom_query(data, query)\n        for item in result:\n            self.assertEqual(list(item.keys()), [\"name\"])\n\nif __name__ == \"__main__\":\n    unittest.main()", "num_test_cases": 15, "task_id": "717a825b"}
{"test": "import unittest\nfrom solution import process_math_expression\n\nclass TestMathExpression(unittest.TestCase):\n    \n    def test_basic_addition(self):\n        # Test basic addition without variables\n        result = process_math_expression(\"2+3\", {})\n        self.assertEqual(result, \"5\")\n    \n    def test_basic_subtraction(self):\n        # Test basic subtraction without variables\n        result = process_math_expression(\"5-3\", {})\n        self.assertEqual(result, \"2\")\n    \n    def test_basic_multiplication(self):\n        # Test basic multiplication without variables\n        result = process_math_expression(\"2*3\", {})\n        self.assertEqual(result, \"6\")\n    \n    def test_basic_division(self):\n        # Test basic division without variables\n        result = process_math_expression(\"6/3\", {})\n        self.assertEqual(result, \"2.0\")\n    \n    def test_variable_addition(self):\n        # Test expression with variables\n        result = process_math_expression(\"a+b\", {'a': 2, 'b': 3})\n        self.assertEqual(result, \"5\")\n    \n    def test_multiple_same_variable(self):\n        # Test expression with multiple occurrences of same variable\n        result = process_math_expression(\"a+a\", {'a': 1})\n        self.assertEqual(result, \"2\")\n    \n    def test_parentheses_expression(self):\n        # Test expression with parentheses\n        result = process_math_expression(\"(2+3)*4\", {})\n        self.assertEqual(result, \"20\")\n    \n    def test_operator_precedence(self):\n        # Test operator precedence without parentheses\n        result = process_math_expression(\"2+3*4\", {})\n        self.assertEqual(result, \"14\")\n    \n    def test_division_by_zero(self):\n        # Test division by zero\n        with self.assertRaises(ValueError):\n            process_math_expression(\"5/0\", {})\n    \n    def test_missing_variable(self):\n        # Test missing variable in expression\n        with self.assertRaises(ValueError):\n            process_math_expression(\"a\", {})\n    \n    def test_syntax_error(self):\n        # Test invalid expression syntax\n        with self.assertRaises(ValueError):\n            process_math_expression(\"2+\", {})\n    \n    def test_unsupported_operation_exponent(self):\n        # Test unsupported exponentiation operation\n        with self.assertRaises(ValueError):\n            process_math_expression(\"2**3\", {})\n    \n    def test_unsupported_unary_minus(self):\n        # Test unsupported unary minus\n        with self.assertRaises(ValueError):\n            process_math_expression(\"-5\", {})\n    \n    def test_unsupported_modulus_operation(self):\n        # Test unsupported modulus operation\n        with self.assertRaises(ValueError):\n            process_math_expression(\"5%2\", {})\n    \n    def test_non_numeric_variable_value(self):\n        # Test non-numeric variable value\n        with self.assertRaises(ValueError):\n            process_math_expression(\"a\", {'a': 'abc'})\n    \n    def test_whitespace_handling(self):\n        # Test whitespace removal\n        result = process_math_expression(\" 2 + 3 \", {})\n        self.assertEqual(result, \"5\")\n    \n    def test_empty_expression(self):\n        # Test empty expression\n        with self.assertRaises(ValueError):\n            process_math_expression(\"\", {})\n    \n    def test_float_variable_value(self):\n        # Test float variable value\n        result = process_math_expression(\"a\", {'a': 2.5})\n        self.assertEqual(result, \"2.5\")\n    \n    def test_float_division_result(self):\n        # Test expression resulting in float\n        result = process_math_expression(\"5/2\", {})\n        self.assertEqual(result, \"2.5\")\n    \n    def test_negative_variable_value(self):\n        # Test negative variable value (causes unary operator error)\n        with self.assertRaises(ValueError):\n            process_math_expression(\"a\", {'a': -5})\n    \n    def test_float_precision(self):\n        # Test float precision representation\n        result = process_math_expression(\"1/3\", {})\n        self.assertEqual(result, \"0.3333333333333333\")\n    \n    def test_complex_expression_order(self):\n        # Test complex expression with multiple operations\n        result = process_math_expression(\"2*(3+4)-5/1\", {})\n        self.assertEqual(result, \"9.0\")\n    \n    def test_mixed_variable_types(self):\n        # Test expression with mixed variable types\n        result = process_math_expression(\"a+b\", {'a': 2.5, 'b': 3})\n        self.assertEqual(result, \"5.5\")\n    \n    def test_large_numbers(self):\n        # Test large numbers\n        result = process_math_expression(\"1000000*1000000\", {})\n        self.assertEqual(result, \"1000000000000\")\n    \n    def test_variable_name_substring(self):\n        # Test variable names that are substrings of others\n        result = process_math_expression(\"aa + a\", {'aa': 2, 'a': 1})\n        self.assertEqual(result, \"3\")\n    \n    def test_zero_variable_value(self):\n        # Test zero variable value\n        result = process_math_expression(\"a*b\", {'a': 0, 'b': 5})\n        self.assertEqual(result, \"0\")\n    \n    def test_nested_parentheses(self):\n        # Test nested parentheses\n        result = process_math_expression(\"2*(3+(4-1))\", {})\n        self.assertEqual(result, \"12\")\n    \n    def test_substitution_order(self):\n        # Test substitution order with overlapping variable names\n        result = process_math_expression(\"a+aa\", {'a': 1, 'aa': 2})\n        self.assertEqual(result, \"3\")", "num_test_cases": 20, "task_id": "c9806de7"}
{"test": "import unittest\nimport re\nimport html\n\nclass TestGenerateDynamicHTML(unittest.TestCase):\n    \n    def test_basic_replacement(self):\n        \"\"\"Test replacement with one placeholder.\"\"\"\n        template = \"Hello, {{name}}!\"\n        user_input = {'name': 'Alice'}\n        result = generate_dynamic_html(template, user_input)\n        self.assertEqual(result, \"Hello, Alice!\")\n    \n    def test_multiple_placeholders(self):\n        \"\"\"Test replacement with multiple placeholders.\"\"\"\n        template = \"Name: {{name}}, Age: {{age}}\"\n        user_input = {'name': 'Bob', 'age': 30}\n        result = generate_dynamic_html(template, user_input)\n        self.assertEqual(result, \"Name: Bob, Age: 30\")\n    \n    def test_html_escaping(self):\n        \"\"\"Test escaping of HTML special characters in values.\"\"\"\n        template = \"<p>{{content}}</p>\"\n        user_input = {'content': '<script>alert(\\\"xss\\\")</script>'}\n        result = generate_dynamic_html(template, user_input)\n        self.assertEqual(result, \"<p>&lt;script&gt;alert(&quot;xss&quot;)&lt;/script&gt;</p>\")\n    \n    def test_empty_template(self):\n        \"\"\"Test empty template returns empty string regardless of user_input.\"\"\"\n        self.assertEqual(generate_dynamic_html(\"\", {}), \"\")\n        self.assertEqual(generate_dynamic_html(\"\", {'key': 'value'}), \"\")\n    \n    def test_no_placeholders(self):\n        \"\"\"Test template without placeholders is returned unchanged.\"\"\"\n        template = \"Static content\"\n        self.assertEqual(generate_dynamic_html(template, {}), template)\n        self.assertEqual(generate_dynamic_html(template, {'key': 'value'}), template)\n    \n    def test_missing_placeholder(self):\n        \"\"\"Test missing placeholder raises ValueError.\"\"\"\n        template = \"Hello, {{name}}!\"\n        user_input = {}\n        with self.assertRaises(ValueError) as context:\n            generate_dynamic_html(template, user_input)\n        self.assertIn(\"Missing values for placeholders: name\", str(context.exception))\n    \n    def test_multiple_missing_placeholders(self):\n        \"\"\"Test multiple missing placeholders in error message.\"\"\"\n        template = \"{{greeting}}, {{name}}! You are {{age}} years old.\"\n        user_input = {'name': 'Alice'}\n        with self.assertRaises(ValueError) as context:\n            generate_dynamic_html(template, user_input)\n        error_msg = str(context.exception)\n        self.assertIn(\"Missing values for placeholders\", error_msg)\n        self.assertIn(\"greeting\", error_msg)\n        self.assertIn(\"age\", error_msg)\n    \n    def test_non_string_template(self):\n        \"\"\"Test non-string template raises ValueError.\"\"\"\n        with self.assertRaises(ValueError):\n            generate_dynamic_html(123, {'key': 'value'})\n    \n    def test_non_dict_user_input(self):\n        \"\"\"Test non-dictionary user_input raises ValueError.\"\"\"\n        with self.assertRaises(ValueError):\n            generate_dynamic_html(\"Template\", \"not a dict\")\n    \n    def test_distinct_placeholders(self):\n        \"\"\"Test distinct placeholders don't interfere during replacement.\"\"\"\n        template = \"{{name}} and {{full_name}}\"\n        user_input = {'name': 'Alice', 'full_name': 'Alice Smith'}\n        result = generate_dynamic_html(template, user_input)\n        self.assertEqual(result, \"Alice and Alice Smith\")\n    \n    def test_nested_pattern_replacement_first(self):\n        \"\"\"Test placeholder value containing pattern replaced first.\"\"\"\n        template = \"{{foo}}{{bar}}\"\n        user_input = {'foo': '{{bar}}', 'bar': 'baz'}\n        result = generate_dynamic_html(template, user_input)\n        self.assertEqual(result, \"bazbaz\")\n    \n    def test_nested_pattern_replacement_last(self):\n        \"\"\"Test placeholder value containing pattern replaced last.\"\"\"\n        template = \"{{foo}}{{bar}}\"\n        user_input = {'bar': 'baz', 'foo': '{{bar}}'}\n        result = generate_dynamic_html(template, user_input)\n        self.assertEqual(result, \"{{bar}}baz\")\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 12, "task_id": "7c6aab34"}
{"test": "import unittest\nimport sys\n\nclass TestExecuteShellCommand(unittest.TestCase):\n\n    def test_case_1(self):\n        \"\"\"Test basic command execution with simple output.\"\"\"\n        result = execute_shell_command(sys.executable, ['-c', \"print('hello')\"])\n        self.assertEqual(result, 'hello')\n\n    def test_case_2(self):\n        \"\"\"Test command with multiple words in output.\"\"\"\n        result = execute_shell_command(sys.executable, ['-c', \"print('hello world')\"])\n        self.assertEqual(result, 'hello world')\n\n    def test_case_3(self):\n        \"\"\"Test command that produces empty output.\"\"\"\n        result = execute_shell_command(sys.executable, ['-c', \"\"])\n        self.assertEqual(result, '')\n\n    def test_case_4(self):\n        \"\"\"Test command returning non-zero exit code.\"\"\"\n        with self.assertRaises(ValueError):\n            execute_shell_command(sys.executable, ['-c', \"import sys; sys.exit(1)\"])\n\n    def test_case_5(self):\n        \"\"\"Test non-existent command.\"\"\"\n        with self.assertRaises(ValueError):\n            execute_shell_command('non_existent_command', [])\n\n    def test_case_6(self):\n        \"\"\"Test empty command string.\"\"\"\n        with self.assertRaises(ValueError):\n            execute_shell_command('', [])\n\n    def test_case_7(self):\n        \"\"\"Test None as command.\"\"\"\n        with self.assertRaises(ValueError):\n            execute_shell_command(None, [])\n\n    def test_case_8(self):\n        \"\"\"Test non-string command type.\"\"\"\n        with self.assertRaises(ValueError):\n            execute_shell_command(123, [])\n\n    def test_case_9(self):\n        \"\"\"Test non-string argument in args list.\"\"\"\n        with self.assertRaises(ValueError):\n            execute_shell_command(sys.executable, [123])\n\n    def test_case_10(self):\n        \"\"\"Test arguments with special characters and spaces.\"\"\"\n        result = execute_shell_command(sys.executable, ['-c', \"print('output')\", 'hello; world', '& special!'])\n        self.assertIsInstance(result, str)\n        self.assertNotEqual(result, '')\n\n    def test_case_11(self):\n        \"\"\"Test very long argument value.\"\"\"\n        long_arg = 'A' * 1000\n        result = execute_shell_command(sys.executable, ['-c', \"print('long_arg_test')\", long_arg])\n        self.assertIsInstance(result, str)\n\n    def test_case_12(self):\n        \"\"\"Test large number of arguments.\"\"\"\n        args = [str(i) for i in range(100)]\n        result = execute_shell_command(sys.executable, ['-c', \"print('many_args')\"] + args)\n        self.assertIsInstance(result, str)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 12, "task_id": "e4e12786"}
{"test": "import unittest\nfrom unittest.mock import patch\nfrom solution import run_shell_command_with_filters\n\nclass TestShellCommandWithFilters(unittest.TestCase):\n\n    def test_happy_path_single_command(self):\n        \"\"\"Test a basic allowed command.\"\"\"\n        with patch('solution.os.popen') as mock_popen:\n            mock_popen.return_value.read.return_value = 'file1.txt'\n            result = run_shell_command_with_filters('ls', ['ls'])\n            self.assertEqual(result, 'file1.txt')\n\n    def test_happy_path_multiple_parts(self):\n        \"\"\"Test a command with multiple allowed parts.\"\"\"\n        with patch('solution.os.popen') as mock_popen:\n            mock_popen.return_value.read.return_value = 'total 0'\n            result = run_shell_command_with_filters('ls -l', ['ls', '-l'])\n            self.assertEqual(result, 'total 0')\n\n    def test_disallowed_subcommand(self):\n        \"\"\"Test a command with one disallowed subcommand.\"\"\"\n        result = run_shell_command_with_filters('ls -a', ['ls', '-l'])\n        self.assertEqual(result, 'Disallowed command or subcommand.')\n\n    def test_empty_command(self):\n        \"\"\"Test an empty command string.\"\"\"\n        result = run_shell_command_with_filters('', ['ls'])\n        self.assertEqual(result, 'Disallowed command or subcommand.')\n\n    def test_command_with_spaces(self):\n        \"\"\"Test a command with extra spaces (allowed).\"\"\"\n        with patch('solution.os.popen') as mock_popen:\n            mock_popen.return_value.read.return_value = 'output'\n            result = run_shell_command_with_filters('   ls   -l   ', ['ls', '-l'])\n            self.assertEqual(result, 'output')\n\n    def test_non_string_command(self):\n        \"\"\"Test a non-string command input.\"\"\"\n        result = run_shell_command_with_filters(123, ['ls'])\n        self.assertEqual(result, 'Disallowed command or subcommand.')\n\n    def test_empty_allowed_list(self):\n        \"\"\"Test an empty allowed subcommands list.\"\"\"\n        result = run_shell_command_with_filters('ls', [])\n        self.assertEqual(result, 'Disallowed command or subcommand.')\n\n    def test_command_not_in_allowed_list(self):\n        \"\"\"Test a command not present in the allowed list.\"\"\"\n        result = run_shell_command_with_filters('rm', ['ls'])\n        self.assertEqual(result, 'Disallowed command or subcommand.')\n\n    def test_mixed_allowed_and_disallowed(self):\n        \"\"\"Test a command with both allowed and disallowed parts.\"\"\"\n        result = run_shell_command_with_filters('echo hello', ['echo', 'world'])\n        self.assertEqual(result, 'Disallowed command or subcommand.')\n\n    def test_substring_command_disallowed(self):\n        \"\"\"Test a command where a substring of an allowed command is used.\"\"\"\n        result = run_shell_command_with_filters('echos hello', ['echo'])\n        self.assertEqual(result, 'Disallowed command or subcommand.')\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 10, "task_id": "1afc04b4"}
{"test": "import unittest\nimport sympy as sp\nimport numpy as np\n\nclass TestParseTransformationString(unittest.TestCase):\n    def test_default_case(self):\n        \"\"\"Test the default transformation string.\"\"\"\n        a, b, c = sp.symbols('a b c')\n        P, p = parse_transformation_string(\"a,b,c;0,0,0\")\n        self.assertEqual(p, [0.0, 0.0, 0.0])\n        self.assertTrue(P[0].equals(a) and P[1].equals(b) and P[2].equals(c))\n\n    def test_simple_transformation(self):\n        \"\"\"Test a simple transformation with explicit multiplication.\"\"\"\n        a, b, c = sp.symbols('a b c')\n        P, p = parse_transformation_string(\"3*a+4*b,2*a+3*b,4*c;1,2,3\")\n        self.assertEqual(p, [1.0, 2.0, 3.0])\n        expected = [3*a+4*b, 2*a+3*b, 4*c]\n        for i in range(3):\n            self.assertTrue(P[i].equals(expected[i]))\n\n    def test_implicit_multiplication(self):\n        \"\"\"Test transformation string with implicit multiplication.\"\"\"\n        a, b, c = sp.symbols('a b c')\n        P, p = parse_transformation_string(\"3a+4b,2a+3b,4c;0,0,0\")\n        self.assertEqual(p, [0.0, 0.0, 0.0])\n        expected = [3*a+4*b, 2*a+3*b, 4*c]\n        for i in range(3):\n            self.assertTrue(P[i].equals(expected[i]))\n\n    def test_parentheses_expression(self):\n        \"\"\"Test expressions with parentheses.\"\"\"\n        a, b, c = sp.symbols('a b c')\n        P, p = parse_transformation_string(\"3(a+b),2a,c;0,0,0\")\n        self.assertEqual(p, [0.0, 0.0, 0.0])\n        expected = [3*(a+b), 2*a, c]\n        for i in range(3):\n            self.assertTrue(P[i].equals(expected[i]))\n\n    def test_extra_origin_shift_values(self):\n        \"\"\"Test origin shift with more than three values.\"\"\"\n        P, p = parse_transformation_string(\"a,b,c;0,0,0,0\")\n        self.assertEqual(p, [0.0, 0.0, 0.0, 0.0])\n\n    def test_fewer_origin_shift_values(self):\n        \"\"\"Test origin shift with fewer than three values.\"\"\"\n        P, p = parse_transformation_string(\"a,b,c;1,2\")\n        self.assertEqual(p, [1.0, 2.0])\n\n    def test_malformed_expression(self):\n        \"\"\"Test invalid expression that fails parsing.\"\"\"\n        with self.assertRaises(ValueError):\n            parse_transformation_string(\"3a+4b,2a+3b,4c+;0,0,0\")\n\n    def test_non_float_origin_shift(self):\n        \"\"\"Test non-float values in origin shift.\"\"\"\n        with self.assertRaises(ValueError):\n            parse_transformation_string(\"a,b,c;x,y,z\")\n\n    def test_empty_string(self):\n        \"\"\"Test empty transformation string.\"\"\"\n        with self.assertRaises(ValueError):\n            parse_transformation_string(\"\")\n\n    def test_missing_semicolon(self):\n        \"\"\"Test transformation string missing semicolon.\"\"\"\n        with self.assertRaises(ValueError):\n            parse_transformation_string(\"a,b,c\")\n\n    def test_invalid_token(self):\n        \"\"\"Test expression with invalid tokens.\"\"\"\n        with self.assertRaises(ValueError):\n            parse_transformation_string(\"a,b,c+!;0,0,0\")\n\n    def test_extra_basis_expressions(self):\n        \"\"\"Test more than three basis expressions.\"\"\"\n        with self.assertRaises(ValueError):\n            parse_transformation_string(\"a,b,c,d;0,0,0,0\")\n", "num_test_cases": 12, "task_id": "bcce7d57"}
{"test": "import unittest\nfrom unittest.mock import patch, MagicMock\nfrom solution import create_backup\n\nclass TestCreateBackup(unittest.TestCase):\n    @patch('solution.logger')\n    @patch('subprocess.run')\n    def test_successful_backup(self, mock_run, mock_logger):\n        \"\"\"Test successful backup creation with valid inputs.\"\"\"\n        mock_run.return_value = MagicMock(returncode=0)\n        folder_path = '/valid/path'\n        archive_name = 'valid_backup'\n        \n        create_backup(folder_path, archive_name)\n        \n        expected_command = ['tar', '-czvf', 'valid_backup.tar.gz', '-C', '/valid/path', '.']\n        mock_run.assert_called_once_with(expected_command)\n        mock_logger.info.assert_any_call(\"Creating backup...\")\n        mock_logger.info.assert_any_call(\"Running command: %s\", ' '.join(expected_command))\n        mock_logger.info.assert_any_call(\"Backup created successfully.\")\n        mock_logger.error.assert_not_called()\n\n    @patch('solution.logger')\n    @patch('subprocess.run')\n    def test_failed_backup(self, mock_run, mock_logger):\n        \"\"\"Test backup failure with non-zero exit code.\"\"\"\n        mock_run.return_value = MagicMock(returncode=1)\n        folder_path = '/valid/path'\n        archive_name = 'valid_backup'\n        \n        with self.assertRaises(OSError):\n            create_backup(folder_path, archive_name)\n            \n        expected_command = ['tar', '-czvf', 'valid_backup.tar.gz', '-C', '/valid/path', '.']\n        mock_run.assert_called_once_with(expected_command)\n        mock_logger.info.assert_any_call(\"Creating backup...\")\n        mock_logger.info.assert_any_call(\"Running command: %s\", ' '.join(expected_command))\n        mock_logger.error.assert_called_once_with(\"Failed to create backup; command exited with code %d.\", 1)\n\n    @patch('solution.logger')\n    @patch('subprocess.run')\n    def test_empty_folder_path(self, mock_run, mock_logger):\n        \"\"\"Test command construction with empty folder_path.\"\"\"\n        mock_run.return_value = MagicMock(returncode=0)\n        folder_path = ''\n        archive_name = 'non_empty_name'\n        \n        create_backup(folder_path, archive_name)\n        \n        expected_command = ['tar', '-czvf', 'non_empty_name.tar.gz', '-C', '', '.']\n        mock_run.assert_called_once_with(expected_command)\n\n    @patch('solution.logger')\n    @patch('subprocess.run')\n    def test_empty_archive_name(self, mock_run, mock_logger):\n        \"\"\"Test command construction with empty archive_name.\"\"\"\n        mock_run.return_value = MagicMock(returncode=0)\n        folder_path = '/valid/path'\n        archive_name = ''\n        \n        create_backup(folder_path, archive_name)\n        \n        expected_command = ['tar', '-czvf', '.tar.gz', '-C', '/valid/path', '.']\n        mock_run.assert_called_once_with(expected_command)\n\n    @patch('solution.logger')\n    @patch('subprocess.run')\n    def test_special_characters_in_path(self, mock_run, mock_logger):\n        \"\"\"Test command handles paths with special characters.\"\"\"\n        mock_run.return_value = MagicMock(returncode=0)\n        folder_path = '/path/with spaces&special_chars!'\n        archive_name = 'normal_name'\n        \n        create_backup(folder_path, archive_name)\n        \n        expected_command = ['tar', '-czvf', 'normal_name.tar.gz', '-C', '/path/with spaces&special_chars!', '.']\n        mock_run.assert_called_once_with(expected_command)\n\n    @patch('solution.logger')\n    @patch('subprocess.run')\n    def test_long_path_and_name(self, mock_run, mock_logger):\n        \"\"\"Test command construction with long folder_path and archive_name.\"\"\"\n        mock_run.return_value = MagicMock(returncode=0)\n        folder_path = '/a/very/long/path' * 10\n        archive_name = 'x' * 100\n        \n        create_backup(folder_path, archive_name)\n        \n        expected_command = ['tar', '-czvf', f'{\"x\"*100}.tar.gz', '-C', folder_path, '.']\n        mock_run.assert_called_once_with(expected_command)\n\n    @patch('solution.logger')\n    @patch('subprocess.run')\n    def test_non_existent_directory(self, mock_run, mock_logger):\n        \"\"\"Test failure when tar command fails due to non-existent directory.\"\"\"\n        mock_run.return_value = MagicMock(returncode=2)\n        folder_path = '/non/existent/path'\n        archive_name = 'backup'\n        \n        with self.assertRaises(OSError):\n            create_backup(folder_path, archive_name)\n        \n        mock_logger.error.assert_called_once_with(\"Failed to create backup; command exited with code %d.\", 2)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 7, "task_id": "64d92900"}
{"test": "import unittest\nfrom unittest.mock import patch, MagicMock\nimport subprocess\n\n# Import the function from its module (assumed to be named 'backup_module')\nfrom backup_module import generate_backup\n\nclass TestGenerateBackup(unittest.TestCase):\n\n    @patch('backup_module.subprocess.run')\n    @patch('backup_module.logger')\n    def test_successful_backup(self, mock_logger, mock_run):\n        \"\"\"Test successful backup creation with valid inputs.\"\"\"\n        # Setup mock\n        mock_run.return_value = subprocess.CompletedProcess(args=[], returncode=0)\n        \n        # Call function\n        target_dir = \"/path/to/important_data\"\n        tar_name = \"important_backup\"\n        generate_backup(target_dir, tar_name)\n        \n        # Verify command construction\n        expected_command = [\"tar\", \"-czvf\", \"important_backup.tar.gz\", \"-C\", \"/path/to/important_data\", \".\"]\n        mock_run.assert_called_once_with(expected_command)\n        \n        # Verify logs\n        mock_logger.info.assert_any_call(\"Creating backup...\")\n        mock_logger.info.assert_any_call(\"Running command: %s\", \" \".join(expected_command))\n        mock_logger.info.assert_any_call(\"Backup created successfully.\")\n        mock_logger.error.assert_not_called()\n\n    @patch('backup_module.subprocess.run')\n    @patch('backup_module.logger')\n    def test_failed_backup_non_zero_exit(self, mock_logger, mock_run):\n        \"\"\"Test backup failure with non-zero exit code.\"\"\"\n        # Setup mock\n        mock_run.return_value = subprocess.CompletedProcess(args=[], returncode=1)\n        \n        # Call function and expect exception\n        with self.assertRaises(OSError):\n            generate_backup(\"/invalid/path\", \"failed_backup\")\n        \n        # Verify logs\n        mock_logger.info.assert_any_call(\"Creating backup...\")\n        mock_logger.info.assert_any_call(\"Running command: %s\", \" \".join(mock_run.call_args[0]))\n        mock_logger.error.assert_called_once_with(\"Failed to create backup; command exited with code %d.\", 1)\n\n    @patch('backup_module.subprocess.run')\n    @patch('backup_module.logger')\n    def test_empty_target_directory(self, mock_logger, mock_run):\n        \"\"\"Test empty target directory input (expected to fail).\"\"\"\n        # Setup mock to fail\n        mock_run.return_value = subprocess.CompletedProcess(args=[], returncode=2)\n        \n        # Call function and expect exception\n        with self.assertRaises(OSError):\n            generate_backup(\"\", \"empty_dir_backup\")\n        \n        # Verify command uses empty string\n        expected_command = [\"tar\", \"-czvf\", \"empty_dir_backup.tar.gz\", \"-C\", \"\", \".\"]\n        mock_run.assert_called_once_with(expected_command)\n        mock_logger.error.assert_called_once_with(\"Failed to create backup; command exited with code %d.\", 2)\n\n    @patch('backup_module.subprocess.run')\n    @patch('backup_module.logger')\n    def test_empty_tar_name(self, mock_logger, mock_run):\n        \"\"\"Test empty tar name input (should create '.tar.gz' file).\"\"\"\n        # Setup mock\n        mock_run.return_value = subprocess.CompletedProcess(args=[], returncode=0)\n        \n        # Call function\n        generate_backup(\"/some/dir\", \"\")\n        \n        # Verify command uses empty tar name\n        expected_command = [\"tar\", \"-czvf\", \".tar.gz\", \"-C\", \"/some/dir\", \".\"]\n        mock_run.assert_called_once_with(expected_command)\n        mock_logger.info.assert_any_call(\"Backup created successfully.\")\n\n    @patch('backup_module.logger')\n    def test_invalid_target_directory_type(self, mock_logger):\n        \"\"\"Test non-string target_directory (should raise TypeError).\"\"\"\n        # Call function with invalid type\n        with self.assertRaises(TypeError):\n            generate_backup(123, \"valid_name\")\n        \n        # Verify initial log occurred\n        mock_logger.info.assert_called_once_with(\"Creating backup...\")\n\n    @patch('backup_module.subprocess.run')\n    @patch('backup_module.logger')\n    def test_tar_command_not_found(self, mock_logger, mock_run):\n        \"\"\"Test failure when tar command is missing (raises OSError).\"\"\"\n        # Setup mock to simulate missing command\n        mock_run.side_effect = FileNotFoundError(\"tar: command not found\")\n        \n        # Call function and expect OSError\n        with self.assertRaises(OSError):\n            generate_backup(\"/valid/path\", \"missing_tar\")\n        \n        # Verify command was attempted and logged\n        expected_command = [\"tar\", \"-czvf\", \"missing_tar.tar.gz\", \"-C\", \"/valid/path\", \".\"]\n        mock_logger.info.assert_any_call(\"Running command: %s\", \" \".join(expected_command))\n        mock_logger.error.assert_not_called()  # Function doesn't reach error log\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 6, "task_id": "5720296d"}
{"test": "import unittest\nfrom unittest.mock import patch, MagicMock\nfrom solution import archive_directory\n\nclass TestArchiveDirectory(unittest.TestCase):\n    @patch('solution.logger')\n    @patch('subprocess.run')\n    def test_successful_backup(self, mock_run, mock_logger):\n        \"\"\"Test successful backup creation with valid inputs.\"\"\"\n        mock_run.return_value = MagicMock(returncode=0)\n        dir_path = '/valid/dir'\n        output_name = 'valid_backup'\n        \n        archive_directory(dir_path, output_name)\n        \n        mock_logger.info.assert_any_call(\"Creating backup...\")\n        mock_logger.info.assert_any_call(\"Running command: %s\", \"tar -czvf valid_backup.tar.gz -C /valid/dir .\")\n        mock_logger.info.assert_called_with(\"Backup created successfully.\")\n        mock_run.assert_called_once_with(['tar', '-czvf', 'valid_backup.tar.gz', '-C', '/valid/dir', '.'])\n    \n    @patch('solution.logger')\n    @patch('subprocess.run')\n    def test_failed_backup_nonzero_exit(self, mock_run, mock_logger):\n        \"\"\"Test backup failure with non-zero exit code.\"\"\"\n        mock_run.return_value = MagicMock(returncode=1)\n        dir_path = '/valid/dir'\n        output_name = 'valid_backup'\n        \n        with self.assertRaises(OSError):\n            archive_directory(dir_path, output_name)\n            \n        mock_logger.info.assert_any_call(\"Creating backup...\")\n        mock_logger.info.assert_any_call(\"Running command: %s\", \"tar -czvf valid_backup.tar.gz -C /valid/dir .\")\n        mock_logger.error.assert_called_with(\"Failed to create backup; command exited with code %d.\", 1)\n    \n    @patch('solution.logger')\n    @patch('subprocess.run')\n    def test_subprocess_exception(self, mock_run, mock_logger):\n        \"\"\"Test behavior when subprocess.run raises an exception.\"\"\"\n        mock_run.side_effect = FileNotFoundError(\"tar command not found\")\n        dir_path = '/valid/dir'\n        output_name = 'valid_backup'\n        \n        with self.assertRaises(FileNotFoundError):\n            archive_directory(dir_path, output_name)\n            \n        mock_logger.info.assert_any_call(\"Creating backup...\")\n        mock_logger.info.assert_any_call(\"Running command: %s\", \"tar -czvf valid_backup.tar.gz -C /valid/dir .\")\n        mock_logger.error.assert_not_called()\n    \n    @patch('solution.logger')\n    @patch('subprocess.run')\n    def test_empty_output_name(self, mock_run, mock_logger):\n        \"\"\"Test with empty output_name string.\"\"\"\n        mock_run.return_value = MagicMock(returncode=0)\n        dir_path = '/valid/dir'\n        output_name = ''\n        \n        archive_directory(dir_path, output_name)\n        \n        mock_run.assert_called_once_with(['tar', '-czvf', '.tar.gz', '-C', '/valid/dir', '.'])\n        mock_logger.info.assert_any_call(\"Running command: %s\", \"tar -czvf .tar.gz -C /valid/dir .\")\n    \n    @patch('solution.logger')\n    @patch('subprocess.run')\n    def test_output_name_with_spaces(self, mock_run, mock_logger):\n        \"\"\"Test output_name containing spaces.\"\"\"\n        mock_run.return_value = MagicMock(returncode=0)\n        dir_path = '/valid/dir'\n        output_name = 'backup name'\n        \n        archive_directory(dir_path, output_name)\n        \n        mock_run.assert_called_once_with(['tar', '-czvf', 'backup name.tar.gz', '-C', '/valid/dir', '.'])\n        mock_logger.info.assert_any_call(\"Running command: %s\", \"tar -czvf backup name.tar.gz -C /valid/dir .\")\n    \n    @patch('solution.logger')\n    @patch('subprocess.run')\n    def test_directory_path_with_spaces(self, mock_run, mock_logger):\n        \"\"\"Test dir_path containing spaces.\"\"\"\n        mock_run.return_value = MagicMock(returncode=0)\n        dir_path = '/valid dir'\n        output_name = 'backup'\n        \n        archive_directory(dir_path, output_name)\n        \n        mock_run.assert_called_once_with(['tar', '-czvf', 'backup.tar.gz', '-C', '/valid dir', '.'])\n        mock_logger.info.assert_any_call(\"Running command: %s\", \"tar -czvf backup.tar.gz -C /valid dir .\")\n    \n    @patch('solution.logger')\n    @patch('subprocess.run')\n    def test_empty_directory_path(self, mock_run, mock_logger):\n        \"\"\"Test with empty dir_path string.\"\"\"\n        mock_run.return_value = MagicMock(returncode=0)\n        dir_path = ''\n        output_name = 'backup'\n        \n        archive_directory(dir_path, output_name)\n        \n        mock_run.assert_called_once_with(['tar', '-czvf', 'backup.tar.gz', '-C', '', '.'])\n        mock_logger.info.assert_any_call(\"Running command: %s\", \"tar -czvf backup.tar.gz -C  .\")\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 7, "task_id": "4f52a1f2"}
{"test": "import unittest\nfrom unittest.mock import patch, MagicMock\nimport errno\n\nclass TestArchiveFolder(unittest.TestCase):\n\n    @patch('archive_utils.subprocess.run')\n    @patch('archive_utils.logger')\n    def test_successful_backup(self, mock_logger, mock_run):\n        \"\"\"Test successful backup creation.\"\"\"\n        mock_run.return_value = MagicMock(returncode=0)\n        folder_path = \"/valid/path\"\n        archive_name = \"valid_backup\"\n        \n        archive_folder(folder_path, archive_name)\n        \n        expected_command = ['tar', '-czvf', 'valid_backup.tar.gz', '-C', '/valid/path', '.']\n        mock_run.assert_called_once_with(expected_command)\n        mock_logger.info.assert_any_call(\"Creating backup...\")\n        mock_logger.info.assert_any_call(\"Running command: %s\", \" \".join(expected_command))\n        mock_logger.info.assert_called_with(\"Backup created successfully.\")\n        mock_logger.error.assert_not_called()\n\n    @patch('archive_utils.subprocess.run')\n    @patch('archive_utils.logger')\n    def test_non_zero_exit(self, mock_logger, mock_run):\n        \"\"\"Test handling of non-zero exit code from tar.\"\"\"\n        mock_run.return_value = MagicMock(returncode=1)\n        folder_path = \"/valid/path\"\n        archive_name = \"backup\"\n        \n        with self.assertRaises(OSError):\n            archive_folder(folder_path, archive_name)\n            \n        expected_command = ['tar', '-czvf', 'backup.tar.gz', '-C', '/valid/path', '.']\n        mock_run.assert_called_once_with(expected_command)\n        mock_logger.info.assert_any_call(\"Creating backup...\")\n        mock_logger.info.assert_any_call(\"Running command: %s\", \" \".join(expected_command))\n        mock_logger.error.assert_called_once_with(\"Failed to create backup; command exited with code %d.\", 1)\n\n    @patch('archive_utils.subprocess.run')\n    @patch('archive_utils.logger')\n    def test_file_not_found(self, mock_logger, mock_run):\n        \"\"\"Test handling of tar command not found (OSError).\"\"\"\n        mock_run.side_effect = FileNotFoundError(\"tar not found\")\n        folder_path = \"/valid/path\"\n        archive_name = \"backup\"\n        \n        with self.assertRaises(OSError):\n            archive_folder(folder_path, archive_name)\n            \n        expected_command = ['tar', '-czvf', 'backup.tar.gz', '-C', '/valid/path', '.']\n        mock_logger.info.assert_any_call(\"Creating backup...\")\n        mock_logger.info.assert_any_call(\"Running command: %s\", \" \".join(expected_command))\n        mock_logger.error.assert_not_called()\n\n    @patch('archive_utils.subprocess.run')\n    @patch('archive_utils.logger')\n    def test_permission_denied(self, mock_logger, mock_run):\n        \"\"\"Test handling of permission denied error (OSError).\"\"\"\n        mock_run.side_effect = OSError(errno.EACCES, \"Permission denied\")\n        folder_path = \"/restricted/path\"\n        archive_name = \"backup\"\n        \n        with self.assertRaises(OSError):\n            archive_folder(folder_path, archive_name)\n            \n        expected_command = ['tar', '-czvf', 'backup.tar.gz', '-C', '/restricted/path', '.']\n        mock_logger.info.assert_any_call(\"Creating backup...\")\n        mock_logger.info.assert_any_call(\"Running command: %s\", \" \".join(expected_command))\n        mock_logger.error.assert_not_called()\n\n    @patch('archive_utils.subprocess.run')\n    @patch('archive_utils.logger')\n    def test_empty_folder_path(self, mock_logger, mock_run):\n        \"\"\"Test empty folder_path with non-zero exit.\"\"\"\n        mock_run.return_value = MagicMock(returncode=2)\n        folder_path = \"\"\n        archive_name = \"backup\"\n        \n        with self.assertRaises(OSError):\n            archive_folder(folder_path, archive_name)\n            \n        expected_command = ['tar', '-czvf', 'backup.tar.gz', '-C', '', '.']\n        mock_run.assert_called_once_with(expected_command)\n        mock_logger.info.assert_any_call(\"Creating backup...\")\n        mock_logger.info.assert_any_call(\"Running command: %s\", \" \".join(expected_command))\n        mock_logger.error.assert_called_once_with(\"Failed to create backup; command exited with code %d.\", 2)\n\n    @patch('archive_utils.subprocess.run')\n    @patch('archive_utils.logger')\n    def test_empty_archive_name(self, mock_logger, mock_run):\n        \"\"\"Test empty archive_name with non-zero exit.\"\"\"\n        mock_run.return_value = MagicMock(returncode=3)\n        folder_path = \"/valid/path\"\n        archive_name = \"\"\n        \n        with self.assertRaises(OSError):\n            archive_folder(folder_path, archive_name)\n            \n        expected_command = ['tar', '-czvf', '.tar.gz', '-C', '/valid/path', '.']\n        mock_run.assert_called_once_with(expected_command)\n        mock_logger.info.assert_any_call(\"Creating backup...\")\n        mock_logger.info.assert_any_call(\"Running command: %s\", \" \".join(expected_command))\n        mock_logger.error.assert_called_once_with(\"Failed to create backup; command exited with code %d.\", 3)\n\n    @patch('archive_utils.subprocess.run')\n    @patch('archive_utils.logger')\n    def test_non_string_folder_path(self, mock_logger, mock_run):\n        \"\"\"Test non-string folder_path raises TypeError.\"\"\"\n        folder_path = 123\n        archive_name = \"backup\"\n        \n        with self.assertRaises(TypeError):\n            archive_folder(folder_path, archive_name)\n            \n        mock_logger.info.assert_called_once_with(\"Creating backup...\")\n        mock_run.assert_not_called()\n        mock_logger.error.assert_not_called()\n\n    @patch('archive_utils.subprocess.run')\n    @patch('archive_utils.logger')\n    def test_non_string_archive_name(self, mock_logger, mock_run):\n        \"\"\"Test non-string archive_name raises TypeError.\"\"\"\n        folder_path = \"/valid/path\"\n        archive_name = 123\n        \n        with self.assertRaises(TypeError):\n            archive_folder(folder_path, archive_name)\n            \n        mock_logger.info.assert_called_once_with(\"Creating backup...\")\n        mock_run.assert_not_called()\n        mock_logger.error.assert_not_called()\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 8, "task_id": "63cf4e2d"}
{"test": "import unittest\nfrom unittest.mock import patch, MagicMock\nfrom solution import compress_directory\n\nclass TestCompressDirectory(unittest.TestCase):\n\n    @patch('solution.subprocess.run')\n    @patch('solution.logger')\n    def test_success(self, mock_logger, mock_run):\n        \"\"\"Test successful backup creation with valid inputs.\"\"\"\n        mock_run.return_value = MagicMock(returncode=0)\n        compress_directory('/path/to/dir', 'backup')\n        mock_logger.info.assert_any_call('Creating backup...')\n        expected_command_str = 'tar -czvf backup.tar.gz -C /path/to/dir .'\n        mock_logger.info.assert_any_call('Running command: %s', expected_command_str)\n        mock_logger.info.assert_any_call('Backup created successfully.')\n        mock_logger.error.assert_not_called()\n\n    @patch('solution.subprocess.run')\n    @patch('solution.logger')\n    def test_failure(self, mock_logger, mock_run):\n        \"\"\"Test backup failure with non-zero exit code.\"\"\"\n        mock_run.return_value = MagicMock(returncode=1)\n        with self.assertRaises(OSError):\n            compress_directory('/path/to/dir', 'backup')\n        mock_logger.info.assert_any_call('Creating backup...')\n        expected_command_str = 'tar -czvf backup.tar.gz -C /path/to/dir .'\n        mock_logger.info.assert_any_call('Running command: %s', expected_command_str)\n        mock_logger.error.assert_called_with('Failed to create backup; command exited with code %d.', 1)\n\n    @patch('solution.subprocess.run')\n    @patch('solution.logger')\n    def test_command_build_normal(self, mock_logger, mock_run):\n        \"\"\"Test command construction with normal inputs.\"\"\"\n        mock_run.return_value = MagicMock(returncode=0)\n        compress_directory('/path/to/dir', 'backup')\n        mock_run.assert_called_once_with(['tar', '-czvf', 'backup.tar.gz', '-C', '/path/to/dir', '.'])\n\n    @patch('solution.subprocess.run')\n    @patch('solution.logger')\n    def test_command_build_with_spaces(self, mock_logger, mock_run):\n        \"\"\"Test command construction with spaces in output name.\"\"\"\n        mock_run.return_value = MagicMock(returncode=0)\n        compress_directory('/path/to/dir', 'my backup')\n        mock_run.assert_called_once_with(['tar', '-czvf', 'my backup.tar.gz', '-C', '/path/to/dir', '.'])\n\n    @patch('solution.subprocess.run')\n    @patch('solution.logger')\n    def test_command_build_empty_dir_path(self, mock_logger, mock_run):\n        \"\"\"Test command construction with empty directory path.\"\"\"\n        mock_run.return_value = MagicMock(returncode=0)\n        compress_directory('', 'backup')\n        mock_run.assert_called_once_with(['tar', '-czvf', 'backup.tar.gz', '-C', '', '.'])\n\n    @patch('solution.subprocess.run')\n    @patch('solution.logger')\n    def test_command_build_empty_output_name(self, mock_logger, mock_run):\n        \"\"\"Test command construction with empty output name.\"\"\"\n        mock_run.return_value = MagicMock(returncode=0)\n        compress_directory('/path/to/dir', '')\n        mock_run.assert_called_once_with(['tar', '-czvf', '.tar.gz', '-C', '/path/to/dir', '.'])\n\n    @patch('solution.subprocess.run')\n    @patch('solution.logger')\n    def test_command_not_found(self, mock_logger, mock_run):\n        \"\"\"Test handling of FileNotFoundError when command doesn't exist.\"\"\"\n        mock_run.side_effect = FileNotFoundError('tar not found')\n        with self.assertRaises(OSError):\n            compress_directory('/path/to/dir', 'backup')\n        mock_logger.info.assert_any_call('Creating backup...')\n        expected_command_str = 'tar -czvf backup.tar.gz -C /path/to/dir .'\n        mock_logger.info.assert_any_call('Running command: %s', expected_command_str)\n        mock_logger.error.assert_not_called()\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 7, "task_id": "7956d110"}
{"test": "import unittest\nfrom unittest.mock import patch, MagicMock\n\nclass TestSaveDirectory(unittest.TestCase):\n\n    @patch('solution.logger')\n    @patch('subprocess.run')\n    def test_success(self, mock_run, mock_logger):\n        \"\"\"Test successful backup creation with valid inputs.\"\"\"\n        mock_run.return_value = MagicMock(returncode=0)\n        folder_location = '/valid/path'\n        backup_title = 'valid_backup'\n        \n        save_directory(folder_location, backup_title)\n        \n        mock_logger.info.assert_any_call('Creating backup...')\n        expected_command = 'tar -czvf valid_backup.tar.gz -C /valid/path .'\n        mock_logger.info.assert_any_call('Running command: %s', expected_command)\n        mock_logger.info.assert_any_call('Backup created successfully.')\n        mock_logger.error.assert_not_called()\n\n    @patch('solution.logger')\n    @patch('subprocess.run')\n    def test_failure_non_zero_exit(self, mock_run, mock_logger):\n        \"\"\"Test failure when tar command returns non-zero exit code.\"\"\"\n        mock_run.return_value = MagicMock(returncode=1)\n        folder_location = '/valid/path'\n        backup_title = 'valid_backup'\n        \n        with self.assertRaises(OSError):\n            save_directory(folder_location, backup_title)\n        \n        mock_logger.info.assert_any_call('Creating backup...')\n        expected_command = 'tar -czvf valid_backup.tar.gz -C /valid/path .'\n        mock_logger.info.assert_any_call('Running command: %s', expected_command)\n        mock_logger.error.assert_called_with('Failed to create backup; command exited with code %d.', 1)\n\n    @patch('solution.logger')\n    @patch('subprocess.run')\n    def test_empty_folder_location(self, mock_run, mock_logger):\n        \"\"\"Test handling of empty folder_location string (simulate command failure).\"\"\"\n        mock_run.return_value = MagicMock(returncode=1)\n        folder_location = ''\n        backup_title = 'valid_title'\n        \n        with self.assertRaises(OSError):\n            save_directory(folder_location, backup_title)\n        \n        expected_command = 'tar -czvf valid_title.tar.gz -C  .'\n        mock_logger.info.assert_any_call('Running command: %s', expected_command)\n        mock_logger.error.assert_called_with('Failed to create backup; command exited with code %d.', 1)\n\n    @patch('solution.logger')\n    def test_non_string_folder_location(self, mock_logger):\n        \"\"\"Test TypeError when folder_location is not a string.\"\"\"\n        with self.assertRaises(TypeError):\n            save_directory(None, 'valid_title')\n        \n        mock_logger.info.assert_called_once_with('Creating backup...')\n\n    @patch('solution.logger')\n    def test_non_string_backup_title(self, mock_logger):\n        \"\"\"Test TypeError when backup_title is not a string.\"\"\"\n        with self.assertRaises(TypeError):\n            save_directory('/valid/path', None)\n        \n        mock_logger.info.assert_called_once_with('Creating backup...')\n\n    @patch('solution.logger')\n    @patch('subprocess.run')\n    def test_command_building(self, mock_run, mock_logger):\n        \"\"\"Verify command list is built correctly with standard inputs.\"\"\"\n        mock_run.return_value = MagicMock(returncode=0)\n        folder_location = '/test/path'\n        backup_title = 'test_backup'\n        \n        save_directory(folder_location, backup_title)\n        \n        mock_run.assert_called_once_with(['tar', '-czvf', 'test_backup.tar.gz', '-C', '/test/path', '.'])\n\n    @patch('solution.logger')\n    @patch('subprocess.run')\n    def test_special_characters_in_backup_title(self, mock_run, mock_logger):\n        \"\"\"Test special characters in backup_title are handled safely in command.\"\"\"\n        mock_run.return_value = MagicMock(returncode=0)\n        folder_location = '/test/path'\n        backup_title = 'backup!@#$%^&*()_+{}|:<>?[];\\',.~`'\n        \n        save_directory(folder_location, backup_title)\n        \n        expected_filename = 'backup!@#$%^&*()_+{}|:<>?[];\\',.~`.tar.gz'\n        mock_run.assert_called_once_with(['tar', '-czvf', expected_filename, '-C', '/test/path', '.'])", "num_test_cases": 7, "task_id": "77d735ab"}
{"test": "import unittest\nimport logging\nfrom unittest.mock import patch, MagicMock\nimport subprocess\n\n# Adjust the import according to your module structure\nfrom archive_module import archive_folder\n\nclass TestArchiveFolder(unittest.TestCase):\n\n    @patch('archive_module.logger')\n    @patch('subprocess.run')\n    def test_successful_archive(self, mock_run, mock_logger):\n        \"\"\"Test successful archive creation with valid inputs.\"\"\"\n        mock_run.return_value = subprocess.CompletedProcess(args=[], returncode=0)\n        \n        folder_path = '/valid/path'\n        archive_name = 'valid_backup'\n        \n        archive_folder(folder_path, archive_name)\n        \n        expected_command = [\"tar\", \"-czvf\", \"valid_backup.tar.gz\", \"-C\", \"/valid/path\", \".\"]\n        mock_run.assert_called_once_with(expected_command)\n        mock_logger.info.assert_any_call(\"Creating archive...\")\n        mock_logger.info.assert_any_call(\"Running command: %s\", \" \".join(expected_command))\n        mock_logger.info.assert_any_call(\"Archive created successfully.\")\n        mock_logger.error.assert_not_called()\n\n    @patch('archive_module.logger')\n    @patch('subprocess.run')\n    def test_failed_archive(self, mock_run, mock_logger):\n        \"\"\"Test archive failure with non-zero exit code.\"\"\"\n        mock_run.return_value = subprocess.CompletedProcess(args=[], returncode=1)\n        \n        folder_path = '/valid/path'\n        archive_name = 'failed_backup'\n        \n        with self.assertRaises(OSError):\n            archive_folder(folder_path, archive_name)\n            \n        expected_command = [\"tar\", \"-czvf\", \"failed_backup.tar.gz\", \"-C\", \"/valid/path\", \".\"]\n        mock_run.assert_called_once_with(expected_command)\n        mock_logger.info.assert_any_call(\"Creating archive...\")\n        mock_logger.info.assert_any_call(\"Running command: %s\", \" \".join(expected_command))\n        mock_logger.error.assert_called_once_with(\"Failed to create archive; command exited with code %d.\", 1)\n\n    @patch('archive_module.logger')\n    @patch('subprocess.run')\n    def test_empty_folder_path(self, mock_run, mock_logger):\n        \"\"\"Test empty folder path input.\"\"\"\n        mock_run.return_value = subprocess.CompletedProcess(args=[], returncode=1)\n        \n        folder_path = ''\n        archive_name = 'empty_folder'\n        \n        with self.assertRaises(OSError):\n            archive_folder(folder_path, archive_name)\n            \n        expected_command = [\"tar\", \"-czvf\", \"empty_folder.tar.gz\", \"-C\", \"\", \".\"]\n        mock_run.assert_called_once_with(expected_command)\n        mock_logger.error.assert_called_once_with(\"Failed to create archive; command exited with code %d.\", 1)\n\n    @patch('archive_module.logger')\n    @patch('subprocess.run')\n    def test_archive_name_with_special_chars(self, mock_run, mock_logger):\n        \"\"\"Test archive name with special characters and spaces.\"\"\"\n        mock_run.return_value = subprocess.CompletedProcess(args=[], returncode=0)\n        \n        folder_path = '/valid/path'\n        archive_name = 'special chars !@# $%^'\n        \n        archive_folder(folder_path, archive_name)\n        \n        expected_archive = \"special chars !@# $%^.tar.gz\"\n        expected_command = [\"tar\", \"-czvf\", expected_archive, \"-C\", \"/valid/path\", \".\"]\n        mock_run.assert_called_once_with(expected_command)\n        mock_logger.info.assert_any_call(\"Running command: %s\", \" \".join(expected_command))\n\n    @patch('archive_module.logger')\n    @patch('subprocess.run')\n    def test_folder_path_with_special_chars(self, mock_run, mock_logger):\n        \"\"\"Test folder path with special characters and spaces.\"\"\"\n        mock_run.return_value = subprocess.CompletedProcess(args=[], returncode=0)\n        \n        folder_path = '/path/with/special @#! chars'\n        archive_name = 'normal_name'\n        \n        archive_folder(folder_path, archive_name)\n        \n        expected_command = [\"tar\", \"-czvf\", \"normal_name.tar.gz\", \"-C\", \"/path/with/special @#! chars\", \".\"]\n        mock_run.assert_called_once_with(expected_command)\n        mock_logger.info.assert_any_call(\"Running command: %s\", \" \".join(expected_command))\n\n    @patch('archive_module.logger')\n    @patch('subprocess.run')\n    def test_non_existent_folder(self, mock_run, mock_logger):\n        \"\"\"Test non-existent folder path (simulated by tar failure).\"\"\"\n        mock_run.return_value = subprocess.CompletedProcess(args=[], returncode=1)\n        \n        folder_path = '/non/existent/path'\n        archive_name = 'non_existent'\n        \n        with self.assertRaises(OSError):\n            archive_folder(folder_path, archive_name)\n            \n        mock_logger.error.assert_called_once_with(\"Failed to create archive; command exited with code %d.\", 1)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 6, "task_id": "ed5b4a72"}
{"test": "import unittest\nfrom unittest.mock import patch, MagicMock\n\nclass TestCompressDirectory(unittest.TestCase):\n\n    @patch('subprocess.run')\n    @patch('solution.logger')\n    def test_success_normal(self, mock_logger, mock_run):\n        \"\"\"Test with normal inputs and successful execution.\"\"\"\n        mock_run.return_value = MagicMock(returncode=0)\n        dir_path = '/path/to/dir'\n        compressed_name = 'backup'\n        compress_directory(dir_path, compressed_name)\n        expected_command = ['tar', '-czvf', 'backup.tar.gz', '-C', dir_path, '.']\n        mock_run.assert_called_once_with(expected_command)\n        mock_logger.info.assert_any_call(\"Creating archive...\")\n        mock_logger.info.assert_any_call(\"Running command: %s\", \" \".join(expected_command))\n        mock_logger.info.assert_called_with(\"Archive created successfully.\")\n        mock_logger.error.assert_not_called()\n\n    @patch('subprocess.run')\n    @patch('solution.logger')\n    def test_success_empty_compressed_name(self, mock_logger, mock_run):\n        \"\"\"Test when compressed_name is an empty string.\"\"\"\n        mock_run.return_value = MagicMock(returncode=0)\n        dir_path = '/path/to/dir'\n        compressed_name = ''\n        compress_directory(dir_path, compressed_name)\n        expected_command = ['tar', '-czvf', '.tar.gz', '-C', dir_path, '.']\n        mock_run.assert_called_once_with(expected_command)\n        mock_logger.info.assert_any_call(\"Creating archive...\")\n        mock_logger.info.assert_any_call(\"Running command: %s\", \" \".join(expected_command))\n        mock_logger.info.assert_called_with(\"Archive created successfully.\")\n        mock_logger.error.assert_not_called()\n\n    @patch('subprocess.run')\n    @patch('solution.logger')\n    def test_success_empty_dir_path(self, mock_logger, mock_run):\n        \"\"\"Test when dir_path is an empty string.\"\"\"\n        mock_run.return_value = MagicMock(returncode=0)\n        dir_path = ''\n        compressed_name = 'backup'\n        compress_directory(dir_path, compressed_name)\n        expected_command = ['tar', '-czvf', 'backup.tar.gz', '-C', '', '.']\n        mock_run.assert_called_once_with(expected_command)\n        mock_logger.info.assert_any_call(\"Creating archive...\")\n        mock_logger.info.assert_any_call(\"Running command: %s\", \" \".join(expected_command))\n        mock_logger.info.assert_called_with(\"Archive created successfully.\")\n        mock_logger.error.assert_not_called()\n\n    @patch('subprocess.run')\n    @patch('solution.logger')\n    def test_failure_normal(self, mock_logger, mock_run):\n        \"\"\"Test failure with non-zero return code and normal inputs.\"\"\"\n        mock_run.return_value = MagicMock(returncode=1)\n        dir_path = '/path/to/dir'\n        compressed_name = 'backup'\n        with self.assertRaises(OSError):\n            compress_directory(dir_path, compressed_name)\n        expected_command = ['tar', '-czvf', 'backup.tar.gz', '-C', dir_path, '.']\n        mock_run.assert_called_once_with(expected_command)\n        mock_logger.info.assert_any_call(\"Creating archive...\")\n        mock_logger.info.assert_any_call(\"Running command: %s\", \" \".join(expected_command))\n        mock_logger.error.assert_called_with(\"Failed to create archive; command exited with code %d.\", 1)\n\n    @patch('subprocess.run')\n    @patch('solution.logger')\n    def test_failure_empty_inputs(self, mock_logger, mock_run):\n        \"\"\"Test failure when both dir_path and compressed_name are empty.\"\"\"\n        mock_run.return_value = MagicMock(returncode=2)\n        dir_path = ''\n        compressed_name = ''\n        with self.assertRaises(OSError):\n            compress_directory(dir_path, compressed_name)\n        expected_command = ['tar', '-czvf', '.tar.gz', '-C', '', '.']\n        mock_run.assert_called_once_with(expected_command)\n        mock_logger.info.assert_any_call(\"Creating archive...\")\n        mock_logger.info.assert_any_call(\"Running command: %s\", \" \".join(expected_command))\n        mock_logger.error.assert_called_with(\"Failed to create archive; command exited with code %d.\", 2)\n\n    @patch('subprocess.run')\n    @patch('solution.logger')\n    def test_tar_command_not_found(self, mock_logger, mock_run):\n        \"\"\"Test when the 'tar' command is not found (raises FileNotFoundError).\"\"\"\n        mock_run.side_effect = FileNotFoundError(\"tar: command not found\")\n        dir_path = '/path/to/dir'\n        compressed_name = 'backup'\n        with self.assertRaises(OSError):\n            compress_directory(dir_path, compressed_name)\n        expected_command = ['tar', '-czvf', 'backup.tar.gz', '-C', dir_path, '.']\n        mock_run.assert_called_once_with(expected_command)\n        mock_logger.info.assert_any_call(\"Creating archive...\")\n        mock_logger.info.assert_any_call(\"Running command: %s\", \" \".join(expected_command))\n        mock_logger.error.assert_not_called()\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 6, "task_id": "a4bb6af3"}
{"test": "import unittest\nfrom unittest.mock import patch, MagicMock\nfrom solution import save_folder\n\n\nclass TestSaveFolder(unittest.TestCase):\n\n    @patch('solution.subprocess.run')\n    @patch('solution.logger')\n    def test_success(self, mock_logger, mock_run):\n        # Test with valid inputs - success scenario.\n        mock_run.return_value = MagicMock(returncode=0)\n        folder_path = '/valid/path'\n        save_name = 'backup'\n        save_folder(folder_path, save_name)\n        expected_command = ['tar', '-czvf', 'backup.tar.gz', '-C', folder_path, '.']\n        mock_run.assert_called_once_with(expected_command)\n        mock_logger.info.assert_any_call('Creating backup...')\n        mock_logger.info.assert_any_call('Running command: %s', ' '.join(expected_command))\n        mock_logger.info.assert_called_with('Backup created successfully.')\n\n    @patch('solution.subprocess.run')\n    @patch('solution.logger')\n    def test_failure_non_zero_exit(self, mock_logger, mock_run):\n        # Test when the tar command fails (non-zero exit code).\n        mock_run.return_value = MagicMock(returncode=1)\n        folder_path = '/valid/path'\n        save_name = 'backup'\n        with self.assertRaises(OSError):\n            save_folder(folder_path, save_name)\n        mock_logger.info.assert_any_call('Creating backup...')\n        mock_logger.error.assert_called_with('Failed to create backup; command exited with code %d.', 1)\n\n    @patch('solution.subprocess.run')\n    @patch('solution.logger')\n    def test_empty_folder_path(self, mock_logger, mock_run):\n        # Test with an empty string for folder_path, which should cause the tar command to fail (non-zero exit).\n        mock_run.return_value = MagicMock(returncode=1)\n        folder_path = ''\n        save_name = 'backup'\n        with self.assertRaises(OSError):\n            save_folder(folder_path, save_name)\n        expected_command = ['tar', '-czvf', 'backup.tar.gz', '-C', '', '.']\n        mock_run.assert_called_once_with(expected_command)\n        mock_logger.info.assert_any_call('Running command: %s', ' '.join(expected_command))\n\n    @patch('solution.subprocess.run')\n    @patch('solution.logger')\n    def test_save_name_with_spaces(self, mock_logger, mock_run):\n        # Test save_name with spaces, which should be handled as a single argument.\n        mock_run.return_value = MagicMock(returncode=0)\n        folder_path = '/valid/path'\n        save_name = 'my backup'\n        save_folder(folder_path, save_name)\n        expected_command = ['tar', '-czvf', 'my backup.tar.gz', '-C', folder_path, '.']\n        mock_run.assert_called_once_with(expected_command)\n        mock_logger.info.assert_any_call('Running command: %s', ' '.join(expected_command))\n\n    @patch('solution.subprocess.run')\n    @patch('solution.logger')\n    def test_save_name_with_special_chars(self, mock_logger, mock_run):\n        # Test save_name with special characters (to ensure no injection and safe command building).\n        mock_run.return_value = MagicMock(returncode=0)\n        folder_path = '/valid/path'\n        save_name = 'backup;rm -rf *'\n        save_folder(folder_path, save_name)\n        expected_command = ['tar', '-czvf', 'backup;rm -rf *.tar.gz', '-C', folder_path, '.']\n        mock_run.assert_called_once_with(expected_command)\n        mock_logger.info.assert_any_call('Running command: %s', ' '.join(expected_command))\n\n    @patch('solution.subprocess.run')\n    @patch('solution.logger')\n    def test_save_name_as_integer(self, mock_logger, mock_run):\n        # Test save_name as an integer (should be converted to string).\n        mock_run.return_value = MagicMock(returncode=0)\n        folder_path = '/valid/path'\n        save_name = 12345\n        save_folder(folder_path, save_name)\n        expected_command = ['tar', '-czvf', '12345.tar.gz', '-C', folder_path, '.']\n        mock_run.assert_called_once_with(expected_command)\n\n    @patch('solution.logger')\n    def test_non_string_folder_path(self, mock_logger):\n        # Test folder_path as a non-string (integer) which should raise a TypeError.\n        with self.assertRaises(TypeError):\n            save_folder(123, 'backup')\n        mock_logger.info.assert_called_with('Creating backup...')\n\n    @patch('solution.logger')\n    def test_none_folder_path(self, mock_logger):\n        # Test folder_path as None which should raise a TypeError.\n        with self.assertRaises(TypeError):\n            save_folder(None, 'backup')\n        mock_logger.info.assert_called_with('Creating backup...')\n\n    @patch('solution.subprocess.run')\n    @patch('solution.logger')\n    def test_empty_save_name(self, mock_logger, mock_run):\n        # Test with empty save_name.\n        mock_run.return_value = MagicMock(returncode=0)\n        folder_path = '/valid/path'\n        save_name = ''\n        save_folder(folder_path, save_name)\n        expected_command = ['tar', '-czvf', '.tar.gz', '-C', folder_path, '.']\n        mock_run.assert_called_once_with(expected_command)\n\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 9, "task_id": "b616d973"}
{"test": "import unittest\nfrom unittest.mock import patch, MagicMock\nimport os\nimport subprocess\nfrom pathlib import Path\n\n# Import the function from its module (assuming it's in 'solution')\nfrom solution import remove_files\n\nclass TestRemoveFiles(unittest.TestCase):\n    \n    @patch('solution.logger')\n    @patch('solution.subprocess.run')\n    @patch('solution.Path')\n    def test_folder_not_exist(self, mock_path, mock_run, mock_logger):\n        \"\"\"Test when the folder does not exist.\"\"\"\n        mock_path.return_value.exists.return_value = False\n        \n        with self.assertRaises(FileNotFoundError):\n            remove_files('/non/existent/folder', 'txt')\n            \n        mock_logger.error.assert_called_once_with(\"The folder '%s' does not exist.\", '/non/existent/folder')\n        mock_run.assert_not_called()\n    \n    @patch('solution.logger')\n    @patch('solution.subprocess.run')\n    @patch('solution.Path')\n    def test_folder_exists_success(self, mock_path, mock_run, mock_logger):\n        \"\"\"Test successful deletion when folder exists and command succeeds.\"\"\"\n        mock_path.return_value.exists.return_value = True\n        mock_run.return_value = MagicMock(returncode=0)\n        \n        remove_files('/valid/folder', 'jpg')\n        \n        mock_logger.info.assert_any_call(\"Deleting files with extension '%s' in folder '%s'...\", 'jpg', '/valid/folder')\n        expected_command = [\"rm\", os.path.join('/valid/folder', '*.jpg')]\n        mock_logger.info.assert_any_call(\"Running command: %s\", expected_command)\n        mock_run.assert_called_once_with(expected_command)\n        mock_logger.info.assert_any_call(\"Files deleted successfully.\")\n    \n    @patch('solution.logger')\n    @patch('solution.subprocess.run')\n    @patch('solution.Path')\n    def test_folder_exists_failure(self, mock_path, mock_run, mock_logger):\n        \"\"\"Test when folder exists but the rm command fails.\"\"\"\n        mock_path.return_value.exists.return_value = True\n        mock_run.return_value = MagicMock(returncode=1)\n        \n        remove_files('/valid/folder', 'png')\n        \n        expected_command = [\"rm\", os.path.join('/valid/folder', '*.png')]\n        mock_run.assert_called_once_with(expected_command)\n        mock_logger.error.assert_called_once_with(\"Failed to delete files; command exited with code %d.\", 1)\n    \n    @patch('solution.logger')\n    @patch('solution.subprocess.run')\n    @patch('solution.Path')\n    def test_extension_without_dot(self, mock_path, mock_run, mock_logger):\n        \"\"\"Test file extension without a leading dot.\"\"\"\n        mock_path.return_value.exists.return_value = True\n        mock_run.return_value = MagicMock(returncode=0)\n        \n        remove_files('/some/folder', 'log')\n        \n        expected_command = [\"rm\", os.path.join('/some/folder', '*.log')]\n        mock_run.assert_called_once_with(expected_command)\n    \n    @patch('solution.logger')\n    @patch('solution.subprocess.run')\n    @patch('solution.Path')\n    def test_extension_with_dot(self, mock_path, mock_run, mock_logger):\n        \"\"\"Test file extension with a leading dot.\"\"\"\n        mock_path.return_value.exists.return_value = True\n        mock_run.return_value = MagicMock(returncode=0)\n        \n        remove_files('/some/folder', '.log')\n        \n        expected_command = [\"rm\", os.path.join('/some/folder', '*..log')]\n        mock_run.assert_called_once_with(expected_command)\n    \n    @patch('solution.logger')\n    @patch('solution.subprocess.run')\n    @patch('solution.Path')\n    def test_empty_extension(self, mock_path, mock_run, mock_logger):\n        \"\"\"Test empty file extension.\"\"\"\n        mock_path.return_value.exists.return_value = True\n        mock_run.return_value = MagicMock(returncode=0)\n        \n        remove_files('/some/folder', '')\n        \n        expected_command = [\"rm\", os.path.join('/some/folder', '*.'')]\n        mock_run.assert_called_once_with(expected_command)\n    \n    @patch('solution.logger')\n    @patch('solution.subprocess.run')\n    @patch('solution.Path')\n    def test_extension_with_space(self, mock_path, mock_run, mock_logger):\n        \"\"\"Test file extension containing a space.\"\"\"\n        mock_path.return_value.exists.return_value = True\n        mock_run.return_value = MagicMock(returncode=0)\n        \n        remove_files('/some/folder', 'text file')\n        \n        expected_command = [\"rm\", os.path.join('/some/folder', '*.text file')]\n        mock_run.assert_called_once_with(expected_command)\n    \n    @patch('solution.logger')\n    @patch('solution.subprocess.run')\n    @patch('solution.Path')\n    def test_extension_with_wildcard(self, mock_path, mock_run, mock_logger):\n        \"\"\"Test file extension containing wildcard characters.\"\"\"\n        mock_path.return_value.exists.return_value = True\n        mock_run.return_value = MagicMock(returncode=0)\n        \n        remove_files('/some/folder', 't*t')\n        \n        expected_command = [\"rm\", os.path.join('/some/folder', '*.t*t')]\n        mock_run.assert_called_once_with(expected_command)\n    \n    @patch('solution.logger')\n    @patch('solution.subprocess.run')\n    @patch('solution.Path')\n    def test_folder_trailing_slash(self, mock_path, mock_run, mock_logger):\n        \"\"\"Test folder path with a trailing slash.\"\"\"\n        mock_path.return_value.exists.return_value = True\n        mock_run.return_value = MagicMock(returncode=0)\n        \n        remove_files('/some/folder/', 'tmp')\n        \n        expected_command = [\"rm\", os.path.join('/some/folder/', '*.tmp')]\n        mock_run.assert_called_once_with(expected_command)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 9, "task_id": "1bcde115"}
{"test": "import os\nimport subprocess\nimport unittest\nfrom unittest.mock import patch, MagicMock\nfrom solution import erase_files\n\nclass TestEraseFiles(unittest.TestCase):\n\n    @patch('pathlib.Path')\n    @patch('subprocess.run')\n    @patch('solution.logger')\n    def test_success(self, mock_logger, mock_run, mock_path):\n        # Test folder exists and command returns 0 (success)\n        mock_path.return_value.exists.return_value = True\n        mock_run.return_value.returncode = 0\n        folder_path = '/test/dir'\n        file_type = 'txt'\n        expected_cmd = ['rm', os.path.join(folder_path, f'*.{file_type}')]\n        \n        erase_files(folder_path, file_type)\n        \n        mock_logger.info.assert_any_call('Deleting files with extension \\'%s\\' in folder \\'%s\\'...', file_type, folder_path)\n        mock_logger.info.assert_any_call('Running command: %s', expected_cmd)\n        mock_run.assert_called_once_with(expected_cmd)\n        mock_logger.info.assert_called_with('Files deleted successfully.')\n\n    @patch('pathlib.Path')\n    @patch('subprocess.run')\n    @patch('solution.logger')\n    def test_command_failure(self, mock_logger, mock_run, mock_path):\n        # Test folder exists but command returns non-zero (failure)\n        mock_path.return_value.exists.return_value = True\n        mock_run.return_value.returncode = 1\n        folder_path = '/test/dir'\n        file_type = 'txt'\n        expected_cmd = ['rm', os.path.join(folder_path, f'*.{file_type}')]\n        \n        erase_files(folder_path, file_type)\n        \n        mock_logger.info.assert_any_call('Deleting files with extension \\'%s\\' in folder \\'%s\\'...', file_type, folder_path)\n        mock_logger.info.assert_any_call('Running command: %s', expected_cmd)\n        mock_run.assert_called_once_with(expected_cmd)\n        mock_logger.error.assert_called_with('Failed to delete files; command exited with code %d.', 1)\n\n    @patch('pathlib.Path')\n    @patch('subprocess.run')\n    @patch('solution.logger')\n    def test_folder_not_found(self, mock_logger, mock_run, mock_path):\n        # Test folder does not exist (raises FileNotFoundError)\n        mock_path.return_value.exists.return_value = False\n        folder_path = '/test/dir'\n        file_type = 'txt'\n        \n        with self.assertRaises(FileNotFoundError) as context:\n            erase_files(folder_path, file_type)\n            \n        self.assertEqual(str(context.exception), f\"The folder '{folder_path}' does not exist.\")\n        mock_logger.error.assert_called_with('The folder \\'%s\\' does not exist.', folder_path)\n        mock_run.assert_not_called()\n\n    @patch('pathlib.Path')\n    @patch('subprocess.run')\n    @patch('solution.logger')\n    def test_folder_path_none(self, mock_logger, mock_run, mock_path):\n        # Test folder_path is None (raises TypeError)\n        folder_path = None\n        file_type = 'txt'\n        \n        with self.assertRaises(TypeError):\n            erase_files(folder_path, file_type)\n            \n        mock_logger.info.assert_called_once_with('Deleting files with extension \\'%s\\' in folder \\'%s\\'...', file_type, folder_path)\n        mock_run.assert_not_called()\n\n    @patch('pathlib.Path')\n    @patch('subprocess.run')\n    @patch('solution.logger')\n    def test_file_type_empty_string(self, mock_logger, mock_run, mock_path):\n        # Test file_type is empty string\n        mock_path.return_value.exists.return_value = True\n        mock_run.return_value.returncode = 0\n        folder_path = '/test/dir'\n        file_type = ''\n        expected_cmd = ['rm', os.path.join(folder_path, f'*.{file_type}')]\n        \n        erase_files(folder_path, file_type)\n        \n        mock_run.assert_called_once_with(expected_cmd)\n        mock_logger.info.assert_any_call('Running command: %s', expected_cmd)\n\n    @patch('pathlib.Path')\n    @patch('subprocess.run')\n    @patch('solution.logger')\n    def test_file_type_special_chars(self, mock_logger, mock_run, mock_path):\n        # Test file_type with special characters\n        mock_path.return_value.exists.return_value = True\n        mock_run.return_value.returncode = 0\n        folder_path = '/test/dir'\n        file_type = 'txt/abc'\n        expected_cmd = ['rm', os.path.join(folder_path, f'*.{file_type}')]\n        \n        erase_files(folder_path, file_type)\n        \n        mock_run.assert_called_once_with(expected_cmd)\n\n    @patch('pathlib.Path')\n    @patch('subprocess.run')\n    @patch('solution.logger')\n    def test_file_type_none(self, mock_logger, mock_run, mock_path):\n        # Test file_type is None\n        mock_path.return_value.exists.return_value = True\n        mock_run.return_value.returncode = 0\n        folder_path = '/test/dir'\n        file_type = None\n        expected_cmd = ['rm', os.path.join(folder_path, f'*.{file_type}')]\n        \n        erase_files(folder_path, file_type)\n        \n        mock_run.assert_called_once_with(expected_cmd)\n\n    @patch('pathlib.Path')\n    @patch('subprocess.run')\n    @patch('solution.logger')\n    def test_folder_path_empty_string(self, mock_logger, mock_run, mock_path):\n        # Test folder_path is empty string\n        mock_path.return_value.exists.return_value = True\n        mock_run.return_value.returncode = 0\n        folder_path = ''\n        file_type = 'txt'\n        expected_cmd = ['rm', os.path.join(folder_path, f'*.{file_type}')]\n        \n        erase_files(folder_path, file_type)\n        \n        mock_run.assert_called_once_with(expected_cmd)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 8, "task_id": "46ad13e6"}
{"test": "import unittest\nimport os\nfrom unittest.mock import patch, MagicMock\n\n# Assume the function is in a module named 'solution'\nfrom solution import discard_files\n\nclass TestDiscardFiles(unittest.TestCase):\n    \n    @patch('solution.Path')\n    @patch('solution.logger')\n    @patch('solution.subprocess.run')\n    def test_happy_path_success(self, mock_run, mock_logger, mock_path):\n        \"\"\"Test successful deletion when directory exists and command returns zero.\"\"\"\n        mock_path.return_value.exists.return_value = True\n        mock_run.return_value = MagicMock(returncode=0)\n        \n        discard_files('/tmp', 'txt')\n        \n        mock_logger.info.assert_any_call(\"Deleting files with extension '%s' in directory '%s'...\", 'txt', '/tmp')\n        expected_cmd = ['rm', os.path.join('/tmp', '*.txt')]\n        mock_logger.info.assert_any_call(\"Running command: %s\", expected_cmd)\n        mock_logger.info.assert_called_with(\"Files deleted successfully.\")\n        mock_run.assert_called_once_with(expected_cmd)\n    \n    @patch('solution.Path')\n    @patch('solution.logger')\n    @patch('solution.subprocess.run')\n    def test_command_failure(self, mock_run, mock_logger, mock_path):\n        \"\"\"Test command failure when directory exists but command returns non-zero.\"\"\"\n        mock_path.return_value.exists.return_value = True\n        mock_run.return_value = MagicMock(returncode=2)\n        \n        discard_files('/tmp', 'log')\n        \n        mock_logger.info.assert_any_call(\"Deleting files with extension '%s' in directory '%s'...\", 'log', '/tmp')\n        expected_cmd = ['rm', os.path.join('/tmp', '*.log')]\n        mock_logger.info.assert_any_call(\"Running command: %s\", expected_cmd)\n        mock_logger.error.assert_called_with(\"Failed to delete files; command exited with code %d.\", 2)\n        mock_run.assert_called_once_with(expected_cmd)\n    \n    @patch('solution.Path')\n    @patch('solution.logger')\n    def test_directory_not_found(self, mock_logger, mock_path):\n        \"\"\"Test FileNotFoundError when directory does not exist.\"\"\"\n        mock_path.return_value.exists.return_value = False\n        \n        with self.assertRaises(FileNotFoundError):\n            discard_files('/nonexistent', 'txt')\n            \n        mock_logger.info.assert_called_with(\"Deleting files with extension '%s' in directory '%s'...\", 'txt', '/nonexistent')\n        mock_logger.error.assert_called_with(\"The directory '%s' does not exist.\", '/nonexistent')\n    \n    @patch('solution.Path')\n    @patch('solution.logger')\n    @patch('solution.subprocess.run')\n    def test_command_building_simple_path(self, mock_run, mock_logger, mock_path):\n        \"\"\"Test command building with a simple directory path and extension.\"\"\"\n        mock_path.return_value.exists.return_value = True\n        mock_run.return_value = MagicMock(returncode=0)\n        \n        discard_files('/simple/path', 'ext')\n        \n        expected_cmd = ['rm', os.path.join('/simple/path', '*.ext')]\n        mock_run.assert_called_once_with(expected_cmd)\n    \n    @patch('solution.Path')\n    @patch('solution.logger')\n    @patch('solution.subprocess.run')\n    def test_command_building_path_with_spaces(self, mock_run, mock_logger, mock_path):\n        \"\"\"Test command building with a directory path containing spaces.\"\"\"\n        mock_path.return_value.exists.return_value = True\n        mock_run.return_value = MagicMock(returncode=0)\n        \n        discard_files('/path with spaces', 'my ext')\n        \n        expected_cmd = ['rm', os.path.join('/path with spaces', '*.my ext')]\n        mock_run.assert_called_once_with(expected_cmd)\n    \n    def test_invalid_dir_path_type(self):\n        \"\"\"Test TypeError when dir_path is not a string.\"\"\"\n        with self.assertRaises(TypeError):\n            discard_files(123, 'txt')\n    \n    def test_invalid_ext_type(self):\n        \"\"\"Test TypeError when extension is not a string.\"\"\"\n        with self.assertRaises(TypeError):\n            discard_files('/tmp', 123)\n    \n    @patch('solution.Path')\n    @patch('solution.logger')\n    @patch('solution.subprocess.run')\n    def test_empty_extension(self, mock_run, mock_logger, mock_path):\n        \"\"\"Test command building with an empty extension.\"\"\"\n        mock_path.return_value.exists.return_value = True\n        mock_run.return_value = MagicMock(returncode=0)\n        \n        discard_files('/tmp', '')\n        \n        expected_cmd = ['rm', os.path.join('/tmp', '*.'')]\n        mock_run.assert_called_once_with(expected_cmd)\n    \n    @patch('solution.Path')\n    @patch('solution.logger')\n    @patch('solution.subprocess.run')\n    def test_special_characters_in_extension(self, mock_run, mock_logger, mock_path):\n        \"\"\"Test command building with special characters in the extension.\"\"\"\n        mock_path.return_value.exists.return_value = True\n        mock_run.return_value = MagicMock(returncode=0)\n        \n        discard_files('/tmp', 'special*char')\n        \n        expected_cmd = ['rm', os.path.join('/tmp', '*.special*char')]\n        mock_run.assert_called_once_with(expected_cmd)\n", "num_test_cases": 9, "task_id": "016f7464"}
{"test": "import unittest\nfrom unittest.mock import patch, MagicMock\nimport os\nfrom solution import remove_files\n\nclass TestRemoveFiles(unittest.TestCase):\n    @patch('solution.Path')\n    @patch('solution.subprocess.run')\n    @patch('solution.logger')\n    def test_directory_not_found(self, mock_logger, mock_run, mock_path):\n        \"\"\"Test that FileNotFoundError is raised when directory doesn't exist.\"\"\"\n        mock_path.return_value.exists.return_value = False\n        \n        with self.assertRaises(FileNotFoundError):\n            remove_files('/non/existent/path', 'txt')\n            \n        mock_logger.error.assert_called_with(\"The directory '%s' does not exist.\", '/non/existent/path')\n    \n    @patch('solution.Path')\n    @patch('solution.subprocess.run')\n    @patch('solution.logger')\n    def test_successful_deletion(self, mock_logger, mock_run, mock_path):\n        \"\"\"Test successful deletion with valid directory and extension.\"\"\"\n        mock_path.return_value.exists.return_value = True\n        mock_run.return_value.returncode = 0\n        \n        folder = '/valid/path'\n        ext = 'txt'\n        remove_files(folder, ext)\n        \n        expected_cmd = ['rm', os.path.join(folder, f'*.{ext}')]\n        mock_run.assert_called_once_with(expected_cmd)\n        mock_logger.info.assert_any_call(\"Deleting files with extension '%s' in directory '%s'...\", ext, folder)\n        mock_logger.info.assert_any_call(\"Running command: %s\", expected_cmd)\n        mock_logger.info.assert_called_with(\"Files deleted successfully.\")\n    \n    @patch('solution.Path')\n    @patch('solution.subprocess.run')\n    @patch('solution.logger')\n    def test_failed_deletion(self, mock_logger, mock_run, mock_path):\n        \"\"\"Test error logging when deletion command fails (non-zero exit code).\"\"\"\n        mock_path.return_value.exists.return_value = True\n        mock_run.return_value.returncode = 1\n        \n        folder = '/valid/path'\n        ext = 'log'\n        remove_files(folder, ext)\n        \n        mock_logger.error.assert_called_with(\"Failed to delete files; command exited with code %d.\", 1)\n    \n    @patch('solution.Path')\n    @patch('solution.subprocess.run')\n    @patch('solution.logger')\n    def test_empty_extension(self, mock_logger, mock_run, mock_path):\n        \"\"\"Test deletion with empty extension string.\"\"\"\n        mock_path.return_value.exists.return_value = True\n        mock_run.return_value.returncode = 0\n        \n        folder = '/valid/path'\n        ext = ''\n        remove_files(folder, ext)\n        \n        expected_cmd = ['rm', os.path.join(folder, '*.')]\n        mock_run.assert_called_once_with(expected_cmd)\n    \n    @patch('solution.Path')\n    @patch('solution.subprocess.run')\n    @patch('solution.logger')\n    def test_extension_with_special_chars(self, mock_logger, mock_run, mock_path):\n        \"\"\"Test command formatting with special characters in extension.\"\"\"\n        mock_path.return_value.exists.return_value = True\n        mock_run.return_value.returncode = 0\n        \n        folder = '/valid/path'\n        ext = 't?xt'\n        remove_files(folder, ext)\n        \n        expected_cmd = ['rm', os.path.join(folder, '*.t?xt')]\n        mock_run.assert_called_once_with(expected_cmd)\n    \n    @patch('solution.Path')\n    @patch('solution.subprocess.run')\n    @patch('solution.logger')\n    def test_extension_with_dot(self, mock_logger, mock_run, mock_path):\n        \"\"\"Test command formatting with extension containing a dot.\"\"\"\n        mock_path.return_value.exists.return_value = True\n        mock_run.return_value.returncode = 0\n        \n        folder = '/valid/path'\n        ext = 'tar.gz'\n        remove_files(folder, ext)\n        \n        expected_cmd = ['rm', os.path.join(folder, '*.tar.gz')]\n        mock_run.assert_called_once_with(expected_cmd)\n    \n    def test_non_string_folder(self):\n        \"\"\"Test TypeError when folder is not a string.\"\"\"\n        with self.assertRaises(TypeError):\n            remove_files(None, 'txt')\n    \n    def test_non_string_extension(self):\n        \"\"\"Test TypeError when extension is not a string.\"\"\"\n        with self.assertRaises(TypeError):\n            remove_files('/valid/path', None)\n", "num_test_cases": 8, "task_id": "aeee72ee"}
{"test": "import unittest\nfrom unittest.mock import patch, MagicMock, call\n\n# Assuming the function is imported from a module named 'solution'\nfrom solution import clean_up_files\n\nclass TestCleanUpFiles(unittest.TestCase):\n\n    @patch('solution.logger')\n    @patch('subprocess.run')\n    @patch('os.path.join')\n    @patch('pathlib.Path')\n    def test_success(self, mock_path, mock_os_path_join, mock_subprocess_run, mock_logger):\n        \"\"\"Test normal operation: directory exists, command runs successfully.\"\"\"\n        mock_path.return_value.exists.return_value = True\n        mock_os_path_join.return_value = '/test/dir/*.txt'\n        mock_subprocess_run.return_value = MagicMock(returncode=0)\n        \n        clean_up_files('/test/dir', 'txt')\n        \n        mock_path.assert_called_once_with('/test/dir')\n        mock_path.return_value.exists.assert_called_once()\n        mock_os_path_join.assert_called_once_with('/test/dir', '*.txt')\n        mock_subprocess_run.assert_called_once_with(['rm', '/test/dir/*.txt'])\n        expected_info_calls = [\n            call(\"Deleting files with extension '%s' in directory '%s'...\", 'txt', '/test/dir'),\n            call(\"Running command: %s\", ['rm', '/test/dir/*.txt']),\n            call(\"Files deleted successfully.\")\n        ]\n        mock_logger.info.assert_has_calls(expected_info_calls)\n        mock_logger.error.assert_not_called()\n\n    @patch('solution.logger')\n    @patch('subprocess.run')\n    @patch('os.path.join')\n    @patch('pathlib.Path')\n    def test_directory_not_found(self, mock_path, mock_os_path_join, mock_subprocess_run, mock_logger):\n        \"\"\"Test when the directory does not exist (raises FileNotFoundError).\"\"\"\n        mock_path.return_value.exists.return_value = False\n        \n        with self.assertRaises(FileNotFoundError) as context:\n            clean_up_files('/test/dir', 'txt')\n        self.assertEqual(str(context.exception), \"The directory '/test/dir' does not exist.\")\n        \n        mock_logger.error.assert_called_once_with(\"The directory '%s' does not exist.\", '/test/dir')\n        mock_os_path_join.assert_not_called()\n        mock_subprocess_run.assert_not_called()\n\n    @patch('solution.logger')\n    @patch('subprocess.run')\n    @patch('os.path.join')\n    @patch('pathlib.Path')\n    def test_command_fails(self, mock_path, mock_os_path_join, mock_subprocess_run, mock_logger):\n        \"\"\"Test when the rm command fails (returns non-zero exit code).\"\"\"\n        mock_path.return_value.exists.return_value = True\n        mock_os_path_join.return_value = '/test/dir/*.txt'\n        mock_subprocess_run.return_value = MagicMock(returncode=1)\n        \n        clean_up_files('/test/dir', 'txt')\n        \n        mock_subprocess_run.assert_called_once_with(['rm', '/test/dir/*.txt'])\n        mock_logger.info.assert_any_call(\"Deleting files with extension '%s' in directory '%s'...\", 'txt', '/test/dir')\n        mock_logger.info.assert_any_call(\"Running command: %s\", ['rm', '/test/dir/*.txt'])\n        mock_logger.error.assert_called_once_with(\"Failed to delete files; command exited with code %d.\", 1)\n\n    @patch('solution.logger')\n    @patch('subprocess.run')\n    @patch('os.path.join')\n    @patch('pathlib.Path')\n    def test_empty_extension(self, mock_path, mock_os_path_join, mock_subprocess_run, mock_logger):\n        \"\"\"Test with an empty string as the file extension.\"\"\"\n        mock_path.return_value.exists.return_value = True\n        mock_os_path_join.return_value = '/test/dir/*.'\n        mock_subprocess_run.return_value = MagicMock(returncode=0)\n        \n        clean_up_files('/test/dir', '')\n        \n        mock_os_path_join.assert_called_once_with('/test/dir', '*.')\n        mock_subprocess_run.assert_called_once_with(['rm', '/test/dir/*.'])\n\n    @patch('solution.logger')\n    @patch('subprocess.run')\n    @patch('os.path.join')\n    @patch('pathlib.Path')\n    def test_extension_with_dot(self, mock_path, mock_os_path_join, mock_subprocess_run, mock_logger):\n        \"\"\"Test with a file extension containing a dot (e.g., 'txt.bak').\"\"\"\n        mock_path.return_value.exists.return_value = True\n        mock_os_path_join.return_value = '/test/dir/*.txt.bak'\n        mock_subprocess_run.return_value = MagicMock(returncode=0)\n        \n        clean_up_files('/test/dir', 'txt.bak')\n        \n        mock_os_path_join.assert_called_once_with('/test/dir', '*.txt.bak')\n        mock_subprocess_run.assert_called_once_with(['rm', '/test/dir/*.txt.bak'])\n\n    @patch('solution.logger')\n    @patch('subprocess.run')\n    @patch('os.path.join')\n    @patch('pathlib.Path')\n    def test_extension_with_space(self, mock_path, mock_os_path_join, mock_subprocess_run, mock_logger):\n        \"\"\"Test with a file extension containing a space.\"\"\"\n        mock_path.return_value.exists.return_value = True\n        mock_os_path_join.return_value = '/test/dir/*.text file'\n        mock_subprocess_run.return_value = MagicMock(returncode=0)\n        \n        clean_up_files('/test/dir', 'text file')\n        \n        mock_os_path_join.assert_called_once_with('/test/dir', '*.text file')\n        mock_subprocess_run.assert_called_once_with(['rm', '/test/dir/*.text file'])\n\n    @patch('solution.logger')\n    @patch('subprocess.run')\n    @patch('os.path.join')\n    @patch('pathlib.Path')\n    def test_extension_as_integer(self, mock_path, mock_os_path_join, mock_subprocess_run, mock_logger):\n        \"\"\"Test with an integer as the file extension (should convert to string).\"\"\"\n        mock_path.return_value.exists.return_value = True\n        mock_os_path_join.return_value = '/test/dir/*.123'\n        mock_subprocess_run.return_value = MagicMock(returncode=0)\n        \n        clean_up_files('/test/dir', 123)\n        \n        mock_os_path_join.assert_called_once_with('/test/dir', '*.123')\n        mock_subprocess_run.assert_called_once_with(['rm', '/test/dir/*.123'])\n\n    @patch('solution.logger')\n    @patch('subprocess.run')\n    @patch('os.path.join')\n    @patch('pathlib.Path')\n    def test_extension_as_none(self, mock_path, mock_os_path_join, mock_subprocess_run, mock_logger):\n        \"\"\"Test with None as the file extension (becomes string 'None').\"\"\"\n        mock_path.return_value.exists.return_value = True\n        mock_os_path_join.return_value = '/test/dir/*.None'\n        mock_subprocess_run.return_value = MagicMock(returncode=0)\n        \n        clean_up_files('/test/dir', None)\n        \n        mock_os_path_join.assert_called_once_with('/test/dir', '*.None')\n        mock_subprocess_run.assert_called_once_with(['rm', '/test/dir/*.None'])\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 8, "task_id": "4e36d9ff"}
{"test": "import unittest\nfrom unittest.mock import patch, MagicMock\nfrom solution import purge_files\n\nclass TestPurgeFiles(unittest.TestCase):\n    \n    @patch('solution.logger')\n    @patch('solution.Path')\n    def test_directory_does_not_exist(self, mock_path, mock_logger):\n        # Test when directory does not exist\n        mock_path_instance = mock_path.return_value\n        mock_path_instance.exists.return_value = False\n        \n        with self.assertRaises(FileNotFoundError):\n            purge_files('/invalid/directory', 'txt')\n        mock_logger.error.assert_called_once_with(\"The directory '%s' does not exist.\", '/invalid/directory')\n    \n    @patch('solution.logger')\n    @patch('solution.subprocess.run')\n    @patch('solution.os.path.join')\n    @patch('solution.Path')\n    def test_successful_deletion(self, mock_path, mock_join, mock_run, mock_logger):\n        # Test successful file deletion\n        mock_path_instance = mock_path.return_value\n        mock_path_instance.exists.return_value = True\n        mock_join.return_value = '/valid/directory/*.txt'\n        mock_run.return_value = MagicMock(returncode=0)\n        \n        purge_files('/valid/directory', 'txt')\n        \n        mock_run.assert_called_once_with(['rm', '/valid/directory/*.txt'])\n        mock_logger.info.assert_any_call(\"Deleting files with extension '%s' in directory '%s'...\", 'txt', '/valid/directory')\n        mock_logger.info.assert_any_call(\"Running command: %s\", ['rm', '/valid/directory/*.txt'])\n        mock_logger.info.assert_called_with(\"Files deleted successfully.\")\n    \n    @patch('solution.logger')\n    @patch('solution.subprocess.run')\n    @patch('solution.Path')\n    def test_failed_deletion(self, mock_path, mock_run, mock_logger):\n        # Test when deletion command fails\n        mock_path_instance = mock_path.return_value\n        mock_path_instance.exists.return_value = True\n        mock_run.return_value = MagicMock(returncode=1)\n        \n        purge_files('/valid/directory', 'txt')\n        \n        mock_logger.error.assert_called_once_with(\"Failed to delete files; command exited with code %d.\", 1)\n    \n    @patch('solution.logger')\n    @patch('solution.subprocess.run')\n    @patch('solution.os.path.join')\n    @patch('solution.Path')\n    def test_empty_extension(self, mock_path, mock_join, mock_run, mock_logger):\n        # Test with empty extension\n        mock_path_instance = mock_path.return_value\n        mock_path_instance.exists.return_value = True\n        mock_join.return_value = '/valid/directory/*.'\n        mock_run.return_value = MagicMock(returncode=0)\n        \n        purge_files('/valid/directory', '')\n        \n        mock_run.assert_called_once_with(['rm', '/valid/directory/*.'])\n    \n    @patch('solution.logger')\n    @patch('solution.subprocess.run')\n    @patch('solution.os.path.join')\n    @patch('solution.Path')\n    def test_extension_with_dot(self, mock_path, mock_join, mock_run, mock_logger):\n        # Test extension containing a dot\n        mock_path_instance = mock_path.return_value\n        mock_path_instance.exists.return_value = True\n        mock_join.return_value = '/valid/directory/*..txt'\n        mock_run.return_value = MagicMock(returncode=0)\n        \n        purge_files('/valid/directory', '.txt')\n        \n        mock_run.assert_called_once_with(['rm', '/valid/directory/*..txt'])\n    \n    @patch('solution.logger')\n    @patch('solution.subprocess.run')\n    @patch('solution.Path')\n    def test_no_files_found(self, mock_path, mock_run, mock_logger):\n        # Test when no files match the extension\n        mock_path_instance = mock_path.return_value\n        mock_path_instance.exists.return_value = True\n        mock_run.return_value = MagicMock(returncode=1)\n        \n        purge_files('/valid/directory', 'txt')\n        \n        mock_logger.error.assert_called_once_with(\"Failed to delete files; command exited with code %d.\", 1)\n    \n    @patch('solution.logger')\n    @patch('solution.subprocess.run')\n    @patch('solution.Path')\n    def test_command_execution_failure(self, mock_path, mock_run, mock_logger):\n        # Test command failure with non-zero exit code\n        mock_path_instance = mock_path.return_value\n        mock_path_instance.exists.return_value = True\n        mock_run.return_value = MagicMock(returncode=2)\n        \n        purge_files('/valid/directory', 'png')\n        \n        mock_logger.error.assert_called_once_with(\"Failed to delete files; command exited with code %d.\", 2)\n    \n    @patch('solution.logger')\n    @patch('solution.subprocess.run')\n    @patch('solution.os.path.join')\n    @patch('solution.Path')\n    def test_extension_with_special_characters(self, mock_path, mock_join, mock_run, mock_logger):\n        # Test extension with special characters\n        mock_path_instance = mock_path.return_value\n        mock_path_instance.exists.return_value = True\n        mock_join.return_value = '/valid/directory/*.special_ext'\n        mock_run.return_value = MagicMock(returncode=0)\n        \n        purge_files('/valid/directory', 'special_ext')\n        \n        mock_run.assert_called_once_with(['rm', '/valid/directory/*.special_ext'])\n    \n    @patch('solution.logger')\n    @patch('solution.subprocess.run')\n    @patch('solution.os.path.join')\n    @patch('solution.Path')\n    def test_long_directory_path(self, mock_path, mock_join, mock_run, mock_logger):\n        # Test with a long directory path\n        long_path = '/a' * 1000\n        mock_path_instance = mock_path.return_value\n        mock_path_instance.exists.return_value = True\n        mock_join.return_value = f'{long_path}/*.txt'\n        mock_run.return_value = MagicMock(returncode=0)\n        \n        purge_files(long_path, 'txt')\n        \n        mock_run.assert_called_once_with(['rm', f'{long_path}/*.txt'])\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 9, "task_id": "395d9af0"}
{"test": "import unittest\nimport os\nfrom unittest.mock import patch, MagicMock\n\nclass TestRemoveFiles(unittest.TestCase):\n\n    @patch('subprocess.run')\n    @patch('pathlib.Path')\n    @patch('__main__.logger')\n    def test_folder_exists_deletion_success(self, mock_logger, mock_path, mock_run):\n        \"\"\"Test deletion with valid folder and file type, successful deletion.\"\"\"\n        mock_path.return_value.exists.return_value = True\n        mock_run.return_value.returncode = 0\n        folder = '/test/dir'\n        file_type = 'txt'\n        \n        remove_files(folder, file_type)\n        \n        expected_command = ['rm', os.path.join(folder, f'*.{file_type}')]\n        mock_logger.info.assert_any_call(\"Deleting files with extension '%s' in directory '%s'...\", file_type, folder)\n        mock_logger.info.assert_any_call(\"Running command: %s\", expected_command)\n        mock_logger.info.assert_any_call(\"Files deleted successfully.\")\n        mock_run.assert_called_once_with(expected_command)\n\n    @patch('subprocess.run')\n    @patch('pathlib.Path')\n    @patch('__main__.logger')\n    def test_folder_not_exists_exception(self, mock_logger, mock_path, mock_run):\n        \"\"\"Test FileNotFoundError when folder does not exist.\"\"\"\n        mock_path.return_value.exists.return_value = False\n        folder = '/nonexistent/dir'\n        file_type = 'log'\n        \n        with self.assertRaises(FileNotFoundError):\n            remove_files(folder, file_type)\n            \n        mock_logger.info.assert_called_with(\"Deleting files with extension '%s' in directory '%s'...\", file_type, folder)\n        mock_logger.error.assert_called_with(\"The folder '%s' does not exist.\", folder)\n        mock_run.assert_not_called()\n\n    @patch('subprocess.run')\n    @patch('pathlib.Path')\n    @patch('__main__.logger')\n    def test_deletion_failure_nonzero_exit(self, mock_logger, mock_path, mock_run):\n        \"\"\"Test deletion failure with non-zero exit code, logs error.\"\"\"\n        mock_path.return_value.exists.return_value = True\n        mock_run.return_value.returncode = 1\n        folder = '/test/dir'\n        file_type = 'tmp'\n        \n        remove_files(folder, file_type)\n        \n        expected_command = ['rm', os.path.join(folder, f'*.{file_type}')]\n        mock_logger.info.assert_any_call(\"Deleting files with extension '%s' in directory '%s'...\", file_type, folder)\n        mock_logger.info.assert_any_call(\"Running command: %s\", expected_command)\n        mock_logger.error.assert_called_with(\"Failed to delete files; command exited with code %d.\", 1)\n\n    @patch('subprocess.run')\n    @patch('pathlib.Path')\n    @patch('__main__.logger')\n    def test_file_type_empty_string(self, mock_logger, mock_path, mock_run):\n        \"\"\"Test command construction with empty file extension.\"\"\"\n        mock_path.return_value.exists.return_value = True\n        mock_run.return_value.returncode = 0\n        folder = '/test/dir'\n        file_type = ''\n        \n        remove_files(folder, file_type)\n        \n        expected_command = ['rm', os.path.join(folder, '*.' + file_type)]\n        mock_run.assert_called_once_with(expected_command)\n\n    @patch('subprocess.run')\n    @patch('pathlib.Path')\n    @patch('__main__.logger')\n    def test_file_type_special_chars(self, mock_logger, mock_path, mock_run):\n        \"\"\"Test command construction with special characters in file type.\"\"\"\n        mock_path.return_value.exists.return_value = True\n        mock_run.return_value.returncode = 0\n        folder = '/test/dir'\n        file_type = 'tar.gz'\n        \n        remove_files(folder, file_type)\n        \n        expected_command = ['rm', os.path.join(folder, f'*.{file_type}')]\n        mock_run.assert_called_once_with(expected_command)\n\n    @patch('subprocess.run')\n    @patch('pathlib.Path')\n    @patch('__main__.logger')\n    def test_folder_with_spaces(self, mock_logger, mock_path, mock_run):\n        \"\"\"Test command construction with spaces in folder path.\"\"\"\n        mock_path.return_value.exists.return_value = True\n        mock_run.return_value.returncode = 0\n        folder = '/test dir/with space'\n        file_type = 'doc'\n        \n        remove_files(folder, file_type)\n        \n        expected_command = ['rm', os.path.join(folder, f'*.{file_type}')]\n        mock_run.assert_called_once_with(expected_command)\n\n    @patch('subprocess.run')\n    @patch('pathlib.Path')\n    @patch('__main__.logger')\n    def test_empty_folder_string(self, mock_logger, mock_path, mock_run):\n        \"\"\"Test command construction with empty folder string.\"\"\"\n        mock_path.return_value.exists.return_value = True\n        mock_run.return_value.returncode = 0\n        folder = ''\n        file_type = 'png'\n        \n        remove_files(folder, file_type)\n        \n        expected_command = ['rm', os.path.join(folder, f'*.{file_type}')]\n        mock_run.assert_called_once_with(expected_command)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 7, "task_id": "1e5200a4"}
{"test": "import unittest\nfrom unittest.mock import patch, MagicMock\nimport os\nimport subprocess\n\nclass TestPurgeDocuments(unittest.TestCase):\n\n    @patch('solution.logger')\n    @patch('solution.subprocess.run')\n    @patch('solution.Path')\n    def test_folder_exists_deletion_success(self, mock_path, mock_run, mock_logger):\n        \"\"\"Test successful deletion when folder exists and command returns 0.\"\"\"\n        mock_path.return_value.exists.return_value = True\n        mock_run.return_value.returncode = 0\n        \n        folder_path = \"/path/to/dir\"\n        file_extension = \"txt\"\n        expected_cmd = [\"rm\", os.path.join(folder_path, f\"*.{file_extension}\")]\n        \n        purge_documents(folder_path, file_extension)\n        \n        mock_logger.info.assert_any_call(\"Deleting files with extension '%s' in directory '%s'...\", file_extension, folder_path)\n        mock_run.assert_called_once_with(expected_cmd)\n        mock_logger.info.assert_called_with(\"Files deleted successfully.\")\n\n    @patch('solution.logger')\n    @patch('solution.subprocess.run')\n    @patch('solution.Path')\n    def test_folder_exists_deletion_failure(self, mock_path, mock_run, mock_logger):\n        \"\"\"Test error logging when folder exists but command returns non-zero.\"\"\"\n        mock_path.return_value.exists.return_value = True\n        mock_run.return_value.returncode = 1\n        \n        folder_path = \"/path/to/dir\"\n        file_extension = \"txt\"\n        \n        purge_documents(folder_path, file_extension)\n        \n        mock_logger.error.assert_called_with(\"Failed to delete files; command exited with code %d.\", 1)\n\n    @patch('solution.logger')\n    @patch('solution.Path')\n    def test_folder_not_found(self, mock_path, mock_logger):\n        \"\"\"Test FileNotFoundError is raised when directory doesn't exist.\"\"\"\n        mock_path.return_value.exists.return_value = False\n        \n        folder_path = \"/invalid/path\"\n        file_extension = \"txt\"\n        \n        with self.assertRaises(FileNotFoundError):\n            purge_documents(folder_path, file_extension)\n        \n        mock_logger.error.assert_called_with(\"The directory '%s' does not exist.\", folder_path)\n\n    @patch('solution.logger')\n    @patch('solution.subprocess.run')\n    @patch('solution.Path')\n    def test_command_built_correctly(self, mock_path, mock_run, mock_logger):\n        \"\"\"Test command is built with correct arguments.\"\"\"\n        mock_path.return_value.exists.return_value = True\n        mock_run.return_value.returncode = 0\n        \n        folder_path = \"/my/directory\"\n        file_extension = \"pdf\"\n        expected_cmd = [\"rm\", os.path.join(folder_path, f\"*.{file_extension}\")]\n        \n        purge_documents(folder_path, file_extension)\n        \n        mock_run.assert_called_once_with(expected_cmd)\n\n    @patch('solution.logger')\n    @patch('solution.Path')\n    def test_empty_folder_path(self, mock_path, mock_logger):\n        \"\"\"Test empty folder_path raises FileNotFoundError.\"\"\"\n        mock_path.return_value.exists.return_value = False\n        \n        folder_path = \"\"\n        file_extension = \"txt\"\n        \n        with self.assertRaises(FileNotFoundError):\n            purge_documents(folder_path, file_extension)\n        \n        mock_logger.error.assert_called_with(\"The directory '%s' does not exist.\", folder_path)\n\n    @patch('solution.logger')\n    @patch('solution.subprocess.run')\n    @patch('solution.Path')\n    def test_empty_file_extension(self, mock_path, mock_run, mock_logger):\n        \"\"\"Test command built correctly with empty file_extension.\"\"\"\n        mock_path.return_value.exists.return_value = True\n        mock_run.return_value.returncode = 0\n        \n        folder_path = \"/some/dir\"\n        file_extension = \"\"\n        expected_cmd = [\"rm\", os.path.join(folder_path, \"*.\")]\n        \n        purge_documents(folder_path, file_extension)\n        \n        mock_run.assert_called_once_with(expected_cmd)\n\n    @patch('solution.logger')\n    @patch('solution.subprocess.run')\n    @patch('solution.Path')\n    def test_file_extension_with_dot(self, mock_path, mock_run, mock_logger):\n        \"\"\"Test command built correctly when file_extension contains a dot.\"\"\"\n        mock_path.return_value.exists.return_value = True\n        mock_run.return_value.returncode = 0\n        \n        folder_path = \"/another/dir\"\n        file_extension = \".txt\"\n        expected_cmd = [\"rm\", os.path.join(folder_path, \"*..txt\")]\n        \n        purge_documents(folder_path, file_extension)\n        \n        mock_run.assert_called_once_with(expected_cmd)\n", "num_test_cases": 7, "task_id": "2904ff7f"}
{"test": "import unittest\nfrom unittest.mock import patch, MagicMock\nimport os\nimport subprocess\nfrom pathlib import Path\n\nclass TestCases(unittest.TestCase):\n    @patch('subprocess.run')\n    @patch('pathlib.Path.exists')\n    @patch('__main__.logger')\n    def test_case_1(self, mock_logger, mock_exists, mock_run):\n        # Happy path: existing directory, valid extension, command succeeds\n        mock_exists.return_value = True\n        mock_run.return_value = subprocess.CompletedProcess([], 0)\n        \n        erase_files('/test/dir', 'txt')\n        \n        mock_exists.assert_called_once()\n        mock_run.assert_called_once_with(['rm', os.path.join('/test/dir', '*.txt')])\n        mock_logger.info.assert_any_call(\"Deleting files with extension '%s' in directory '%s'...\", 'txt', '/test/dir')\n        mock_logger.info.assert_any_call(\"Running command: %s\", ['rm', os.path.join('/test/dir', '*.txt')])\n        mock_logger.info.assert_any_call(\"Files deleted successfully.\")\n    \n    @patch('subprocess.run')\n    @patch('pathlib.Path.exists')\n    @patch('__main__.logger')\n    def test_case_2(self, mock_logger, mock_exists, mock_run):\n        # Directory does not exist\n        mock_exists.return_value = False\n        \n        with self.assertRaises(FileNotFoundError):\n            erase_files('/nonexistent/dir', 'txt')\n            \n        mock_exists.assert_called_once()\n        mock_run.assert_not_called()\n        mock_logger.error.assert_called_once_with(\"The directory '%s' does not exist.\", '/nonexistent/dir')\n    \n    @patch('subprocess.run')\n    @patch('pathlib.Path.exists')\n    @patch('__main__.logger')\n    def test_case_3(self, mock_logger, mock_exists, mock_run):\n        # Command fails with non-zero exit code\n        mock_exists.return_value = True\n        mock_run.return_value = subprocess.CompletedProcess([], 1)\n        \n        erase_files('/test/dir', 'txt')\n        \n        mock_run.assert_called_once()\n        mock_logger.error.assert_called_once_with(\"Failed to delete files; command exited with code %d.\", 1)\n    \n    @patch('subprocess.run')\n    @patch('pathlib.Path.exists')\n    @patch('__main__.logger')\n    def test_case_4(self, mock_logger, mock_exists, mock_run):\n        # Extension with space\n        mock_exists.return_value = True\n        mock_run.return_value = subprocess.CompletedProcess([], 0)\n        \n        erase_files('/test/dir', 'txt space')\n        \n        mock_run.assert_called_once_with(['rm', os.path.join('/test/dir', '*.txt space')])\n    \n    @patch('subprocess.run')\n    @patch('pathlib.Path.exists')\n    @patch('__main__.logger')\n    def test_case_5(self, mock_logger, mock_exists, mock_run):\n        # Empty extension\n        mock_exists.return_value = True\n        mock_run.return_value = subprocess.CompletedProcess([], 0)\n        \n        erase_files('/test/dir', '')\n        \n        mock_run.assert_called_once_with(['rm', os.path.join('/test/dir', '*.' + '')])\n    \n    @patch('subprocess.run')\n    @patch('pathlib.Path.exists')\n    @patch('__main__.logger')\n    def test_case_6(self, mock_logger, mock_exists, mock_run):\n        # Extension with leading dot\n        mock_exists.return_value = True\n        mock_run.return_value = subprocess.CompletedProcess([], 0)\n        \n        erase_files('/test/dir', '.txt')\n        \n        mock_run.assert_called_once_with(['rm', os.path.join('/test/dir', '*..txt')])\n    \n    @patch('subprocess.run')\n    @patch('pathlib.Path.exists')\n    @patch('__main__.logger')\n    def test_case_7(self, mock_logger, mock_exists, mock_run):\n        # Extension with wildcard\n        mock_exists.return_value = True\n        mock_run.return_value = subprocess.CompletedProcess([], 0)\n        \n        erase_files('/test/dir', 't?t')\n        \n        mock_run.assert_called_once_with(['rm', os.path.join('/test/dir', '*.t?t')])\n    \n    @patch('subprocess.run')\n    @patch('pathlib.Path.exists')\n    @patch('__main__.logger')\n    def test_case_8(self, mock_logger, mock_exists, mock_run):\n        # Empty directory path\n        mock_exists.return_value = True\n        mock_run.return_value = subprocess.CompletedProcess([], 0)\n        \n        erase_files('', 'txt')\n        \n        mock_run.assert_called_once_with(['rm', os.path.join('', '*.txt')])\n    \n    @patch('subprocess.run')\n    @patch('pathlib.Path.exists')\n    @patch('__main__.logger')\n    def test_case_9(self, mock_logger, mock_exists, mock_run):\n        # None for directory path\n        mock_exists.return_value = True\n        \n        with self.assertRaises(TypeError):\n            erase_files(None, 'txt')\n        \n        mock_exists.assert_not_called()\n        mock_run.assert_not_called()\n    \n    @patch('subprocess.run')\n    @patch('pathlib.Path.exists')\n    @patch('__main__.logger')\n    def test_case_10(self, mock_logger, mock_exists, mock_run):\n        # None for file extension\n        mock_exists.return_value = True\n        \n        with self.assertRaises(TypeError):\n            erase_files('/test/dir', None)\n        \n        mock_exists.assert_not_called()\n        mock_run.assert_not_called()\n    \n    @patch('subprocess.run')\n    @patch('pathlib.Path.exists')\n    @patch('__main__.logger')\n    def test_case_11(self, mock_logger, mock_exists, mock_run):\n        # Extension with slash\n        mock_exists.return_value = True\n        mock_run.return_value = subprocess.CompletedProcess([], 0)\n        \n        erase_files('/test/dir', 'ext/path')\n        \n        mock_run.assert_called_once_with(['rm', os.path.join('/test/dir', '*.ext/path')])\n    \n    @patch('subprocess.run')\n    @patch('pathlib.Path.exists')\n    @patch('__main__.logger')\n    def test_case_12(self, mock_logger, mock_exists, mock_run):\n        # Complex extension (tar.gz)\n        mock_exists.return_value = True\n        mock_run.return_value = subprocess.CompletedProcess([], 0)\n        \n        erase_files('/test/dir', 'tar.gz')\n        \n        mock_run.assert_called_once_with(['rm', os.path.join('/test/dir', '*.tar.gz')])\n    \n    @patch('subprocess.run')\n    @patch('pathlib.Path.exists')\n    @patch('__main__.logger')\n    def test_case_13(self, mock_logger, mock_exists, mock_run):\n        # Extension with backslash (simulate Windows path)\n        mock_exists.return_value = True\n        mock_run.return_value = subprocess.CompletedProcess([], 0)\n        \n        erase_files('/test/dir', 'ext\\\\path')\n        \n        mock_run.assert_called_once_with(['rm', os.path.join('/test/dir', '*.ext\\\\path')])\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 13, "task_id": "f13d2fa0"}
{"test": "import unittest\nfrom unittest.mock import patch, MagicMock\nimport tempfile\nimport os\nfrom pathlib import Path\n\n# Import the function from its module (assumed to be available)\nfrom log_utils import archive_logs\n\nclass TestArchiveLogs(unittest.TestCase):\n\n    @patch('log_utils.logger')\n    @patch('subprocess.run')\n    def test_success_with_files(self, mock_run, mock_logger):\n        \"\"\"Test successful backup with non-empty log directory.\"\"\"\n        mock_run.return_value = MagicMock(returncode=0)\n        with tempfile.TemporaryDirectory() as tmpdir:\n            log_dir = os.path.join(tmpdir, 'logs')\n            os.mkdir(log_dir)\n            file_path = os.path.join(log_dir, 'test.log')\n            with open(file_path, 'w') as f:\n                f.write('test')\n            dest_dir = os.path.join(tmpdir, 'backup')\n            os.mkdir(dest_dir)\n            \n            archive_logs(log_dir, dest_dir)\n            \n            mock_run.assert_called_once()\n            cmd = mock_run.call_args[0][0]\n            self.assertEqual(cmd[0], 'zip')\n            self.assertEqual(cmd[1], '-r')\n            self.assertEqual(cmd[2], str(Path(dest_dir) / 'logs_backup.zip'))\n            self.assertEqual(cmd[3], log_dir)\n            mock_logger.info.assert_any_call('Backing up logs...')\n            mock_logger.info.assert_any_call('Running command: %s', cmd)\n            mock_logger.info.assert_any_call('Logs backed up successfully.')\n            mock_logger.error.assert_not_called()\n\n    @patch('log_utils.logger')\n    @patch('subprocess.run')\n    def test_success_empty_log_directory(self, mock_run, mock_logger):\n        \"\"\"Test backup with empty log directory.\"\"\"\n        mock_run.return_value = MagicMock(returncode=0)\n        with tempfile.TemporaryDirectory() as tmpdir:\n            log_dir = os.path.join(tmpdir, 'empty_logs')\n            os.mkdir(log_dir)\n            dest_dir = os.path.join(tmpdir, 'backup')\n            os.mkdir(dest_dir)\n            \n            archive_logs(log_dir, dest_dir)\n            \n            mock_run.assert_called_once()\n            cmd = mock_run.call_args[0][0]\n            self.assertEqual(cmd[0], 'zip')\n            self.assertEqual(cmd[1], '-r')\n            self.assertEqual(cmd[2], str(Path(dest_dir) / 'logs_backup.zip'))\n            self.assertEqual(cmd[3], log_dir)\n            mock_logger.info.assert_any_call('Logs backed up successfully.')\n            mock_logger.error.assert_not_called()\n\n    @patch('log_utils.logger')\n    @patch('subprocess.run')\n    def test_log_directory_not_exist(self, mock_run, mock_logger):\n        \"\"\"Test when log directory does not exist.\"\"\"\n        with tempfile.TemporaryDirectory() as tmpdir:\n            log_dir = os.path.join(tmpdir, 'non_existent_logs')\n            dest_dir = os.path.join(tmpdir, 'backup')\n            os.mkdir(dest_dir)\n            \n            archive_logs(log_dir, dest_dir)\n            \n            mock_run.assert_not_called()\n            expected_error = 'Logs directory \\'{}\\' does not exist.'.format(log_dir)\n            mock_logger.error.assert_called_once_with(expected_error)\n\n    @patch('log_utils.logger')\n    @patch('subprocess.run')\n    def test_destination_directory_not_exist(self, mock_run, mock_logger):\n        \"\"\"Test when destination directory does not exist.\"\"\"\n        with tempfile.TemporaryDirectory() as tmpdir:\n            log_dir = os.path.join(tmpdir, 'logs')\n            os.mkdir(log_dir)\n            dest_dir = os.path.join(tmpdir, 'non_existent_backup')\n            \n            archive_logs(log_dir, dest_dir)\n            \n            mock_run.assert_not_called()\n            expected_error = 'Backup directory \\'{}\\' does not exist.'.format(dest_dir)\n            mock_logger.error.assert_called_once_with(expected_error)\n\n    @patch('log_utils.logger')\n    @patch('subprocess.run')\n    def test_zip_command_failure(self, mock_run, mock_logger):\n        \"\"\"Test when the zip command fails.\"\"\"\n        mock_run.return_value = MagicMock(returncode=1)\n        with tempfile.TemporaryDirectory() as tmpdir:\n            log_dir = os.path.join(tmpdir, 'logs')\n            os.mkdir(log_dir)\n            dest_dir = os.path.join(tmpdir, 'backup')\n            os.mkdir(dest_dir)\n            \n            archive_logs(log_dir, dest_dir)\n            \n            mock_run.assert_called_once()\n            cmd = mock_run.call_args[0][0]\n            mock_logger.info.assert_any_call('Backing up logs...')\n            mock_logger.info.assert_any_call('Running command: %s', cmd)\n            mock_logger.error.assert_called_once_with('Failed to back up logs; command exited with code %d.', 1)\n", "num_test_cases": 5, "task_id": "1d3c745b"}
{"test": "import unittest\nfrom unittest.mock import patch, MagicMock\nfrom pathlib import Path\nfrom solution import compress_logs\n\nclass TestCompressLogs(unittest.TestCase):\n\n    # Test Case 1: Happy path with valid directories and successful zip command\n    @patch('solution.subprocess.run')\n    @patch('solution.os.path.isdir')\n    @patch('solution.logger')\n    def test_happy_path_success(self, mock_logger, mock_isdir, mock_run):\n        \"\"\"Test successful log backup with valid source and save directories.\"\"\"\n        source_dir = \"/var/log\"\n        save_dir = \"/backup\"\n        expected_save_path = str(Path(save_dir) / \"logs_backup.zip\")\n        expected_command = ['zip', '-r', expected_save_path, source_dir]\n        \n        mock_isdir.side_effect = [True, True]\n        mock_run.return_value = MagicMock(returncode=0)\n        \n        compress_logs(source_dir, save_dir)\n        \n        mock_logger.info.assert_any_call(\"Backing up logs...\")\n        mock_logger.info.assert_any_call(\"Running command: %s\", expected_command)\n        mock_logger.info.assert_any_call(\"Logs backed up successfully.\")\n        mock_logger.error.assert_not_called()\n        mock_run.assert_called_once_with(expected_command)\n\n    # Test Case 2: Source directory does not exist\n    @patch('solution.subprocess.run')\n    @patch('solution.os.path.isdir')\n    @patch('solution.logger')\n    def test_source_dir_not_exist(self, mock_logger, mock_isdir, mock_run):\n        \"\"\"Test error when source directory does not exist.\"\"\"\n        source_dir = \"/non/existent/logs\"\n        save_dir = \"/backup\"\n        \n        mock_isdir.side_effect = [False]\n        \n        compress_logs(source_dir, save_dir)\n        \n        mock_logger.info.assert_any_call(\"Backing up logs...\")\n        mock_logger.error.assert_any_call(\"Logs directory '%s' does not exist.\", source_dir)\n        self.assertEqual(mock_logger.info.call_count, 1)  # Only initial info call\n        mock_run.assert_not_called()\n\n    # Test Case 3: Save directory does not exist\n    @patch('solution.subprocess.run')\n    @patch('solution.os.path.isdir')\n    @patch('solution.logger')\n    def test_save_dir_not_exist(self, mock_logger, mock_isdir, mock_run):\n        \"\"\"Test error when save directory does not exist.\"\"\"\n        source_dir = \"/var/log\"\n        save_dir = \"/invalid/backup\"\n        \n        mock_isdir.side_effect = [True, False]\n        \n        compress_logs(source_dir, save_dir)\n        \n        mock_logger.info.assert_any_call(\"Backing up logs...\")\n        mock_logger.error.assert_any_call(\"Backup directory '%s' does not exist.\", save_dir)\n        self.assertEqual(mock_logger.info.call_count, 1)  # Only initial info call\n        mock_run.assert_not_called()\n\n    # Test Case 4: Zip command fails with non-zero exit code\n    @patch('solution.subprocess.run')\n    @patch('solution.os.path.isdir')\n    @patch('solution.logger')\n    def test_zip_command_failure(self, mock_logger, mock_isdir, mock_run):\n        \"\"\"Test error handling when zip command fails.\"\"\"\n        source_dir = \"/var/log\"\n        save_dir = \"/backup\"\n        expected_save_path = str(Path(save_dir) / \"logs_backup.zip\")\n        expected_command = ['zip', '-r', expected_save_path, source_dir]\n        \n        mock_isdir.side_effect = [True, True]\n        mock_run.return_value = MagicMock(returncode=1)\n        \n        compress_logs(source_dir, save_dir)\n        \n        mock_logger.info.assert_any_call(\"Backing up logs...\")\n        mock_logger.info.assert_any_call(\"Running command: %s\", expected_command)\n        mock_logger.error.assert_any_call(\"Failed to back up logs; command exited with code %d.\", 1)\n        mock_run.assert_called_once_with(expected_command)\n\n    # Test Case 5: Trailing slash in save directory path\n    @patch('solution.subprocess.run')\n    @patch('solution.os.path.isdir')\n    @patch('solution.logger')\n    def test_save_dir_trailing_slash(self, mock_logger, mock_isdir, mock_run):\n        \"\"\"Test path normalization with trailing slash in save directory.\"\"\"\n        source_dir = \"/var/log\"\n        save_dir = \"/backup/\"  # Trailing slash\n        expected_save_path = str(Path(save_dir) / \"logs_backup.zip\")  # Normalizes path\n        expected_command = ['zip', '-r', expected_save_path, source_dir]\n        \n        mock_isdir.side_effect = [True, True]\n        mock_run.return_value = MagicMock(returncode=0)\n        \n        compress_logs(source_dir, save_dir)\n        \n        mock_run.assert_called_once_with(expected_command)\n        mock_logger.info.assert_any_call(\"Running command: %s\", expected_command)\n\n    # Test Case 6: Empty source directory string\n    @patch('solution.subprocess.run')\n    @patch('solution.os.path.isdir')\n    @patch('solution.logger')\n    def test_empty_source_dir(self, mock_logger, mock_isdir, mock_run):\n        \"\"\"Test error when source directory is an empty string.\"\"\"\n        source_dir = \"\"\n        save_dir = \"/backup\"\n        \n        mock_isdir.side_effect = [False]\n        \n        compress_logs(source_dir, save_dir)\n        \n        mock_logger.error.assert_any_call(\"Logs directory '%s' does not exist.\", source_dir)\n        mock_run.assert_not_called()\n\n    # Test Case 7: Empty save directory string\n    @patch('solution.subprocess.run')\n    @patch('solution.os.path.isdir')\n    @patch('solution.logger')\n    def test_empty_save_dir(self, mock_logger, mock_isdir, mock_run):\n        \"\"\"Test error when save directory is an empty string.\"\"\"\n        source_dir = \"/var/log\"\n        save_dir = \"\"\n        \n        mock_isdir.side_effect = [True, False]\n        \n        compress_logs(source_dir, save_dir)\n        \n        mock_logger.error.assert_any_call(\"Backup directory '%s' does not exist.\", save_dir)\n        mock_run.assert_not_called()\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 7, "task_id": "58f4a42e"}
{"test": "import unittest\nimport os\nimport subprocess\nfrom unittest.mock import patch, MagicMock\n\nclass TestSaveLogs(unittest.TestCase):\n    @patch('subprocess.run')\n    @patch('os.path.isdir')\n    def test_happy_path(self, mock_isdir, mock_run):\n        \"\"\"Test successful backup when both directories exist and zip command succeeds.\"\"\"\n        with patch(f\"{save_logs.__module__}.logger\") as mock_logger:\n            mock_isdir.side_effect = [True, True]\n            mock_run.return_value = subprocess.CompletedProcess([], 0)\n            log_folder = '/path/to/logs'\n            output_folder = '/path/to/backup'\n            expected_archive = os.path.join(output_folder, 'logs_backup.zip')\n            \n            save_logs(log_folder, output_folder)\n            \n            mock_logger.info.assert_any_call('Backing up logs...')\n            mock_logger.info.assert_any_call('Running command: %s', ['zip', '-r', expected_archive, log_folder])\n            mock_logger.info.assert_any_call('Logs backed up successfully.')\n            mock_logger.error.assert_not_called()\n            mock_run.assert_called_once_with(['zip', '-r', expected_archive, log_folder])\n\n    @patch('subprocess.run')\n    @patch('os.path.isdir')\n    def test_log_folder_not_exist(self, mock_isdir, mock_run):\n        \"\"\"Test error when log directory does not exist.\"\"\"\n        with patch(f\"{save_logs.__module__}.logger\") as mock_logger:\n            mock_isdir.side_effect = [False]\n            log_folder = '/invalid/logs'\n            output_folder = '/path/to/backup'\n            expected_error = 'Logs directory \\'{}\\' does not exist.'.format(log_folder)\n            \n            save_logs(log_folder, output_folder)\n            \n            mock_logger.info.assert_called_once_with('Backing up logs...')\n            mock_logger.error.assert_called_once_with(expected_error)\n            mock_run.assert_not_called()\n\n    @patch('subprocess.run')\n    @patch('os.path.isdir')\n    def test_output_folder_not_exist(self, mock_isdir, mock_run):\n        \"\"\"Test error when backup directory does not exist.\"\"\"\n        with patch(f\"{save_logs.__module__}.logger\") as mock_logger:\n            mock_isdir.side_effect = [True, False]\n            log_folder = '/path/to/logs'\n            output_folder = '/invalid/backup'\n            expected_error = 'Backup directory \\'{}\\' does not exist.'.format(output_folder)\n            \n            save_logs(log_folder, output_folder)\n            \n            mock_logger.info.assert_called_once_with('Backing up logs...')\n            mock_logger.error.assert_called_once_with(expected_error)\n            mock_run.assert_not_called()\n\n    @patch('subprocess.run')\n    @patch('os.path.isdir')\n    def test_zip_command_fails(self, mock_isdir, mock_run):\n        \"\"\"Test error handling when zip command returns non-zero exit code.\"\"\"\n        with patch(f\"{save_logs.__module__}.logger\") as mock_logger:\n            mock_isdir.side_effect = [True, True]\n            mock_run.return_value = subprocess.CompletedProcess([], 1)\n            log_folder = '/path/to/logs'\n            output_folder = '/path/to/backup'\n            expected_archive = os.path.join(output_folder, 'logs_backup.zip')\n            \n            save_logs(log_folder, output_folder)\n            \n            mock_logger.info.assert_any_call('Backing up logs...')\n            mock_logger.info.assert_any_call('Running command: %s', ['zip', '-r', expected_archive, log_folder])\n            mock_logger.error.assert_called_once_with('Failed to back up logs; command exited with code %d.', 1)\n            mock_run.assert_called_once_with(['zip', '-r', expected_archive, log_folder])\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 4, "task_id": "7c66a192"}
{"test": "import unittest\nfrom unittest.mock import patch, MagicMock\nimport os\nfrom pathlib import Path\n\n# Import the function from the module (assumed to be named 'solution')\nfrom solution import archive_logs\n\nclass TestArchiveLogs(unittest.TestCase):\n\n    @patch('solution.logger')\n    @patch('subprocess.run')\n    @patch('os.path.isdir')\n    def test_happy_path(self, mock_isdir, mock_run, mock_logger):\n        \"\"\"Test successful archiving with valid directories and successful zip command.\"\"\"\n        mock_isdir.side_effect = [True, True]\n        mock_run.return_value = MagicMock(returncode=0)\n        \n        logs_folder = '/path/to/logs'\n        archive_dir = '/path/to/backup'\n        result = archive_logs(logs_folder, archive_dir)\n        \n        self.assertIsNone(result)\n        mock_logger.info.assert_any_call('Archiving logs...')\n        expected_archive_path = str(Path(archive_dir) / 'logs_archive.zip')\n        expected_command = ['zip', '-r', expected_archive_path, logs_folder]\n        mock_run.assert_called_once_with(expected_command)\n        mock_logger.info.assert_any_call('Running command: %s', expected_command)\n        mock_logger.info.assert_any_call('Logs archived successfully.')\n        mock_logger.error.assert_not_called()\n\n    @patch('solution.logger')\n    @patch('subprocess.run')\n    @patch('os.path.isdir')\n    def test_logs_folder_not_exist(self, mock_isdir, mock_run, mock_logger):\n        \"\"\"Test when logs directory does not exist.\"\"\"\n        mock_isdir.return_value = False  # Only first call returns False\n        \n        logs_folder = '/path/to/logs'\n        archive_dir = '/path/to/backup'\n        result = archive_logs(logs_folder, archive_dir)\n        \n        self.assertIsNone(result)\n        mock_logger.info.assert_called_with('Archiving logs...')\n        expected_error = 'Logs directory \\'{}\\' does not exist.'.format(logs_folder)\n        mock_logger.error.assert_called_with(expected_error)\n        mock_run.assert_not_called()\n\n    @patch('solution.logger')\n    @patch('subprocess.run')\n    @patch('os.path.isdir')\n    def test_archive_dir_not_exist(self, mock_isdir, mock_run, mock_logger):\n        \"\"\"Test when backup directory does not exist.\"\"\"\n        mock_isdir.side_effect = [True, False]\n        \n        logs_folder = '/path/to/logs'\n        archive_dir = '/path/to/backup'\n        result = archive_logs(logs_folder, archive_dir)\n        \n        self.assertIsNone(result)\n        mock_logger.info.assert_called_with('Archiving logs...')\n        expected_error = 'Backup directory \\'{}\\' does not exist.'.format(archive_dir)\n        mock_logger.error.assert_called_with(expected_error)\n        mock_run.assert_not_called()\n\n    @patch('solution.logger')\n    @patch('subprocess.run')\n    @patch('os.path.isdir')\n    def test_zip_command_fails(self, mock_isdir, mock_run, mock_logger):\n        \"\"\"Test when the zip command fails with non-zero exit code.\"\"\"\n        mock_isdir.side_effect = [True, True]\n        mock_run.return_value = MagicMock(returncode=1)\n        \n        logs_folder = '/path/to/logs'\n        archive_dir = '/path/to/backup'\n        result = archive_logs(logs_folder, archive_dir)\n        \n        self.assertIsNone(result)\n        mock_run.assert_called_once()\n        mock_logger.error.assert_called_with('Failed to archive logs; command exited with code %d.', 1)\n\n    @patch('solution.logger')\n    @patch('subprocess.run')\n    @patch('os.path.isdir')\n    def test_long_paths(self, mock_isdir, mock_run, mock_logger):\n        \"\"\"Test with very long paths for logs and backup directories.\"\"\"\n        mock_isdir.side_effect = [True, True]\n        mock_run.return_value = MagicMock(returncode=0)\n        \n        long_logs_folder = '/a' * 500\n        long_archive_dir = '/b' * 500\n        result = archive_logs(long_logs_folder, long_archive_dir)\n        \n        self.assertIsNone(result)\n        expected_archive_path = str(Path(long_archive_dir) / 'logs_archive.zip')\n        expected_command = ['zip', '-r', expected_archive_path, long_logs_folder]\n        mock_run.assert_called_once_with(expected_command)\n        mock_logger.info.assert_any_call('Running command: %s', expected_command)\n\n    @patch('solution.logger')\n    @patch('subprocess.run')\n    @patch('os.path.isdir')\n    def test_relative_paths(self, mock_isdir, mock_run, mock_logger):\n        \"\"\"Test with relative paths for logs and backup directories.\"\"\"\n        mock_isdir.side_effect = [True, True]\n        mock_run.return_value = MagicMock(returncode=0)\n        \n        logs_folder = 'relative/logs'\n        archive_dir = 'relative/backup'\n        result = archive_logs(logs_folder, archive_dir)\n        \n        self.assertIsNone(result)\n        expected_archive_path = str(Path(archive_dir) / 'logs_archive.zip')\n        expected_command = ['zip', '-r', expected_archive_path, logs_folder]\n        mock_run.assert_called_once_with(expected_command)\n        mock_logger.info.assert_any_call('Running command: %s', expected_command)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 6, "task_id": "15fea880"}
{"test": "import unittest\nfrom unittest.mock import patch, MagicMock\nimport os\nimport subprocess\nfrom solution import compress_logs\n\nclass TestCompressLogs(unittest.TestCase):\n\n    def test_happy_path(self):\n        \"\"\"Test successful compression with valid directories.\"\"\"\n        with patch('solution.logger') as mock_logger, \\\n             patch('os.path.isdir') as mock_isdir, \\\n             patch('subprocess.run') as mock_run:\n            \n            mock_isdir.side_effect = [True, True]\n            mock_run.return_value = subprocess.CompletedProcess([], 0)\n            logs_dir = '/valid/logs'\n            dest_dir = '/valid/backup'\n            \n            compress_logs(logs_dir, dest_dir)\n            \n            expected_target = os.path.join(dest_dir, 'logs_backup.zip')\n            expected_command = ['zip', '-r', expected_target, logs_dir]\n            \n            mock_logger.info.assert_any_call('Compressing logs...')\n            mock_logger.info.assert_any_call('Running command: %s', expected_command)\n            mock_run.assert_called_once_with(expected_command)\n            mock_logger.info.assert_any_call('Logs compressed successfully.')\n            mock_logger.error.assert_not_called()\n\n    def test_logs_directory_non_existent(self):\n        \"\"\"Test when logs directory does not exist (non-empty string).\"\"\"\n        with patch('solution.logger') as mock_logger, \\\n             patch('os.path.isdir') as mock_isdir, \\\n             patch('subprocess.run') as mock_run:\n            \n            mock_isdir.side_effect = [False, True]\n            logs_dir = '/non/existent/logs'\n            dest_dir = '/valid/backup'\n            \n            compress_logs(logs_dir, dest_dir)\n            \n            mock_logger.info.assert_called_once_with('Compressing logs...')\n            mock_logger.error.assert_called_once_with(f'Logs directory \\'{logs_dir}\\' does not exist.')\n            mock_run.assert_not_called()\n\n    def test_destination_directory_non_existent(self):\n        \"\"\"Test when destination directory does not exist (non-empty string).\"\"\"\n        with patch('solution.logger') as mock_logger, \\\n             patch('os.path.isdir') as mock_isdir, \\\n             patch('subprocess.run') as mock_run:\n            \n            mock_isdir.side_effect = [True, False]\n            logs_dir = '/valid/logs'\n            dest_dir = '/non/existent/backup'\n            \n            compress_logs(logs_dir, dest_dir)\n            \n            mock_logger.info.assert_called_once_with('Compressing logs...')\n            mock_logger.error.assert_called_once_with(f'Backup directory \\'{dest_dir}\\' does not exist.')\n            mock_run.assert_not_called()\n\n    def test_zip_command_failure(self):\n        \"\"\"Test when the zip command returns a non-zero exit code.\"\"\"\n        with patch('solution.logger') as mock_logger, \\\n             patch('os.path.isdir') as mock_isdir, \\\n             patch('subprocess.run') as mock_run:\n            \n            mock_isdir.side_effect = [True, True]\n            mock_run.return_value = subprocess.CompletedProcess([], 1)\n            logs_dir = '/valid/logs'\n            dest_dir = '/valid/backup'\n            \n            compress_logs(logs_dir, dest_dir)\n            \n            mock_logger.info.assert_any_call('Compressing logs...')\n            expected_command = ['zip', '-r', os.path.join(dest_dir, 'logs_backup.zip'), logs_dir]\n            mock_logger.info.assert_any_call('Running command: %s', expected_command)\n            mock_logger.error.assert_called_once_with('Failed to compress logs; command exited with code %d.', 1)\n\n    def test_logs_directory_empty_string(self):\n        \"\"\"Test when logs directory is an empty string.\"\"\"\n        with patch('solution.logger') as mock_logger, \\\n             patch('os.path.isdir') as mock_isdir, \\\n             patch('subprocess.run') as mock_run:\n            \n            mock_isdir.return_value = False\n            logs_dir = ''\n            dest_dir = '/valid/backup'\n            \n            compress_logs(logs_dir, dest_dir)\n            \n            mock_logger.info.assert_called_once_with('Compressing logs...')\n            mock_logger.error.assert_called_once_with('Logs directory \\'\\' does not exist.')\n            mock_run.assert_not_called()\n\n    def test_destination_directory_empty_string(self):\n        \"\"\"Test when destination directory is an empty string.\"\"\"\n        with patch('solution.logger') as mock_logger, \\\n             patch('os.path.isdir') as mock_isdir, \\\n             patch('subprocess.run') as mock_run:\n            \n            mock_isdir.side_effect = [True, False]\n            logs_dir = '/valid/logs'\n            dest_dir = ''\n            \n            compress_logs(logs_dir, dest_dir)\n            \n            mock_logger.info.assert_called_once_with('Compressing logs...')\n            mock_logger.error.assert_called_once_with('Backup directory \\'\\' does not exist.')\n            mock_run.assert_not_called()\n\n    def test_directories_with_spaces(self):\n        \"\"\"Test paths containing spaces are handled correctly.\"\"\"\n        with patch('solution.logger') as mock_logger, \\\n             patch('os.path.isdir') as mock_isdir, \\\n             patch('subprocess.run') as mock_run:\n            \n            mock_isdir.side_effect = [True, True]\n            mock_run.return_value = subprocess.CompletedProcess([], 0)\n            logs_dir = '/path/with space/logs'\n            dest_dir = '/path/with space/backup'\n            \n            compress_logs(logs_dir, dest_dir)\n            \n            expected_target = os.path.join(dest_dir, 'logs_backup.zip')\n            expected_command = ['zip', '-r', expected_target, logs_dir]\n            mock_run.assert_called_once_with(expected_command)\n\n    def test_relative_paths(self):\n        \"\"\"Test relative paths are handled correctly.\"\"\"\n        with patch('solution.logger') as mock_logger, \\\n             patch('os.path.isdir') as mock_isdir, \\\n             patch('subprocess.run') as mock_run:\n            \n            mock_isdir.side_effect = [True, True]\n            mock_run.return_value = subprocess.CompletedProcess([], 0)\n            logs_dir = 'relative/logs'\n            dest_dir = 'relative/backup'\n            \n            compress_logs(logs_dir, dest_dir)\n            \n            expected_target = os.path.join(dest_dir, 'logs_backup.zip')\n            expected_command = ['zip', '-r', expected_target, logs_dir]\n            mock_run.assert_called_once_with(expected_command)\n\n    def test_long_paths(self):\n        \"\"\"Test very long directory paths are handled correctly.\"\"\"\n        with patch('solution.logger') as mock_logger, \\\n             patch('os.path.isdir') as mock_isdir, \\\n             patch('subprocess.run') as mock_run:\n            \n            mock_isdir.side_effect = [True, True]\n            mock_run.return_value = subprocess.CompletedProcess([], 0)\n            long_str = 'a' * 1000\n            logs_dir = long_str\n            dest_dir = long_str\n            \n            compress_logs(logs_dir, dest_dir)\n            \n            expected_target = os.path.join(dest_dir, 'logs_backup.zip')\n            expected_command = ['zip', '-r', expected_target, logs_dir]\n            mock_run.assert_called_once_with(expected_command)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 9, "task_id": "dc4e3bf2"}
{"test": "import unittest\nfrom unittest.mock import patch, MagicMock\nfrom pathlib import Path\nfrom solution import store_logs\n\nclass TestStoreLogs(unittest.TestCase):\n    @patch('solution.subprocess.run')\n    @patch('solution.os.path.isdir')\n    @patch('solution.logger')\n    def test_absolute_paths_success(self, mock_logger, mock_isdir, mock_run):\n        # Test with absolute paths and successful zip command\n        mock_isdir.side_effect = [True, True]\n        mock_run.return_value = MagicMock(returncode=0)\n        source = '/var/log/app'\n        target = '/backup'\n        store_logs(source, target)\n        mock_logger.info.assert_any_call(\"Storing logs...\")\n        expected_backup = str(Path(target) / \"logs_storage.zip\")\n        expected_command = [\"zip\", \"-r\", expected_backup, source]\n        mock_logger.info.assert_any_call(\"Running command: %s\", expected_command)\n        mock_run.assert_called_with(expected_command)\n        mock_logger.info.assert_any_call(\"Logs stored successfully.\")\n        mock_logger.error.assert_not_called()\n\n    @patch('solution.subprocess.run')\n    @patch('solution.os.path.isdir')\n    @patch('solution.logger')\n    def test_relative_paths_success(self, mock_logger, mock_isdir, mock_run):\n        # Test with relative paths and successful zip command\n        mock_isdir.side_effect = [True, True]\n        mock_run.return_value = MagicMock(returncode=0)\n        source = '../logs'\n        target = './backup'\n        store_logs(source, target)\n        expected_backup = str(Path(target) / \"logs_storage.zip\")\n        expected_command = [\"zip\", \"-r\", expected_backup, source]\n        mock_run.assert_called_with(expected_command)\n        mock_logger.info.assert_any_call(\"Running command: %s\", expected_command)\n\n    @patch('solution.subprocess.run')\n    @patch('solution.os.path.isdir')\n    @patch('solution.logger')\n    def test_source_not_exist(self, mock_logger, mock_isdir, mock_run):\n        # Test when source directory does not exist\n        mock_isdir.side_effect = [False, True]\n        source = '/var/log/app'\n        target = '/backup'\n        store_logs(source, target)\n        mock_logger.error.assert_called_with(f\"Logs directory '{source}' does not exist.\")\n        mock_run.assert_not_called()\n\n    @patch('solution.subprocess.run')\n    @patch('solution.os.path.isdir')\n    @patch('solution.logger')\n    def test_target_not_exist(self, mock_logger, mock_isdir, mock_run):\n        # Test when target directory does not exist\n        mock_isdir.side_effect = [True, False]\n        source = '/var/log/app'\n        target = '/backup'\n        store_logs(source, target)\n        mock_logger.error.assert_called_with(f\"Backup directory '{target}' does not exist.\")\n        mock_run.assert_not_called()\n\n    @patch('solution.subprocess.run')\n    @patch('solution.os.path.isdir')\n    @patch('solution.logger')\n    def test_zip_failure(self, mock_logger, mock_isdir, mock_run):\n        # Test when zip command fails (non-zero exit code)\n        mock_isdir.side_effect = [True, True]\n        mock_run.return_value = MagicMock(returncode=1)\n        source = '/var/log/app'\n        target = '/backup'\n        store_logs(source, target)\n        mock_logger.error.assert_called_with(\"Failed to store logs; command exited with code %d.\", 1)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 5, "task_id": "4e4bc7b4"}
{"test": "import unittest\nimport os\nfrom unittest.mock import patch, MagicMock\n\nclass TestArchiveLogs(unittest.TestCase):\n    @patch('solution.logger')\n    @patch('subprocess.run')\n    def test_happy_path(self, mock_run, mock_logger):\n        # Test with valid directories and successful zip command\n        logs_dir = \"/path/to/logs\"\n        backup_dir = \"/path/to/backup\"\n        expected_backup_path = os.path.normpath(os.path.join(backup_dir, \"logs_backup.zip\"))\n        \n        with patch('os.path.isdir', side_effect=[True, True]):\n            mock_run.return_value = MagicMock(returncode=0)\n            \n            # Import inside the test to ensure proper patching\n            from solution import archive_logs\n            archive_logs(logs_dir, backup_dir)\n            \n            # Verify logger calls\n            mock_logger.info.assert_any_call(\"Backing up logs...\")\n            mock_logger.info.assert_any_call(\"Running command: %s\", [\"zip\", \"-r\", expected_backup_path, logs_dir])\n            mock_logger.info.assert_any_call(\"Logs backed up successfully.\")\n            \n            # Verify command execution\n            mock_run.assert_called_once_with([\"zip\", \"-r\", expected_backup_path, logs_dir])\n\n    @patch('solution.logger')\n    @patch('subprocess.run')\n    def test_logs_directory_not_exist(self, mock_run, mock_logger):\n        # Test when logs directory does not exist\n        logs_dir = \"/invalid/logs\"\n        backup_dir = \"/valid/backup\"\n        \n        with patch('os.path.isdir', return_value=False):\n            # Import inside the test\n            from solution import archive_logs\n            archive_logs(logs_dir, backup_dir)\n            \n            # Verify error logging and no command execution\n            mock_logger.error.assert_called_once_with(f\"Logs directory '{logs_dir}' does not exist.\")\n            mock_run.assert_not_called()\n\n    @patch('solution.logger')\n    @patch('subprocess.run')\n    def test_backup_directory_not_exist(self, mock_run, mock_logger):\n        # Test when backup directory does not exist\n        logs_dir = \"/valid/logs\"\n        backup_dir = \"/invalid/backup\"\n        \n        with patch('os.path.isdir', side_effect=[True, False]):\n            # Import inside the test\n            from solution import archive_logs\n            archive_logs(logs_dir, backup_dir)\n            \n            # Verify error logging and no command execution\n            mock_logger.error.assert_called_once_with(f\"Backup directory '{backup_dir}' does not exist.\")\n            mock_run.assert_not_called()\n\n    @patch('solution.logger')\n    @patch('subprocess.run')\n    def test_zip_command_failure(self, mock_run, mock_logger):\n        # Test when zip command returns non-zero exit code\n        logs_dir = \"/path/to/logs\"\n        backup_dir = \"/path/to/backup\"\n        \n        with patch('os.path.isdir', side_effect=[True, True]):\n            mock_run.return_value = MagicMock(returncode=1)\n            \n            # Import inside the test\n            from solution import archive_logs\n            archive_logs(logs_dir, backup_dir)\n            \n            # Verify error logging\n            mock_logger.error.assert_called_once_with(\"Failed to back up logs; command exited with code %d.\", 1)\n\n    @patch('solution.logger')\n    @patch('subprocess.run')\n    def test_non_string_logs_directory(self, mock_run, mock_logger):\n        # Test with non-string logs_directory\n        with self.assertRaises(TypeError):\n            # Import inside the test\n            from solution import archive_logs\n            archive_logs(123, \"/valid/backup\")\n\n    @patch('solution.logger')\n    @patch('subprocess.run')\n    def test_non_string_backup_directory(self, mock_run, mock_logger):\n        # Test with non-string backup_directory\n        with self.assertRaises(TypeError):\n            # Import inside the test\n            from solution import archive_logs\n            archive_logs(\"/valid/logs\", 456)\n\n    @patch('solution.logger')\n    @patch('subprocess.run')\n    def test_command_building(self, mock_run, mock_logger):\n        # Test command building with normalized paths\n        logs_dir = \"/path/with/../logs\"\n        backup_dir = \"/path/to/backup\"\n        normalized_logs = os.path.normpath(logs_dir)\n        expected_backup_path = os.path.normpath(os.path.join(backup_dir, \"logs_backup.zip\"))\n        \n        with patch('os.path.isdir', side_effect=[True, True]):\n            mock_run.return_value = MagicMock(returncode=0)\n            \n            # Import inside the test\n            from solution import archive_logs\n            archive_logs(logs_dir, backup_dir)\n            \n            # Verify command uses normalized paths\n            args, _ = mock_run.call_args\n            actual_command = args[0]\n            self.assertEqual(actual_command[2], expected_backup_path)\n            self.assertEqual(actual_command[3], normalized_logs)\n", "num_test_cases": 7, "task_id": "ecdf68b8"}
{"test": "import unittest\nfrom unittest.mock import patch, MagicMock, call\n\nclass TestSaveLogs(unittest.TestCase):\n\n    @patch('solution.logger')\n    @patch('solution.subprocess.run')\n    @patch('solution.os.path.isdir')\n    def test_success(self, mock_isdir, mock_run, mock_logger):\n        \"\"\"Test successful backup with valid directories and successful command execution.\"\"\"\n        mock_isdir.side_effect = [True, True]\n        mock_run.return_value = MagicMock(returncode=0)\n        save_logs('/path/to/logs', '/path/to/backup')\n        mock_logger.info.assert_any_call(\"Backing up logs...\")\n        expected_command = [\"zip\", \"-r\", \"/path/to/backup/logs_backup.zip\", \"/path/to/logs\"]\n        mock_run.assert_called_once_with(expected_command)\n        mock_logger.info.assert_any_call(\"Running command: %s\", expected_command)\n        mock_logger.info.assert_any_call(\"Logs backed up successfully.\")\n\n    @patch('solution.logger')\n    @patch('solution.subprocess.run')\n    @patch('solution.os.path.isdir')\n    def test_logs_folder_not_exist(self, mock_isdir, mock_run, mock_logger):\n        \"\"\"Test error when logs directory does not exist.\"\"\"\n        mock_isdir.side_effect = [False, True]\n        save_logs('/path/to/logs', '/path/to/backup')\n        mock_logger.info.assert_any_call(\"Backing up logs...\")\n        mock_logger.error.assert_called_once_with(\"Logs directory '/path/to/logs' does not exist.\")\n        mock_run.assert_not_called()\n\n    @patch('solution.logger')\n    @patch('solution.subprocess.run')\n    @patch('solution.os.path.isdir')\n    def test_backup_folder_not_exist(self, mock_isdir, mock_run, mock_logger):\n        \"\"\"Test error when backup directory does not exist.\"\"\"\n        mock_isdir.side_effect = [True, False]\n        save_logs('/path/to/logs', '/path/to/backup')\n        mock_logger.info.assert_any_call(\"Backing up logs...\")\n        mock_logger.error.assert_called_once_with(\"Backup directory '/path/to/backup' does not exist.\")\n        mock_run.assert_not_called()\n\n    @patch('solution.logger')\n    @patch('solution.subprocess.run')\n    @patch('solution.os.path.isdir')\n    def test_zip_command_fails(self, mock_isdir, mock_run, mock_logger):\n        \"\"\"Test error when the zip command fails with non-zero exit code.\"\"\"\n        mock_isdir.side_effect = [True, True]\n        mock_run.return_value = MagicMock(returncode=1)\n        save_logs('/path/to/logs', '/path/to/backup')\n        mock_logger.info.assert_any_call(\"Backing up logs...\")\n        mock_run.assert_called_once()\n        mock_logger.error.assert_called_once_with(\"Failed to back up logs; command exited with code %d.\", 1)\n\n    @patch('solution.logger')\n    @patch('solution.subprocess.run')\n    @patch('solution.os.path.isdir')\n    def test_logs_folder_none(self, mock_isdir, mock_run, mock_logger):\n        \"\"\"Test TypeError when logs_folder is None.\"\"\"\n        with self.assertRaises(TypeError):\n            save_logs(None, '/path/to/backup')\n        mock_logger.info.assert_called_once_with(\"Backing up logs...\")\n        mock_isdir.assert_not_called()\n        mock_run.assert_not_called()\n\n    @patch('solution.logger')\n    @patch('solution.subprocess.run')\n    @patch('solution.os.path.isdir')\n    def test_backup_folder_none(self, mock_isdir, mock_run, mock_logger):\n        \"\"\"Test TypeError when backup_folder is None.\"\"\"\n        mock_isdir.return_value = True\n        with self.assertRaises(TypeError):\n            save_logs('/path/to/logs', None)\n        mock_logger.info.assert_called_once_with(\"Backing up logs...\")\n        mock_isdir.assert_called_once_with('/path/to/logs')\n        mock_run.assert_not_called()\n\n    @patch('solution.logger')\n    @patch('solution.subprocess.run')\n    @patch('solution.os.path.isdir')\n    def test_logs_folder_empty_string(self, mock_isdir, mock_run, mock_logger):\n        \"\"\"Test error when logs_folder is an empty string.\"\"\"\n        mock_isdir.return_value = False\n        save_logs('', '/path/to/backup')\n        mock_logger.info.assert_any_call(\"Backing up logs...\")\n        mock_logger.error.assert_called_once_with(\"Logs directory '' does not exist.\")\n        mock_isdir.assert_called_once_with('')\n        mock_run.assert_not_called()\n\n    @patch('solution.logger')\n    @patch('solution.subprocess.run')\n    @patch('solution.os.path.isdir')\n    def test_backup_folder_empty_string(self, mock_isdir, mock_run, mock_logger):\n        \"\"\"Test error when backup_folder is an empty string.\"\"\"\n        mock_isdir.side_effect = [True, False]\n        save_logs('/path/to/logs', '')\n        mock_logger.info.assert_any_call(\"Backing up logs...\")\n        mock_logger.error.assert_called_once_with(\"Backup directory '' does not exist.\")\n        mock_isdir.assert_has_calls([call('/path/to/logs'), call('')])\n        mock_run.assert_not_called()", "num_test_cases": 8, "task_id": "fb382ca9"}
{"test": "import os\nimport unittest\nfrom unittest.mock import patch, call\n\n# Import the function from the solution module\nfrom solution import create_log_backup\n\nclass TestCreateLogBackup(unittest.TestCase):\n    \n    @patch('subprocess.run')\n    @patch('os.path.isdir')\n    @patch('solution.logger')\n    def test_successful_backup(self, mock_logger, mock_isdir, mock_run):\n        \"\"\"Test backup with valid directories and successful zip command.\"\"\"\n        mock_isdir.side_effect = [True, True]  # Both directories exist\n        mock_process = unittest.mock.Mock()\n        mock_process.returncode = 0\n        mock_run.return_value = mock_process\n        \n        log_path = '/var/log/app'\n        archive_path = '/backup'\n        create_log_backup(log_path, archive_path)\n        \n        mock_logger.info.assert_any_call(\"Backing up logs...\")\n        expected_backup_file = os.path.join(archive_path, 'logs_backup.zip')\n        expected_command = ['zip', '-r', expected_backup_file, log_path]\n        mock_logger.info.assert_any_call(\"Running command: %s\", expected_command)\n        mock_logger.info.assert_any_call(\"Logs backed up successfully.\")\n        mock_logger.error.assert_not_called()\n        mock_isdir.assert_has_calls([call(log_path), call(archive_path)])\n        mock_run.assert_called_once_with(expected_command)\n        # Verify no shell=True for security\n        _, kwargs = mock_run.call_args\n        self.assertNotIn('shell', kwargs)\n    \n    @patch('subprocess.run')\n    @patch('os.path.isdir')\n    @patch('solution.logger')\n    def test_log_path_missing(self, mock_logger, mock_isdir, mock_run):\n        \"\"\"Test error when log directory does not exist.\"\"\"\n        mock_isdir.return_value = False  # log_path doesn't exist\n        \n        log_path = '/invalid/logs'\n        archive_path = '/backup'\n        create_log_backup(log_path, archive_path)\n        \n        mock_logger.info.assert_called_with(\"Backing up logs...\")\n        mock_logger.error.assert_called_with(\"Logs directory '%s' does not exist.\", log_path)\n        mock_isdir.assert_called_once_with(log_path)\n        mock_run.assert_not_called()\n    \n    @patch('subprocess.run')\n    @patch('os.path.isdir')\n    @patch('solution.logger')\n    def test_archive_path_missing(self, mock_logger, mock_isdir, mock_run):\n        \"\"\"Test error when backup directory does not exist.\"\"\"\n        mock_isdir.side_effect = [True, False]  # archive_path missing\n        \n        log_path = '/var/log/app'\n        archive_path = '/invalid/backup'\n        create_log_backup(log_path, archive_path)\n        \n        mock_logger.info.assert_called_with(\"Backing up logs...\")\n        mock_logger.error.assert_called_with(\"Backup directory '%s' does not exist.\", archive_path)\n        mock_isdir.assert_has_calls([call(log_path), call(archive_path)])\n        mock_run.assert_not_called()\n    \n    @patch('subprocess.run')\n    @patch('os.path.isdir')\n    @patch('solution.logger')\n    def test_zip_command_failure(self, mock_logger, mock_isdir, mock_run):\n        \"\"\"Test handling when zip command returns non-zero exit code.\"\"\"\n        mock_isdir.side_effect = [True, True]  # Both directories exist\n        mock_process = unittest.mock.Mock()\n        mock_process.returncode = 1  # Simulate command failure\n        mock_run.return_value = mock_process\n        \n        log_path = '/var/log/app'\n        archive_path = '/backup'\n        create_log_backup(log_path, archive_path)\n        \n        mock_logger.info.assert_any_call(\"Backing up logs...\")\n        expected_backup_file = os.path.join(archive_path, 'logs_backup.zip')\n        expected_command = ['zip', '-r', expected_backup_file, log_path]\n        mock_logger.info.assert_any_call(\"Running command: %s\", expected_command)\n        mock_logger.error.assert_called_with(\"Failed to back up logs; command exited with code %d.\", 1)\n        mock_run.assert_called_once_with(expected_command)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 4, "task_id": "7f100b32"}
{"test": "import unittest\nfrom unittest.mock import patch, MagicMock\n\nclass TestConvertMdToPdf(unittest.TestCase):\n\n    @patch('subprocess.run')\n    @patch('os.path.exists')\n    @patch('logging.Logger')\n    def test_happy_path(self, mock_logger, mock_exists, mock_run):\n        \"\"\"Test successful conversion with valid markdown file and output path.\"\"\"\n        mock_exists.return_value = True\n        mock_run.return_value = MagicMock(returncode=0)\n        \n        md_path = 'test.md'\n        output_pdf_path = 'output.pdf'\n        \n        result = convert_md_to_pdf(md_path, output_pdf_path)\n        self.assertIsNone(result)\n        mock_exists.assert_called_once_with(md_path)\n        mock_run.assert_called_once_with(['pandoc', md_path, '-o', output_pdf_path])\n        mock_logger.info.assert_any_call(\"Converting markdown file to PDF...\")\n        mock_logger.info.assert_any_call(\"Running command: pandoc test.md -o output.pdf\")\n        mock_logger.info.assert_any_call(\"Markdown converted to PDF successfully.\")\n        mock_logger.error.assert_not_called()\n\n    @patch('subprocess.run')\n    @patch('os.path.exists')\n    @patch('logging.Logger')\n    def test_file_not_found(self, mock_logger, mock_exists, mock_run):\n        \"\"\"Test FileNotFoundError when markdown file does not exist.\"\"\"\n        mock_exists.return_value = False\n        \n        md_path = 'missing.md'\n        output_pdf_path = 'output.pdf'\n        \n        with self.assertRaises(FileNotFoundError):\n            convert_md_to_pdf(md_path, output_pdf_path)\n        \n        mock_exists.assert_called_once_with(md_path)\n        mock_logger.info.assert_called_once_with(\"Converting markdown file to PDF...\")\n        mock_logger.error.assert_called_once_with(\"Markdown file not found: %s\", md_path)\n        mock_run.assert_not_called()\n\n    @patch('subprocess.run')\n    @patch('os.path.exists')\n    @patch('logging.Logger')\n    def test_invalid_file_type(self, mock_logger, mock_exists, mock_run):\n        \"\"\"Test early return when file does not have .md extension.\"\"\"\n        mock_exists.return_value = True\n        \n        md_path = 'invalid.txt'\n        output_pdf_path = 'output.pdf'\n        \n        result = convert_md_to_pdf(md_path, output_pdf_path)\n        self.assertIsNone(result)\n        mock_exists.assert_called_once_with(md_path)\n        mock_logger.info.assert_called_once_with(\"Converting markdown file to PDF...\")\n        mock_logger.error.assert_called_once_with(\"Invalid file type: %s\", md_path)\n        mock_run.assert_not_called()\n\n    @patch('subprocess.run')\n    @patch('os.path.exists')\n    @patch('logging.Logger')\n    def test_conversion_failure(self, mock_logger, mock_exists, mock_run):\n        \"\"\"Test error logging when pandoc returns non-zero exit code.\"\"\"\n        mock_exists.return_value = True\n        mock_run.return_value = MagicMock(returncode=1)\n        \n        md_path = 'test.md'\n        output_pdf_path = 'output.pdf'\n        \n        result = convert_md_to_pdf(md_path, output_pdf_path)\n        self.assertIsNone(result)\n        mock_run.assert_called_once_with(['pandoc', md_path, '-o', output_pdf_path])\n        mock_logger.info.assert_any_call(\"Converting markdown file to PDF...\")\n        mock_logger.info.assert_any_call(\"Running command: pandoc test.md -o output.pdf\")\n        mock_logger.error.assert_called_once_with(\"Failed to convert markdown to PDF; command exited with code %d.\", 1)\n\n    @patch('subprocess.run')\n    @patch('os.path.exists')\n    @patch('logging.Logger')\n    def test_empty_md_path(self, mock_logger, mock_exists, mock_run):\n        \"\"\"Test FileNotFoundError when markdown path is an empty string.\"\"\"\n        mock_exists.return_value = False\n        \n        md_path = ''\n        output_pdf_path = 'output.pdf'\n        \n        with self.assertRaises(FileNotFoundError):\n            convert_md_to_pdf(md_path, output_pdf_path)\n        \n        mock_exists.assert_called_once_with(md_path)\n        mock_logger.error.assert_called_once_with(\"Markdown file not found: %s\", md_path)\n        mock_run.assert_not_called()\n\n    @patch('subprocess.run')\n    @patch('os.path.exists')\n    @patch('logging.Logger')\n    def test_empty_output_path(self, mock_logger, mock_exists, mock_run):\n        \"\"\"Test successful conversion with empty output path.\"\"\"\n        mock_exists.return_value = True\n        mock_run.return_value = MagicMock(returncode=0)\n        \n        md_path = 'test.md'\n        output_pdf_path = ''\n        \n        result = convert_md_to_pdf(md_path, output_pdf_path)\n        self.assertIsNone(result)\n        mock_run.assert_called_once_with(['pandoc', md_path, '-o', ''])\n        mock_logger.info.assert_any_call(\"Running command: pandoc test.md -o \")\n\n    @patch('subprocess.run')\n    @patch('os.path.exists')\n    @patch('logging.Logger')\n    def test_non_string_md_path_not_exist(self, mock_logger, mock_exists, mock_run):\n        \"\"\"Test FileNotFoundError with non-string md_path (simulating non-existent).\"\"\"\n        mock_exists.return_value = False\n        \n        md_path = 123  # Non-string\n        output_pdf_path = 'output.pdf'\n        \n        with self.assertRaises(FileNotFoundError):\n            convert_md_to_pdf(md_path, output_pdf_path)\n        \n        mock_exists.assert_called_once_with(md_path)\n        mock_logger.error.assert_called_once_with(\"Markdown file not found: %s\", md_path)\n\n    @patch('subprocess.run')\n    @patch('os.path.exists')\n    @patch('logging.Logger')\n    def test_non_string_md_path_exists(self, mock_logger, mock_exists, mock_run):\n        \"\"\"Test AttributeError when non-string md_path exists but lacks .md method.\"\"\"\n        mock_exists.return_value = True\n        \n        md_path = 123  # Non-string\n        output_pdf_path = 'output.pdf'\n        \n        with self.assertRaises(AttributeError):\n            convert_md_to_pdf(md_path, output_pdf_path)\n        \n        mock_exists.assert_called_once_with(md_path)\n        mock_logger.info.assert_called_once_with(\"Converting markdown file to PDF...\")\n\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 8, "task_id": "1734948f"}
{"test": "import unittest\nfrom unittest.mock import patch, MagicMock\nfrom solution import task_func\n\nclass TestTranslateMdToPdf(unittest.TestCase):\n\n    @patch('solution.logger')\n    @patch('solution.subprocess.run')\n    @patch('solution.os.path.exists')\n    def test_successful_conversion(self, mock_exists, mock_run, mock_logger):\n        \"\"\"Test successful conversion with valid inputs.\"\"\"\n        mock_exists.return_value = True\n        mock_run.return_value = MagicMock(returncode=0)\n        input_path = 'test.md'\n        output_path = 'output.pdf'\n        \n        task_func(input_path, output_path)\n        \n        mock_exists.assert_called_once_with(input_path)\n        expected_command = ['pandoc', input_path, '-o', output_path]\n        mock_run.assert_called_once_with(expected_command)\n        expected_command_str = ' '.join(expected_command)\n        mock_logger.info.assert_any_call('Converting markdown file to PDF...')\n        mock_logger.info.assert_any_call('Running command: %s', expected_command_str)\n        mock_logger.info.assert_any_call('Markdown converted to PDF successfully.')\n\n    @patch('solution.logger')\n    @patch('solution.subprocess.run')\n    @patch('solution.os.path.exists')\n    def test_file_not_found(self, mock_exists, mock_run, mock_logger):\n        \"\"\"Test FileNotFoundError when markdown file doesn't exist.\"\"\"\n        mock_exists.return_value = False\n        input_path = 'nonexistent.md'\n        output_path = 'output.pdf'\n\n        with self.assertRaises(FileNotFoundError) as context:\n            task_func(input_path, output_path)\n            \n        self.assertEqual(str(context.exception), f'Markdown file not found: {input_path}')\n        mock_logger.error.assert_called_once_with('Markdown file not found: %s', input_path)\n        mock_run.assert_not_called()\n\n    @patch('solution.logger')\n    @patch('solution.subprocess.run')\n    @patch('solution.os.path.exists')\n    def test_invalid_file_extension(self, mock_exists, mock_run, mock_logger):\n        \"\"\"Test handling of non-markdown file extension.\"\"\"\n        mock_exists.return_value = True\n        input_path = 'invalid.txt'\n        output_path = 'output.pdf'\n        \n        task_func(input_path, output_path)\n        \n        mock_logger.error.assert_called_once_with('Invalid file type: %s', input_path)\n        mock_run.assert_not_called()\n\n    @patch('solution.logger')\n    @patch('solution.subprocess.run')\n    @patch('solution.os.path.exists')\n    def test_pandoc_failure(self, mock_exists, mock_run, mock_logger):\n        \"\"\"Test handling of pandoc command failure.\"\"\"\n        mock_exists.return_value = True\n        mock_run.return_value = MagicMock(returncode=1)\n        input_path = 'test.md'\n        output_path = 'output.pdf'\n        \n        task_func(input_path, output_path)\n        \n        mock_run.assert_called_once_with(['pandoc', input_path, '-o', output_path])\n        mock_logger.error.assert_called_once_with('Failed to convert markdown to PDF; command exited with code %d.', 1)\n\n    @patch('solution.logger')\n    @patch('solution.subprocess.run')\n    @patch('solution.os.path.exists')\n    def test_file_paths_with_spaces(self, mock_exists, mock_run, mock_logger):\n        \"\"\"Test handling of file paths containing spaces.\"\"\"\n        mock_exists.return_value = True\n        mock_run.return_value = MagicMock(returncode=0)\n        input_path = '/path/with spaces/file.md'\n        output_path = '/another path/output.pdf'\n        \n        task_func(input_path, output_path)\n        \n        expected_command = ['pandoc', input_path, '-o', output_path]\n        mock_run.assert_called_once_with(expected_command)\n        expected_command_str = ' '.join(expected_command)\n        mock_logger.info.assert_any_call('Running command: %s', expected_command_str)\n\n    @patch('solution.logger')\n    @patch('solution.subprocess.run')\n    @patch('solution.os.path.exists')\n    def test_file_paths_with_non_ascii(self, mock_exists, mock_run, mock_logger):\n        \"\"\"Test handling of file paths with non-ASCII characters.\"\"\"\n        mock_exists.return_value = True\n        mock_run.return_value = MagicMock(returncode=0)\n        input_path = '/path/with/非ASCII.md'\n        output_path = '/another/路径/output.pdf'\n        \n        task_func(input_path, output_path)\n        \n        expected_command = ['pandoc', input_path, '-o', output_path]\n        mock_run.assert_called_once_with(expected_command)\n        expected_command_str = ' '.join(expected_command)\n        mock_logger.info.assert_any_call('Running command: %s', expected_command_str)\n\n    @patch('solution.logger')\n    @patch('solution.subprocess.run')\n    @patch('solution.os.path.exists')\n    def test_empty_filename(self, mock_exists, mock_run, mock_logger):\n        \"\"\"Test handling of empty filename string.\"\"\"\n        mock_exists.return_value = False\n        input_path = ''\n        output_path = 'output.pdf'\n\n        with self.assertRaises(FileNotFoundError) as context:\n            task_func(input_path, output_path)\n            \n        self.assertEqual(str(context.exception), 'Markdown file not found: ')\n        mock_logger.error.assert_called_once_with('Markdown file not found: %s', '')\n        mock_run.assert_not_called()\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 7, "task_id": "07ee6a66"}
{"test": "import unittest\nfrom unittest.mock import patch, MagicMock\n\nclass TestCases(unittest.TestCase):\n    @patch('converter_module.logger')\n    @patch('os.path.exists', return_value=True)\n    @patch('subprocess.run')\n    def test_case_1(self, mock_run, mock_exists, mock_logger):\n        \"\"\"Test successful conversion with valid inputs.\"\"\"\n        mock_run.return_value = MagicMock(returncode=0)\n        src = \"document.md\"\n        dest = \"output.pdf\"\n        \n        convert_markdown_to_pdf_uri(src, dest)\n        \n        mock_logger.info.assert_any_call(\"Converting markdown file to PDF...\")\n        mock_logger.info.assert_any_call(f\"Running command: pandoc {src} -o {dest}\")\n        mock_logger.info.assert_any_call(\"Markdown converted to PDF successfully.\")\n        mock_exists.assert_called_once_with(src)\n        mock_run.assert_called_once_with([\"pandoc\", src, \"-o\", dest])\n    \n    @patch('converter_module.logger')\n    @patch('os.path.exists', return_value=False)\n    @patch('subprocess.run')\n    def test_case_2(self, mock_run, mock_exists, mock_logger):\n        \"\"\"Test FileNotFoundError when source file doesn't exist.\"\"\"\n        src = \"missing.md\"\n        dest = \"output.pdf\"\n        \n        with self.assertRaises(FileNotFoundError):\n            convert_markdown_to_pdf_uri(src, dest)\n            \n        mock_exists.assert_called_once_with(src)\n        mock_logger.error.assert_called_once_with(\"Markdown file not found: %s\", src)\n        mock_run.assert_not_called()\n    \n    @patch('converter_module.logger')\n    @patch('os.path.exists', return_value=True)\n    @patch('subprocess.run')\n    def test_case_3(self, mock_run, mock_exists, mock_logger):\n        \"\"\"Test early return when source file has invalid extension.\"\"\"\n        src = \"document.txt\"\n        dest = \"output.pdf\"\n        \n        convert_markdown_to_pdf_uri(src, dest)\n        \n        mock_exists.assert_called_once_with(src)\n        mock_logger.error.assert_called_once_with(\"Invalid file type: %s\", src)\n        mock_run.assert_not_called()\n    \n    @patch('converter_module.logger')\n    @patch('os.path.exists', return_value=True)\n    @patch('subprocess.run')\n    def test_case_4(self, mock_run, mock_exists, mock_logger):\n        \"\"\"Test error logging when pandoc returns non-zero exit code.\"\"\"\n        mock_run.return_value = MagicMock(returncode=1)\n        src = \"document.md\"\n        dest = \"output.pdf\"\n        \n        convert_markdown_to_pdf_uri(src, dest)\n        \n        mock_run.assert_called_once_with([\"pandoc\", src, \"-o\", dest])\n        mock_logger.error.assert_called_with(\"Failed to convert markdown to PDF; command exited with code %d.\", 1)\n    \n    @patch('converter_module.logger')\n    @patch('os.path.exists', return_value=False)\n    @patch('subprocess.run')\n    def test_case_5(self, mock_run, mock_exists, mock_logger):\n        \"\"\"Test FileNotFoundError with empty source path.\"\"\"\n        src = \"\"\n        dest = \"output.pdf\"\n        \n        with self.assertRaises(FileNotFoundError):\n            convert_markdown_to_pdf_uri(src, dest)\n            \n        mock_exists.assert_called_once_with(src)\n        mock_logger.error.assert_called_once_with(\"Markdown file not found: %s\", src)\n        mock_run.assert_not_called()\n    \n    @patch('converter_module.logger')\n    def test_case_6(self, mock_logger):\n        \"\"\"Test TypeError with non-string source path.\"\"\"\n        src = 123\n        dest = \"output.pdf\"\n        \n        with self.assertRaises(TypeError):\n            convert_markdown_to_pdf_uri(src, dest)\n    \n    @patch('converter_module.logger')\n    @patch('os.path.exists', return_value=True)\n    @patch('subprocess.run')\n    def test_case_7(self, mock_run, mock_exists, mock_logger):\n        \"\"\"Test TypeError with non-string destination path.\"\"\"\n        def run_side_effect(command, *args, **kwargs):\n            for item in command:\n                if not isinstance(item, str):\n                    raise TypeError(\"Command parts must be strings\")\n            return MagicMock(returncode=0)\n        mock_run.side_effect = run_side_effect\n        \n        src = \"document.md\"\n        dest = 123\n        \n        with self.assertRaises(TypeError):\n            convert_markdown_to_pdf_uri(src, dest)\n    \n    @patch('converter_module.logger')\n    @patch('os.path.exists', return_value=True)\n    @patch('subprocess.run')\n    def test_case_8(self, mock_run, mock_exists, mock_logger):\n        \"\"\"Test successful conversion with empty destination path.\"\"\"\n        mock_run.return_value = MagicMock(returncode=0)\n        src = \"document.md\"\n        dest = \"\"\n        \n        convert_markdown_to_pdf_uri(src, dest)\n        \n        mock_run.assert_called_once_with([\"pandoc\", src, \"-o\", dest])\n        mock_logger.info.assert_any_call(\"Markdown converted to PDF successfully.\")\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 8, "task_id": "284e2c58"}
{"test": "import unittest\nfrom unittest.mock import patch, MagicMock\nfrom converter import md_to_pdf_conversion\n\nclass TestMdToPdfConversion(unittest.TestCase):\n\n    @patch('converter.os.path.exists')\n    @patch('converter.subprocess.run')\n    @patch('converter.logger')\n    def test_happy_path(self, mock_logger, mock_run, mock_exists):\n        \"\"\"Test successful conversion with valid .md file and output path.\"\"\"\n        mock_exists.return_value = True\n        mock_run.return_value = MagicMock(returncode=0)\n        md_to_pdf_conversion('test.md', 'output.pdf')\n        mock_exists.assert_called_once_with('test.md')\n        mock_run.assert_called_once_with(['pandoc', 'test.md', '-o', 'output.pdf'])\n        mock_logger.info.assert_any_call(\"Converting markdown file to PDF...\")\n        mock_logger.info.assert_any_call(\"Running command: pandoc test.md -o output.pdf\")\n        mock_logger.info.assert_any_call(\"Markdown converted to PDF successfully.\")\n        mock_logger.error.assert_not_called()\n\n    @patch('converter.os.path.exists')\n    @patch('converter.logger')\n    def test_file_not_found(self, mock_logger, mock_exists):\n        \"\"\"Test FileNotFoundError when markdown file doesn't exist.\"\"\"\n        mock_exists.return_value = False\n        with self.assertRaises(FileNotFoundError):\n            md_to_pdf_conversion('nonexistent.md', 'output.pdf')\n        mock_logger.error.assert_called_once_with(\"Markdown file not found: %s\", 'nonexistent.md')\n\n    @patch('converter.os.path.exists')\n    @patch('converter.subprocess.run')\n    @patch('converter.logger')\n    def test_invalid_file_extension(self, mock_logger, mock_run, mock_exists):\n        \"\"\"Test error logging for non-.md file extension.\"\"\"\n        mock_exists.return_value = True\n        md_to_pdf_conversion('test.txt', 'output.pdf')\n        mock_logger.error.assert_called_once_with(\"Invalid file type: %s\", 'test.txt')\n        mock_run.assert_not_called()\n\n    @patch('converter.os.path.exists')\n    @patch('converter.subprocess.run')\n    @patch('converter.logger')\n    def test_pandoc_failure(self, mock_logger, mock_run, mock_exists):\n        \"\"\"Test error logging when pandoc returns non-zero exit code.\"\"\"\n        mock_exists.return_value = True\n        mock_run.return_value = MagicMock(returncode=1)\n        md_to_pdf_conversion('test.md', 'output.pdf')\n        mock_run.assert_called_once_with(['pandoc', 'test.md', '-o', 'output.pdf'])\n        mock_logger.error.assert_called_once_with(\"Failed to convert markdown to PDF; command exited with code %d.\", 1)\n\n    @patch('converter.os.path.exists')\n    @patch('converter.logger')\n    def test_empty_markdown_file(self, mock_logger, mock_exists):\n        \"\"\"Test FileNotFoundError with empty markdown file path.\"\"\"\n        mock_exists.return_value = False\n        with self.assertRaises(FileNotFoundError):\n            md_to_pdf_conversion('', 'output.pdf')\n        mock_logger.error.assert_called_once_with(\"Markdown file not found: %s\", '')\n\n    @patch('converter.os.path.exists')\n    @patch('converter.subprocess.run')\n    @patch('converter.logger')\n    def test_empty_pdf_output(self, mock_logger, mock_run, mock_exists):\n        \"\"\"Test pandoc failure with empty PDF output path.\"\"\"\n        mock_exists.return_value = True\n        mock_run.return_value = MagicMock(returncode=1)\n        md_to_pdf_conversion('test.md', '')\n        mock_run.assert_called_once_with(['pandoc', 'test.md', '-o', ''])\n        mock_logger.error.assert_called_once_with(\"Failed to convert markdown to PDF; command exited with code %d.\", 1)\n\n    @patch('converter.os.path.exists')\n    @patch('converter.logger')\n    def test_non_string_markdown_file(self, mock_logger, mock_exists):\n        \"\"\"Test AttributeError when markdown_file is not a string.\"\"\"\n        mock_exists.return_value = True\n        with self.assertRaises(AttributeError):\n            md_to_pdf_conversion(123, 'output.pdf')\n        mock_logger.info.assert_called_once_with(\"Converting markdown file to PDF...\")\n\n    @patch('converter.os.path.exists')\n    @patch('converter.logger')\n    def test_non_string_pdf_output(self, mock_logger, mock_exists):\n        \"\"\"Test TypeError when pdf_output is not a string.\"\"\"\n        mock_exists.return_value = True\n        with self.assertRaises(TypeError):\n            md_to_pdf_conversion('test.md', 123)\n        mock_logger.info.assert_called_once_with(\"Converting markdown file to PDF...\")\n", "num_test_cases": 8, "task_id": "b96699e0"}
{"test": "import unittest\nfrom unittest.mock import patch, MagicMock\n\ntry:\n    from solution import markdown_to_pdf\nexcept ImportError:\n    from __main__ import markdown_to_pdf\n\nclass TestMarkdownToPdf(unittest.TestCase):\n\n    @patch('solution.os.path.exists')\n    @patch('solution.subprocess.run')\n    @patch('solution.logger')\n    def test_successful_conversion(self, mock_logger, mock_run, mock_exists):\n        \"\"\"Test successful conversion with valid .md file and successful pandoc execution.\"\"\"\n        mock_exists.return_value = True\n        mock_run.return_value = MagicMock(returncode=0)\n        md_file = \"test.md\"\n        pdf_file = \"output.pdf\"\n        \n        markdown_to_pdf(md_file, pdf_file)\n        \n        mock_logger.info.assert_any_call(\"Converting markdown file to PDF...\")\n        mock_logger.info.assert_any_call(\"Running command: pandoc test.md -o output.pdf\")\n        mock_logger.info.assert_any_call(\"Markdown converted to PDF successfully.\")\n        mock_run.assert_called_once_with([\"pandoc\", \"test.md\", \"-o\", \"output.pdf\"])\n\n    @patch('solution.os.path.exists')\n    @patch('solution.subprocess.run')\n    @patch('solution.logger')\n    def test_file_not_found(self, mock_logger, mock_run, mock_exists):\n        \"\"\"Test FileNotFoundError when markdown file doesn't exist.\"\"\"\n        mock_exists.return_value = False\n        md_file = \"nonexistent.md\"\n        pdf_file = \"output.pdf\"\n        \n        with self.assertRaises(FileNotFoundError):\n            markdown_to_pdf(md_file, pdf_file)\n            \n        mock_logger.error.assert_called_once_with(\"Markdown file not found: %s\", md_file)\n        mock_run.assert_not_called()\n\n    @patch('solution.os.path.exists')\n    @patch('solution.subprocess.run')\n    @patch('solution.logger')\n    def test_invalid_file_extension(self, mock_logger, mock_run, mock_exists):\n        \"\"\"Test early return and error logging for non-.md file extension.\"\"\"\n        mock_exists.return_value = True\n        md_file = \"test.txt\"\n        pdf_file = \"output.pdf\"\n        \n        markdown_to_pdf(md_file, pdf_file)\n        \n        mock_logger.error.assert_called_once_with(\"Invalid file type: %s\", md_file)\n        mock_run.assert_not_called()\n\n    @patch('solution.os.path.exists')\n    @patch('solution.subprocess.run')\n    @patch('solution.logger')\n    def test_pandoc_failure(self, mock_logger, mock_run, mock_exists):\n        \"\"\"Test error logging when pandoc returns non-zero exit code.\"\"\"\n        mock_exists.return_value = True\n        mock_run.return_value = MagicMock(returncode=1)\n        md_file = \"test.md\"\n        pdf_file = \"output.pdf\"\n        \n        markdown_to_pdf(md_file, pdf_file)\n        \n        mock_logger.info.assert_any_call(\"Converting markdown file to PDF...\")\n        mock_logger.info.assert_any_call(\"Running command: pandoc test.md -o output.pdf\")\n        mock_logger.error.assert_called_once_with(\"Failed to convert markdown to PDF; command exited with code %d.\", 1)\n\n    @patch('solution.os.path.exists')\n    @patch('solution.subprocess.run')\n    @patch('solution.logger')\n    def test_empty_md_file_path(self, mock_logger, mock_run, mock_exists):\n        \"\"\"Test FileNotFoundError when markdown file path is empty string.\"\"\"\n        mock_exists.return_value = False\n        md_file = \"\"\n        pdf_file = \"output.pdf\"\n        \n        with self.assertRaises(FileNotFoundError):\n            markdown_to_pdf(md_file, pdf_file)\n            \n        mock_logger.error.assert_called_once_with(\"Markdown file not found: %s\", md_file)\n        mock_run.assert_not_called()\n\n    @patch('solution.os.path.exists')\n    @patch('solution.subprocess.run')\n    @patch('solution.logger')\n    def test_long_file_paths(self, mock_logger, mock_run, mock_exists):\n        \"\"\"Test with very long input and output file paths.\"\"\"\n        mock_exists.return_value = True\n        mock_run.return_value = MagicMock(returncode=0)\n        md_file = \"a\" * 500 + \".md\"\n        pdf_file = \"b\" * 500 + \".pdf\"\n        \n        markdown_to_pdf(md_file, pdf_file)\n        \n        expected_command = [\"pandoc\", md_file, \"-o\", pdf_file]\n        mock_logger.info.assert_any_call(\"Running command: pandoc {} -o {}\".format(md_file, pdf_file))\n        mock_run.assert_called_once_with(expected_command)\n\n    @patch('solution.os.path.exists')\n    @patch('solution.subprocess.run')\n    @patch('solution.logger')\n    def test_spaces_in_file_paths(self, mock_logger, mock_run, mock_exists):\n        \"\"\"Test file paths containing spaces are handled correctly.\"\"\"\n        mock_exists.return_value = True\n        mock_run.return_value = MagicMock(returncode=0)\n        md_file = \"file with spaces.md\"\n        pdf_file = \"output with spaces.pdf\"\n        \n        markdown_to_pdf(md_file, pdf_file)\n        \n        expected_command = [\"pandoc\", md_file, \"-o\", pdf_file]\n        mock_logger.info.assert_any_call(\"Running command: pandoc {} -o {}\".format(md_file, pdf_file))\n        mock_run.assert_called_once_with(expected_command)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 7, "task_id": "0ce62dfa"}
{"test": "import unittest\nfrom unittest.mock import patch, Mock\n\nclass TestConvertMdToPdf(unittest.TestCase):\n    \n    @patch('converter.subprocess.run')\n    @patch('converter.os.path.exists')\n    @patch('converter.logger')\n    def test_successful_conversion(self, mock_logger, mock_exists, mock_run):\n        \"\"\"Test successful conversion with valid .md file.\"\"\"\n        mock_exists.return_value = True\n        mock_run.return_value = Mock(returncode=0)\n        \n        convert_md_to_pdf('input.md', 'output.pdf')\n        \n        mock_logger.info.assert_any_call(\"Converting markdown file to PDF...\")\n        mock_logger.info.assert_any_call(\"Running command: pandoc input.md -o output.pdf\")\n        mock_logger.info.assert_any_call(\"Markdown converted to PDF successfully.\")\n        mock_run.assert_called_once_with(['pandoc', 'input.md', '-o', 'output.pdf'])\n    \n    @patch('converter.subprocess.run')\n    @patch('converter.os.path.exists')\n    @patch('converter.logger')\n    def test_file_not_found(self, mock_logger, mock_exists, mock_run):\n        \"\"\"Test FileNotFoundError when markdown file is missing.\"\"\"\n        mock_exists.return_value = False\n        \n        with self.assertRaises(FileNotFoundError):\n            convert_md_to_pdf('missing.md', 'output.pdf')\n            \n        mock_logger.error.assert_called_once_with(\"Markdown file not found: %s\", 'missing.md')\n        mock_run.assert_not_called()\n    \n    @patch('converter.subprocess.run')\n    @patch('converter.os.path.exists')\n    @patch('converter.logger')\n    def test_invalid_extension(self, mock_logger, mock_exists, mock_run):\n        \"\"\"Test non-.md file extension handling.\"\"\"\n        mock_exists.return_value = True\n        \n        convert_md_to_pdf('input.txt', 'output.pdf')\n        \n        mock_logger.error.assert_called_once_with(\"Invalid file type: %s\", 'input.txt')\n        mock_run.assert_not_called()\n    \n    @patch('converter.subprocess.run')\n    @patch('converter.os.path.exists')\n    @patch('converter.logger')\n    def test_conversion_failure(self, mock_logger, mock_exists, mock_run):\n        \"\"\"Test non-zero exit code from pandoc command.\"\"\"\n        mock_exists.return_value = True\n        mock_run.return_value = Mock(returncode=1)\n        \n        convert_md_to_pdf('input.md', 'output.pdf')\n        \n        mock_logger.error.assert_called_once_with(\"Failed to convert markdown to PDF; command exited with code %d.\", 1)\n    \n    @patch('converter.subprocess.run')\n    @patch('converter.os.path.exists')\n    @patch('converter.logger')\n    def test_empty_string_input(self, mock_logger, mock_exists, mock_run):\n        \"\"\"Test empty input_md_path (should be treated as missing file).\"\"\"\n        mock_exists.return_value = False\n        \n        with self.assertRaises(FileNotFoundError):\n            convert_md_to_pdf('', 'output.pdf')\n            \n        mock_logger.error.assert_called_once_with(\"Markdown file not found: %s\", '')\n        mock_run.assert_not_called()\n    \n    @patch('converter.logger')\n    def test_none_input(self, mock_logger):\n        \"\"\"Test None input_md_path (should raise TypeError).\"\"\"\n        with self.assertRaises(TypeError):\n            convert_md_to_pdf(None, 'output.pdf')\n        \n        mock_logger.info.assert_called_with(\"Converting markdown file to PDF...\")\n    \n    @patch('converter.logger')\n    def test_non_string_input(self, mock_logger):\n        \"\"\"Test non-string input_md_path (integer).\"\"\"\n        with self.assertRaises(TypeError):\n            convert_md_to_pdf(123, 'output.pdf')\n        \n        mock_logger.info.assert_called_with(\"Converting markdown file to PDF...\")\n    \n    @patch('converter.subprocess.run')\n    @patch('converter.os.path.exists')\n    @patch('converter.logger')\n    def test_command_injection_safety(self, mock_logger, mock_exists, mock_run):\n        \"\"\"Test command injection safety with special characters.\"\"\"\n        mock_exists.return_value = True\n        mock_run.return_value = Mock(returncode=0)\n        \n        convert_md_to_pdf('input.md', 'output.pdf; rm -rf /')\n        \n        # Verify command is passed as list (safe from injection)\n        mock_run.assert_called_once_with(['pandoc', 'input.md', '-o', 'output.pdf; rm -rf /'])\n    \n    @patch('converter.subprocess.run')\n    @patch('converter.os.path.exists')\n    @patch('converter.logger')\n    def test_command_not_found(self, mock_logger, mock_exists, mock_run):\n        \"\"\"Test handling of missing pandoc executable.\"\"\"\n        mock_exists.return_value = True\n        mock_run.side_effect = FileNotFoundError(\"pandoc not found\")\n        \n        with self.assertRaises(FileNotFoundError):\n            convert_md_to_pdf('input.md', 'output.pdf')\n        \n        mock_logger.info.assert_called_with(\"Running command: pandoc input.md -o output.pdf\")\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 9, "task_id": "0a18a3a1"}
{"test": "import unittest\nfrom unittest.mock import patch, MagicMock\nfrom solution import md_to_pdf_converter\n\nclass TestMdToPdfConverter(unittest.TestCase):\n\n    @patch('solution.os.path.exists')\n    @patch('solution.subprocess.run')\n    @patch('solution.logger')\n    def test_successful_conversion(self, mock_logger, mock_run, mock_exists):\n        # Happy path: valid markdown file and pdf output\n        mock_exists.return_value = True\n        mock_run.return_value = MagicMock(returncode=0)\n        markdown_file = 'test.md'\n        pdf_output = 'output.pdf'\n        \n        md_to_pdf_converter(markdown_file, pdf_output)\n        \n        mock_exists.assert_called_once_with(markdown_file)\n        mock_run.assert_called_once_with(['pandoc', markdown_file, '-o', pdf_output])\n        mock_logger.info.assert_any_call('Converting markdown file to PDF...')\n        mock_logger.info.assert_any_call('Running command: pandoc test.md -o output.pdf')\n        mock_logger.info.assert_any_call('Markdown converted to PDF successfully.')\n        mock_logger.error.assert_not_called()\n\n    @patch('solution.os.path.exists')\n    @patch('solution.subprocess.run')\n    @patch('solution.logger')\n    def test_file_not_found_non_empty(self, mock_logger, mock_run, mock_exists):\n        # Non-empty markdown file that doesn't exist\n        mock_exists.return_value = False\n        markdown_file = 'nonexistent.md'\n        pdf_output = 'output.pdf'\n        \n        with self.assertRaises(FileNotFoundError) as context:\n            md_to_pdf_converter(markdown_file, pdf_output)\n        \n        self.assertEqual(str(context.exception), f'Markdown file not found: {markdown_file}')\n        mock_exists.assert_called_once_with(markdown_file)\n        mock_run.assert_not_called()\n        mock_logger.error.assert_called_once_with('Markdown file not found: %s', markdown_file)\n\n    @patch('solution.os.path.exists')\n    @patch('solution.subprocess.run')\n    @patch('solution.logger')\n    def test_file_not_found_empty(self, mock_logger, mock_run, mock_exists):\n        # Edge case: empty string for markdown file\n        mock_exists.return_value = False\n        markdown_file = ''\n        pdf_output = 'output.pdf'\n        \n        with self.assertRaises(FileNotFoundError) as context:\n            md_to_pdf_converter(markdown_file, pdf_output)\n        \n        self.assertEqual(str(context.exception), f'Markdown file not found: {markdown_file}')\n        mock_exists.assert_called_once_with(markdown_file)\n        mock_run.assert_not_called()\n        mock_logger.error.assert_called_once_with('Markdown file not found: %s', markdown_file)\n\n    @patch('solution.os.path.exists')\n    @patch('solution.subprocess.run')\n    @patch('solution.logger')\n    def test_invalid_file_type(self, mock_logger, mock_run, mock_exists):\n        # Existing file without .md extension\n        mock_exists.return_value = True\n        markdown_file = 'test.txt'\n        pdf_output = 'output.pdf'\n        \n        md_to_pdf_converter(markdown_file, pdf_output)\n        \n        mock_exists.assert_called_once_with(markdown_file)\n        mock_run.assert_not_called()\n        mock_logger.error.assert_called_once_with('Invalid file type: %s', markdown_file)\n\n    @patch('solution.os.path.exists')\n    @patch('solution.subprocess.run')\n    @patch('solution.logger')\n    def test_pandoc_failure(self, mock_logger, mock_run, mock_exists):\n        # Pandoc command returns non-zero exit code\n        mock_exists.return_value = True\n        mock_run.return_value = MagicMock(returncode=1)\n        markdown_file = 'test.md'\n        pdf_output = 'output.pdf'\n        \n        md_to_pdf_converter(markdown_file, pdf_output)\n        \n        mock_run.assert_called_once_with(['pandoc', markdown_file, '-o', pdf_output])\n        mock_logger.error.assert_called_once_with('Failed to convert markdown to PDF; command exited with code %d.', 1)\n\n    @patch('solution.os.path.exists')\n    @patch('solution.subprocess.run')\n    @patch('solution.logger')\n    def test_empty_string_pdf_output(self, mock_logger, mock_run, mock_exists):\n        # Edge case: empty string for pdf_output\n        mock_exists.return_value = True\n        mock_run.return_value = MagicMock(returncode=0)\n        markdown_file = 'test.md'\n        pdf_output = ''\n        \n        md_to_pdf_converter(markdown_file, pdf_output)\n        \n        mock_run.assert_called_once_with(['pandoc', markdown_file, '-o', pdf_output])\n        mock_logger.info.assert_any_call('Running command: pandoc test.md -o ')\n\n    @patch('solution.os.path.exists')\n    @patch('solution.subprocess.run')\n    @patch('solution.logger')\n    def test_non_string_markdown_file(self, mock_logger, mock_run, mock_exists):\n        # Non-string markdown_file (integer)\n        markdown_file = 123\n        pdf_output = 'output.pdf'\n        \n        with self.assertRaises(AttributeError):\n            md_to_pdf_converter(markdown_file, pdf_output)\n        \n        mock_exists.assert_not_called()\n        mock_run.assert_not_called()\n\n    @patch('solution.os.path.exists')\n    @patch('solution.subprocess.run')\n    @patch('solution.logger')\n    def test_non_string_pdf_output(self, mock_logger, mock_run, mock_exists):\n        # Non-string pdf_output (integer)\n        mock_exists.return_value = True\n        markdown_file = 'test.md'\n        pdf_output = 123\n        \n        with self.assertRaises(TypeError):\n            md_to_pdf_converter(markdown_file, pdf_output)\n        \n        mock_exists.assert_called_once_with(markdown_file)\n        mock_run.assert_not_called()\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 8, "task_id": "62926084"}
{"test": "import unittest\nfrom unittest.mock import patch, MagicMock, call\n\n# Import the function to be tested\nfrom converter import markdown_to_pdf_conversion\n\nclass TestMarkdownToPDFConversion(unittest.TestCase):\n\n    @patch('converter.subprocess.run')\n    @patch('converter.os.path.exists')\n    @patch('converter.logger')\n    def test_file_not_found(self, mock_logger, mock_exists, mock_run):\n        \"\"\"Test that FileNotFoundError is raised when markdown file does not exist.\"\"\"\n        mock_exists.return_value = False\n        with self.assertRaises(FileNotFoundError):\n            markdown_to_pdf_conversion('nonexistent.md', 'output.pdf')\n        mock_logger.error.assert_called_once_with(\"Markdown file not found: %s\", 'nonexistent.md')\n        mock_run.assert_not_called()\n\n    @patch('converter.subprocess.run')\n    @patch('converter.os.path.exists')\n    @patch('converter.logger')\n    def test_invalid_file_type(self, mock_logger, mock_exists, mock_run):\n        \"\"\"Test error logging and no conversion when file does not have .md extension.\"\"\"\n        mock_exists.return_value = True\n        markdown_to_pdf_conversion('test.txt', 'output.pdf')\n        mock_logger.error.assert_called_once_with(\"Invalid file type: %s\", 'test.txt')\n        mock_run.assert_not_called()\n\n    @patch('converter.subprocess.run')\n    @patch('converter.os.path.exists')\n    @patch('converter.logger')\n    def test_successful_conversion(self, mock_logger, mock_exists, mock_run):\n        \"\"\"Test successful conversion with correct command execution and logging.\"\"\"\n        mock_exists.return_value = True\n        mock_run.return_value.returncode = 0\n        \n        markdown_to_pdf_conversion('test.md', 'output.pdf')\n        \n        mock_logger.info.assert_any_call(\"Converting markdown file to PDF...\")\n        mock_logger.info.assert_any_call(\"Running command: pandoc test.md -o output.pdf\")\n        mock_logger.info.assert_called_with(\"Markdown converted to PDF successfully.\")\n        mock_run.assert_called_once_with(['pandoc', 'test.md', '-o', 'output.pdf'])\n\n    @patch('converter.subprocess.run')\n    @patch('converter.os.path.exists')\n    @patch('converter.logger')\n    def test_conversion_failure(self, mock_logger, mock_exists, mock_run):\n        \"\"\"Test error logging when pandoc returns non-zero exit code.\"\"\"\n        mock_exists.return_value = True\n        mock_run.return_value.returncode = 1\n        \n        markdown_to_pdf_conversion('test.md', 'output.pdf')\n        \n        mock_logger.info.assert_any_call(\"Converting markdown file to PDF...\")\n        mock_logger.info.assert_any_call(\"Running command: pandoc test.md -o output.pdf\")\n        mock_logger.error.assert_called_once_with(\"Failed to convert markdown to PDF; command exited with code %d.\", 1)\n        self.assertNotIn(call(\"Markdown converted to PDF successfully.\"), mock_logger.info.mock_calls)\n\n    @patch('converter.subprocess.run')\n    @patch('converter.os.path.exists')\n    @patch('converter.logger')\n    def test_pandoc_not_found(self, mock_logger, mock_exists, mock_run):\n        \"\"\"Test FileNotFoundError when pandoc executable is not found.\"\"\"\n        mock_exists.return_value = True\n        mock_run.side_effect = FileNotFoundError(\"pandoc not found\")\n        \n        with self.assertRaises(FileNotFoundError):\n            markdown_to_pdf_conversion('test.md', 'output.pdf')\n        \n        mock_logger.info.assert_any_call(\"Converting markdown file to PDF...\")\n        mock_logger.info.assert_any_call(\"Running command: pandoc test.md -o output.pdf\")\n        mock_logger.error.assert_not_called()\n        self.assertNotIn(call(\"Markdown converted to PDF successfully.\"), mock_logger.info.mock_calls)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 5, "task_id": "66ac0f43"}
{"test": "import unittest\nimport subprocess\nfrom unittest import mock\n\nclass TestLogProjectDependencies(unittest.TestCase):\n\n    @mock.patch('__main__.logger')\n    @mock.patch('subprocess.run')\n    @mock.patch('os.getcwd', return_value='/current/working/directory')\n    def test_success_case(self, mock_getcwd, mock_run, mock_logger):\n        \"\"\"Test successful execution with pigar installed and command returning 0.\"\"\"\n        mock_run.return_value = subprocess.CompletedProcess([], 0)\n        dependency_file_path = 'requirements.txt'\n        log_project_dependencies(dependency_file_path)\n        mock_logger.info.assert_any_call(\"Capturing dependencies...\")\n        expected_command = ['pigar', 'gen', '-f', 'requirements.txt', '/current/working/directory']\n        mock_logger.info.assert_any_call(\"Running command: %s\", expected_command)\n        mock_logger.info.assert_any_call(\"Dependencies captured successfully.\")\n        mock_run.assert_called_once_with(expected_command)\n\n    @mock.patch('__main__.logger')\n    @mock.patch('subprocess.run')\n    @mock.patch('os.getcwd')\n    def test_pigar_not_installed(self, mock_getcwd, mock_run, mock_logger):\n        \"\"\"Test behavior when pigar is not installed.\"\"\"\n        with mock.patch('builtins.__import__') as mock_import:\n            mock_import.side_effect = ModuleNotFoundError(\"No module named 'pigar'\")\n            dependency_file_path = 'requirements.txt'\n            log_project_dependencies(dependency_file_path)\n        mock_logger.info.assert_called_once_with(\"Capturing dependencies...\")\n        mock_logger.warning.assert_called_once_with(\n            \"pigar module is not installed, dependency capture might be incomplete.\"\n        )\n        mock_run.assert_not_called()\n\n    @mock.patch('__main__.logger')\n    @mock.patch('subprocess.run')\n    @mock.patch('os.getcwd', return_value='/current/working/directory')\n    def test_command_failure(self, mock_getcwd, mock_run, mock_logger):\n        \"\"\"Test handling of non-zero exit code from the pigar command.\"\"\"\n        mock_run.return_value = subprocess.CompletedProcess([], 1)\n        dependency_file_path = 'requirements.txt'\n        log_project_dependencies(dependency_file_path)\n        mock_logger.info.assert_any_call(\"Capturing dependencies...\")\n        expected_command = ['pigar', 'gen', '-f', 'requirements.txt', '/current/working/directory']\n        mock_logger.info.assert_any_call(\"Running command: %s\", expected_command)\n        mock_logger.error.assert_called_once_with(\n            \"Failed to capture dependencies; command exited with code %d.\", 1\n        )\n\n    @mock.patch('__main__.logger')\n    @mock.patch('subprocess.run')\n    @mock.patch('os.getcwd', return_value='/current/working/directory')\n    def test_non_string_path_with_pigar_installed(self, mock_getcwd, mock_run, mock_logger):\n        \"\"\"Test TypeError when dependency_file_path is not a string and pigar is installed.\"\"\"\n        with mock.patch('builtins.__import__', return_value=mock.MagicMock()):\n            with self.assertRaises(TypeError):\n                log_project_dependencies(123)\n        mock_logger.info.assert_called_once_with(\"Capturing dependencies...\")\n        mock_run.assert_not_called()\n\n    @mock.patch('__main__.logger')\n    @mock.patch('subprocess.run')\n    @mock.patch('os.getcwd')\n    def test_non_string_path_with_pigar_not_installed(self, mock_getcwd, mock_run, mock_logger):\n        \"\"\"Test non-string dependency_file_path when pigar is not installed.\"\"\"\n        with mock.patch('builtins.__import__') as mock_import:\n            mock_import.side_effect = ModuleNotFoundError(\"No module named 'pigar'\")\n            log_project_dependencies(123)\n        mock_logger.info.assert_called_once_with(\"Capturing dependencies...\")\n        mock_logger.warning.assert_called_once_with(\n            \"pigar module is not installed, dependency capture might be incomplete.\"\n        )\n        mock_run.assert_not_called()\n", "num_test_cases": 5, "task_id": "f01d7921"}
{"test": "import unittest\nfrom unittest.mock import patch, MagicMock\n\n# Import placeholder - replace 'module_under_test' with the actual module name\nfrom module_under_test import fetch_project_dependencies\n\nclass TestFetchProjectDependencies(unittest.TestCase):\n    @patch('module_under_test.subprocess.run')\n    @patch('module_under_test.os.getcwd', return_value='/current/dir')\n    @patch('module_under_test.logger')\n    @patch('module_under_test.logging')\n    def test_successful_dependency_capture(self, mock_logging, mock_logger, mock_getcwd, mock_run):\n        \"\"\"Test dependency capture with valid inputs and successful execution.\"\"\"\n        mock_run.return_value = MagicMock(returncode=0)\n        \n        with patch('builtins.__import__', return_value=MagicMock()):\n            fetch_project_dependencies('requirements.txt')\n        \n        mock_logger.info.assert_any_call(\"Capturing dependencies...\")\n        mock_run.assert_called_once_with(['pigar', 'gen', '-f', 'requirements.txt', '/current/dir'])\n        mock_logger.info.assert_any_call(\"Running command: %s\", ['pigar', 'gen', '-f', 'requirements.txt', '/current/dir'])\n        mock_logger.info.assert_any_call(\"Dependencies captured successfully.\")\n        mock_logger.error.assert_not_called()\n        mock_logging.warning.assert_not_called()\n\n    @patch('module_under_test.subprocess.run')\n    @patch('module_under_test.os.getcwd', return_value='/current/dir')\n    @patch('module_under_test.logger')\n    @patch('module_under_test.logging')\n    def test_command_failure(self, mock_logging, mock_logger, mock_getcwd, mock_run):\n        \"\"\"Test handling of non-zero exit code from the command.\"\"\"\n        mock_run.return_value = MagicMock(returncode=1)\n        \n        with patch('builtins.__import__', return_value=MagicMock()):\n            fetch_project_dependencies('requirements.txt')\n        \n        mock_logger.info.assert_any_call(\"Capturing dependencies...\")\n        mock_run.assert_called_once_with(['pigar', 'gen', '-f', 'requirements.txt', '/current/dir'])\n        mock_logger.info.assert_any_call(\"Running command: %s\", ['pigar', 'gen', '-f', 'requirements.txt', '/current/dir'])\n        mock_logger.error.assert_called_once_with(\"Failed to capture dependencies; command exited with code %d.\", 1)\n        mock_logging.warning.assert_not_called()\n\n    @patch('module_under_test.subprocess.run')\n    @patch('module_under_test.logger')\n    @patch('module_under_test.logging')\n    def test_missing_pigar(self, mock_logging, mock_logger, mock_run):\n        \"\"\"Test handling of missing pigar module.\"\"\"\n        with patch('builtins.__import__', side_effect=ModuleNotFoundError(\"No module named 'pigar'\")):\n            fetch_project_dependencies('requirements.txt')\n        \n        mock_logger.info.assert_called_once_with(\"Capturing dependencies...\")\n        mock_logging.warning.assert_called_once_with(\n            \"pigar module is not installed, dependency capture might be incomplete.\"\n        )\n        mock_run.assert_not_called()\n        mock_logger.error.assert_not_called()\n\n    @patch('module_under_test.subprocess.run')\n    @patch('module_under_test.os.getcwd', return_value='/current/dir')\n    @patch('module_under_test.logger')\n    @patch('module_under_test.logging')\n    def test_empty_dep_file_path(self, mock_logging, mock_logger, mock_getcwd, mock_run):\n        \"\"\"Test with empty dependency file path.\"\"\"\n        mock_run.return_value = MagicMock(returncode=0)\n        \n        with patch('builtins.__import__', return_value=MagicMock()):\n            fetch_project_dependencies('')\n        \n        mock_logger.info.assert_any_call(\"Capturing dependencies...\")\n        mock_run.assert_called_once_with(['pigar', 'gen', '-f', '', '/current/dir'])\n        mock_logger.info.assert_any_call(\"Running command: %s\", ['pigar', 'gen', '-f', '', '/current/dir'])\n        mock_logger.info.assert_any_call(\"Dependencies captured successfully.\")\n        mock_logger.error.assert_not_called()\n        mock_logging.warning.assert_not_called()\n\n    @patch('module_under_test.subprocess.run')\n    @patch('module_under_test.os.getcwd')\n    @patch('module_under_test.logger')\n    @patch('module_under_test.logging')\n    def test_non_string_dep_file_path(self, mock_logging, mock_logger, mock_getcwd, mock_run):\n        \"\"\"Test type error when dependency file path is not a string.\"\"\"\n        with self.assertRaises(TypeError):\n            fetch_project_dependencies(123)\n        \n        mock_logger.info.assert_called_once_with(\"Capturing dependencies...\")\n        mock_run.assert_not_called()\n        mock_logging.warning.assert_not_called()\n\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 5, "task_id": "8efbc5c0"}
{"test": "import unittest\nfrom unittest.mock import patch, MagicMock\nimport builtins\nimport logging\n\nclass TestGatherProjectDependencies(unittest.TestCase):\n\n    @patch('dependency_utils.logger')\n    @patch('os.getcwd')\n    @patch('subprocess.run')\n    def test_case_1(self, mock_run, mock_getcwd, mock_logger):\n        \"\"\"Test happy path: pigar installed and command successful.\"\"\"\n        mock_getcwd.return_value = '/fake/path'\n        mock_run.return_value = MagicMock(returncode=0)\n        \n        gather_project_dependencies('requirements.txt')\n        \n        mock_logger.info.assert_any_call('Capturing dependencies...')\n        mock_logger.info.assert_any_call('Running command: %s', ['pigar', 'gen', '-f', 'requirements.txt', '/fake/path'])\n        mock_logger.info.assert_any_call('Dependencies captured successfully.')\n        mock_run.assert_called_once_with(['pigar', 'gen', '-f', 'requirements.txt', '/fake/path'])\n\n    @patch('dependency_utils.logger')\n    @patch('os.getcwd')\n    @patch('subprocess.run')\n    def test_case_2(self, mock_run, mock_getcwd, mock_logger):\n        \"\"\"Test when pigar is installed and command fails.\"\"\"\n        mock_getcwd.return_value = '/fake/path'\n        mock_run.return_value = MagicMock(returncode=1)\n        \n        gather_project_dependencies('requirements.txt')\n        \n        mock_logger.info.assert_any_call('Capturing dependencies...')\n        mock_logger.info.assert_any_call('Running command: %s', ['pigar', 'gen', '-f', 'requirements.txt', '/fake/path'])\n        mock_logger.error.assert_called_once_with('Failed to capture dependencies; command exited with code %d.', 1)\n\n    @patch('dependency_utils.logger')\n    @patch('logging.warning')\n    def test_case_3(self, mock_warning, mock_logger):\n        \"\"\"Test when pigar is not installed.\"\"\"\n        def import_side_effect(module_name, *args, **kwargs):\n            if module_name == 'pigar':\n                raise ModuleNotFoundError(\"No module named 'pigar'\")\n            return builtins.__import__(module_name, *args, **kwargs)\n        \n        with patch('dependency_utils.__import__', side_effect=import_side_effect):\n            gather_project_dependencies('requirements.txt')\n        \n        mock_logger.info.assert_called_once_with('Capturing dependencies...')\n        mock_warning.assert_called_once_with('pigar module is not installed, dependency capture might be incomplete.')\n\n    @patch('dependency_utils.logger')\n    @patch('os.getcwd')\n    @patch('subprocess.run')\n    def test_case_4(self, mock_run, mock_getcwd, mock_logger):\n        \"\"\"Test with empty string for req_file_path.\"\"\"\n        mock_getcwd.return_value = '/fake/path'\n        mock_run.return_value = MagicMock(returncode=0)\n        \n        gather_project_dependencies('')\n        \n        mock_logger.info.assert_any_call('Running command: %s', ['pigar', 'gen', '-f', '', '/fake/path'])\n        mock_run.assert_called_once_with(['pigar', 'gen', '-f', '', '/fake/path'])\n\n    @patch('dependency_utils.logger')\n    @patch('os.getcwd')\n    @patch('subprocess.run')\n    def test_case_5(self, mock_run, mock_getcwd, mock_logger):\n        \"\"\"Test with path containing special characters.\"\"\"\n        mock_getcwd.return_value = '/fake/path'\n        mock_run.return_value = MagicMock(returncode=0)\n        \n        gather_project_dependencies('my requirements.txt')\n        \n        mock_logger.info.assert_any_call('Running command: %s', ['pigar', 'gen', '-f', 'my requirements.txt', '/fake/path'])\n        mock_run.assert_called_once_with(['pigar', 'gen', '-f', 'my requirements.txt', '/fake/path'])\n\n    @patch('dependency_utils.logger')\n    @patch('os.getcwd')\n    @patch('subprocess.run')\n    def test_case_6(self, mock_run, mock_getcwd, mock_logger):\n        \"\"\"Test when subprocess.run raises FileNotFoundError.\"\"\"\n        mock_getcwd.return_value = '/fake/path'\n        mock_run.side_effect = FileNotFoundError(\"pigar command not found\")\n        \n        with self.assertRaises(FileNotFoundError):\n            gather_project_dependencies('requirements.txt')\n        \n        mock_logger.info.assert_any_call('Capturing dependencies...')\n        mock_logger.info.assert_any_call('Running command: %s', ['pigar', 'gen', '-f', 'requirements.txt', '/fake/path'])\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 6, "task_id": "5884f057"}
{"test": "import unittest\nfrom unittest.mock import patch, MagicMock\n\nclass TestGatherDependencies(unittest.TestCase):\n    \n    @patch('builtins.__import__', return_value=MagicMock())\n    @patch('solution.subprocess.run')\n    @patch('solution.os.getcwd')\n    @patch('solution.logger')\n    @patch('solution.logging')\n    def test_happy_path_success(self, mock_logging, mock_logger, mock_getcwd, mock_run, mock_import):\n        \"\"\"Test typical case: pigar available, command executes successfully.\"\"\"\n        mock_getcwd.return_value = '/project'\n        mock_run.return_value = MagicMock(returncode=0)\n        \n        output_path = 'requirements.txt'\n        result = gather_dependencies(output_path)\n        \n        mock_logger.info.assert_any_call(\"Capturing dependencies...\")\n        mock_run.assert_called_once_with(['pigar', 'gen', '-f', output_path, '/project'])\n        mock_logger.info.assert_any_call(\"Running command: %s\", ['pigar', 'gen', '-f', output_path, '/project'])\n        mock_logger.info.assert_any_call(\"Dependencies captured successfully.\")\n        self.assertIsNone(result)\n    \n    @patch('builtins.__import__', side_effect=ModuleNotFoundError)\n    @patch('solution.logger')\n    @patch('solution.logging')\n    def test_pigar_not_available(self, mock_logging, mock_logger, mock_import):\n        \"\"\"Test when pigar module is missing - should log warning and return.\"\"\"\n        output_path = 'requirements.txt'\n        result = gather_dependencies(output_path)\n        \n        mock_logger.info.assert_called_with(\"Capturing dependencies...\")\n        mock_logging.warning.assert_called_with(\"pigar module is not installed, dependency capture might be incomplete.\")\n        self.assertIsNone(result)\n    \n    @patch('builtins.__import__', return_value=MagicMock())\n    @patch('solution.subprocess.run')\n    @patch('solution.os.getcwd')\n    @patch('solution.logger')\n    @patch('solution.logging')\n    def test_command_failure(self, mock_logging, mock_logger, mock_getcwd, mock_run, mock_import):\n        \"\"\"Test when command execution fails - should log error with exit code.\"\"\"\n        mock_getcwd.return_value = '/project'\n        mock_run.return_value = MagicMock(returncode=1)\n        \n        output_path = 'requirements.txt'\n        result = gather_dependencies(output_path)\n        \n        mock_logger.error.assert_called_with(\"Failed to capture dependencies; command exited with code %d.\", 1)\n        self.assertIsNone(result)\n    \n    @patch('builtins.__import__', return_value=MagicMock())\n    @patch('solution.subprocess.run')\n    @patch('solution.os.getcwd')\n    @patch('solution.logger')\n    @patch('solution.logging')\n    def test_empty_output_path(self, mock_logging, mock_logger, mock_getcwd, mock_run, mock_import):\n        \"\"\"Test edge case: empty output path.\"\"\"\n        mock_getcwd.return_value = '/project'\n        mock_run.return_value = MagicMock(returncode=0)\n        \n        output_path = ''\n        result = gather_dependencies(output_path)\n        \n        mock_run.assert_called_once_with(['pigar', 'gen', '-f', '', '/project'])\n        self.assertIsNone(result)\n    \n    @patch('builtins.__import__', return_value=MagicMock())\n    @patch('solution.subprocess.run')\n    @patch('solution.os.getcwd')\n    @patch('solution.logger')\n    @patch('solution.logging')\n    def test_output_path_none(self, mock_logging, mock_logger, mock_getcwd, mock_run, mock_import):\n        \"\"\"Test invalid input: output_path is None - should raise TypeError.\"\"\"\n        mock_getcwd.return_value = '/project'\n        \n        with self.assertRaises(TypeError):\n            gather_dependencies(None)\n        mock_run.assert_not_called()\n    \n    @patch('builtins.__import__', return_value=MagicMock())\n    @patch('solution.subprocess.run')\n    @patch('solution.os.getcwd')\n    @patch('solution.logger')\n    @patch('solution.logging')\n    def test_non_string_output_path(self, mock_logging, mock_logger, mock_getcwd, mock_run, mock_import):\n        \"\"\"Test invalid input: output_path is not a string - should raise TypeError.\"\"\"\n        mock_getcwd.return_value = '/project'\n        \n        with self.assertRaises(TypeError):\n            gather_dependencies(123)\n        mock_run.assert_not_called()\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 6, "task_id": "46d6bb87"}
{"test": "import unittest\nfrom unittest.mock import patch, MagicMock\nimport sys\n\nfrom solution import list_dependencies\n\nclass TestListDependencies(unittest.TestCase):\n\n    @patch('solution.subprocess.run')\n    @patch('solution.os.getcwd')\n    @patch('solution.logger')\n    @patch('solution.logging')\n    @patch.dict('sys.modules', {'pigar': MagicMock()})\n    def test_pigar_installed_success(self, mock_logging, mock_logger, mock_cwd, mock_run):\n        \"\"\"Test with pigar installed and command successful.\"\"\"\n        mock_cwd.return_value = '/current/path'\n        mock_run.return_value = MagicMock(returncode=0)\n        \n        file_path = 'requirements.txt'\n        list_dependencies(file_path)\n        \n        mock_logger.info.assert_any_call(\"Capturing dependencies...\")\n        mock_logger.info.assert_any_call(\"Running command: %s\", ['pigar', 'gen', '-f', file_path, '/current/path'])\n        mock_logger.info.assert_any_call(\"Dependencies captured successfully.\")\n        mock_logger.error.assert_not_called()\n        mock_logging.warning.assert_not_called()\n\n    @patch('solution.subprocess.run')\n    @patch('solution.os.getcwd')\n    @patch('solution.logger')\n    @patch('solution.logging')\n    @patch.dict('sys.modules', {'pigar': MagicMock()})\n    def test_pigar_installed_failure(self, mock_logging, mock_logger, mock_cwd, mock_run):\n        \"\"\"Test with pigar installed but command fails (non-zero exit code).\"\"\"\n        mock_cwd.return_value = '/current/path'\n        mock_run.return_value = MagicMock(returncode=1)\n        \n        file_path = 'requirements.txt'\n        list_dependencies(file_path)\n        \n        mock_logger.info.assert_any_call(\"Capturing dependencies...\")\n        mock_logger.info.assert_any_call(\"Running command: %s\", ['pigar', 'gen', '-f', file_path, '/current/path'])\n        mock_logger.error.assert_called_once_with(\"Failed to capture dependencies; command exited with code %d.\", 1)\n        self.assertEqual(mock_logger.info.call_count, 2)  # Only initial and command logs\n\n    @patch('solution.subprocess.run')\n    @patch('solution.logger')\n    @patch('solution.logging')\n    def test_pigar_not_installed(self, mock_logging, mock_logger, mock_run):\n        \"\"\"Test when pigar is not installed.\"\"\"\n        file_path = 'requirements.txt'\n        list_dependencies(file_path)\n        \n        mock_logger.info.assert_called_once_with(\"Capturing dependencies...\")\n        mock_logging.warning.assert_called_once_with(\n            \"pigar module is not installed, dependency capture might be incomplete.\"\n        )\n        mock_run.assert_not_called()\n\n    @patch('solution.subprocess.run')\n    @patch('solution.os.getcwd')\n    @patch('solution.logger')\n    @patch('solution.logging')\n    @patch.dict('sys.modules', {'pigar': MagicMock()})\n    def test_empty_file_path(self, mock_logging, mock_logger, mock_cwd, mock_run):\n        \"\"\"Test with empty file path.\"\"\"\n        mock_cwd.return_value = '/current/path'\n        mock_run.return_value = MagicMock(returncode=0)\n        \n        file_path = ''\n        list_dependencies(file_path)\n        \n        mock_logger.info.assert_any_call(\"Running command: %s\", ['pigar', 'gen', '-f', '', '/current/path'])\n\n    @patch('solution.subprocess.run')\n    @patch('solution.os.getcwd')\n    @patch('solution.logger')\n    @patch('solution.logging')\n    @patch.dict('sys.modules', {'pigar': MagicMock()})\n    def test_absolute_file_path(self, mock_logging, mock_logger, mock_cwd, mock_run):\n        \"\"\"Test with absolute file path.\"\"\"\n        mock_cwd.return_value = '/current/path'\n        mock_run.return_value = MagicMock(returncode=0)\n        \n        file_path = '/absolute/path/requirements.txt'\n        list_dependencies(file_path)\n        \n        mock_logger.info.assert_any_call(\"Running command: %s\", ['pigar', 'gen', '-f', file_path, '/current/path'])\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 5, "task_id": "4215fd7f"}
{"test": "import unittest\nimport subprocess\nfrom unittest.mock import patch, MagicMock, call\nimport builtins\n\nclass TestFetchDependencies(unittest.TestCase):\n    def setUp(self):\n        # Patch the logger, logging, and os.getcwd in the solution module\n        self.logger_patcher = patch('solution.logger')\n        self.logging_patcher = patch('solution.logging')\n        self.os_patcher = patch('solution.os')\n        \n        self.mock_logger = self.logger_patcher.start()\n        self.mock_logging = self.logging_patcher.start()\n        self.mock_os = self.os_patcher.start()\n        \n        # Configure os.getcwd to return a default value\n        self.mock_os.getcwd.return_value = '/default/current/directory'\n        \n    def tearDown(self):\n        # Stop all patchers\n        self.logger_patcher.stop()\n        self.logging_patcher.stop()\n        self.os_patcher.stop()\n    \n    def _mock_import(self, module_name, should_raise=False):\n        \"\"\"Helper to mock module imports during tests.\"\"\"\n        original_import = builtins.__import__\n        \n        def custom_import(name, *args, **kwargs):\n            if name == module_name:\n                if should_raise:\n                    raise ModuleNotFoundError(f\"No module named '{module_name}'\")\n                else:\n                    return MagicMock()\n            return original_import(name, *args, **kwargs)\n            \n        return patch('builtins.__import__', side_effect=custom_import)\n\n    def test_successful_dependency_capture(self):\n        \"\"\"Test successful execution with pigar installed and command success.\"\"\"\n        with self._mock_import('pigar', should_raise=False), \\\n             patch('solution.subprocess.run') as mock_run:\n            \n            # Configure subprocess.run to return a successful exit code\n            mock_run.return_value = subprocess.CompletedProcess([], 0)\n            \n            # Call the function\n            dep_output_path = 'requirements.txt'\n            solution.fetch_dependencies(dep_output_path)\n            \n            # Verify logging\n            self.mock_logger.info.assert_any_call(\"Capturing dependencies...\")\n            expected_command = ['pigar', 'gen', '-f', dep_output_path, '/default/current/directory']\n            self.mock_logger.info.assert_any_call(\"Running command: %s\", expected_command)\n            self.mock_logger.info.assert_any_call(\"Dependencies captured successfully.\")\n            self.mock_logger.error.assert_not_called()\n            \n            # Verify subprocess call\n            mock_run.assert_called_once_with(expected_command)\n\n    def test_pigar_not_installed(self):\n        \"\"\"Test behavior when pigar module is not installed.\"\"\"\n        with self._mock_import('pigar', should_raise=True), \\\n             patch('solution.subprocess.run') as mock_run:\n            \n            # Call the function\n            dep_output_path = 'requirements.txt'\n            solution.fetch_dependencies(dep_output_path)\n            \n            # Verify logging\n            self.mock_logger.info.assert_called_once_with(\"Capturing dependencies...\")\n            self.mock_logging.warning.assert_called_once_with(\n                \"pigar module is not installed, dependency capture might be incomplete.\"\n            )\n            # Verify subprocess was not called\n            mock_run.assert_not_called()\n\n    def test_command_failure(self):\n        \"\"\"Test handling when the pigar command fails (non-zero exit code).\"\"\"\n        with self._mock_import('pigar', should_raise=False), \\\n             patch('solution.subprocess.run') as mock_run:\n            \n            # Configure subprocess.run to return a failed exit code\n            mock_run.return_value = subprocess.CompletedProcess([], 1)\n            \n            # Call the function\n            dep_output_path = 'requirements.txt'\n            solution.fetch_dependencies(dep_output_path)\n            \n            # Verify error logging\n            self.mock_logger.info.assert_any_call(\"Capturing dependencies...\")\n            expected_command = ['pigar', 'gen', '-f', dep_output_path, '/default/current/directory']\n            self.mock_logger.info.assert_any_call(\"Running command: %s\", expected_command)\n            self.mock_logger.error.assert_called_once_with(\n                \"Failed to capture dependencies; command exited with code %d.\", 1\n            )\n\n    def test_command_format(self):\n        \"\"\"Test the exact command format with mocked paths.\"\"\"\n        with self._mock_import('pigar', should_raise=False), \\\n             patch('solution.subprocess.run') as mock_run, \\\n             patch('solution.os.getcwd') as mock_cwd:\n            \n            # Configure specific paths\n            mock_cwd.return_value = '/specific/current/directory'\n            dep_output_path = '/specific/output/requirements.txt'\n            \n            # Call the function\n            solution.fetch_dependencies(dep_output_path)\n            \n            # Verify command format\n            expected_command = ['pigar', 'gen', '-f', dep_output_path, '/specific/current/directory']\n            mock_run.assert_called_once_with(expected_command)\n            self.mock_logger.info.assert_any_call(\"Running command: %s\", expected_command)\n\n    def test_empty_output_path(self):\n        \"\"\"Test behavior with an empty output path string.\"\"\"\n        with self._mock_import('pigar', should_raise=False), \\\n             patch('solution.subprocess.run') as mock_run:\n            \n            # Call with empty path\n            solution.fetch_dependencies('')\n            \n            # Verify command includes empty string\n            expected_command = ['pigar', 'gen', '-f', '', '/default/current/directory']\n            mock_run.assert_called_once_with(expected_command)\n\n    def test_none_output_path(self):\n        \"\"\"Test that passing None as output path raises TypeError.\"\"\"\n        with self._mock_import('pigar', should_raise=False), \\\n             patch('solution.subprocess.run') as mock_run:\n            \n            # Call with None and expect TypeError\n            with self.assertRaises(TypeError):\n                solution.fetch_dependencies(None)\n            \n            # Verify subprocess not called\n            mock_run.assert_not_called()\n\n    def test_getcwd_exception(self):\n        \"\"\"Test handling when os.getcwd() raises an exception.\"\"\"\n        with self._mock_import('pigar', should_raise=False), \\\n             patch('solution.os.getcwd') as mock_cwd:\n            \n            # Configure getcwd to raise an exception\n            mock_cwd.side_effect = FileNotFoundError(\"Current directory not accessible\")\n            \n            # Call the function and expect the exception\n            with self.assertRaises(FileNotFoundError):\n                solution.fetch_dependencies('requirements.txt')\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 7, "task_id": "5e113fa2"}
{"test": "import unittest\nfrom unittest.mock import patch, MagicMock, call\nimport sys\nimport logging\n\nclass TestGatherDependencies(unittest.TestCase):\n\n    @patch('subprocess.run')\n    @patch('os.getcwd', return_value='/mock/cwd')\n    def test_happy_path(self, mock_cwd, mock_run):\n        \"\"\"Test with valid output_file and successful command execution.\"\"\"\n        with patch.dict('sys.modules', {'pigar': MagicMock()}):\n            mock_logger = MagicMock()\n            with patch('solution.logger', mock_logger):\n                mock_run.return_value = MagicMock(returncode=0)\n                output_file = 'requirements.txt'\n                from solution import gather_dependencies\n                gather_dependencies(output_file)\n                \n                expected_command = ['pigar', 'gen', '-f', output_file, '/mock/cwd']\n                mock_run.assert_called_once_with(expected_command)\n                mock_logger.info.assert_has_calls([\n                    call(\"Capturing project dependencies...\"),\n                    call(\"Running command: %s\", expected_command),\n                    call(\"Dependencies captured successfully.\")\n                ])\n\n    @patch('subprocess.run')\n    def test_pigar_not_installed(self, mock_run):\n        \"\"\"Test when pigar is not installed.\"\"\"\n        if 'pigar' in sys.modules:\n            del sys.modules['pigar']\n        with patch('builtins.__import__', side_effect=ModuleNotFoundError(\"No module named 'pigar'\")):\n            mock_logger = MagicMock()\n            mock_warning = MagicMock()\n            with patch('solution.logger', mock_logger), \\\n                 patch('logging.warning', mock_warning):\n                output_file = 'requirements.txt'\n                from solution import gather_dependencies\n                gather_dependencies(output_file)\n                \n                mock_warning.assert_called_once_with(\n                    \"pigar module is not installed, dependency capture might be incomplete.\"\n                )\n                mock_logger.info.assert_called_once_with(\"Capturing project dependencies...\")\n                mock_run.assert_not_called()\n\n    @patch('subprocess.run')\n    @patch('os.getcwd', return_value='/mock/cwd')\n    def test_command_failure(self, mock_cwd, mock_run):\n        \"\"\"Test when pigar command fails with non-zero exit code.\"\"\"\n        with patch.dict('sys.modules', {'pigar': MagicMock()}):\n            mock_logger = MagicMock()\n            with patch('solution.logger', mock_logger):\n                mock_run.return_value = MagicMock(returncode=1)\n                output_file = 'requirements.txt'\n                from solution import gather_dependencies\n                gather_dependencies(output_file)\n                \n                expected_command = ['pigar', 'gen', '-f', output_file, '/mock/cwd']\n                mock_run.assert_called_once_with(expected_command)\n                mock_logger.info.assert_has_calls([\n                    call(\"Capturing project dependencies...\"),\n                    call(\"Running command: %s\", expected_command)\n                ])\n                mock_logger.error.assert_called_once_with(\n                    \"Failed to capture dependencies; command exited with code %d.\", 1\n                )\n\n    @patch('subprocess.run')\n    @patch('os.getcwd', return_value='/mock/cwd')\n    def test_empty_output_file(self, mock_cwd, mock_run):\n        \"\"\"Test with empty output_file string.\"\"\"\n        with patch.dict('sys.modules', {'pigar': MagicMock()}):\n            mock_logger = MagicMock()\n            with patch('solution.logger', mock_logger):\n                mock_run.return_value = MagicMock(returncode=0)\n                output_file = ''\n                from solution import gather_dependencies\n                gather_dependencies(output_file)\n                \n                expected_command = ['pigar', 'gen', '-f', '', '/mock/cwd']\n                mock_run.assert_called_once_with(expected_command)\n                mock_logger.info.assert_any_call(\"Running command: %s\", expected_command)\n\n    @patch('subprocess.run')\n    @patch('os.getcwd', return_value='/mock/cwd')\n    def test_output_file_with_spaces(self, mock_cwd, mock_run):\n        \"\"\"Test with output_file containing spaces.\"\"\"\n        with patch.dict('sys.modules', {'pigar': MagicMock()}):\n            mock_logger = MagicMock()\n            with patch('solution.logger', mock_logger):\n                mock_run.return_value = MagicMock(returncode=0)\n                output_file = 'my requirements.txt'\n                from solution import gather_dependencies\n                gather_dependencies(output_file)\n                \n                expected_command = ['pigar', 'gen', '-f', 'my requirements.txt', '/mock/cwd']\n                mock_run.assert_called_once_with(expected_command)\n                mock_logger.info.assert_any_call(\"Running command: %s\", expected_command)\n\n    def test_none_output_file_pigar_not_installed(self):\n        \"\"\"Test with None output_file when pigar is not installed.\"\"\"\n        if 'pigar' in sys.modules:\n            del sys.modules['pigar']\n        with patch('builtins.__import__', side_effect=ModuleNotFoundError(\"No module named 'pigar'\")):\n            mock_logger = MagicMock()\n            mock_warning = MagicMock()\n            with patch('solution.logger', mock_logger), \\\n                 patch('logging.warning', mock_warning):\n                from solution import gather_dependencies\n                gather_dependencies(None)\n                \n                mock_warning.assert_called_once_with(\n                    \"pigar module is not installed, dependency capture might be incomplete.\"\n                )\n                mock_logger.info.assert_called_once_with(\"Capturing project dependencies...\")\n\n    @patch('subprocess.run')\n    @patch('os.getcwd', return_value='/mock/cwd')\n    def test_none_output_file_pigar_installed(self, mock_cwd, mock_run):\n        \"\"\"Test with None output_file when pigar is installed.\"\"\"\n        with patch.dict('sys.modules', {'pigar': MagicMock()}):\n            mock_logger = MagicMock()\n            with patch('solution.logger', mock_logger):\n                mock_run.side_effect = TypeError(\"NoneType in command\")\n                from solution import gather_dependencies\n                with self.assertRaises(TypeError):\n                    gather_dependencies(None)", "num_test_cases": 7, "task_id": "904387e7"}
{"test": "import unittest\nfrom unittest import mock\nfrom solution import extract_dependencies\n\nclass TestExtractDependencies(unittest.TestCase):\n    @mock.patch('solution.logger')\n    @mock.patch('solution.logging')\n    @mock.patch('solution.subprocess.run')\n    @mock.patch('solution.os.getcwd')\n    @mock.patch('builtins.__import__')\n    def test_happy_path(self, mock_import, mock_getcwd, mock_run, mock_logging, mock_logger):\n        \"\"\"Test with valid inputs and successful dependency capture.\"\"\"\n        mock_import.side_effect = lambda name, *args, **kwargs: mock.MagicMock()\n        mock_getcwd.return_value = '/current/directory'\n        mock_run.return_value = mock.Mock(returncode=0)\n        \n        output_path = 'requirements.txt'\n        extract_dependencies(output_path)\n        \n        expected_command = ['pigar', 'gen', '-f', output_path, '/current/directory']\n        mock_run.assert_called_once_with(expected_command)\n        mock_logger.info.assert_any_call(\"Capturing project dependencies...\")\n        mock_logger.info.assert_any_call(\"Running command: %s\", expected_command)\n        mock_logger.info.assert_any_call(\"Dependencies captured successfully.\")\n        mock_logger.error.assert_not_called()\n        mock_logging.warning.assert_not_called()\n\n    @mock.patch('solution.logger')\n    @mock.patch('solution.logging')\n    @mock.patch('solution.subprocess.run')\n    @mock.patch('solution.os.getcwd')\n    @mock.patch('builtins.__import__')\n    def test_missing_pigar(self, mock_import, mock_getcwd, mock_run, mock_logging, mock_logger):\n        \"\"\"Test when pigar is not installed.\"\"\"\n        def import_side_effect(name, *args, **kwargs):\n            if name == 'pigar':\n                raise ModuleNotFoundError\n            return mock.MagicMock()\n        mock_import.side_effect = import_side_effect\n        \n        output_path = 'requirements.txt'\n        extract_dependencies(output_path)\n        \n        mock_run.assert_not_called()\n        mock_logger.info.assert_called_once_with(\"Capturing project dependencies...\")\n        mock_logging.warning.assert_called_once_with(\n            \"pigar module is not installed, dependency capture might be incomplete.\"\n        )\n\n    @mock.patch('solution.logger')\n    @mock.patch('solution.logging')\n    @mock.patch('solution.subprocess.run')\n    @mock.patch('solution.os.getcwd')\n    @mock.patch('builtins.__import__')\n    def test_command_failure(self, mock_import, mock_getcwd, mock_run, mock_logging, mock_logger):\n        \"\"\"Test when the pigar command fails with a non-zero exit code.\"\"\"\n        mock_import.side_effect = lambda name, *args, **kwargs: mock.MagicMock()\n        mock_getcwd.return_value = '/current/directory'\n        mock_run.return_value = mock.Mock(returncode=1)\n        \n        output_path = 'requirements.txt'\n        extract_dependencies(output_path)\n        \n        expected_command = ['pigar', 'gen', '-f', output_path, '/current/directory']\n        mock_run.assert_called_once_with(expected_command)\n        mock_logger.info.assert_any_call(\"Capturing project dependencies...\")\n        mock_logger.info.assert_any_call(\"Running command: %s\", expected_command)\n        mock_logger.error.assert_called_once_with(\n            \"Failed to capture dependencies; command exited with code %d.\", 1\n        )\n\n    @mock.patch('solution.logger')\n    @mock.patch('solution.logging')\n    @mock.patch('solution.subprocess.run')\n    @mock.patch('solution.os.getcwd')\n    @mock.patch('builtins.__import__')\n    def test_empty_output_path(self, mock_import, mock_getcwd, mock_run, mock_logging, mock_logger):\n        \"\"\"Test with an empty output_path string.\"\"\"\n        mock_import.side_effect = lambda name, *args, **kwargs: mock.MagicMock()\n        mock_getcwd.return_value = '/current/directory'\n        mock_run.return_value = mock.Mock(returncode=0)\n        \n        output_path = ''\n        extract_dependencies(output_path)\n        \n        expected_command = ['pigar', 'gen', '-f', '', '/current/directory']\n        mock_run.assert_called_once_with(expected_command)\n        mock_logger.info.assert_any_call(\"Running command: %s\", expected_command)\n\n    @mock.patch('solution.logger')\n    @mock.patch('solution.logging')\n    @mock.patch('solution.subprocess.run')\n    @mock.patch('solution.os.getcwd')\n    @mock.patch('builtins.__import__')\n    def test_invalid_output_path_type(self, mock_import, mock_getcwd, mock_run, mock_logging, mock_logger):\n        \"\"\"Test with a non-string output_path (None) causing a TypeError.\"\"\"\n        def run_side_effect(command):\n            for item in command:\n                if not isinstance(item, str):\n                    raise TypeError(\"Command arguments must be strings\")\n            return mock.Mock(returncode=0)\n        \n        mock_import.side_effect = lambda name, *args, **kwargs: mock.MagicMock()\n        mock_getcwd.return_value = '/current/directory'\n        mock_run.side_effect = run_side_effect\n        \n        with self.assertRaises(TypeError):\n            extract_dependencies(None)", "num_test_cases": 5, "task_id": "a196f1b3"}
{"test": "import unittest\nfrom unittest.mock import patch, MagicMock\nfrom solution import find_dependencies\n\nclass TestFindDependencies(unittest.TestCase):\n\n    @patch('solution.subprocess.run')\n    @patch('solution.os.getcwd')\n    @patch('solution.logger')\n    def test_happy_path_success(self, mock_logger, mock_getcwd, mock_run):\n        # Test successful execution with valid inputs\n        mock_getcwd.return_value = '/fake/cwd'\n        mock_run.return_value = MagicMock(returncode=0)\n        \n        find_dependencies('requirements.txt')\n        \n        mock_logger.info.assert_any_call(\"Retrieving project dependencies...\")\n        mock_logger.info.assert_any_call(\"Running command: %s\", ['pigar', 'gen', '-f', 'requirements.txt', '/fake/cwd'])\n        mock_logger.info.assert_called_with(\"Dependencies retrieved successfully.\")\n        mock_run.assert_called_once_with(['pigar', 'gen', '-f', 'requirements.txt', '/fake/cwd'])\n\n    @patch('solution.subprocess.run')\n    @patch('solution.os.getcwd')\n    @patch('solution.logger')\n    def test_command_failure(self, mock_logger, mock_getcwd, mock_run):\n        # Test when pigar command fails (non-zero exit code)\n        mock_getcwd.return_value = '/fake/cwd'\n        mock_run.return_value = MagicMock(returncode=1)\n        \n        find_dependencies('req.txt')\n        \n        mock_logger.info.assert_any_call(\"Retrieving project dependencies...\")\n        mock_logger.info.assert_any_call(\"Running command: %s\", ['pigar', 'gen', '-f', 'req.txt', '/fake/cwd'])\n        mock_logger.error.assert_called_once_with(\"Failed to retrieve dependencies; command exited with code %d.\", 1)\n        mock_run.assert_called_once_with(['pigar', 'gen', '-f', 'req.txt', '/fake/cwd'])\n\n    @patch('solution.subprocess.run')\n    @patch('solution.logger')\n    @patch('solution.logging')\n    def test_pigar_not_installed(self, mock_logging, mock_logger, mock_run):\n        # Test when pigar module is not available\n        real_import = __import__\n        def mock_import(name, *args, **kwargs):\n            if name == 'pigar':\n                raise ModuleNotFoundError(\"No module named 'pigar'\")\n            return real_import(name, *args, **kwargs)\n        \n        with patch('builtins.__import__', side_effect=mock_import):\n            find_dependencies('req.txt')\n        \n        mock_logger.info.assert_called_once_with(\"Retrieving project dependencies...\")\n        mock_logging.warning.assert_called_once_with(\n            \"pigar module is not installed, dependency retrieval may not be complete.\"\n        )\n        mock_run.assert_not_called()\n\n    @patch('solution.subprocess.run')\n    @patch('solution.os.getcwd')\n    @patch('solution.logger')\n    def test_empty_result_file(self, mock_logger, mock_getcwd, mock_run):\n        # Test with empty result_file path\n        mock_getcwd.return_value = '/fake/cwd'\n        mock_run.return_value = MagicMock(returncode=0)\n        \n        find_dependencies('')\n        \n        mock_logger.info.assert_any_call(\"Running command: %s\", ['pigar', 'gen', '-f', '', '/fake/cwd'])\n        mock_run.assert_called_once_with(['pigar', 'gen', '-f', '', '/fake/cwd'])\n\n    @patch('solution.logger')\n    def test_none_result_file(self, mock_logger):\n        # Test with None result_file (should raise TypeError)\n        with self.assertRaises(TypeError):\n            find_dependencies(None)\n        mock_logger.info.assert_called_once_with(\"Retrieving project dependencies...\")\n\n    @patch('solution.logger')\n    def test_non_string_result_file(self, mock_logger):\n        # Test with non-string result_file (integer)\n        with self.assertRaises(TypeError):\n            find_dependencies(123)\n        mock_logger.info.assert_called_once_with(\"Retrieving project dependencies...\")\n\n    @patch('solution.subprocess.run')\n    @patch('solution.os.getcwd')\n    @patch('solution.logger')\n    def test_cwd_in_command(self, mock_logger, mock_getcwd, mock_run):\n        # Test current working directory is correctly included in command\n        mock_getcwd.return_value = '/another/cwd'\n        mock_run.return_value = MagicMock(returncode=0)\n        \n        find_dependencies('req.txt')\n        \n        mock_run.assert_called_once_with(['pigar', 'gen', '-f', 'req.txt', '/another/cwd'])\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 7, "task_id": "3371502f"}
{"test": "import unittest\nfrom unittest.mock import patch, MagicMock\nfrom solution import backup_directory\n\nclass TestBackupDirectory(unittest.TestCase):\n\n    @patch('solution.subprocess.run')\n    @patch('solution.logger')\n    def test_success(self, mock_logger, mock_run):\n        \"\"\"Test successful backup creation.\"\"\"\n        mock_run.return_value = MagicMock(returncode=0)\n        backup_directory('/valid/path', 'valid_backup')\n        mock_logger.info.assert_any_call(\"Creating backup...\")\n        mock_logger.info.assert_any_call(\"Running command: %s\", \"tar -czvf valid_backup.tar.gz -C /valid/path .\")\n        mock_logger.info.assert_called_with(\"Backup created successfully.\")\n        mock_run.assert_called_once_with(['tar', '-czvf', 'valid_backup.tar.gz', '-C', '/valid/path', '.'])\n\n    @patch('solution.subprocess.run')\n    @patch('solution.logger')\n    def test_failure(self, mock_logger, mock_run):\n        \"\"\"Test backup failure with non-zero exit code.\"\"\"\n        mock_run.return_value = MagicMock(returncode=1)\n        with self.assertRaises(OSError) as context:\n            backup_directory('/valid/path', 'valid_backup')\n        self.assertEqual(str(context.exception), \"Backup creation failed\")\n        mock_logger.info.assert_any_call(\"Creating backup...\")\n        mock_logger.error.assert_called_with(\"Failed to create backup; command exited with code %d.\", 1)\n\n    @patch('solution.subprocess.run')\n    @patch('solution.logger')\n    def test_command_with_empty_directory(self, mock_logger, mock_run):\n        \"\"\"Test command construction with empty directory path.\"\"\"\n        mock_run.return_value = MagicMock(returncode=0)\n        backup_directory('', 'empty_dir_backup')\n        mock_run.assert_called_once_with(['tar', '-czvf', 'empty_dir_backup.tar.gz', '-C', '', '.'])\n        mock_logger.info.assert_any_call(\"Running command: %s\", \"tar -czvf empty_dir_backup.tar.gz -C  .\")\n\n    @patch('solution.subprocess.run')\n    @patch('solution.logger')\n    def test_command_with_empty_backup_name(self, mock_logger, mock_run):\n        \"\"\"Test command construction with empty backup name.\"\"\"\n        mock_run.return_value = MagicMock(returncode=0)\n        backup_directory('/valid/path', '')\n        mock_run.assert_called_once_with(['tar', '-czvf', '.tar.gz', '-C', '/valid/path', '.'])\n        mock_logger.info.assert_any_call(\"Running command: %s\", \"tar -czvf .tar.gz -C /valid/path .\")\n\n    @patch('solution.subprocess.run')\n    @patch('solution.logger')\n    def test_command_with_non_ascii(self, mock_logger, mock_run):\n        \"\"\"Test command construction with non-ASCII characters.\"\"\"\n        mock_run.return_value = MagicMock(returncode=0)\n        backup_directory('/path/with/ünîcödé', 'bäckup')\n        mock_run.assert_called_once_with(['tar', '-czvf', 'bäckup.tar.gz', '-C', '/path/with/ünîcödé', '.'])\n        mock_logger.info.assert_any_call(\"Running command: %s\", \"tar -czvf bäckup.tar.gz -C /path/with/ünîcödé .\")\n\n    @patch('solution.logger')\n    def test_invalid_input_types(self, mock_logger):\n        \"\"\"Test invalid input types (non-string).\"\"\"\n        with self.assertRaises(TypeError):\n            backup_directory(123, 'backup')\n        with self.assertRaises(TypeError):\n            backup_directory('/valid/path', 456)\n", "num_test_cases": 6, "task_id": "3feac19d"}
