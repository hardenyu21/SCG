{"test": "import unittest\nimport solution\n\nclass TestProcessSSHVersion(unittest.TestCase):\n    def setUp(self):\n        solution.known_versions = [b\"2.0\", b\"1.99\", b\"3.5\"]\n\n    def test_happy_path(self):\n        \"\"\"Test valid version string with extra data.\"\"\"\n        data = b\"SSH-2.0-OpenSSH_8.2\\nHello\"\n        result = solution.process_ssh_version(data)\n        self.assertEqual(result, b\"Hello\")\n\n    def test_empty_input(self):\n        \"\"\"Test empty input raises ConnectionError.\"\"\"\n        with self.assertRaises(ConnectionError) as cm:\n            solution.process_ssh_version(b\"\")\n        self.assertEqual(str(cm.exception), \"No SSH version string found\")\n\n    def test_input_too_long(self):\n        \"\"\"Test data >4096 bytes raises ConnectionError.\"\"\"\n        data = b\"A\" * 4097\n        with self.assertRaises(ConnectionError) as cm:\n            solution.process_ssh_version(data)\n        self.assertEqual(str(cm.exception), \"Peer version string longer than 4KB. Preventing a denial of service attack.\")\n\n    def test_version_without_newline(self):\n        \"\"\"Test version string without newline raises ConnectionError.\"\"\"\n        data = b\"SSH-2.0-OpenSSH_8.2\"\n        with self.assertRaises(ConnectionError) as cm:\n            solution.process_ssh_version(data)\n        self.assertEqual(str(cm.exception), \"No SSH version string found\")\n\n    def test_no_ssh_with_newline(self):\n        \"\"\"Test data without SSH- prefix but with newline returns original.\"\"\"\n        data = b\"Hello\\nWorld\"\n        result = solution.process_ssh_version(data)\n        self.assertEqual(result, data)\n\n    def test_unsupported_version(self):\n        \"\"\"Test unsupported version raises ValueError.\"\"\"\n        data = b\"SSH-3.0-OpenSSH_8.2\\n\"\n        with self.assertRaises(ValueError) as cm:\n            solution.process_ssh_version(data)\n        self.assertEqual(str(cm.exception), \"Unsupported SSH version: b'3.0'\")\n\n    def test_no_ssh_no_newline(self):\n        \"\"\"Test no SSH- and no newline raises ConnectionError.\"\"\"\n        data = b\"HelloWorld\"\n        with self.assertRaises(ConnectionError) as cm:\n            solution.process_ssh_version(data)\n        self.assertEqual(str(cm.exception), \"No SSH version string found\")\n\n    def test_empty_version(self):\n        \"\"\"Test empty version string raises ValueError.\"\"\"\n        data = b\"SSH-\\n\"\n        with self.assertRaises(ValueError) as cm:\n            solution.process_ssh_version(data)\n        self.assertEqual(str(cm.exception), \"Unsupported SSH version: b''\")\n\n    def test_version_with_space(self):\n        \"\"\"Test version string with space in later parts processes correctly.\"\"\"\n        data = b\"SSH-2.0-OpenSSH_8.2 with space\\nMore data\"\n        result = solution.process_ssh_version(data)\n        self.assertEqual(result, b\"More data\")\n\n    def test_multiple_dashes_in_version(self):\n        \"\"\"Test version string with multiple dashes processes correctly.\"\"\"\n        data = b\"SSH-2.0-something-else\\n\"\n        result = solution.process_ssh_version(data)\n        self.assertEqual(result, b\"\")\n", "num_test_cases": 10, "task_id": "70a33aa8"}
{"test": "import unittest\n\n# Define the function and global variable for the tests\nglobal allowed_versions\nallowed_versions = []\n\ndef handle_ssh_version(data_buffer: bytes):\n    if len(data_buffer) > 4096:\n        raise ConnectionError(\"Peer version string longer than 4KB. Preventing a denial of service attack.\")\n    \n    if data_buffer.find(b\"\\n\", data_buffer.find(b\"SSH-\")) == -1:\n        raise ConnectionError(\"No SSH version string found\")\n    \n    lines_of_data = data_buffer.split(b\"\\n\")\n    for line in lines_of_data:\n        if line.startswith(b\"SSH-\"):\n            peer_ver = line.split(b\"-\")[1]\n            if peer_ver not in allowed_versions:\n                raise ValueError(f\"Unsupported SSH version: {peer_ver}\")\n            index = lines_of_data.index(line)\n            data_buffer = b\"\\n\".join(lines_of_data[index + 1:])\n            return data_buffer\n    return data_buffer\n\n\nclass TestSSHVersionHandling(unittest.TestCase):\n    def setUp(self):\n        # Reset allowed_versions before each test\n        global allowed_versions\n        allowed_versions = []\n    \n    def test_valid_version(self):\n        \"\"\"Test with a valid SSH version string and extra data.\"\"\"\n        global allowed_versions\n        allowed_versions = [b'2.0']\n        data = b\"SSH-2.0-OpenSSH_7.9\\nsome extra data\"\n        result = handle_ssh_version(data)\n        self.assertEqual(result, b\"some extra data\")\n    \n    def test_empty_buffer(self):\n        \"\"\"Test with an empty buffer.\"\"\"\n        with self.assertRaises(ConnectionError):\n            handle_ssh_version(b\"\")\n    \n    def test_no_ssh_prefix(self):\n        \"\"\"Test buffer without any SSH- prefix.\"\"\"\n        with self.assertRaises(ConnectionError):\n            handle_ssh_version(b\"Hello\\nWorld\")\n    \n    def test_ssh_prefix_but_no_newline(self):\n        \"\"\"Test SSH version string without a newline terminator.\"\"\"\n        with self.assertRaises(ConnectionError):\n            handle_ssh_version(b\"SSH-2.0-OpenSSH_7.9\")\n    \n    def test_version_not_allowed(self):\n        \"\"\"Test unsupported SSH version.\"\"\"\n        global allowed_versions\n        allowed_versions = [b'2.0']\n        with self.assertRaises(ValueError):\n            handle_ssh_version(b\"SSH-1.5-OpenSSH_7.9\\n\")\n    \n    def test_buffer_too_long(self):\n        \"\"\"Test buffer exceeding 4096 bytes.\"\"\"\n        data = b'x' * 4097\n        with self.assertRaises(ConnectionError) as cm:\n            handle_ssh_version(data)\n        self.assertEqual(str(cm.exception), \"Peer version string longer than 4KB. Preventing a denial of service attack.\")\n    \n    def test_multiple_lines_before_ssh(self):\n        \"\"\"Test buffer with content before the SSH version line.\"\"\"\n        global allowed_versions\n        allowed_versions = [b'2.0']\n        data = b\"Hello\\nSSH-2.0-OpenSSH_7.9\\nextra\"\n        result = handle_ssh_version(data)\n        self.assertEqual(result, b\"extra\")\n    \n    def test_multiple_ssh_lines_takes_first(self):\n        \"\"\"Test that the first SSH version line is processed.\"\"\"\n        global allowed_versions\n        allowed_versions = [b'2.0']\n        data = b\"SSH-1.0\\nSSH-2.0\\nextra\"\n        with self.assertRaises(ValueError):\n            handle_ssh_version(data)\n    \n    def test_after_processing_returns_remaining_buffer(self):\n        \"\"\"Test returning remaining data after SSH version line.\"\"\"\n        global allowed_versions\n        allowed_versions = [b'2.0']\n        data = b\"SSH-2.0\\nline1\\nline2\"\n        result = handle_ssh_version(data)\n        self.assertEqual(result, b\"line1\\nline2\")\n    \n    def test_ssh_prefix_in_middle_of_line(self):\n        \"\"\"Test SSH- not at the start of a line.\"\"\"\n        data = b\"Hello SSH-2.0\\n\"\n        result = handle_ssh_version(data)\n        self.assertEqual(result, data)\n    \n    def test_version_with_carriage_return_allowed(self):\n        \"\"\"Test version with carriage return when allowed.\"\"\"\n        global allowed_versions\n        allowed_versions = [b'2.0\\r']\n        data = b\"SSH-2.0\\r\\nextra\"\n        result = handle_ssh_version(data)\n        self.assertEqual(result, b\"extra\")\n    \n    def test_version_with_carriage_return_not_allowed(self):\n        \"\"\"Test version with carriage return when not allowed.\"\"\"\n        global allowed_versions\n        allowed_versions = [b'2.0']\n        data = b\"SSH-2.0\\r\\nextra\"\n        with self.assertRaises(ValueError):\n            handle_ssh_version(data)\n    \n    def test_version_with_multiple_dashes(self):\n        \"\"\"Test version string with multiple dashes.\"\"\"\n        global allowed_versions\n        allowed_versions = [b'2.0']\n        data = b\"SSH-2.0-OpenSSH_7.9\\nextra\"\n        result = handle_ssh_version(data)\n        self.assertEqual(result, b\"extra\")\n    \n    def test_version_line_with_no_dash_after_ssh(self):\n        \"\"\"Test version line with no dash after SSH.\"\"\"\n        global allowed_versions\n        allowed_versions = [b'2.0']\n        data = b\"SSH-2.0\\nextra\"\n        result = handle_ssh_version(data)\n        self.assertEqual(result, b\"extra\")\n    \n    def test_version_line_with_extra_spaces(self):\n        \"\"\"Test version line with leading spaces.\"\"\"\n        data = b\"  SSH-2.0\\n\"\n        result = handle_ssh_version(data)\n        self.assertEqual(result, data)\n    \n    def test_allowed_versions_empty(self):\n        \"\"\"Test when allowed_versions is empty.\"\"\"\n        global allowed_versions\n        allowed_versions = []\n        data = b\"SSH-2.0\\n\"\n        with self.assertRaises(ValueError):\n            handle_ssh_version(data)\n    \n    def test_very_long_but_valid(self):\n        \"\"\"Test a long but valid buffer within size limit.\"\"\"\n        global allowed_versions\n        # Construct a long version string (total buffer 4096 bytes)\n        padding = b'A' * 4089  # 4096 - 7 (prefix) - 10 (next line) - 1 (newline) - 1 (newline after SSH line)\n        ssh_line = b\"SSH-2.0\" + padding\n        data = ssh_line + b\"\\nnext_line\"\n        allowed_versions = [b'2.0' + padding]\n        result = handle_ssh_version(data)\n        self.assertEqual(result, b\"next_line\")\n\ndef suite():\n    suite = unittest.TestSuite()\n    suite.addTest(unittest.makeSuite(TestSSHVersionHandling))\n    return suite\n\nif __name__ == '__main__':\n    runner = unittest.TextTestRunner()\n    runner.run(suite())", "num_test_cases": 17, "task_id": "1e1391de"}
{"test": "import unittest\nfrom unittest import mock\n\nclass TestProcessHttpHeader(unittest.TestCase):\n    \n    def test_case_1(self):\n        # Test valid header with acceptable version\n        buf = b\"HTTP/1.1 200 OK\\r\\nHeader1: value1\\r\\n\\r\\nbody\"\n        with mock.patch('solution.acceptable_headers', [b\"HTTP/1.1\"]):\n            result = process_http_header(buf)\n            self.assertEqual(result, b\"Header1: value1\\r\\n\\r\\nbody\")\n    \n    def test_case_2(self):\n        # Test empty buffer\n        buf = b\"\"\n        with self.assertRaises(ValueError) as context:\n            process_http_header(buf)\n        self.assertEqual(str(context.exception), \"No complete HTTP header found\")\n    \n    def test_case_3(self):\n        # Test buffer exceeding size limit\n        buf = b\"A\" * 8193\n        with self.assertRaises(ValueError) as context:\n            process_http_header(buf)\n        self.assertEqual(str(context.exception), \"HTTP header longer than 8KB. Preventing denial of service attack.\")\n    \n    def test_case_4(self):\n        # Test buffer with double CRLF but no status line\n        buf = b\"Header1: value1\\r\\nHeader2: value2\\r\\n\\r\\nbody\"\n        result = process_http_header(buf)\n        self.assertEqual(result, buf)\n    \n    def test_case_5(self):\n        # Test unacceptable HTTP version\n        buf = b\"HTTP/2.0 200 OK\\r\\n\\r\\nbody\"\n        with mock.patch('solution.acceptable_headers', [b\"HTTP/1.1\"]):\n            with self.assertRaises(ValueError) as context:\n                process_http_header(buf)\n            self.assertEqual(str(context.exception), \"Unsupported HTTP version: b'HTTP/2.0'\")\n    \n    def test_case_6(self):\n        # Test status line not at the beginning\n        buf = b\"Some garbage\\r\\nHTTP/1.1 200 OK\\r\\n\\r\\nbody\"\n        with mock.patch('solution.acceptable_headers', [b\"HTTP/1.1\"]):\n            result = process_http_header(buf)\n            self.assertEqual(result, b\"\\r\\nbody\")\n    \n    def test_case_7(self):\n        # Test buffer exactly 8192 bytes\n        status_line = b\"HTTP/1.1 200 OK\\r\\n\"\n        header_field = b\"X: value\\r\\n\"\n        empty_line = b\"\\r\\n\"\n        body_length = 8192 - len(status_line) - len(header_field) - len(empty_line)\n        body = b\"A\" * body_length\n        buf = status_line + header_field + empty_line + body\n        expected = header_field + empty_line + body\n        with mock.patch('solution.acceptable_headers', [b\"HTTP/1.1\"]):\n            result = process_http_header(buf)\n            self.assertEqual(result, expected)\n    \n    def test_case_8(self):\n        # Test buffer with only status line and double CRLF\n        buf = b\"HTTP/1.1 200 OK\\r\\n\\r\\n\"\n        with mock.patch('solution.acceptable_headers', [b\"HTTP/1.1\"]):\n            result = process_http_header(buf)\n            self.assertEqual(result, b\"\\r\\n\")\n    \n    def test_case_9(self):\n        # Test buffer with two status lines\n        buf = b\"HTTP/1.1 200 OK\\r\\nHTTP/1.1 200 OK\\r\\n\\r\\nbody\"\n        with mock.patch('solution.acceptable_headers', [b\"HTTP/1.1\"]):\n            result = process_http_header(buf)\n            self.assertEqual(result, b\"HTTP/1.1 200 OK\\r\\n\\r\\nbody\")\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 9, "task_id": "1ceb8d90"}
{"test": "import unittest\nimport base64\n\n# Global variable required_headers for the function\nrequired_headers = []\n\nclass TestProcessHttpRequest(unittest.TestCase):\n\n    def test_happy_path_multiple_headers(self):\n        \"\"\"Test with multiple headers and required headers present.\"\"\"\n        global required_headers\n        required_headers = [\"Host\", \"User-Agent\"]\n        data = b\"Host: example.com\\r\\nUser-Agent: test\\r\\n\\r\\n\"\n        result = process_http_request(data)\n        self.assertEqual(result, {\"Host\": \"example.com\", \"User-Agent\": \"test\"})\n\n    def test_happy_path_single_header(self):\n        \"\"\"Test with single header and required header present.\"\"\"\n        global required_headers\n        required_headers = [\"Host\"]\n        data = b\"Host: example.com\\r\\n\\r\\n\"\n        result = process_http_request(data)\n        self.assertEqual(result, {\"Host\": \"example.com\"})\n\n    def test_empty_headers_no_required(self):\n        \"\"\"Test empty headers with no required headers.\"\"\"\n        global required_headers\n        required_headers = []\n        data = b\"\\r\\n\\r\\n\"\n        result = process_http_request(data)\n        self.assertEqual(result, {})\n\n    def test_empty_headers_with_required(self):\n        \"\"\"Test empty headers with required headers present (expects missing header).\"\"\"\n        global required_headers\n        required_headers = [\"Host\"]\n        data = b\"\\r\\n\\r\\n\"\n        with self.assertRaises(ValueError) as context:\n            process_http_request(data)\n        self.assertIn(\"Missing required header: Host\", str(context.exception))\n\n    def test_max_length_headers(self):\n        \"\"\"Test headers at exactly the maximum allowed length (8192 bytes).\"\"\"\n        global required_headers\n        required_headers = [\"X\"]\n        header_line = \"X: \" + (\"a\" * (8192 - 5)) + \"\\r\\n\"\n        data = header_line.encode('utf-8')\n        self.assertEqual(len(data), 8192)\n        result = process_http_request(data)\n        self.assertEqual(result, {\"X\": \"a\" * (8192 - 5)})\n\n    def test_exceed_max_length(self):\n        \"\"\"Test headers exceeding maximum length (8193 bytes).\"\"\"\n        global required_headers\n        required_headers = []\n        header_line = \"X: \" + (\"a\" * (8193 - 5)) + \"\\r\\n\"\n        data = header_line.encode('utf-8')\n        self.assertEqual(len(data), 8193)\n        with self.assertRaises(ValueError) as context:\n            process_http_request(data)\n        self.assertEqual(str(context.exception), \"HTTP headers too long. Preventing buffer overflow.\")\n\n    def test_malformed_header_no_colon(self):\n        \"\"\"Test malformed header without colon.\"\"\"\n        global required_headers\n        required_headers = []\n        data = b\"Host example.com\\r\\n\"\n        with self.assertRaises(ValueError) as context:\n            process_http_request(data)\n        self.assertEqual(str(context.exception), \"Malformed header line\")\n\n    def test_malformed_header_colon_without_space(self):\n        \"\"\"Test header with colon but without trailing space.\"\"\"\n        global required_headers\n        required_headers = []\n        data = b\"Host:example.com\\r\\n\"\n        with self.assertRaises(ValueError) as context:\n            process_http_request(data)\n        self.assertEqual(str(context.exception), \"Malformed header line\")\n\n    def test_header_with_multiple_colons(self):\n        \"\"\"Test valid header containing multiple colons.\"\"\"\n        global required_headers\n        required_headers = [\"Header\"]\n        data = b\"Header: part1: part2\\r\\n\"\n        result = process_http_request(data)\n        self.assertEqual(result, {\"Header\": \"part1: part2\"})\n\n    def test_missing_required_header(self):\n        \"\"\"Test missing required header.\"\"\"\n        global required_headers\n        required_headers = [\"Missing-Header\"]\n        data = b\"Host: example.com\\r\\n\"\n        with self.assertRaises(ValueError) as context:\n            process_http_request(data)\n        self.assertIn(\"Missing required header: Missing-Header\", str(context.exception))\n\n    def test_header_with_spaces(self):\n        \"\"\"Test header with spaces around the colon.\"\"\"\n        global required_headers\n        required_headers = [\"Header  \"]\n        data = b\"Header  :   value\\r\\n\"\n        result = process_http_request(data)\n        self.assertEqual(result, {\"Header  \": \"  value\"})\n\n    def test_case_sensitivity_missing(self):\n        \"\"\"Test case sensitivity of header names (required header missing).\"\"\"\n        global required_headers\n        required_headers = [\"host\"]\n        data = b\"Host: example.com\\r\\n\"\n        with self.assertRaises(ValueError) as context:\n            process_http_request(data)\n        self.assertIn(\"Missing required header: host\", str(context.exception))\n\n    def test_non_utf8_data(self):\n        \"\"\"Test with non-UTF8 encoded data (invalid byte sequence).\"\"\"\n        global required_headers\n        required_headers = []\n        data = b'\\x80abc'\n        with self.assertRaises(UnicodeDecodeError):\n            process_http_request(data)\n", "num_test_cases": 13, "task_id": "0b4b40ed"}
{"test": "import unittest\nimport unittest.mock\nfrom solution import process_user_input\nimport solution\n\nclass TestCases(unittest.TestCase):\n    def setUp(self):\n        solution.internal_buffer = bytearray()\n    \n    def test_valid_non_empty(self):\n        # Tests non-empty valid input: buffer updated and success message printed\n        data = b'Hello'\n        with unittest.mock.patch('builtins.print') as mock_print:\n            process_user_input(data)\n            self.assertEqual(solution.internal_buffer, data)\n            mock_print.assert_called_once_with('User input processed successfully')\n    \n    def test_valid_empty(self):\n        # Tests empty valid input: buffer remains empty and success message printed\n        data = b''\n        with unittest.mock.patch('builtins.print') as mock_print:\n            process_user_input(data)\n            self.assertEqual(solution.internal_buffer, data)\n            mock_print.assert_called_once_with('User input processed successfully')\n    \n    def test_valid_1024_bytes(self):\n        # Tests input of exactly 1024 bytes: buffer updated and success message printed\n        data = b'x' * 1024\n        with unittest.mock.patch('builtins.print') as mock_print:\n            process_user_input(data)\n            self.assertEqual(solution.internal_buffer, data)\n            mock_print.assert_called_once_with('User input processed successfully')\n    \n    def test_exceptions(self):\n        # Tests exception cases: 1025 bytes and non-bytes input\n        cases = [\n            (b'x' * 1025, ValueError, 'Input data exceeds the maximum allowed length of 1024 bytes.'),\n            ('string', TypeError, None)\n        ]\n        for data, exception, message in cases:\n            with self.subTest(data=data, exception=exception):\n                with self.assertRaises(exception) as context:\n                    process_user_input(data)\n                if message is not None:\n                    self.assertEqual(str(context.exception), message)\n                self.assertEqual(solution.internal_buffer, b'')\n    \n    def test_no_print_on_exception(self):\n        # Tests that print is not called during exception cases\n        cases = [\n            (b'x' * 1025, ValueError),\n            ('string', TypeError)\n        ]\n        for data, exception in cases:\n            with self.subTest(data=data, exception=exception):\n                with unittest.mock.patch('builtins.print') as mock_print:\n                    with self.assertRaises(exception):\n                        process_user_input(data)\n                    mock_print.assert_not_called()\n                    self.assertEqual(solution.internal_buffer, b'')", "num_test_cases": 5, "task_id": "7fa1b967"}
{"test": "import unittest\nimport re\n\nclass TestProcessUserInput(unittest.TestCase):\n    def test_html_removal(self):\n        \"\"\"Test removal of HTML tags in various scenarios.\"\"\"\n        test_cases = [\n            (\"<p>Hello</p>\", \"Hello\"),\n            (\"<div><p>Hello</p></div>\", \"Hello\"),\n            (\"Hello<br/>World\", \"HelloWorld\"),\n            ('<a href=\\\"example.com\\\">Link</a>', \"Link\"),\n            (\"Hello, World!\", \"Hello, World!\"),\n            (\"\", \"\"),\n            (\"<p>Nested <b>tags</b> test</p>\", \"Nested tags test\"),\n            (\"No tags here\", \"No tags here\"),\n        ]\n        for input_str, expected in test_cases:\n            with self.subTest(input_str=input_str):\n                result = process_user_input(input_str)\n                self.assertEqual(result, expected)\n    \n    def test_input_length_boundary(self):\n        \"\"\"Test exact length boundary (1024 characters).\"\"\"\n        # Exactly 1024 characters without HTML\n        input1 = 'a' * 1024\n        self.assertEqual(process_user_input(input1), input1)\n        \n        # Exactly 1024 characters with HTML tags\n        content = 'b' * (1024 - 7)  # Compensate for '<a></a>'\n        input2 = f'<a>{content}</a>'\n        self.assertEqual(process_user_input(input2), content)\n    \n    def test_input_too_long(self):\n        \"\"\"Test input exceeding 1024 characters raises ValueError.\"\"\"\n        # 1025 characters without HTML\n        input1 = 'a' * 1025\n        with self.assertRaises(ValueError) as context:\n            process_user_input(input1)\n        self.assertEqual(str(context.exception), \"Input data is too long. Rejecting to prevent buffer overflow.\")\n        \n        # 1025 characters with HTML tags\n        content = 'c' * (1025 - 7)\n        input2 = f'<div>{content}</div>'  # Total length 1025\n        with self.assertRaises(ValueError) as context:\n            process_user_input(input2)\n        self.assertEqual(str(context.exception), \"Input data is too long. Rejecting to prevent buffer overflow.\")\n    \n    def test_non_string_input(self):\n        \"\"\"Test non-string inputs raise appropriate exceptions.\"\"\"\n        # Integer input\n        with self.assertRaises(TypeError):\n            process_user_input(123)\n            \n        # List input (has length but not string)\n        with self.assertRaises(TypeError):\n            process_user_input([1, 2, 3])\n    \n    def test_special_characters(self):\n        \"\"\"Test input with special characters and mixed content.\"\"\"\n        input_str = \"<script>alert('XSS');</script>\"\n        expected = \"alert('XSS');\"\n        self.assertEqual(process_user_input(input_str), expected)\n        \n        input_str = \"<span>Special chars: @#$%^&*()</span>\"\n        expected = \"Special chars: @#$%^&*()\"\n        self.assertEqual(process_user_input(input_str), expected)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 5, "task_id": "f566d08a"}
{"test": "import unittest\nimport solution\n\nclass TestCases(unittest.TestCase):\n    def setUp(self):\n        self.original_supported = solution.supported_versions\n        solution.supported_versions = [b'2.0', b'1.99']\n\n    def tearDown(self):\n        solution.supported_versions = self.original_supported\n\n    def test_happy_path_supported_version(self):\n        # Basic happy path with supported version\n        buf = b\"SSH-2.0-OpenSSH_7.2\\nrest of data\"\n        result = solution.parse_ssh_version(buf)\n        self.assertEqual(result, b\"rest of data\")\n\n    def test_unsupported_version(self):\n        # Version not in supported list\n        buf = b\"SSH-3.0-OpenSSH_7.2\\n\"\n        with self.assertRaises(ValueError) as context:\n            solution.parse_ssh_version(buf)\n        self.assertIn(\"Unsupported SSH version: b'3.0'\", str(context.exception))\n\n    def test_buffer_exceeds_max_length(self):\n        # Buffer larger than 4096 bytes\n        buf = b'x' * 4097\n        with self.assertRaises(ConnectionError) as context:\n            solution.parse_ssh_version(buf)\n        self.assertEqual(str(context.exception), \"Peer version string longer than 4KB. Preventing a denial of service attack.\")\n\n    def test_empty_buffer(self):\n        # Empty input buffer\n        buf = b''\n        with self.assertRaises(ConnectionError) as context:\n            solution.parse_ssh_version(buf)\n        self.assertEqual(str(context.exception), \"No SSH version string found\")\n\n    def test_no_ssh_prefix_found(self):\n        # Buffer without SSH- prefix and no newline\n        buf = b'InvalidData'\n        with self.assertRaises(ConnectionError) as context:\n            solution.parse_ssh_version(buf)\n        self.assertEqual(str(context.exception), \"No SSH version string found\")\n\n    def test_ssh_prefix_without_newline(self):\n        # SSH- prefix present but no newline after\n        buf = b'SSH-2.0-OpenSSH_7.2'\n        with self.assertRaises(ConnectionError) as context:\n            solution.parse_ssh_version(buf)\n        self.assertEqual(str(context.exception), \"No SSH version string found\")\n\n    def test_multiple_lines_version_in_second_line(self):\n        # Version in second line\n        buf = b\"First line\\nSSH-1.99-OpenSSH\\nrest\"\n        result = solution.parse_ssh_version(buf)\n        self.assertEqual(result, b\"rest\")\n\n    def test_version_in_middle_of_line(self):\n        # SSH- not at start of line\n        buf = b\"PrefixSSH-2.0\\n\"\n        result = solution.parse_ssh_version(buf)\n        self.assertEqual(result, buf)  # Returns original buffer\n\n    def test_buffer_exact_max_length(self):\n        # Buffer exactly 4096 bytes with valid version\n        header = b\"SSH-2.0-OpenSSH\\n\"\n        padding = b'x' * (4096 - len(header))\n        buf = header + padding\n        result = solution.parse_ssh_version(buf)\n        self.assertEqual(result, padding)\n\n    def test_multiple_ssh_prefixes(self):\n        # Multiple SSH- prefixes, valid version in second\n        buf = b\"SSH-3.0-Invalid\\nSSH-1.99-Valid\\ndata\"\n        result = solution.parse_ssh_version(buf)\n        self.assertEqual(result, b\"data\")\n\n    def test_version_at_end_without_newline(self):\n        # Version at buffer end without terminating newline\n        buf = b\"First line\\nSSH-2.0\"\n        with self.assertRaises(ConnectionError) as context:\n            solution.parse_ssh_version(buf)\n        self.assertEqual(str(context.exception), \"No SSH version string found\")\n\n    def test_valid_version_with_data_after(self):\n        # Valid version with multiple data lines after\n        buf = b\"SSH-2.0\\nline1\\nline2\"\n        result = solution.parse_ssh_version(buf)\n        self.assertEqual(result, b\"line1\\nline2\")\n", "num_test_cases": 12, "task_id": "013bacfc"}
{"test": "import unittest\nimport healthcare_system\n\nclass TestCases(unittest.TestCase):\n    def setUp(self):\n        class Patient:\n            def __init__(self, name, age, gender, diagnosis, treatment_plan):\n                self.name = name\n                self.age = age\n                self.gender = gender\n                self.diagnosis = diagnosis\n                self.treatment_plan = treatment_plan\n        self.Patient = Patient\n        self.patient1 = Patient('John Doe', 30, 'Male', 'Common Cold', 'Rest and hydration')\n        self.patient2 = Patient('Jane Smith', 25, 'Female', 'Sprained ankle', 'Physical therapy')\n        self.patients_dict = {\n            'P001': self.patient1,\n            'P002': self.patient2\n        }\n        healthcare_system.patients = self.patients_dict\n\n    def test_case_1(self):\n        # Happy path: non-sensitive placeholders\n        layout = 'Patient Name: {patient.name}, Age: {patient.age}'\n        result = healthcare_system.create_patient_report('P001', layout)\n        self.assertEqual(result, 'Patient Name: John Doe, Age: 30')\n\n    def test_case_2(self):\n        # Empty layout\n        layout = ''\n        result = healthcare_system.create_patient_report('P001', layout)\n        self.assertEqual(result, '')\n\n    def test_case_3(self):\n        # Invalid patient ID\n        with self.assertRaises(ValueError):\n            healthcare_system.create_patient_report('P999', 'some layout')\n\n    def test_case_4(self):\n        # Layout includes sensitive field: diagnosis\n        layout = 'Diagnosis: {patient.diagnosis}'\n        with self.assertRaises(ValueError) as context:\n            healthcare_system.create_patient_report('P001', layout)\n        self.assertIn('Access to diagnosis is not allowed in reports', str(context.exception))\n\n    def test_case_5(self):\n        # Layout includes sensitive field: treatment_plan\n        layout = 'Treatment: {patient.treatment_plan}'\n        with self.assertRaises(ValueError) as context:\n            healthcare_system.create_patient_report('P001', layout)\n        self.assertIn('Access to treatment_plan is not allowed in reports', str(context.exception))\n\n    def test_case_6(self):\n        # Layout includes non-existing attribute\n        layout = 'Address: {patient.address}'\n        with self.assertRaises(AttributeError):\n            healthcare_system.create_patient_report('P001', layout)\n\n    def test_case_7(self):\n        # Non-string data (integer age) in placeholder\n        layout = 'Age: {patient.age}'\n        result = healthcare_system.create_patient_report('P001', layout)\n        self.assertEqual(result, 'Age: 30')\n\n    def test_case_8(self):\n        # Multiple non-sensitive placeholders\n        layout = 'Name: {patient.name}, Age: {patient.age}, Gender: {patient.gender}'\n        result = healthcare_system.create_patient_report('P002', layout)\n        self.assertEqual(result, 'Name: Jane Smith, Age: 25, Gender: Female')\n\n    def test_case_9(self):\n        # Empty patient ID\n        with self.assertRaises(ValueError):\n            healthcare_system.create_patient_report('', 'some layout')\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 9, "task_id": "6d5e35a2"}
{"test": "import unittest\n\n# Define the Patient class and patients dictionary for testing\nclass Patient:\n    def __init__(self, name, age, gender, diagnosis, treatment_plan):\n        self.name = name\n        self.age = age\n        self.gender = gender\n        self.diagnosis = diagnosis\n        self.treatment_plan = treatment_plan\n\npatients = {\n    \"patient1\": Patient(\"John Doe\", 30, \"Male\", \"Flu\", \"Rest and hydration\"),\n    \"patient2\": Patient(\"Jane Smith\", 25, \"Female\", \"Cold\", \"Medication\"),\n    \"patient3\": Patient(\"Alice Johnson\", 45, \"Female\", \"\", \"\"),  # Empty sensitive fields\n    \"patient4\": Patient(\"Bob Brown\", 0, \"Male\", \"Fever\", \"Antibiotics\"),  # Age 0\n    \"patient5\": Patient(\"\", 99, \"Other\", \"Cancer\", \"Chemotherapy\")  # Empty name\n}\n\nclass TestBuildPatientSummary(unittest.TestCase):\n    \n    def test_happy_path_basic(self):\n        # Test basic functionality with valid patient and template\n        result = build_patient_summary(\"patient1\", \"Name: {patient.name}, Age: {patient.age}\")\n        self.assertEqual(result, \"Name: John Doe, Age: 30\")\n    \n    def test_happy_path_all_demographics(self):\n        # Test with all allowed demographic fields\n        result = build_patient_summary(\"patient2\", \"Name: {patient.name}, Age: {patient.age}, Gender: {patient.gender}\")\n        self.assertEqual(result, \"Name: Jane Smith, Age: 25, Gender: Female\")\n    \n    def test_edge_empty_template(self):\n        # Test with an empty report template\n        result = build_patient_summary(\"patient1\", \"\")\n        self.assertEqual(result, \"\")\n    \n    def test_edge_patient_zero_age(self):\n        # Test patient with age 0\n        result = build_patient_summary(\"patient4\", \"Age: {patient.age}\")\n        self.assertEqual(result, \"Age: 0\")\n    \n    def test_edge_empty_name(self):\n        # Test patient with empty name\n        result = build_patient_summary(\"patient5\", \"Name: '{patient.name}'\")\n        self.assertEqual(result, \"Name: ''\")\n    \n    def test_error_invalid_patient_id(self):\n        # Test with invalid patient ID\n        with self.assertRaises(ValueError) as context:\n            build_patient_summary(\"non_existent\", \"Template\")\n        self.assertEqual(str(context.exception), \"Patient not found\")\n    \n    def test_error_sensitive_field_diagnosis(self):\n        # Test accessing restricted 'diagnosis' field\n        with self.assertRaises(ValueError) as context:\n            build_patient_summary(\"patient1\", \"Diagnosis: {patient.diagnosis}\")\n        self.assertIn(\"Access to diagnosis is not allowed in reports\", str(context.exception))\n    \n    def test_error_sensitive_field_treatment_plan(self):\n        # Test accessing restricted 'treatment_plan' field\n        with self.assertRaises(ValueError) as context:\n            build_patient_summary(\"patient1\", \"Treatment: {patient.treatment_plan}\")\n        self.assertIn(\"Access to treatment_plan is not allowed in reports\", str(context.exception))\n    \n    def test_error_mixed_fields(self):\n        # Test template with both allowed and restricted fields\n        with self.assertRaises(ValueError):\n            build_patient_summary(\"patient2\", \"Name: {patient.name}, Treatment: {patient.treatment_plan}\")\n    \n    def test_error_invalid_field(self):\n        # Test accessing a non-existing patient field\n        with self.assertRaises(AttributeError):\n            build_patient_summary(\"patient1\", \"Invalid: {patient.invalid_field}\")\n    \n    def test_security_empty_sensitive_fields(self):\n        # Test patient with empty sensitive fields (should still block access)\n        with self.assertRaises(ValueError):\n            build_patient_summary(\"patient3\", \"Diagnosis: {patient.diagnosis}\")\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 12, "task_id": "7fc76463"}
{"test": "import unittest\nimport solution\n\nclass Patient:\n    def __init__(self, name, age, gender, diagnosis, treatment_plan):\n        self.name = name\n        self.age = age\n        self.gender = gender\n        self.diagnosis = diagnosis\n        self.treatment_plan = treatment_plan\n\nclass TestAssemblePatientReport(unittest.TestCase):\n    def setUp(self):\n        self.patients_dict = {\n            '001': Patient('John Doe', 30, 'Male', 'Flu', 'Rest and hydration'),\n            '002': Patient('Jane Smith', 25, 'Female', 'Cold', 'Medication'),\n            '003': Patient('Alice Johnson', 45, 'Female', '', ''),\n            '004': Patient('Bob Brown', 50, 'Male', 'Headache', 'Painkillers')\n        }\n        solution.patients = self.patients_dict\n\n    def test_case_1(self):\n        # Happy path: valid patient ID and non-sensitive fields\n        template = 'Patient: {patient.name}, Age: {patient.age}, Gender: {patient.gender}'\n        result = solution.assemble_patient_report('001', template)\n        self.assertEqual(result, 'Patient: John Doe, Age: 30, Gender: Male')\n\n    def test_case_2(self):\n        # Edge case: empty template\n        result = solution.assemble_patient_report('001', '')\n        self.assertEqual(result, '')\n\n    def test_case_3(self):\n        # Error handling: invalid patient ID\n        with self.assertRaises(ValueError) as context:\n            solution.assemble_patient_report('005', 'Template')\n        self.assertEqual(str(context.exception), 'Patient not found')\n\n    def test_case_4(self):\n        # Error handling: accessing diagnosis (sensitive field)\n        template = 'Diagnosis: {patient.diagnosis}'\n        with self.assertRaises(ValueError) as context:\n            solution.assemble_patient_report('001', template)\n        self.assertIn('Access to diagnosis is not allowed in reports', str(context.exception))\n\n    def test_case_5(self):\n        # Error handling: accessing treatment_plan (sensitive field)\n        template = 'Treatment: {patient.treatment_plan}'\n        with self.assertRaises(ValueError) as context:\n            solution.assemble_patient_report('001', template)\n        self.assertIn('Access to treatment_plan is not allowed in reports', str(context.exception))\n\n    def test_case_6(self):\n        # Edge case: patient with empty sensitive fields (non-sensitive access)\n        template = 'Name: {patient.name}, Age: {patient.age}'\n        result = solution.assemble_patient_report('003', template)\n        self.assertEqual(result, 'Name: Alice Johnson, Age: 45')\n\n    def test_case_7(self):\n        # Error handling: non-existing patient attribute\n        template = 'Height: {patient.height}'\n        with self.assertRaises(AttributeError):\n            solution.assemble_patient_report('001', template)\n\n    def test_case_8(self):\n        # Error handling: mixed sensitive and non-sensitive fields\n        template = 'Name: {patient.name}, Diagnosis: {patient.diagnosis}'\n        with self.assertRaises(ValueError) as context:\n            solution.assemble_patient_report('001', template)\n        self.assertIn('Access to diagnosis is not allowed in reports', str(context.exception))", "num_test_cases": 8, "task_id": "811ab156"}
{"test": "import unittest\nfrom unittest.mock import patch\nimport solution\n\nclass TestCases(unittest.TestCase):\n    @classmethod\n    def setUpClass(cls):\n        # Define the Patient class and test_patients dictionary\n        class Patient:\n            def __init__(self, name, age, gender, diagnosis=None, treatment_plan=None, address=None):\n                self.name = name\n                self.age = age\n                self.gender = gender\n                self.diagnosis = diagnosis\n                self.treatment_plan = treatment_plan\n                self.address = address\n                \n        cls.test_patients = {\n            \"001\": Patient(\"John Doe\", 30, \"Male\", \"Flu\", \"Rest and hydration\", \"123 Main St\"),\n            \"002\": Patient(\"Jane Smith\", 25, \"Female\"),\n            \"003\": Patient(\"Bob Lee\", 45, \"Male\", \"Healthy\", \"No treatment\", \"456 Elm St\")\n        }\n        # Patch the solution.patients with our test_patients\n        cls.patcher = patch('solution.patients', cls.test_patients)\n        cls.patcher.start()\n    \n    @classmethod\n    def tearDownClass(cls):\n        cls.patcher.stop()\n    \n    def test_case_1(self):\n        # Test with allowed placeholders: name, age, gender\n        result = solution.create_patient_report(\"001\", \"Name: {patient.name}, Age: {patient.age}, Gender: {patient.gender}\")\n        self.assertEqual(result, \"Name: John Doe, Age: 30, Gender: Male\")\n    \n    def test_case_2(self):\n        # Test with an extra non-restricted attribute (address)\n        result = solution.create_patient_report(\"001\", \"Address: {patient.address}\")\n        self.assertEqual(result, \"Address: 123 Main St\")\n    \n    def test_case_3(self):\n        # Test with an empty template\n        result = solution.create_patient_report(\"001\", \"\")\n        self.assertEqual(result, \"\")\n    \n    def test_case_4(self):\n        # Test with a template without placeholders\n        result = solution.create_patient_report(\"001\", \"This is a static report.\")\n        self.assertEqual(result, \"This is a static report.\")\n    \n    def test_case_5(self):\n        # Test with an invalid patient ID\n        with self.assertRaises(ValueError) as context:\n            solution.create_patient_report(\"004\", \"Report for {patient.name}\")\n        self.assertEqual(str(context.exception), \"Patient not found\")\n    \n    def test_case_6(self):\n        # Test accessing a restricted attribute (diagnosis)\n        with self.assertRaises(ValueError) as context:\n            solution.create_patient_report(\"001\", \"Diagnosis: {patient.diagnosis}\")\n        self.assertEqual(str(context.exception), \"Access to diagnosis is not allowed in reports\")\n    \n    def test_case_7(self):\n        # Test accessing another restricted attribute (treatment_plan)\n        with self.assertRaises(ValueError) as context:\n            solution.create_patient_report(\"001\", \"Treatment Plan: {patient.treatment_plan}\")\n        self.assertEqual(str(context.exception), \"Access to treatment_plan is not allowed in reports\")\n    \n    def test_case_8(self):\n        # Test accessing a non-existing attribute\n        with self.assertRaises(AttributeError):\n            solution.create_patient_report(\"001\", \"Height: {patient.height}\")\n", "num_test_cases": 8, "task_id": "a266e70f"}
{"test": "import unittest\n\n# We define a Patient class and the patients_data dictionary to simulate the environment\nclass Patient:\n    def __init__(self, name, age, gender, diagnosis, treatment_plan):\n        self.name = name\n        self.age = age\n        self.gender = gender\n        self.diagnosis = diagnosis\n        self.treatment_plan = treatment_plan\n\n# Global patients_data dictionary that the function uses\npatients_data = {}\n\ndef generate_patient_summary(patient_id, report_template):\n    if patient_id not in patients_data:\n        raise ValueError(\"Patient not found\")\n    patient = patients_data[patient_id]\n    class SecurePatientDetails:\n        def __init__(self, patient):\n            self._patient = patient\n\n        def __getattr__(self, attribute):\n            if attribute in ['diagnosis', 'treatment_plan']:\n                raise ValueError(f\"Access to {attribute} is not allowed in reports\")\n            return getattr(self._patient, attribute)\n\n    secure_patient_info = SecurePatientDetails(patient)\n    return report_template.format(patient=secure_patient_info)\n\nclass TestGeneratePatientSummary(unittest.TestCase):\n    def setUp(self):\n        # Reset and populate patients_data for each test\n        global patients_data\n        patients_data.clear()\n        self.patient1 = Patient(\"John Doe\", 45, \"Male\", \"Hypertension\", \"Medication and exercise\")\n        self.patient2 = Patient(\"\", 0, \"\", \"\", \"\")  # Empty values\n        self.patient3 = Patient(None, None, None, None, None)  # None values\n        patients_data[\"12345\"] = self.patient1\n        patients_data[\"empty_patient\"] = self.patient2\n        patients_data[\"null_patient\"] = self.patient3\n\n    def test_valid_template(self):\n        # Test basic functionality with allowed attributes\n        template = \"Patient Name: {patient.name}, Age: {patient.age}, Gender: {patient.gender}\"\n        result = generate_patient_summary(\"12345\", template)\n        self.assertEqual(result, \"Patient Name: John Doe, Age: 45, Gender: Male\")\n\n    def test_invalid_patient_id(self):\n        # Test invalid patient ID\n        template = \"Template\"\n        with self.assertRaises(ValueError):\n            generate_patient_summary(\"99999\", template)\n\n    def test_restricted_diagnosis(self):\n        # Test accessing restricted attribute 'diagnosis'\n        template = \"Diagnosis: {patient.diagnosis}\"\n        with self.assertRaises(ValueError) as context:\n            generate_patient_summary(\"12345\", template)\n        self.assertIn(\"Access to diagnosis is not allowed\", str(context.exception))\n\n    def test_restricted_treatment_plan(self):\n        # Test accessing restricted attribute 'treatment_plan'\n        template = \"Treatment: {patient.treatment_plan}\"\n        with self.assertRaises(ValueError) as context:\n            generate_patient_summary(\"12345\", template)\n        self.assertIn(\"Access to treatment_plan is not allowed\", str(context.exception))\n\n    def test_mixed_allowed_and_restricted(self):\n        # Test template with both allowed and restricted attributes\n        template = \"Name: {patient.name}, Diagnosis: {patient.diagnosis}\"\n        with self.assertRaises(ValueError):\n            generate_patient_summary(\"12345\", template)\n\n    def test_empty_template(self):\n        # Test empty template string\n        result = generate_patient_summary(\"12345\", \"\")\n        self.assertEqual(result, \"\")\n\n    def test_template_no_placeholders(self):\n        # Test template without placeholders\n        template = \"This is a report with no placeholders.\"\n        result = generate_patient_summary(\"12345\", template)\n        self.assertEqual(result, template)\n\n    def test_non_existent_attribute(self):\n        # Test accessing non-existing attribute (not restricted)\n        template = \"Address: {patient.address}\"\n        with self.assertRaises(AttributeError):\n            generate_patient_summary(\"12345\", template)\n\n    def test_patient_id_none(self):\n        # Test None as patient_id\n        template = \"Template\"\n        with self.assertRaises(ValueError):\n            generate_patient_summary(None, template)\n\n    def test_patient_id_integer(self):\n        # Test integer patient_id (should not match string keys)\n        template = \"Template\"\n        with self.assertRaises(ValueError):\n            generate_patient_summary(12345, template)\n\n    def test_escaped_braces(self):\n        # Test template with escaped braces\n        template = \"{{Hello}} {patient.name}\"\n        result = generate_patient_summary(\"12345\", template)\n        self.assertEqual(result, \"{Hello} John Doe\")\n\n    def test_uppercase_restricted_attribute(self):\n        # Test case sensitivity with uppercase restricted attribute\n        template = \"Diagnosis: {patient.Diagnosis}\"  # Note uppercase\n        with self.assertRaises(AttributeError):\n            generate_patient_summary(\"12345\", template)\n\n    def test_patient_with_empty_values(self):\n        # Test patient with empty string attributes\n        template = \"Name: {patient.name}, Age: {patient.age}, Gender: {patient.gender}\"\n        result = generate_patient_summary(\"empty_patient\", template)\n        self.assertEqual(result, \"Name: , Age: 0, Gender: \")\n\n    def test_patient_with_none_values(self):\n        # Test patient with None values\n        template = \"Name: {patient.name}, Age: {patient.age}, Gender: {patient.gender}\"\n        result = generate_patient_summary(\"null_patient\", template)\n        self.assertEqual(result, \"Name: None, Age: None, Gender: None\")", "num_test_cases": 14, "task_id": "89b5f762"}
{"test": "import unittest\nfrom unittest.mock import patch\nfrom solution import build_patient_report\n\nclass TestBuildPatientReport(unittest.TestCase):\n    class Patient:\n        def __init__(self, name, age, gender, diagnosis, treatment_plan):\n            self.name = name\n            self.age = age\n            self.gender = gender\n            self.diagnosis = diagnosis\n            self.treatment_plan = treatment_plan\n\n    def setUp(self):\n        self.patient1 = self.Patient('John Doe', 30, 'Male', 'Common Cold', 'Rest and hydration')\n        self.patient2 = self.Patient('Jane Smith', 25, 'Female', 'Healthy', 'No treatment')\n        self.patient3 = self.Patient('Bob Lee', None, 'Male', 'Broken arm', 'Cast')\n        self.patient4 = self.Patient('A'*1000, 100, 'Non-binary', 'None', 'None')\n        self.patient_records = {\n            'P001': self.patient1,\n            'P002': self.patient2,\n            'P003': self.patient3,\n            'P004': self.patient4\n        }\n\n    def test_valid_patient_and_template(self):\n        # Test basic happy path with allowed placeholders\n        template = 'Patient: {patient.name}, Age: {patient.age}, Gender: {patient.gender}'\n        expected = 'Patient: John Doe, Age: 30, Gender: Male'\n        with patch('solution.patient_records', self.patient_records):\n            result = build_patient_report('P001', template)\n        self.assertEqual(result, expected)\n\n    def test_empty_template(self):\n        # Test edge case with empty template string\n        template = ''\n        expected = ''\n        with patch('solution.patient_records', self.patient_records):\n            result = build_patient_report('P001', template)\n        self.assertEqual(result, expected)\n\n    def test_invalid_patient_id(self):\n        # Test invalid patient ID raises ValueError\n        template = 'Patient: {patient.name}'\n        with patch('solution.patient_records', self.patient_records):\n            with self.assertRaises(ValueError):\n                build_patient_report('P999', template)\n\n    def test_restricted_placeholder(self):\n        # Test restricted placeholder (diagnosis) raises ValueError\n        template = 'Patient: {patient.name}, Diagnosis: {patient.diagnosis}'\n        with patch('solution.patient_records', self.patient_records):\n            with self.assertRaises(ValueError) as context:\n                build_patient_report('P001', template)\n            self.assertIn('diagnosis', str(context.exception))\n\n    def test_nonexistent_placeholder(self):\n        # Test non-existent placeholder raises AttributeError\n        template = 'Patient: {patient.address}'\n        with patch('solution.patient_records', self.patient_records):\n            with self.assertRaises(AttributeError):\n                build_patient_report('P001', template)\n\n    def test_multiple_allowed_placeholders(self):\n        # Test template with multiple allowed placeholders\n        template = 'Name: {patient.name}, Age: {patient.age}, Gender: {patient.gender}'\n        expected = 'Name: Jane Smith, Age: 25, Gender: Female'\n        with patch('solution.patient_records', self.patient_records):\n            result = build_patient_report('P002', template)\n        self.assertEqual(result, expected)\n\n    def test_none_value_in_field(self):\n        # Test allowed field with None value formats correctly\n        template = 'Name: {patient.name}, Age: {patient.age}'\n        expected = 'Name: Bob Lee, Age: None'\n        with patch('solution.patient_records', self.patient_records):\n            result = build_patient_report('P003', template)\n        self.assertEqual(result, expected)\n\n    def test_long_string_in_field(self):\n        # Test long string in allowed field\n        long_name = 'A' * 1000\n        template = 'Name: {patient.name}'\n        expected = 'Name: ' + long_name\n        with patch('solution.patient_records', self.patient_records):\n            result = build_patient_report('P004', template)\n        self.assertEqual(result, expected)", "num_test_cases": 8, "task_id": "975cd35a"}
{"test": "import unittest\nimport healthcare_report\nfrom healthcare_report import create_person_report\n\nclass Patient:\n    def __init__(self, name, age, gender, diagnosis, treatment_plan):\n        self.name = name\n        self.age = age\n        self.gender = gender\n        self.diagnosis = diagnosis\n        self.treatment_plan = treatment_plan\n\nclass TestCases(unittest.TestCase):\n    def setUp(self):\n        self.patients_dict = {\n            \"P001\": Patient(\"John Doe\", 30, \"Male\", \"Flu\", \"Rest and hydration\"),\n            \"P002\": Patient(\"Jane Smith\", 25, \"Female\", \"Cold\", \"Medication\"),\n            \"P003\": Patient(\"\", 0, \"\", \"None\", \"None\")\n        }\n        healthcare_report.patients = self.patients_dict\n\n    def test_case_1(self):\n        # Test happy path with name and age\n        result = create_person_report(\"P001\", \"Name: {patient.name}, Age: {patient.age}\")\n        self.assertEqual(result, \"Name: John Doe, Age: 30\")\n\n    def test_case_2(self):\n        # Test happy path with gender\n        result = create_person_report(\"P002\", \"Gender: {patient.gender}\")\n        self.assertEqual(result, \"Gender: Female\")\n\n    def test_case_3(self):\n        # Test patient not found\n        with self.assertRaises(ValueError):\n            create_person_report(\"P999\", \"Name: {patient.name}\")\n\n    def test_case_4(self):\n        # Test access to sensitive field 'diagnosis'\n        with self.assertRaises(ValueError):\n            create_person_report(\"P001\", \"Diagnosis: {patient.diagnosis}\")\n\n    def test_case_5(self):\n        # Test access to sensitive field 'treatment_plan'\n        with self.assertRaises(ValueError):\n            create_person_report(\"P001\", \"Treatment: {patient.treatment_plan}\")\n\n    def test_case_6(self):\n        # Test empty report template\n        result = create_person_report(\"P001\", \"\")\n        self.assertEqual(result, \"\")\n\n    def test_case_7(self):\n        # Test template with no placeholders\n        result = create_person_report(\"P001\", \"Static content\")\n        self.assertEqual(result, \"Static content\")\n\n    def test_case_8(self):\n        # Test empty patient code (not found)\n        with self.assertRaises(ValueError):\n            create_person_report(\"\", \"Name: {patient.name}\")\n\n    def test_case_9(self):\n        # Test patient with empty non-sensitive fields\n        result = create_person_report(\"P003\", \"Name: '{patient.name}', Age: {patient.age}, Gender: '{patient.gender}'\")\n        self.assertEqual(result, \"Name: '', Age: 0, Gender: ''\")\n\n    def test_case_10(self):\n        # Test multiple non-sensitive fields together\n        result = create_person_report(\"P002\", \"{patient.name} ({patient.age}): {patient.gender}\")\n        self.assertEqual(result, \"Jane Smith (25): Female\")\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 10, "task_id": "ec5b25d1"}
{"test": "import unittest\n\n# Define the Patient class for testing\nclass Patient:\n    def __init__(self, name, age, gender, diagnosis, treatment_plan):\n        self.name = name\n        self.age = age\n        self.gender = gender\n        self.diagnosis = diagnosis\n        self.treatment_plan = treatment_plan\n\n# Define the global patients dictionary for testing\npatients = {\n    \"P001\": Patient(\"John Doe\", 30, \"Male\", \"Flu\", \"Rest and hydration\"),\n    \"P002\": Patient(\"Jane Smith\", 25, \"Female\", \"Cold\", \"Rest and medication\"),\n    \"P003\": Patient(\"\", 0, \"\", \"\", \"\"),  # Patient with empty non-sensitive fields\n}\n\n# The function to be tested (defined as per the provided code)\ndef build_patient_summary(patient_key, template_string):\n    if patient_key not in patients:\n        raise ValueError(\"Patient not found\")\n    patient = patients[patient_key]\n    class SecurePatient:\n        def __init__(self, patient):\n            self._patient = patient\n\n        def __getattr__(self, name):\n            if name in ['diagnosis', 'treatment_plan']:\n                raise ValueError(f\"Access to {name} is not allowed in reports\")\n            return getattr(self._patient, name)\n\n    secure_patient = SecurePatient(patient)\n    return template_string.format(patient=secure_patient)\n\nclass TestBuildPatientSummary(unittest.TestCase):\n    def test_valid_patient_and_template(self):\n        # Test typical usage with valid patient and non-sensitive fields\n        result = build_patient_summary(\"P001\", \"Patient: {patient.name}, Age: {patient.age}\")\n        self.assertEqual(result, \"Patient: John Doe, Age: 30\")\n\n    def test_patient_not_found(self):\n        # Test invalid patient_key raises ValueError\n        with self.assertRaises(ValueError) as context:\n            build_patient_summary(\"P999\", \"Template\")\n        self.assertEqual(str(context.exception), \"Patient not found\")\n\n    def test_sensitive_diagnosis_access(self):\n        # Test accessing diagnosis raises ValueError\n        with self.assertRaises(ValueError) as context:\n            build_patient_summary(\"P001\", \"Diagnosis: {patient.diagnosis}\")\n        self.assertEqual(str(context.exception), \"Access to diagnosis is not allowed in reports\")\n\n    def test_sensitive_treatment_plan_access(self):\n        # Test accessing treatment_plan raises ValueError\n        with self.assertRaises(ValueError) as context:\n            build_patient_summary(\"P001\", \"Treatment: {patient.treatment_plan}\")\n        self.assertEqual(str(context.exception), \"Access to treatment_plan is not allowed in reports\")\n\n    def test_template_no_placeholders(self):\n        # Test template without placeholders returns unchanged\n        result = build_patient_summary(\"P001\", \"Hello World\")\n        self.assertEqual(result, \"Hello World\")\n\n    def test_empty_template(self):\n        # Test empty template returns empty string\n        result = build_patient_summary(\"P001\", \"\")\n        self.assertEqual(result, \"\")\n\n    def test_multiple_valid_fields(self):\n        # Test template with multiple non-sensitive fields\n        result = build_patient_summary(\"P002\", \"Name: {patient.name}, Gender: {patient.gender}, Age: {patient.age}\")\n        self.assertEqual(result, \"Name: Jane Smith, Gender: Female, Age: 25\")\n\n    def test_patient_empty_fields(self):\n        # Test patient with empty non-sensitive fields\n        result = build_patient_summary(\"P003\", \"Name: '{patient.name}', Age: {patient.age}, Gender: '{patient.gender}'\")\n        self.assertEqual(result, \"Name: '', Age: 0, Gender: ''\")\n\n    def test_invalid_field_access(self):\n        # Test accessing non-existent field raises AttributeError\n        with self.assertRaises(AttributeError):\n            build_patient_summary(\"P001\", \"Address: {patient.address}\")\n\n    def test_large_age_value(self):\n        # Test very large age value\n        patients[\"P004\"] = Patient(\"Old Patient\", 150, \"Unknown\", \"Old Age\", \"None\")\n        result = build_patient_summary(\"P004\", \"Age: {patient.age}\")\n        self.assertEqual(result, \"Age: 150\")\n        del patients[\"P004\"]  # Clean up\n\n    def test_special_characters_in_name(self):\n        # Test special characters in name field\n        patients[\"P005\"] = Patient(\"O\\\"Reilly\", 40, \"Male\", \"None\", \"None\")\n        result = build_patient_summary(\"P005\", \"Name: {patient.name}\")\n        self.assertEqual(result, \"Name: O\\\"Reilly\")\n        del patients[\"P005\"]\n\n    def test_very_long_template(self):\n        # Test very long template string\n        long_template = \"{\" + \"patient.name}\" * 1000\n        result = build_patient_summary(\"P001\", long_template)\n        self.assertEqual(result, \"John Doe\" * 1000)\n\n    def test_none_patient_key(self):\n        # Test None patient_key\n        with self.assertRaises(ValueError):\n            build_patient_summary(None, \"Template\")\n\n    def test_none_template_string(self):\n        # Test None template_string\n        with self.assertRaises(AttributeError):\n            build_patient_summary(\"P001\", None)", "num_test_cases": 15, "task_id": "0e49b448"}
{"test": "import unittest\nfrom unittest.mock import patch\nimport solution\n\n# Define a Patient class for testing\nclass Patient:\n    def __init__(self, name, age, gender, diagnosis, treatment_plan):\n        self.name = name\n        self.age = age\n        self.gender = gender\n        self.diagnosis = diagnosis\n        self.treatment_plan = treatment_plan\n\n# Test patient data\ntest_patients = {\n    'p001': Patient('John Doe', 30, 'Male', 'Flu', 'Rest and hydration'),\n    'p002': Patient('Jane Smith', 25, 'Female', 'Cold', 'Medication'),\n    'p003': Patient('', 0, '', 'None', 'None')\n}\n\nclass TestComposePatientReport(unittest.TestCase):\n    def setUp(self):\n        # Patch the global 'patients' in the solution module\n        self.patcher = patch('solution.patients', test_patients)\n        self.patcher.start()\n    \n    def tearDown(self):\n        # Stop patching\n        self.patcher.stop()\n    \n    def test_case_1(self):\n        # Happy path: single allowed field\n        result = solution.compose_patient_report('p001', 'Name: {patient.name}')\n        self.assertEqual(result, 'Name: John Doe')\n    \n    def test_case_2(self):\n        # Patient not found\n        with self.assertRaises(ValueError):\n            solution.compose_patient_report('p999', 'Any template')\n    \n    def test_case_3(self):\n        # Disallowed field: diagnosis\n        with self.assertRaises(ValueError):\n            solution.compose_patient_report('p001', 'Diagnosis: {patient.diagnosis}')\n    \n    def test_case_4(self):\n        # Disallowed field: treatment_plan\n        with self.assertRaises(ValueError):\n            solution.compose_patient_report('p001', 'Treatment: {patient.treatment_plan}')\n    \n    def test_case_5(self):\n        # Non-existent field\n        with self.assertRaises(AttributeError):\n            solution.compose_patient_report('p001', 'Height: {patient.height}')\n    \n    def test_case_6(self):\n        # Multiple allowed fields\n        result = solution.compose_patient_report('p001', 'Name: {patient.name}, Age: {patient.age}, Gender: {patient.gender}')\n        self.assertEqual(result, 'Name: John Doe, Age: 30, Gender: Male')\n    \n    def test_case_7(self):\n        # Empty template\n        result = solution.compose_patient_report('p001', '')\n        self.assertEqual(result, '')\n    \n    def test_case_8(self):\n        # Empty field value\n        result = solution.compose_patient_report('p003', 'Name: {patient.name}')\n        self.assertEqual(result, 'Name: ')\n    \n    def test_case_9(self):\n        # Mixed fields: disallowed field first\n        with self.assertRaises(ValueError):\n            solution.compose_patient_report('p001', 'Diagnosis: {patient.diagnosis}, Name: {patient.name}')\n    \n    def test_case_10(self):\n        # Mixed fields: disallowed field last\n        with self.assertRaises(ValueError):\n            solution.compose_patient_report('p001', 'Name: {patient.name}, Diagnosis: {patient.diagnosis}')\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 10, "task_id": "93e5c5fe"}
{"test": "import unittest\nfrom unittest.mock import patch\n\nclass Employee:\n    def __init__(self, name, position, department, salary, personal_email):\n        self.name = name\n        self.position = position\n        self.department = department\n        self.team = department\n        self.salary = salary\n        self.personal_email = personal_email\n\ntest_employees = [\n    Employee('John Doe', 'Manager', 'HR', 50000, 'john@example.com'),\n    Employee('Jane Smith', 'Developer', 'IT', 60000, 'jane@example.com'),\n    Employee('Jim Brown', 'Accountant', 'Finance', 55000, 'jim@example.com'),\n    Employee('Jake White', 'Developer', 'IT', 62000, 'jake@example.com'),\n    Employee('Ghost', 'Unknown', '', 0, 'ghost@example.com'),\n    Employee('John O\\'Doe', 'Designer', 'IT', 70000, 'john_odoe@example.com')\n]\n\nclass TestGenerateDepartmentDirectory(unittest.TestCase):\n    def setUp(self):\n        self.patcher = patch('solution.employees', test_employees)\n        self.patcher.start()\n\n    def tearDown(self):\n        self.patcher.stop()\n\n    def test_happy_path_one_employee(self):\n        # Test typical case: one employee in HR department with allowed attributes\n        dept_name = 'HR'\n        template = 'Name: {employee.name}, Position: {employee.position}'\n        result = generate_department_directory(dept_name, template)\n        expected = 'Name: John Doe, Position: Manager'\n        self.assertEqual(result, expected)\n\n    def test_happy_path_multiple_employees(self):\n        # Test multiple employees in IT department\n        dept_name = 'IT'\n        template = 'Name: {employee.name}'\n        result = generate_department_directory(dept_name, template)\n        expected = \"Name: Jane Smith\\nName: Jake White\\nName: John O'Doe\"\n        self.assertEqual(result, expected)\n\n    def test_no_employees_in_department(self):\n        # Test department with no matching employees\n        dept_name = 'Marketing'\n        template = 'Name: {employee.name}'\n        result = generate_department_directory(dept_name, template)\n        expected = ''\n        self.assertEqual(result, expected)\n\n    def test_blocked_attribute_wage(self):\n        # Test accessing blocked attribute 'wage'\n        dept_name = 'HR'\n        template = 'Wage: {employee.wage}'\n        with self.assertRaises(ValueError):\n            generate_department_directory(dept_name, template)\n\n    def test_blocked_attribute_contact_info(self):\n        # Test accessing blocked attribute 'contact_info'\n        dept_name = 'HR'\n        template = 'Contact: {employee.contact_info}'\n        with self.assertRaises(ValueError):\n            generate_department_directory(dept_name, template)\n\n    def test_sensitive_but_not_blocked_salary(self):\n        # Test accessing sensitive attribute 'salary' (not blocked by function)\n        dept_name = 'HR'\n        template = 'Salary: {employee.salary}'\n        result = generate_department_directory(dept_name, template)\n        expected = 'Salary: 50000'\n        self.assertEqual(result, expected)\n\n    def test_sensitive_but_not_blocked_personal_email(self):\n        # Test accessing sensitive attribute 'personal_email' (not blocked)\n        dept_name = 'HR'\n        template = 'Email: {employee.personal_email}'\n        result = generate_department_directory(dept_name, template)\n        expected = 'Email: john@example.com'\n        self.assertEqual(result, expected)\n\n    def test_non_existing_attribute(self):\n        # Test accessing non-existing attribute\n        dept_name = 'HR'\n        template = 'Attr: {employee.non_existent}'\n        with self.assertRaises(AttributeError):\n            generate_department_directory(dept_name, template)\n\n    def test_empty_template(self):\n        # Test empty template string\n        dept_name = 'IT'\n        template = ''\n        result = generate_department_directory(dept_name, template)\n        expected = '\\n\\n'\n        self.assertEqual(result, expected)\n\n    def test_template_without_placeholder(self):\n        # Test template without placeholders\n        dept_name = 'IT'\n        template = 'Employee Record'\n        result = generate_department_directory(dept_name, template)\n        expected = 'Employee Record\\nEmployee Record\\nEmployee Record'\n        self.assertEqual(result, expected)\n\n    def test_department_empty_string(self):\n        # Test department name as empty string\n        dept_name = ''\n        template = 'Name: {employee.name}'\n        result = generate_department_directory(dept_name, template)\n        expected = 'Name: Ghost'\n        self.assertEqual(result, expected)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 11, "task_id": "b97133af"}
{"test": "import unittest\nimport solution\n\nclass Employee:\n    def __init__(self, name, position, department, salary, personal_email):\n        self.name = name\n        self.position = position\n        self.department = department\n        self.salary = salary\n        self.personal_email = personal_email\n\nclass TestCompileDepartmentRoster(unittest.TestCase):\n    def setUp(self):\n        self.employees = [\n            Employee('John Doe', 'Developer', 'Engineering', 70000, 'john@example.com'),\n            Employee('Jane Smith', 'Manager', 'Engineering', 80000, 'jane@example.com'),\n            Employee('Jim Brown', 'HR Manager', 'Human Resources', 65000, 'jim@example.com')\n        ]\n        solution.employees = self.employees\n\n    def test_one_employee(self):\n        # Test formatting one employee with safe attributes\n        division = 'Human Resources'\n        template = 'Name: {employee.name}'\n        result = solution.compile_department_roster(division, template)\n        self.assertEqual(result, 'Name: Jim Brown')\n\n    def test_two_employees(self):\n        # Test formatting two employees with safe attributes\n        division = 'Engineering'\n        template = 'Name: {employee.name}'\n        result = solution.compile_department_roster(division, template)\n        self.assertEqual(result, 'Name: John Doe\\nName: Jane Smith')\n\n    def test_no_employees(self):\n        # Test division with no matching employees\n        division = 'Marketing'\n        template = 'Name: {employee.name}'\n        result = solution.compile_department_roster(division, template)\n        self.assertEqual(result, '')\n\n    def test_restricted_salary(self):\n        # Test template accessing restricted 'salary' attribute\n        division = 'Engineering'\n        template = 'Name: {employee.name}, Salary: {employee.salary}'\n        with self.assertRaises(ValueError):\n            solution.compile_department_roster(division, template)\n\n    def test_restricted_personal_email(self):\n        # Test template accessing restricted 'personal_email' attribute\n        division = 'Engineering'\n        template = 'Email: {employee.personal_email}'\n        with self.assertRaises(ValueError):\n            solution.compile_department_roster(division, template)\n\n    def test_non_existing_attribute(self):\n        # Test template accessing non-existing attribute\n        division = 'Engineering'\n        template = 'Age: {employee.age}'\n        with self.assertRaises(AttributeError):\n            solution.compile_department_roster(division, template)\n\n    def test_case_sensitivity(self):\n        # Test case sensitivity in division name\n        division = 'engineering'\n        template = 'Name: {employee.name}'\n        result = solution.compile_department_roster(division, template)\n        self.assertEqual(result, '')\n\n    def test_empty_division(self):\n        # Test empty division name\n        division = ''\n        template = 'Name: {employee.name}'\n        result = solution.compile_department_roster(division, template)\n        self.assertEqual(result, '')\n\n    def test_empty_template_one_employee(self):\n        # Test empty template with one employee\n        division = 'Human Resources'\n        template = ''\n        result = solution.compile_department_roster(division, template)\n        self.assertEqual(result, '')\n\n    def test_empty_template_two_employees(self):\n        # Test empty template with two employees\n        division = 'Engineering'\n        template = ''\n        result = solution.compile_department_roster(division, template)\n        self.assertEqual(result, '\\n')\n\n    def test_none_template(self):\n        # Test None as template (should raise AttributeError)\n        division = 'Engineering'\n        with self.assertRaises(AttributeError):\n            solution.compile_department_roster(division, None)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 11, "task_id": "c2acc881"}
{"test": "import unittest\n\n# Define the Employee class and the function as per the task requirements\nclass Employee:\n    def __init__(self, name, position, department, salary, personal_email):\n        self.name = name\n        self.position = position\n        self.department = department\n        self.salary = salary\n        self.personal_email = personal_email\n\n# Global employees list to be used by the function\nemployees = []\n\ndef build_team_directory(team, template_text):\n    directory = []\n    for employee in employees:\n        if employee.department == team:\n            class SafeEmployee:\n                def __init__(self, emp):\n                    self._emp = emp\n\n                def __getattr__(self, sensitive_attr):\n                    if sensitive_attr in ['salary', 'personal_email']:\n                        raise ValueError(f\"Access to {sensitive_attr} is not permitted in the directory\")\n                    return getattr(self._emp, sensitive_attr)\n\n            protected_employee = SafeEmployee(employee)\n            directory.append(template_text.format(employee=protected_employee))\n    return \"\\n\".join(directory)\n\nclass TestBuildTeamDirectory(unittest.TestCase):\n    def setUp(self):\n        global employees\n        # Create test employees\n        self.emp1 = Employee(\"John Doe\", \"Manager\", \"HR\", 100000, \"john@example.com\")\n        self.emp2 = Employee(\"Jane Smith\", \"Developer\", \"IT\", 90000, \"jane@example.com\")\n        self.emp3 = Employee(\"Jim Brown\", \"Analyst\", \"Finance\", 80000, \"jim@example.com\")\n        self.emp4 = Employee(\"Jill White\", \"Developer\", \"IT\", 95000, \"jill@example.com\")\n        employees = [self.emp1, self.emp2, self.emp3, self.emp4]\n    \n    def test_case_1(self):\n        # Test filtering for IT department with two employees\n        result = build_team_directory(\"IT\", \"Name: {employee.name}, Position: {employee.position}\")\n        expected = \"Name: Jane Smith, Position: Developer\\nName: Jill White, Position: Developer\"\n        self.assertEqual(result, expected)\n    \n    def test_case_2(self):\n        # Test filtering for HR department (one employee)\n        result = build_team_directory(\"HR\", \"Name: {employee.name}\")\n        self.assertEqual(result, \"Name: John Doe\")\n    \n    def test_case_3(self):\n        # Test department with no employees (Marketing)\n        result = build_team_directory(\"Marketing\", \"Name: {employee.name}\")\n        self.assertEqual(result, \"\")\n    \n    def test_case_4(self):\n        # Test accessing sensitive attribute 'salary'\n        with self.assertRaises(ValueError):\n            build_team_directory(\"IT\", \"Salary: {employee.salary}\")\n    \n    def test_case_5(self):\n        # Test accessing sensitive attribute 'personal_email'\n        with self.assertRaises(ValueError):\n            build_team_directory(\"IT\", \"Email: {employee.personal_email}\")\n    \n    def test_case_6(self):\n        # Test accessing non-existing attribute 'phone'\n        with self.assertRaises(AttributeError):\n            build_team_directory(\"IT\", \"Phone: {employee.phone}\")\n    \n    def test_case_7(self):\n        # Test employee with empty strings for attributes\n        global employees\n        emp5 = Employee(\"\", \"\", \"IT\", 0, \"\")\n        employees = [emp5]  # Override global list\n        result = build_team_directory(\"IT\", \"Name: '{employee.name}', Position: '{employee.position}'\")\n        self.assertEqual(result, \"Name: '', Position: ''\")\n    \n    def test_case_8(self):\n        # Test very long string in an attribute\n        global employees\n        long_name = \"A\" * 1000\n        emp = Employee(long_name, \"Tester\", \"QA\", 50000, \"test@example.com\")\n        employees = [emp]  # Override global list\n        result = build_team_directory(\"QA\", \"Name: {employee.name}\")\n        self.assertEqual(result, f\"Name: {long_name}\")\n    \n    def test_case_9(self):\n        # Test template without placeholders\n        result = build_team_directory(\"IT\", \"No placeholders here!\")\n        self.assertEqual(result, \"No placeholders here!\\nNo placeholders here!\")\n    \n    def test_case_10(self):\n        # Test multiple placeholders in template\n        result = build_team_directory(\"Finance\", \"Dept: {employee.department}, Name: {employee.name}\")\n        self.assertEqual(result, \"Dept: Finance, Name: Jim Brown\")\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 10, "task_id": "7c2ce56f"}
{"test": "import unittest\nfrom unittest.mock import patch\n\n# Define the Employee class for testing\nclass Employee:\n    def __init__(self, name, position, department, salary, personal_email):\n        self.name = name\n        self.position = position\n        self.department = department\n        self.salary = salary\n        self.personal_email = personal_email\n\n# Import the function from the assumed module\n# Replace 'employee_module' with the actual module name if different\nfrom employee_module import generate_team_roster\n\nclass TestGenerateTeamRoster(unittest.TestCase):\n    def setUp(self):\n        # Create sample employees for testing\n        self.emp1 = Employee(\"John Doe\", \"Developer\", \"Engineering\", 80000, \"john@example.com\")\n        self.emp2 = Employee(\"Jane Smith\", \"Manager\", \"Engineering\", 90000, \"jane@example.com\")\n        self.emp3 = Employee(\"Jim Brown\", \"Designer\", \"Design\", 70000, \"jim@example.com\")\n        self.emp4 = Employee(\"Jake Blues\", \"HR Manager\", \"HR\", 85000, \"jake@example.com\")\n        self.all_employees = [self.emp1, self.emp2, self.emp3, self.emp4]\n    \n    def test_happy_path_engineering(self):\n        # Test typical Engineering department with valid template\n        template = 'Name: {employee.name}, Position: {employee.position}'\n        with patch('employee_module.employees', self.all_employees):\n            result = generate_team_roster('Engineering', template)\n        self.assertIn('Name: John Doe, Position: Developer', result)\n        self.assertIn('Name: Jane Smith, Position: Manager', result)\n        self.assertEqual(len(result.split('\\n')), 2)\n    \n    def test_happy_path_hr(self):\n        # Test HR department with valid template\n        template = '{employee.name} - {employee.position}'\n        with patch('employee_module.employees', self.all_employees):\n            result = generate_team_roster('HR', template)\n        self.assertEqual(result, 'Jake Blues - HR Manager')\n    \n    def test_empty_department(self):\n        # Test department with no employees\n        template = 'Name: {employee.name}'\n        with patch('employee_module.employees', self.all_employees):\n            result = generate_team_roster('Marketing', template)\n        self.assertEqual(result, '')\n    \n    def test_empty_template(self):\n        # Test empty template string\n        template = ''\n        with patch('employee_module.employees', self.all_employees):\n            result = generate_team_roster('Engineering', template)\n        self.assertEqual(result, '\\n')\n    \n    def test_restricted_field_salary(self):\n        # Test accessing restricted 'salary' field\n        template = 'Name: {employee.name}, Salary: {employee.salary}'\n        with patch('employee_module.employees', self.all_employees):\n            with self.assertRaises(ValueError) as context:\n                generate_team_roster('Engineering', template)\n        self.assertIn('Access to salary is not allowed', str(context.exception))\n    \n    def test_restricted_field_personal_email(self):\n        # Test accessing restricted 'personal_email' field\n        template = 'Contact: {employee.personal_email}'\n        with patch('employee_module.employees', self.all_employees):\n            with self.assertRaises(ValueError) as context:\n                generate_team_roster('Design', template)\n        self.assertIn('Access to personal_email is not allowed', str(context.exception))\n    \n    def test_non_existent_field(self):\n        # Test accessing non-existent field\n        template = 'Name: {employee.name}, Age: {employee.age}'\n        with patch('employee_module.employees', self.all_employees):\n            with self.assertRaises(AttributeError):\n                generate_team_roster('Engineering', template)\n    \n    def test_large_input(self):\n        # Test with large number of employees\n        many_employees = [Employee(f\"Employee{i}\", \"Position{i}\", \"LargeDept\", i*1000, f\"emp{i}@example.com\") for i in range(1000)]\n        template = 'ID: {employee.name}'\n        with patch('employee_module.employees', many_employees):\n            result = generate_team_roster('LargeDept', template)\n        self.assertEqual(len(result.split('\\n')), 1000)\n    \n    def test_special_characters(self):\n        # Test special characters in employee data\n        emp = Employee(\"A&B <>\", \"C# Dev\", \"Engineering\", 80000, \"a&b@example.com\")\n        template = 'Name: {employee.name}, Position: {employee.position}'\n        with patch('employee_module.employees', [emp]):\n            result = generate_team_roster('Engineering', template)\n        self.assertEqual(result, 'Name: A&B <>, Position: C# Dev')", "num_test_cases": 9, "task_id": "1852a580"}
{"test": "import unittest\nfrom unittest.mock import patch\nimport worker_utils\nfrom worker_utils import build_worker_list\n\nclass TestBuildWorkerList(unittest.TestCase):\n    class Employee:\n        pass\n\n    def test_basic_functionality(self):\n        \"\"\"Test typical case with one employee and allowed fields.\"\"\"\n        emp1 = self.Employee()\n        emp1.name = 'John Doe'\n        emp1.position = 'Developer'\n        emp1.department = 'Engineering'\n        employees_list = [emp1]\n        \n        with patch('worker_utils.employees', employees_list):\n            result = build_worker_list('Engineering', \"Name: {employee.name}, Position: {employee.position}\")\n            self.assertEqual(result, \"Name: John Doe, Position: Developer\")\n\n    def test_multiple_employees(self):\n        \"\"\"Test multiple employees in the same department.\"\"\"\n        emp1 = self.Employee()\n        emp1.name = 'John Doe'\n        emp1.position = 'Developer'\n        emp1.department = 'Engineering'\n        \n        emp2 = self.Employee()\n        emp2.name = 'Alice Smith'\n        emp2.position = 'Manager'\n        emp2.department = 'Engineering'\n        \n        emp3 = self.Employee()\n        emp3.name = 'Bob Brown'\n        emp3.position = 'HR'\n        emp3.department = 'HR'\n        \n        employees_list = [emp1, emp2, emp3]\n        \n        with patch('worker_utils.employees', employees_list):\n            result = build_worker_list('Engineering', \"Name: {employee.name}, Position: {employee.position}\")\n            expected = \"Name: John Doe, Position: Developer\\nName: Alice Smith, Position: Manager\"\n            self.assertEqual(result, expected)\n\n    def test_no_employees_in_department(self):\n        \"\"\"Test department with no employees.\"\"\"\n        emp1 = self.Employee()\n        emp1.department = 'HR'\n        employees_list = [emp1]\n        \n        with patch('worker_utils.employees', employees_list):\n            result = build_worker_list('Engineering', \"Name: {employee.name}\")\n            self.assertEqual(result, \"\")\n\n    def test_restricted_field_in_template(self):\n        \"\"\"Test template accessing restricted salary field.\"\"\"\n        emp1 = self.Employee()\n        emp1.department = 'Engineering'\n        employees_list = [emp1]\n        \n        with patch('worker_utils.employees', employees_list):\n            with self.assertRaises(ValueError):\n                build_worker_list('Engineering', \"Name: {employee.name}, Salary: {employee.salary}\")\n\n    def test_non_existing_field_in_template(self):\n        \"\"\"Test template accessing non-existing field.\"\"\"\n        emp1 = self.Employee()\n        emp1.department = 'Engineering'\n        employees_list = [emp1]\n        \n        with patch('worker_utils.employees', employees_list):\n            with self.assertRaises(AttributeError):\n                build_worker_list('Engineering', \"Name: {employee.name}, Phone: {employee.phone}\")\n\n    def test_empty_team_name(self):\n        \"\"\"Test empty team name matching employee with empty department.\"\"\"\n        emp1 = self.Employee()\n        emp1.name = 'John Doe'\n        emp1.department = ''\n        employees_list = [emp1]\n        \n        with patch('worker_utils.employees', employees_list):\n            result = build_worker_list('', \"Name: {employee.name}\")\n            self.assertEqual(result, \"Name: John Doe\")\n\n    def test_empty_template(self):\n        \"\"\"Test empty template string with one and two employees.\"\"\"\n        emp1 = self.Employee()\n        emp1.department = 'Engineering'\n        \n        emp2 = self.Employee()\n        emp2.department = 'Engineering'\n        \n        # Test with one employee\n        with patch('worker_utils.employees', [emp1]):\n            result = build_worker_list('Engineering', \"\")\n            self.assertEqual(result, \"\")\n            \n        # Test with two employees\n        with patch('worker_utils.employees', [emp1, emp2]):\n            result = build_worker_list('Engineering', \"\")\n            self.assertEqual(result, \"\\n\")\n\n    def test_team_name_none(self):\n        \"\"\"Test None team name matching employee with None department.\"\"\"\n        emp1 = self.Employee()\n        emp1.name = 'John Doe'\n        emp1.department = None\n        employees_list = [emp1]\n        \n        with patch('worker_utils.employees', employees_list):\n            result = build_worker_list(None, \"Name: {employee.name}\")\n            self.assertEqual(result, \"Name: John Doe\")\n\n    def test_team_name_integer_matching(self):\n        \"\"\"Test integer team name matching employee with same integer department.\"\"\"\n        emp1 = self.Employee()\n        emp1.name = 'John Doe'\n        emp1.department = 123\n        employees_list = [emp1]\n        \n        with patch('worker_utils.employees', employees_list):\n            result = build_worker_list(123, \"Name: {employee.name}\")\n            self.assertEqual(result, \"Name: John Doe\")\n\n    def test_team_name_integer_not_matching(self):\n        \"\"\"Test integer team name not matching employee department.\"\"\"\n        emp1 = self.Employee()\n        emp1.name = 'John Doe'\n        emp1.department = 123\n        employees_list = [emp1]\n        \n        with patch('worker_utils.employees', employees_list):\n            result = build_worker_list(456, \"Name: {employee.name}\")\n            self.assertEqual(result, \"\")\n\n    def test_long_strings(self):\n        \"\"\"Test with very long strings for attributes and department.\"\"\"\n        long_string = 'A' * 1000\n        emp1 = self.Employee()\n        emp1.name = long_string\n        emp1.position = long_string\n        emp1.department = long_string\n        employees_list = [emp1]\n        \n        with patch('worker_utils.employees', employees_list):\n            result = build_worker_list(long_string, \"Name: {employee.name}, Position: {employee.position}\")\n            expected = f\"Name: {long_string}, Position: {long_string}\"\n            self.assertEqual(result, expected)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 11, "task_id": "201056af"}
{"test": "import unittest\n\n# Define the Employee class for testing\nclass Employee:\n    def __init__(self, name, position, department, salary, personal_email):\n        self.name = name\n        self.position = position\n        self.department = department\n        self.salary = salary\n        self.personal_email = personal_email\n\n# Global employees list (to be set in tests)\nemployees = []\n\ndef assemble_employee_list(dept_name, template):\n    employee_list = []\n    for employee in employees:\n        if employee.department == dept_name:\n            class SecureEmployee:\n                def __init__(self, emp):\n                    self._emp = emp\n\n                def __getattr__(self, attr_name):\n                    if attr_name in ['salary', 'personal_email']:\n                        raise ValueError(f\"Access to {attr_name} is not allowed in the directory\")\n                    return getattr(self._emp, attr_name)\n            \n            secured_employee = SecureEmployee(employee)\n            employee_list.append(template.format(employee=secured_employee))\n    return \"\\n\".join(employee_list)\n\nclass TestAssembleEmployeeList(unittest.TestCase):\n    def setUp(self):\n        global employees\n        self.emp1 = Employee('John Doe', 'Developer', 'Engineering', 50000, 'john@example.com')\n        self.emp2 = Employee('Jane Smith', 'Manager', 'HR', 60000, 'jane@example.com')\n        self.emp3 = Employee('Alice Wonder', 'Designer', 'Engineering', 55000, 'alice@example.com')\n        employees = [self.emp1, self.emp2, self.emp3]\n    \n    def tearDown(self):\n        global employees\n        employees = []\n\n    def test_engineering_department(self):\n        # Test multiple employees in Engineering with allowed fields\n        template = \"Name: {employee.name}, Position: {employee.position}\"\n        result = assemble_employee_list('Engineering', template)\n        self.assertIn(\"Name: John Doe, Position: Developer\", result)\n        self.assertIn(\"Name: Alice Wonder, Position: Designer\", result)\n        self.assertEqual(len(result.split('\\n')), 2)\n\n    def test_hr_department(self):\n        # Test single employee in HR with allowed field\n        template = \"Name: {employee.name}\"\n        result = assemble_employee_list('HR', template)\n        self.assertEqual(result, \"Name: Jane Smith\")\n\n    def test_department_not_exist(self):\n        # Test non-existent department\n        template = \"Name: {employee.name}\"\n        result = assemble_employee_list('Marketing', template)\n        self.assertEqual(result, \"\")\n\n    def test_restricted_salary_field(self):\n        # Test template accessing restricted 'salary' field\n        template = \"Salary: {employee.salary}\"\n        with self.assertRaises(ValueError) as context:\n            assemble_employee_list('Engineering', template)\n        self.assertIn(\"Access to salary is not allowed\", str(context.exception))\n\n    def test_restricted_email_field(self):\n        # Test template accessing restricted 'personal_email' field\n        template = \"Email: {employee.personal_email}\"\n        with self.assertRaises(ValueError) as context:\n            assemble_employee_list('Engineering', template)\n        self.assertIn(\"Access to personal_email is not allowed\", str(context.exception))\n\n    def test_mixed_restricted_field(self):\n        # Test template mixing allowed and restricted field\n        template = \"Name: {employee.name}, Email: {employee.personal_email}\"\n        with self.assertRaises(ValueError) as context:\n            assemble_employee_list('Engineering', template)\n        self.assertIn(\"Access to personal_email is not allowed\", str(context.exception))\n\n    def test_non_existent_field(self):\n        # Test template accessing non-existent attribute\n        template = \"Name: {employee.name}, Age: {employee.age}\"\n        with self.assertRaises(AttributeError):\n            assemble_employee_list('Engineering', template)\n\n    def test_extra_allowed_field(self):\n        # Test template accessing extra allowed field\n        global employees\n        emp4 = Employee('Test', 'Tester', 'QA', 30000, 'test@example.com')\n        emp4.phone = '12345'\n        employees = [emp4]\n        template = \"Phone: {employee.phone}\"\n        result = assemble_employee_list('QA', template)\n        self.assertEqual(result, \"Phone: 12345\")\n\n    def test_empty_template_multiple_employees(self):\n        # Test empty template with multiple employees\n        result = assemble_employee_list('Engineering', '')\n        self.assertEqual(result, \"\\n\")\n\n    def test_empty_template_single_employee(self):\n        # Test empty template with single employee\n        result = assemble_employee_list('HR', '')\n        self.assertEqual(result, \"\")\n\n    def test_empty_template_no_employees(self):\n        # Test empty template with no matching employees\n        result = assemble_employee_list('Marketing', '')\n        self.assertEqual(result, \"\")\n\n    def test_all_attributes_allowed(self):\n        # Test template with all allowed attributes\n        template = \"Dept: {employee.department}, Name: {employee.name}, Role: {employee.position}\"\n        result = assemble_employee_list('Engineering', template)\n        self.assertIn(\"Dept: Engineering, Name: John Doe, Role: Developer\", result)\n        self.assertIn(\"Dept: Engineering, Name: Alice Wonder, Role: Designer\", result)\n\n    def test_different_department_format(self):\n        # Test different department with specific format\n        template = \"{employee.position} - {employee.name}\"\n        result = assemble_employee_list('HR', template)\n        self.assertEqual(result, \"Manager - Jane Smith\")\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 14, "task_id": "c4c96a50"}
{"test": "import unittest\nfrom unittest.mock import patch\n\n# Define the Employee class for testing\nclass Employee:\n    def __init__(self, name, position, department, salary, personal_email):\n        self.name = name\n        self.position = position\n        self.department = department\n        self.salary = salary\n        self.personal_email = personal_email\n\n# Test employee data\ntest_employees = [\n    Employee(\"John Doe\", \"Software Engineer\", \"Engineering\", 100000, \"john@example.com\"),\n    Employee(\"Jane Smith\", \"Product Manager\", \"Product\", 120000, \"jane@example.com\"),\n    Employee(\"Alice Johnson\", \"HR Specialist\", \"HR\", 85000, \"alice@example.com\"),\n    Employee(\"Bob Brown\", \"Intern\", \"Engineering\", 30000, \"bob@example.com\"),\n    Employee(\"Eve White\", \"Consultant\", None, 90000, \"eve@example.com\")\n]\n\nclass TestEmployeeDirectory(unittest.TestCase):\n    @classmethod\n    def setUpClass(cls):\n        # Patch the 'employees' list in the module where the function is defined\n        cls.emp_patch = patch('solution.employees', test_employees)\n        cls.emp_patch.start()\n\n    @classmethod\n    def tearDownClass(cls):\n        cls.emp_patch.stop()\n\n    def test_typical_case(self):\n        # Test typical usage with safe attributes and multiple employees\n        result = build_team_directory(\"Engineering\", \"{employee.name} - {employee.position}\")\n        expected = \"John Doe - Software Engineer\\nBob Brown - Intern\"\n        self.assertEqual(result, expected)\n\n    def test_empty_department(self):\n        # Test department with no matching employees\n        result = build_team_directory(\"Marketing\", \"{employee.name}\")\n        self.assertEqual(result, \"\")\n\n    def test_sensitive_attribute_salary(self):\n        # Test template accessing 'salary' raises ValueError\n        with self.assertRaises(ValueError):\n            build_team_directory(\"Engineering\", \"{employee.salary}\")\n\n    def test_sensitive_attribute_personal_email(self):\n        # Test template accessing 'personal_email' raises ValueError\n        with self.assertRaises(ValueError):\n            build_team_directory(\"Engineering\", \"{employee.personal_email}\")\n\n    def test_nonexistent_attribute(self):\n        # Test template accessing non-existent attribute raises AttributeError\n        with self.assertRaises(AttributeError):\n            build_team_directory(\"Engineering\", \"{employee.phone}\")\n\n    def test_empty_template_multiple_employees(self):\n        # Test empty template with department having multiple employees\n        result = build_team_directory(\"Engineering\", \"\")\n        self.assertEqual(result, \"\\n\")\n        self.assertEqual(len(result.split('\\n')), 2)\n\n    def test_empty_template_single_employee(self):\n        # Test empty template with department having one employee\n        result = build_team_directory(\"HR\", \"\")\n        self.assertEqual(result, \"\")\n\n    def test_none_department(self):\n        # Test department name None returns employee with department None\n        result = build_team_directory(None, \"{employee.name}\")\n        self.assertEqual(result, \"Eve White\")\n\n    def test_empty_department_name(self):\n        # Test empty string department name\n        result = build_team_directory(\"\", \"{employee.name}\")\n        self.assertEqual(result, \"\")\n\n    def test_case_sensitive_department_name(self):\n        # Test case sensitivity in department name\n        result = build_team_directory(\"engineering\", \"{employee.name}\")\n        self.assertEqual(result, \"\")", "num_test_cases": 10, "task_id": "5b74f91a"}
{"test": "import unittest\n\n# Define the Employee class for testing\nclass Employee:\n    def __init__(self, name, position, department, salary, personal_email):\n        self.name = name\n        self.position = position\n        self.department = department\n        self.salary = salary\n        self.personal_email = personal_email\n\n# Global variable that the function uses\nemployees = None\n\n# Function implementation as provided\ndef generate_staff_listing(dep, format_template):\n    directory = []\n    for worker in employees:\n        if worker.department == dep:\n            class ProtectedEmployee:\n                def __init__(self, e):\n                    self._e = e\n                \n                def __getattr__(self, attr):\n                    if attr in ['salary', 'personal_email']:\n                        raise ValueError(f\"Access to {attr} is not allowed in the directory\")\n                    return getattr(self._e, attr)\n            \n            protected_worker = ProtectedEmployee(worker)\n            directory.append(format_template.format(employee=protected_worker))\n    return \"\\n\".join(directory)\n\nclass TestGenerateStaffListing(unittest.TestCase):\n    def setUp(self):\n        # Set up global employees before each test\n        global employees\n        employees = [\n            Employee(\"John Doe\", \"Engineer\", \"Engineering\", 100000, \"john@example.com\"),\n            Employee(\"Jane Smith\", \"Manager\", \"Engineering\", 150000, \"jane@example.com\"),\n            Employee(\"Alice Johnson\", \"HR\", \"Human Resources\", 120000, \"alice@example.com\"),\n            Employee(\"Bob Brown\", \"Intern\", \"\", 40000, \"bob@example.com\")\n        ]\n    \n    def test_basic_functionality(self):\n        # Test typical usage with multiple employees in Engineering\n        result = generate_staff_listing(\"Engineering\", \"{employee.name} - {employee.position}\")\n        expected = \"John Doe - Engineer\\nJane Smith - Manager\"\n        self.assertEqual(result, expected)\n    \n    def test_single_employee(self):\n        # Test department with only one employee\n        result = generate_staff_listing(\"Human Resources\", \"{employee.name}\")\n        self.assertEqual(result, \"Alice Johnson\")\n    \n    def test_no_employees(self):\n        # Test department with no employees\n        result = generate_staff_listing(\"Marketing\", \"{employee.name}\")\n        self.assertEqual(result, \"\")\n    \n    def test_multiple_fields(self):\n        # Test template with multiple non-sensitive fields\n        result = generate_staff_listing(\"Engineering\", \"{employee.name} ({employee.position}) in {employee.department}\")\n        expected = \"John Doe (Engineer) in Engineering\\nJane Smith (Manager) in Engineering\"\n        self.assertEqual(result, expected)\n    \n    def test_sensitive_field_salary(self):\n        # Test template accessing forbidden 'salary' field\n        with self.assertRaises(ValueError):\n            generate_staff_listing(\"Engineering\", \"Salary: {employee.salary}\")\n    \n    def test_sensitive_field_personal_email(self):\n        # Test template accessing forbidden 'personal_email' field\n        with self.assertRaises(ValueError):\n            generate_staff_listing(\"Engineering\", \"Email: {employee.personal_email}\")\n    \n    def test_non_existent_field(self):\n        # Test template accessing a non-existent field\n        with self.assertRaises(AttributeError):\n            generate_staff_listing(\"Engineering\", \"Age: {employee.age}\")\n    \n    def test_empty_department(self):\n        # Test employee with empty string department\n        result = generate_staff_listing(\"\", \"{employee.name}\")\n        self.assertEqual(result, \"Bob Brown\")\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 8, "task_id": "ea06dbee"}
{"test": "import unittest\nfrom unittest.mock import patch\n\n# Define Employee class for testing\nclass Employee:\n    def __init__(self, name, position, dept, wage, personal_email):\n        self.name = name\n        self.position = position\n        self.dept = dept\n        self.wage = wage\n        self.personal_email = personal_email\n\n# Test staff data\nTEST_STAFF = [\n    Employee(\"John Doe\", \"Engineer\", \"Engineering\", 50000, \"john@example.com\"),\n    Employee(\"Jane Smith\", \"Manager\", \"Engineering\", 70000, \"jane@example.com\"),\n    Employee(\"Jim Brown\", \"HR\", \"Human Resources\", 60000, \"jim@example.com\"),\n    Employee(\"Alice Wonder\", \"Admin\", \"\", 40000, \"alice@example.com\"),\n    Employee(\"Bob Builder\", \"Contractor\", None, 55000, \"bob@example.com\")\n]\n\nclass TestEmployeeDirectory(unittest.TestCase):\n    @classmethod\n    def setUpClass(cls):\n        # Patch 'solution.staff' with our test data\n        cls.patcher = patch('solution.staff', TEST_STAFF)\n        cls.patcher.start()\n        # Import the function from the solution module\n        from solution import create_team_roster\n        cls.create_team_roster = create_team_roster\n\n    @classmethod\n    def tearDownClass(cls):\n        cls.patcher.stop()\n\n    def test_case_1(self):\n        # Test basic functionality with expected input\n        result = self.create_team_roster(\"Engineering\", \"{employee.name}: {employee.position}\")\n        expected = \"John Doe: Engineer\\nJane Smith: Manager\"\n        self.assertEqual(result, expected)\n\n    def test_case_2(self):\n        # Test department with no employees\n        result = self.create_team_roster(\"Marketing\", \"{employee.name}\")\n        self.assertEqual(result, \"\")\n\n    def test_case_3(self):\n        # Test valid non-sensitive field access\n        result = self.create_team_roster(\"Engineering\", \"Dept: {employee.dept}\")\n        expected = \"Dept: Engineering\\nDept: Engineering\"\n        self.assertEqual(result, expected)\n\n    def test_case_4(self):\n        # Test access to sensitive field 'wage'\n        with self.assertRaises(ValueError) as context:\n            self.create_team_roster(\"Engineering\", \"Wage: {employee.wage}\")\n        self.assertIn(\"Access to wage is not allowed\", str(context.exception))\n\n    def test_case_5(self):\n        # Test access to sensitive field 'email'\n        with self.assertRaises(ValueError) as context:\n            self.create_team_roster(\"Engineering\", \"Email: {employee.email}\")\n        self.assertIn(\"Access to email is not allowed\", str(context.exception))\n\n    def test_case_6(self):\n        # Test non-existent field access\n        with self.assertRaises(AttributeError):\n            self.create_team_roster(\"Engineering\", \"Age: {employee.age}\")\n\n    def test_case_7(self):\n        # Test empty department string\n        result = self.create_team_roster(\"\", \"{employee.name}\")\n        self.assertEqual(result, \"Alice Wonder\")\n\n    def test_case_8(self):\n        # Test empty template string\n        result = self.create_team_roster(\"Engineering\", \"\")\n        self.assertEqual(result, \"\\n\")\n\n    def test_case_9(self):\n        # Test None as department\n        result = self.create_team_roster(None, \"{employee.name}\")\n        self.assertEqual(result, \"Bob Builder\")\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 9, "task_id": "dab167c5"}
{"test": "import unittest\nfrom unittest.mock import patch\n\nclass MockCustomer:\n    def __init__(self, name, email, home_address=None, payment_card=None):\n        self.name = name\n        self.email = email\n        self.home_address = home_address\n        self.payment_card = payment_card\n\nclass MockOrder:\n    def __init__(self, order_id, total, buyer, status=None):\n        self.order_id = order_id\n        self.total = total\n        self.buyer = buyer\n        self.status = status\n\nclass TestCreatePurchaseReceipt(unittest.TestCase):\n    def setUp(self):\n        # Patch the 'purchases' variable in the module where create_purchase_receipt is defined\n        self.patcher = patch(__name__ + '.purchases', {})\n        self.mock_purchases = self.patcher.start()\n\n    def tearDown(self):\n        self.patcher.stop()\n\n    def test_valid_order_and_template(self):\n        # Test with valid order ID and template with allowed placeholders\n        buyer = MockCustomer(\"John Doe\", \"john@example.com\")\n        order = MockOrder(\"order1\", 100.0, buyer)\n        self.mock_purchases[\"order1\"] = order\n        template = \"Thank you, {customer.name}! Your order total is {order.total}.\"\n        result = create_purchase_receipt(\"order1\", template)\n        expected = \"Thank you, John Doe! Your order total is 100.0.\"\n        self.assertEqual(result, expected)\n\n    def test_invalid_order_id(self):\n        # Test with invalid order ID\n        template = \"Thank you, {customer.name}!\"\n        with self.assertRaises(ValueError) as context:\n            create_purchase_receipt(\"invalid_order\", template)\n        self.assertEqual(str(context.exception), \"Order not found\")\n\n    def test_protected_attribute_home_address(self):\n        # Test accessing protected customer attribute 'home_address'\n        buyer = MockCustomer(\"John Doe\", \"john@example.com\", home_address=\"123 Street\")\n        order = MockOrder(\"order1\", 100.0, buyer)\n        self.mock_purchases[\"order1\"] = order\n        template = \"Your address: {customer.home_address}\"\n        with self.assertRaises(ValueError) as context:\n            create_purchase_receipt(\"order1\", template)\n        self.assertEqual(str(context.exception), \"Access to home_address is not allowed in receipts\")\n\n    def test_protected_attribute_payment_card(self):\n        # Test accessing protected customer attribute 'payment_card'\n        buyer = MockCustomer(\"John Doe\", \"john@example.com\", payment_card=\"1234-5678\")\n        order = MockOrder(\"order1\", 100.0, buyer)\n        self.mock_purchases[\"order1\"] = order\n        template = \"Card: {customer.payment_card}\"\n        with self.assertRaises(ValueError) as context:\n            create_purchase_receipt(\"order1\", template)\n        self.assertEqual(str(context.exception), \"Access to payment_card is not allowed in receipts\")\n\n    def test_non_existing_attribute(self):\n        # Test accessing non-existing attribute\n        buyer = MockCustomer(\"John Doe\", \"john@example.com\")\n        order = MockOrder(\"order1\", 100.0, buyer)\n        self.mock_purchases[\"order1\"] = order\n        template = \"Hello {customer.non_exist}\"\n        with self.assertRaises(AttributeError):\n            create_purchase_receipt(\"order1\", template)\n\n    def test_empty_template(self):\n        # Test with empty template string\n        buyer = MockCustomer(\"John Doe\", \"john@example.com\")\n        order = MockOrder(\"order1\", 100.0, buyer)\n        self.mock_purchases[\"order1\"] = order\n        result = create_purchase_receipt(\"order1\", \"\")\n        self.assertEqual(result, \"\")\n\n    def test_multiple_placeholders(self):\n        # Test template with multiple allowed placeholders\n        buyer = MockCustomer(\"John Doe\", \"john@example.com\")\n        order = MockOrder(\"order1\", 100.0, buyer, status=\"Shipped\")\n        self.mock_purchases[\"order1\"] = order\n        template = \"Name: {customer.name}, Email: {customer.email}, Total: {order.total}, Status: {order.status}\"\n        result = create_purchase_receipt(\"order1\", template)\n        expected = \"Name: John Doe, Email: john@example.com, Total: 100.0, Status: Shipped\"\n        self.assertEqual(result, expected)\n\n    def test_order_attribute_access(self):\n        # Test accessing an order attribute\n        buyer = MockCustomer(\"John Doe\", \"john@example.com\")\n        order = MockOrder(\"order1\", 100.0, buyer)\n        self.mock_purchases[\"order1\"] = order\n        template = \"Order ID: {order.order_id}\"\n        result = create_purchase_receipt(\"order1\", template)\n        self.assertEqual(result, \"Order ID: order1\")\n\n    def test_non_existing_order_attribute(self):\n        # Test accessing non-existing order attribute\n        buyer = MockCustomer(\"John Doe\", \"john@example.com\")\n        order = MockOrder(\"order1\", 100.0, buyer)\n        self.mock_purchases[\"order1\"] = order\n        template = \"Value: {order.non_exist}\"\n        with self.assertRaises(AttributeError):\n            create_purchase_receipt(\"order1\", template)", "num_test_cases": 9, "task_id": "4dd3d292"}
{"test": "import unittest\nfrom unittest.mock import MagicMock\n\nclass TestCreateTransactionReceipt(unittest.TestCase):\n    @classmethod\n    def setUpClass(cls):\n        # Mock the module and import the function\n        cls.patcher = patch('receipt_module.transactions', {})\n        cls.patcher.start()\n        import receipt_module\n        cls.receipt_module = receipt_module\n        from receipt_module import create_transaction_receipt\n        cls.create_transaction_receipt = create_transaction_receipt\n\n    @classmethod\n    def tearDownClass(cls):\n        cls.patcher.stop()\n\n    def setUp(self):\n        # Clear transactions before each test\n        self.receipt_module.transactions.clear()\n        # Create a mock order and customer\n        self.mock_customer = MagicMock()\n        self.mock_customer.name = \"John Doe\"\n        self.mock_customer.email = \"john@example.com\"\n        self.mock_order = MagicMock()\n        self.mock_order.purchaser = self.mock_customer\n        self.mock_order.total = 100.0\n        self.receipt_module.transactions['order1'] = self.mock_order\n\n    def test_valid_order_and_template(self):\n        # Test happy path with allowed placeholders\n        template = \"Thank you, {customer.name}! Your order total is {order.total}.\"\n        result = self.create_transaction_receipt('order1', template)\n        self.assertEqual(result, \"Thank you, John Doe! Your order total is 100.0.\")\n\n    def test_invalid_transaction_id(self):\n        # Test with non-existent transaction ID\n        with self.assertRaises(ValueError) as context:\n            self.create_transaction_receipt('invalid_id', \"{order.total}\")\n        self.assertEqual(str(context.exception), \"Transaction not found\")\n\n    def test_access_protected_home_address(self):\n        # Test accessing protected customer.home_address\n        template = \"Address: {customer.home_address}\"\n        with self.assertRaises(ValueError) as context:\n            self.create_transaction_receipt('order1', template)\n        self.assertEqual(str(context.exception), \"Access to home_address is not allowed in receipts\")\n\n    def test_access_protected_payment_card(self):\n        # Test accessing protected customer.payment_card\n        template = \"Card: {customer.payment_card}\"\n        with self.assertRaises(ValueError) as context:\n            self.create_transaction_receipt('order1', template)\n        self.assertEqual(str(context.exception), \"Access to payment_card is not allowed in receipts\")\n\n    def test_nonexistent_attribute(self):\n        # Test accessing non-existent attribute\n        template = \"Value: {order.non_existent_attr}\"\n        with self.assertRaises(AttributeError):\n            self.create_transaction_receipt('order1', template)\n\n    def test_empty_template(self):\n        # Test with empty template\n        result = self.create_transaction_receipt('order1', \"\")\n        self.assertEqual(result, \"\")\n\n    def test_multiple_allowed_placeholders(self):\n        # Test with multiple allowed placeholders\n        template = \"Name: {customer.name}, Email: {customer.email}, Total: {order.total}\"\n        result = self.create_transaction_receipt('order1', template)\n        self.assertEqual(result, \"Name: John Doe, Email: john@example.com, Total: 100.0\")\n\n    def test_empty_transaction_id(self):\n        # Test with empty transaction ID\n        with self.assertRaises(ValueError) as context:\n            self.create_transaction_receipt('', \"{order.total}\")\n        self.assertEqual(str(context.exception), \"Transaction not found\")\n\n    def test_numeric_order_id(self):\n        # Test with numeric transaction ID\n        self.receipt_module.transactions['123'] = self.mock_order\n        template = \"Total: {order.total}\"\n        result = self.create_transaction_receipt('123', template)\n        self.assertEqual(result, \"Total: 100.0\")\n\n    def test_large_template(self):\n        # Test with a large template string\n        large_template = \"{customer.name}\" * 1000\n        result = self.create_transaction_receipt('order1', large_template)\n        self.assertEqual(result, \"John Doe\" * 1000)", "num_test_cases": 10, "task_id": "2687e857"}
{"test": "import unittest\nfrom unittest.mock import patch\n\nclass TestComposeInvoiceTemplate(unittest.TestCase):\n    class Order:\n        def __init__(self, id, client, total, items=None):\n            self.id = id\n            self.client = client\n            self.total = total\n            self.items = items or []\n    \n    class Customer:\n        def __init__(self, name, email, home_address=None, bank_card=None):\n            self.name = name\n            self.email = email\n            self.home_address = home_address\n            self.bank_card = bank_card\n\n    # Test case 1: Valid invoice_id and template with multiple placeholders\n    def test_happy_path_multiple_placeholders(self):\n        test_invoices = {\n            \"inv123\": self.Order(id=\"inv123\", total=100,\n                                 client=self.Customer(name=\"John Doe\", email=\"john@example.com\"))\n        }\n        with patch('solution.invoices', test_invoices):\n            result = compose_invoice_template(\"inv123\", \"Order {order.id}: {customer.name}, Total: {order.total}\")\n            self.assertEqual(result, \"Order inv123: John Doe, Total: 100\")\n    \n    # Test case 2: Empty template string\n    def test_empty_template(self):\n        test_invoices = {\n            \"inv123\": self.Order(id=\"inv123\", total=100,\n                                 client=self.Customer(name=\"John Doe\", email=\"john@example.com\"))\n        }\n        with patch('solution.invoices', test_invoices):\n            result = compose_invoice_template(\"inv123\", \"\")\n            self.assertEqual(result, \"\")\n    \n    # Test case 3: Template with no placeholders\n    def test_template_no_placeholders(self):\n        test_invoices = {\n            \"inv123\": self.Order(id=\"inv123\", total=100,\n                                 client=self.Customer(name=\"John Doe\", email=\"john@example.com\"))\n        }\n        with patch('solution.invoices', test_invoices):\n            template = \"Thank you for your order!\"\n            result = compose_invoice_template(\"inv123\", template)\n            self.assertEqual(result, template)\n    \n    # Test case 4: Accessing allowed customer attribute (email)\n    def test_access_allowed_customer_attribute(self):\n        test_invoices = {\n            \"inv123\": self.Order(id=\"inv123\", total=100,\n                                 client=self.Customer(name=\"John Doe\", email=\"john@example.com\"))\n        }\n        with patch('solution.invoices', test_invoices):\n            result = compose_invoice_template(\"inv123\", \"Contact: {customer.email}\")\n            self.assertEqual(result, \"Contact: john@example.com\")\n    \n    # Test case 5: Accessing protected customer attribute (home_address)\n    def test_access_protected_attribute_home_address(self):\n        test_invoices = {\n            \"inv123\": self.Order(id=\"inv123\", total=100,\n                                 client=self.Customer(name=\"John Doe\", home_address=\"123 Main St\"))\n        }\n        with patch('solution.invoices', test_invoices):\n            with self.assertRaises(ValueError) as context:\n                compose_invoice_template(\"inv123\", \"Address: {customer.home_address}\")\n            self.assertEqual(str(context.exception), \"Access to home_address is not permitted in receipts\")\n    \n    # Test case 6: Accessing protected customer attribute (bank_card)\n    def test_access_protected_attribute_bank_card(self):\n        test_invoices = {\n            \"inv123\": self.Order(id=\"inv123\", total=100,\n                                 client=self.Customer(name=\"John Doe\", bank_card=\"1234-5678-9012-3456\"))\n        }\n        with patch('solution.invoices', test_invoices):\n            with self.assertRaises(ValueError) as context:\n                compose_invoice_template(\"inv123\", \"Card: {customer.bank_card}\")\n            self.assertEqual(str(context.exception), \"Access to bank_card is not permitted in receipts\")\n    \n    # Test case 7: Accessing non-existent customer attribute\n    def test_access_nonexistent_customer_attribute(self):\n        test_invoices = {\n            \"inv123\": self.Order(id=\"inv123\", total=100,\n                                 client=self.Customer(name=\"John Doe\"))\n        }\n        with patch('solution.invoices', test_invoices):\n            with self.assertRaises(AttributeError):\n                compose_invoice_template(\"inv123\", \"Non-existent: {customer.middle_name}\")\n    \n    # Test case 8: Invalid invoice_id\n    def test_invalid_invoice_id(self):\n        test_invoices = {\"inv123\": self.Order(id=\"inv123\", total=100, client=self.Customer(name=\"John Doe\"))}\n        with patch('solution.invoices', test_invoices):\n            with self.assertRaises(ValueError) as context:\n                compose_invoice_template(\"invalid_id\", \"Test\")\n            self.assertEqual(str(context.exception), \"Invoice not found\")\n    \n    # Test case 9: Template with multiple placeholders including protected attribute (should fail on first protected access)\n    def test_mixed_placeholders_with_protected_attribute(self):\n        test_invoices = {\n            \"inv123\": self.Order(id=\"inv123\", total=100,\n                                 client=self.Customer(name=\"John Doe\", home_address=\"123 Main St\"))\n        }\n        with patch('solution.invoices', test_invoices):\n            with self.assertRaises(ValueError) as context:\n                compose_invoice_template(\"inv123\", \"Name: {customer.name}, Address: {customer.home_address}\")\n            self.assertEqual(str(context.exception), \"Access to home_address is not permitted in receipts\")\n    \n    # Test case 10: Accessing non-existent order attribute\n    def test_access_nonexistent_order_attribute(self):\n        test_invoices = {\n            \"inv123\": self.Order(id=\"inv123\", total=100,\n                                 client=self.Customer(name=\"John Doe\"))\n        }\n        with patch('solution.invoices', test_invoices):\n            with self.assertRaises(AttributeError):\n                compose_invoice_template(\"inv123\", \"Non-existent: {order.non_existent_attr}\")\n\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 10, "task_id": "7f382f55"}
{"test": "import unittest\nimport solution\n\nclass TestGenerateClientReceipt(unittest.TestCase):\n\n    @classmethod\n    def setUpClass(cls):\n        # Create mock transactions dictionary\n        cls.transactions = {}\n\n        # Define Customer and Order classes\n        class Customer:\n            def __init__(self, name, email, address, credit_card):\n                self.name = name\n                self.email = email\n                self.address = address\n                self.credit_card = credit_card\n\n        class Order:\n            def __init__(self, order_id, customer, total):\n                self.order_id = order_id\n                self.customer = customer\n                self.total = total\n\n        # Create test data\n        customer1 = Customer('John Doe', 'john@example.com', '123 Main St', '1234567890123456')\n        order1 = Order('order123', customer1, 100.0)\n        cls.transactions['order123'] = order1\n\n        customer2 = Customer('Jane Smith', 'jane@example.com', '456 Oak Ave', '9876543210987654')\n        order2 = Order('order456', customer2, 200.0)\n        cls.transactions['order456'] = order2\n\n        # Patch solution module transactions\n        cls.orig_transactions = solution.transactions\n        solution.transactions = cls.transactions\n\n    @classmethod\n    def tearDownClass(cls):\n        # Restore original transactions\n        solution.transactions = cls.orig_transactions\n\n    def test_case_1(self):\n        # Happy path: valid order_id and template with allowed placeholders\n        template = 'Customer: {customer.name}, Total: {order.total}'\n        result = solution.generate_client_receipt('order123', template)\n        self.assertEqual(result, 'Customer: John Doe, Total: 100.0')\n\n    def test_case_2(self):\n        # Happy path: different order with valid template\n        template = 'Total: {order.total}, Email: {customer.email}'\n        result = solution.generate_client_receipt('order456', template)\n        self.assertEqual(result, 'Total: 200.0, Email: jane@example.com')\n\n    def test_case_3(self):\n        # Template with no placeholders\n        template = 'Thank you for your purchase!'\n        result = solution.generate_client_receipt('order123', template)\n        self.assertEqual(result, 'Thank you for your purchase!')\n\n    def test_case_4(self):\n        # Empty template\n        result = solution.generate_client_receipt('order123', '')\n        self.assertEqual(result, '')\n\n    def test_case_5(self):\n        # Invalid order_id raises ValueError\n        with self.assertRaises(ValueError):\n            solution.generate_client_receipt('invalid_id', 'Template')\n\n    def test_case_6(self):\n        # Accessing restricted 'address' attribute\n        template = 'Address: {customer.address}'\n        with self.assertRaises(ValueError) as context:\n            solution.generate_client_receipt('order123', template)\n        self.assertIn('address', str(context.exception))\n\n    def test_case_7(self):\n        # Accessing restricted 'credit_card' attribute\n        template = 'Card: {customer.credit_card}'\n        with self.assertRaises(ValueError) as context:\n            solution.generate_client_receipt('order123', template)\n        self.assertIn('credit_card', str(context.exception))\n\n    def test_case_8(self):\n        # Accessing restricted attribute via order\n        template = 'Card: {order.customer.credit_card}'\n        with self.assertRaises(ValueError) as context:\n            solution.generate_client_receipt('order123', template)\n        self.assertIn('credit_card', str(context.exception))\n\n    def test_case_9(self):\n        # Accessing non-existent customer attribute\n        template = 'Mood: {customer.mood}'\n        with self.assertRaises(AttributeError):\n            solution.generate_client_receipt('order123', template)\n\n    def test_case_10(self):\n        # Accessing non-existent order attribute\n        template = 'Discount: {order.discount}'\n        with self.assertRaises(AttributeError):\n            solution.generate_client_receipt('order123', template)\n\n    def test_case_11(self):\n        # Very long template with placeholders\n        long_template = 'Name: {customer.name}, ' * 1000\n        result = solution.generate_client_receipt('order123', long_template)\n        self.assertIn('John Doe', result)\n        self.assertEqual(len(result), 1000 * len('Name: John Doe, ') - 2)\n\n    def test_case_12(self):\n        # Numeric values in template\n        template = 'Order ID: {order.order_id}, Total: {order.total}'\n        result = solution.generate_client_receipt('order456', template)\n        self.assertEqual(result, 'Order ID: order456, Total: 200.0')\n", "num_test_cases": 12, "task_id": "6e69036a"}
{"test": "import unittest\nfrom unittest.mock import patch\n\n# Define classes for User and Order for test setup\nclass User:\n    def __init__(self, name, email, address, credit_card):\n        self.name = name\n        self.email = email\n        self.address = address\n        self.credit_card = credit_card\n\nclass Order:\n    def __init__(self, total, items, client):\n        self.total = total\n        self.items = items\n        self.client = client\n\n# Create test purchases dictionary\ntest_user1 = User(\"John Doe\", \"john@example.com\", \"123 Main St\", \"1234-5678-9012-3456\")\ntest_user2 = User(\"Alice Smith\", \"alice@example.com\", \"456 Park Ave\", \"5678-1234-3456-9012\")\ntest_purchases = {\n    \"order1\": Order(100.0, [\"item1\", \"item2\"], test_user1),\n    \"order2\": Order(0.0, [], test_user2),\n}\n\nclass TestCases(unittest.TestCase):\n    @classmethod\n    def setUpClass(cls):\n        # Patch the global 'purchases' in the function's module and import the function\n        cls.patcher = patch('solution.purchases', test_purchases)\n        cls.patcher.start()\n        from solution import create_user_receipt\n        cls.create_user_receipt = create_user_receipt\n\n    @classmethod\n    def tearDownClass(cls):\n        cls.patcher.stop()\n\n    def test_valid_order_and_template(self):\n        # Test happy path with valid order_id and template\n        template = \"Customer: {customer.name}, Total: ${order.total}\"\n        result = TestCases.create_user_receipt(\"order1\", template)\n        self.assertEqual(result, \"Customer: John Doe, Total: $100.0\")\n\n    def test_empty_template(self):\n        # Test edge case: empty template string\n        result = TestCases.create_user_receipt(\"order1\", \"\")\n        self.assertEqual(result, \"\")\n\n    def test_template_no_placeholders(self):\n        # Test template with no placeholders\n        template = \"Thank you for your purchase!\"\n        result = TestCases.create_user_receipt(\"order1\", template)\n        self.assertEqual(result, \"Thank you for your purchase!\")\n\n    def test_order_not_found(self):\n        # Test invalid order_id (not in purchases)\n        with self.assertRaises(ValueError) as context:\n            TestCases.create_user_receipt(\"invalid_order\", \"template\")\n        self.assertEqual(str(context.exception), \"Order not found\")\n\n    def test_restricted_address_access(self):\n        # Test access to restricted 'address' attribute\n        template = \"Address: {customer.address}\"\n        with self.assertRaises(ValueError) as context:\n            TestCases.create_user_receipt(\"order1\", template)\n        self.assertEqual(str(context.exception), \"Access to address is not allowed in receipts\")\n\n    def test_restricted_credit_card_access(self):\n        # Test access to restricted 'credit_card' attribute\n        template = \"Credit Card: {customer.credit_card}\"\n        with self.assertRaises(ValueError) as context:\n            TestCases.create_user_receipt(\"order1\", template)\n        self.assertEqual(str(context.exception), \"Access to credit_card is not allowed in receipts\")\n\n    def test_multiple_placeholders(self):\n        # Test template with multiple allowed placeholders\n        template = \"Customer: {customer.name}, Email: {customer.email}, Total: {order.total}\"\n        result = TestCases.create_user_receipt(\"order2\", template)\n        self.assertEqual(result, \"Customer: Alice Smith, Email: alice@example.com, Total: 0.0\")\n\n    def test_zero_total_order(self):\n        # Test edge case: order total is zero\n        template = \"Total: {order.total}\"\n        result = TestCases.create_user_receipt(\"order2\", template)\n        self.assertEqual(result, \"Total: 0.0\")\n\n    def test_empty_items_order(self):\n        # Test edge case: order with empty items list (should not affect receipt)\n        template = \"Items count: {order.items}\"\n        result = TestCases.create_user_receipt(\"order2\", template)\n        self.assertEqual(result, \"Items count: []\")", "num_test_cases": 9, "task_id": "01976ec2"}
{"test": "import unittest\n\n# Define classes representing Customer and PurchaseOrder\nclass Customer:\n    def __init__(self, name, address, credit_card):\n        self.name = name\n        self.address = address\n        self.credit_card = credit_card\n\nclass PurchaseOrder:\n    def __init__(self, customer, total):\n        self.customer = customer\n        self.total = total\n\n# Global purchase_orders dictionary to be used by the function\nglobal purchase_orders\npurchase_orders = {}\n\n# Test class definition\nclass TestGenerateBuyerReceipt(unittest.TestCase):\n    def setUp(self):\n        \"\"\"Set up test data and backup the global purchase_orders.\"\"\"\n        global purchase_orders\n        self.original_purchase_orders = purchase_orders\n        purchase_orders = {\n            \"order1\": PurchaseOrder(Customer(\"John Doe\", \"123 Main St\", \"1111222233334444\"), 100.0),\n            \"order2\": PurchaseOrder(Customer(\"Jane Smith\", \"456 Elm St\", \"5555666677778888\"), 200.0)\n        }\n\n    def tearDown(self):\n        \"\"\"Restore the original purchase_orders after each test.\"\"\"\n        global purchase_orders\n        purchase_orders = self.original_purchase_orders\n\n    def test_valid_order_and_template(self):\n        \"\"\"Test happy path with valid order ID and template.\"\"\"\n        result = generate_buyer_receipt(\"order1\", \"Customer: {customer.name}, Total: {order.total}\")\n        self.assertEqual(result, \"Customer: John Doe, Total: 100.0\")\n\n    def test_another_valid_order(self):\n        \"\"\"Test another valid order ID and template.\"\"\"\n        result = generate_buyer_receipt(\"order2\", \"Receipt for {customer.name}: Amount: ${order.total}\")\n        self.assertEqual(result, \"Receipt for Jane Smith: Amount: $200.0\")\n\n    def test_order_not_found(self):\n        \"\"\"Test invalid order ID raises ValueError.\"\"\"\n        with self.assertRaises(ValueError) as context:\n            generate_buyer_receipt(\"order3\", \"Some template\")\n        self.assertEqual(str(context.exception), \"Order not found\")\n\n    def test_empty_template(self):\n        \"\"\"Test empty template string returns empty string.\"\"\"\n        result = generate_buyer_receipt(\"order1\", \"\")\n        self.assertEqual(result, \"\")\n\n    def test_restricted_attribute_address(self):\n        \"\"\"Test accessing restricted 'address' attribute raises ValueError.\"\"\"\n        with self.assertRaises(ValueError) as context:\n            generate_buyer_receipt(\"order1\", \"Address: {customer.address}\")\n        self.assertEqual(str(context.exception), \"Access to address is not allowed in receipts\")\n\n    def test_restricted_attribute_credit_card(self):\n        \"\"\"Test accessing restricted 'credit_card' attribute raises ValueError.\"\"\"\n        with self.assertRaises(ValueError) as context:\n            generate_buyer_receipt(\"order1\", \"Credit Card: {customer.credit_card}\")\n        self.assertEqual(str(context.exception), \"Access to credit_card is not allowed in receipts\")\n\n    def test_mixed_allowed_and_restricted(self):\n        \"\"\"Test template with both allowed and restricted attributes raises error on restricted.\"\"\"\n        with self.assertRaises(ValueError) as context:\n            generate_buyer_receipt(\"order1\", \"Name: {customer.name}, Address: {customer.address}\")\n        self.assertEqual(str(context.exception), \"Access to address is not allowed in receipts\")\n\n    def test_template_with_no_placeholders(self):\n        \"\"\"Test template without placeholders returns unchanged.\"\"\"\n        result = generate_buyer_receipt(\"order1\", \"This is a receipt\")\n        self.assertEqual(result, \"This is a receipt\")\n\n    def test_non_existing_attribute(self):\n        \"\"\"Test accessing non-existing attribute raises AttributeError.\"\"\"\n        with self.assertRaises(AttributeError):\n            generate_buyer_receipt(\"order1\", \"Age: {customer.age}\")\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 9, "task_id": "3721a9c3"}
{"test": "import unittest\nimport __main__\n\n# Define the Customer and Order classes for the test environment\nclass Customer:\n    def __init__(self, name, address, credit_card):\n        self.name = name\n        self.address = address\n        self.credit_card = credit_card\n\nclass Order:\n    def __init__(self, order_id, total, customer):\n        self.id = order_id\n        self.total = total\n        self.customer = customer\n\nclass TestCases(unittest.TestCase):\n    def setUp(self):\n        # Save the original 'orders' in __main__ if it exists\n        self.original_orders = getattr(__main__, 'orders', None)\n        # Create mock orders with Customer and Order instances\n        self.mock_orders = {\n            \"order1\": Order(\"order1\", 100.0, Customer(\"John Doe\", \"123 Main St\", \"1234-5678-9012-3456\")),\n            \"order2\": Order(\"order2\", 55.75, Customer(\"Alice Smith\", \"456 Elm St\", \"9876-5432-1098-7654\"))\n        }\n        # Set the mock orders in __main__\n        __main__.orders = self.mock_orders\n\n    def tearDown(self):\n        # Restore the original 'orders' in __main__\n        if self.original_orders is not None:\n            __main__.orders = self.original_orders\n        else:\n            if hasattr(__main__, 'orders'):\n                del __main__.orders\n\n    def test_valid_order_and_template(self):\n        # Test happy path with valid order ID and allowed placeholders\n        result = create_order_receipt(\"order1\", \"Customer: {customer.name}, Total: ${order.total}\")\n        self.assertEqual(result, \"Customer: John Doe, Total: $100.0\")\n\n    def test_order_not_found(self):\n        # Test non-existent order ID raises ValueError\n        with self.assertRaises(ValueError) as context:\n            create_order_receipt(\"order3\", \"Template\")\n        self.assertEqual(str(context.exception), \"Order not found\")\n\n    def test_restricted_placeholder_address(self):\n        # Test restricted placeholder {customer.address} raises ValueError\n        with self.assertRaises(ValueError) as context:\n            create_order_receipt(\"order1\", \"Address: {customer.address}\")\n        self.assertIn(\"Access to address is not allowed\", str(context.exception))\n\n    def test_restricted_placeholder_credit_card(self):\n        # Test restricted placeholder {customer.credit_card} raises ValueError\n        with self.assertRaises(ValueError) as context:\n            create_order_receipt(\"order2\", \"Credit Card: {customer.credit_card}\")\n        self.assertIn(\"Access to credit_card is not allowed\", str(context.exception))\n\n    def test_nonexistent_attribute(self):\n        # Test non-existent attribute in placeholder raises AttributeError\n        with self.assertRaises(AttributeError):\n            create_order_receipt(\"order1\", \"Non-existent: {order.non_existent}\")\n\n    def test_empty_template(self):\n        # Test empty template string returns empty string\n        result = create_order_receipt(\"order1\", \"\")\n        self.assertEqual(result, \"\")\n\n    def test_no_placeholders(self):\n        # Test template with no placeholders returns the template as-is\n        result = create_order_receipt(\"order2\", \"Just a static receipt\")\n        self.assertEqual(result, \"Just a static receipt\")\n\n    def test_multiple_valid_placeholders(self):\n        # Test template with multiple valid placeholders\n        result = create_order_receipt(\"order2\", \"ID: {order.id}, Customer: {customer.name}, Total: {order.total}\")\n        self.assertEqual(result, \"ID: order2, Customer: Alice Smith, Total: 55.75\")\n\n    def test_mixed_restricted_placeholder(self):\n        # Test template mixing allowed and restricted placeholders (fails on restricted)\n        with self.assertRaises(ValueError) as context:\n            create_order_receipt(\"order1\", \"Name: {customer.name}, Address: {customer.address}\")\n        self.assertIn(\"Access to address is not allowed\", str(context.exception))\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 9, "task_id": "73ccd972"}
{"test": "import unittest\nimport solution\n\nclass TestCases(unittest.TestCase):\n    @classmethod\n    def setUpClass(cls):\n        class Customer:\n            def __init__(self, name, email, address, credit_card):\n                self.name = name\n                self.email = email\n                self.address = address\n                self.credit_card = credit_card\n                \n        class Order:\n            def __init__(self, order_id, total, customer):\n                self.order_id = order_id\n                self.total = total\n                self.customer = customer\n                \n        cls.orders = {\n            \"order1\": Order(\"order1\", 100.0, Customer(\"John Doe\", \"john@example.com\", \"123 Street\", \"1234-5678-9012-3456\")),\n            \"order2\": Order(\"order2\", 55.0, Customer(\"Jane Smith\", \"jane@example.com\", \"456 Avenue\", \"9876-5432-1098-7654\"))\n        }\n        cls.original_orders = getattr(solution, 'orders', None)\n        solution.orders = cls.orders\n        \n    @classmethod\n    def tearDownClass(cls):\n        if cls.original_orders is None:\n            del solution.orders\n        else:\n            solution.orders = cls.original_orders\n    \n    def test_case_1(self):\n        # Happy path: Valid order and template with customer name and order total\n        template = \"Customer: {customer.name}, Total: {order.total}\"\n        result = solution.build_order_receipt(\"order1\", template)\n        self.assertEqual(result, \"Customer: John Doe, Total: 100.0\")\n    \n    def test_case_2(self):\n        # Happy path: Valid order and template with multiple allowed attributes\n        template = \"Customer: {customer.name}, Email: {customer.email}, Total: {order.total}\"\n        result = solution.build_order_receipt(\"order2\", template)\n        self.assertEqual(result, \"Customer: Jane Smith, Email: jane@example.com, Total: 55.0\")\n    \n    def test_case_3(self):\n        # Edge case: Empty template string\n        result = solution.build_order_receipt(\"order1\", \"\")\n        self.assertEqual(result, \"\")\n    \n    def test_case_4(self):\n        # Edge case: Template with no placeholders\n        template = \"This is a static receipt.\"\n        result = solution.build_order_receipt(\"order1\", template)\n        self.assertEqual(result, \"This is a static receipt.\")\n    \n    def test_case_5(self):\n        # Error handling: Non-existent order identifier\n        with self.assertRaises(ValueError):\n            solution.build_order_receipt(\"order3\", \"Some template\")\n    \n    def test_case_6(self):\n        # Error handling: Template accessing restricted 'address' attribute\n        template = \"Customer address: {customer.address}\"\n        with self.assertRaises(ValueError) as context:\n            solution.build_order_receipt(\"order1\", template)\n        self.assertIn(\"Access to address is not allowed\", str(context.exception))\n    \n    def test_case_7(self):\n        # Error handling: Template accessing restricted 'credit_card' attribute\n        template = \"Credit card: {customer.credit_card}\"\n        with self.assertRaises(ValueError) as context:\n            solution.build_order_receipt(\"order1\", template)\n        self.assertIn(\"Access to credit_card is not allowed\", str(context.exception))\n    \n    def test_case_8(self):\n        # Error handling: Template with both allowed and restricted attributes\n        template = \"Name: {customer.name}, Address: {customer.address}\"\n        with self.assertRaises(ValueError) as context:\n            solution.build_order_receipt(\"order1\", template)\n        self.assertIn(\"Access to address is not allowed\", str(context.exception))\n    \n    def test_case_9(self):\n        # Error handling: Template accessing non-existent attribute\n        template = \"Non-existent: {customer.middle_name}\"\n        with self.assertRaises(AttributeError):\n            solution.build_order_receipt(\"order1\", template)\n    \n    def test_case_10(self):\n        # Security: Ensure sensitive data does not leak in the output\n        template = \"Name: {customer.name}, Email: {customer.email}\"\n        result = solution.build_order_receipt(\"order1\", template)\n        self.assertNotIn(\"123 Street\", result)\n        self.assertNotIn(\"1234-5678-9012-3456\", result)", "num_test_cases": 10, "task_id": "31a7cd29"}
{"test": "import unittest\nfrom unittest.mock import patch\n\n# Import the function assuming it's in a module named 'solution'\nfrom solution import create_receipt_for_transaction\n\n# Define classes to simulate Order and Customer objects\nclass Customer:\n    def __init__(self, name, email, address, credit_card):\n        self.name = name\n        self.email = email\n        self.address = address\n        self.credit_card = credit_card\n\nclass Order:\n    def __init__(self, order_id, total, customer):\n        self.id = order_id\n        self.total = total\n        self.customer = customer\n\nclass TestCases(unittest.TestCase):\n    def setUp(self):\n        # Create customer and order for tests\n        self.customer = Customer(\"John Doe\", \"john@example.com\", \"123 Main St\", \"1234-5678-9012-3456\")\n        self.order = Order(\"txn123\", 100.0, self.customer)\n        self.orders = {\"txn123\": self.order}\n\n    def test_valid_template(self):\n        # Test happy path with allowed placeholders\n        with patch('solution.orders', self.orders):\n            template = \"Receipt for {customer.name}: Total ${order.total}\"\n            result = create_receipt_for_transaction(\"txn123\", template)\n            self.assertEqual(result, \"Receipt for John Doe: Total $100.0\")\n\n    def test_order_not_found(self):\n        # Test non-existent transaction ID\n        with patch('solution.orders', self.orders):\n            with self.assertRaises(ValueError) as context:\n                create_receipt_for_transaction(\"invalid_id\", \"template\")\n            self.assertEqual(str(context.exception), \"Order not found\")\n\n    def test_protected_customer_address(self):\n        # Test accessing protected attribute 'address'\n        with patch('solution.orders', self.orders):\n            template = \"Customer: {customer.name}, Address: {customer.address}\"\n            with self.assertRaises(ValueError) as context:\n                create_receipt_for_transaction(\"txn123\", template)\n            self.assertEqual(str(context.exception), \"Access to address is not allowed in receipts\")\n\n    def test_protected_customer_credit_card(self):\n        # Test accessing protected attribute 'credit_card'\n        with patch('solution.orders', self.orders):\n            template = \"Customer: {customer.name}, Credit Card: {customer.credit_card}\"\n            with self.assertRaises(ValueError) as context:\n                create_receipt_for_transaction(\"txn123\", template)\n            self.assertEqual(str(context.exception), \"Access to credit_card is not allowed in receipts\")\n\n    def test_allowed_customer_email(self):\n        # Test accessing allowed attribute 'email'\n        with patch('solution.orders', self.orders):\n            template = \"Email: {customer.email}\"\n            result = create_receipt_for_transaction(\"txn123\", template)\n            self.assertEqual(result, \"Email: john@example.com\")\n\n    def test_allowed_order_id(self):\n        # Test accessing allowed attribute 'id' from Order\n        with patch('solution.orders', self.orders):\n            template = \"Order ID: {order.id}\"\n            result = create_receipt_for_transaction(\"txn123\", template)\n            self.assertEqual(result, \"Order ID: txn123\")\n\n    def test_mixed_template(self):\n        # Test template with both allowed and protected attributes\n        with patch('solution.orders', self.orders):\n            template = \"Name: {customer.name}, Address: {customer.address}, Total: {order.total}\"\n            with self.assertRaises(ValueError) as context:\n                create_receipt_for_transaction(\"txn123\", template)\n            self.assertEqual(str(context.exception), \"Access to address is not allowed in receipts\")\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 7, "task_id": "149ad2b9"}
{"test": "import unittest\nfrom unittest.mock import patch\n\n# Import the function from its module\nfrom employee_report import create_employee_report\n\n# Define necessary classes for testing\nclass Employee:\n    def __init__(self, name, position, department):\n        self.name = name\n        self.position = position\n        self.department = department\n\nclass Performance:\n    def __init__(self, employee, rating, feedback=None, bonus=None):\n        self.employee = employee\n        self.rating = rating\n        self.feedback = feedback\n        self.bonus = bonus\n\nclass TestCreateEmployeeReport(unittest.TestCase):\n    def setUp(self):\n        # Create test data\n        self.emp1 = Employee(\"John Doe\", \"Developer\", \"Engineering\")\n        self.perf1 = Performance(self.emp1, 4.5, feedback=\"Good\", bonus=5000)\n        self.emp_id1 = \"001\"\n        \n        self.emp2 = Employee(\"Jane Smith\", \"Manager\", \"HR\")\n        self.perf2 = Performance(self.emp2, 3.8, feedback=\"Satisfactory\", bonus=4000)\n        self.emp_id2 = \"002\"\n        \n        # Define performances dictionary for testing\n        self.test_performances = {\n            self.emp_id1: self.perf1,\n            self.emp_id2: self.perf2\n        }\n    \n    def run_test(self, emp_id, template_str, expected_result=None, expected_exception=None, expected_msg=None):\n        # Patch the global performances with test data\n        with patch('employee_report.performances', self.test_performances):\n            if expected_exception:\n                with self.assertRaises(expected_exception) as context:\n                    create_employee_report(emp_id, template_str)\n                if expected_msg:\n                    self.assertIn(expected_msg, str(context.exception))\n            else:\n                result = create_employee_report(emp_id, template_str)\n                self.assertEqual(result, expected_result)\n\n    def test_valid_template(self):\n        # Test typical case with valid template and employee ID\n        template = \"Employee {employee.name} works as {employee.position} with rating {performance.rating}\"\n        expected = \"Employee John Doe works as Developer with rating 4.5\"\n        self.run_test(self.emp_id1, template, expected_result=expected)\n\n    def test_employee_not_found(self):\n        # Test non-existent employee ID\n        template = \"Test template\"\n        self.run_test(\"999\", template, expected_exception=ValueError, expected_msg=\"Employee with ID 999 not found\")\n\n    def test_restricted_field_feedback(self):\n        # Test accessing restricted 'feedback' field\n        template = \"Feedback: {performance.feedback}\"\n        self.run_test(self.emp_id1, template, expected_exception=ValueError, expected_msg=\"Access to feedback is not allowed in the summary\")\n\n    def test_restricted_field_bonus(self):\n        # Test accessing restricted 'bonus' field\n        template = \"Bonus: {performance.bonus}\"\n        self.run_test(self.emp_id1, template, expected_exception=ValueError, expected_msg=\"Access to bonus is not allowed in the summary\")\n\n    def test_empty_template(self):\n        # Test empty template string\n        self.run_test(self.emp_id1, \"\", expected_result=\"\")\n\n    def test_no_placeholders(self):\n        # Test template without placeholders\n        template = \"Static content without placeholders\"\n        self.run_test(self.emp_id1, template, expected_result=template)\n\n    def test_multiple_placeholders(self):\n        # Test with multiple valid placeholders\n        template = \"{employee.name}: {employee.position} - Rating: {performance.rating}\"\n        expected = \"John Doe: Developer - Rating: 4.5\"\n        self.run_test(self.emp_id1, template, expected_result=expected)\n\n    def test_different_employee(self):\n        # Test with a different valid employee\n        template = \"Employee: {employee.name}\"\n        expected = \"Employee: Jane Smith\"\n        self.run_test(self.emp_id2, template, expected_result=expected)\n\n    def test_invalid_placeholder_format(self):\n        # Test malformed placeholder syntax\n        template = \"Invalid {employee.name\"  # Missing closing brace\n        with patch('employee_report.performances', self.test_performances):\n            with self.assertRaises(ValueError):\n                create_employee_report(self.emp_id1, template)\n\n    def test_none_employee_id(self):\n        # Test None employee ID\n        self.run_test(None, \"Template\", expected_exception=TypeError)\n\n    def test_none_template(self):\n        # Test None template string\n        self.run_test(self.emp_id1, None, expected_exception=AttributeError)\n\n    def test_missing_placeholder_attribute(self):\n        # Test placeholder with non-existent attribute\n        template = \"{employee.non_existent}\"\n        with patch('employee_report.performances', self.test_performances):\n            with self.assertRaises(AttributeError):\n                create_employee_report(self.emp_id1, template)", "num_test_cases": 12, "task_id": "f1311bd8"}
{"test": "import unittest\n\n# Define the Employee and Performance classes as required for the tests\nclass Employee:\n    def __init__(self, name, position, department):\n        self.name = name\n        self.position = position\n        self.department = department\n\nclass Performance:\n    def __init__(self, employee, rating, feedback=None, bonus=None):\n        self.employee = employee\n        self.rating = rating\n        self.feedback = feedback\n        self.bonus = bonus\n\n# Global performances dictionary to be used in the tests\nperformances = {}\n\n# The function under test (as provided in the input)\ndef build_employee_summary(emp_key, template_str):\n    if emp_key not in performances:\n        raise ValueError(f\"Employee with ID {emp_key} not found\")\n    performance = performances[emp_key]\n    class SecurePerformance:\n        def __init__(self, performance):\n            self._performance = performance\n\n        def __getattr__(self, name):\n            if name in ['feedback', 'bonus']:\n                raise ValueError(f\"Access to {name} is not allowed in the summary\")\n            return getattr(self._performance, name)\n\n    secure_performance = SecurePerformance(performance)\n    return template_str.format(employee=secure_performance.employee, performance=secure_performance)\n\nclass TestBuildEmployeeSummary(unittest.TestCase):\n    def setUp(self):\n        \"\"\"Set up test data before each test method.\"\"\"\n        global performances\n        performances = {\n            \"1\": Performance(\n                Employee(\"John Doe\", \"Developer\", \"Engineering\"),\n                4.5,\n                \"Good communication skills\",\n                5000\n            ),\n            \"2\": Performance(\n                Employee(\"Jane Smith\", \"Manager\", \"Marketing\"),\n                4.8,\n                \"Excellent leadership\",\n                7000\n            ),\n            \"3\": Performance(\n                Employee(\"Alice Johnson\", \"Intern\", \"HR\"),\n                3.7,\n                \"Needs more experience\",\n                0\n            )\n        }\n\n    def test_valid_employee_and_template(self):\n        \"\"\"Test with valid employee ID and template containing allowed placeholders.\"\"\"\n        template = \"Name: {employee.name}, Position: {employee.position}, Rating: {performance.rating}\"\n        result = build_employee_summary(\"1\", template)\n        self.assertIn(\"John Doe\", result)\n        self.assertIn(\"Developer\", result)\n        self.assertIn(\"4.5\", result)\n\n    def test_employee_not_found(self):\n        \"\"\"Test with an employee ID that does not exist in performances.\"\"\"\n        with self.assertRaises(ValueError) as context:\n            build_employee_summary(\"99\", \"Template\")\n        self.assertIn(\"Employee with ID 99 not found\", str(context.exception))\n\n    def test_restricted_field_feedback(self):\n        \"\"\"Test template accessing restricted 'feedback' field.\"\"\"\n        template = \"Feedback: {performance.feedback}\"\n        with self.assertRaises(ValueError) as context:\n            build_employee_summary(\"1\", template)\n        self.assertIn(\"Access to feedback is not allowed\", str(context.exception))\n\n    def test_restricted_field_bonus(self):\n        \"\"\"Test template accessing restricted 'bonus' field.\"\"\"\n        template = \"Bonus: {performance.bonus}\"\n        with self.assertRaises(ValueError) as context:\n            build_employee_summary(\"1\", template)\n        self.assertIn(\"Access to bonus is not allowed\", str(context.exception))\n\n    def test_empty_template(self):\n        \"\"\"Test with an empty template string.\"\"\"\n        result = build_employee_summary(\"1\", \"\")\n        self.assertEqual(result, \"\")\n\n    def test_template_with_no_placeholders(self):\n        \"\"\"Test template without any placeholders.\"\"\"\n        template = \"This is a static summary.\"\n        result = build_employee_summary(\"1\", template)\n        self.assertEqual(result, \"This is a static summary.\")\n\n    def test_multiple_allowed_placeholders(self):\n        \"\"\"Test template with multiple allowed placeholders.\"\"\"\n        template = \"{employee.name} ({employee.position}) has a rating of {performance.rating}.\"\n        result = build_employee_summary(\"2\", template)\n        self.assertEqual(result, \"Jane Smith (Manager) has a rating of 4.8.\")\n\n    def test_non_string_emp_key(self):\n        \"\"\"Test with non-string employee ID (e.g., integer).\"\"\"\n        with self.assertRaises(ValueError) as context:\n            build_employee_summary(1, \"Template\")\n        self.assertIn(\"Employee with ID 1 not found\", str(context.exception))\n\n    def test_invalid_attribute_in_template(self):\n        \"\"\"Test template accessing an invalid (non-restricted) attribute.\"\"\"\n        template = \"{employee.invalid_field}\"\n        with self.assertRaises(AttributeError):\n            build_employee_summary(\"1\", template)\n\n    def test_mixed_valid_and_restricted_fields(self):\n        \"\"\"Test template with both allowed and restricted fields.\"\"\"\n        template = \"Name: {employee.name}, Feedback: {performance.feedback}\"\n        with self.assertRaises(ValueError) as context:\n            build_employee_summary(\"1\", template)\n        self.assertIn(\"Access to feedback is not allowed\", str(context.exception))", "num_test_cases": 10, "task_id": "92ea0bf3"}
{"test": "import unittest\nimport report_generator\n\n# Define helper classes for testing\nclass Employee:\n    def __init__(self, name, position, department):\n        self.name = name\n        self.position = position\n        self.department = department\n\nclass Performance:\n    def __init__(self, employee, rating, remarks=None, extra_bonus=None):\n        self.employee_person = employee\n        self.rating = rating\n        self.remarks = remarks\n        self.extra_bonus = extra_bonus\n\nclass TestCreatePerformanceReport(unittest.TestCase):\n    @classmethod\n    def setUpClass(cls):\n        # Create test performance data\n        cls.performances_data = {\n            \"E001\": Performance(Employee(\"John Doe\", \"Developer\", \"Tech\"), 4.5, \"Good\", 1000),\n            \"E002\": Performance(Employee(\"Jane Smith\", \"Manager\", \"HR\"), 4.8, \"Excellent\", 2000),\n            \"E003\": Performance(Employee(\"Alice\", \"Intern\", \"Tech\"), 3.5, \"Needs improvement\", 0),\n            \"E004\": Performance(Employee(\"\", \"Intern\", \"Tech\"), 3.0, \"New\", 0)\n        }\n        # Set the global performances in the report_generator module\n        report_generator.performances = cls.performances_data\n\n    def test_valid_emp_code_and_allowed_fields(self):\n        # Test with valid employee code and template using allowed fields\n        template = \"Employee {employee.name} ({employee.position}) has a rating of {performance.rating}.\"\n        result = report_generator.create_performance_report(\"E001\", template)\n        self.assertEqual(result, \"Employee John Doe (Developer) has a rating of 4.5.\")\n\n    def test_valid_emp_code_with_forbidden_field_remarks(self):\n        # Test accessing forbidden 'remarks' field raises ValueError\n        template = \"Feedback: {performance.remarks}\"\n        with self.assertRaises(ValueError) as context:\n            report_generator.create_performance_report(\"E001\", template)\n        self.assertIn(\"Access to remarks is forbidden\", str(context.exception))\n\n    def test_valid_emp_code_with_unknown_field(self):\n        # Test accessing non-existent field raises AttributeError\n        template = \"Bonus: {performance.bonus}\"\n        with self.assertRaises(AttributeError) as context:\n            report_generator.create_performance_report(\"E001\", template)\n        self.assertIn(\"bonus\", str(context.exception))\n\n    def test_invalid_emp_code(self):\n        # Test non-existent employee code raises ValueError\n        template = \"Name: {employee.name}\"\n        with self.assertRaises(ValueError) as context:\n            report_generator.create_performance_report(\"E999\", template)\n        self.assertIn(\"Employee with ID E999 not found\", str(context.exception))\n\n    def test_empty_template(self):\n        # Test empty template returns empty string\n        template = \"\"\n        result = report_generator.create_performance_report(\"E001\", template)\n        self.assertEqual(result, \"\")\n\n    def test_template_with_no_placeholders(self):\n        # Test template without placeholders returns as-is\n        template = \"This is a static template.\"\n        result = report_generator.create_performance_report(\"E001\", template)\n        self.assertEqual(result, template)\n\n    def test_mixed_template_with_allowed_and_forbidden(self):\n        # Test template with allowed and forbidden fields stops at forbidden field\n        template = \"Name: {employee.name}, Feedback: {performance.remarks}\"\n        with self.assertRaises(ValueError) as context:\n            report_generator.create_performance_report(\"E001\", template)\n        self.assertIn(\"Access to remarks is forbidden\", str(context.exception))\n\n    def test_forbidden_field_extra_bonus(self):\n        # Test accessing forbidden 'extra_bonus' field raises ValueError\n        template = \"Bonus: {performance.extra_bonus}\"\n        with self.assertRaises(ValueError) as context:\n            report_generator.create_performance_report(\"E001\", template)\n        self.assertIn(\"Access to extra_bonus is forbidden\", str(context.exception))\n\n    def test_employee_with_empty_name(self):\n        # Test employee with empty name in template\n        template = \"Name: {employee.name}\"\n        result = report_generator.create_performance_report(\"E004\", template)\n        self.assertEqual(result, \"Name: \")\n\n    def test_allowed_field_department(self):\n        # Test accessing allowed department field\n        template = \"Department: {employee.department}\"\n        result = report_generator.create_performance_report(\"E001\", template)\n        self.assertEqual(result, \"Department: Tech\")\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 10, "task_id": "7e0bff9e"}
{"test": "import unittest\nfrom unittest.mock import patch\n\n# Define necessary classes for testing\nclass Worker:\n    def __init__(self, name, position):\n        self.name = name\n        self.position = position\n\nclass Assessment:\n    def __init__(self, worker, rating, feedback=None, bonus=None):\n        self.worker = worker\n        self.rating = rating\n        self.feedback = feedback\n        self.bonus = bonus\n\n# Create test performances dictionary\ntest_performances = {\n    \"001\": Assessment(Worker(\"John Doe\", \"Engineer\"), 5, \"Excellent\", 1000),\n    \"002\": Assessment(Worker(\"Jane Smith\", \"Manager\"), 4, \"Good\", 800),\n    \"003\": Assessment(Worker(\"Bob Johnson\", \"Intern\"), 3, \"Average\", 0)\n}\n\nclass TestEmployeeReport(unittest.TestCase):\n    @patch('solution.performances', test_performances)\n    def test_valid_worker_and_template(self):\n        \"\"\"Test with valid worker_id and template with allowed placeholders.\"\"\"\n        result = create_employee_report(\"001\", \"Employee: {worker.name}, Position: {worker.position}, Rating: {assessment.rating}\")\n        self.assertEqual(result, \"Employee: John Doe, Position: Engineer, Rating: 5\")\n    \n    @patch('solution.performances', test_performances)\n    def test_empty_template(self):\n        \"\"\"Test with empty template returns empty string.\"\"\"\n        result = create_employee_report(\"001\", \"\")\n        self.assertEqual(result, \"\")\n    \n    @patch('solution.performances', test_performances)\n    def test_no_placeholders(self):\n        \"\"\"Test template without placeholders returns the template as is.\"\"\"\n        template = \"This is a static template\"\n        result = create_employee_report(\"001\", template)\n        self.assertEqual(result, template)\n    \n    @patch('solution.performances', test_performances)\n    def test_invalid_worker_id(self):\n        \"\"\"Test with invalid worker_id raises ValueError.\"\"\"\n        with self.assertRaises(ValueError) as context:\n            create_employee_report(\"004\", \"Template\")\n        self.assertIn(\"Worker with ID 004 not found\", str(context.exception))\n    \n    @patch('solution.performances', test_performances)\n    def test_access_forbidden_feedback(self):\n        \"\"\"Test accessing forbidden 'feedback' attribute raises ValueError.\"\"\"\n        with self.assertRaises(ValueError) as context:\n            create_employee_report(\"001\", \"Feedback: {assessment.feedback}\")\n        self.assertEqual(str(context.exception), \"Access to feedback is not allowed in the summary\")\n    \n    @patch('solution.performances', test_performances)\n    def test_access_forbidden_bonus(self):\n        \"\"\"Test accessing forbidden 'bonus' attribute raises ValueError.\"\"\"\n        with self.assertRaises(ValueError) as context:\n            create_employee_report(\"001\", \"Bonus: {assessment.bonus}\")\n        self.assertEqual(str(context.exception), \"Access to bonus is not allowed in the summary\")\n    \n    @patch('solution.performances', test_performances)\n    def test_nonexistent_attribute(self):\n        \"\"\"Test accessing non-existent attribute raises AttributeError.\"\"\"\n        with self.assertRaises(AttributeError):\n            create_employee_report(\"001\", \"Unknown: {assessment.unknown_attribute}\")\n    \n    @patch('solution.performances', test_performances)\n    def test_different_valid_worker(self):\n        \"\"\"Test with a different valid worker_id.\"\"\"\n        result = create_employee_report(\"002\", \"Name: {worker.name}, Position: {worker.position}\")\n        self.assertEqual(result, \"Name: Jane Smith, Position: Manager\")\n    \n    @patch('solution.performances', test_performances)\n    def test_multiline_template(self):\n        \"\"\"Test multiline template with multiple placeholders.\"\"\"\n        template = \"Employee Summary:\\nName: {worker.name}\\nPosition: {worker.position}\\nRating: {assessment.rating}\"\n        expected = \"Employee Summary:\\nName: Bob Johnson\\nPosition: Intern\\nRating: 3\"\n        result = create_employee_report(\"003\", template)\n        self.assertEqual(result, expected)\n    \n    @patch('solution.performances', test_performances)\n    def test_worker_with_minimal_data(self):\n        \"\"\"Test worker with only name and position (no feedback/bonus).\"\"\"\n        test_perf = {\"004\": Assessment(Worker(\"Minimal\", \"Employee\"), 2)}\n        with patch('solution.performances', test_perf):\n            result = create_employee_report(\"004\", \"{worker.name} - {worker.position}\")\n        self.assertEqual(result, \"Minimal - Employee\")\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 10, "task_id": "d44fa9a5"}
{"test": "import unittest\n\n# Define the Employee and Performance classes for testing\nclass Employee:\n    def __init__(self, name, position, department=None):\n        self.name = name\n        self.position = position\n        self.department = department\n\nclass Performance:\n    def __init__(self, personnel, rating, feedback=None, bonus=None):\n        self.personnel = personnel\n        self.rating = rating\n        self.feedback = feedback\n        self.bonus = bonus\n\n# Define the function under test\ndef compile_employee_evaluation(employee_id, template):\n    if employee_id not in performances:\n        raise ValueError(f\"Employee with ID {employee_id} not found\")\n    review = performances[employee_id]\n    class ProtectedPerformance:\n        def __init__(self, review):\n            self._review = review\n\n        def __getattr__(self, name):\n            if name in ['feedback', 'bonus']:\n                raise ValueError(f\"Access to {name} is not allowed in the summary\")\n            return getattr(self._review, name)\n\n    protected_review = ProtectedPerformance(review)\n    return template.format(personnel=protected_review.personnel, review=protected_review)\n\nclass TestCompileEmployeeEvaluation(unittest.TestCase):\n    def setUp(self):\n        global performances\n        # Save original performances to restore in tearDown\n        self.orig_performances = performances if 'performances' in globals() else None\n        \n        # Setup test data\n        self.test_performances = {\n            \"001\": Performance(Employee(\"John Doe\", \"Developer\", \"Engineering\"), 5, \"Good\", 10000),\n            \"002\": Performance(Employee(\"Jane Smith\", \"Manager\", \"Marketing\"), 4, \"Excellent\", 15000),\n            \"003\": Performance(Employee(\"Bob Johnson\", \"HR\", \"Human Resources\"), 3, \"Average\", 5000)\n        }\n        # Add dynamic attribute for test case 9\n        self.test_performances[\"003\"].projects = 10\n        performances = self.test_performances\n\n    def tearDown(self):\n        global performances\n        if self.orig_performances is not None:\n            performances = self.orig_performances\n        else:\n            if 'performances' in globals():\n                del performances\n\n    def test_case_1(self):\n        # Typical usage with valid employee ID and template\n        result = compile_employee_evaluation(\"001\", \"Employee {personnel.name} is a {personnel.position} with rating {review.rating}.\")\n        self.assertEqual(result, \"Employee John Doe is a Developer with rating 5.\")\n\n    def test_case_2(self):\n        # Multiple allowed attributes including department\n        result = compile_employee_evaluation(\"002\", \"Name: {personnel.name}, Position: {personnel.position}, Department: {personnel.department}, Rating: {review.rating}.\")\n        self.assertEqual(result, \"Name: Jane Smith, Position: Manager, Department: Marketing, Rating: 4.\")\n\n    def test_case_3(self):\n        # Empty template string\n        result = compile_employee_evaluation(\"001\", \"\")\n        self.assertEqual(result, \"\")\n\n    def test_case_4(self):\n        # Template without placeholders\n        result = compile_employee_evaluation(\"001\", \"Static content without placeholders.\")\n        self.assertEqual(result, \"Static content without placeholders.\")\n\n    def test_case_5(self):\n        # Invalid employee ID\n        with self.assertRaises(ValueError):\n            compile_employee_evaluation(\"004\", \"Template\")\n\n    def test_case_6(self):\n        # Attempt to access protected 'feedback' attribute\n        with self.assertRaises(ValueError):\n            compile_employee_evaluation(\"001\", \"Feedback: {review.feedback}\")\n\n    def test_case_7(self):\n        # Attempt to access protected 'bonus' attribute\n        with self.assertRaises(ValueError):\n            compile_employee_evaluation(\"001\", \"Bonus: {review.bonus}\")\n\n    def test_case_8(self):\n        # Reference non-existent attribute\n        with self.assertRaises(AttributeError):\n            compile_employee_evaluation(\"001\", \"Age: {personnel.age}\")\n\n    def test_case_9(self):\n        # Access allowed non-standard attribute\n        result = compile_employee_evaluation(\"003\", \"Projects: {review.projects}\")\n        self.assertEqual(result, \"Projects: 10\")\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 9, "task_id": "81a794b7"}
{"test": "import unittest\nfrom unittest.mock import patch\n\nclass Employee:\n    def __init__(self, name, position, department):\n        self.name = name\n        self.position = position\n        self.department = department\n\nclass Performance:\n    def __init__(self, staff, rating):\n        self.staff = staff\n        self.rating = rating\n        self.feedback = \"Confidential feedback\"\n        self.bonus = 1000\n\nclass TestBuildEmployeeReport(unittest.TestCase):\n    def setUp(self):\n        self.employee1 = Employee(\"John Doe\", \"Developer\", \"Engineering\")\n        self.performance1 = Performance(self.employee1, 5)\n        self.employee2 = Employee(\"Jane Smith\", \"Manager\", \"Marketing\")\n        self.performance2 = Performance(self.employee2, 4)\n        self.performances = {\n            \"001\": self.performance1,\n            \"002\": self.performance2\n        }\n\n    def test_valid_employee_and_template(self):\n        # Test with allowed placeholders: name, position, department, rating\n        template = \"Employee {staff.name} is a {staff.position} in {staff.department}. Rating: {evaluation.rating}\"\n        with patch('__main__.performances', self.performances):\n            result = build_employee_report(\"001\", template)\n        expected = \"Employee John Doe is a Developer in Engineering. Rating: 5\"\n        self.assertEqual(result, expected)\n\n    def test_multiple_placeholders(self):\n        # Test template with multiple allowed placeholders\n        template = \"{staff.name} {staff.position} {evaluation.rating}\"\n        with patch('__main__.performances', self.performances):\n            result = build_employee_report(\"001\", template)\n        expected = \"John Doe Developer 5\"\n        self.assertEqual(result, expected)\n\n    def test_empty_template(self):\n        # Test with empty template string\n        template = \"\"\n        with patch('__main__.performances', self.performances):\n            result = build_employee_report(\"001\", template)\n        self.assertEqual(result, \"\")\n\n    def test_no_placeholders(self):\n        # Test template without any placeholders (static text)\n        template = \"Hello, this is a static template.\"\n        with patch('__main__.performances', self.performances):\n            result = build_employee_report(\"001\", template)\n        self.assertEqual(result, \"Hello, this is a static template.\")\n\n    def test_invalid_employee_id(self):\n        # Test with non-existent employee ID\n        template = \"Some template\"\n        with patch('__main__.performances', self.performances):\n            with self.assertRaises(ValueError) as context:\n                build_employee_report(\"003\", template)\n            self.assertEqual(str(context.exception), \"Employee with ID 003 not found\")\n\n    def test_access_feedback(self):\n        # Test accessing restricted 'feedback' attribute\n        template = \"Feedback: {evaluation.feedback}\"\n        with patch('__main__.performances', self.performances):\n            with self.assertRaises(ValueError) as context:\n                build_employee_report(\"001\", template)\n            self.assertEqual(str(context.exception), \"Access to feedback is not allowed in the summary\")\n\n    def test_access_bonus(self):\n        # Test accessing restricted 'bonus' attribute\n        template = \"Bonus: {evaluation.bonus}\"\n        with patch('__main__.performances', self.performances):\n            with self.assertRaises(ValueError) as context:\n                build_employee_report(\"001\", template)\n            self.assertEqual(str(context.exception), \"Access to bonus is not allowed in the summary\")\n\n    def test_rating_access(self):\n        # Test accessing allowed 'rating' attribute\n        template = \"Rating: {evaluation.rating}\"\n        with patch('__main__.performances', self.performances):\n            result = build_employee_report(\"001\", template)\n        self.assertEqual(result, \"Rating: 5\")\n\n    def test_non_existent_evaluation_attribute(self):\n        # Test accessing non-existent attribute on evaluation\n        template = \"Something: {evaluation.something}\"\n        with patch('__main__.performances', self.performances):\n            with self.assertRaises(AttributeError):\n                build_employee_report(\"001\", template)\n\n    def test_non_existent_staff_attribute(self):\n        # Test accessing non-existent attribute on staff\n        template = \"Something: {staff.something}\"\n        with patch('__main__.performances', self.performances):\n            with self.assertRaises(AttributeError):\n                build_employee_report(\"001\", template)\n\n    def test_invalid_employee_id_empty_string(self):\n        # Test with empty string employee ID\n        template = \"Some template\"\n        with patch('__main__.performances', self.performances):\n            with self.assertRaises(ValueError) as context:\n                build_employee_report(\"\", template)\n            self.assertEqual(str(context.exception), \"Employee with ID  not found\")\n", "num_test_cases": 12, "task_id": "d0e5f326"}
{"test": "import unittest\n\nclass Employee:\n    def __init__(self, name, position, department):\n        self.name = name\n        self.position = position\n        self.department = department\n\nclass Performance:\n    def __init__(self, employee, rating, feedback=None, bonus=None):\n        self.employee = employee\n        self.rating = rating\n        self.feedback = feedback\n        self.bonus = bonus\n\nclass TestCreatePerformanceSummary(unittest.TestCase):\n    def setUp(self):\n        self.employee1 = Employee(name='John Doe', position='Engineer', department='IT')\n        self.employee2 = Employee(name='Jane Smith', position='Manager', department='HR')\n        self.performance1 = Performance(employee=self.employee1, rating=5, feedback='Good', bonus=1000)\n        self.performance2 = Performance(employee=self.employee2, rating=None, feedback='Excellent', bonus=2000)\n        global performances\n        self.original_performances = globals().get('performances', None)\n        performances = {\n            '001': self.performance1,\n            '002': self.performance2\n        }\n\n    def tearDown(self):\n        global performances\n        if self.original_performances is not None:\n            performances = self.original_performances\n        else:\n            if 'performances' in globals():\n                del globals()['performances']\n\n    def test_happy_path_multiple_attributes(self):\n        # Typical use case with multiple allowed placeholders\n        template = 'Employee {employee.name} is a {employee.position} in {employee.department}. Rating: {performance.rating}'\n        result = create_performance_summary('001', template)\n        self.assertEqual(result, 'Employee John Doe is a Engineer in IT. Rating: 5')\n\n    def test_employee_not_found(self):\n        # Invalid employee ID\n        template = 'Some template'\n        with self.assertRaises(ValueError) as context:\n            create_performance_summary('003', template)\n        self.assertEqual(str(context.exception), 'Employee with ID 003 not found')\n\n    def test_restricted_field_feedback(self):\n        # Attempt to access restricted 'feedback' field\n        template = 'Feedback: {performance.feedback}'\n        with self.assertRaises(ValueError) as context:\n            create_performance_summary('001', template)\n        self.assertEqual(str(context.exception), 'Access to feedback is not allowed in the summary')\n\n    def test_restricted_field_bonus(self):\n        # Attempt to access restricted 'bonus' field\n        template = 'Bonus: {performance.bonus}'\n        with self.assertRaises(ValueError) as context:\n            create_performance_summary('001', template)\n        self.assertEqual(str(context.exception), 'Access to bonus is not allowed in the summary')\n\n    def test_invalid_attribute(self):\n        # Placeholder references non-existing attribute\n        template = 'Invalid: {performance.invalid_attr}'\n        with self.assertRaises(AttributeError):\n            create_performance_summary('001', template)\n\n    def test_empty_template(self):\n        # Empty template string\n        template = ''\n        result = create_performance_summary('001', template)\n        self.assertEqual(result, '')\n\n    def test_none_rating(self):\n        # None value for allowed attribute\n        template = 'Rating: {performance.rating}'\n        result = create_performance_summary('002', template)\n        self.assertEqual(result, 'Rating: None')\n\n    def test_float_rating(self):\n        # Float value for rating attribute\n        employee3 = Employee(name='Bob', position='Intern', department='IT')\n        performance3 = Performance(employee=employee3, rating=4.5)\n        performances['003'] = performance3\n        template = 'Rating: {performance.rating}'\n        result = create_performance_summary('003', template)\n        self.assertEqual(result, 'Rating: 4.5')\n\n    def test_single_attribute(self):\n        # Template with only employee name\n        template = '{employee.name}'\n        result = create_performance_summary('001', template)\n        self.assertEqual(result, 'John Doe')", "num_test_cases": 9, "task_id": "1f33da33"}
{"test": "import unittest\nfrom unittest.mock import patch\n\n# Define necessary classes for testing\nclass Employee:\n    def __init__(self, name, position, department):\n        self.name = name\n        self.position = position\n        self.department = department\n\nclass Performance:\n    def __init__(self, employee, rating, feedback=None, bonus=None):\n        self.employee = employee\n        self.rating = rating\n        self.feedback = feedback\n        self.bonus = bonus\n\nclass TestConstructEmployeeReport(unittest.TestCase):\n    def setUp(self):\n        # Create a sample employee and performance\n        self.employee = Employee(\"John Doe\", \"Software Engineer\", \"Engineering\")\n        self.performance = Performance(self.employee, 8, \"Good performance\", 5000)\n        self.mock_performances = {\"001\": self.performance}\n\n    def test_happy_path(self):\n        # Test valid employee ID and template with allowed fields\n        with patch('__main__.performances', self.mock_performances):\n            template = 'Employee: {employee.name}, Position: {employee.position}, Rating: {performance.rating}'\n            result = construct_employee_report('001', template)\n            expected = 'Employee: John Doe, Position: Software Engineer, Rating: 8'\n            self.assertEqual(result, expected)\n\n    def test_employee_not_found(self):\n        # Test non-existent employee ID\n        with patch('__main__.performances', self.mock_performances):\n            with self.assertRaises(ValueError) as context:\n                construct_employee_report('002', 'Any template')\n            self.assertEqual(str(context.exception), \"Employee with ID 002 not found\")\n\n    def test_restricted_field_feedback(self):\n        # Test accessing restricted 'feedback' field\n        with patch('__main__.performances', self.mock_performances):\n            template = 'Feedback: {performance.feedback}'\n            with self.assertRaises(ValueError) as context:\n                construct_employee_report('001', template)\n            self.assertEqual(str(context.exception), \"Access to feedback is not allowed in the summary\")\n\n    def test_restricted_field_bonus(self):\n        # Test accessing restricted 'bonus' field\n        with patch('__main__.performances', self.mock_performances):\n            template = 'Bonus: {performance.bonus}'\n            with self.assertRaises(ValueError) as context:\n                construct_employee_report('001', template)\n            self.assertEqual(str(context.exception), \"Access to bonus is not allowed in the summary\")\n\n    def test_non_existent_field(self):\n        # Test using non-existent field in performance\n        with patch('__main__.performances', self.mock_performances):\n            template = 'NonExistent: {performance.non_exist}'\n            with self.assertRaises(AttributeError):\n                construct_employee_report('001', template)\n\n    def test_empty_template(self):\n        # Test empty template string\n        with patch('__main__.performances', self.mock_performances):\n            template = ''\n            result = construct_employee_report('001', template)\n            self.assertEqual(result, '')\n\n    def test_multiple_allowed_fields(self):\n        # Test template with multiple allowed fields\n        with patch('__main__.performances', self.mock_performances):\n            template = 'Name: {employee.name}, Rating: {performance.rating}, Department: {employee.department}'\n            result = construct_employee_report('001', template)\n            expected = 'Name: John Doe, Rating: 8, Department: Engineering'\n            self.assertEqual(result, expected)\n\n    def test_non_existent_field_in_employee(self):\n        # Test non-existent field in employee object\n        employee2 = Employee(\"Jane Smith\", \"Manager\", \"HR\")\n        del employee2.department  # Remove attribute to simulate non-existence\n        performance2 = Performance(employee2, 9)\n        mock_performances = {'002': performance2}\n        with patch('__main__.performances', mock_performances):\n            template = 'Department: {employee.department}'\n            with self.assertRaises(AttributeError):\n                construct_employee_report('002', template)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 8, "task_id": "4550d49e"}
{"test": "import unittest\nfrom unittest.mock import patch\n\n# Helper classes for test data\nclass Employee:\n    def __init__(self, name, position, department):\n        self.name = name\n        self.position = position\n        self.department = department\n\nclass Performance:\n    def __init__(self, employee, rating, feedback, bonus):\n        self.employee = employee\n        self.rating = rating\n        self.feedback = feedback\n        self.bonus = bonus\n\n# Import the function from the solution module\nfrom solution import compile_performance_report\n\nclass TestPerformanceReport(unittest.TestCase):\n    def setUp(self):\n        # Setup test data\n        self.emp = Employee('John Doe', 'Software Engineer', 'Engineering')\n        self.perf = Performance(self.emp, 5, 'Excellent', 10000)\n        self.emp_special = Employee('Jane Smith-\\u00c7', 'Manager, R&D', 'R&D')\n        self.perf_special = Performance(self.emp_special, 4, 'Good', 5000)\n        self.performances = {\n            '123': self.perf,\n            '456': self.perf_special\n        }\n\n    def test_valid_template(self):\n        # Test happy path with valid employee and allowed fields\n        with patch('solution.performances', self.performances):\n            template = 'Employee: {employee.name}, Position: {employee.position}, Rating: {performance.rating}'\n            result = compile_performance_report('123', template)\n            self.assertEqual(result, 'Employee: John Doe, Position: Software Engineer, Rating: 5')\n\n    def test_employee_not_found(self):\n        # Test with non-existent employee ID\n        with patch('solution.performances', self.performances):\n            with self.assertRaises(ValueError) as context:\n                compile_performance_report('999', 'Template')\n            self.assertIn('Employee with ID 999 not found', str(context.exception))\n\n    def test_employee_id_empty_string(self):\n        # Test with empty string employee ID\n        with patch('solution.performances', self.performances):\n            with self.assertRaises(ValueError) as context:\n                compile_performance_report('', 'Template')\n            self.assertIn('Employee with ID  not found', str(context.exception))\n\n    def test_employee_id_none(self):\n        # Test with None employee ID\n        with patch('solution.performances', self.performances):\n            with self.assertRaises(ValueError) as context:\n                compile_performance_report(None, 'Template')\n            self.assertIn('Employee with ID None not found', str(context.exception))\n\n    def test_restricted_field_feedback(self):\n        # Test accessing restricted 'feedback' field\n        with patch('solution.performances', self.performances):\n            template = 'Feedback: {performance.feedback}'\n            with self.assertRaises(ValueError) as context:\n                compile_performance_report('123', template)\n            self.assertIn('Access to feedback is not allowed', str(context.exception))\n\n    def test_restricted_field_bonus(self):\n        # Test accessing restricted 'bonus' field\n        with patch('solution.performances', self.performances):\n            template = 'Bonus: {performance.bonus}'\n            with self.assertRaises(ValueError) as context:\n                compile_performance_report('123', template)\n            self.assertIn('Access to bonus is not allowed', str(context.exception))\n\n    def test_multiple_restricted_fields(self):\n        # Test template with multiple restricted fields\n        with patch('solution.performances', self.performances):\n            template = 'Bonus: {performance.bonus}, Feedback: {performance.feedback}'\n            with self.assertRaises(ValueError) as context:\n                compile_performance_report('123', template)\n            self.assertIn('Access to bonus is not allowed', str(context.exception))\n\n    def test_empty_template(self):\n        # Test with empty template string\n        with patch('solution.performances', self.performances):\n            result = compile_performance_report('123', '')\n            self.assertEqual(result, '')\n\n    def test_non_existent_field(self):\n        # Test accessing non-existent field\n        with patch('solution.performances', self.performances):\n            template = '{employee.non_existent}'\n            with self.assertRaises(AttributeError):\n                compile_performance_report('123', template)\n\n    def test_template_with_multiple_lines(self):\n        # Test multi-line template with allowed fields\n        with patch('solution.performances', self.performances):\n            template = 'Name: {employee.name}\\nPosition: {employee.position}\\nRating: {performance.rating}'\n            expected = 'Name: John Doe\\nPosition: Software Engineer\\nRating: 5'\n            result = compile_performance_report('123', template)\n            self.assertEqual(result, expected)\n\n    def test_special_characters(self):\n        # Test special characters in employee data\n        with patch('solution.performances', self.performances):\n            template = 'Name: {employee.name}, Position: {employee.position}'\n            result = compile_performance_report('456', template)\n            self.assertEqual(result, 'Name: Jane Smith-\\u00c7, Position: Manager, R&D')\n\n    def test_template_none(self):\n        # Test None as template (invalid input)\n        with patch('solution.performances', self.performances):\n            with self.assertRaises(AttributeError):\n                compile_performance_report('123', None)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 12, "task_id": "2b32dda7"}
{"test": "import unittest\n\n# Define a Student class for the tests\nclass Student:\n    def __init__(self, name, course, age, gpa=None, address=None, record=None):\n        self.name = name\n        self.course = course\n        self.age = age\n        self.gpa = gpa\n        self.address = address\n        self.record = record\n\n# Define the global 'students' dictionary that the function uses\nstudents = {\n    '001': Student('John Doe', 'Computer Science', 20, 3.5, '123 Main St', None),\n    '002': Student('Jane Smith', 'Mathematics', 22, 3.8, '456 Oak Ave', None),\n    '003': Student('Bob Brown', 'Physics', 21, 3.2, '789 Pine Rd', 'Disciplinary note')\n}\n\nclass TestCases(unittest.TestCase):\n    def test_happy_path(self):\n        \"\"\"Test with allowed placeholders: name, course, age.\"\"\"\n        template = \"Name: {student.name}, Course: {student.course}, Age: {student.age}\"\n        result = create_student_summary('001', template)\n        self.assertEqual(result, \"Name: John Doe, Course: Computer Science, Age: 20\")\n    \n    def test_no_placeholders(self):\n        \"\"\"Test template without placeholders.\"\"\"\n        template = \"Simple greeting\"\n        result = create_student_summary('002', template)\n        self.assertEqual(result, \"Simple greeting\")\n    \n    def test_restricted_placeholder(self):\n        \"\"\"Test accessing restricted attribute (gpa) raises ValueError.\"\"\"\n        template = \"Name: {student.name}, GPA: {student.gpa}\"\n        with self.assertRaises(ValueError) as context:\n            create_student_summary('001', template)\n        self.assertIn(\"gpa\", str(context.exception))\n    \n    def test_student_not_found(self):\n        \"\"\"Test invalid student ID raises ValueError.\"\"\"\n        with self.assertRaises(ValueError) as context:\n            create_student_summary('004', \"Template\")\n        self.assertEqual(str(context.exception), \"Student not found\")\n    \n    def test_empty_template(self):\n        \"\"\"Test empty template returns empty string.\"\"\"\n        result = create_student_summary('001', \"\")\n        self.assertEqual(result, \"\")\n    \n    def test_multiple_occurrences(self):\n        \"\"\"Test multiple occurrences of allowed placeholder.\"\"\"\n        template = \"{student.name} - {student.name}\"\n        result = create_student_summary('001', template)\n        self.assertEqual(result, \"John Doe - John Doe\")\n    \n    def test_non_existent_attribute(self):\n        \"\"\"Test non-existent attribute raises AttributeError.\"\"\"\n        template = \"{student.unknown_attribute}\"\n        with self.assertRaises(AttributeError):\n            create_student_summary('001', template)\n    \n    def test_only_restricted_attribute(self):\n        \"\"\"Test template with only restricted attributes raises ValueError.\"\"\"\n        template = \"GPA: {student.gpa}\"\n        with self.assertRaises(ValueError):\n            create_student_summary('001', template)\n    \n    def test_age_as_restricted_bypass(self):\n        \"\"\"Ensure age (allowed) works even if other restricted attributes exist.\"\"\"\n        template = \"Age: {student.age}\"\n        result = create_student_summary('003', template)\n        self.assertEqual(result, \"Age: 21\")\n    \n    def test_all_allowed_attributes(self):\n        \"\"\"Test all allowed attributes together.\"\"\"\n        template = \"{student.name} studies {student.course} at age {student.age}\"\n        result = create_student_summary('002', template)\n        self.assertEqual(result, \"Jane Smith studies Mathematics at age 22\")\n    \n    def test_missing_optional_attribute(self):\n        \"\"\"Test accessing a non-restricted but unset attribute raises AttributeError.\"\"\"\n        # Create a student without a 'hobby' attribute\n        template = \"Hobby: {student.hobby}\"\n        with self.assertRaises(AttributeError):\n            create_student_summary('001', template)", "num_test_cases": 11, "task_id": "62d5a158"}
{"test": "import unittest\nfrom unittest.mock import patch\n\n# Define a Student class for testing\nclass Student:\n    def __init__(self, name, course, age, gpa, residence, discipl_record):\n        self.name = name\n        self.course = course\n        self.age = age\n        self.gpa = gpa\n        self.residence = residence\n        self.discipl_record = discipl_record\n\n# Sample students\nstudent1 = Student(\"John Doe\", \"Computer Science\", 20, 3.8, \"123 Main St\", None)\nstudent2 = Student(\"Jane Smith\", \"Mathematics\", 21, 3.9, \"456 Oak Ave\", \"Late submission\")\nlearners_dict = {\n    \"S001\": student1,\n    \"S002\": student2\n}\n\nclass TestBuildStudentReport(unittest.TestCase):\n    @classmethod\n    def setUpClass(cls):\n        # Patch the 'learners' in the solution module\n        cls.patcher = patch('solution.learners', learners_dict)\n        cls.patcher.start()\n\n    @classmethod\n    def tearDownClass(cls):\n        cls.patcher.stop()\n\n    def test_valid_student_and_allowed_attribute(self):\n        # Test with valid student ID and layout using allowed attribute (name)\n        layout = \"Student Name: {student.name}\"\n        from solution import build_student_report\n        result = build_student_report(\"S001\", layout)\n        self.assertEqual(result, \"Student Name: John Doe\")\n\n    def test_student_not_found(self):\n        # Test with invalid student ID\n        from solution import build_student_report\n        with self.assertRaises(ValueError) as context:\n            build_student_report(\"S003\", \"layout\")\n        self.assertEqual(str(context.exception), \"Student not found\")\n\n    def test_restricted_gpa(self):\n        # Test accessing restricted attribute (gpa)\n        from solution import build_student_report\n        layout = \"GPA: {student.gpa}\"\n        with self.assertRaises(ValueError) as context:\n            build_student_report(\"S001\", layout)\n        self.assertEqual(str(context.exception), \"Access to gpa is not permitted in the report\")\n\n    def test_restricted_residence(self):\n        # Test accessing restricted attribute (residence)\n        from solution import build_student_report\n        layout = \"Address: {student.residence}\"\n        with self.assertRaises(ValueError) as context:\n            build_student_report(\"S001\", layout)\n        self.assertEqual(str(context.exception), \"Access to residence is not permitted in the report\")\n\n    def test_restricted_discipl_record(self):\n        # Test accessing restricted attribute (discipl_record)\n        from solution import build_student_report\n        layout = \"Record: {student.discipl_record}\"\n        with self.assertRaises(ValueError) as context:\n            build_student_report(\"S001\", layout)\n        self.assertEqual(str(context.exception), \"Access to discipl_record is not permitted in the report\")\n\n    def test_mixed_attributes(self):\n        # Test mix of allowed and restricted attributes (fails at restricted)\n        from solution import build_student_report\n        layout = \"Name: {student.name}, GPA: {student.gpa}\"\n        with self.assertRaises(ValueError) as context:\n            build_student_report(\"S001\", layout)\n        self.assertEqual(str(context.exception), \"Access to gpa is not permitted in the report\")\n\n    def test_non_existent_attribute(self):\n        # Test accessing a non-existent attribute\n        from solution import build_student_report\n        layout = \"Hobby: {student.hobby}\"\n        with self.assertRaises(AttributeError):\n            build_student_report(\"S001\", layout)\n\n    def test_empty_layout(self):\n        # Test with an empty layout string\n        from solution import build_student_report\n        result = build_student_report(\"S001\", \"\")\n        self.assertEqual(result, \"\")\n\n    def test_multiple_allowed_attributes(self):\n        # Test with multiple allowed attributes\n        from solution import build_student_report\n        layout = \"Name: {student.name}, Course: {student.course}, Age: {student.age}\"\n        result = build_student_report(\"S001\", layout)\n        self.assertEqual(result, \"Name: John Doe, Course: Computer Science, Age: 20\")\n\n    def test_age_as_integer(self):\n        # Test formatting of non-string allowed attribute (age)\n        from solution import build_student_report\n        layout = \"Age: {student.age}\"\n        result = build_student_report(\"S001\", layout)\n        self.assertEqual(result, \"Age: 20\")\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 10, "task_id": "dff3619e"}
{"test": "import unittest\n\nclass Student:\n    def __init__(self, name, course, age, marks, address, behavior_record):\n        self.name = name\n        self.course = course\n        self.age = age\n        self.marks = marks\n        self.address = address\n        self.behavior_record = behavior_record\n\nclass TestCompileStudentProfile(unittest.TestCase):\n    def setUp(self):\n        global learners\n        self.student1 = Student('John Doe', 'Computer Science', 20, 3.5, '123 Main St', 'Good')\n        self.student2 = Student('Jane Smith', 'Mathematics', 21, 3.8, '456 Oak Ave', 'Excellent')\n        learners = {\n            'S001': self.student1,\n            'S002': self.student2\n        }\n\n    def test_basic_formatting(self):\n        # Test basic formatting with allowed attribute (name)\n        result = compile_student_profile('S001', 'Name: {student.name}')\n        self.assertEqual(result, 'Name: John Doe')\n\n    def test_multiple_allowed_attributes(self):\n        # Test multiple allowed attributes\n        template = 'Name: {student.name}, Course: {student.course}, Age: {student.age}'\n        result = compile_student_profile('S001', template)\n        self.assertEqual(result, 'Name: John Doe, Course: Computer Science, Age: 20')\n\n    def test_empty_template(self):\n        # Test with an empty template\n        result = compile_student_profile('S001', '')\n        self.assertEqual(result, '')\n\n    def test_template_without_placeholders(self):\n        # Test template without placeholders\n        template = 'This is a fixed string without placeholders.'\n        result = compile_student_profile('S001', template)\n        self.assertEqual(result, template)\n\n    def test_invalid_learner_code(self):\n        # Test with an invalid learner code\n        with self.assertRaises(ValueError):\n            compile_student_profile('S003', 'Some template')\n\n    def test_sensitive_attribute_marks(self):\n        # Test template accessing 'marks' (sensitive) - should raise ValueError\n        template = 'Name: {student.name}, GPA: {student.marks}'\n        with self.assertRaises(ValueError):\n            compile_student_profile('S001', template)\n\n    def test_sensitive_attribute_address(self):\n        # Test template accessing 'address' (sensitive) - should raise ValueError\n        template = 'Address: {student.address}'\n        with self.assertRaises(ValueError):\n            compile_student_profile('S001', template)\n\n    def test_sensitive_attribute_behavior_record(self):\n        # Test template accessing 'behavior_record' (sensitive) - should raise ValueError\n        template = 'Behavior: {student.behavior_record}'\n        with self.assertRaises(ValueError):\n            compile_student_profile('S001', template)\n\n    def test_non_existing_attribute(self):\n        # Test template accessing a non-existing attribute (not sensitive) - should raise AttributeError\n        template = 'Name: {student.name}, Foo: {student.foo}'\n        with self.assertRaises(AttributeError):\n            compile_student_profile('S001', template)\n\n    def test_long_strings(self):\n        # Test with very long strings in allowed attributes\n        global learners\n        long_string = 'A' * 1000\n        student = Student(long_string, long_string, 100, 4.0, 'B'*1000, 'C'*1000)\n        learners = {'S003': student}\n        template = 'Name: {student.name}, Course: {student.course}, Age: {student.age}'\n        result = compile_student_profile('S003', template)\n        expected = 'Name: ' + long_string + ', Course: ' + long_string + ', Age: 100'\n        self.assertEqual(result, expected)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 10, "task_id": "b770a6b4"}
{"test": "import unittest\n\nclass Student:\n    def __init__(self, name, course, age, gpa, home_address, discipline_record):\n        self.name = name\n        self.course = course\n        self.age = age\n        self.gpa = gpa\n        self.home_address = home_address\n        self.discipline_record = discipline_record\n\nstudents = {\n    'student1': Student('John Doe', 'Computer Science', 20, 3.5, '123 Main St', 'None'),\n    'student2': Student('Jane Smith', 'Mathematics', 21, 3.8, '456 Elm St', 'None'),\n    'student3': Student('Alice Johnson', 'Physics', 22, 3.9, '789 Oak St', 'None')\n}\n\nclass TestCreateStudentSummary(unittest.TestCase):\n    def test_allowed_attributes(self):\n        # Test with allowed attributes: name and course\n        result = create_student_summary('student1', 'Name: {student.name}, Course: {student.course}')\n        self.assertEqual(result, 'Name: John Doe, Course: Computer Science')\n\n    def test_student_not_found(self):\n        # Test with an invalid student ID\n        with self.assertRaises(ValueError) as context:\n            create_student_summary('invalid_id', 'Name: {student.name}')\n        self.assertIn('Student not found', str(context.exception))\n\n    def test_forbidden_gpa(self):\n        # Test accessing forbidden attribute: gpa\n        with self.assertRaises(ValueError) as context:\n            create_student_summary('student1', 'GPA: {student.gpa}')\n        self.assertIn('Access to gpa is not permitted', str(context.exception))\n\n    def test_forbidden_home_address(self):\n        # Test accessing forbidden attribute: home_address\n        with self.assertRaises(ValueError) as context:\n            create_student_summary('student1', 'Address: {student.home_address}')\n        self.assertIn('Access to home_address is not permitted', str(context.exception))\n\n    def test_forbidden_discipline_record(self):\n        # Test accessing forbidden attribute: discipline_record\n        with self.assertRaises(ValueError) as context:\n            create_student_summary('student1', 'Record: {student.discipline_record}')\n        self.assertIn('Access to discipline_record is not permitted', str(context.exception))\n\n    def test_empty_format_string(self):\n        # Test with empty format string\n        result = create_student_summary('student1', '')\n        self.assertEqual(result, '')\n\n    def test_non_existent_attribute(self):\n        # Test accessing non-existing attribute\n        with self.assertRaises(AttributeError) as context:\n            create_student_summary('student1', 'Test: {student.invalid_attr}')\n\n    def test_multiple_allowed_attributes(self):\n        # Test with multiple allowed attributes\n        result = create_student_summary('student2', 'Name: {student.name}, Age: {student.age}')\n        self.assertEqual(result, 'Name: Jane Smith, Age: 21')\n\n    def test_mixed_attributes(self):\n        # Test mix of allowed and forbidden attributes\n        with self.assertRaises(ValueError) as context:\n            create_student_summary('student1', 'Name: {student.name}, GPA: {student.gpa}')\n        self.assertIn('Access to gpa is not permitted', str(context.exception))\n\n    def test_no_placeholders(self):\n        # Test format string without placeholders\n        result = create_student_summary('student1', 'Static content')\n        self.assertEqual(result, 'Static content')\n\n    def test_large_input(self):\n        # Test with large input values\n        large_id = 'student3'\n        large_format = 'Name: ' + ('X' * 1000)\n        result = create_student_summary(large_id, large_format)\n        self.assertEqual(result, large_format)\n\n    def test_numeric_values(self):\n        # Test numeric attributes\n        result = create_student_summary('student1', 'Age: {student.age}')\n        self.assertEqual(result, 'Age: 20')\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 13, "task_id": "0491aaf8"}
{"test": "import unittest\nfrom unittest.mock import patch\n\ntry:\n    from solution import build_student_profile\nexcept ImportError:\n    from __main__ import build_student_profile\n\nclass Student:\n    def __init__(self, name, course, age, gpa, home_address, discipline_record):\n        self.name = name\n        self.course = course\n        self.age = age\n        self.gpa = gpa\n        self.home_address = home_address\n        self.discipline_record = discipline_record\n\ntest_student1 = Student(name='John Doe', course='Computer Science', age=22, gpa=3.8, home_address='123 Main St', discipline_record='None')\ntest_student2 = Student(name='Alice Smith', course='Physics', age=21, gpa=3.9, home_address='456 Elm St', discipline_record='None')\ntest_student3 = Student(name='Bob Brown', course='Mathematics', age=20, gpa=3.5, home_address='789 Oak St', discipline_record='Warning: Late submission')\ntest_students = {\n    '001': test_student1,\n    '002': test_student2,\n    '003': test_student3,\n    'empty': Student(name='', course='', age=0, gpa=0.0, home_address='', discipline_record='')\n}\n\nclass TestBuildStudentProfile(unittest.TestCase):\n\n    def test_valid_template(self):\n        # Test with valid unique_id and template with non-sensitive fields\n        with patch('solution.students', test_students):\n            template = 'Name: {student.name}, Course: {student.course}, Age: {student.age}'\n            result = build_student_profile('001', template)\n            expected = 'Name: John Doe, Course: Computer Science, Age: 22'\n            self.assertEqual(result, expected)\n\n    def test_student_not_found(self):\n        # Test with a unique_id that does not exist\n        with patch('solution.students', test_students):\n            with self.assertRaises(ValueError) as context:\n                build_student_profile('004', 'template')\n            self.assertEqual(str(context.exception), 'Student not found')\n\n    def test_sensitive_field_gpa(self):\n        # Test accessing the sensitive field 'gpa'\n        with patch('solution.students', test_students):\n            template = 'Name: {student.name}, GPA: {student.gpa}'\n            with self.assertRaises(ValueError) as context:\n                build_student_profile('001', template)\n            self.assertEqual(str(context.exception), 'Access to gpa is not permitted in the report')\n\n    def test_sensitive_field_home_address(self):\n        # Test accessing the sensitive field 'home_address'\n        with patch('solution.students', test_students):\n            template = 'Name: {student.name}, Address: {student.home_address}'\n            with self.assertRaises(ValueError) as context:\n                build_student_profile('001', template)\n            self.assertEqual(str(context.exception), 'Access to home_address is not permitted in the report')\n\n    def test_sensitive_field_discipline_record(self):\n        # Test accessing the sensitive field 'discipline_record'\n        with patch('solution.students', test_students):\n            template = 'Name: {student.name}, Record: {student.discipline_record}'\n            with self.assertRaises(ValueError) as context:\n                build_student_profile('001', template)\n            self.assertEqual(str(context.exception), 'Access to discipline_record is not permitted in the report')\n\n    def test_non_existent_field(self):\n        # Test accessing a non-existent field\n        with patch('solution.students', test_students):\n            template = 'Name: {student.name}, Field: {student.non_existent}'\n            with self.assertRaises(AttributeError):\n                build_student_profile('001', template)\n\n    def test_empty_template(self):\n        # Test with an empty template string\n        with patch('solution.students', test_students):\n            result = build_student_profile('001', '')\n            self.assertEqual(result, '')\n\n    def test_template_without_placeholders(self):\n        # Test with a template that has no placeholders\n        with patch('solution.students', test_students):\n            template = 'Hello World'\n            result = build_student_profile('001', template)\n            self.assertEqual(result, 'Hello World')\n\n    def test_mixed_sensitive_and_non_sensitive(self):\n        # Test template with both non-sensitive and sensitive fields (fails on first sensitive)\n        with patch('solution.students', test_students):\n            template = 'Name: {student.name}, Address: {student.home_address}'\n            with self.assertRaises(ValueError) as context:\n                build_student_profile('001', template)\n            self.assertEqual(str(context.exception), 'Access to home_address is not permitted in the report')\n\n    def test_empty_fields(self):\n        # Test with a student that has empty non-sensitive fields\n        with patch('solution.students', test_students):\n            template = 'Name: {student.name}, Course: {student.course}, Age: {student.age}'\n            result = build_student_profile('empty', template)\n            expected = 'Name: , Course: , Age: 0'\n            self.assertEqual(result, expected)\n\n    def test_multiple_valid_placeholders(self):\n        # Test multiple students with valid templates\n        with patch('solution.students', test_students):\n            template = 'Name: {student.name}, Course: {student.course}'\n            result1 = build_student_profile('001', template)\n            expected1 = 'Name: John Doe, Course: Computer Science'\n            self.assertEqual(result1, expected1)\n            result2 = build_student_profile('002', template)\n            expected2 = 'Name: Alice Smith, Course: Physics'\n            self.assertEqual(result2, expected2)\n\n    def test_none_template(self):\n        # Test with None as template (should raise AttributeError)\n        with patch('solution.students', test_students):\n            with self.assertRaises(AttributeError):\n                build_student_profile('001', None)\n\n    def test_large_input(self):\n        # Test with a very large template\n        with patch('solution.students', test_students):\n            long_template = 'Name: {student.name} ' + ('X' * 10000)\n            result = build_student_profile('001', long_template)\n            self.assertIn('John Doe', result)\n            self.assertEqual(len(result), 10000 + len('Name: John Doe '))\n", "num_test_cases": 13, "task_id": "11868c71"}
{"test": "import unittest\n\nclass Student:\n    def __init__(self, name, course, age, gpa, home_address, discipline_record):\n        self.name = name\n        self.course = course\n        self.age = age\n        self.gpa = gpa\n        self.home_address = home_address\n        self.discipline_record = discipline_record\n\nstudents = {\n    \"1\": Student(\"John Doe\", \"Computer Science\", 20, 3.5, \"123 Main St\", \"None\"),\n    \"2\": Student(\"Jane Smith\", \"Mathematics\", 21, 3.8, \"456 Elm St\", \"None\")\n}\n\ndef produce_student_report(stu_id, custom_template):\n    if stu_id not in students:\n        raise ValueError(\"Student not found\")\n    student = students[stu_id]\n    class SecureStudent:\n        def __init__(self, student):\n            self._student = student\n\n        def __getattr__(self, name):\n            if name in ['gpa', 'home_address', 'discipline_record']:\n                raise ValueError(f\"Access to {name} is not permitted in the report\")\n            return getattr(self._student, name)\n\n    secure_student = SecureStudent(student)\n    return custom_template.format(student=secure_student)\n\nclass TestProduceStudentReport(unittest.TestCase):\n    \n    def test_valid_template_allowed_placeholders(self):\n        # Test with valid student ID and template using allowed placeholders\n        result = produce_student_report(\"1\", \"Name: {student.name}, Course: {student.course}, Age: {student.age}\")\n        self.assertEqual(result, \"Name: John Doe, Course: Computer Science, Age: 20\")\n    \n    def test_empty_template(self):\n        # Test with empty template string\n        result = produce_student_report(\"1\", \"\")\n        self.assertEqual(result, \"\")\n    \n    def test_template_no_placeholders(self):\n        # Test with template containing no placeholders\n        result = produce_student_report(\"2\", \"Student Report\")\n        self.assertEqual(result, \"Student Report\")\n    \n    def test_student_not_found(self):\n        # Test with non-existent student ID\n        with self.assertRaises(ValueError) as context:\n            produce_student_report(\"3\", \"{student.name}\")\n        self.assertEqual(str(context.exception), \"Student not found\")\n    \n    def test_access_sensitive_gpa(self):\n        # Test template attempting to access GPA\n        with self.assertRaises(ValueError) as context:\n            produce_student_report(\"1\", \"GPA: {student.gpa}\")\n        self.assertEqual(str(context.exception), \"Access to gpa is not permitted in the report\")\n    \n    def test_access_sensitive_home_address(self):\n        # Test template attempting to access home address\n        with self.assertRaises(ValueError) as context:\n            produce_student_report(\"1\", \"Address: {student.home_address}\")\n        self.assertEqual(str(context.exception), \"Access to home_address is not permitted in the report\")\n    \n    def test_access_sensitive_discipline_record(self):\n        # Test template attempting to access discipline record\n        with self.assertRaises(ValueError) as context:\n            produce_student_report(\"1\", \"Discipline: {student.discipline_record}\")\n        self.assertEqual(str(context.exception), \"Access to discipline_record is not permitted in the report\")\n    \n    def test_access_nonexistent_attribute(self):\n        # Test template accessing a non-existing attribute\n        with self.assertRaises(AttributeError):\n            produce_student_report(\"1\", \"Hobby: {student.hobby}\")\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 8, "task_id": "1c1c74dd"}
{"test": "import unittest\n\n# Define a mock Student class for testing\nclass Student:\n    def __init__(self, name, course, age, gpa, home_address, discipline_record):\n        self.name = name\n        self.course = course\n        self.age = age\n        self.gpa = gpa\n        self.home_address = home_address\n        self.discipline_record = discipline_record\n\nclass TestCases(unittest.TestCase):\n    def setUp(self):\n        # Create student objects\n        self.student1 = Student(\n            name='John Doe',\n            course='Computer Science',\n            age=22,\n            gpa=3.8,\n            home_address='123 Main St',\n            discipline_record=None\n        )\n        self.student2 = Student(\n            name='Jane Smith',\n            course='Mathematics',\n            age=20,\n            gpa=3.9,\n            home_address='456 Oak Ave',\n            discipline_record='None'\n        )\n        self.students_dict = {\n            '001': self.student1,\n            '002': self.student2\n        }\n        # Backup and replace the global 'students' variable\n        self.original_students = globals().get('students', None)\n        globals()['students'] = self.students_dict\n    \n    def tearDown(self):\n        # Restore the original 'students' variable\n        if self.original_students is not None:\n            globals()['students'] = self.original_students\n        else:\n            del globals()['students']\n    \n    def test_valid_student_and_name(self):\n        # Test valid student ID and template with name attribute\n        result = create_student_report('001', 'Student Name: {student.name}')\n        self.assertEqual(result, 'Student Name: John Doe')\n    \n    def test_valid_student_multiple_attributes(self):\n        # Test valid student ID and template with multiple allowed attributes\n        template = 'Name: {student.name}, Course: {student.course}, Age: {student.age}'\n        result = create_student_report('002', template)\n        self.assertEqual(result, 'Name: Jane Smith, Course: Mathematics, Age: 20')\n    \n    def test_empty_template(self):\n        # Test valid student ID with empty template\n        result = create_student_report('001', '')\n        self.assertEqual(result, '')\n    \n    def test_invalid_student_id(self):\n        # Test invalid student ID\n        with self.assertRaises(ValueError) as context:\n            create_student_report('003', 'Some template')\n        self.assertEqual(str(context.exception), 'Student not found')\n    \n    def test_sensitive_gpa(self):\n        # Test template accessing sensitive GPA attribute\n        with self.assertRaises(ValueError) as context:\n            create_student_report('001', 'GPA: {student.gpa}')\n        self.assertEqual(str(context.exception), 'Access to gpa is not permitted in the report')\n    \n    def test_sensitive_home_address(self):\n        # Test template accessing sensitive home address attribute\n        with self.assertRaises(ValueError) as context:\n            create_student_report('001', 'Address: {student.home_address}')\n        self.assertEqual(str(context.exception), 'Access to home_address is not permitted in the report')\n    \n    def test_sensitive_discipline_record(self):\n        # Test template accessing sensitive discipline record\n        with self.assertRaises(ValueError) as context:\n            create_student_report('002', 'Record: {student.discipline_record}')\n        self.assertEqual(str(context.exception), 'Access to discipline_record is not permitted in the report')\n    \n    def test_mixed_attributes(self):\n        # Test template mixing allowed and sensitive attributes (allowed first)\n        template = 'Name: {student.name}, GPA: {student.gpa}'\n        with self.assertRaises(ValueError) as context:\n            create_student_report('001', template)\n        self.assertEqual(str(context.exception), 'Access to gpa is not permitted in the report')\n    \n    def test_mixed_attributes_sensitive_first(self):\n        # Test template mixing allowed and sensitive attributes (sensitive first)\n        template = 'GPA: {student.gpa}, Name: {student.name}'\n        with self.assertRaises(ValueError) as context:\n            create_student_report('001', template)\n        self.assertEqual(str(context.exception), 'Access to gpa is not permitted in the report')\n    \n    def test_age_attribute(self):\n        # Test valid student ID and template with age attribute\n        result = create_student_report('001', 'Age: {student.age}')\n        self.assertEqual(result, 'Age: 22')\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 10, "task_id": "85330604"}
{"test": "import unittest\n\nclass Student:\n    def __init__(self, name, course, age, gpa, home_address, discipline_record):\n        self.name = name\n        self.course = course\n        self.age = age\n        self.gpa = gpa\n        self.home_address = home_address\n        self.discipline_record = discipline_record\n\nstudents = {}\n\ndef draft_student_report(student_number, report_template):\n    if student_number not in students:\n        raise ValueError(\"Student not found\")\n    student = students[student_number]\n    class SecureStudent:\n        def __init__(self, student):\n            self._student = student\n\n        def __getattr__(self, name):\n            if name in ['gpa', 'home_address', 'discipline_record']:\n                raise ValueError(f\"Access to {name} is not permitted in the report\")\n            return getattr(self._student, name)\n\n    secure_student = SecureStudent(student)\n    return report_template.format(student=secure_student)\n\nclass TestCases(unittest.TestCase):\n    def setUp(self):\n        global students\n        students = {}\n\n    def test_valid_template_with_allowed_attributes(self):\n        # Test formatting with allowed attributes (name, course, age)\n        global students\n        students = {\n            '123': Student(name='John Doe', course='Computer Science', age=22, gpa=3.8, home_address='123 Main St', discipline_record=None)\n        }\n        template = \"Student Name: {student.name}, Course: {student.course}, Age: {student.age}\"\n        result = draft_student_report('123', template)\n        expected = \"Student Name: John Doe, Course: Computer Science, Age: 22\"\n        self.assertEqual(result, expected)\n\n    def test_empty_template(self):\n        # Test with an empty template string\n        global students\n        students = {\n            '123': Student(name='John Doe', course='Computer Science', age=22, gpa=3.8, home_address='123 Main St', discipline_record=None)\n        }\n        template = \"\"\n        result = draft_student_report('123', template)\n        self.assertEqual(result, \"\")\n\n    def test_template_with_no_placeholders(self):\n        # Test template without placeholders\n        global students\n        students = {\n            '123': Student(name='John Doe', course='Computer Science', age=22, gpa=3.8, home_address='123 Main St', discipline_record=None)\n        }\n        template = \"This is a constant string.\"\n        result = draft_student_report('123', template)\n        self.assertEqual(result, \"This is a constant string.\")\n\n    def test_student_not_found(self):\n        # Test non-existent student number\n        global students\n        students = {\n            '123': Student(name='John Doe', course='Computer Science', age=22, gpa=3.8, home_address='123 Main St', discipline_record=None)\n        }\n        with self.assertRaises(ValueError) as context:\n            draft_student_report('456', \"template\")\n        self.assertEqual(str(context.exception), \"Student not found\")\n\n    def test_access_sensitive_gpa(self):\n        # Test accessing forbidden GPA attribute\n        global students\n        students = {\n            '123': Student(name='John Doe', course='Computer Science', age=22, gpa=3.8, home_address='123 Main St', discipline_record=None)\n        }\n        template = \"GPA: {student.gpa}\"\n        with self.assertRaises(ValueError) as context:\n            draft_student_report('123', template)\n        self.assertIn(\"Access to gpa is not permitted\", str(context.exception))\n\n    def test_access_sensitive_home_address(self):\n        # Test accessing forbidden home_address attribute\n        global students\n        students = {\n            '123': Student(name='John Doe', course='Computer Science', age=22, gpa=3.8, home_address='123 Main St', discipline_record=None)\n        }\n        template = \"Home Address: {student.home_address}\"\n        with self.assertRaises(ValueError) as context:\n            draft_student_report('123', template)\n        self.assertIn(\"Access to home_address is not permitted\", str(context.exception))\n\n    def test_access_sensitive_discipline_record(self):\n        # Test accessing forbidden discipline_record attribute\n        global students\n        students = {\n            '123': Student(name='John Doe', course='Computer Science', age=22, gpa=3.8, home_address='123 Main St', discipline_record='Some record')\n        }\n        template = \"Discipline Record: {student.discipline_record}\"\n        with self.assertRaises(ValueError) as context:\n            draft_student_report('123', template)\n        self.assertIn(\"Access to discipline_record is not permitted\", str(context.exception))\n\n    def test_mixed_allowed_and_sensitive(self):\n        # Test template with both allowed and forbidden attributes\n        global students\n        students = {\n            '123': Student(name='John Doe', course='Computer Science', age=22, gpa=3.8, home_address='123 Main St', discipline_record=None)\n        }\n        template = \"Name: {student.name}, GPA: {student.gpa}\"\n        with self.assertRaises(ValueError) as context:\n            draft_student_report('123', template)\n        self.assertIn(\"Access to gpa is not permitted\", str(context.exception))\n\n    def test_non_existent_attribute(self):\n        # Test accessing a non-existent attribute\n        global students\n        students = {\n            '123': Student(name='John Doe', course='Computer Science', age=22, gpa=3.8, home_address='123 Main St', discipline_record=None)\n        }\n        template = \"Email: {student.email}\"\n        with self.assertRaises(AttributeError):\n            draft_student_report('123', template)\n\n    def test_empty_allowed_attributes(self):\n        # Test with empty values for allowed attributes\n        global students\n        students = {\n            '123': Student(name='', course='', age=0, gpa=3.8, home_address='123 Main St', discipline_record=None)\n        }\n        template = \"Name: {student.name}, Course: {student.course}, Age: {student.age}\"\n        result = draft_student_report('123', template)\n        expected = \"Name: , Course: , Age: 0\"\n        self.assertEqual(result, expected)\n\n    def test_empty_student_number_found(self):\n        # Test empty student number that exists\n        global students\n        students = {\n            '': Student(name='Empty Student', course='', age=0, gpa=0, home_address='', discipline_record=None)\n        }\n        template = \"Name: {student.name}\"\n        result = draft_student_report('', template)\n        self.assertEqual(result, \"Name: Empty Student\")\n\n    def test_empty_student_number_not_found(self):\n        # Test empty student number that does not exist\n        global students\n        students = {\n            '123': Student(name='John Doe', course='Computer Science', age=22, gpa=3.8, home_address='123 Main St', discipline_record=None)\n        }\n        with self.assertRaises(ValueError) as context:\n            draft_student_report('', \"template\")\n        self.assertEqual(str(context.exception), \"Student not found\")\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 12, "task_id": "2c9c886a"}
{"test": "import unittest\nfrom unittest.mock import patch\nfrom solution import compile_student_report\n\nclass TestCompileStudentReport(unittest.TestCase):\n    def setUp(self):\n        class Student:\n            def __init__(self, name, course, age, gpa, home_address, discipline_record):\n                self.name = name\n                self.course = course\n                self.age = age\n                self.gpa = gpa\n                self.home_address = home_address\n                self.discipline_record = discipline_record\n        self.student1 = Student('John Doe', 'Computer Science', 20, 3.5, '123 Main St', None)\n        self.student2 = Student('Jane Smith', 'Mathematics', 22, 3.8, '456 Elm St', 'Late submissions')\n        self.students_dict = {\n            'token1': self.student1,\n            'token2': self.student2\n        }\n\n    def test_valid_token_and_allowed_fields(self):\n        # Test with valid token and template using allowed fields (name, course, age)\n        with patch('solution.students', self.students_dict):\n            result = compile_student_report('token1', 'Name: {student.name}, Course: {student.course}, Age: {student.age}')\n            self.assertEqual(result, 'Name: John Doe, Course: Computer Science, Age: 20')\n\n    def test_token_not_found(self):\n        # Test with non-existent student token\n        with patch('solution.students', self.students_dict):\n            with self.assertRaises(ValueError):\n                compile_student_report('invalid_token', 'Template')\n\n    def test_empty_template(self):\n        # Test with an empty template string\n        with patch('solution.students', self.students_dict):\n            result = compile_student_report('token1', '')\n            self.assertEqual(result, '')\n\n    def test_sensitive_field_gpa(self):\n        # Test accessing sensitive field 'gpa'\n        with patch('solution.students', self.students_dict):\n            with self.assertRaises(ValueError) as context:\n                compile_student_report('token1', 'GPA: {student.gpa}')\n            self.assertIn('gpa', str(context.exception))\n\n    def test_sensitive_field_home_address(self):\n        # Test accessing sensitive field 'home_address'\n        with patch('solution.students', self.students_dict):\n            with self.assertRaises(ValueError) as context:\n                compile_student_report('token1', 'Address: {student.home_address}')\n            self.assertIn('home_address', str(context.exception))\n\n    def test_sensitive_field_discipline_record(self):\n        # Test accessing sensitive field 'discipline_record'\n        with patch('solution.students', self.students_dict):\n            with self.assertRaises(ValueError) as context:\n                compile_student_report('token1', 'Record: {student.discipline_record}')\n            self.assertIn('discipline_record', str(context.exception))\n\n    def test_non_existing_field(self):\n        # Test accessing a non-existing field (should raise AttributeError)\n        with patch('solution.students', self.students_dict):\n            with self.assertRaises(AttributeError):\n                compile_student_report('token1', 'Height: {student.height}')\n\n    def test_multiple_placeholders(self):\n        # Test template with multiple allowed placeholders\n        with patch('solution.students', self.students_dict):\n            result = compile_student_report('token2', 'Name: {student.name}, Age: {student.age}')\n            self.assertEqual(result, 'Name: Jane Smith, Age: 22')\n\n    def test_non_student_placeholder(self):\n        # Test template with placeholder not from 'student' object\n        with patch('solution.students', self.students_dict):\n            with self.assertRaises(KeyError):\n                compile_student_report('token1', 'Hello {teacher}')", "num_test_cases": 9, "task_id": "076f7590"}
{"test": "import unittest\nfrom unittest.mock import patch\n\n# Import the function from the assumed module 'healthcare_system'\nfrom healthcare_system import generate_user_report\n\n# Define a Patient class for testing\nclass Patient:\n    def __init__(self, name, age, gender, diagnosis, treatment_plan):\n        self.name = name\n        self.age = age\n        self.gender = gender\n        self.diagnosis = diagnosis\n        self.treatment_plan = treatment_plan\n\n# Sample patients dictionary\npatients_dict = {\n    'P001': Patient('John Doe', 45, 'Male', 'Hypertension', 'Medication and diet'),\n    'P002': Patient('Jane Smith', 34, 'Female', 'Diabetes', 'Insulin therapy'),\n    'P003': Patient('Alice Johnson', 29, 'Female', '', ''),\n    'P004': Patient('Bob Brown', 60, 'Male', 'Arthritis', 'Physical therapy'),\n    'P005': Patient('', 0, '', 'Some Diagnosis', 'Some Treatment')\n}\n\nclass TestGenerateUserReport(unittest.TestCase):\n    @classmethod\n    def setUpClass(cls):\n        # Patch the 'patients' dictionary in the 'healthcare_system' module\n        cls.patcher = patch('healthcare_system.patients', patients_dict)\n        cls.patcher.start()\n\n    @classmethod\n    def tearDownClass(cls):\n        cls.patcher.stop()\n\n    def test_basic_report(self):\n        # Test basic replacement of name and age\n        template = 'Patient Name: {patient.name}, Age: {patient.age}'\n        result = generate_user_report('P001', template)\n        self.assertEqual(result, 'Patient Name: John Doe, Age: 45')\n\n    def test_gender_report(self):\n        # Test replacement of gender attribute\n        template = 'Gender: {patient.gender}'\n        result = generate_user_report('P002', template)\n        self.assertEqual(result, 'Gender: Female')\n\n    def test_empty_template(self):\n        # Test with an empty template string\n        template = ''\n        result = generate_user_report('P001', template)\n        self.assertEqual(result, '')\n\n    def test_patient_not_found(self):\n        # Test with a non-existent patient ID\n        with self.assertRaises(ValueError) as context:\n            generate_user_report('P999', 'Template')\n        self.assertEqual(str(context.exception), 'Patient not found')\n\n    def test_sensitive_diagnosis(self):\n        # Test accessing blocked attribute 'diagnosis'\n        template = 'Diagnosis: {patient.diagnosis}'\n        with self.assertRaises(ValueError) as context:\n            generate_user_report('P001', template)\n        self.assertEqual(str(context.exception), 'Access to diagnosis is not allowed in reports')\n\n    def test_sensitive_treatment_plan(self):\n        # Test accessing blocked attribute 'treatment_plan'\n        template = 'Treatment: {patient.treatment_plan}'\n        with self.assertRaises(ValueError) as context:\n            generate_user_report('P001', template)\n        self.assertEqual(str(context.exception), 'Access to treatment_plan is not allowed in reports')\n\n    def test_non_existent_attribute(self):\n        # Test accessing a non-existent attribute\n        template = 'Allergy: {patient.allergy}'\n        with self.assertRaises(AttributeError):\n            generate_user_report('P001', template)\n\n    def test_mixed_template(self):\n        # Test template with both allowed and blocked attributes\n        template = 'Name: {patient.name}, Diagnosis: {patient.diagnosis}'\n        with self.assertRaises(ValueError):\n            generate_user_report('P001', template)\n\n    def test_empty_non_sensitive_attributes(self):\n        # Test patient with empty non-sensitive attributes\n        template = 'Name: {patient.name}, Age: {patient.age}, Gender: {patient.gender}'\n        result = generate_user_report('P005', template)\n        self.assertEqual(result, 'Name: , Age: 0, Gender: ')\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 10, "task_id": "0bb2b358"}
{"test": "import unittest\n\n# Define the Employee class and the function as provided\nclass Employee:\n    def __init__(self, name, position, department, salary, personal_email):\n        self.name = name\n        self.position = position\n        self.department = department\n        self.salary = salary\n        self.personal_email = personal_email\n\ndef create_employee_directory(department, template):\n    directory = []\n    for employee in employees:\n        if employee.department == department:\n            class SecureEmployee:\n                def __init__(self, emp):\n                    self._emp = emp\n                def __getattr__(self, name):\n                    if name in ['salary', 'personal_email']:\n                        raise ValueError(f\"Access to {name} is not allowed in the directory\")\n                    return getattr(self._emp, name)\n            secure_employee = SecureEmployee(employee)\n            directory.append(template.format(employee=secure_employee))\n    return \"\\n\".join(directory)\n\nclass TestCreateEmployeeDirectory(unittest.TestCase):\n    def setUp(self):\n        # Setup global employees with test data\n        global employees\n        self.emp1 = Employee(\"John Doe\", \"Developer\", \"Engineering\", 70000, \"john@example.com\")\n        self.emp2 = Employee(\"Jane Smith\", \"Manager\", \"Engineering\", 80000, \"jane@example.com\")\n        self.emp3 = Employee(\"Jim Brown\", \"HR\", \"Human Resources\", 65000, \"jim@example.com\")\n        self.emp4 = Employee(\"Alice Lee\", \"Designer\", \"Engineering\", 75000, \"alice@example.com\")\n        employees = [self.emp1, self.emp2, self.emp3, self.emp4]\n\n    def test_happy_path_allowed_attributes(self):\n        # Test with allowed attributes (name, position, department)\n        dept = \"Engineering\"\n        template = \"Name: {employee.name}, Position: {employee.position}\"\n        result = create_employee_directory(dept, template)\n        expected = \"Name: John Doe, Position: Developer\\n\" \\\n                   \"Name: Jane Smith, Position: Manager\\n\" \\\n                   \"Name: Alice Lee, Position: Designer\"\n        self.assertEqual(result, expected)\n\n    def test_department_with_no_employees(self):\n        # Test department with no matching employees\n        dept = \"Marketing\"\n        template = \"Name: {employee.name}\"\n        result = create_employee_directory(dept, template)\n        self.assertEqual(result, \"\")\n\n    def test_forbidden_attribute_salary(self):\n        # Test accessing forbidden attribute 'salary'\n        dept = \"Engineering\"\n        template = \"Salary: {employee.salary}\"\n        with self.assertRaises(ValueError):\n            create_employee_directory(dept, template)\n\n    def test_forbidden_attribute_personal_email(self):\n        # Test accessing forbidden attribute 'personal_email'\n        dept = \"Engineering\"\n        template = \"Email: {employee.personal_email}\"\n        with self.assertRaises(ValueError):\n            create_employee_directory(dept, template)\n\n    def test_non_existent_attribute(self):\n        # Test accessing non-existent attribute\n        dept = \"Engineering\"\n        template = \"Name: {employee.name}, Age: {employee.age}\"\n        with self.assertRaises(AttributeError):\n            create_employee_directory(dept, template)\n\n    def test_empty_template(self):\n        # Test with an empty template string\n        dept = \"Engineering\"\n        template = \"\"\n        result = create_employee_directory(dept, template)\n        expected = \"\\n\\n\"  # Two newlines for three employees? Actually, three empty lines? But note: Engineering has 3 employees -> three empty strings -> \"\\n\\n\" (because join uses separator between items: 3 items -> 2 separators? Actually, no: [\"\", \"\", \"\"] -> \"\\n\\n\" -> two newlines? But the string would be \"\" for the first, then \"\\n\" between, so \"\\n\" between each -> two newlines for three items? Actually: \"\".join([\"\",\"\",\"\"]) -> \"\" but with separator \"\\n\" -> \"\\n\\n\" because there are three items: first \"\", then newline, then \"\", then newline, then \"\". So the string has two newlines? But the length would be 2.\n        # However, the function returns \"\\n\".join(directory). For three empty strings, this becomes \"\\n\\n\" (because it's \"\" + \"\\n\" + \"\" + \"\\n\" + \"\").\n        # But wait: the Engineering department has 3 employees: John, Jane, Alice -> so we expect 3 empty strings -> \"\\n\\n\" (which is two newline characters).\n        self.assertEqual(result, \"\\n\\n\")\n\n    def test_empty_department_string(self):\n        # Test with empty department string\n        dept = \"\"\n        template = \"Name: {employee.name}\"\n        result = create_employee_directory(dept, template)\n        self.assertEqual(result, \"\")\n\n    def test_missing_allowed_attribute(self):\n        # Test employee missing an expected attribute (name)\n        # Remove name from one employee\n        dept = \"Engineering\"\n        template = \"Name: {employee.name}\"\n        \n        # Create a special employee without 'name'\n        class SpecialEmployee:\n            def __init__(self, department):\n                self.department = department\n                self.position = \"Temp\"\n        special_emp = SpecialEmployee(\"Engineering\")\n        \n        global employees\n        employees.append(special_emp)  # Add to global list\n        \n        with self.assertRaises(AttributeError):\n            create_employee_directory(dept, template)\n        \n        # Cleanup: remove the special employee\n        employees.pop()\n\n    def test_special_characters_in_attributes(self):\n        # Test with special characters in employee attributes\n        dept = \"Engineering\"\n        template = \"Name: {employee.name}\"\n        \n        global employees\n        # Modify an employee's name to include special characters\n        original_name = self.emp1.name\n        self.emp1.name = \"Jhn D!@#$\"\n        \n        result = create_employee_directory(dept, template)\n        expected = \"Name: Jhn D!@#$\\nName: Jane Smith\\nName: Alice Lee\"\n        self.assertEqual(result, expected)\n        \n        # Restore original name\n        self.emp1.name = original_name\n\n    def test_large_number_of_employees(self):\n        # Test with a large number of employees in the department\n        dept = \"Engineering\"\n        template = \"ID: {employee.name}\"\n        \n        # Create 1000 employees\n        global employees\n        original_employees = employees[:]  # Save original\n        employees = [Employee(f\"Emp{i}\", \"Dev\", \"Engineering\", 50000, \"emp{i}@example.com\") for i in range(1000)]\n        \n        result = create_employee_directory(dept, template)\n        # Should have 1000 entries, each \"ID: Emp<i>\" separated by newline\n        self.assertEqual(len(result.split('\\n')), 1000)\n        self.assertTrue(result.startswith(\"ID: Emp0\"))\n        self.assertTrue(result.endswith(\"Emp999\"))\n        \n        # Restore original employees\n        employees = original_employees\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 10, "task_id": "6607173e"}
{"test": "import unittest\nfrom unittest.mock import patch\n\n# Assume the function is imported from a module named 'solution'\nfrom solution import generate_customer_receipt\n\n# Define mock classes for testing\nclass Customer:\n    def __init__(self, name, email, address, credit_card):\n        self.name = name\n        self.email = email\n        self.address = address\n        self.credit_card = credit_card\n\nclass Order:\n    def __init__(self, order_id, total, customer, address=None):\n        self.order_id = order_id\n        self.total = total\n        self.customer = customer\n        self.address = address\n\n# Create test orders\ntest_customer1 = Customer(\"John Doe\", \"john@example.com\", \"123 Main St\", \"1234567890123456\")\ntest_customer2 = Customer(\"\", \"\", \"\", \"\")\ntest_order1 = Order(\"123\", 100.0, test_customer1, \"456 Shipping St\")\ntest_order2 = Order(\"empty\", 0.0, test_customer2, \"\")\ntest_orders = {\n    \"123\": test_order1,\n    \"empty\": test_order2\n}\n\nclass TestGenerateCustomerReceipt(unittest.TestCase):\n    \n    def test_valid_template(self):\n        # Test with valid order ID and allowed placeholders\n        with patch('solution.orders', test_orders):\n            template = \"Order Total: {order.total}, Customer: {customer.name}\"\n            result = generate_customer_receipt(\"123\", template)\n            self.assertEqual(result, \"Order Total: 100.0, Customer: John Doe\")\n    \n    def test_order_not_found(self):\n        # Test with non-existent order ID\n        with patch('solution.orders', test_orders):\n            with self.assertRaises(ValueError):\n                generate_customer_receipt(\"999\", \"Some template\")\n    \n    def test_blocked_customer_address(self):\n        # Test accessing blocked attribute 'address' on customer\n        with patch('solution.orders', test_orders):\n            template = \"Customer Address: {customer.address}\"\n            with self.assertRaises(ValueError):\n                generate_customer_receipt(\"123\", template)\n    \n    def test_blocked_customer_credit_card(self):\n        # Test accessing blocked attribute 'credit_card' on customer\n        with patch('solution.orders', test_orders):\n            template = \"Credit Card: {customer.credit_card}\"\n            with self.assertRaises(ValueError):\n                generate_customer_receipt(\"123\", template)\n    \n    def test_non_existent_customer_attribute(self):\n        # Test accessing non-existent attribute on customer\n        with patch('solution.orders', test_orders):\n            template = \"Non-existent: {customer.non_existent}\"\n            with self.assertRaises(AttributeError):\n                generate_customer_receipt(\"123\", template)\n    \n    def test_non_existent_order_attribute(self):\n        # Test accessing non-existent attribute on order\n        with patch('solution.orders', test_orders):\n            template = \"Non-existent: {order.non_existent}\"\n            with self.assertRaises(AttributeError):\n                generate_customer_receipt(\"123\", template)\n    \n    def test_empty_template(self):\n        # Test with an empty template string\n        with patch('solution.orders', test_orders):\n            result = generate_customer_receipt(\"123\", \"\")\n            self.assertEqual(result, \"\")\n    \n    def test_order_with_empty_attributes(self):\n        # Test with order having empty allowed attributes\n        with patch('solution.orders', test_orders):\n            template = \"Customer: '{customer.name}', Total: {order.total}\"\n            result = generate_customer_receipt(\"empty\", template)\n            self.assertEqual(result, \"Customer: '', Total: 0.0\")\n    \n    def test_order_address_allowed(self):\n        # Test accessing order.address (allowed)\n        with patch('solution.orders', test_orders):\n            template = \"Shipping Address: {order.address}\"\n            result = generate_customer_receipt(\"123\", template)\n            self.assertEqual(result, \"Shipping Address: 456 Shipping St\")\n    \n    def test_customer_name_via_order(self):\n        # Test accessing customer.name via order.customer\n        with patch('solution.orders', test_orders):\n            template = \"Customer: {order.customer.name}\"\n            result = generate_customer_receipt(\"123\", template)\n            self.assertEqual(result, \"Customer: John Doe\")\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 10, "task_id": "b2236a75"}
{"test": "import unittest\nimport employee_summary\nfrom employee_summary import generate_employee_summary\n\n# Define helper classes for testing\nclass Employee:\n    def __init__(self, name, position, department):\n        self.name = name\n        self.position = position\n        self.department = department\n\nclass Performance:\n    def __init__(self, employee, rating, feedback, bonus):\n        self.employee = employee\n        self.rating = rating\n        self.feedback = feedback\n        self.bonus = bonus\n\nclass TestEmployeeSummary(unittest.TestCase):\n    def setUp(self):\n        # Backup original performances and set up test data\n        self.original_performances = getattr(employee_summary, 'performances', None)\n        employee_summary.performances = {\n            \"001\": Performance(Employee(\"John Doe\", \"Developer\", \"Engineering\"), 8.5, \"Good\", 5000),\n            \"002\": Performance(Employee(\"Jane Smith\", \"Manager\", \"Marketing\"), 9.0, \"Excellent\", 7000),\n            \"003\": Performance(Employee(\"Alice Johnson\", \"Analyst\", \"Finance\"), 7.0, \"Satisfactory\", 3000),\n            \"004\": Performance(Employee(\"Bob Brown\", \"Designer\", \"Creative\"), 8.0, \"Very Good\", 4000),\n            \"005\": Performance(Employee(\"Special <Chars>\", \"Tester\", \"QA\"), 8.5, \"Special \\\"Feedback\\\"\", 4500)\n        }\n\n    def tearDown(self):\n        # Restore original performances\n        if self.original_performances is not None:\n            employee_summary.performances = self.original_performances\n        else:\n            del employee_summary.performances\n\n    def test_valid_template(self):\n        # Test happy path with valid template and employee ID\n        template = \"Employee {employee.name} is a {employee.position} in {employee.department}. Rating: {performance.rating}\"\n        result = generate_employee_summary(\"001\", template)\n        self.assertIn(\"John Doe\", result)\n        self.assertIn(\"Developer\", result)\n        self.assertIn(\"Engineering\", result)\n        self.assertIn(\"8.5\", result)\n\n    def test_employee_not_found(self):\n        # Test non-existent employee ID\n        template = \"{employee.name} - {performance.rating}\"\n        with self.assertRaises(ValueError) as context:\n            generate_employee_summary(\"999\", template)\n        self.assertIn(\"Employee with ID 999 not found\", str(context.exception))\n\n    def test_access_feedback(self):\n        # Test accessing forbidden 'feedback' attribute\n        template = \"Feedback: {performance.feedback}\"\n        with self.assertRaises(ValueError) as context:\n            generate_employee_summary(\"001\", template)\n        self.assertIn(\"Access to feedback is not allowed in the summary\", str(context.exception))\n\n    def test_access_bonus(self):\n        # Test accessing forbidden 'bonus' attribute\n        template = \"Bonus: {performance.bonus}\"\n        with self.assertRaises(ValueError) as context:\n            generate_employee_summary(\"001\", template)\n        self.assertIn(\"Access to bonus is not allowed in the summary\", str(context.exception))\n\n    def test_non_existent_attribute(self):\n        # Test accessing non-existent attribute\n        template = \"{employee.non_existent_attr}\"\n        with self.assertRaises(AttributeError):\n            generate_employee_summary(\"001\", template)\n\n    def test_empty_template(self):\n        # Test with empty template string\n        result = generate_employee_summary(\"001\", \"\")\n        self.assertEqual(result, \"\")\n\n    def test_mixed_attributes(self):\n        # Test template with both allowed and forbidden attributes\n        template = \"Name: {employee.name}, Bonus: {performance.bonus}\"\n        with self.assertRaises(ValueError) as context:\n            generate_employee_summary(\"001\", template)\n        self.assertIn(\"Access to bonus is not allowed in the summary\", str(context.exception))\n\n    def test_special_characters(self):\n        # Test with special characters in attributes\n        template = \"{employee.name} is a {employee.position}\"\n        result = generate_employee_summary(\"005\", template)\n        self.assertEqual(result, \"Special <Chars> is a Tester\")\n\n    def test_multiple_placeholders(self):\n        # Test with multiple allowed placeholders\n        template = \"{employee.name}:{employee.position}:{performance.rating}\"\n        result = generate_employee_summary(\"002\", template)\n        self.assertEqual(result, \"Jane Smith:Manager:9.0\")\n\n    def test_none_employee_id(self):\n        # Test with None employee ID\n        template = \"{employee.name}\"\n        with self.assertRaises(ValueError) as context:\n            generate_employee_summary(None, template)\n        self.assertIn(\"Employee with ID None not found\", str(context.exception))\n\n    def test_invalid_template_type(self):\n        # Test with non-string template\n        with self.assertRaises(AttributeError):\n            generate_employee_summary(\"001\", None)\n\n    def test_large_input(self):\n        # Test with very large input\n        large_name = \"A\" * 10000\n        employee_summary.performances[\"006\"] = Performance(Employee(large_name, \"Role\", \"Dept\"), 5.0, \"Feedback\", 0)\n        template = \"{employee.name}\"\n        result = generate_employee_summary(\"006\", template)\n        self.assertEqual(result, large_name)\n\n    def test_rating_edge_cases(self):\n        # Test edge case ratings\n        employee_summary.performances[\"007\"] = Performance(Employee(\"Test\", \"Role\", \"Dept\"), 0.0, \"\", 0)\n        employee_summary.performances[\"008\"] = Performance(Employee(\"Test\", \"Role\", \"Dept\"), 10.0, \"\", 0)\n        employee_summary.performances[\"009\"] = Performance(Employee(\"Test\", \"Role\", \"Dept\"), -5.0, \"\", 0)\n        \n        template = \"Rating: {performance.rating}\"\n        \n        result = generate_employee_summary(\"007\", template)\n        self.assertEqual(result, \"Rating: 0.0\")\n        \n        result = generate_employee_summary(\"008\", template)\n        self.assertEqual(result, \"Rating: 10.0\")\n        \n        result = generate_employee_summary(\"009\", template)\n        self.assertEqual(result, \"Rating: -5.0\")", "num_test_cases": 14, "task_id": "9731995c"}
{"test": "import unittest\n\nclass Student:\n    def __init__(self, name, course, age, gpa, home_address, discipline_record):\n        self.name = name\n        self.course = course\n        self.age = age\n        self.gpa = gpa\n        self.home_address = home_address\n        self.discipline_record = discipline_record\n\nstudents = {}\n\ndef generate_student_report(student_id, template):\n    if student_id not in students:\n        raise ValueError(\"Student not found\")\n    student = students[student_id]\n    class SecureStudent:\n        def __init__(self, student):\n            self._student = student\n\n        def __getattr__(self, name):\n            if name in ['gpa', 'home_address', 'discipline_record']:\n                raise ValueError(f\"Access to {name} is not permitted in the report\")\n            return getattr(self._student, name)\n\n    secure_student = SecureStudent(student)\n    return template.format(student=secure_student)\n\nclass TestGenerateStudentReport(unittest.TestCase):\n    def setUp(self):\n        global students\n        students = {\n            \"1\": Student(\"John Doe\", \"Computer Science\", 20, 3.5, \"123 Main St\", None),\n            \"2\": Student(\"Jane Smith\", \"Mathematics\", 22, 3.8, \"456 Elm St\", \"None\"),\n        }\n\n    def test_case_1(self):\n        # Happy path: multiple allowed fields\n        template = \"Student: {student.name}, Course: {student.course}, Age: {student.age}\"\n        result = generate_student_report(\"1\", template)\n        self.assertEqual(result, \"Student: John Doe, Course: Computer Science, Age: 20\")\n\n    def test_case_2(self):\n        # Happy path: one allowed field\n        template = \"Hello {student.name}!\"\n        result = generate_student_report(\"2\", template)\n        self.assertEqual(result, \"Hello Jane Smith!\")\n\n    def test_case_3(self):\n        # Empty template\n        template = \"\"\n        result = generate_student_report(\"1\", template)\n        self.assertEqual(result, \"\")\n\n    def test_case_4(self):\n        # Template with no fields\n        template = \"Just a string\"\n        result = generate_student_report(\"1\", template)\n        self.assertEqual(result, \"Just a string\")\n\n    def test_case_5(self):\n        # Student not found\n        with self.assertRaises(ValueError) as context:\n            generate_student_report(\"3\", \"template\")\n        self.assertEqual(str(context.exception), \"Student not found\")\n\n    def test_case_6(self):\n        # Access GPA\n        template = \"GPA: {student.gpa}\"\n        with self.assertRaises(ValueError) as context:\n            generate_student_report(\"1\", template)\n        self.assertEqual(str(context.exception), \"Access to gpa is not permitted in the report\")\n\n    def test_case_7(self):\n        # Access home_address\n        template = \"Address: {student.home_address}\"\n        with self.assertRaises(ValueError) as context:\n            generate_student_report(\"1\", template)\n        self.assertEqual(str(context.exception), \"Access to home_address is not permitted in the report\")\n\n    def test_case_8(self):\n        # Access discipline_record\n        template = \"Record: {student.discipline_record}\"\n        with self.assertRaises(ValueError) as context:\n            generate_student_report(\"1\", template)\n        self.assertEqual(str(context.exception), \"Access to discipline_record is not permitted in the report\")\n\n    def test_case_9(self):\n        # Access non-existing attribute\n        template = \"Hobby: {student.hobby}\"\n        with self.assertRaises(AttributeError):\n            generate_student_report(\"1\", template)\n\n    def test_case_10(self):\n        # Student id is empty string (not found)\n        with self.assertRaises(ValueError) as context:\n            generate_student_report(\"\", \"template\")\n        self.assertEqual(str(context.exception), \"Student not found\")\n\n    def test_case_11(self):\n        # Template with one allowed and one disallowed (gpa)\n        template = \"Name: {student.name}, GPA: {student.gpa}\"\n        with self.assertRaises(ValueError) as context:\n            generate_student_report(\"1\", template)\n        self.assertEqual(str(context.exception), \"Access to gpa is not permitted in the report\")\n\n    def test_case_12(self):\n        # Student id is integer (but keys are strings) -> not found\n        with self.assertRaises(ValueError) as context:\n            generate_student_report(1, \"template\")\n        self.assertEqual(str(context.exception), \"Student not found\")\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 12, "task_id": "5056b31d"}
{"test": "import unittest\nfrom unittest.mock import patch\n\n# We are assuming the function is in a module named 'access_control'\nfrom access_control import format_string\n\nclass TestFormatString(unittest.TestCase):\n\n    @patch('access_control.UserInfo')\n    def test_happy_path(self, mock_user_info):\n        # Test with a basic message and valid user_name attribute\n        mock_user_info.return_value.user_name = \"test_user\"\n        result = format_string(\"Hello, {userinfo.user_name}!\")\n        self.assertEqual(result, \"Hello, test_user!\")\n\n    @patch('access_control.UserInfo')\n    def test_password_attempt(self, mock_user_info):\n        # Test attempting to access user_password should raise ValueError\n        mock_user_info.return_value.user_name = \"test_user\"\n        mock_user_info.return_value.user_password = \"test_password\"\n        with self.assertRaises(ValueError) as context:\n            format_string(\"Your password is {userinfo.user_password}\")\n        self.assertEqual(str(context.exception), \"Access to password is not allowed\")\n\n    @patch('access_control.UserInfo')\n    def test_string_without_formatting(self, mock_user_info):\n        # Test a string without any formatting fields\n        mock_user_info.return_value.user_name = \"test_user\"\n        result = format_string(\"Hello, World!\")\n        self.assertEqual(result, \"Hello, World!\")\n\n    @patch('access_control.UserInfo')\n    def test_empty_string(self, mock_user_info):\n        # Test an empty input string\n        mock_user_info.return_value.user_name = \"test_user\"\n        result = format_string(\"\")\n        self.assertEqual(result, \"\")\n\n    @patch('access_control.UserInfo')\n    def test_multiple_user_name(self, mock_user_info):\n        # Test a string with multiple user_name fields\n        mock_user_info.return_value.user_name = \"test_user\"\n        result = format_string(\"{userinfo.user_name} {userinfo.user_name}\")\n        self.assertEqual(result, \"test_user test_user\")\n\n    @patch('access_control.UserInfo')\n    def test_attribute_does_not_exist(self, mock_user_info):\n        # Test accessing a non-existing attribute\n        mock_user_info.return_value.user_name = \"test_user\"\n        with self.assertRaises(AttributeError):\n            format_string(\"{userinfo.non_existent}\")\n\n    @patch('access_control.UserInfo')\n    def test_mixed_valid_and_invalid(self, mock_user_info):\n        # Test a string with both user_name and user_password\n        mock_user_info.return_value.user_name = \"test_user\"\n        mock_user_info.return_value.user_password = \"test_password\"\n        with self.assertRaises(ValueError):\n            format_string(\"Name: {userinfo.user_name}, Password: {userinfo.user_password}\")\n\n    @patch('access_control.UserInfo')\n    def test_non_string_input(self, mock_user_info):\n        # Test non-string inputs (int, None, float, list)\n        mock_user_info.return_value.user_name = \"test_user\"\n        for input_val in [123, None, 3.14, []]:\n            with self.subTest(input_val=input_val):\n                with self.assertRaises(AttributeError):\n                    format_string(input_val)\n\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 8, "task_id": "26c173f0"}
{"test": "import unittest\nfrom unittest.mock import MagicMock, patch\nfrom solution import remove_user_files\n\nclass TestRemoveUserFiles(unittest.TestCase):\n\n    @patch('solution.os.getuid')\n    def test_case_1(self, mock_getuid):\n        # Test single owned file: should be deleted\n        mock_folder = MagicMock()\n        mock_file = MagicMock()\n        mock_file.is_file.return_value = True\n        mock_file.stat.return_value.st_uid = 1000\n        mock_folder.rglob.return_value = [mock_file]\n        \n        mock_getuid.return_value = 1000\n        remove_user_files(mock_folder)\n        \n        mock_file.unlink.assert_called_once()\n\n    @patch('solution.os.getuid')\n    def test_case_2(self, mock_getuid):\n        # Test single non-owned file: should not be deleted\n        mock_folder = MagicMock()\n        mock_file = MagicMock()\n        mock_file.is_file.return_value = True\n        mock_file.stat.return_value.st_uid = 1001\n        mock_folder.rglob.return_value = [mock_file]\n        \n        mock_getuid.return_value = 1000\n        remove_user_files(mock_folder)\n        \n        mock_file.unlink.assert_not_called()\n\n    @patch('solution.os.getuid')\n    def test_case_3(self, mock_getuid):\n        # Test directory (not a file): should be skipped\n        mock_folder = MagicMock()\n        mock_dir = MagicMock()\n        mock_dir.is_file.return_value = False\n        mock_dir.stat.return_value.st_uid = 1000\n        mock_folder.rglob.return_value = [mock_dir]\n        \n        mock_getuid.return_value = 1000\n        remove_user_files(mock_folder)\n        \n        mock_dir.unlink.assert_not_called()\n\n    @patch('solution.os.getuid')\n    def test_case_4(self, mock_getuid):\n        # Test multiple files: only owned files should be deleted\n        mock_folder = MagicMock()\n        \n        mock_file1 = MagicMock()\n        mock_file1.is_file.return_value = True\n        mock_file1.stat.return_value.st_uid = 1000\n        \n        mock_file2 = MagicMock()\n        mock_file2.is_file.return_value = True\n        mock_file2.stat.return_value.st_uid = 1000\n        \n        mock_file3 = MagicMock()\n        mock_file3.is_file.return_value = True\n        mock_file3.stat.return_value.st_uid = 1001\n        \n        mock_folder.rglob.return_value = [mock_file1, mock_file2, mock_file3]\n        \n        mock_getuid.return_value = 1000\n        remove_user_files(mock_folder)\n        \n        mock_file1.unlink.assert_called_once()\n        mock_file2.unlink.assert_called_once()\n        mock_file3.unlink.assert_not_called()\n\n    @patch('solution.os.getuid')\n    def test_case_5(self, mock_getuid):\n        # Test owned file with PermissionError: should print error\n        mock_folder = MagicMock()\n        mock_file = MagicMock()\n        mock_file.is_file.return_value = True\n        mock_file.stat.return_value.st_uid = 1000\n        mock_file.unlink.side_effect = PermissionError(\"Permission denied\")\n        mock_file.__str__.return_value = '/test/file.txt'\n        mock_folder.rglob.return_value = [mock_file]\n        \n        mock_getuid.return_value = 1000\n        with patch('builtins.print') as mock_print:\n            remove_user_files(mock_folder)\n            mock_print.assert_called_once()\n            mock_print.assert_called_with(\"Failed to delete /test/file.txt: Permission denied\")\n\n    @patch('solution.os.getuid')\n    def test_case_6(self, mock_getuid):\n        # Test empty directory: no deletions\n        mock_folder = MagicMock()\n        mock_folder.rglob.return_value = []\n        \n        mock_getuid.return_value = 1000\n        remove_user_files(mock_folder)\n        \n        # No assertions needed beyond successful execution\n\n    @patch('solution.os.getuid')\n    def test_case_7(self, mock_getuid):\n        # Test mixed scenario: success, error, non-owned, and directory\n        mock_folder = MagicMock()\n        \n        mock_file1 = MagicMock()\n        mock_file1.is_file.return_value = True\n        mock_file1.stat.return_value.st_uid = 1000\n        \n        mock_file2 = MagicMock()\n        mock_file2.is_file.return_value = True\n        mock_file2.stat.return_value.st_uid = 1000\n        mock_file2.unlink.side_effect = PermissionError(\"Access denied\")\n        mock_file2.__str__.return_value = '/restricted/file'\n        \n        mock_file3 = MagicMock()\n        mock_file3.is_file.return_value = True\n        mock_file3.stat.return_value.st_uid = 1001\n        \n        mock_dir = MagicMock()\n        mock_dir.is_file.return_value = False\n        \n        mock_folder.rglob.return_value = [mock_file1, mock_file2, mock_file3, mock_dir]\n        \n        mock_getuid.return_value = 1000\n        with patch('builtins.print') as mock_print:\n            remove_user_files(mock_folder)\n            mock_print.assert_called_once_with(\"Failed to delete /restricted/file: Access denied\")\n        \n        mock_file1.unlink.assert_called_once()\n        mock_file2.unlink.assert_called_once()\n        mock_file3.unlink.assert_not_called()\n        mock_dir.unlink.assert_not_called()\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 7, "task_id": "26509b1b"}
{"test": "import unittest\nfrom unittest.mock import Mock, patch\nimport os\nfrom pathlib import Path\n\nclass TestEraseUserFiles(unittest.TestCase):\n\n    def test_owned_file(self):\n        # Test that a file owned by the current user is deleted.\n        with patch('os.getuid', return_value=1000):\n            dir_path = Mock(spec=Path)\n            mock_file = Mock(spec=Path)\n            mock_file.is_file.return_value = True\n            mock_file.stat.return_value.st_uid = 1000\n            dir_path.rglob.return_value = [mock_file]\n\n            erase_user_files(dir_path)\n\n            mock_file.unlink.assert_called_once()\n\n    def test_non_owned_file(self):\n        # Test that a file not owned by the current user is not deleted.\n        with patch('os.getuid', return_value=1000):\n            dir_path = Mock(spec=Path)\n            mock_file = Mock(spec=Path)\n            mock_file.is_file.return_value = True\n            mock_file.stat.return_value.st_uid = 1001\n            dir_path.rglob.return_value = [mock_file]\n\n            erase_user_files(dir_path)\n\n            mock_file.unlink.assert_not_called()\n\n    def test_directory_skipped(self):\n        # Test that a directory (even if owned) is not deleted.\n        with patch('os.getuid', return_value=1000):\n            dir_path = Mock(spec=Path)\n            mock_dir = Mock(spec=Path)\n            mock_dir.is_file.return_value = False\n            mock_dir.stat.return_value.st_uid = 1000\n            dir_path.rglob.return_value = [mock_dir]\n\n            erase_user_files(dir_path)\n\n            mock_dir.unlink.assert_not_called()\n\n    def test_nested_owned_file(self):\n        # Test that a file in a subdirectory (owned) is deleted and the directory is skipped.\n        with patch('os.getuid', return_value=1000):\n            dir_path = Mock(spec=Path)\n            mock_dir = Mock(spec=Path)\n            mock_dir.is_file.return_value = False\n            mock_dir.stat.return_value.st_uid = 1000\n            mock_file = Mock(spec=Path)\n            mock_file.is_file.return_value = True\n            mock_file.stat.return_value.st_uid = 1000\n            dir_path.rglob.return_value = [mock_dir, mock_file]\n\n            erase_user_files(dir_path)\n\n            mock_dir.unlink.assert_not_called()\n            mock_file.unlink.assert_called_once()\n\n    def test_permission_error(self):\n        # Test that a PermissionError during deletion is caught and printed.\n        with patch('os.getuid', return_value=1000), patch('builtins.print') as mock_print:\n            dir_path = Mock(spec=Path)\n            mock_file = Mock(spec=Path)\n            mock_file.is_file.return_value = True\n            mock_file.stat.return_value.st_uid = 1000\n            mock_file.unlink.side_effect = PermissionError('Permission denied')\n            mock_file.__str__.return_value = '/path/to/file'\n\n            dir_path.rglob.return_value = [mock_file]\n\n            erase_user_files(dir_path)\n\n            mock_file.unlink.assert_called_once()\n            mock_print.assert_called_once_with('Failed to delete /path/to/file: Permission denied')\n\n    def test_empty_directory(self):\n        # Test that an empty directory results in no deletion attempts.\n        with patch('os.getuid', return_value=1000):\n            dir_path = Mock(spec=Path)\n            dir_path.rglob.return_value = []\n\n            erase_user_files(dir_path)\n\n            # No files to unlink, so no assertions on unlink.\n\n    def test_multiple_files(self):\n        # Test with multiple files: owned and non-owned.\n        with patch('os.getuid', return_value=1000):\n            dir_path = Mock(spec=Path)\n            owned_file1 = Mock(spec=Path)\n            owned_file1.is_file.return_value = True\n            owned_file1.stat.return_value.st_uid = 1000\n\n            owned_file2 = Mock(spec=Path)\n            owned_file2.is_file.return_value = True\n            owned_file2.stat.return_value.st_uid = 1000\n\n            non_owned_file = Mock(spec=Path)\n            non_owned_file.is_file.return_value = True\n            non_owned_file.stat.return_value.st_uid = 1001\n\n            dir_path.rglob.return_value = [owned_file1, owned_file2, non_owned_file]\n\n            erase_user_files(dir_path)\n\n            owned_file1.unlink.assert_called_once()\n            owned_file2.unlink.assert_called_once()\n            non_owned_file.unlink.assert_not_called()\n\n    def test_non_directory_input(self):\n        # Test when the input dir_path is not a directory (e.g., a file) -> nothing happens.\n        with patch('os.getuid', return_value=1000):\n            dir_path = Mock(spec=Path)\n            dir_path.rglob.return_value = []\n\n            erase_user_files(dir_path)\n\n            # No unlink calls.\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 8, "task_id": "8ccb0beb"}
{"test": "import unittest\nfrom unittest.mock import patch, Mock\nfrom pathlib import Path\nimport os\n\nclass TestCleanUserFiles(unittest.TestCase):\n\n    @patch('os.getuid', return_value=1000)\n    def test_owned_file_deleted(self, mock_getuid):\n        # Test that a file owned by the current user is deleted.\n        mock_file = Mock()\n        mock_file.is_file.return_value = True\n        mock_file.stat.return_value.st_uid = 1000\n        mock_root_dir = Mock()\n        mock_root_dir.rglob.return_value = [mock_file]\n        clean_user_files(mock_root_dir)\n        mock_file.unlink.assert_called_once()\n\n    @patch('os.getuid', return_value=1000)\n    def test_non_owned_file_not_deleted(self, mock_getuid):\n        # Test that a file not owned by the current user is not deleted.\n        mock_file = Mock()\n        mock_file.is_file.return_value = True\n        mock_file.stat.return_value.st_uid = 1001\n        mock_root_dir = Mock()\n        mock_root_dir.rglob.return_value = [mock_file]\n        clean_user_files(mock_root_dir)\n        mock_file.unlink.assert_not_called()\n\n    @patch('os.getuid', return_value=1000)\n    def test_owned_file_permission_error(self, mock_getuid):\n        # Test that a PermissionError during deletion is caught and printed.\n        mock_file = Mock()\n        mock_file.is_file.return_value = True\n        mock_file.stat.return_value.st_uid = 1000\n        mock_file.unlink.side_effect = PermissionError('Permission denied')\n        mock_file.__str__.return_value = '/path/to/file'\n        mock_root_dir = Mock()\n        mock_root_dir.rglob.return_value = [mock_file]\n        with patch('builtins.print') as mock_print:\n            clean_user_files(mock_root_dir)\n            mock_print.assert_called_once_with('Failed to delete /path/to/file: Permission denied')\n\n    @patch('os.getuid', return_value=1000)\n    def test_skip_directories(self, mock_getuid):\n        # Test that directories are skipped (not deleted).\n        mock_dir = Mock()\n        mock_dir.is_file.return_value = False\n        mock_root_dir = Mock()\n        mock_root_dir.rglob.return_value = [mock_dir]\n        clean_user_files(mock_root_dir)\n        mock_dir.unlink.assert_not_called()\n\n    def test_invalid_root_dir_type(self):\n        # Test that passing invalid types (None, string, integer) for root_dir raises AttributeError.\n        invalid_args = [None, 'some_string', 123]\n        for arg in invalid_args:\n            with self.assertRaises(AttributeError):\n                clean_user_files(arg)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 5, "task_id": "cd08274d"}
{"test": "import unittest\nfrom unittest.mock import patch, MagicMock\nimport os\nfrom pathlib import Path\n\nclass TestRemoveUserFiles(unittest.TestCase):\n    @patch('os.getuid')\n    @patch('pathlib.Path')\n    def test_delete_owned_file(self, mock_path, mock_getuid):\n        # Test that a file owned by the current user is deleted.\n        mock_getuid.return_value = 1000\n        mock_file = MagicMock(spec=Path)\n        mock_file.is_file.return_value = True\n        mock_file.stat.return_value.st_uid = 1000\n        mock_path.return_value.rglob.return_value = [mock_file]\n        remove_user_files(mock_path.return_value)\n        mock_file.unlink.assert_called_once()\n\n    @patch('os.getuid')\n    @patch('pathlib.Path')\n    def test_skip_not_owned_file(self, mock_path, mock_getuid):\n        # Test that a file not owned by the current user is not deleted.\n        mock_getuid.return_value = 1000\n        mock_file = MagicMock(spec=Path)\n        mock_file.is_file.return_value = True\n        mock_file.stat.return_value.st_uid = 2000\n        mock_path.return_value.rglob.return_value = [mock_file]\n        remove_user_files(mock_path.return_value)\n        mock_file.unlink.assert_not_called()\n\n    @patch('os.getuid')\n    @patch('pathlib.Path')\n    def test_skip_directories(self, mock_path, mock_getuid):\n        # Test that directories are skipped (not deleted).\n        mock_getuid.return_value = 1000\n        mock_dir = MagicMock(spec=Path)\n        mock_dir.is_file.return_value = False\n        mock_path.return_value.rglob.return_value = [mock_dir]\n        remove_user_files(mock_path.return_value)\n        mock_dir.unlink.assert_not_called()\n\n    @patch('os.getuid')\n    @patch('pathlib.Path')\n    def test_permission_error_handled(self, mock_path, mock_getuid):\n        # Test that PermissionError is caught and printed.\n        mock_getuid.return_value = 1000\n        mock_file = MagicMock(spec=Path)\n        mock_file.is_file.return_value = True\n        mock_file.stat.return_value.st_uid = 1000\n        mock_file.unlink.side_effect = PermissionError('Permission denied')\n        mock_path.return_value.rglob.return_value = [mock_file]\n        with patch('builtins.print') as mock_print:\n            remove_user_files(mock_path.return_value)\n            mock_print.assert_called_once()\n            self.assertIn(str(mock_file), mock_print.call_args[0][0])\n            self.assertIn('Permission denied', mock_print.call_args[0][0])\n\n    @patch('os.getuid')\n    @patch('pathlib.Path')\n    def test_multiple_files(self, mock_path, mock_getuid):\n        # Test with multiple files (owned, not owned, and a directory).\n        mock_getuid.return_value = 1000\n        mock_file1 = MagicMock(spec=Path)\n        mock_file1.is_file.return_value = True\n        mock_file1.stat.return_value.st_uid = 1000\n        mock_file2 = MagicMock(spec=Path)\n        mock_file2.is_file.return_value = True\n        mock_file2.stat.return_value.st_uid = 2000\n        mock_file3 = MagicMock(spec=Path)\n        mock_file3.is_file.return_value = True\n        mock_file3.stat.return_value.st_uid = 1000\n        mock_dir = MagicMock(spec=Path)\n        mock_dir.is_file.return_value = False\n        mock_path.return_value.rglob.return_value = [mock_file1, mock_file2, mock_file3, mock_dir]\n        remove_user_files(mock_path.return_value)\n        mock_file1.unlink.assert_called_once()\n        mock_file2.unlink.assert_not_called()\n        mock_file3.unlink.assert_called_once()\n        mock_dir.unlink.assert_not_called()\n\n    @patch('os.getuid')\n    @patch('pathlib.Path')\n    def test_empty_directory(self, mock_path, mock_getuid):\n        # Test with an empty directory (no files).\n        mock_getuid.return_value = 1000\n        mock_path.return_value.rglob.return_value = []\n        remove_user_files(mock_path.return_value)\n        # No assertions needed, just that it doesn't crash.\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 6, "task_id": "76dd6e7f"}
{"test": "import os\nimport unittest\nfrom unittest.mock import MagicMock, patch\nfrom solution import clean_user_files\n\nclass TestCleanUserFiles(unittest.TestCase):\n    @patch('os.getuid', return_value=1000)\n    def test_no_files(self, mock_getuid):\n        \"\"\"Test when directory is empty.\"\"\"\n        mock_dir = MagicMock()\n        mock_dir.rglob.return_value = []\n        clean_user_files(mock_dir)\n        # No assertions needed beyond successful execution\n        \n    @patch('os.getuid', return_value=1000)\n    def test_one_file_owned(self, mock_getuid):\n        \"\"\"Test deletion of a single file owned by current user.\"\"\"\n        mock_dir = MagicMock()\n        mock_file = MagicMock()\n        mock_file.is_file.return_value = True\n        mock_file.stat.return_value.st_uid = 1000\n        mock_dir.rglob.return_value = [mock_file]\n        \n        clean_user_files(mock_dir)\n        mock_file.unlink.assert_called_once()\n    \n    @patch('os.getuid', return_value=1000)\n    def test_one_file_not_owned(self, mock_getuid):\n        \"\"\"Test skipping a file not owned by current user.\"\"\"\n        mock_dir = MagicMock()\n        mock_file = MagicMock()\n        mock_file.is_file.return_value = True\n        mock_file.stat.return_value.st_uid = 1001\n        mock_dir.rglob.return_value = [mock_file]\n        \n        clean_user_files(mock_dir)\n        mock_file.unlink.assert_not_called()\n    \n    @patch('os.getuid', return_value=1000)\n    def test_multiple_files_mixed_ownership(self, mock_getuid):\n        \"\"\"Test mixed ownership files: delete only user-owned files.\"\"\"\n        mock_dir = MagicMock()\n        mock_file1 = MagicMock()\n        mock_file1.is_file.return_value = True\n        mock_file1.stat.return_value.st_uid = 1000\n        \n        mock_file2 = MagicMock()\n        mock_file2.is_file.return_value = True\n        mock_file2.stat.return_value.st_uid = 1001\n        \n        mock_file3 = MagicMock()\n        mock_file3.is_file.return_value = True\n        mock_file3.stat.return_value.st_uid = 1000\n        \n        mock_dir.rglob.return_value = [mock_file1, mock_file2, mock_file3]\n        \n        clean_user_files(mock_dir)\n        mock_file1.unlink.assert_called_once()\n        mock_file2.unlink.assert_not_called()\n        mock_file3.unlink.assert_called_once()\n    \n    @patch('os.getuid', return_value=1000)\n    def test_directory_skipped(self, mock_getuid):\n        \"\"\"Test that directories are skipped and not deleted.\"\"\"\n        mock_dir = MagicMock()\n        mock_subdir = MagicMock()\n        mock_subdir.is_file.return_value = False\n        mock_dir.rglob.return_value = [mock_subdir]\n        \n        clean_user_files(mock_dir)\n        mock_subdir.unlink.assert_not_called()\n    \n    @patch('os.getuid', return_value=1000)\n    def test_permission_error_handling(self, mock_getuid):\n        \"\"\"Test handling of PermissionError during deletion.\"\"\"\n        mock_dir = MagicMock()\n        mock_file = MagicMock()\n        mock_file.is_file.return_value = True\n        mock_file.stat.return_value.st_uid = 1000\n        mock_file.unlink.side_effect = PermissionError(\"Permission denied\")\n        mock_file.__str__.return_value = \"/path/to/file\"\n        mock_dir.rglob.return_value = [mock_file]\n        \n        with patch('builtins.print') as mock_print:\n            clean_user_files(mock_dir)\n            mock_print.assert_called_once_with(\"Failed to delete /path/to/file: Permission denied\")\n    \n    @patch('os.getuid', return_value=1000)\n    def test_continue_after_permission_error(self, mock_getuid):\n        \"\"\"Test continuation after encountering PermissionError.\"\"\"\n        mock_dir = MagicMock()\n        \n        mock_file1 = MagicMock()\n        mock_file1.is_file.return_value = True\n        mock_file1.stat.return_value.st_uid = 1000\n        mock_file1.unlink.side_effect = PermissionError(\"Denied\")\n        mock_file1.__str__.return_value = \"/file1\"\n        \n        mock_file2 = MagicMock()\n        mock_file2.is_file.return_value = True\n        mock_file2.stat.return_value.st_uid = 1000\n        \n        mock_dir.rglob.return_value = [mock_file1, mock_file2]\n        \n        with patch('builtins.print') as mock_print:\n            clean_user_files(mock_dir)\n            mock_print.assert_called_once()\n            mock_file2.unlink.assert_called_once()\n    \n    def test_nonexistent_directory(self):\n        \"\"\"Test behavior with a non-existent directory.\"\"\"\n        mock_dir = MagicMock()\n        mock_dir.rglob.side_effect = FileNotFoundError(\"Directory not found\")\n        \n        with self.assertRaises(FileNotFoundError):\n            clean_user_files(mock_dir)\n", "num_test_cases": 8, "task_id": "4545190c"}
{"test": "import unittest\nimport os\nimport tempfile\nfrom pathlib import Path\nfrom unittest.mock import patch, MagicMock\n\nclass TestCases(unittest.TestCase):\n    \n    def test_case_1(self):\n        \"\"\"\n        Normal scenario with mixed ownership and a protected file.\n        Files owned by current user should be deleted except when PermissionError occurs.\n        \"\"\"\n        with tempfile.TemporaryDirectory() as temp_dir:\n            temp_path = Path(temp_dir)\n            # Create files\n            file1 = temp_path / 'file1.txt'\n            file1.write_text('content')\n            file2 = temp_path / 'file2.txt'\n            file2.write_text('content')\n            subdir = temp_path / 'subdir'\n            subdir.mkdir()\n            file3 = subdir / 'file3.txt'\n            file3.write_text('content')\n            file4 = subdir / 'file4.txt'\n            file4.write_text('content')\n            protected_file = temp_path / 'protected.txt'\n            protected_file.write_text('content')\n\n            # Mock ownership and unlink behavior\n            file_info = {\n                str(file1): {'uid': 1000, 'unlink_raises': False},\n                str(file2): {'uid': 1001, 'unlink_raises': False},\n                str(file3): {'uid': 1000, 'unlink_raises': False},\n                str(file4): {'uid': 1001, 'unlink_raises': False},\n                str(protected_file): {'uid': 1000, 'unlink_raises': True}\n            }\n\n            original_stat = Path.stat\n            def mock_stat(self):\n                path_str = str(self)\n                if path_str in file_info:\n                    mock_result = MagicMock()\n                    mock_result.st_uid = file_info[path_str]['uid']\n                    return mock_result\n                return original_stat(self)\n\n            original_unlink = Path.unlink\n            def mock_unlink(self):\n                path_str = str(self)\n                if path_str in file_info and file_info[path_str]['unlink_raises']:\n                    raise PermissionError(\"Simulated permission error\")\n                original_unlink(self)\n\n            with patch('os.getuid', return_value=1000), \\\n                 patch.object(Path, 'stat', new=mock_stat), \\\n                 patch.object(Path, 'unlink', new=mock_unlink), \\\n                 patch('builtins.print') as mock_print:\n                \n                purge_user_files(temp_path)\n                \n                # Check file deletions\n                self.assertFalse(file1.exists())\n                self.assertTrue(file2.exists())\n                self.assertFalse(file3.exists())\n                self.assertTrue(file4.exists())\n                self.assertTrue(protected_file.exists())\n                \n                # Check error message\n                mock_print.assert_called_once()\n                call_args = mock_print.call_args[0][0]\n                self.assertIn(str(protected_file), call_args)\n                self.assertIn(\"Simulated permission error\", call_args)\n\n    def test_case_2(self):\n        \"\"\"\n        Empty directory should result in no deletions.\n        \"\"\"\n        with tempfile.TemporaryDirectory() as temp_dir:\n            temp_path = Path(temp_dir)\n            purge_user_files(temp_path)\n            # No files to check, just ensure no errors occur\n\n    def test_case_3(self):\n        \"\"\"\n        Non-existent directory should raise FileNotFoundError.\n        \"\"\"\n        with tempfile.TemporaryDirectory() as temp_dir:\n            non_existent = Path(temp_dir) / \"missing\"\n            with self.assertRaises(FileNotFoundError):\n                purge_user_files(non_existent)\n\n    def test_case_4(self):\n        \"\"\"\n        Passing a file as root_dir should not delete anything.\n        \"\"\"\n        with tempfile.NamedTemporaryFile() as temp_file:\n            file_path = Path(temp_file.name)\n            purge_user_files(file_path)\n            # Ensure the file still exists\n            self.assertTrue(file_path.exists())\n\n    def test_case_5(self):\n        \"\"\"\n        All files owned by current user should be deleted.\n        \"\"\"\n        with tempfile.TemporaryDirectory() as temp_dir:\n            temp_path = Path(temp_dir)\n            file1 = temp_path / 'file1.txt'\n            file1.write_text('content')\n            file2 = temp_path / 'file2.txt'\n            file2.write_text('content')\n\n            # Mock all files as owned by current user\n            with patch('os.getuid', return_value=1000), \\\n                 patch.object(Path, 'stat') as mock_stat:\n                mock_stat.return_value.st_uid = 1000\n                purge_user_files(temp_path)\n                \n                self.assertFalse(file1.exists())\n                self.assertFalse(file2.exists())\n\n    def test_case_6(self):\n        \"\"\"\n        No files owned by current user should result in no deletions.\n        \"\"\"\n        with tempfile.TemporaryDirectory() as temp_dir:\n            temp_path = Path(temp_dir)\n            file1 = temp_path / 'file1.txt'\n            file1.write_text('content')\n            file2 = temp_path / 'file2.txt'\n            file2.write_text('content')\n\n            # Mock all files as owned by another user\n            with patch('os.getuid', return_value=1000), \\\n                 patch.object(Path, 'stat') as mock_stat:\n                mock_stat.return_value.st_uid = 1001\n                purge_user_files(temp_path)\n                \n                self.assertTrue(file1.exists())\n                self.assertTrue(file2.exists())\n\n    def test_case_7(self):\n        \"\"\"\n        Single file causing PermissionError should be handled gracefully.\n        \"\"\"\n        with tempfile.TemporaryDirectory() as temp_dir:\n            temp_path = Path(temp_dir)\n            protected_file = temp_path / 'protected.txt'\n            protected_file.write_text('content')\n\n            # Mock ownership and force unlink error\n            with patch('os.getuid', return_value=1000), \\\n                 patch.object(Path, 'stat') as mock_stat, \\\n                 patch.object(Path, 'unlink') as mock_unlink, \\\n                 patch('builtins.print') as mock_print:\n                \n                mock_stat.return_value.st_uid = 1000\n                mock_unlink.side_effect = PermissionError(\"Simulated error\")\n                \n                purge_user_files(temp_path)\n                \n                self.assertTrue(protected_file.exists())\n                mock_print.assert_called_once()\n                call_args = mock_print.call_args[0][0]\n                self.assertIn(str(protected_file), call_args)\n                self.assertIn(\"Simulated error\", call_args)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 7, "task_id": "0eb66c14"}
{"test": "import unittest\nimport os\nimport stat\nfrom pathlib import Path\nfrom tempfile import TemporaryDirectory\nfrom unittest.mock import patch\n\nclass TestRemoveUserFiles(unittest.TestCase):\n\n    def test_empty_directory(self):\n        \"\"\"Test that function handles empty directory without errors.\"\"\"\n        with TemporaryDirectory() as tmpdir:\n            dir_path = Path(tmpdir)\n            remove_user_files(dir_path)\n            self.assertTrue(dir_path.exists())\n            self.assertEqual(len(list(dir_path.iterdir())), 0)\n\n    def test_single_owned_file(self):\n        \"\"\"Test that a single owned file is deleted.\"\"\"\n        with TemporaryDirectory() as tmpdir:\n            file_path = Path(tmpdir) / 'test.txt'\n            file_path.write_text('content')\n            remove_user_files(Path(tmpdir))\n            self.assertFalse(file_path.exists())\n\n    def test_nested_owned_files(self):\n        \"\"\"Test nested owned files are all deleted.\"\"\"\n        with TemporaryDirectory() as tmpdir:\n            top = Path(tmpdir)\n            dir1 = top / 'dir1'\n            dir1.mkdir()\n            dir2 = dir1 / 'dir2'\n            dir2.mkdir()\n            file1 = dir2 / 'file1.txt'\n            file1.write_text('content1')\n            file2 = dir2 / 'file2.txt'\n            file2.write_text('content2')\n            remove_user_files(top)\n            self.assertFalse(file1.exists())\n            self.assertFalse(file2.exists())\n            self.assertTrue(dir1.exists())\n            self.assertTrue(dir2.exists())\n\n    def test_permission_error_on_unlink(self):\n        \"\"\"Test PermissionError during deletion is handled and file remains.\"\"\"\n        with TemporaryDirectory() as tmpdir:\n            top = Path(tmpdir)\n            subdir = top / 'sub'\n            subdir.mkdir()\n            file_path = subdir / 'test.txt'\n            file_path.write_text('content')\n            current_permissions = subdir.stat().st_mode\n            subdir.chmod(current_permissions & ~stat.S_IWUSR & ~stat.S_IWGRP & ~stat.S_IWOTH)\n            remove_user_files(top)\n            self.assertTrue(file_path.exists())\n            subdir.chmod(current_permissions)\n\n    def test_file_not_owned(self):\n        \"\"\"Test non-owned file (simulated via mock) is not deleted.\"\"\"\n        with TemporaryDirectory() as tmpdir:\n            file_path = Path(tmpdir) / 'test.txt'\n            file_path.write_text('content')\n            with patch.object(file_path, 'stat') as mock_stat:\n                mock_stat.return_value.st_uid = os.getuid() + 1\n                remove_user_files(Path(tmpdir))\n                self.assertTrue(file_path.exists())\n\n    def test_owned_symlink(self):\n        \"\"\"Test owned symlink (to file) is deleted.\"\"\"\n        with TemporaryDirectory() as tmpdir:\n            top = Path(tmpdir)\n            target = top / 'target.txt'\n            target.write_text('content')\n            symlink = top / 'link.txt'\n            symlink.symlink_to(target)\n            remove_user_files(top)\n            self.assertFalse(symlink.exists())\n            self.assertTrue(target.exists())\n\n    def test_not_owned_symlink(self):\n        \"\"\"Test non-owned symlink (simulated via mock) is not deleted.\"\"\"\n        with TemporaryDirectory() as tmpdir:\n            top = Path(tmpdir)\n            target = top / 'target.txt'\n            target.write_text('content')\n            symlink = top / 'link.txt'\n            symlink.symlink_to(target)\n            with patch.object(symlink, 'stat') as mock_stat:\n                mock_stat.return_value.st_uid = os.getuid() + 1\n                remove_user_files(top)\n                self.assertTrue(symlink.exists())\n\n    def test_directory_not_deleted(self):\n        \"\"\"Test directories are not deleted.\"\"\"\n        with TemporaryDirectory() as tmpdir:\n            top = Path(tmpdir)\n            subdir = top / 'subdir'\n            subdir.mkdir()\n            remove_user_files(top)\n            self.assertTrue(subdir.exists())\n\n    def test_broken_symlink(self):\n        \"\"\"Test broken symlink is not deleted.\"\"\"\n        with TemporaryDirectory() as tmpdir:\n            top = Path(tmpdir)\n            symlink = top / 'broken_link'\n            symlink.symlink_to('non_existent_file')\n            remove_user_files(top)\n            self.assertTrue(symlink.exists())\n\n    def test_subdirectory_without_execute_permission(self):\n        \"\"\"Test PermissionError on traversal, with partial deletion.\"\"\"\n        with TemporaryDirectory() as tmpdir:\n            top = Path(tmpdir)\n            accessible_dir = top / 'accessible'\n            accessible_dir.mkdir()\n            file1 = accessible_dir / 'file1.txt'\n            file1.write_text('content')\n            inaccessible_dir = top / 'inaccessible'\n            inaccessible_dir.mkdir()\n            file2 = inaccessible_dir / 'file2.txt'\n            file2.write_text('content')\n            current_permissions = inaccessible_dir.stat().st_mode\n            inaccessible_dir.chmod(current_permissions & ~stat.S_IXUSR)\n            try:\n                remove_user_files(top)\n            except PermissionError:\n                pass\n            else:\n                self.fail(\"PermissionError not raised\")\n            self.assertFalse(file1.exists())\n            self.assertTrue(file2.exists())\n            inaccessible_dir.chmod(current_permissions)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 10, "task_id": "cd88f14d"}
{"test": "import unittest\nfrom unittest.mock import patch, MagicMock\nfrom pathlib import Path\nimport os\n\n@patch('os.getuid', return_value=1000)\nclass TestClearUserData(unittest.TestCase):\n\n    def test_non_existent_path(self, mock_getuid):\n        \"\"\"Test when the top-level directory does not exist (raises FileNotFoundError).\"\"\"\n        non_existent_path = MagicMock(spec=Path)\n        non_existent_path.rglob.side_effect = FileNotFoundError('No such directory')\n        with self.assertRaises(FileNotFoundError):\n            clear_user_data(non_existent_path)\n\n    def test_single_owned_file(self, mock_getuid):\n        \"\"\"Test with one file owned by the current user: should be deleted.\"\"\"\n        top_path = MagicMock(spec=Path)\n        file1 = MagicMock(spec=Path)\n        file1.is_file.return_value = True\n        file1.stat.return_value.st_uid = 1000\n        top_path.rglob.return_value = [file1]\n        clear_user_data(top_path)\n        file1.unlink.assert_called_once()\n\n    def test_single_non_owned_file(self, mock_getuid):\n        \"\"\"Test with one file not owned by the current user: should not be deleted.\"\"\"\n        top_path = MagicMock(spec=Path)\n        file1 = MagicMock(spec=Path)\n        file1.is_file.return_value = True\n        file1.stat.return_value.st_uid = 2000\n        top_path.rglob.return_value = [file1]\n        clear_user_data(top_path)\n        file1.unlink.assert_not_called()\n\n    def test_directory_skipped(self, mock_getuid):\n        \"\"\"Test with a directory: should be skipped (not unlinked).\"\"\"\n        top_path = MagicMock(spec=Path)\n        dir1 = MagicMock(spec=Path)\n        dir1.is_file.return_value = False\n        top_path.rglob.return_value = [dir1]\n        clear_user_data(top_path)\n        dir1.unlink.assert_not_called()\n\n    @patch('builtins.print')\n    def test_owned_file_but_permission_error(self, mock_print, mock_getuid):\n        \"\"\"Test with a file owned by current user but unlink raises PermissionError: should print error.\"\"\"\n        top_path = MagicMock(spec=Path)\n        file1 = MagicMock(spec=Path)\n        file1.is_file.return_value = True\n        file1.stat.return_value.st_uid = 1000\n        file1.unlink.side_effect = PermissionError('Permission denied')\n        file1.__str__.return_value = '/path/to/file1'\n        top_path.rglob.return_value = [file1]\n        clear_user_data(top_path)\n        file1.unlink.assert_called_once()\n        mock_print.assert_called_once_with('Failed to delete /path/to/file1: Permission denied')\n\n    def test_multiple_files(self, mock_getuid):\n        \"\"\"Test with multiple files: owned files unlinked, others skipped.\"\"\"\n        top_path = MagicMock(spec=Path)\n        file1 = MagicMock(spec=Path)  # owned\n        file1.is_file.return_value = True\n        file1.stat.return_value.st_uid = 1000\n        file2 = MagicMock(spec=Path)  # not owned\n        file2.is_file.return_value = True\n        file2.stat.return_value.st_uid = 2000\n        file3 = MagicMock(spec=Path)  # directory\n        file3.is_file.return_value = False\n        file4 = MagicMock(spec=Path)  # owned\n        file4.is_file.return_value = True\n        file4.stat.return_value.st_uid = 1000\n        top_path.rglob.return_value = [file1, file2, file3, file4]\n        clear_user_data(top_path)\n        file1.unlink.assert_called_once()\n        file2.unlink.assert_not_called()\n        file3.unlink.assert_not_called()\n        file4.unlink.assert_called_once()\n\n    def test_empty_directory(self, mock_getuid):\n        \"\"\"Test with an empty directory: no files to process.\"\"\"\n        top_path = MagicMock(spec=Path)\n        top_path.rglob.return_value = []\n        clear_user_data(top_path)\n        # No assertions needed beyond ensuring no exceptions\n\n    def test_no_owned_files(self, mock_getuid):\n        \"\"\"Test directory with only non-owned files: nothing deleted.\"\"\"\n        top_path = MagicMock(spec=Path)\n        file1 = MagicMock(spec=Path)\n        file1.is_file.return_value = True\n        file1.stat.return_value.st_uid = 2000\n        file2 = MagicMock(spec=Path)\n        file2.is_file.return_value = True\n        file2.stat.return_value.st_uid = 2000\n        top_path.rglob.return_value = [file1, file2]\n        clear_user_data(top_path)\n        file1.unlink.assert_not_called()\n        file2.unlink.assert_not_called()\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 8, "task_id": "a94f5a79"}
{"test": "import unittest\nfrom unittest.mock import MagicMock, patch\nfrom pathlib import Path\nimport os\n\nfrom solution import purge_user_files\n\nclass TestPurgeUserFiles(unittest.TestCase):\n    @patch('os.getuid')\n    def test_owned_file_deletion(self, mock_getuid):\n        # Tests deletion of file owned by current user\n        mock_getuid.return_value = 1000\n        target_dir = MagicMock(spec=Path)\n        mock_file = MagicMock(spec=Path)\n        mock_file.is_file.return_value = True\n        mock_stat = MagicMock()\n        mock_stat.st_uid = 1000\n        mock_file.stat.return_value = mock_stat\n        target_dir.rglob.return_value = [mock_file]\n        \n        purge_user_files(target_dir)\n        mock_file.unlink.assert_called_once()\n\n    @patch('os.getuid')\n    def test_non_owned_file_skipped(self, mock_getuid):\n        # Tests skipping file not owned by current user\n        mock_getuid.return_value = 1000\n        target_dir = MagicMock(spec=Path)\n        mock_file = MagicMock(spec=Path)\n        mock_file.is_file.return_value = True\n        mock_stat = MagicMock()\n        mock_stat.st_uid = 1001\n        mock_file.stat.return_value = mock_stat\n        target_dir.rglob.return_value = [mock_file]\n        \n        purge_user_files(target_dir)\n        mock_file.unlink.assert_not_called()\n\n    @patch('os.getuid')\n    def test_directory_skipped(self, mock_getuid):\n        # Tests skipping directories\n        mock_getuid.return_value = 1000\n        target_dir = MagicMock(spec=Path)\n        mock_dir = MagicMock(spec=Path)\n        mock_dir.is_file.return_value = False\n        target_dir.rglob.return_value = [mock_dir]\n        \n        purge_user_files(target_dir)\n        mock_dir.unlink.assert_not_called()\n\n    @patch('builtins.print')\n    @patch('os.getuid')\n    def test_permission_error_handling(self, mock_getuid, mock_print):\n        # Tests handling of PermissionError during deletion\n        mock_getuid.return_value = 1000\n        target_dir = MagicMock(spec=Path)\n        mock_file = MagicMock(spec=Path)\n        mock_file.is_file.return_value = True\n        mock_stat = MagicMock()\n        mock_stat.st_uid = 1000\n        mock_file.stat.return_value = mock_stat\n        mock_file.unlink.side_effect = PermissionError('Permission denied')\n        mock_file.__str__.return_value = '/path/to/file'\n        target_dir.rglob.return_value = [mock_file]\n        \n        purge_user_files(target_dir)\n        mock_file.unlink.assert_called_once()\n        mock_print.assert_called_with('Failed to delete /path/to/file: Permission denied')\n\n    @patch('os.getuid')\n    def test_nonexistent_directory(self, mock_getuid):\n        # Tests handling of non-existent directory\n        mock_getuid.return_value = 1000\n        target_dir = MagicMock(spec=Path)\n        target_dir.rglob.side_effect = FileNotFoundError('Dir not found')\n        \n        with self.assertRaises(FileNotFoundError):\n            purge_user_files(target_dir)\n\n    @patch('os.getuid')\n    def test_empty_directory(self, mock_getuid):\n        # Tests empty directory (no files to delete)\n        mock_getuid.return_value = 1000\n        target_dir = MagicMock(spec=Path)\n        target_dir.rglob.return_value = []\n        \n        purge_user_files(target_dir)\n\n    @patch('builtins.print')\n    @patch('os.getuid')\n    def test_multiple_files_processing(self, mock_getuid, mock_print):\n        # Tests processing multiple files with mixed conditions\n        mock_getuid.return_value = 1000\n        target_dir = MagicMock(spec=Path)\n        \n        # Owned file (should be deleted)\n        file1 = MagicMock(spec=Path)\n        file1.is_file.return_value = True\n        stat1 = MagicMock()\n        stat1.st_uid = 1000\n        file1.stat.return_value = stat1\n        \n        # Non-owned file (should skip)\n        file2 = MagicMock(spec=Path)\n        file2.is_file.return_value = True\n        stat2 = MagicMock()\n        stat2.st_uid = 1001\n        file2.stat.return_value = stat2\n        \n        # Directory (should skip)\n        dir1 = MagicMock(spec=Path)\n        dir1.is_file.return_value = False\n        \n        # Owned file with PermissionError\n        file3 = MagicMock(spec=Path)\n        file3.is_file.return_value = True\n        stat3 = MagicMock()\n        stat3.st_uid = 1000\n        file3.stat.return_value = stat3\n        file3.unlink.side_effect = PermissionError('Denied')\n        file3.__str__.return_value = 'restricted_file'\n        \n        target_dir.rglob.return_value = [file1, file2, dir1, file3]\n        \n        purge_user_files(target_dir)\n        \n        file1.unlink.assert_called_once()\n        file2.unlink.assert_not_called()\n        dir1.unlink.assert_not_called()\n        file3.unlink.assert_called_once()\n        mock_print.assert_called_with('Failed to delete restricted_file: Denied')\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 7, "task_id": "93b46082"}
{"test": "import unittest\nimport os\nimport time\nfrom pathlib import Path\nimport tempfile\nfrom unittest.mock import patch\n\nclass TestRemoveOldEntries(unittest.TestCase):\n\n    def setUp(self):\n        self.test_dir = tempfile.TemporaryDirectory()\n        self.folder_path = Path(self.test_dir.name)\n\n    def tearDown(self):\n        self.test_dir.cleanup()\n\n    def test_delete_old_file_owned_by_current_user(self):\n        # Test deletion of old file owned by current user\n        file_path = self.folder_path / 'test.txt'\n        file_path.touch()\n        old_time = time.time() - 10 * 86400\n        os.utime(file_path, (old_time, old_time))\n        remove_old_entries(self.folder_path, 5)\n        self.assertFalse(file_path.exists())\n\n    def test_old_file_not_owned_by_current_user(self):\n        # Test old file not deleted when owned by different user\n        file_path = self.folder_path / 'test.txt'\n        file_path.touch()\n        old_time = time.time() - 10 * 86400\n        os.utime(file_path, (old_time, old_time))\n        current_uid = os.getuid()\n        non_current_uid = current_uid + 1\n        original_os_stat = os.stat\n        def mock_os_stat(path, *args, **kwargs):\n            if path == str(file_path):\n                stat_result = list(original_os_stat(path, *args, **kwargs))\n                stat_result[4] = non_current_uid\n                stat_result[8] = old_time\n                return os.stat_result(tuple(stat_result))\n            else:\n                return original_os_stat(path, *args, **kwargs)\n        with patch('os.stat', new=mock_os_stat):\n            remove_old_entries(self.folder_path, 5)\n        self.assertTrue(file_path.exists())\n\n    def test_permission_error_handling(self):\n        # Test PermissionError during deletion is caught and printed\n        file_path = self.folder_path / 'test.txt'\n        file_path.touch()\n        old_time = time.time() - 10 * 86400\n        os.utime(file_path, (old_time, old_time))\n        with patch.object(Path, 'unlink', side_effect=PermissionError('Permission denied')) as mock_unlink, \\\n             patch('builtins.print') as mock_print:\n            remove_old_entries(self.folder_path, 5)\n            mock_print.assert_called_once()\n            printed_message = mock_print.call_args[0][0]\n            self.assertIn(str(file_path), printed_message)\n            self.assertIn('Permission denied', printed_message)\n        self.assertTrue(file_path.exists())\n\n    def test_directory_not_deleted(self):\n        # Test directories are not deleted even if old\n        dir_path = self.folder_path / 'subdir'\n        dir_path.mkdir()\n        old_time = time.time() - 10 * 86400\n        os.utime(dir_path, (old_time, old_time))\n        remove_old_entries(self.folder_path, 5)\n        self.assertTrue(dir_path.exists())\n\n    def test_new_file_not_deleted(self):\n        # Test new file is not deleted\n        file_path = self.folder_path / 'test.txt'\n        file_path.touch()\n        remove_old_entries(self.folder_path, 5)\n        self.assertTrue(file_path.exists())\n\n    def test_empty_directory(self):\n        # Test function handles empty directory correctly\n        remove_old_entries(self.folder_path, 5)\n        self.assertTrue(self.folder_path.exists())\n        self.assertEqual(len(list(self.folder_path.iterdir())), 0)\n\n    def test_multiple_files(self):\n        # Test mixed scenario: old owned, old not owned, and new files\n        file1 = self.folder_path / 'file1.txt'\n        file2 = self.folder_path / 'file2.txt'\n        file3 = self.folder_path / 'file3.txt'\n        file1.touch()\n        file2.touch()\n        file3.touch()\n        old_time = time.time() - 10 * 86400\n        new_time = time.time() - 3 * 86400\n        os.utime(file1, (old_time, old_time))\n        os.utime(file2, (old_time, old_time))\n        os.utime(file3, (new_time, new_time))\n        current_uid = os.getuid()\n        non_current_uid = current_uid + 1\n        original_os_stat = os.stat\n        def mock_os_stat(path, *args, **kwargs):\n            if path == str(file2):\n                stat_result = list(original_os_stat(path, *args, **kwargs))\n                stat_result[4] = non_current_uid\n                stat_result[8] = old_time\n                return os.stat_result(tuple(stat_result))\n            else:\n                return original_os_stat(path, *args, **kwargs)\n        with patch('os.stat', new=mock_os_stat):\n            remove_old_entries(self.folder_path, 5)\n        self.assertFalse(file1.exists())\n        self.assertTrue(file2.exists())\n        self.assertTrue(file3.exists())\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 7, "task_id": "142b3637"}
{"test": "import os\nimport time\nimport unittest\nimport tempfile\nfrom pathlib import Path\nfrom unittest.mock import patch, Mock\n\nclass TestCleanOldLogs(unittest.TestCase):\n    def setUp(self):\n        self.test_dir = tempfile.TemporaryDirectory()\n        self.temp_path = Path(self.test_dir.name)\n    \n    def tearDown(self):\n        self.test_dir.cleanup()\n    \n    def test_normal_deletion(self):\n        \"\"\"Test deletion of old files owned by current user while skipping others.\"\"\"\n        current_uid = 1000\n        other_uid = 1001\n        current_time = time.time()\n        old_time = current_time - 8 * 86400  # 8 days old\n        new_time = current_time - 6 * 86400  # 6 days old\n        \n        file1 = Mock(spec=Path)\n        file1.is_file.return_value = True\n        file1.stat.return_value.st_uid = current_uid\n        file1.stat.return_value.st_mtime = old_time\n        \n        file2 = Mock(spec=Path)\n        file2.is_file.return_value = True\n        file2.stat.return_value.st_uid = other_uid\n        file2.stat.return_value.st_mtime = old_time\n        \n        file3 = Mock(spec=Path)\n        file3.is_file.return_value = True\n        file3.stat.return_value.st_uid = current_uid\n        file3.stat.return_value.st_mtime = new_time\n        \n        dir1 = Mock(spec=Path)\n        dir1.is_file.return_value = False\n        \n        with patch('os.getuid', return_value=current_uid), \\\n             patch.object(Path, 'iterdir', return_value=[file1, file2, file3, dir1]):\n            \n            clean_old_logs(self.temp_path, 7)\n            file1.unlink.assert_called_once()\n            file2.unlink.assert_not_called()\n            file3.unlink.assert_not_called()\n            dir1.unlink.assert_not_called()\n    \n    def test_permission_error(self):\n        \"\"\"Test handling of PermissionError during file deletion.\"\"\"\n        current_uid = 1000\n        current_time = time.time()\n        old_time = current_time - 8 * 86400\n        \n        file4 = Mock(spec=Path)\n        file4.is_file.return_value = True\n        file4.stat.return_value.st_uid = current_uid\n        file4.stat.return_value.st_mtime = old_time\n        file4.unlink.side_effect = PermissionError(\"Permission denied\")\n        \n        with patch('os.getuid', return_value=current_uid), \\\n             patch.object(Path, 'iterdir', return_value=[file4]), \\\n             patch('builtins.print') as mock_print:\n            \n            clean_old_logs(self.temp_path, 7)\n            file4.unlink.assert_called_once()\n            mock_print.assert_called_once()\n            self.assertIn(\"Failed to delete\", mock_print.call_args[0][0])\n            self.assertIn(\"Permission denied\", mock_print.call_args[0][0])\n    \n    def test_non_file(self):\n        \"\"\"Test that non-file entries (like directories) are skipped.\"\"\"\n        current_uid = 1000\n        current_time = time.time()\n        old_time = current_time - 8 * 86400\n        \n        dir1 = Mock(spec=Path)\n        dir1.is_file.return_value = False\n        \n        with patch('os.getuid', return_value=current_uid), \\\n             patch.object(Path, 'iterdir', return_value=[dir1]):\n            \n            clean_old_logs(self.temp_path, 7)\n            dir1.unlink.assert_not_called()\n    \n    def test_num_days_zero(self):\n        \"\"\"Test with zero days threshold (deletes files older than now).\"\"\"\n        current_uid = 1000\n        current_time = time.time()\n        \n        file1 = Mock(spec=Path)\n        file1.is_file.return_value = True\n        file1.stat.return_value.st_uid = current_uid\n        file1.stat.return_value.st_mtime = current_time - 1  # 1 second ago\n        \n        with patch('os.getuid', return_value=current_uid), \\\n             patch.object(Path, 'iterdir', return_value=[file1]):\n            \n            clean_old_logs(self.temp_path, 0)\n            file1.unlink.assert_called_once()\n    \n    def test_num_days_negative(self):\n        \"\"\"Test with negative days threshold (deletes files before future cutoff).\"\"\"\n        current_uid = 1000\n        current_time = time.time()\n        \n        file1 = Mock(spec=Path)\n        file1.is_file.return_value = True\n        file1.stat.return_value.st_uid = current_uid\n        file1.stat.return_value.st_mtime = current_time  # now\n        \n        with patch('os.getuid', return_value=current_uid), \\\n             patch.object(Path, 'iterdir', return_value=[file1]):\n            \n            clean_old_logs(self.temp_path, -1)\n            file1.unlink.assert_called_once()\n    \n    def test_log_dir_not_exists(self):\n        \"\"\"Test behavior with non-existent directory.\"\"\"\n        non_existing = self.temp_path / \"nonexistent\"\n        self.assertFalse(non_existing.exists())\n        with self.assertRaises(FileNotFoundError):\n            clean_old_logs(non_existing, 7)\n    \n    def test_log_dir_is_file(self):\n        \"\"\"Test behavior when directory path is actually a file.\"\"\"\n        file_path = self.temp_path / \"file.txt\"\n        file_path.touch()\n        with self.assertRaises(NotADirectoryError):\n            clean_old_logs(file_path, 7)\n    \n    def test_large_num_days(self):\n        \"\"\"Test with very large num_days (no deletion as cutoff is ancient).\"\"\"\n        current_uid = 1000\n        \n        file1 = Mock(spec=Path)\n        file1.is_file.return_value = True\n        file1.stat.return_value.st_uid = current_uid\n        file1.stat.return_value.st_mtime = 0  # epoch time\n        \n        with patch('os.getuid', return_value=current_uid), \\\n             patch.object(Path, 'iterdir', return_value=[file1]):\n            \n            clean_old_logs(self.temp_path, 10**6)  # 1,000,000 days\n            file1.unlink.assert_not_called()\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 8, "task_id": "f68bddb4"}
{"test": "import unittest\nfrom pathlib import Path\nimport os\nimport time\nfrom tempfile import TemporaryDirectory\nfrom unittest.mock import patch, MagicMock\n\nclass TestPurgeOutdatedFiles(unittest.TestCase):\n\n    def test_happy_path(self):\n        # Test deletion of old file owned by current user\n        with TemporaryDirectory() as temp_dir:\n            temp_path = Path(temp_dir)\n            file_old = temp_path / \"old.txt\"\n            file_old.touch()\n            old_time = time.time() - 86401  # 1 day + 1 second\n            os.utime(file_old, (old_time, old_time))\n            \n            file_new = temp_path / \"new.txt\"\n            file_new.touch()\n            \n            purge_outdated_files(temp_path, 1)\n            \n            self.assertFalse(file_old.exists(), \"Old file should be deleted\")\n            self.assertTrue(file_new.exists(), \"New file should remain\")\n\n    def test_non_owned_file(self):\n        # Test old file not owned by current user is not deleted\n        with TemporaryDirectory() as temp_dir:\n            temp_path = Path(temp_dir)\n            file_old = temp_path / \"old.txt\"\n            file_old.touch()\n            old_time = time.time() - 86401\n            os.utime(file_old, (old_time, old_time))\n            \n            current_uid = os.getuid()\n            with patch.object(Path, 'stat') as mock_stat:\n                mock_stat.return_value.st_uid = current_uid + 1\n                mock_stat.return_value.st_mtime = old_time\n                \n                purge_outdated_files(temp_path, 1)\n                \n                self.assertTrue(file_old.exists(), \"Non-owned file should remain\")\n\n    def test_permission_error(self):\n        # Test handling of PermissionError during deletion\n        with TemporaryDirectory() as temp_dir:\n            temp_path = Path(temp_dir)\n            file_old = temp_path / \"old.txt\"\n            file_old.touch()\n            old_time = time.time() - 86401\n            os.utime(file_old, (old_time, old_time))\n            \n            with patch.object(Path, 'unlink') as mock_unlink:\n                mock_unlink.side_effect = PermissionError(\"Permission denied\")\n                with patch('builtins.print') as mock_print:\n                    purge_outdated_files(temp_path, 1)\n                    \n                    self.assertTrue(file_old.exists(), \"File should remain after PermissionError\")\n                    mock_print.assert_called_once()\n                    self.assertIn(\"Failed to delete\", mock_print.call_args[0][0])\n\n    def test_empty_directory(self):\n        # Test function on an empty directory\n        with TemporaryDirectory() as temp_dir:\n            temp_path = Path(temp_dir)\n            purge_outdated_files(temp_path, 1)\n            # No exception expected\n            self.assertEqual(len(list(temp_path.iterdir())), 0, \"Directory should remain empty\")\n\n    def test_mix_of_files(self):\n        # Test combination of owned, non-owned, and protected files\n        with TemporaryDirectory() as temp_dir:\n            temp_path = Path(temp_dir)\n            now = time.time()\n            old_time = now - 86401\n            \n            # Old owned file (should be deleted)\n            file1 = temp_path / \"file1.txt\"\n            file1.touch()\n            os.utime(file1, (old_time, old_time))\n            \n            # New owned file (should remain)\n            file2 = temp_path / \"file2.txt\"\n            file2.touch()\n            \n            # Old non-owned file (should remain)\n            file3 = temp_path / \"file3.txt\"\n            file3.touch()\n            os.utime(file3, (old_time, old_time))\n            \n            # Old owned file with PermissionError (should remain)\n            file4 = temp_path / \"file4.txt\"\n            file4.touch()\n            os.utime(file4, (old_time, old_time))\n            \n            current_uid = os.getuid()\n            \n            with patch.object(Path, 'stat') as mock_stat:\n                def stat_side_effect(self):\n                    orig = self._orig_stat()\n                    if self.name == \"file3.txt\":\n                        return MagicMock(st_uid=current_uid + 1, st_mtime=old_time)\n                    return orig\n                \n                mock_stat.side_effect = stat_side_effect\n                \n                with patch.object(Path, 'unlink') as mock_unlink:\n                    def unlink_side_effect(self):\n                        if self.name == \"file4.txt\":\n                            raise PermissionError(\"Permission denied\")\n                        self._orig_unlink()\n                    \n                    mock_unlink.side_effect = unlink_side_effect\n                    \n                    with patch('builtins.print') as mock_print:\n                        purge_outdated_files(temp_path, 1)\n                        \n                        self.assertFalse(file1.exists(), \"Old owned file should be deleted\")\n                        self.assertTrue(file2.exists(), \"New owned file should remain\")\n                        self.assertTrue(file3.exists(), \"Non-owned file should remain\")\n                        self.assertTrue(file4.exists(), \"Protected file should remain\")\n                        mock_print.assert_called_once()\n\n    def test_non_existent_directory(self):\n        # Test non-existent directory raises FileNotFoundError\n        with TemporaryDirectory() as temp_dir:\n            temp_path = Path(temp_dir)\n            os.rmdir(temp_path)\n            with self.assertRaises(FileNotFoundError):\n                purge_outdated_files(temp_path, 1)\n\n    def test_non_directory_path(self):\n        # Test passing a file path raises NotADirectoryError\n        with TemporaryDirectory() as temp_dir:\n            temp_path = Path(temp_dir)\n            file_path = temp_path / \"test.txt\"\n            file_path.touch()\n            with self.assertRaises(NotADirectoryError):\n                purge_outdated_files(file_path, 1)\n\n    def test_negative_threshold_days(self):\n        # Test negative threshold_days (no files should be deleted)\n        with TemporaryDirectory() as temp_dir:\n            temp_path = Path(temp_dir)\n            file_old = temp_path / \"old.txt\"\n            file_old.touch()\n            old_time = time.time() - 86401\n            os.utime(file_old, (old_time, old_time))\n            \n            purge_outdated_files(temp_path, -1)\n            \n            self.assertTrue(file_old.exists(), \"File should remain with negative threshold\")\n\n    def test_zero_threshold_days(self):\n        # Test zero threshold_days (delete files older than 0 days)\n        with TemporaryDirectory() as temp_dir:\n            temp_path = Path(temp_dir)\n            now = time.time()\n            \n            # File modified 10 seconds ago\n            file_past = temp_path / \"past.txt\"\n            file_past.touch()\n            os.utime(file_past, (now - 10, now - 10))\n            \n            # File modified in the future\n            file_future = temp_path / \"future.txt\"\n            file_future.touch()\n            os.utime(file_future, (now + 10, now + 10))\n            \n            with patch('time.time', return_value=now):\n                purge_outdated_files(temp_path, 0)\n                \n                self.assertFalse(file_past.exists(), \"Past file should be deleted\")\n                self.assertTrue(file_future.exists(), \"Future file should remain\")\n\n    def test_directory_skipped(self):\n        # Test directories are skipped and not deleted\n        with TemporaryDirectory() as temp_dir:\n            temp_path = Path(temp_dir)\n            subdir = temp_path / \"subdir\"\n            subdir.mkdir()\n            old_time = time.time() - 86401\n            os.utime(subdir, (old_time, old_time))\n            \n            purge_outdated_files(temp_path, 1)\n            \n            self.assertTrue(subdir.exists(), \"Directory should remain\")\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 10, "task_id": "4f0265e6"}
{"test": "import unittest\nimport os\nimport time\nimport tempfile\nfrom pathlib import Path\nfrom unittest.mock import patch, Mock\n\nclass TestRemoveExpiredFiles(unittest.TestCase):\n\n    def test_empty_directory(self):\n        # Test that function handles empty directory without errors\n        with tempfile.TemporaryDirectory() as temp_dir:\n            temp_path = Path(temp_dir)\n            remove_expired_files(temp_path, 1)\n            self.assertEqual(len(list(temp_path.iterdir())), 0)\n\n    def test_old_owned_file_deleted(self):\n        # Test that old file owned by current user is deleted\n        with tempfile.TemporaryDirectory() as temp_dir:\n            temp_path = Path(temp_dir)\n            file_path = temp_path / 'old_owned.txt'\n            file_path.touch()\n            old_time = time.time() - (2 * 86400)\n            os.utime(str(file_path), (old_time, old_time))\n            \n            current_uid = 1000\n            with patch('os.getuid', return_value=current_uid), \\\n                 patch('pathlib.Path.stat', \n                       return_value=Mock(st_uid=current_uid, st_mtime=old_time)):\n                \n                remove_expired_files(temp_path, 1)\n                self.assertFalse(file_path.exists())\n\n    def test_old_not_owned_not_deleted(self):\n        # Test that old file not owned by current user is not deleted\n        with tempfile.TemporaryDirectory() as temp_dir:\n            temp_path = Path(temp_dir)\n            file_path = temp_path / 'old_not_owned.txt'\n            file_path.touch()\n            old_time = time.time() - (2 * 86400)\n            os.utime(str(file_path), (old_time, old_time))\n            \n            current_uid = 1000\n            fake_uid = 1001\n            with patch('os.getuid', return_value=current_uid), \\\n                 patch('pathlib.Path.stat', \n                       return_value=Mock(st_uid=fake_uid, st_mtime=old_time)):\n                \n                remove_expired_files(temp_path, 1)\n                self.assertTrue(file_path.exists())\n\n    def test_new_owned_not_deleted(self):\n        # Test that new file owned by current user is not deleted\n        with tempfile.TemporaryDirectory() as temp_dir:\n            temp_path = Path(temp_dir)\n            file_path = temp_path / 'new_owned.txt'\n            file_path.touch()\n            current_time = time.time()\n            \n            current_uid = 1000\n            with patch('os.getuid', return_value=current_uid), \\\n                 patch('pathlib.Path.stat', \n                       return_value=Mock(st_uid=current_uid, st_mtime=current_time)):\n                \n                remove_expired_files(temp_path, 2)\n                self.assertTrue(file_path.exists())\n\n    def test_directory_not_deleted(self):\n        # Test that directories are not deleted even if old and owned\n        with tempfile.TemporaryDirectory() as temp_dir:\n            temp_path = Path(temp_dir)\n            dir_path = temp_path / 'old_dir'\n            dir_path.mkdir()\n            old_time = time.time() - (2 * 86400)\n            os.utime(str(dir_path), (old_time, old_time))\n            \n            current_uid = 1000\n            with patch('os.getuid', return_value=current_uid), \\\n                 patch('pathlib.Path.stat', \n                       return_value=Mock(st_uid=current_uid, st_mtime=old_time)) as mock_stat:\n                \n                remove_expired_files(temp_path, 1)\n                self.assertTrue(dir_path.exists())\n                self.assertTrue(dir_path.is_dir())\n\n    def test_permission_error_handled(self):\n        # Test that PermissionError is caught and printed\n        with tempfile.TemporaryDirectory() as temp_dir:\n            temp_path = Path(temp_dir)\n            file_path = temp_path / 'protected.txt'\n            file_path.touch()\n            old_time = time.time() - (2 * 86400)\n            os.utime(str(file_path), (old_time, old_time))\n            \n            current_uid = 1000\n            with patch('os.getuid', return_value=current_uid), \\\n                 patch('pathlib.Path.stat', \n                       return_value=Mock(st_uid=current_uid, st_mtime=old_time)), \\\n                 patch('pathlib.Path.unlink', \n                       side_effect=PermissionError(\"Permission denied\")), \\\n                 patch('builtins.print') as mock_print:\n                \n                remove_expired_files(temp_path, 1)\n                self.assertTrue(file_path.exists())\n                mock_print.assert_called_once_with(f\"Failed to delete {file_path}: Permission denied\")\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 6, "task_id": "61168b71"}
{"test": "import unittest\nimport os\nimport time\nfrom pathlib import Path\nimport tempfile\nfrom unittest.mock import patch\n\nclass TestCleanOldDocuments(unittest.TestCase):\n\n    def test_empty_directory(self):\n        # Test empty directory: nothing should be deleted\n        with tempfile.TemporaryDirectory() as temp_dir:\n            temp_dir = Path(temp_dir)\n            clean_old_documents(temp_dir, 10)\n\n    def test_file_not_old(self):\n        # Test file not old enough: should not be deleted\n        with tempfile.TemporaryDirectory() as temp_dir:\n            temp_dir = Path(temp_dir)\n            file = temp_dir / \"new_file.txt\"\n            file.touch()\n            clean_old_documents(temp_dir, 10)\n            self.assertTrue(file.exists())\n\n    def test_old_file_owned(self):\n        # Test old file owned by current user: should be deleted\n        with tempfile.TemporaryDirectory() as temp_dir:\n            temp_dir = Path(temp_dir)\n            file = temp_dir / \"old_file.txt\"\n            file.touch()\n            old_time = time.time() - 10 * 86400\n            os.utime(file, (old_time, old_time))\n            clean_old_documents(temp_dir, 5)\n            self.assertFalse(file.exists())\n\n    def test_old_file_not_owned(self):\n        # Test old file not owned by current user: should not be deleted\n        with tempfile.TemporaryDirectory() as temp_dir:\n            temp_dir = Path(temp_dir)\n            file1 = temp_dir / \"file1.txt\"\n            file1.touch()\n            old_time = time.time() - 10 * 86400\n            os.utime(file1, (old_time, old_time))\n            \n            file2 = temp_dir / \"file2.txt\"\n            file2.touch()\n            os.utime(file2, (old_time, old_time))\n            \n            original_stat = Path.stat\n            def stat_mock(self):\n                if self == file2:\n                    real_stat = original_stat(self)\n                    return os.stat_result((\n                        real_stat.st_mode,\n                        real_stat.st_ino,\n                        real_stat.st_dev,\n                        real_stat.st_nlink,\n                        12345,  # Different UID\n                        real_stat.st_gid,\n                        real_stat.st_size,\n                        real_stat.st_atime,\n                        real_stat.st_mtime,\n                        real_stat.st_ctime\n                    ))\n                else:\n                    return original_stat(self)\n            \n            with patch('pathlib.Path.stat', new=stat_mock):\n                clean_old_documents(temp_dir, 5)\n            \n            self.assertFalse(file1.exists())\n            self.assertTrue(file2.exists())\n\n    def test_multiple_files(self):\n        # Test multiple files: only old and owned files should be deleted\n        with tempfile.TemporaryDirectory() as temp_dir:\n            temp_dir = Path(temp_dir)\n            file1 = temp_dir / \"file1_old_owned.txt\"\n            file1.touch()\n            old_time = time.time() - 10 * 86400\n            os.utime(file1, (old_time, old_time))\n            \n            file2 = temp_dir / \"file2_old_not_owned.txt\"\n            file2.touch()\n            os.utime(file2, (old_time, old_time))\n            \n            file3 = temp_dir / \"file3_new_owned.txt\"\n            file3.touch()\n            \n            file4 = temp_dir / \"file4_new_not_owned.txt\"\n            file4.touch()\n            \n            subdir = temp_dir / \"subdir\"\n            subdir.mkdir()\n            \n            original_stat = Path.stat\n            def stat_mock(self):\n                if self in [file2, file4]:\n                    real_stat = original_stat(self)\n                    return os.stat_result((\n                        real_stat.st_mode,\n                        real_stat.st_ino,\n                        real_stat.st_dev,\n                        real_stat.st_nlink,\n                        12345,  # Different UID\n                        real_stat.st_gid,\n                        real_stat.st_size,\n                        real_stat.st_atime,\n                        real_stat.st_mtime,\n                        real_stat.st_ctime\n                    ))\n                else:\n                    return original_stat(self)\n            \n            with patch('pathlib.Path.stat', new=stat_mock):\n                clean_old_documents(temp_dir, 5)\n            \n            self.assertFalse(file1.exists())\n            self.assertTrue(file2.exists())\n            self.assertTrue(file3.exists())\n            self.assertTrue(file4.exists())\n            self.assertTrue(subdir.exists())\n\n    def test_non_existent_directory(self):\n        # Test non-existent directory: should raise FileNotFoundError\n        non_existent = Path(\"/non/existent/directory\")\n        with self.assertRaises(FileNotFoundError):\n            clean_old_documents(non_existent, 10)\n\n    def test_permission_error(self):\n        # Test file causing PermissionError: should print error and skip\n        with tempfile.TemporaryDirectory() as temp_dir:\n            temp_dir = Path(temp_dir)\n            file1 = temp_dir / \"file1.txt\"\n            file1.touch()\n            old_time = time.time() - 10 * 86400\n            os.utime(file1, (old_time, old_time))\n            \n            original_unlink = Path.unlink\n            def unlink_side_effect(self):\n                if self == file1:\n                    raise PermissionError(\"Permission denied\")\n                else:\n                    original_unlink(self)\n            \n            with patch('pathlib.Path.unlink', new=unlink_side_effect):\n                with patch('builtins.print') as mock_print:\n                    clean_old_documents(temp_dir, 5)\n            \n            self.assertTrue(file1.exists())\n            mock_print.assert_called_with(f\"Failed to delete {file1}: Permission denied\")\n\n    def test_negative_file_age(self):\n        # Test negative file_age: no files should be deleted\n        with tempfile.TemporaryDirectory() as temp_dir:\n            temp_dir = Path(temp_dir)\n            file1 = temp_dir / \"file1.txt\"\n            file1.touch()\n            old_time = time.time() - 10 * 86400\n            os.utime(file1, (old_time, old_time))\n            clean_old_documents(temp_dir, -5)\n            self.assertTrue(file1.exists())\n\n    def test_zero_file_age(self):\n        # Test zero file_age: file modified 1 second ago should be deleted\n        with tempfile.TemporaryDirectory() as temp_dir:\n            temp_dir = Path(temp_dir)\n            file1 = temp_dir / \"file1.txt\"\n            file1.touch()\n            now = time.time()\n            one_second_ago = now - 1\n            os.utime(file1, (one_second_ago, one_second_ago))\n            clean_old_documents(temp_dir, 0)\n            self.assertFalse(file1.exists())\n\n    def test_file_age_string(self):\n        # Test file_age as string: should raise TypeError\n        with tempfile.TemporaryDirectory() as temp_dir:\n            temp_dir = Path(temp_dir)\n            with self.assertRaises(TypeError):\n                clean_old_documents(temp_dir, \"5\")\n\n    def test_dir_path_is_file(self):\n        # Test dir_path being a file: should raise NotADirectoryError\n        with tempfile.NamedTemporaryFile() as temp_file:\n            file_path = Path(temp_file.name)\n            with self.assertRaises(NotADirectoryError):\n                clean_old_documents(file_path, 5)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 11, "task_id": "99e46128"}
{"test": "import unittest\nimport tempfile\nimport os\nimport time\nfrom pathlib import Path\nfrom unittest.mock import patch, MagicMock\n\nclass TestPurgeOldItems(unittest.TestCase):\n\n    def setUp(self):\n        # Create a temporary directory for tests\n        self.test_dir = tempfile.TemporaryDirectory()\n        self.test_dir_path = Path(self.test_dir.name)\n\n    def tearDown(self):\n        # Clean up the temporary directory\n        self.test_dir.cleanup()\n\n    def test_delete_old_owned(self):\n        # Test deletion of an old file owned by current user\n        file_path = self.test_dir_path / \"old_owned.txt\"\n        file_path.touch()\n        old_time = time.time() - (10 * 86400)  # 10 days ago\n        os.utime(file_path, (old_time, old_time))\n        \n        purge_old_items(self.test_dir_path, 5)  # Delete older than 5 days\n        \n        self.assertFalse(file_path.exists())\n\n    def test_do_not_delete_old_if_not_owned(self):\n        # Test old file not owned by current user is not deleted\n        mock_file = MagicMock(spec=Path)\n        mock_file.is_file.return_value = True\n        mock_file.stat.return_value.st_mtime = time.time() - (10 * 86400)  # Old\n        mock_file.stat.return_value.st_uid = 1001  # Different UID\n        \n        with patch('os.getuid', return_value=1000), \\\n             patch.object(Path, 'iterdir', return_value=[mock_file]):\n            purge_old_items(self.test_dir_path, 5)\n            \n        mock_file.unlink.assert_not_called()\n\n    def test_do_not_delete_new_owned(self):\n        # Test new file (not old enough) is not deleted\n        file_path = self.test_dir_path / \"new_owned.txt\"\n        file_path.touch()\n        new_time = time.time() - (5 * 86400)  # 5 days ago\n        os.utime(file_path, (new_time, new_time))\n        \n        purge_old_items(self.test_dir_path, 10)  # Delete older than 10 days\n        \n        self.assertTrue(file_path.exists())\n\n    def test_multiple_files(self):\n        # Test multiple files: delete old owned, keep new owned\n        file1 = self.test_dir_path / \"old1.txt\"\n        file2 = self.test_dir_path / \"old2.txt\"\n        file3 = self.test_dir_path / \"new.txt\"\n        file1.touch()\n        file2.touch()\n        file3.touch()\n        \n        old_time = time.time() - (10 * 86400)\n        new_time = time.time() - (5 * 86400)\n        os.utime(file1, (old_time, old_time))\n        os.utime(file2, (old_time, old_time))\n        os.utime(file3, (new_time, new_time))\n        \n        purge_old_items(self.test_dir_path, 7)  # Delete older than 7 days\n        \n        self.assertFalse(file1.exists())\n        self.assertFalse(file2.exists())\n        self.assertTrue(file3.exists())\n\n    def test_age_days_zero(self):\n        # Test age_days=0 deletes any file (older than current time)\n        file_path = self.test_dir_path / \"any_file.txt\"\n        file_path.touch()\n        old_time = time.time() - 10  # 10 seconds old\n        os.utime(file_path, (old_time, old_time))\n        \n        purge_old_items(self.test_dir_path, 0)\n        \n        self.assertFalse(file_path.exists())\n\n    def test_negative_age_days(self):\n        # Test negative age_days deletes all files (cutoff in future)\n        file_path = self.test_dir_path / \"any_file.txt\"\n        file_path.touch()\n        \n        purge_old_items(self.test_dir_path, -1)  # Cutoff = current time + 1 day\n        \n        self.assertFalse(file_path.exists())\n\n    def test_permission_error(self):\n        # Test PermissionError during deletion is caught and printed\n        mock_file = MagicMock(spec=Path)\n        mock_file.is_file.return_value = True\n        mock_file.stat.return_value.st_mtime = time.time() - (10 * 86400)  # Old\n        mock_file.stat.return_value.st_uid = os.getuid()  # Current user\n        mock_file.unlink.side_effect = PermissionError(\"Permission denied\")\n        \n        with patch('builtins.print') as mock_print, \\\n             patch.object(Path, 'iterdir', return_value=[mock_file]):\n            purge_old_items(self.test_dir_path, 5)\n            \n        mock_file.unlink.assert_called_once()\n        mock_print.assert_called_once()\n        args, _ = mock_print.call_args\n        self.assertIn(\"Failed to delete\", args[0])\n        self.assertIn(\"Permission denied\", args[0])\n\n    def test_nonexistent_directory(self):\n        # Test non-existent directory raises FileNotFoundError\n        non_existent = self.test_dir_path / \"non_existent\"\n        \n        with self.assertRaises(FileNotFoundError):\n            purge_old_items(non_existent, 5)\n\n    def test_target_dir_is_file(self):\n        # Test passing a file as directory raises NotADirectoryError\n        file_path = self.test_dir_path / \"dummy_file\"\n        file_path.touch()\n        \n        with self.assertRaises(NotADirectoryError):\n            purge_old_items(file_path, 5)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 9, "task_id": "072c735a"}
{"test": "import unittest\nfrom unittest.mock import patch\nimport tempfile\nfrom pathlib import Path\nimport os\nimport time\nimport shutil\n\nclass TestRemoveOldFiles(unittest.TestCase):\n\n    def test_normal_deletion(self):\n        # Test that an old file owned by current user is deleted\n        with tempfile.TemporaryDirectory() as temp_dir:\n            temp_path = Path(temp_dir)\n            file_path = temp_path / 'file.txt'\n            file_path.write_text('Test content')\n            past_time = time.time() - (10 * 86400)\n            os.utime(file_path, (past_time, past_time))\n            remove_old_files(temp_path, 5)\n            self.assertFalse(file_path.exists())\n\n    def test_file_not_old(self):\n        # Test that a recent file is not deleted\n        with tempfile.TemporaryDirectory() as temp_dir:\n            temp_path = Path(temp_dir)\n            file_path = temp_path / 'file.txt'\n            file_path.write_text('Test content')\n            past_time = time.time() - (1 * 86400)\n            os.utime(file_path, (past_time, past_time))\n            remove_old_files(temp_path, 5)\n            self.assertTrue(file_path.exists())\n\n    def test_file_old_but_not_owned(self):\n        # Test that old file not owned by current user is not deleted\n        with tempfile.TemporaryDirectory() as temp_dir:\n            temp_path = Path(temp_dir)\n            file_path = temp_path / 'file.txt'\n            file_path.write_text('Test content')\n            past_time = time.time() - (10 * 86400)\n            os.utime(file_path, (past_time, past_time))\n            current_uid = os.getuid()\n            with patch('os.getuid', return_value=current_uid + 1):\n                remove_old_files(temp_path, 5)\n            self.assertTrue(file_path.exists())\n\n    def test_directory_not_deleted(self):\n        # Test that directories are not deleted even when old\n        with tempfile.TemporaryDirectory() as temp_dir:\n            temp_path = Path(temp_dir)\n            dir_path = temp_path / 'subdir'\n            dir_path.mkdir()\n            past_time = time.time() - (10 * 86400)\n            os.utime(dir_path, (past_time, past_time))\n            remove_old_files(temp_path, 5)\n            self.assertTrue(dir_path.exists())\n\n    def test_symlink_to_old_file_deleted(self):\n        # Test that symlink to old file is deleted (target remains)\n        with tempfile.TemporaryDirectory() as temp_dir:\n            temp_path = Path(temp_dir)\n            target = temp_path / 'target.txt'\n            target.write_text('Target content')\n            past_time = time.time() - (10 * 86400)\n            os.utime(target, (past_time, past_time))\n            symlink = temp_path / 'symlink'\n            symlink.symlink_to(target)\n            remove_old_files(temp_path, 5)\n            self.assertFalse(symlink.exists())\n            self.assertTrue(target.exists())\n\n    def test_symlink_to_old_file_but_target_not_owned(self):\n        # Test symlink not deleted when target not owned by current user\n        with tempfile.TemporaryDirectory() as temp_dir:\n            temp_path = Path(temp_dir)\n            target = temp_path / 'target.txt'\n            target.write_text('Target content')\n            past_time = time.time() - (10 * 86400)\n            os.utime(target, (past_time, past_time))\n            symlink = temp_path / 'symlink'\n            symlink.symlink_to(target)\n            current_uid = os.getuid()\n            with patch('os.getuid', return_value=current_uid + 1):\n                remove_old_files(temp_path, 5)\n            self.assertTrue(symlink.exists())\n            self.assertTrue(target.exists())\n\n    def test_negative_max_days(self):\n        # Test negative max_days deletes files (cutoff in future)\n        with tempfile.TemporaryDirectory() as temp_dir:\n            temp_path = Path(temp_dir)\n            file_path = temp_path / 'file.txt'\n            file_path.write_text('Test content')\n            remove_old_files(temp_path, -1)\n            self.assertFalse(file_path.exists())\n\n    def test_zero_days(self):\n        # Test max_days=0 deletes files older than now\n        with tempfile.TemporaryDirectory() as temp_dir:\n            temp_path = Path(temp_dir)\n            file_old = temp_path / 'file_old.txt'\n            file_old.write_text('Test content')\n            old_time = time.time() - 1\n            os.utime(file_old, (old_time, old_time))\n            \n            file_new = temp_path / 'file_new.txt'\n            file_new.write_text('Test content')\n            \n            remove_old_files(temp_path, 0)\n            self.assertFalse(file_old.exists())\n            self.assertTrue(file_new.exists())\n\n    def test_nonexistent_folder(self):\n        # Test non-existent folder raises FileNotFoundError\n        temp_dir = tempfile.mkdtemp()\n        temp_path = Path(temp_dir)\n        shutil.rmtree(temp_dir)\n        with self.assertRaises(FileNotFoundError):\n            remove_old_files(temp_path, 5)\n\n    def test_permission_error(self):\n        # Test PermissionError during deletion prints error\n        with tempfile.TemporaryDirectory() as temp_dir:\n            temp_path = Path(temp_dir)\n            file_path = temp_path / 'file.txt'\n            file_path.write_text('Test content')\n            past_time = time.time() - (10 * 86400)\n            os.utime(file_path, (past_time, past_time))\n            \n            with patch.object(file_path, 'unlink', side_effect=PermissionError('Permission denied')), \\\n                 patch('builtins.print') as mock_print:\n                \n                remove_old_files(temp_path, 5)\n                mock_print.assert_called_with(f'Failed to delete {file_path}: Permission denied')\n            \n            self.assertTrue(file_path.exists())\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 10, "task_id": "2aad3e40"}
{"test": "import unittest\nfrom pathlib import Path\nimport os\nimport time\nimport tempfile\nimport shutil\nfrom unittest.mock import patch\n\nclass TestDiscardOldFiles(unittest.TestCase):\n\n    def create_temp_dir(self):\n        temp_dir = tempfile.mkdtemp()\n        self.addCleanup(lambda: shutil.rmtree(temp_dir, ignore_errors=True))\n        return Path(temp_dir)\n\n    def test_delete_old_file(self):\n        # Test deletion of old file owned by current user\n        temp_dir = self.create_temp_dir()\n        file_path = temp_dir / 'test.txt'\n        file_path.touch()\n        old_time = time.time() - (10 * 86400)  # 10 days old\n        os.utime(file_path, (old_time, old_time))\n        discard_old_files(temp_dir, 5)\n        self.assertFalse(file_path.exists())\n\n    def test_do_not_delete_recent_file(self):\n        # Test non-deletion of recent file\n        temp_dir = self.create_temp_dir()\n        file_path = temp_dir / 'test.txt'\n        file_path.touch()\n        recent_time = time.time() - (4 * 86400)  # 4 days old\n        os.utime(file_path, (recent_time, recent_time))\n        discard_old_files(temp_dir, 5)\n        self.assertTrue(file_path.exists())\n\n    def test_do_not_delete_if_not_owned(self):\n        # Test non-deletion when file not owned by current user (using uid mock)\n        temp_dir = self.create_temp_dir()\n        file_path = temp_dir / 'test.txt'\n        file_path.touch()\n        old_time = time.time() - (10 * 86400)\n        os.utime(file_path, (old_time, old_time))\n        with patch('os.getuid', return_value=0):  # mock current user as root\n            discard_old_files(temp_dir, 5)\n        self.assertTrue(file_path.exists())\n\n    def test_do_not_delete_directories(self):\n        # Test directories are not deleted\n        temp_dir = self.create_temp_dir()\n        subdir = temp_dir / 'subdir'\n        subdir.mkdir()\n        old_time = time.time() - (10 * 86400)\n        os.utime(subdir, (old_time, old_time))\n        discard_old_files(temp_dir, 5)\n        self.assertTrue(subdir.exists())\n\n    def test_delete_file_with_zero_days(self):\n        # Test deletion with zero days (file older than now)\n        temp_dir = self.create_temp_dir()\n        file_path = temp_dir / 'test.txt'\n        file_path.touch()\n        old_time = time.time() - 1  # 1 second old\n        os.utime(file_path, (old_time, old_time))\n        discard_old_files(temp_dir, 0)\n        self.assertFalse(file_path.exists())\n\n    def test_do_not_delete_file_with_zero_days_modified_now(self):\n        # Test non-deletion when file modified at current time\n        temp_dir = self.create_temp_dir()\n        file_path = temp_dir / 'test.txt'\n        file_path.touch()\n        current_time = time.time()\n        os.utime(file_path, (current_time, current_time))\n        discard_old_files(temp_dir, 0)\n        self.assertTrue(file_path.exists())\n\n    def test_delete_file_with_negative_days(self):\n        # Test deletion with negative days (cutoff in future)\n        temp_dir = self.create_temp_dir()\n        file_path = temp_dir / 'test.txt'\n        file_path.touch()\n        discard_old_files(temp_dir, -1)\n        self.assertFalse(file_path.exists())\n\n    def test_permission_error(self):\n        # Test file remains after PermissionError\n        temp_dir = self.create_temp_dir()\n        file_path = temp_dir / 'test.txt'\n        file_path.touch()\n        old_time = time.time() - (10 * 86400)\n        os.utime(file_path, (old_time, old_time))\n        old_perms = temp_dir.stat().st_mode\n        try:\n            temp_dir.chmod(0o555)  # Make directory read-only\n            discard_old_files(temp_dir, 5)\n            self.assertTrue(file_path.exists())\n        finally:\n            temp_dir.chmod(old_perms)  # Restore permissions\n\n    def test_non_existent_path(self):\n        # Test non-existent path raises FileNotFoundError\n        non_existent = Path('/non/existent/path')\n        with self.assertRaises(FileNotFoundError):\n            discard_old_files(non_existent, 5)\n\n    def test_path_is_file(self):\n        # Test file path instead of directory raises NotADirectoryError\n        temp_dir = self.create_temp_dir()\n        file_path = temp_dir / 'test.txt'\n        file_path.touch()\n        with self.assertRaises(NotADirectoryError):\n            discard_old_files(file_path, 5)\n\n    def test_empty_directory(self):\n        # Test function handles empty directory\n        temp_dir = self.create_temp_dir()\n        discard_old_files(temp_dir, 5)  # Should complete without error\n\n    def test_directory_with_subdirectory(self):\n        # Test subdirectories and their contents are not removed\n        temp_dir = self.create_temp_dir()\n        subdir = temp_dir / 'subdir'\n        subdir.mkdir()\n        file_in_subdir = subdir / 'test.txt'\n        file_in_subdir.touch()\n        old_time = time.time() - (10 * 86400)\n        os.utime(subdir, (old_time, old_time))\n        os.utime(file_in_subdir, (old_time, old_time))\n        discard_old_files(temp_dir, 5)\n        self.assertTrue(subdir.exists())\n        self.assertTrue(file_in_subdir.exists())\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 12, "task_id": "b3658a0d"}
{"test": "import unittest\nimport os\nimport shutil\nimport tempfile\nimport time\nfrom pathlib import Path\nfrom unittest import mock\n\nclass TestPurgeExpiredFiles(unittest.TestCase):\n    \n    def setUp(self):\n        # Create a temporary directory\n        self.test_dir = Path(tempfile.mkdtemp())\n        self.current_time = time.time()\n        self.days_threshold = 7\n        self.cutoff_time = self.current_time - (self.days_threshold * 86400)\n    \n    def tearDown(self):\n        # Clean up the temporary directory\n        shutil.rmtree(self.test_dir)\n    \n    def test_delete_old_file_owned_by_current_user(self):\n        # Test deletion of an old file owned by current user\n        file_path = self.test_dir / \"old_file.txt\"\n        file_path.touch()\n        old_time = self.cutoff_time - 86400  # 1 day older than cutoff\n        os.utime(file_path, (old_time, old_time))\n        \n        with mock.patch('time.time', return_value=self.current_time):\n            purge_expired_files(self.test_dir, self.days_threshold)\n            \n        self.assertFalse(file_path.exists())\n    \n    def test_do_not_delete_new_file(self):\n        # Test that a new file is not deleted\n        file_path = self.test_dir / \"new_file.txt\"\n        file_path.touch()\n        \n        with mock.patch('time.time', return_value=self.current_time):\n            purge_expired_files(self.test_dir, self.days_threshold)\n            \n        self.assertTrue(file_path.exists())\n    \n    def test_do_not_delete_old_file_not_owned_by_user(self):\n        # Test that an old file not owned by current user is not deleted\n        file_path = self.test_dir / \"old_file_not_owned.txt\"\n        file_path.touch()\n        old_time = self.cutoff_time - 86400\n        os.utime(file_path, (old_time, old_time))\n        \n        # Mock stat to return a different UID\n        with mock.patch.object(file_path, 'stat') as mock_stat:\n            mock_stat_result = mock.Mock()\n            mock_stat_result.st_uid = os.getuid() + 1\n            mock_stat_result.st_mtime = old_time\n            mock_stat.return_value = mock_stat_result\n            \n            with mock.patch('time.time', return_value=self.current_time):\n                purge_expired_files(self.test_dir, self.days_threshold)\n                \n        self.assertTrue(file_path.exists())\n    \n    def test_do_not_delete_directory(self):\n        # Test that directories are not deleted even if old\n        dir_path = self.test_dir / \"old_dir\"\n        dir_path.mkdir()\n        old_time = self.cutoff_time - 86400\n        os.utime(dir_path, (old_time, old_time))\n        \n        with mock.patch('time.time', return_value=self.current_time):\n            purge_expired_files(self.test_dir, self.days_threshold)\n            \n        self.assertTrue(dir_path.exists())\n    \n    def test_handle_permission_error_gracefully(self):\n        # Test that PermissionError during deletion is caught and printed\n        file_path = self.test_dir / \"protected_file.txt\"\n        file_path.touch()\n        old_time = self.cutoff_time - 86400\n        os.utime(file_path, (old_time, old_time))\n        \n        with mock.patch.object(file_path, 'unlink', side_effect=PermissionError(\"Access denied\")) as mock_unlink, \\\n             mock.patch('builtins.print') as mock_print, \\\n             mock.patch('time.time', return_value=self.current_time):\n                \n            purge_expired_files(self.test_dir, self.days_threshold)\n            \n            mock_print.assert_called_once_with(f\"Failed to delete {file_path}: Access denied\")\n        self.assertTrue(file_path.exists())\n    \n    def test_do_not_delete_symlink(self):\n        # Test that symlinks are not followed/deleted\n        target_file = self.test_dir / \"target.txt\"\n        target_file.touch()\n        symlink_path = self.test_dir / \"symlink\"\n        symlink_path.symlink_to(target_file)\n        old_time = self.cutoff_time - 86400\n        os.utime(symlink_path, (old_time, old_time), follow_symlinks=False)\n        \n        with mock.patch('time.time', return_value=self.current_time):\n            purge_expired_files(self.test_dir, self.days_threshold)\n            \n        self.assertTrue(symlink_path.exists())\n        self.assertTrue(target_file.exists())\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 6, "task_id": "ae07d364"}
{"test": "import unittest\nfrom unittest.mock import patch, Mock\nfrom pathlib import Path\nimport os\n\nclass TestUpdateFilePermissions(unittest.TestCase):\n\n    @patch('os.getuid')\n    def test_happy_path(self, mock_getuid):\n        # Test with file owned by current user and valid permissions\n        mock_getuid.return_value = 1000\n        mock_path = Mock(spec=Path)\n        mock_stat = mock_path.stat.return_value\n        mock_stat.st_uid = 1000\n        result = update_file_permissions(mock_path, 0o644)\n        mock_path.chmod.assert_called_once_with(0o644)\n        self.assertIsNone(result)\n\n    @patch('os.getuid')\n    def test_not_owned(self, mock_getuid):\n        # Test with file not owned by current user\n        mock_getuid.return_value = 1000\n        mock_path = Mock(spec=Path)\n        mock_stat = mock_path.stat.return_value\n        mock_stat.st_uid = 1001\n        result = update_file_permissions(mock_path, 0o644)\n        mock_path.chmod.assert_not_called()\n        self.assertIsNone(result)\n\n    @patch('os.getuid')\n    @patch('builtins.print')\n    def test_permission_error(self, mock_print, mock_getuid):\n        # Test when chmod raises PermissionError\n        mock_getuid.return_value = 1000\n        mock_path = Mock(spec=Path)\n        mock_stat = mock_path.stat.return_value\n        mock_stat.st_uid = 1000\n        error = PermissionError('Operation not permitted')\n        mock_path.chmod.side_effect = error\n        mock_path.__str__.return_value = '/test/file.txt'\n        result = update_file_permissions(mock_path, 0o644)\n        mock_print.assert_called_once_with('Failed to change /test/file.txt permission to 420: Operation not permitted')\n        self.assertIsNone(result)\n\n    @patch('os.getuid')\n    def test_file_not_found(self, mock_getuid):\n        # Test when file does not exist\n        mock_getuid.return_value = 1000\n        mock_path = Mock(spec=Path)\n        error = FileNotFoundError('File not found')\n        mock_path.stat.side_effect = error\n        with self.assertRaises(FileNotFoundError):\n            update_file_permissions(mock_path, 0o644)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 4, "task_id": "519450a9"}
{"test": "import unittest\nfrom unittest.mock import patch, MagicMock\nfrom pathlib import Path\nimport os\nfrom solution import modify_file_permissions\n\nclass TestCases(unittest.TestCase):\n\n    @patch('os.getuid')\n    def test_case_1(self, mock_getuid):\n        # Happy path: typical mode (0o644), user is owner, chmod succeeds.\n        mock_getuid.return_value = 1000\n        mock_file = MagicMock(spec=Path)\n        mock_stat = MagicMock()\n        mock_stat.st_uid = 1000\n        mock_file.stat.return_value = mock_stat\n        result = modify_file_permissions(mock_file, 0o644)\n        mock_file.chmod.assert_called_once_with(0o644)\n        self.assertIsNone(result)\n\n    @patch('os.getuid')\n    def test_case_2(self, mock_getuid):\n        # Happy path: edge mode (0o000), user is owner, chmod succeeds.\n        mock_getuid.return_value = 1000\n        mock_file = MagicMock(spec=Path)\n        mock_stat = MagicMock()\n        mock_stat.st_uid = 1000\n        mock_file.stat.return_value = mock_stat\n        result = modify_file_permissions(mock_file, 0o000)\n        mock_file.chmod.assert_called_once_with(0o000)\n        self.assertIsNone(result)\n\n    @patch('os.getuid')\n    @patch('builtins.print')\n    def test_case_3(self, mock_print, mock_getuid):\n        # Owner, but chmod raises PermissionError.\n        mock_getuid.return_value = 1000\n        mock_file = MagicMock(spec=Path)\n        mock_stat = MagicMock()\n        mock_stat.st_uid = 1000\n        mock_file.stat.return_value = mock_stat\n        mock_file.chmod.side_effect = PermissionError('Permission denied')\n        result = modify_file_permissions(mock_file, 0o644)\n        mock_print.assert_called_once()\n        self.assertIsNone(result)\n\n    @patch('os.getuid')\n    def test_case_4(self, mock_getuid):\n        # User is not the owner.\n        mock_getuid.return_value = 1000\n        mock_file = MagicMock(spec=Path)\n        mock_stat = MagicMock()\n        mock_stat.st_uid = 1001\n        mock_file.stat.return_value = mock_stat\n        result = modify_file_permissions(mock_file, 0o644)\n        mock_file.chmod.assert_not_called()\n        self.assertIsNone(result)\n\n    @patch('os.getuid')\n    def test_case_5(self, mock_getuid):\n        # File not found.\n        mock_getuid.return_value = 1000\n        mock_file = MagicMock(spec=Path)\n        mock_file.stat.side_effect = FileNotFoundError('File not found')\n        with self.assertRaises(FileNotFoundError):\n            modify_file_permissions(mock_file, 0o644)\n", "num_test_cases": 5, "task_id": "8b207583"}
{"test": "import unittest\nimport os\nfrom pathlib import Path\nfrom unittest.mock import patch, MagicMock\n\nclass TestChangeFilePermissions(unittest.TestCase):\n    \n    @patch('os.getuid')\n    def test_happy_path_owned_file(self, mock_getuid):\n        \"\"\"Test changing permissions successfully when file is owned by current user.\"\"\"\n        mock_getuid.return_value = 1000\n        mock_file = MagicMock(spec=Path)\n        mock_file.stat.return_value.st_uid = 1000\n        \n        change_file_permissions(mock_file, 0o644)\n        \n        mock_file.chmod.assert_called_once_with(0o644)\n\n    @patch('os.getuid')\n    @patch('builtins.print')\n    def test_permission_error_handling(self, mock_print, mock_getuid):\n        \"\"\"Test PermissionError during chmod is caught and prints error message.\"\"\"\n        mock_getuid.return_value = 1000\n        mock_file = MagicMock(spec=Path)\n        mock_file.stat.return_value.st_uid = 1000\n        mock_file.chmod.side_effect = PermissionError(\"Operation not permitted\")\n        \n        change_file_permissions(mock_file, 0o600)\n        \n        mock_print.assert_called_once_with(f\"Failed to change {mock_file} permission to 0o600: Operation not permitted\")\n\n    @patch('os.getuid')\n    def test_not_owned_file(self, mock_getuid):\n        \"\"\"Test no action when file is not owned by current user.\"\"\"\n        mock_getuid.return_value = 1000\n        mock_file = MagicMock(spec=Path)\n        mock_file.stat.return_value.st_uid = 1001\n        \n        change_file_permissions(mock_file, 0o644)\n        \n        mock_file.chmod.assert_not_called()\n\n    def test_file_not_found(self):\n        \"\"\"Test FileNotFoundError when file does not exist.\"\"\"\n        mock_file = MagicMock(spec=Path)\n        mock_file.stat.side_effect = FileNotFoundError(\"File not found\")\n        \n        with self.assertRaises(FileNotFoundError):\n            change_file_permissions(mock_file, 0o644)\n\n    @patch('os.getuid')\n    def test_edge_case_zero_permissions(self, mock_getuid):\n        \"\"\"Test setting extreme permission mode (0o000) on owned file.\"\"\"\n        mock_getuid.return_value = 1000\n        mock_file = MagicMock(spec=Path)\n        mock_file.stat.return_value.st_uid = 1000\n        \n        change_file_permissions(mock_file, 0o000)\n        \n        mock_file.chmod.assert_called_once_with(0o000)\n\n    @patch('os.getuid')\n    def test_edge_case_full_permissions(self, mock_getuid):\n        \"\"\"Test setting full permissions (0o777) on owned file.\"\"\"\n        mock_getuid.return_value = 1000\n        mock_file = MagicMock(spec=Path)\n        mock_file.stat.return_value.st_uid = 1000\n        \n        change_file_permissions(mock_file, 0o777)\n        \n        mock_file.chmod.assert_called_once_with(0o777)\n\n    @patch('os.getuid')\n    def test_edge_case_large_octal_permissions(self, mock_getuid):\n        \"\"\"Test with a large octal permission mode (0o7777).\"\"\"\n        mock_getuid.return_value = 1000\n        mock_file = MagicMock(spec=Path)\n        mock_file.stat.return_value.st_uid = 1000\n        \n        change_file_permissions(mock_file, 0o7777)\n        \n        mock_file.chmod.assert_called_once_with(0o7777)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 7, "task_id": "b02b99f6"}
{"test": "import unittest\nfrom unittest.mock import MagicMock, patch\nfrom pathlib import Path\nimport os\nfrom solution import adjust_file_permissions\n\nclass TestAdjustFilePermissions(unittest.TestCase):\n    @patch('os.getuid')\n    def test_owner_success(self, mock_getuid):\n        # Test with owner and valid permission (0o600)\n        mock_getuid.return_value = 1000\n        mock_path = MagicMock(spec=Path)\n        mock_path.stat.return_value.st_uid = 1000\n        perm = 0o600\n        adjust_file_permissions(mock_path, perm)\n        mock_path.chmod.assert_called_once_with(perm)\n\n    @patch('os.getuid')\n    def test_non_owner(self, mock_getuid):\n        # Test with non-owner (should not change permissions)\n        mock_getuid.return_value = 1000\n        mock_path = MagicMock(spec=Path)\n        mock_path.stat.return_value.st_uid = 1001\n        perm = 0o600\n        adjust_file_permissions(mock_path, perm)\n        mock_path.chmod.assert_not_called()\n\n    @patch('os.getuid')\n    @patch('builtins.print')\n    def test_owner_permission_error(self, mocked_print, mock_getuid):\n        # Test owner but chmod raises PermissionError\n        mock_getuid.return_value = 1000\n        mock_path = MagicMock(spec=Path)\n        mock_path.stat.return_value.st_uid = 1000\n        error = PermissionError(\"mock permission denied\")\n        mock_path.chmod.side_effect = error\n        mock_path.__str__.return_value = '/fake/path'\n        perm = 0o600\n        adjust_file_permissions(mock_path, perm)\n        expected_message = f\"Failed to change /fake/path permission to {perm}: mock permission denied\"\n        mocked_print.assert_called_once_with(expected_message)\n\n    @patch('os.getuid')\n    def test_owner_zero_permission(self, mock_getuid):\n        # Test owner with permission 0 (edge case)\n        mock_getuid.return_value = 1000\n        mock_path = MagicMock(spec=Path)\n        mock_path.stat.return_value.st_uid = 1000\n        perm = 0\n        adjust_file_permissions(mock_path, perm)\n        mock_path.chmod.assert_called_once_with(perm)\n\n    @patch('os.getuid')\n    def test_owner_negative_permission(self, mock_getuid):\n        # Test owner with invalid negative permission (edge case)\n        mock_getuid.return_value = 1000\n        mock_path = MagicMock(spec=Path)\n        mock_path.stat.return_value.st_uid = 1000\n        perm = -1\n        with self.assertRaises(ValueError):\n            adjust_file_permissions(mock_path, perm)\n\n    @patch('os.getuid')\n    def test_non_owner_zero_permission(self, mock_getuid):\n        # Test non-owner with permission 0 (edge case)\n        mock_getuid.return_value = 1000\n        mock_path = MagicMock(spec=Path)\n        mock_path.stat.return_value.st_uid = 1001\n        perm = 0\n        adjust_file_permissions(mock_path, perm)\n        mock_path.chmod.assert_not_called()\n\n    @patch('os.getuid')\n    def test_non_owner_negative_permission(self, mock_getuid):\n        # Test non-owner with invalid negative permission (edge case)\n        mock_getuid.return_value = 1000\n        mock_path = MagicMock(spec=Path)\n        mock_path.stat.return_value.st_uid = 1001\n        perm = -1\n        adjust_file_permissions(mock_path, perm)\n        mock_path.chmod.assert_not_called()\n\n    @patch('os.getuid')\n    def test_file_not_found(self, mock_getuid):\n        # Test when file does not exist (edge case)\n        mock_getuid.return_value = 1000\n        mock_path = MagicMock(spec=Path)\n        mock_path.stat.side_effect = FileNotFoundError(\"File not found\")\n        perm = 0o600\n        with self.assertRaises(FileNotFoundError):\n            adjust_file_permissions(mock_path, perm)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 8, "task_id": "da0b3dd8"}
{"test": "import unittest\nfrom unittest.mock import patch, MagicMock\nimport os\nfrom pathlib import Path\n\nclass TestModifyFilePermissions(unittest.TestCase):\n\n    def test_owner_permission_change_success(self):\n        # Test changing permissions when current user is owner (happy path)\n        mock_file = MagicMock(spec=Path)\n        mock_file.stat.return_value.st_uid = 1000\n        with patch('os.getuid', return_value=1000):\n            modify_file_permissions(mock_file, 0o644)\n            mock_file.chmod.assert_called_once_with(0o644)\n\n    def test_different_permission_values(self):\n        # Test with various valid permission values\n        mock_file = MagicMock(spec=Path)\n        mock_file.stat.return_value.st_uid = 1000\n        with patch('os.getuid', return_value=1000):\n            for perm in [0o600, 0o755, 0o400]:\n                mock_file.reset_mock()\n                modify_file_permissions(mock_file, perm)\n                mock_file.chmod.assert_called_once_with(perm)\n\n    def test_not_owner(self):\n        # Test when current user is not the owner (should not change permissions)\n        mock_file = MagicMock(spec=Path)\n        mock_file.stat.return_value.st_uid = 1000\n        with patch('os.getuid', return_value=1001):\n            modify_file_permissions(mock_file, 0o644)\n            mock_file.chmod.assert_not_called()\n\n    def test_permission_error_handling(self):\n        # Test PermissionError handling during chmod operation\n        mock_file = MagicMock(spec=Path)\n        mock_file.__str__.return_value = '/path/to/file'\n        mock_file.stat.return_value.st_uid = 1000\n        mock_file.chmod.side_effect = PermissionError('Operation not permitted')\n        with patch('os.getuid', return_value=1000), patch('builtins.print') as mock_print:\n            modify_file_permissions(mock_file, 0o644)\n            mock_print.assert_called_once_with('Failed to change /path/to/file permission to 420: Operation not permitted')\n\n    def test_file_not_found(self):\n        # Test behavior when file does not exist\n        mock_file = MagicMock(spec=Path)\n        mock_file.stat.side_effect = FileNotFoundError('File not found')\n        with patch('os.getuid', return_value=1000):\n            with self.assertRaises(FileNotFoundError):\n                modify_file_permissions(mock_file, 0o644)\n\n    def test_invalid_permission_type(self):\n        # Test with non-integer permission values\n        mock_file = MagicMock(spec=Path)\n        mock_file.stat.return_value.st_uid = 1000\n        with patch('os.getuid', return_value=1000):\n            with self.assertRaises(TypeError):\n                modify_file_permissions(mock_file, '644')\n\n    def test_negative_permission_value(self):\n        # Test with negative permission value\n        mock_file = MagicMock(spec=Path)\n        mock_file.stat.return_value.st_uid = 1000\n        with patch('os.getuid', return_value=1000):\n            with self.assertRaises(ValueError):\n                modify_file_permissions(mock_file, -1)\n\n    def test_extremely_large_permission_value(self):\n        # Test with excessively large permission value\n        mock_file = MagicMock(spec=Path)\n        mock_file.stat.return_value.st_uid = 1000\n        with patch('os.getuid', return_value=1000):\n            modify_file_permissions(mock_file, 0o7777)\n            mock_file.chmod.assert_called_once_with(0o7777)", "num_test_cases": 8, "task_id": "8c376e30"}
{"test": "import unittest\nfrom unittest.mock import patch, MagicMock\nfrom pathlib import Path\nimport os\n\nclass TestChangeFileAccess(unittest.TestCase):\n\n    def test_happy_path(self):\n        # Test when file is owned by current user and chmod succeeds\n        mock_path = MagicMock(spec=Path)\n        mock_path.stat.return_value.st_uid = 1000\n        mock_uid = 1000\n\n        with patch('os.getuid', return_value=mock_uid):\n            result = change_file_access(mock_path, 0o600)\n\n        mock_path.chmod.assert_called_once_with(0o600)\n        self.assertIsNone(result)\n\n    def test_permission_error(self):\n        # Test when chmod raises PermissionError for owned file\n        mock_path = MagicMock(spec=Path)\n        mock_path.stat.return_value.st_uid = 1000\n        mock_path.chmod.side_effect = PermissionError(\\\"Operation not permitted\\\")\n        mock_uid = 1000\n\n        with patch('os.getuid', return_value=mock_uid), patch('builtins.print') as mock_print:\n            result = change_file_access(mock_path, 0o600)\n\n        mock_path.chmod.assert_called_once_with(0o600)\n        self.assertIsNone(result)\n        mock_print.assert_called_once()\n        args, _ = mock_print.call_args\n        self.assertIn(str(mock_path), args[0])\n        self.assertIn('384', args[0])  # 0o600 decimal representation\n        self.assertIn(\\\"Operation not permitted\\\", args[0])\n\n    def test_not_owned(self):\n        # Test when file is not owned by current user\n        mock_path = MagicMock(spec=Path)\n        mock_path.stat.return_value.st_uid = 1000\n        mock_uid = 1001\n\n        with patch('os.getuid', return_value=mock_uid):\n            result = change_file_access(mock_path, 0o600)\n\n        mock_path.chmod.assert_not_called()\n        self.assertIsNone(result)\n\n    def test_file_not_found(self):\n        # Test when file does not exist\n        mock_path = MagicMock(spec=Path)\n        mock_path.stat.side_effect = FileNotFoundError(\\\"No such file or directory\\\")\n        mock_uid = 1000\n\n        with patch('os.getuid', return_value=mock_uid):\n            with self.assertRaises(FileNotFoundError):\n                change_file_access(mock_path, 0o600)\n\n    def test_invalid_access_bits(self):\n        # Test invalid access_bits (negative) for owned file\n        mock_path = MagicMock(spec=Path)\n        mock_path.stat.return_value.st_uid = 1000\n        mock_uid = 1000\n        mock_path.chmod.side_effect = OSError(\\\"Invalid argument\\\")\n\n        with patch('os.getuid', return_value=mock_uid):\n            with self.assertRaises(OSError):\n                change_file_access(mock_path, -1)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 5, "task_id": "40baa3f0"}
{"test": "import unittest\nimport unittest.mock\nimport errno\nimport os\nfrom pathlib import Path\n\nclass TestModifyFilePermissions(unittest.TestCase):\n\n    @unittest.mock.patch('os.getuid')\n    def test_happy_path(self, mock_getuid):\n        \"\"\"Test successful permission change when file is owned by current user.\"\"\"\n        mock_getuid.return_value = 1000\n        mock_path = unittest.mock.Mock()\n        mock_path.stat.return_value.st_uid = 1000\n        modify_file_permissions(mock_path, 0o644)\n        mock_path.chmod.assert_called_once_with(0o644)\n\n    @unittest.mock.patch('os.getuid')\n    def test_permission_error(self, mock_getuid):\n        \"\"\"Test PermissionError is caught and printed when changing permissions fails.\"\"\"\n        mock_getuid.return_value = 1000\n        mock_path = unittest.mock.Mock()\n        mock_path.__str__.return_value = '/test/file.txt'\n        mock_path.stat.return_value.st_uid = 1000\n        mock_path.chmod.side_effect = PermissionError(\"Operation not permitted\")\n        with unittest.mock.patch('builtins.print') as mock_print:\n            modify_file_permissions(mock_path, 0o644)\n            mock_print.assert_called_once()\n            args, _ = mock_print.call_args\n            self.assertIn('/test/file.txt', args[0])\n            self.assertIn('0o644', args[0])\n            self.assertIn('Operation not permitted', args[0])\n\n    @unittest.mock.patch('os.getuid')\n    def test_not_owned(self, mock_getuid):\n        \"\"\"Test no permission change when file is not owned by current user.\"\"\"\n        mock_getuid.return_value = 1000\n        mock_path = unittest.mock.Mock()\n        mock_path.stat.return_value.st_uid = 2000\n        modify_file_permissions(mock_path, 0o644)\n        mock_path.chmod.assert_not_called()\n\n    def test_file_not_found(self):\n        \"\"\"Test FileNotFoundError raised when file does not exist.\"\"\"\n        mock_path = unittest.mock.Mock()\n        mock_path.stat.side_effect = FileNotFoundError(\"File not found\")\n        with self.assertRaises(FileNotFoundError):\n            modify_file_permissions(mock_path, 0o644)\n\n    @unittest.mock.patch('os.getuid')\n    def test_os_error_other(self, mock_getuid):\n        \"\"\"Test OSError (other than PermissionError) is raised during chmod.\"\"\"\n        mock_getuid.return_value = 1000\n        mock_path = unittest.mock.Mock()\n        mock_path.stat.return_value.st_uid = 1000\n        mock_path.chmod.side_effect = OSError(errno.EINVAL, \"Invalid argument\")\n        with self.assertRaises(OSError):\n            modify_file_permissions(mock_path, 0o644)\n\n    @unittest.mock.patch('os.getuid')\n    def test_non_integer_permission(self, mock_getuid):\n        \"\"\"Test TypeError raised when permission value is not an integer.\"\"\"\n        mock_getuid.return_value = 1000\n        mock_path = unittest.mock.Mock()\n        mock_path.stat.return_value.st_uid = 1000\n        with self.assertRaises(TypeError):\n            modify_file_permissions(mock_path, \"644\")\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 6, "task_id": "6506c107"}
{"test": "import unittest\nfrom unittest.mock import patch, MagicMock\nfrom pathlib import Path\n\n# Import the function from the solution module\nfrom solution import update_file_permissions\n\nclass TestUpdateFilePermissions(unittest.TestCase):\n\n    def test_owned_success(self):\n        # Test when current user owns file and chmod succeeds\n        with patch('solution.os.getuid', return_value=1000):\n            mock_path = MagicMock(spec=Path)\n            mock_path.stat.return_value.st_uid = 1000\n            result = update_file_permissions(mock_path, 0o644)\n            mock_path.chmod.assert_called_once_with(0o644)\n            self.assertIsNone(result)\n\n    def test_not_owned(self):\n        # Test when current user does not own the file\n        with patch('solution.os.getuid', return_value=1000):\n            mock_path = MagicMock(spec=Path)\n            mock_path.stat.return_value.st_uid = 1001\n            result = update_file_permissions(mock_path, 0o644)\n            mock_path.chmod.assert_not_called()\n            self.assertIsNone(result)\n\n    def test_owned_but_permission_error(self):\n        # Test when user owns file but chmod raises PermissionError\n        with patch('solution.os.getuid', return_value=1000):\n            mock_path = MagicMock(spec=Path)\n            mock_path.stat.return_value.st_uid = 1000\n            mock_path.chmod.side_effect = PermissionError('Permission denied')\n            with patch('builtins.print') as mock_print:\n                result = update_file_permissions(mock_path, 0o644)\n                mock_path.chmod.assert_called_once_with(0o644)\n                mock_print.assert_called_once_with(f'Failed to change {mock_path} permission to 420: Permission denied')\n                self.assertIsNone(result)\n\n    def test_non_existent_file(self):\n        # Test when the file does not exist\n        with patch('solution.os.getuid', return_value=1000):\n            mock_path = MagicMock(spec=Path)\n            mock_path.stat.side_effect = FileNotFoundError('File not found')\n            with self.assertRaises(FileNotFoundError):\n                update_file_permissions(mock_path, 0o644)\n\n    def test_invalid_path_type(self):\n        # Test with invalid path type (string instead of Path)\n        with self.assertRaises(AttributeError):\n            update_file_permissions('invalid_path', 0o644)\n\n    def test_invalid_permission_type(self):\n        # Test with non-integer permission value\n        with patch('solution.os.getuid', return_value=1000):\n            mock_path = MagicMock(spec=Path)\n            mock_path.stat.return_value.st_uid = 1000\n            with self.assertRaises(TypeError):\n                update_file_permissions(mock_path, '644')\n\n    def test_negative_permission_value(self):\n        # Test with negative permission value\n        with patch('solution.os.getuid', return_value=1000):\n            mock_path = MagicMock(spec=Path)\n            mock_path.stat.return_value.st_uid = 1000\n            mock_path.chmod.side_effect = ValueError('invalid mode')\n            with self.assertRaises(ValueError):\n                update_file_permissions(mock_path, -1)\n\n    def test_large_permission_value(self):\n        # Test with excessively large permission value\n        with patch('solution.os.getuid', return_value=1000):\n            mock_path = MagicMock(spec=Path)\n            mock_path.stat.return_value.st_uid = 1000\n            mock_path.chmod.side_effect = ValueError('invalid mode')\n            with self.assertRaises(ValueError):\n                update_file_permissions(mock_path, 0o100000)\n", "num_test_cases": 8, "task_id": "fbc22240"}
{"test": "import unittest\nfrom unittest.mock import patch, MagicMock\nfrom pathlib import Path\nimport os\n\nclass TestChangeFilePermissions(unittest.TestCase):\n\n    def test_owned_success(self):\n        # Test when the file is owned by the current user and the permission change is successful.\n        mock_file = MagicMock(spec=Path)\n        mock_file.stat.return_value.st_uid = 1000\n        with patch('os.getuid', return_value=1000):\n            result = change_file_permissions(mock_file, 0o644)\n            mock_file.chmod.assert_called_once_with(0o644)\n            self.assertIsNone(result)\n\n    def test_owned_permission_error(self):\n        # Test when the file is owned but changing permission results in PermissionError.\n        mock_file = MagicMock(spec=Path)\n        mock_file.stat.return_value.st_uid = 1000\n        mock_file.__str__.return_value = '/some/file'\n        mock_file.chmod.side_effect = PermissionError('Operation not permitted')\n        new_perms = 0o644\n        with patch('os.getuid', return_value=1000), patch('builtins.print') as mock_print:\n            result = change_file_permissions(mock_file, new_perms)\n            mock_file.chmod.assert_called_once_with(new_perms)\n            self.assertIsNone(result)\n            expected_message = 'Failed to change /some/file permission to 420: Operation not permitted'\n            mock_print.assert_called_once_with(expected_message)\n\n    def test_not_owned(self):\n        # Test when the file is not owned by the current user: no change attempted.\n        mock_file = MagicMock(spec=Path)\n        mock_file.stat.return_value.st_uid = 1001\n        with patch('os.getuid', return_value=1000):\n            result = change_file_permissions(mock_file, 0o644)\n            mock_file.chmod.assert_not_called()\n            self.assertIsNone(result)\n\n    def test_file_not_found(self):\n        # Test when the file does not exist (raises FileNotFoundError).\n        mock_file = MagicMock(spec=Path)\n        mock_file.stat.side_effect = FileNotFoundError\n        with patch('os.getuid', return_value=1000):\n            with self.assertRaises(FileNotFoundError):\n                change_file_permissions(mock_file, 0o644)\n\n    def test_non_integer_perms(self):\n        # Test passing a non-integer for new_perms (raises TypeError).\n        mock_file = MagicMock(spec=Path)\n        mock_file.stat.return_value.st_uid = 1000\n        mock_file.chmod.side_effect = TypeError\n        with patch('os.getuid', return_value=1000):\n            with self.assertRaises(TypeError):\n                change_file_permissions(mock_file, '644')\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 5, "task_id": "49212da5"}
{"test": "import unittest\nfrom unittest.mock import patch, MagicMock\nfrom solution import safe_copy_files\n\nclass TestSafeCopyFiles(unittest.TestCase):\n\n    @patch('solution.shutil.copy')\n    @patch('solution.os.getuid')\n    @patch('builtins.print')\n    def test_happy_path(self, mock_print, mock_getuid, mock_copy):\n        \"\"\"Test copying files when destination is owned by current user.\"\"\"\n        mock_getuid.return_value = 1000\n        src_dir = MagicMock()\n        dest_dir = MagicMock()\n        dest_dir.stat.return_value.st_uid = 1000\n        file1 = MagicMock()\n        file1.is_file.return_value = True\n        file2 = MagicMock()\n        file2.is_file.return_value = True\n        src_dir.iterdir.return_value = [file1, file2]\n        file1.__str__.return_value = '/mocked/src/file1.txt'\n        file2.__str__.return_value = '/mocked/src/file2.txt'\n        dest_dir.__str__.return_value = '/mocked/dest'\n\n        safe_copy_files(src_dir, dest_dir)\n\n        self.assertEqual(mock_copy.call_count, 2)\n        mock_copy.assert_any_call(file1, dest_dir)\n        mock_copy.assert_any_call(file2, dest_dir)\n        mock_print.assert_not_called()\n\n    @patch('solution.shutil.copy')\n    @patch('solution.os.getuid')\n    @patch('builtins.print')\n    def test_destination_not_owned(self, mock_print, mock_getuid, mock_copy):\n        \"\"\"Test destination not owned by current user prevents copying.\"\"\"\n        mock_getuid.return_value = 1000\n        src_dir = MagicMock()\n        dest_dir = MagicMock()\n        dest_dir.stat.return_value.st_uid = 1001\n        dest_dir.__str__.return_value = '/mocked/dest'\n\n        safe_copy_files(src_dir, dest_dir)\n\n        mock_print.assert_called_once_with('Target directory /mocked/dest is not owned by the current user.')\n        mock_copy.assert_not_called()\n\n    @patch('solution.shutil.copy')\n    @patch('solution.os.getuid')\n    @patch('builtins.print')\n    def test_permission_error_during_copy(self, mock_print, mock_getuid, mock_copy):\n        \"\"\"Test PermissionError during copying handles gracefully.\"\"\"\n        mock_getuid.return_value = 1000\n        src_dir = MagicMock()\n        dest_dir = MagicMock()\n        dest_dir.stat.return_value.st_uid = 1000\n        file1 = MagicMock()\n        file1.is_file.return_value = True\n        file2 = MagicMock()\n        file2.is_file.return_value = True\n        src_dir.iterdir.return_value = [file1, file2]\n        file1.__str__.return_value = '/mocked/src/file1.txt'\n        file2.__str__.return_value = '/mocked/src/file2.txt'\n        dest_dir.__str__.return_value = '/mocked/dest'\n\n        mock_copy.side_effect = PermissionError('permission denied')\n\n        safe_copy_files(src_dir, dest_dir)\n\n        mock_print.assert_called_once_with('Failed to copy /mocked/src/file1.txt to /mocked/dest: permission denied')\n        mock_copy.assert_called_once_with(file1, dest_dir)\n\n    @patch('solution.shutil.copy')\n    @patch('solution.os.getuid')\n    @patch('builtins.print')\n    def test_empty_source_directory(self, mock_print, mock_getuid, mock_copy):\n        \"\"\"Test source directory with no files.\"\"\"\n        mock_getuid.return_value = 1000\n        src_dir = MagicMock()\n        dest_dir = MagicMock()\n        dest_dir.stat.return_value.st_uid = 1000\n        src_dir.iterdir.return_value = []\n\n        safe_copy_files(src_dir, dest_dir)\n\n        mock_copy.assert_not_called()\n        mock_print.assert_not_called()\n\n    @patch('solution.shutil.copy')\n    @patch('solution.os.getuid')\n    @patch('builtins.print')\n    def test_mix_of_files_and_directories(self, mock_print, mock_getuid, mock_copy):\n        \"\"\"Test source with mix of files and directories (only files copied).\"\"\"\n        mock_getuid.return_value = 1000\n        src_dir = MagicMock()\n        dest_dir = MagicMock()\n        dest_dir.stat.return_value.st_uid = 1000\n        file1 = MagicMock()\n        file1.is_file.return_value = True\n        dir1 = MagicMock()\n        dir1.is_file.return_value = False\n        src_dir.iterdir.return_value = [file1, dir1]\n        file1.__str__.return_value = '/mocked/src/file1.txt'\n        dir1.__str__.return_value = '/mocked/src/dir1'\n        dest_dir.__str__.return_value = '/mocked/dest'\n\n        safe_copy_files(src_dir, dest_dir)\n\n        mock_copy.assert_called_once_with(file1, dest_dir)\n        mock_print.assert_not_called()\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 5, "task_id": "1744cd79"}
{"test": "import unittest\nfrom unittest.mock import patch, Mock\nfrom pathlib import Path\nimport os\nimport shutil\nfrom solution_module import validated_copy_files\n\nclass TestCases(unittest.TestCase):\n\n    @patch('shutil.copy')\n    @patch('os.getuid')\n    @patch('builtins.print')\n    def test_case_1(self, mock_print, mock_getuid, mock_copy):\n        \"\"\"Test copying files when target directory is owned by current user.\"\"\"\n        mock_getuid.return_value = 1000\n        directory_from = Mock(spec=Path)\n        directory_to = Mock(spec=Path)\n        stat_mock = Mock()\n        stat_mock.st_uid = 1000\n        directory_to.stat.return_value = stat_mock\n        file1 = Mock()\n        file1.is_file.return_value = True\n        file2 = Mock()\n        file2.is_file.return_value = True\n        directory_from.iterdir.return_value = [file1, file2]\n        \n        validated_copy_files(directory_from, directory_to)\n        \n        self.assertEqual(mock_copy.call_count, 2)\n        mock_copy.assert_any_call(file1, directory_to)\n        mock_copy.assert_any_call(file2, directory_to)\n        mock_print.assert_not_called()\n\n    @patch('shutil.copy')\n    @patch('os.getuid')\n    @patch('builtins.print')\n    def test_case_2(self, mock_print, mock_getuid, mock_copy):\n        \"\"\"Test that files are not copied when target directory is not owned by current user.\"\"\"\n        mock_getuid.return_value = 1000\n        directory_from = Mock(spec=Path)\n        directory_to = Mock(spec=Path)\n        stat_mock = Mock()\n        stat_mock.st_uid = 1001\n        directory_to.stat.return_value = stat_mock\n        \n        validated_copy_files(directory_from, directory_to)\n        \n        mock_copy.assert_not_called()\n        mock_print.assert_called_once_with(f\"Directory {directory_to} is not owned by the current user.\")\n\n    @patch('shutil.copy')\n    @patch('os.getuid')\n    @patch('builtins.print')\n    def test_case_3(self, mock_print, mock_getuid, mock_copy):\n        \"\"\"Test PermissionError during file copy prints error and aborts further copying.\"\"\"\n        mock_getuid.return_value = 1000\n        directory_from = Mock(spec=Path)\n        directory_to = Mock(spec=Path)\n        stat_mock = Mock()\n        stat_mock.st_uid = 1000\n        directory_to.stat.return_value = stat_mock\n        file1 = Mock()\n        file1.is_file.return_value = True\n        file2 = Mock()\n        file2.is_file.return_value = True\n        directory_from.iterdir.return_value = [file1, file2]\n        mock_copy.side_effect = PermissionError(\"permission denied\")\n        \n        validated_copy_files(directory_from, directory_to)\n        \n        mock_copy.assert_called_once_with(file1, directory_to)\n        mock_print.assert_called_once_with(f\"Failure during copying {file1} to {directory_to}: permission denied\")\n\n    @patch('shutil.copy')\n    @patch('os.getuid')\n    @patch('builtins.print')\n    def test_case_4(self, mock_print, mock_getuid, mock_copy):\n        \"\"\"Test copying from an empty source directory.\"\"\"\n        mock_getuid.return_value = 1000\n        directory_from = Mock(spec=Path)\n        directory_to = Mock(spec=Path)\n        stat_mock = Mock()\n        stat_mock.st_uid = 1000\n        directory_to.stat.return_value = stat_mock\n        directory_from.iterdir.return_value = []\n        \n        validated_copy_files(directory_from, directory_to)\n        \n        mock_copy.assert_not_called()\n        mock_print.assert_not_called()\n\n    @patch('shutil.copy')\n    @patch('os.getuid')\n    @patch('builtins.print')\n    def test_case_5(self, mock_print, mock_getuid, mock_copy):\n        \"\"\"Test only files are copied (directories are skipped).\"\"\"\n        mock_getuid.return_value = 1000\n        directory_from = Mock(spec=Path)\n        directory_to = Mock(spec=Path)\n        stat_mock = Mock()\n        stat_mock.st_uid = 1000\n        directory_to.stat.return_value = stat_mock\n        file1 = Mock()\n        file1.is_file.return_value = True\n        directory_item = Mock()\n        directory_item.is_file.return_value = False\n        file2 = Mock()\n        file2.is_file.return_value = True\n        directory_from.iterdir.return_value = [file1, directory_item, file2]\n        \n        validated_copy_files(directory_from, directory_to)\n        \n        self.assertEqual(mock_copy.call_count, 2)\n        mock_copy.assert_any_call(file1, directory_to)\n        mock_copy.assert_any_call(file2, directory_to)\n        mock_print.assert_not_called()\n\n    @patch('shutil.copy')\n    @patch('os.getuid')\n    @patch('builtins.print')\n    def test_case_6(self, mock_print, mock_getuid, mock_copy):\n        \"\"\"Test PermissionError when accessing target directory's stat.\"\"\"\n        mock_getuid.return_value = 1000\n        directory_from = Mock(spec=Path)\n        directory_to = Mock(spec=Path)\n        directory_to.stat.side_effect = PermissionError(\"stat permission denied\")\n        \n        with self.assertRaises(PermissionError):\n            validated_copy_files(directory_from, directory_to)\n        \n        mock_copy.assert_not_called()\n        mock_print.assert_not_called()\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 6, "task_id": "d8de24d3"}
{"test": "import unittest\nimport os\nimport shutil\nfrom pathlib import Path\nfrom tempfile import TemporaryDirectory\nfrom unittest.mock import patch, MagicMock\n\nclass TestCopyFilesSafely(unittest.TestCase):\n\n    def test_happy_path(self):\n        # Test successful copy when target directory is owned by current user\n        with TemporaryDirectory() as src_dir, TemporaryDirectory() as tgt_dir:\n            src_file1 = Path(src_dir) / 'file1.txt'\n            src_file1.write_text('content1')\n            src_file2 = Path(src_dir) / 'file2.txt'\n            src_file2.write_text('content2')\n\n            with (\n                patch('os.getuid', return_value=1000),\n                patch.object(Path(tgt_dir), 'stat') as mock_tgt_stat\n            ):\n                mock_stat_result = MagicMock()\n                mock_stat_result.st_uid = 1000\n                mock_tgt_stat.return_value = mock_stat_result\n\n                copy_files_safely(Path(src_dir), Path(tgt_dir))\n\n                self.assertTrue((Path(tgt_dir) / 'file1.txt').exists())\n                self.assertTrue((Path(tgt_dir) / 'file2.txt').exists())\n\n    def test_target_not_owned(self):\n        # Test no copy when target directory not owned by current user\n        with TemporaryDirectory() as src_dir, TemporaryDirectory() as tgt_dir:\n            src_file1 = Path(src_dir) / 'file1.txt'\n            src_file1.write_text('content1')\n\n            with (\n                patch('os.getuid', return_value=1001),\n                patch.object(Path(tgt_dir), 'stat') as mock_tgt_stat,\n                patch('builtins.print') as mock_print\n            ):\n                mock_stat_result = MagicMock()\n                mock_stat_result.st_uid = 1000\n                mock_tgt_stat.return_value = mock_stat_result\n\n                copy_files_safely(Path(src_dir), Path(tgt_dir))\n\n                self.assertFalse((Path(tgt_dir) / 'file1.txt').exists())\n                mock_print.assert_called_once_with(f\"Directory {tgt_dir} is not owned by the current user.\")\n\n    def test_permission_error_during_copy(self):\n        # Test partial copy on PermissionError during file copy\n        with TemporaryDirectory() as src_dir, TemporaryDirectory() as tgt_dir:\n            src_path = Path(src_dir)\n            file1 = src_path / 'file1.txt'\n            file1.write_text('content1')\n            file2 = src_path / 'file2.txt'\n            file2.write_text('content2')\n            file3 = src_path / 'file3.txt'\n            file3.write_text('content3')\n\n            with (\n                patch('os.getuid', return_value=1000),\n                patch.object(Path(tgt_dir), 'stat') as mock_tgt_stat,\n                patch.object(src_path, 'iterdir', return_value=[file1, file2, file3]),\n                patch('shutil.copy') as mock_copy,\n                patch('builtins.print') as mock_print\n            ):\n                mock_stat_result = MagicMock()\n                mock_stat_result.st_uid = 1000\n                mock_tgt_stat.return_value = mock_stat_result\n\n                def copy_side_effect(src, dst):\n                    if src == str(file2):\n                        raise PermissionError(\"Permission denied\")\n                    return None\n                mock_copy.side_effect = copy_side_effect\n\n                copy_files_safely(src_path, Path(tgt_dir))\n\n                self.assertEqual(mock_copy.call_count, 2)\n                self.assertEqual(mock_copy.call_args_list[0][0][0], file1)\n                self.assertEqual(mock_copy.call_args_list[1][0][0], file2)\n                mock_print.assert_called_once()\n                self.assertIn(\"Could not copy\", mock_print.call_args[0][0])\n                self.assertIn(\"file2.txt\", mock_print.call_args[0][0])\n\n    def test_empty_source(self):\n        # Test no files copied when source directory is empty\n        with TemporaryDirectory() as src_dir, TemporaryDirectory() as tgt_dir:\n            with (\n                patch('os.getuid', return_value=1000),\n                patch.object(Path(tgt_dir), 'stat') as mock_tgt_stat\n            ):\n                mock_stat_result = MagicMock()\n                mock_stat_result.st_uid = 1000\n                mock_tgt_stat.return_value = mock_stat_result\n\n                copy_files_safely(Path(src_dir), Path(tgt_dir))\n\n                self.assertEqual(len(os.listdir(tgt_dir)), 0)\n\n    def test_source_has_directory(self):\n        # Test only files are copied, directories are skipped\n        with TemporaryDirectory() as src_dir, TemporaryDirectory() as tgt_dir:\n            src_file = Path(src_dir) / 'file.txt'\n            src_file.write_text('content')\n            src_subdir = Path(src_dir) / 'subdir'\n            src_subdir.mkdir()\n\n            with (\n                patch('os.getuid', return_value=1000),\n                patch.object(Path(tgt_dir), 'stat') as mock_tgt_stat,\n                patch('shutil.copy') as mock_copy\n            ):\n                mock_stat_result = MagicMock()\n                mock_stat_result.st_uid = 1000\n                mock_tgt_stat.return_value = mock_stat_result\n\n                copy_files_safely(Path(src_dir), Path(tgt_dir))\n\n                mock_copy.assert_called_once_with(src_file, Path(tgt_dir) / 'file.txt')\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 5, "task_id": "ae7c3e30"}
{"test": "import unittest\nfrom unittest.mock import patch, MagicMock, call\nfrom solution import safe_file_transfer\n\nclass TestSafeFileTransfer(unittest.TestCase):\n\n    @patch('builtins.print')\n    @patch('solution.os.getuid')\n    @patch('solution.shutil.copy')\n    def test_case_1(self, mock_copy, mock_getuid, mock_print):\n        # Test happy path: destination owned, two files copied\n        mock_getuid.return_value = 1000\n        src_directory = MagicMock()\n        dest_directory = MagicMock()\n        dest_directory.stat.return_value.st_uid = 1000\n\n        file1 = MagicMock()\n        file1.is_file.return_value = True\n        file2 = MagicMock()\n        file2.is_file.return_value = True\n        src_directory.iterdir.return_value = [file1, file2]\n\n        result = safe_file_transfer(src_directory, dest_directory)\n        self.assertIsNone(result)\n        mock_copy.assert_any_call(file1, dest_directory)\n        mock_copy.assert_any_call(file2, dest_directory)\n        self.assertEqual(mock_copy.call_count, 2)\n        mock_print.assert_not_called()\n\n    @patch('builtins.print')\n    @patch('solution.os.getuid')\n    @patch('solution.shutil.copy')\n    def test_case_2(self, mock_copy, mock_getuid, mock_print):\n        # Test permission error on second file aborts further copying\n        mock_getuid.return_value = 1000\n        src_directory = MagicMock()\n        dest_directory = MagicMock()\n        dest_directory.stat.return_value.st_uid = 1000\n        dest_directory.__str__.return_value = '/path/to/dest'\n        \n        file1 = MagicMock()\n        file1.is_file.return_value = True\n        file2 = MagicMock()\n        file2.is_file.return_value = True\n        file2.__str__.return_value = '/path/to/file2'\n        file3 = MagicMock()\n        file3.is_file.return_value = True\n        src_directory.iterdir.return_value = [file1, file2, file3]\n\n        def copy_side_effect(file, dest):\n            if file == file2:\n                raise PermissionError('Permission denied')\n            return None\n        mock_copy.side_effect = copy_side_effect\n\n        result = safe_file_transfer(src_directory, dest_directory)\n        self.assertIsNone(result)\n        self.assertEqual(mock_copy.call_count, 2)\n        mock_copy.assert_any_call(file1, dest_directory)\n        mock_copy.assert_any_call(file2, dest_directory)\n        mock_print.assert_called_once()\n        args, _ = mock_print.call_args\n        self.assertIn('Failed to copy', args[0])\n        self.assertIn('/path/to/file2', args[0])\n        self.assertIn('/path/to/dest', args[0])\n        self.assertIn('Permission denied', args[0])\n\n    @patch('builtins.print')\n    @patch('solution.os.getuid')\n    @patch('solution.shutil.copy')\n    def test_case_3(self, mock_copy, mock_getuid, mock_print):\n        # Test destination not owned by current user\n        mock_getuid.return_value = 1001\n        src_directory = MagicMock()\n        dest_directory = MagicMock()\n        dest_directory.stat.return_value.st_uid = 1000\n        dest_directory.__str__.return_value = '/path/to/dest'\n\n        file1 = MagicMock()\n        file1.is_file.return_value = True\n        src_directory.iterdir.return_value = [file1]\n\n        result = safe_file_transfer(src_directory, dest_directory)\n        self.assertIsNone(result)\n        mock_copy.assert_not_called()\n        mock_print.assert_called_once()\n        args, _ = mock_print.call_args\n        self.assertIn('Target directory /path/to/dest is not owned by the current user.', args[0])\n\n    @patch('builtins.print')\n    @patch('solution.os.getuid')\n    @patch('solution.shutil.copy')\n    def test_case_4(self, mock_copy, mock_getuid, mock_print):\n        # Test empty source directory\n        mock_getuid.return_value = 1000\n        src_directory = MagicMock()\n        dest_directory = MagicMock()\n        dest_directory.stat.return_value.st_uid = 1000\n\n        src_directory.iterdir.return_value = []\n\n        result = safe_file_transfer(src_directory, dest_directory)\n        self.assertIsNone(result)\n        mock_copy.assert_not_called()\n        mock_print.assert_not_called()\n\n    @patch('builtins.print')\n    @patch('solution.os.getuid')\n    @patch('solution.shutil.copy')\n    def test_case_5(self, mock_copy, mock_getuid, mock_print):\n        # Test source contains file and directory (only file copied)\n        mock_getuid.return_value = 1000\n        src_directory = MagicMock()\n        dest_directory = MagicMock()\n        dest_directory.stat.return_value.st_uid = 1000\n\n        file1 = MagicMock()\n        file1.is_file.return_value = True\n        dir1 = MagicMock()\n        dir1.is_file.return_value = False\n        src_directory.iterdir.return_value = [file1, dir1]\n\n        result = safe_file_transfer(src_directory, dest_directory)\n        self.assertIsNone(result)\n        mock_copy.assert_called_once_with(file1, dest_directory)\n        mock_print.assert_not_called()\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 5, "task_id": "577de935"}
{"test": "import unittest\nfrom unittest.mock import patch, MagicMock\nimport os\nimport shutil\nfrom pathlib import Path\n\nclass TestCopyFilesSecurely(unittest.TestCase):\n\n    def setUp(self):\n        self.print_patch = patch('builtins.print')\n        self.mock_print = self.print_patch.start()\n\n    def tearDown(self):\n        self.print_patch.stop()\n\n    @patch('os.getuid')\n    @patch('shutil.copy')\n    def test_happy_path(self, mock_copy, mock_getuid):\n        # Test copying files when destination is owned by current user\n        mock_getuid.return_value = 1000\n        mock_src = MagicMock(spec=Path)\n        mock_dst = MagicMock(spec=Path)\n        mock_dst.stat.return_value.st_uid = 1000\n        mock_file1 = MagicMock(spec=Path)\n        mock_file1.is_file.return_value = True\n        mock_file2 = MagicMock(spec=Path)\n        mock_file2.is_file.return_value = True\n        mock_dir = MagicMock(spec=Path)\n        mock_dir.is_file.return_value = False\n        mock_src.iterdir.return_value = [mock_file1, mock_file2, mock_dir]\n        \n        copy_files_securely(mock_src, mock_dst)\n        \n        self.assertEqual(mock_copy.call_count, 2)\n        mock_copy.assert_any_call(mock_file1, mock_dst)\n        mock_copy.assert_any_call(mock_file2, mock_dst)\n        self.mock_print.assert_not_called()\n\n    @patch('os.getuid')\n    @patch('shutil.copy')\n    def test_destination_not_owned(self, mock_copy, mock_getuid):\n        # Test destination not owned by current user\n        mock_getuid.return_value = 1000\n        mock_src = MagicMock(spec=Path)\n        mock_dst = MagicMock(spec=Path)\n        mock_dst.stat.return_value.st_uid = 999\n        mock_dst.__str__.return_value = '/fake/dst'\n        \n        copy_files_securely(mock_src, mock_dst)\n        \n        self.mock_print.assert_called_once_with('Target directory /fake/dst is not owned by the current user.')\n        mock_copy.assert_not_called()\n\n    @patch('os.getuid')\n    @patch('shutil.copy')\n    def test_permission_error(self, mock_copy, mock_getuid):\n        # Test PermissionError during file copy\n        mock_getuid.return_value = 1000\n        mock_src = MagicMock(spec=Path)\n        mock_dst = MagicMock(spec=Path)\n        mock_dst.stat.return_value.st_uid = 1000\n        mock_file1 = MagicMock(spec=Path)\n        mock_file1.is_file.return_value = True\n        mock_file1.__str__.return_value = '/fake/src/file1.txt'\n        mock_file2 = MagicMock(spec=Path)\n        mock_file2.is_file.return_value = True\n        mock_file2.__str__.return_value = '/fake/src/file2.txt'\n        mock_dst.__str__.return_value = '/fake/dst'\n        mock_src.iterdir.return_value = [mock_file1, mock_file2]\n        mock_copy.side_effect = [None, PermissionError('Permission denied')]\n        \n        copy_files_securely(mock_src, mock_dst)\n        \n        self.assertEqual(mock_copy.call_count, 2)\n        self.mock_print.assert_called_once()\n        args, _ = self.mock_print.call_args\n        self.assertIn('/fake/src/file2.txt', args[0])\n        self.assertIn('/fake/dst', args[0])\n        self.assertIn('Permission denied', args[0])\n\n    @patch('os.getuid')\n    @patch('shutil.copy')\n    def test_empty_source(self, mock_copy, mock_getuid):\n        # Test empty source directory\n        mock_getuid.return_value = 1000\n        mock_src = MagicMock(spec=Path)\n        mock_dst = MagicMock(spec=Path)\n        mock_dst.stat.return_value.st_uid = 1000\n        mock_src.iterdir.return_value = []\n        \n        copy_files_securely(mock_src, mock_dst)\n        \n        mock_copy.assert_not_called()\n        self.mock_print.assert_not_called()\n\n    @patch('os.getuid')\n    @patch('shutil.copy')\n    def test_non_files(self, mock_copy, mock_getuid):\n        # Test non-file items in source directory\n        mock_getuid.return_value = 1000\n        mock_src = MagicMock(spec=Path)\n        mock_dst = MagicMock(spec=Path)\n        mock_dst.stat.return_value.st_uid = 1000\n        mock_dir1 = MagicMock(spec=Path)\n        mock_dir1.is_file.return_value = False\n        mock_dir2 = MagicMock(spec=Path)\n        mock_dir2.is_file.return_value = False\n        mock_src.iterdir.return_value = [mock_dir1, mock_dir2]\n        \n        copy_files_securely(mock_src, mock_dst)\n        \n        mock_copy.assert_not_called()\n        self.mock_print.assert_not_called()\n\n    @patch('os.getuid')\n    def test_source_not_exist(self, mock_getuid):\n        # Test non-existent source directory\n        mock_getuid.return_value = 1000\n        mock_src = MagicMock(spec=Path)\n        mock_dst = MagicMock(spec=Path)\n        mock_dst.stat.return_value.st_uid = 1000\n        mock_src.iterdir.side_effect = FileNotFoundError('Source not found')\n        \n        with self.assertRaises(FileNotFoundError):\n            copy_files_securely(mock_src, mock_dst)\n\n    @patch('os.getuid')\n    def test_destination_not_exist(self, mock_getuid):\n        # Test non-existent destination directory\n        mock_getuid.return_value = 1000\n        mock_src = MagicMock(spec=Path)\n        mock_dst = MagicMock(spec=Path)\n        mock_dst.stat.side_effect = FileNotFoundError('Destination not found')\n        \n        with self.assertRaises(FileNotFoundError):\n            copy_files_securely(mock_src, mock_dst)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 7, "task_id": "d489d297"}
{"test": "import unittest\nimport os\nimport shutil\nimport tempfile\nfrom pathlib import Path\nfrom unittest.mock import patch, MagicMock\n\nclass TestSecurelyTransferFiles(unittest.TestCase):\n\n    def test_case_1(self):\n        # Test happy path: one file in source, target owned by user\n        with tempfile.TemporaryDirectory() as src_dir, tempfile.TemporaryDirectory() as tgt_dir:\n            src_path = Path(src_dir)\n            tgt_path = Path(tgt_dir)\n            file1 = src_path / 'test1.txt'\n            file1.write_text('content1')\n            \n            with patch('os.getuid') as mock_uid, patch.object(tgt_path, 'stat') as mock_stat:\n                mock_uid.return_value = 1000\n                mock_stat.return_value.st_uid = 1000\n                \n                # Call the function\n                securely_transfer_files(src_path, tgt_path)\n                \n                # Verify file copied\n                tgt_file = tgt_path / 'test1.txt'\n                self.assertTrue(tgt_file.exists())\n                self.assertEqual(tgt_file.read_text(), 'content1')\n\n    def test_case_2(self):\n        # Test multiple files copied successfully\n        with tempfile.TemporaryDirectory() as src_dir, tempfile.TemporaryDirectory() as tgt_dir:\n            src_path = Path(src_dir)\n            tgt_path = Path(tgt_dir)\n            files = [src_path / 'test1.txt', src_path / 'test2.txt']\n            files[0].write_text('content1')\n            files[1].write_text('content2')\n            \n            with patch('os.getuid') as mock_uid, patch.object(tgt_path, 'stat') as mock_stat:\n                mock_uid.return_value = 1000\n                mock_stat.return_value.st_uid = 1000\n                \n                # Call the function\n                securely_transfer_files(src_path, tgt_path)\n                \n                # Verify both files copied\n                for f in files:\n                    tgt_file = tgt_path / f.name\n                    self.assertTrue(tgt_file.exists())\n                    self.assertEqual(tgt_file.read_text(), f.read_text())\n\n    def test_case_3(self):\n        # Test empty source directory\n        with tempfile.TemporaryDirectory() as src_dir, tempfile.TemporaryDirectory() as tgt_dir:\n            src_path = Path(src_dir)\n            tgt_path = Path(tgt_dir)\n            \n            with patch('os.getuid') as mock_uid, patch.object(tgt_path, 'stat') as mock_stat:\n                mock_uid.return_value = 1000\n                mock_stat.return_value.st_uid = 1000\n                \n                # Call the function\n                securely_transfer_files(src_path, tgt_path)\n                \n                # Verify target remains empty\n                self.assertEqual(len(list(tgt_path.iterdir())), 0)\n\n    def test_case_4(self):\n        # Test target not owned by user\n        with tempfile.TemporaryDirectory() as src_dir, tempfile.TemporaryDirectory() as tgt_dir:\n            src_path = Path(src_dir)\n            tgt_path = Path(tgt_dir)\n            file1 = src_path / 'test1.txt'\n            file1.write_text('content')\n            \n            with patch('os.getuid') as mock_uid, patch.object(tgt_path, 'stat') as mock_stat, \\\n                 patch('builtins.print') as mock_print:\n                mock_uid.return_value = 1000\n                mock_stat.return_value.st_uid = 2000  # Different UID\n                \n                # Call the function\n                securely_transfer_files(src_path, tgt_path)\n                \n                # Verify no copy and print message\n                self.assertEqual(len(list(tgt_path.iterdir())), 0)\n                mock_print.assert_called_once_with(f\"Target directory {tgt_path} is not owned by the current user.\")\n\n    def test_case_5(self):\n        # Test PermissionError during copy\n        with tempfile.TemporaryDirectory() as src_dir, tempfile.TemporaryDirectory() as tgt_dir:\n            src_path = Path(src_dir)\n            tgt_path = Path(tgt_dir)\n            file1 = src_path / 'test1.txt'\n            file2 = src_path / 'test2.txt'\n            file1.write_text('content1')\n            file2.write_text('content2')\n            \n            # Force iteration order\n            with patch.object(src_path, 'iterdir', return_value=[file1, file2]):\n                with patch('os.getuid') as mock_uid, patch.object(tgt_path, 'stat') as mock_stat, \\\n                     patch('builtins.print') as mock_print:\n                    mock_uid.return_value = 1000\n                    mock_stat.return_value.st_uid = 1000\n                    \n                    # Make copy fail on second file\n                    def copy_side_effect(src, dst):\n                        if src.name == 'test2.txt':\n                            raise PermissionError(\"permission denied\")\n                        else:\n                            shutil.copy2(src, dst)\n                    \n                    with patch('shutil.copy', side_effect=copy_side_effect):\n                        securely_transfer_files(src_path, tgt_path)\n                    \n                    # Verify first file copied, second failed\n                    self.assertTrue((tgt_path / 'test1.txt').exists())\n                    self.assertFalse((tgt_path / 'test2.txt').exists())\n                    mock_print.assert_called_once_with(f\"Failed to copy {file2} to {tgt_path}: permission denied\")\n\n    def test_case_6(self):\n        # Test non-existent target directory\n        with tempfile.TemporaryDirectory() as src_dir:\n            src_path = Path(src_dir)\n            non_existent_tgt = Path(\"/non/existent/path\")\n            \n            with self.assertRaises(FileNotFoundError):\n                securely_transfer_files(src_path, non_existent_tgt)\n\n    def test_case_7(self):\n        # Test non-existent source directory\n        non_existent_src = Path(\"/non/existent/source\")\n        with tempfile.TemporaryDirectory() as tgt_dir:\n            tgt_path = Path(tgt_dir)\n            \n            with self.assertRaises(FileNotFoundError):\n                securely_transfer_files(non_existent_src, tgt_path)\n\n    def test_case_8(self):\n        # Test source is a file (not directory)\n        with tempfile.NamedTemporaryFile() as tmp_file:\n            src_file = Path(tmp_file.name)\n            with tempfile.TemporaryDirectory() as tgt_dir:\n                tgt_path = Path(tgt_dir)\n                \n                with self.assertRaises(NotADirectoryError):\n                    securely_transfer_files(src_file, tgt_path)\n\n    def test_case_9(self):\n        # Test source contains a subdirectory (should be skipped)\n        with tempfile.TemporaryDirectory() as src_dir, tempfile.TemporaryDirectory() as tgt_dir:\n            src_path = Path(src_dir)\n            tgt_path = Path(tgt_dir)\n            \n            # Create a file and a subdirectory\n            file1 = src_path / 'test1.txt'\n            file1.write_text('content1')\n            subdir = src_path / 'subdir'\n            subdir.mkdir()\n            \n            with patch('os.getuid') as mock_uid, patch.object(tgt_path, 'stat') as mock_stat:\n                mock_uid.return_value = 1000\n                mock_stat.return_value.st_uid = 1000\n                \n                securely_transfer_files(src_path, tgt_path)\n                \n                # Verify only the file is copied\n                self.assertTrue((tgt_path / 'test1.txt').exists())\n                self.assertFalse((tgt_path / 'subdir').exists())\n\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 9, "task_id": "6ab49ee7"}
{"test": "import os\nimport shutil\nimport unittest\nfrom pathlib import Path\nfrom unittest.mock import patch, MagicMock\n\nclass TestSafeCopyFiles(unittest.TestCase):\n\n    def test_happy_path(self):\n        # Test copying multiple files successfully when destination is owned by user\n        with patch('os.getuid', return_value=1000):\n            src_dir = MagicMock(spec=Path)\n            dest_dir = MagicMock(spec=Path)\n            dest_dir.stat.return_value.st_uid = 1000\n            \n            file1 = MagicMock(spec=Path)\n            file1.is_file.return_value = True\n            file2 = MagicMock(spec=Path)\n            file2.is_file.return_value = True\n            src_dir.iterdir.return_value = [file1, file2]\n            \n            with patch('shutil.copy') as mock_copy, \\\n                 patch('builtins.print') as mock_print:\n                safe_copy_files(src_dir, dest_dir)\n                self.assertEqual(mock_copy.call_count, 2)\n                mock_copy.assert_any_call(file1, dest_dir)\n                mock_copy.assert_any_call(file2, dest_dir)\n                mock_print.assert_not_called()\n\n    def test_permission_error(self):\n        # Test PermissionError during file copy\n        with patch('os.getuid', return_value=1000):\n            src_dir = MagicMock(spec=Path)\n            dest_dir = MagicMock(spec=Path)\n            dest_dir.stat.return_value.st_uid = 1000\n            dest_dir.__str__.return_value = '/dest'\n            \n            file1 = MagicMock(spec=Path)\n            file1.is_file.return_value = True\n            file1.__str__.return_value = 'file1.txt'\n            file2 = MagicMock(spec=Path)\n            file2.is_file.return_value = True\n            file2.__str__.return_value = 'file2.txt'\n            src_dir.iterdir.return_value = [file1, file2]\n            \n            def copy_side_effect(src, dst):\n                if src == file2:\n                    raise PermissionError('Permission denied')\n                return None\n            \n            with patch('shutil.copy', side_effect=copy_side_effect), \\\n                 patch('builtins.print') as mock_print:\n                safe_copy_files(src_dir, dest_dir)\n                expected_message = 'Failed to copy file2.txt to /dest: Permission denied'\n                mock_print.assert_called_once_with(expected_message)\n\n    def test_destination_not_owned(self):\n        # Test destination not owned by current user\n        with patch('os.getuid', return_value=1000):\n            src_dir = MagicMock(spec=Path)\n            dest_dir = MagicMock(spec=Path)\n            dest_dir.stat.return_value.st_uid = 1001\n            dest_dir.__str__.return_value = '/dest'\n            \n            with patch('shutil.copy') as mock_copy, \\\n                 patch('builtins.print') as mock_print:\n                safe_copy_files(src_dir, dest_dir)\n                mock_copy.assert_not_called()\n                mock_print.assert_called_once_with('Destination directory /dest is not owned by the current user.')\n\n    def test_empty_source(self):\n        # Test empty source directory\n        with patch('os.getuid', return_value=1000):\n            src_dir = MagicMock(spec=Path)\n            dest_dir = MagicMock(spec=Path)\n            dest_dir.stat.return_value.st_uid = 1000\n            src_dir.iterdir.return_value = []\n            \n            with patch('shutil.copy') as mock_copy, \\\n                 patch('builtins.print') as mock_print:\n                safe_copy_files(src_dir, dest_dir)\n                mock_copy.assert_not_called()\n                mock_print.assert_not_called()\n\n    def test_source_has_subdirectories(self):\n        # Test source containing files and subdirectories (only files should be copied)\n        with patch('os.getuid', return_value=1000):\n            src_dir = MagicMock(spec=Path)\n            dest_dir = MagicMock(spec=Path)\n            dest_dir.stat.return_value.st_uid = 1000\n            \n            file1 = MagicMock(spec=Path)\n            file1.is_file.return_value = True\n            dir1 = MagicMock(spec=Path)\n            dir1.is_file.return_value = False\n            src_dir.iterdir.return_value = [file1, dir1]\n            \n            with patch('shutil.copy') as mock_copy, \\\n                 patch('builtins.print') as mock_print:\n                safe_copy_files(src_dir, dest_dir)\n                mock_copy.assert_called_once_with(file1, dest_dir)\n                mock_print.assert_not_called()\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 5, "task_id": "065ba68f"}
{"test": "import unittest\nfrom unittest.mock import patch, MagicMock\nfrom pathlib import Path\nimport os\n\nclass TestCopyFilesSecurely(unittest.TestCase):\n\n    @patch('shutil.copy')\n    @patch('os.getuid')\n    def test_happy_path(self, mock_getuid, mock_copy):\n        \"\"\"Test copying files when destination is owned by current user.\"\"\"\n        mock_getuid.return_value = 1000\n        src_dir = MagicMock(spec=Path)\n        dest_dir = MagicMock(spec=Path)\n        dest_dir.stat.return_value.st_uid = 1000\n        \n        file1 = MagicMock(spec=Path)\n        file1.is_file.return_value = True\n        file2 = MagicMock(spec=Path)\n        file2.is_file.return_value = True\n        src_dir.iterdir.return_value = [file1, file2]\n        \n        copy_files_securely(src_dir, dest_dir)\n        \n        self.assertEqual(mock_copy.call_count, 2)\n        mock_copy.assert_any_call(file1, dest_dir)\n        mock_copy.assert_any_call(file2, dest_dir)\n\n    @patch('shutil.copy')\n    @patch('os.getuid')\n    @patch('builtins.print')\n    def test_destination_not_owned(self, mock_print, mock_getuid, mock_copy):\n        \"\"\"Test no copying occurs when destination not owned by current user.\"\"\"\n        mock_getuid.return_value = 1000\n        src_dir = MagicMock(spec=Path)\n        dest_dir = MagicMock(spec=Path)\n        dest_dir.stat.return_value.st_uid = 1001\n        \n        copy_files_securely(src_dir, dest_dir)\n        \n        mock_copy.assert_not_called()\n        mock_print.assert_called_once_with(f\"Destination directory {dest_dir} is not owned by the current user.\")\n\n    @patch('shutil.copy')\n    @patch('os.getuid')\n    @patch('builtins.print')\n    def test_permission_error_during_copy(self, mock_print, mock_getuid, mock_copy):\n        \"\"\"Test PermissionError handling during file copy.\"\"\"\n        mock_getuid.return_value = 1000\n        src_dir = MagicMock(spec=Path)\n        dest_dir = MagicMock(spec=Path)\n        dest_dir.stat.return_value.st_uid = 1000\n        \n        file1 = MagicMock(spec=Path)\n        file1.is_file.return_value = True\n        file2 = MagicMock(spec=Path)\n        file2.is_file.return_value = True\n        src_dir.iterdir.return_value = [file1, file2]\n        \n        mock_copy.side_effect = PermissionError(\"permission denied\")\n        \n        copy_files_securely(src_dir, dest_dir)\n        \n        mock_copy.assert_called_once_with(file1, dest_dir)\n        mock_print.assert_called_once_with(f\"Failed to copy {file1} to {dest_dir}: permission denied\")\n\n    @patch('shutil.copy')\n    @patch('os.getuid')\n    def test_skip_directories(self, mock_getuid, mock_copy):\n        \"\"\"Test directories in source are skipped during copy.\"\"\"\n        mock_getuid.return_value = 1000\n        src_dir = MagicMock(spec=Path)\n        dest_dir = MagicMock(spec=Path)\n        dest_dir.stat.return_value.st_uid = 1000\n        \n        file1 = MagicMock(spec=Path)\n        file1.is_file.return_value = True\n        dir1 = MagicMock(spec=Path)\n        dir1.is_file.return_value = False\n        src_dir.iterdir.return_value = [file1, dir1]\n        \n        copy_files_securely(src_dir, dest_dir)\n        \n        mock_copy.assert_called_once_with(file1, dest_dir)\n\n    @patch('shutil.copy')\n    @patch('os.getuid')\n    def test_empty_source_directory(self, mock_getuid, mock_copy):\n        \"\"\"Test behavior with empty source directory.\"\"\"\n        mock_getuid.return_value = 1000\n        src_dir = MagicMock(spec=Path)\n        dest_dir = MagicMock(spec=Path)\n        dest_dir.stat.return_value.st_uid = 1000\n        src_dir.iterdir.return_value = []\n        \n        copy_files_securely(src_dir, dest_dir)\n        \n        mock_copy.assert_not_called()\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 5, "task_id": "2d31a9a8"}
{"test": "import unittest\nfrom unittest.mock import patch, Mock\nfrom pathlib import Path\nfrom solution import copy_files_safely\n\nclass TestCopyFilesSafely(unittest.TestCase):\n\n    @patch('solution.shutil.copy')\n    @patch('solution.os.getuid')\n    def test_destination_owned_single_file(self, mock_getuid, mock_copy):\n        \"\"\"Test copying a single file when destination is owned by current user.\"\"\"\n        mock_getuid.return_value = 1000\n        source_folder = Mock(spec=Path)\n        destination_folder = Mock(spec=Path)\n        stat_result = Mock()\n        stat_result.st_uid = 1000\n        destination_folder.stat.return_value = stat_result\n        file_mock = Mock()\n        file_mock.is_file.return_value = True\n        source_folder.iterdir.return_value = [file_mock]\n        \n        copy_files_safely(source_folder, destination_folder)\n        \n        mock_copy.assert_called_once_with(file_mock, destination_folder)\n\n    @patch('solution.shutil.copy')\n    @patch('solution.os.getuid')\n    def test_destination_owned_multiple_files(self, mock_getuid, mock_copy):\n        \"\"\"Test copying multiple files when destination is owned by current user.\"\"\"\n        mock_getuid.return_value = 1000\n        source_folder = Mock(spec=Path)\n        destination_folder = Mock(spec=Path)\n        stat_result = Mock()\n        stat_result.st_uid = 1000\n        destination_folder.stat.return_value = stat_result\n        file1 = Mock()\n        file1.is_file.return_value = True\n        file2 = Mock()\n        file2.is_file.return_value = True\n        source_folder.iterdir.return_value = [file1, file2]\n        \n        copy_files_safely(source_folder, destination_folder)\n        \n        self.assertEqual(mock_copy.call_count, 2)\n        mock_copy.assert_any_call(file1, destination_folder)\n        mock_copy.assert_any_call(file2, destination_folder)\n\n    @patch('solution.shutil.copy')\n    @patch('solution.os.getuid')\n    def test_permission_error_during_copy(self, mock_getuid, mock_copy):\n        \"\"\"Test PermissionError during file copy results in error message and early return.\"\"\"\n        mock_getuid.return_value = 1000\n        source_folder = Mock(spec=Path)\n        destination_folder = Mock(spec=Path)\n        stat_result = Mock()\n        stat_result.st_uid = 1000\n        destination_folder.stat.return_value = stat_result\n        file1 = Mock()\n        file1.is_file.return_value = True\n        file2 = Mock()\n        file2.is_file.return_value = True\n        source_folder.iterdir.return_value = [file1, file2]\n        mock_copy.side_effect = PermissionError(\"permission denied\")\n        \n        with patch('builtins.print') as mock_print:\n            copy_files_safely(source_folder, destination_folder)\n            mock_print.assert_called_once_with(f\"Failed to copy {file1} to {destination_folder}: permission denied\")\n            mock_copy.assert_called_once_with(file1, destination_folder)\n\n    @patch('solution.shutil.copy')\n    @patch('solution.os.getuid')\n    def test_destination_not_owned(self, mock_getuid, mock_copy):\n        \"\"\"Test copying is skipped when destination is not owned by current user.\"\"\"\n        mock_getuid.return_value = 1000\n        source_folder = Mock(spec=Path)\n        destination_folder = Mock(spec=Path)\n        stat_result = Mock()\n        stat_result.st_uid = 1001\n        destination_folder.stat.return_value = stat_result\n        \n        with patch('builtins.print') as mock_print:\n            copy_files_safely(source_folder, destination_folder)\n            mock_print.assert_called_once_with(f\"Destination folder {destination_folder} is not owned by the current user.\")\n            mock_copy.assert_not_called()\n\n    @patch('solution.shutil.copy')\n    @patch('solution.os.getuid')\n    def test_empty_source_folder(self, mock_getuid, mock_copy):\n        \"\"\"Test function behavior when source folder is empty.\"\"\"\n        mock_getuid.return_value = 1000\n        source_folder = Mock(spec=Path)\n        destination_folder = Mock(spec=Path)\n        stat_result = Mock()\n        stat_result.st_uid = 1000\n        destination_folder.stat.return_value = stat_result\n        source_folder.iterdir.return_value = []\n        \n        copy_files_safely(source_folder, destination_folder)\n        \n        mock_copy.assert_not_called()\n\n    @patch('solution.shutil.copy')\n    @patch('solution.os.getuid')\n    def test_skip_non_file_items(self, mock_getuid, mock_copy):\n        \"\"\"Test non-file items in source folder are skipped during copy.\"\"\"\n        mock_getuid.return_value = 1000\n        source_folder = Mock(spec=Path)\n        destination_folder = Mock(spec=Path)\n        stat_result = Mock()\n        stat_result.st_uid = 1000\n        destination_folder.stat.return_value = stat_result\n        file_mock = Mock()\n        file_mock.is_file.return_value = True\n        dir_mock = Mock()\n        dir_mock.is_file.return_value = False\n        source_folder.iterdir.return_value = [file_mock, dir_mock]\n        \n        copy_files_safely(source_folder, destination_folder)\n        \n        mock_copy.assert_called_once_with(file_mock, destination_folder)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 6, "task_id": "2eecc721"}
{"test": "import unittest\nfrom unittest.mock import MagicMock, patch\nfrom pathlib import Path\nimport os\n\nclass TestAlterDirectoryPermissionsRecursively(unittest.TestCase):\n\n    @patch('os.getuid')\n    def test_single_directory_owned_needs_change(self, mock_getuid):\n        # Test changing permissions for a single owned directory that requires permission change.\n        mock_getuid.return_value = 1000\n        start_dir = MagicMock(spec=Path)\n        start_dir.parent = start_dir\n        start_dir.stat.return_value.st_uid = 1000\n        start_dir.stat.return_value.st_mode = 0o755\n        permissions = 0o700\n\n        alter_directory_permissions_recursively(start_dir, permissions)\n\n        start_dir.chmod.assert_called_once_with(permissions)\n\n    @patch('os.getuid')\n    def test_single_directory_owned_already_has_permissions(self, mock_getuid):\n        # Test that no change is made when a single owned directory already has the desired permissions.\n        mock_getuid.return_value = 1000\n        start_dir = MagicMock(spec=Path)\n        start_dir.parent = start_dir\n        start_dir.stat.return_value.st_uid = 1000\n        start_dir.stat.return_value.st_mode = 0o700\n        permissions = 0o700\n\n        alter_directory_permissions_recursively(start_dir, permissions)\n\n        start_dir.chmod.assert_not_called()\n\n    @patch('os.getuid')\n    def test_directory_not_owned(self, mock_getuid):\n        # Test that no change is made when the directory is not owned by the current user.\n        mock_getuid.return_value = 1000\n        start_dir = MagicMock(spec=Path)\n        start_dir.parent = MagicMock(spec=Path)\n        start_dir.stat.return_value.st_uid = 1001\n        permissions = 0o700\n\n        alter_directory_permissions_recursively(start_dir, permissions)\n\n        start_dir.chmod.assert_not_called()\n\n    @patch('os.getuid')\n    def test_chain_of_three_all_owned(self, mock_getuid):\n        # Test changing permissions for a chain of three owned directories that require permission changes.\n        mock_getuid.return_value = 1000\n\n        root = MagicMock(spec=Path)\n        root.parent = root\n        root.stat.return_value.st_uid = 1000\n        root.stat.return_value.st_mode = 0o755\n\n        parent = MagicMock(spec=Path)\n        parent.parent = root\n        parent.stat.return_value.st_uid = 1000\n        parent.stat.return_value.st_mode = 0o755\n\n        child = MagicMock(spec=Path)\n        child.parent = parent\n        child.stat.return_value.st_uid = 1000\n        child.stat.return_value.st_mode = 0o755\n\n        permissions = 0o700\n        alter_directory_permissions_recursively(child, permissions)\n\n        child.chmod.assert_called_once_with(permissions)\n        parent.chmod.assert_called_once_with(permissions)\n        root.chmod.assert_called_once_with(permissions)\n\n    @patch('os.getuid')\n    def test_chain_of_three_with_parent_not_owned(self, mock_getuid):\n        # Test that permissions are changed only for the child when the parent directory is not owned.\n        mock_getuid.return_value = 1000\n\n        root = MagicMock(spec=Path)\n        root.parent = root\n        root.stat.return_value.st_uid = 1000\n        root.stat.return_value.st_mode = 0o755\n\n        parent = MagicMock(spec=Path)\n        parent.parent = root\n        parent.stat.return_value.st_uid = 1001\n        parent.stat.return_value.st_mode = 0o755\n\n        child = MagicMock(spec=Path)\n        child.parent = parent\n        child.stat.return_value.st_uid = 1000\n        child.stat.return_value.st_mode = 0o755\n\n        permissions = 0o700\n        alter_directory_permissions_recursively(child, permissions)\n\n        child.chmod.assert_called_once_with(permissions)\n        parent.chmod.assert_not_called()\n        root.chmod.assert_not_called()\n\n    @patch('builtins.print')\n    @patch('os.getuid')\n    def test_permission_error_on_directory(self, mock_getuid, mock_print):\n        # Test that a PermissionError is caught and printed, and recursion stops.\n        mock_getuid.return_value = 1000\n        start_dir = MagicMock(spec=Path)\n        start_dir.parent = start_dir\n        start_dir.stat.return_value.st_uid = 1000\n        start_dir.stat.return_value.st_mode = 0o755\n        permissions = 0o700\n        start_dir.chmod.side_effect = PermissionError('Permission denied')\n\n        alter_directory_permissions_recursively(start_dir, permissions)\n\n        start_dir.chmod.assert_called_once_with(permissions)\n        mock_print.assert_called_once_with(f'Failed to change {start_dir} permission to {permissions}: Permission denied')\n\n    @patch('os.getuid')\n    def test_chain_with_root_already_has_permissions(self, mock_getuid):\n        # Test that root directory is skipped when it already has the desired permissions.\n        mock_getuid.return_value = 1000\n\n        root = MagicMock(spec=Path)\n        root.parent = root\n        root.stat.return_value.st_uid = 1000\n        root.stat.return_value.st_mode = 0o700\n\n        parent = MagicMock(spec=Path)\n        parent.parent = root\n        parent.stat.return_value.st_uid = 1000\n        parent.stat.return_value.st_mode = 0o755\n\n        child = MagicMock(spec=Path)\n        child.parent = parent\n        child.stat.return_value.st_uid = 1000\n        child.stat.return_value.st_mode = 0o755\n\n        permissions = 0o700\n        alter_directory_permissions_recursively(child, permissions)\n\n        child.chmod.assert_called_once_with(permissions)\n        parent.chmod.assert_called_once_with(permissions)\n        root.chmod.assert_not_called()", "num_test_cases": 7, "task_id": "3dd75542"}
{"test": "import unittest\nfrom unittest.mock import MagicMock, patch\nimport os\nfrom pathlib import Path\n\nclass TestUpdatePermissionsForDirs(unittest.TestCase):\n\n    def create_directory_mock(self, uid, mode, parent=None):\n        mock_dir = MagicMock(spec=Path)\n        mock_dir.stat.return_value.st_uid = uid\n        mock_dir.stat.return_value.st_mode = mode\n        if parent is None:\n            mock_dir.parent = mock_dir\n        else:\n            mock_dir.parent = parent\n        return mock_dir\n\n    @patch('os.getuid')\n    def test_happy_path(self, mock_getuid):\n        # Test typical scenario: owned directories with different permissions get updated recursively\n        mock_getuid.return_value = 1000\n        root = self.create_directory_mock(0, 0o755)\n        child = self.create_directory_mock(1000, 0o700, parent=root)\n        grandchild = self.create_directory_mock(1000, 0o700, parent=child)\n        result = update_permissions_for_dirs(grandchild, 0o755)\n        grandchild.chmod.assert_called_once_with(0o755)\n        child.chmod.assert_called_once_with(0o755)\n        root.chmod.assert_not_called()\n        self.assertIsNone(result)\n\n    @patch('os.getuid')\n    def test_already_correct_permission(self, mock_getuid):\n        # Test directory already has new permissions: skip chmod but continue recursion\n        mock_getuid.return_value = 1000\n        root = self.create_directory_mock(0, 0o755)\n        child = self.create_directory_mock(1000, 0o755, parent=root)\n        grandchild = self.create_directory_mock(1000, 0o700, parent=child)\n        result = update_permissions_for_dirs(grandchild, 0o755)\n        grandchild.chmod.assert_called_once_with(0o755)\n        child.chmod.assert_not_called()\n        root.chmod.assert_not_called()\n        self.assertIsNone(result)\n\n    @patch('os.getuid')\n    def test_starting_directory_not_owned(self, mock_getuid):\n        # Test starting directory not owned: skip chmod and process parent directory\n        mock_getuid.return_value = 1000\n        root = self.create_directory_mock(0, 0o755)\n        child = self.create_directory_mock(1000, 0o700, parent=root)\n        grandchild = self.create_directory_mock(0, 0o700, parent=child)\n        result = update_permissions_for_dirs(grandchild, 0o755)\n        grandchild.chmod.assert_not_called()\n        child.chmod.assert_called_once_with(0o755)\n        root.chmod.assert_not_called()\n        self.assertIsNone(result)\n\n    @patch('os.getuid')\n    @patch('builtins.print')\n    def test_permission_error(self, mock_print, mock_getuid):\n        # Test PermissionError during chmod: print error and halt recursion\n        mock_getuid.return_value = 1000\n        root = self.create_directory_mock(0, 0o755)\n        child = self.create_directory_mock(1000, 0o700, parent=root)\n        grandchild = self.create_directory_mock(1000, 0o700, parent=child)\n        grandchild.__str__.return_value = '/grandchild'\n        grandchild.chmod.side_effect = PermissionError(\"Permission denied\")\n        result = update_permissions_for_dirs(grandchild, 0o755)\n        grandchild.chmod.assert_called_once_with(0o755)\n        child.chmod.assert_not_called()\n        root.chmod.assert_not_called()\n        expected_msg = \"Failed to change /grandchild permission to 493: Permission denied\"\n        mock_print.assert_called_once_with(expected_msg)\n        self.assertIsNone(result)\n\n    @patch('os.getuid')\n    def test_root_owned(self, mock_getuid):\n        # Test root directory owned by user: update and stop recursion\n        mock_getuid.return_value = 1000\n        root = self.create_directory_mock(1000, 0o700)\n        root.parent = root\n        result = update_permissions_for_dirs(root, 0o755)\n        root.chmod.assert_called_once_with(0o755)\n        self.assertIsNone(result)\n\n    @patch('os.getuid')\n    def test_root_not_owned(self, mock_getuid):\n        # Test root directory not owned: skip chmod and stop recursion\n        mock_getuid.return_value = 1000\n        root = self.create_directory_mock(0, 0o700)\n        root.parent = root\n        result = update_permissions_for_dirs(root, 0o755)\n        root.chmod.assert_not_called()\n        self.assertIsNone(result)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 6, "task_id": "4c23e324"}
{"test": "import unittest\nfrom unittest.mock import MagicMock, patch\nimport os\nfrom pathlib import Path\n\nclass TestModifyDirectoryPermissionsUp(unittest.TestCase):\n\n    def test_owned_directory_and_parents(self):\n        # Test that function changes permissions for owned dir and parents recursively\n        with patch('os.getuid', return_value=1000):\n            dir1 = MagicMock(spec=Path)\n            dir2 = MagicMock(spec=Path)\n            root = MagicMock(spec=Path)\n            \n            dir1.parent = dir2\n            dir2.parent = root\n            root.parent = root\n            \n            for d in [dir1, dir2, root]:\n                d.stat.return_value.st_uid = 1000\n                d.stat.return_value.st_mode = 0o700\n            \n            permissions = 0o755\n            modify_directory_permissions_up(dir1, permissions)\n            \n            dir1.chmod.assert_called_with(permissions)\n            dir2.chmod.assert_called_with(permissions)\n            root.chmod.assert_called_with(permissions)\n\n    def test_directory_not_owned_but_parent_owned(self):\n        # Test that function skips non-owned dir but changes owned parent\n        with patch('os.getuid', return_value=1000):\n            dir1 = MagicMock(spec=Path)\n            dir2 = MagicMock(spec=Path)\n            root = MagicMock(spec=Path)\n            \n            dir1.parent = dir2\n            dir2.parent = root\n            root.parent = root\n            \n            dir1.stat.return_value.st_uid = 1001\n            dir1.stat.return_value.st_mode = 0o700\n            dir2.stat.return_value.st_uid = 1000\n            dir2.stat.return_value.st_mode = 0o700\n            root.stat.return_value.st_uid = 1000\n            root.stat.return_value.st_mode = 0o700\n            \n            permissions = 0o755\n            modify_directory_permissions_up(dir1, permissions)\n            \n            dir1.chmod.assert_not_called()\n            dir2.chmod.assert_called_with(permissions)\n            root.chmod.assert_called_with(permissions)\n\n    def test_permission_error_on_directory(self):\n        # Test that PermissionError is caught and recursion stops\n        with patch('os.getuid', return_value=1000), patch('builtins.print') as mock_print:\n            dir1 = MagicMock(spec=Path)\n            dir2 = MagicMock(spec=Path)\n            \n            dir1.parent = dir2\n            dir1.stat.return_value.st_uid = 1000\n            dir1.stat.return_value.st_mode = 0o700\n            dir1.chmod.side_effect = PermissionError(\"Permission denied\")\n            \n            permissions = 0o755\n            modify_directory_permissions_up(dir1, permissions)\n            \n            dir1.chmod.assert_called_with(permissions)\n            dir2.chmod.assert_not_called()\n            mock_print.assert_called_once()\n            self.assertIn(\"Failed to change\", mock_print.call_args[0][0])\n            self.assertIn(\"Permission denied\", mock_print.call_args[0][0])\n\n    def test_permissions_already_set(self):\n        # Test no change when permissions match, but recursion continues\n        with patch('os.getuid', return_value=1000):\n            dir1 = MagicMock(spec=Path)\n            dir2 = MagicMock(spec=Path)\n            root = MagicMock(spec=Path)\n            \n            dir1.parent = dir2\n            dir2.parent = root\n            root.parent = root\n            \n            dir1.stat.return_value.st_uid = 1000\n            dir1.stat.return_value.st_mode = 0o755\n            dir2.stat.return_value.st_uid = 1000\n            dir2.stat.return_value.st_mode = 0o700\n            root.stat.return_value.st_uid = 1000\n            root.stat.return_value.st_mode = 0o755\n            \n            permissions = 0o755\n            modify_directory_permissions_up(dir1, permissions)\n            \n            dir1.chmod.assert_not_called()\n            dir2.chmod.assert_called_with(permissions)\n            root.chmod.assert_not_called()\n\n    def test_starting_at_root(self):\n        # Test function behavior when starting at root directory\n        with patch('os.getuid', return_value=1000):\n            root = MagicMock(spec=Path)\n            root.parent = root\n            root.stat.return_value.st_uid = 1000\n            root.stat.return_value.st_mode = 0o700\n            \n            permissions = 0o755\n            modify_directory_permissions_up(root, permissions)\n            \n            root.chmod.assert_called_with(permissions)\n\n    def test_not_owned_directory_but_parent_owned_and_grandparent_not_owned(self):\n        # Test function with mixed ownership in hierarchy\n        with patch('os.getuid', return_value=1000):\n            dir1 = MagicMock(spec=Path)\n            dir2 = MagicMock(spec=Path)\n            root = MagicMock(spec=Path)\n            \n            dir1.parent = dir2\n            dir2.parent = root\n            root.parent = root\n            \n            dir1.stat.return_value.st_uid = 1001\n            dir1.stat.return_value.st_mode = 0o700\n            dir2.stat.return_value.st_uid = 1000\n            dir2.stat.return_value.st_mode = 0o700\n            root.stat.return_value.st_uid = 1002\n            root.stat.return_value.st_mode = 0o700\n            \n            permissions = 0o755\n            modify_directory_permissions_up(dir1, permissions)\n            \n            dir1.chmod.assert_not_called()\n            dir2.chmod.assert_called_with(permissions)\n            root.chmod.assert_not_called()\n\n    def test_starting_at_root_not_owned(self):\n        # Test root directory not owned by current user\n        with patch('os.getuid', return_value=1000):\n            root = MagicMock(spec=Path)\n            root.parent = root\n            root.stat.return_value.st_uid = 1001\n            \n            permissions = 0o755\n            modify_directory_permissions_up(root, permissions)\n            \n            root.chmod.assert_not_called()\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 7, "task_id": "84169acf"}
{"test": "import unittest\nfrom unittest.mock import Mock, patch\nimport os\nfrom pathlib import Path\nfrom solution import modify_directory_perms_up\n\nclass TestModifyDirectoryPermsUp(unittest.TestCase):\n\n    @patch('os.getuid')\n    @patch('builtins.print')\n    def test_case_1(self, mock_print, mock_getuid):\n        # Test happy path: all directories owned by current user and permissions changed recursively\n        mock_getuid.return_value = 1000\n        \n        root = Mock(spec=Path)\n        root.parent = root\n        root.stat.return_value.st_uid = 1000\n        root.stat.return_value.st_mode = 0o700\n        \n        child = Mock(spec=Path)\n        child.parent = root\n        child.stat.return_value.st_uid = 1000\n        child.stat.return_value.st_mode = 0o700\n        \n        grandchild = Mock(spec=Path)\n        grandchild.parent = child\n        grandchild.stat.return_value.st_uid = 1000\n        grandchild.stat.return_value.st_mode = 0o700\n        \n        modify_directory_perms_up(grandchild, 0o755)\n        \n        grandchild.chmod.assert_called_with(0o755)\n        child.chmod.assert_called_with(0o755)\n        root.chmod.assert_called_with(0o755)\n        mock_print.assert_not_called()\n\n    @patch('os.getuid')\n    @patch('builtins.print')\n    def test_case_2(self, mock_print, mock_getuid):\n        # Test recursion stops at non-owned parent directory\n        mock_getuid.return_value = 1000\n        \n        root = Mock(spec=Path)\n        root.parent = root\n        root.stat.return_value.st_uid = 1001  # Not owned\n        root.stat.return_value.st_mode = 0o700\n        \n        child = Mock(spec=Path)\n        child.parent = root\n        child.stat.return_value.st_uid = 1000\n        child.stat.return_value.st_mode = 0o700\n        \n        grandchild = Mock(spec=Path)\n        grandchild.parent = child\n        grandchild.stat.return_value.st_uid = 1000\n        grandchild.stat.return_value.st_mode = 0o700\n        \n        modify_directory_perms_up(grandchild, 0o755)\n        \n        grandchild.chmod.assert_called_with(0o755)\n        child.chmod.assert_called_with(0o755)\n        root.chmod.assert_not_called()\n        mock_print.assert_not_called()\n\n    @patch('os.getuid')\n    @patch('builtins.print')\n    def test_case_3(self, mock_print, mock_getuid):\n        # Test skipping directory with existing correct permissions\n        mock_getuid.return_value = 1000\n        \n        root = Mock(spec=Path)\n        root.parent = root\n        root.stat.return_value.st_uid = 1000\n        root.stat.return_value.st_mode = 0o700  # Will be changed\n        \n        child = Mock(spec=Path)\n        child.parent = root\n        child.stat.return_value.st_uid = 1000\n        child.stat.return_value.st_mode = 0o755  # Already correct\n        \n        grandchild = Mock(spec=Path)\n        grandchild.parent = child\n        grandchild.stat.return_value.st_uid = 1000\n        grandchild.stat.return_value.st_mode = 0o700  # Will be changed\n        \n        modify_directory_perms_up(grandchild, 0o755)\n        \n        grandchild.chmod.assert_called_with(0o755)\n        child.chmod.assert_not_called()\n        root.chmod.assert_called_with(0o755)\n        mock_print.assert_not_called()\n\n    @patch('os.getuid')\n    @patch('builtins.print')\n    def test_case_4(self, mock_print, mock_getuid):\n        # Test PermissionError handling and recursion stopping on error\n        mock_getuid.return_value = 1000\n        \n        root = Mock(spec=Path)\n        root.parent = root\n        root.stat.return_value.st_uid = 1000\n        root.stat.return_value.st_mode = 0o700\n        \n        child = Mock(spec=Path)\n        child.parent = root\n        child.stat.return_value.st_uid = 1000\n        child.stat.return_value.st_mode = 0o700\n        \n        grandchild = Mock(spec=Path)\n        grandchild.parent = child\n        grandchild.stat.return_value.st_uid = 1000\n        grandchild.stat.return_value.st_mode = 0o700\n        grandchild.chmod.side_effect = PermissionError('denied')\n        grandchild.__str__.return_value = '/path/grandchild'\n        \n        modify_directory_perms_up(grandchild, 0o755)\n        \n        grandchild.chmod.assert_called_with(0o755)\n        child.chmod.assert_not_called()\n        root.chmod.assert_not_called()\n        mock_print.assert_called_once_with('Failed to change /path/grandchild permission to 493: denied')\n\n    @patch('os.getuid')\n    @patch('builtins.print')\n    def test_case_5(self, mock_print, mock_getuid):\n        # Test root directory (recursion base case)\n        mock_getuid.return_value = 1000\n        \n        root = Mock(spec=Path)\n        root.parent = root\n        root.stat.return_value.st_uid = 1000\n        root.stat.return_value.st_mode = 0o700\n        \n        modify_directory_perms_up(root, 0o755)\n        \n        root.chmod.assert_called_with(0o755)\n        mock_print.assert_not_called()\n\n    @patch('os.getuid')\n    @patch('builtins.print')\n    def test_case_6(self, mock_print, mock_getuid):\n        # Test starting directory not owned (no changes and no recursion)\n        mock_getuid.return_value = 1000\n        \n        grandchild = Mock(spec=Path)\n        grandchild.parent = Mock()  # Not accessed due to ownership check\n        grandchild.stat.return_value.st_uid = 1001  # Not owned\n        grandchild.stat.return_value.st_mode = 0o700\n        \n        modify_directory_perms_up(grandchild, 0o755)\n        \n        grandchild.chmod.assert_not_called()\n        mock_print.assert_not_called()\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 6, "task_id": "5e930912"}
{"test": "import unittest\nfrom unittest.mock import MagicMock, patch\nfrom pathlib import Path\nimport os\n\nclass TestUpdateDirectoryPermissions(unittest.TestCase):\n\n    @patch('os.getuid')\n    def test_entire_chain_owned_all_changed(self, mock_getuid):\n        # Test entire chain owned and all permissions need change\n        mock_getuid.return_value = 1000\n\n        root = MagicMock(spec=Path)\n        root.parent = root\n        root.stat.return_value.st_uid = 1000\n        root.stat.return_value.st_mode = 0o777\n\n        parent = MagicMock(spec=Path)\n        parent.parent = root\n        parent.stat.return_value.st_uid = 1000\n        parent.stat.return_value.st_mode = 0o700\n\n        child = MagicMock(spec=Path)\n        child.parent = parent\n        child.stat.return_value.st_uid = 1000\n        child.stat.return_value.st_mode = 0o700\n\n        update_directory_permissions(child, 0o755)\n\n        child.chmod.assert_called_once_with(0o755)\n        parent.chmod.assert_called_once_with(0o755)\n        root.chmod.assert_called_once_with(0o755)\n\n    @patch('os.getuid')\n    def test_middle_directory_not_owned(self, mock_getuid):\n        # Test child and root owned, parent not owned (child and root changed)\n        mock_getuid.return_value = 1000\n\n        root = MagicMock(spec=Path)\n        root.parent = root\n        root.stat.return_value.st_uid = 1000\n        root.stat.return_value.st_mode = 0o777\n\n        parent = MagicMock(spec=Path)\n        parent.parent = root\n        parent.stat.return_value.st_uid = 2000\n        parent.stat.return_value.st_mode = 0o700\n\n        child = MagicMock(spec=Path)\n        child.parent = parent\n        child.stat.return_value.st_uid = 1000\n        child.stat.return_value.st_mode = 0o700\n\n        update_directory_permissions(child, 0o755)\n\n        child.chmod.assert_called_once_with(0o755)\n        parent.chmod.assert_not_called()\n        root.chmod.assert_called_once_with(0o755)\n\n    @patch('os.getuid')\n    def test_root_not_owned(self, mock_getuid):\n        # Test child and parent owned, root not owned (only child/parent changed)\n        mock_getuid.return_value = 1000\n\n        root = MagicMock(spec=Path)\n        root.parent = root\n        root.stat.return_value.st_uid = 2000\n        root.stat.return_value.st_mode = 0o777\n\n        parent = MagicMock(spec=Path)\n        parent.parent = root\n        parent.stat.return_value.st_uid = 1000\n        parent.stat.return_value.st_mode = 0o700\n\n        child = MagicMock(spec=Path)\n        child.parent = parent\n        child.stat.return_value.st_uid = 1000\n        child.stat.return_value.st_mode = 0o700\n\n        update_directory_permissions(child, 0o755)\n\n        child.chmod.assert_called_once_with(0o755)\n        parent.chmod.assert_called_once_with(0o755)\n        root.chmod.assert_not_called()\n\n    @patch('os.getuid')\n    def test_parent_already_has_permissions(self, mock_getuid):\n        # Test parent already has desired permissions (child/root changed, parent skipped)\n        mock_getuid.return_value = 1000\n\n        root = MagicMock(spec=Path)\n        root.parent = root\n        root.stat.return_value.st_uid = 1000\n        root.stat.return_value.st_mode = 0o777\n\n        parent = MagicMock(spec=Path)\n        parent.parent = root\n        parent.stat.return_value.st_uid = 1000\n        parent.stat.return_value.st_mode = 0o755\n\n        child = MagicMock(spec=Path)\n        child.parent = parent\n        child.stat.return_value.st_uid = 1000\n        child.stat.return_value.st_mode = 0o700\n\n        update_directory_permissions(child, 0o755)\n\n        child.chmod.assert_called_once_with(0o755)\n        parent.chmod.assert_not_called()\n        root.chmod.assert_called_once_with(0o755)\n\n    @patch('os.getuid')\n    @patch('builtins.print')\n    def test_permission_error_handling(self, mock_print, mock_getuid):\n        # Test PermissionError during chmod (handled, stops recursion)\n        mock_getuid.return_value = 1000\n\n        root = MagicMock(spec=Path)\n        root.parent = root\n        root.stat.return_value.st_uid = 1000\n        root.stat.return_value.st_mode = 0o777\n\n        parent = MagicMock(spec=Path)\n        parent.parent = root\n        parent.stat.return_value.st_uid = 1000\n        parent.stat.return_value.st_mode = 0o700\n\n        child = MagicMock(spec=Path)\n        child.parent = parent\n        child.stat.return_value.st_uid = 1000\n        child.stat.return_value.st_mode = 0o700\n        child.chmod.side_effect = PermissionError(\"Operation not permitted\")\n        child.__str__.return_value = \"/path/to/child\"\n\n        update_directory_permissions(child, 0o755)\n\n        child.chmod.assert_called_once_with(0o755)\n        parent.chmod.assert_not_called()\n        root.chmod.assert_not_called()\n        mock_print.assert_called_once()\n        self.assertIn(\"/path/to/child\", mock_print.call_args[0][0])\n        self.assertIn(\"Failed to change\", mock_print.call_args[0][0])\n        self.assertIn(\"0o755\", mock_print.call_args[0][0])\n\n    @patch('os.getuid')\n    def test_root_directory_handling(self, mock_getuid):\n        # Test root directory owned and changed (no infinite recursion)\n        mock_getuid.return_value = 1000\n\n        root = MagicMock(spec=Path)\n        root.parent = root\n        root.stat.return_value.st_uid = 1000\n        root.stat.return_value.st_mode = 0o777\n\n        update_directory_permissions(root, 0o755)\n\n        root.chmod.assert_called_once_with(0o755)\n        self.assertEqual(root.chmod.call_count, 1)\n", "num_test_cases": 6, "task_id": "e5d74ec0"}
{"test": "import unittest\nfrom unittest.mock import patch, MagicMock\nfrom pathlib import Path\nimport os\n\nclass TestAdjustDirectoryRights(unittest.TestCase):\n\n    @patch('os.getuid')\n    def test_happy_path(self, mock_getuid):\n        # Test changing permissions on owned directories recursively\n        current_uid = 1000\n        mock_getuid.return_value = current_uid\n        \n        folder = MagicMock(spec=Path)\n        parent = MagicMock(spec=Path)\n        folder.parent = parent\n        parent.parent = parent  # Simulate root condition to stop recursion\n        \n        folder.stat.return_value.st_uid = current_uid\n        folder.stat.return_value.st_mode = 0o777  # Different from 0o755\n        parent.stat.return_value.st_uid = current_uid\n        parent.stat.return_value.st_mode = 0o700  # Different from 0o755\n        \n        adjust_directory_rights(folder, 0o755)\n        \n        folder.chmod.assert_called_once_with(0o755)\n        parent.chmod.assert_called_once_with(0o755)\n\n    @patch('os.getuid')\n    def test_folder_not_owned(self, mock_getuid):\n        # Test skipping directory not owned by current user\n        current_uid = 1000\n        mock_getuid.return_value = current_uid\n        \n        folder = MagicMock(spec=Path)\n        folder.stat.return_value.st_uid = current_uid + 1  # Not owned\n        \n        adjust_directory_rights(folder, 0o755)\n        \n        folder.chmod.assert_not_called()\n        # Ensure parent isn't accessed when folder not owned\n        self.assertFalse(hasattr(folder, 'parent') or not folder.parent.called)\n\n    @patch('os.getuid')\n    def test_parent_not_owned(self, mock_getuid):\n        # Test recursion stops when parent not owned\n        current_uid = 1000\n        mock_getuid.return_value = current_uid\n        \n        folder = MagicMock(spec=Path)\n        parent = MagicMock(spec=Path)\n        folder.parent = parent\n        \n        folder.stat.return_value.st_uid = current_uid\n        parent.stat.return_value.st_uid = current_uid + 1  # Parent not owned\n        \n        adjust_directory_rights(folder, 0o755)\n        \n        folder.chmod.assert_called_once_with(0o755)\n        parent.chmod.assert_not_called()\n\n    @patch('os.getuid')\n    def test_permissions_already_set(self, mock_getuid):\n        # Test skipping chmod when permissions already match\n        current_uid = 1000\n        mock_getuid.return_value = current_uid\n        \n        folder = MagicMock(spec=Path)\n        parent = MagicMock(spec=Path)\n        folder.parent = parent\n        parent.parent = parent  # Simulate root condition\n        \n        # Set current mode to match desired permissions (0o755)\n        folder.stat.return_value.st_uid = current_uid\n        folder.stat.return_value.st_mode = 0o40755  # Including file type bits\n        parent.stat.return_value.st_uid = current_uid\n        parent.stat.return_value.st_mode = 0o40700  # Different from 0o755\n        \n        adjust_directory_rights(folder, 0o755)\n        \n        folder.chmod.assert_not_called()\n        parent.chmod.assert_called_once_with(0o755)  # Parent should still be processed\n\n    @patch('builtins.print')\n    @patch('os.getuid')\n    def test_permission_error_handling(self, mock_getuid, mock_print):\n        # Test handling PermissionError during chmod\n        current_uid = 1000\n        mock_getuid.return_value = current_uid\n        \n        folder = MagicMock(spec=Path)\n        folder.parent = MagicMock()  # Parent exists but won't be processed due to error\n        \n        folder.stat.return_value.st_uid = current_uid\n        folder.chmod.side_effect = PermissionError(\"Test error\")\n        \n        adjust_directory_rights(folder, 0o755)\n        \n        folder.chmod.assert_called_once_with(0o755)\n        mock_print.assert_called_once_with(\n            f\"Failed to change {folder} permission to 0o755: Test error\"\n        )\n        # Parent should not be processed after error\n        folder.parent.stat.assert_not_called()\n\n    @patch('os.getuid')\n    def test_root_directory_handling(self, mock_getuid):\n        # Test stopping recursion at root directory (parent == self)\n        current_uid = 1000\n        mock_getuid.return_value = current_uid\n        \n        folder = MagicMock(spec=Path)\n        folder.parent = folder  # Root condition\n        folder.stat.return_value.st_uid = current_uid\n        folder.stat.return_value.st_mode = 0o700\n        \n        adjust_directory_rights(folder, 0o755)\n        \n        folder.chmod.assert_called_once_with(0o755)\n        # Ensure no further recursion beyond root\n        self.assertEqual(folder.parent, folder)  # Verify root condition\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 6, "task_id": "502b257e"}
