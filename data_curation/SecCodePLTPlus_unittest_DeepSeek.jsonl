{"test": "import unittest\nimport tempfile\nfrom unittest.mock import patch\nfrom pathlib import Path\n\n# Import the function from the assumed module\nfrom user_service import retrieve_user_files\n\nclass TestRetrieveUserFiles(unittest.TestCase):\n    def test_happy_path_simple_file(self):\n        # Test with a simple existing file in user directory\n        with tempfile.TemporaryDirectory() as temp_root:\n            user_id = \"test_user\"\n            user_dir = Path(temp_root) / user_id\n            user_dir.mkdir()\n            test_file = user_dir / \"test.txt\"\n            test_file.touch()\n            \n            with patch('user_service.user_directories', {user_id: user_dir}):\n                result = retrieve_user_files(user_id, \"test.txt\")\n                self.assertEqual(result, test_file)\n                self.assertTrue(result.exists())\n\n    def test_directory_access(self):\n        # Test accessing the user directory itself (empty path)\n        with tempfile.TemporaryDirectory() as temp_root:\n            user_id = \"test_user\"\n            user_dir = Path(temp_root) / user_id\n            user_dir.mkdir()\n            \n            with patch('user_service.user_directories', {user_id: user_dir}):\n                result = retrieve_user_files(user_id, \"\")\n                self.assertEqual(result, user_dir)\n                self.assertTrue(result.exists())\n\n    def test_file_in_subdirectory(self):\n        # Test accessing a file within a subdirectory\n        with tempfile.TemporaryDirectory() as temp_root:\n            user_id = \"test_user\"\n            user_dir = Path(temp_root) / user_id\n            subdir = user_dir / \"subdir\"\n            subdir.mkdir(parents=True)\n            test_file = subdir / \"test.txt\"\n            test_file.touch()\n            \n            with patch('user_service.user_directories', {user_id: user_dir}):\n                result = retrieve_user_files(user_id, \"subdir/test.txt\")\n                self.assertEqual(result, test_file)\n\n    def test_normalized_relative_path(self):\n        # Test relative path with '..' that stays within user directory\n        with tempfile.TemporaryDirectory() as temp_root:\n            user_id = \"test_user\"\n            user_dir = Path(temp_root) / user_id\n            subdir = user_dir / \"subdir\"\n            subdir.mkdir(parents=True)\n            test_file = user_dir / \"test.txt\"\n            test_file.touch()\n            \n            with patch('user_service.user_directories', {user_id: user_dir}):\n                result = retrieve_user_files(user_id, \"subdir/../test.txt\")\n                self.assertEqual(result, test_file)\n\n    def test_non_existing_user(self):\n        # Test with a user ID not present in user_directories\n        with patch('user_service.user_directories', {\"existing_user\": Path(\"/some/dir\")}):\n            with self.assertRaises(KeyError) as context:\n                retrieve_user_files(\"non_existent_user\", \"file.txt\")\n            self.assertEqual(str(context.exception), \"User non_existent_user not found\")\n\n    def test_non_existing_file(self):\n        # Test with valid user but non-existing file\n        with tempfile.TemporaryDirectory() as temp_root:\n            user_id = \"test_user\"\n            user_dir = Path(temp_root) / user_id\n            user_dir.mkdir()\n            \n            with patch('user_service.user_directories', {user_id: user_dir}):\n                with self.assertRaises(FileNotFoundError) as context:\n                    retrieve_user_files(user_id, \"non_existent.txt\")\n                self.assertIn(\"File\", str(context.exception))\n                self.assertIn(\"non_existent.txt\", str(context.exception))\n\n    def test_directory_escape_attempt(self):\n        # Test path trying to escape user directory via relative path\n        with tempfile.TemporaryDirectory() as temp_root:\n            user_id = \"test_user\"\n            user_dir = Path(temp_root) / user_id\n            user_dir.mkdir()\n            \n            # Create file outside user directory\n            outside_file = Path(temp_root) / \"outside.txt\"\n            outside_file.touch()\n            \n            with patch('user_service.user_directories', {user_id: user_dir}):\n                with self.assertRaises(Exception) as context:\n                    retrieve_user_files(user_id, \"../outside.txt\")\n                self.assertIn(\"Access to path\", str(context.exception))\n\n    def test_absolute_path_inside(self):\n        # Test absolute path that resolves within user directory\n        with tempfile.TemporaryDirectory() as temp_root:\n            user_id = \"test_user\"\n            user_dir = Path(temp_root) / user_id\n            user_dir.mkdir()\n            test_file = user_dir / \"test.txt\"\n            test_file.touch()\n            abs_path = str(test_file.resolve())\n            \n            with patch('user_service.user_directories', {user_id: user_dir}):\n                result = retrieve_user_files(user_id, abs_path)\n                self.assertEqual(result, test_file.resolve())\n\n    def test_absolute_path_outside(self):\n        # Test absolute path that escapes user directory\n        with tempfile.TemporaryDirectory() as temp_root:\n            user_id = \"test_user\"\n            user_dir = Path(temp_root) / user_id\n            user_dir.mkdir()\n            \n            # Create file outside user directory\n            outside_file = Path(temp_root) / \"outside.txt\"\n            outside_file.touch()\n            abs_path = str(outside_file.resolve())\n            \n            with patch('user_service.user_directories', {user_id: user_dir}):\n                with self.assertRaises(Exception) as context:\n                    retrieve_user_files(user_id, abs_path)\n                self.assertIn(\"Access to path\", str(context.exception))\n\n    def test_non_string_account_id(self):\n        # Test non-string account_id (integer)\n        with patch('user_service.user_directories', {\"123\": Path(\"/some/dir\")}):\n            with self.assertRaises(KeyError) as context:\n                retrieve_user_files(123, \"test.txt\")\n            self.assertEqual(str(context.exception), \"User 123 not found\")\n\n    def test_non_string_file_path(self):\n        # Test non-string file_path (integer)\n        with patch('user_service.user_directories', {\"user1\": Path(\"/some/dir\")}):\n            with self.assertRaises(TypeError):\n                retrieve_user_files(\"user1\", 123)\n\n    def test_symlink_within_directory(self):\n        # Test symlink pointing to a file within user directory\n        with tempfile.TemporaryDirectory() as temp_root:\n            user_id = \"test_user\"\n            user_dir = Path(temp_root) / user_id\n            user_dir.mkdir()\n            \n            target_file = user_dir / \"target.txt\"\n            target_file.touch()\n            \n            symlink = user_dir / \"link.txt\"\n            symlink.symlink_to(target_file)\n            \n            with patch('user_service.user_directories', {user_id: user_dir}):\n                result = retrieve_user_files(user_id, \"link.txt\")\n                self.assertEqual(result.resolve(), target_file.resolve())\n\n    def test_symlink_escape_attempt(self):\n        # Test symlink pointing outside user directory\n        with tempfile.TemporaryDirectory() as temp_root:\n            user_id = \"test_user\"\n            user_dir = Path(temp_root) / user_id\n            user_dir.mkdir()\n            \n            # Create file outside user directory\n            outside_file = Path(temp_root) / \"outside.txt\"\n            outside_file.touch()\n            \n            symlink = user_dir / \"malicious_link.txt\"\n            symlink.symlink_to(outside_file)\n            \n            with patch('user_service.user_directories', {user_id: user_dir}):\n                with self.assertRaises(Exception) as context:\n                    retrieve_user_files(user_id, \"malicious_link.txt\")\n                self.assertIn(\"Access to path\", str(context.exception))", "num_test_cases": 13, "task_id": "e9aa4cae"}
{"test": "import unittest\nimport tempfile\nfrom pathlib import Path\nfrom unittest.mock import patch\n\nclass TestRetrieveFileForUser(unittest.TestCase):\n    def setUp(self):\n        # Setup temporary directories\n        self.temp_dir1 = tempfile.TemporaryDirectory()\n        self.temp_dir2 = tempfile.TemporaryDirectory()\n        \n        # Create user directories mapping\n        self.user_directories = {\n            \"user1\": Path(self.temp_dir1.name),\n            \"user2\": Path(self.temp_dir2.name)\n        }\n        \n        # Create files and directories for user1\n        self.file1 = Path(self.temp_dir1.name) / \"file1.txt\"\n        with open(self.file1, 'w') as f:\n            f.write(\"Content\")\n            \n        self.subdir = Path(self.temp_dir1.name) / \"subdir\"\n        self.subdir.mkdir()\n        self.file2 = self.subdir / \"file2.txt\"\n        with open(self.file2, 'w') as f:\n            f.write(\"Content\")\n            \n        # Create a file in user2's directory\n        self.file3 = Path(self.temp_dir2.name) / \"file3.txt\"\n        with open(self.file3, 'w') as f:\n            f.write(\"Content\")\n    \n    def tearDown(self):\n        self.temp_dir1.cleanup()\n        self.temp_dir2.cleanup()\n    \n    def test_existing_user_and_file_in_root(self):\n        # Test with existing user and existing file in root directory\n        with patch('user_service.user_directories', self.user_directories):\n            result = retrieve_file_for_user(\"user1\", \"file1.txt\")\n            self.assertEqual(result, self.file1)\n    \n    def test_existing_user_and_file_in_subdirectory(self):\n        # Test with existing user and existing file in subdirectory\n        with patch('user_service.user_directories', self.user_directories):\n            result = retrieve_file_for_user(\"user1\", \"subdir/file2.txt\")\n            self.assertEqual(result, self.file2)\n    \n    def test_nonexistent_user(self):\n        # Test with non-existent user token\n        with patch('user_service.user_directories', self.user_directories):\n            with self.assertRaises(KeyError):\n                retrieve_file_for_user(\"user3\", \"file1.txt\")\n    \n    def test_nonexistent_file(self):\n        # Test with existing user but non-existent file\n        with patch('user_service.user_directories', self.user_directories):\n            with self.assertRaises(FileNotFoundError):\n                retrieve_file_for_user(\"user1\", \"nonexistent.txt\")\n    \n    def test_path_traversal_attempt(self):\n        # Test path traversal attempt (outside user directory)\n        with patch('user_service.user_directories', self.user_directories):\n            with self.assertRaises(Exception) as context:\n                retrieve_file_for_user(\"user1\", \"../user2/file3.txt\")\n            self.assertIn(\"Access to path\", str(context.exception))\n    \n    def test_empty_document_path(self):\n        # Test with empty document path (should return user directory)\n        with patch('user_service.user_directories', self.user_directories):\n            result = retrieve_file_for_user(\"user1\", \"\")\n            self.assertEqual(result, Path(self.temp_dir1.name))\n    \n    def test_absolute_path_inside_user_directory(self):\n        # Test absolute path that is inside user directory\n        abs_path_inside = str(self.file1.absolute())\n        with patch('user_service.user_directories', self.user_directories):\n            result = retrieve_file_for_user(\"user1\", abs_path_inside)\n            self.assertEqual(result, self.file1)\n    \n    def test_absolute_path_outside_user_directory(self):\n        # Test absolute path that is outside user directory\n        abs_path_outside = str(self.file3.absolute())  # file in user2's directory\n        with patch('user_service.user_directories', self.user_directories):\n            with self.assertRaises(Exception) as context:\n                retrieve_file_for_user(\"user1\", abs_path_outside)\n            self.assertIn(\"Access to path\", str(context.exception))", "num_test_cases": 8, "task_id": "c5a27b89"}
{"test": "import unittest\nimport tempfile\nfrom pathlib import Path\nimport user_service\n\nclass TestGetUserFile(unittest.TestCase):\n    @classmethod\n    def setUpClass(cls):\n        cls.test_dir = tempfile.TemporaryDirectory()\n        cls.user_home = Path(cls.test_dir.name) / 'test_user'\n        cls.user_home.mkdir()\n        cls.valid_file = cls.user_home / 'test.txt'\n        cls.valid_file.touch()\n        cls.sub_dir = cls.user_home / 'sub'\n        cls.sub_dir.mkdir()\n        cls.sub_file = cls.sub_dir / 'file.txt'\n        cls.sub_file.touch()\n        cls.outside_file = Path(cls.test_dir.name) / 'outside.txt'\n        cls.outside_file.touch()\n\n    @classmethod\n    def tearDownClass(cls):\n        cls.test_dir.cleanup()\n\n    def setUp(self):\n        user_service.user_directories = {\n            'test_user': self.user_home\n        }\n\n    def test_valid_user_and_existing_file(self):\n        # Test with valid user and existing file in root directory\n        result = user_service.get_user_file('test_user', 'test.txt')\n        self.assertEqual(result, self.valid_file)\n\n    def test_valid_user_non_existing_file(self):\n        # Test valid user but non-existent file\n        with self.assertRaises(FileNotFoundError):\n            user_service.get_user_file('test_user', 'non_existent.txt')\n\n    def test_invalid_user(self):\n        # Test with user not in user_directories\n        with self.assertRaises(KeyError):\n            user_service.get_user_file('invalid_user', 'test.txt')\n\n    def test_relative_path_escape(self):\n        # Test relative path escaping user directory\n        with self.assertRaises(Exception) as context:\n            user_service.get_user_file('test_user', '../outside.txt')\n        self.assertIn(\"Access to path\", str(context.exception))\n\n    def test_empty_path(self):\n        # Test empty path returns user home directory\n        result = user_service.get_user_file('test_user', '')\n        self.assertEqual(result, self.user_home)\n\n    def test_dot_path(self):\n        # Test '.' path returns user home directory\n        result = user_service.get_user_file('test_user', '.')\n        self.assertEqual(result, self.user_home)\n\n    def test_absolute_path_inside(self):\n        # Test absolute path within user directory\n        result = user_service.get_user_file('test_user', str(self.sub_file))\n        self.assertEqual(result, self.sub_file)\n\n    def test_absolute_path_outside(self):\n        # Test absolute path outside user directory\n        with self.assertRaises(Exception) as context:\n            user_service.get_user_file('test_user', str(self.outside_file))\n        self.assertIn(\"Access to path\", str(context.exception))\n\n    def test_relative_path_to_sub_file(self):\n        # Test relative path to file in subdirectory\n        result = user_service.get_user_file('test_user', 'sub/file.txt')\n        self.assertEqual(result, self.sub_file)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 9, "task_id": "05eb87ee"}
{"test": "import unittest\nfrom unittest.mock import patch\nimport tempfile\nimport shutil\nimport os\nfrom pathlib import Path\nfrom user_service import get_user_file\n\nclass TestGetUserFile(unittest.TestCase):\n    def setUp(self):\n        # Create a temporary directory structure\n        self.base_temp = tempfile.mkdtemp()\n        self.base_path = Path(self.base_temp)\n        self.user_dir = self.base_path / 'user1'\n        self.user_dir.mkdir()\n        \n        # Create files and directories\n        self.inside_file = self.user_dir / 'inside.txt'\n        self.inside_file.touch()\n        \n        self.sub_dir = self.user_dir / 'sub'\n        self.sub_dir.mkdir()\n        self.file_in_sub = self.sub_dir / 'file.txt'\n        self.file_in_sub.touch()\n        \n        self.non_ascii_file = self.user_dir / '\\u6587\\u4ef6.txt'  # Non-ASCII filename\n        self.non_ascii_file.touch()\n        \n        self.outside_file = self.base_path / 'outside.txt'\n        self.outside_file.touch()\n\n    def tearDown(self):\n        # Clean up temporary directory\n        if os.path.exists(self.base_temp):\n            shutil.rmtree(self.base_temp)\n\n    def test_valid_file_in_root(self):\n        # Test existing file in user root directory\n        with patch('user_service.user_directories', {'user1': self.user_dir}):\n            result = get_user_file('user1', 'inside.txt')\n            self.assertIsInstance(result, Path)\n            self.assertEqual(result, self.inside_file)\n\n    def test_valid_file_in_subdirectory(self):\n        # Test existing file in user subdirectory\n        with patch('user_service.user_directories', {'user1': self.user_dir}):\n            result = get_user_file('user1', 'sub/file.txt')\n            self.assertIsInstance(result, Path)\n            self.assertEqual(result, self.file_in_sub)\n\n    def test_non_ascii_filename(self):\n        # Test existing file with non-ASCII characters\n        with patch('user_service.user_directories', {'user1': self.user_dir}):\n            result = get_user_file('user1', '\\u6587\\u4ef6.txt')\n            self.assertIsInstance(result, Path)\n            self.assertEqual(result, self.non_ascii_file)\n\n    def test_empty_file_path(self):\n        # Test empty file path (should return user directory)\n        with patch('user_service.user_directories', {'user1': self.user_dir}):\n            result = get_user_file('user1', '')\n            self.assertIsInstance(result, Path)\n            self.assertEqual(result, self.user_dir)\n\n    def test_dot_file_path(self):\n        # Test '.' file path (should return user directory with dot component)\n        with patch('user_service.user_directories', {'user1': self.user_dir}):\n            result = get_user_file('user1', '.')\n            self.assertIsInstance(result, Path)\n            self.assertEqual(result, self.user_dir / '.')\n\n    def test_user_not_found(self):\n        # Test non-existent user ID\n        with patch('user_service.user_directories', {'user1': self.user_dir}):\n            with self.assertRaises(KeyError):\n                get_user_file('invalid_user', 'any_file.txt')\n\n    def test_file_does_not_exist(self):\n        # Test non-existent file in valid user directory\n        with patch('user_service.user_directories', {'user1': self.user_dir}):\n            with self.assertRaises(FileNotFoundError):\n                get_user_file('user1', 'non_existent.txt')\n\n    def test_path_traversal_attempt(self):\n        # Test path traversal outside user directory\n        with patch('user_service.user_directories', {'user1': self.user_dir}):\n            with self.assertRaises(Exception) as context:\n                get_user_file('user1', '../outside.txt')\n            self.assertIn('Access to path', str(context.exception))\n\n    def test_absolute_path_inside_directory(self):\n        # Test absolute path that resolves inside user directory\n        with patch('user_service.user_directories', {'user1': self.user_dir}):\n            abs_path = str(self.inside_file.resolve())\n            result = get_user_file('user1', abs_path)\n            self.assertIsInstance(result, Path)\n            self.assertEqual(result, self.inside_file)\n\n    def test_absolute_path_outside_directory(self):\n        # Test absolute path that resolves outside user directory\n        with patch('user_service.user_directories', {'user1': self.user_dir}):\n            abs_path = str(self.outside_file.resolve())\n            with self.assertRaises(Exception) as context:\n                get_user_file('user1', abs_path)\n            self.assertIn('Access to path', str(context.exception))\n\n    def test_directory_target(self):\n        # Test valid directory path (should return directory)\n        with patch('user_service.user_directories', {'user1': self.user_dir}):\n            result = get_user_file('user1', 'sub')\n            self.assertIsInstance(result, Path)\n            self.assertEqual(result, self.sub_dir)\n\n    def test_large_file_path(self):\n        # Test very long file path\n        with patch('user_service.user_directories', {'user1': self.user_dir}):\n            long_path = 'a' * 1000 + '.txt'\n            (self.user_dir / long_path).touch()\n            result = get_user_file('user1', long_path)\n            self.assertIsInstance(result, Path)\n            self.assertEqual(result, self.user_dir / long_path)\n\n    def test_special_characters_in_path(self):\n        # Test file path with special characters\n        with patch('user_service.user_directories', {'user1': self.user_dir}):\n            special_path = '!@#$%^&()_+-=[]{};,.txt'\n            (self.user_dir / special_path).touch()\n            result = get_user_file('user1', special_path)\n            self.assertIsInstance(result, Path)\n            self.assertEqual(result, self.user_dir / special_path)\n\n    def test_none_user_id(self):\n        # Test None as user ID\n        with patch('user_service.user_directories', {'user1': self.user_dir}):\n            with self.assertRaises(KeyError):\n                get_user_file(None, 'inside.txt')\n\n    def test_none_file_path(self):\n        # Test None as file path\n        with patch('user_service.user_directories', {'user1': self.user_dir}):\n            with self.assertRaises(Exception):\n                get_user_file('user1', None)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 15, "task_id": "f33ab5fc"}
{"test": "import unittest\nfrom unittest.mock import patch\nfrom pathlib import Path\nimport tempfile\n\nclass TestUserService(unittest.TestCase):\n    def setUp(self):\n        # Create a base temporary directory\n        self.base_dir = tempfile.TemporaryDirectory()\n        base_path = Path(self.base_dir.name)\n        \n        # Create user1 root directory\n        self.user1_root = base_path / 'user1'\n        self.user1_root.mkdir()\n        \n        # Create files and directories inside user1 root\n        self.file1 = self.user1_root / 'file1.txt'\n        self.file1.touch()\n        \n        self.sub_dir = self.user1_root / 'sub'\n        self.sub_dir.mkdir()\n        self.file2 = self.sub_dir / 'file2.txt'\n        self.file2.touch()\n        \n        self.empty_dir = self.user1_root / 'empty_dir'\n        self.empty_dir.mkdir()\n        \n        # Create a file outside user1 root\n        self.outside_file = base_path / 'outside.txt'\n        self.outside_file.touch()\n        \n        # Create symlinks\n        self.symlink_outside = self.user1_root / 'symlink_outside'\n        self.symlink_outside.symlink_to(self.outside_file)\n        \n        self.symlink_inside = self.user1_root / 'symlink_inside'\n        self.symlink_inside.symlink_to(self.file1)\n        \n        # Create nested directory structure\n        self.dir_a = self.user1_root / 'a'\n        self.dir_a.mkdir()\n        self.file3 = self.dir_a / 'c'\n        self.file3.touch()\n    \n    def tearDown(self):\n        self.base_dir.cleanup()\n    \n    def test_valid_file_in_root(self):\n        # Test retrieving a file in the root directory\n        with patch('user_service.user_directories', {'user1': self.user1_root}):\n            from user_service import retrieve_user_file\n            result = retrieve_user_file('user1', 'file1.txt')\n            self.assertEqual(result, self.file1)\n    \n    def test_valid_file_in_subdirectory(self):\n        # Test retrieving a file in a subdirectory\n        with patch('user_service.user_directories', {'user1': self.user1_root}):\n            from user_service import retrieve_user_file\n            result = retrieve_user_file('user1', 'sub/file2.txt')\n            self.assertEqual(result, self.file2)\n    \n    def test_directory_exists(self):\n        # Test retrieving an existing directory\n        with patch('user_service.user_directories', {'user1': self.user1_root}):\n            from user_service import retrieve_user_file\n            result = retrieve_user_file('user1', 'empty_dir')\n            self.assertEqual(result, self.empty_dir)\n    \n    def test_user_not_found(self):\n        # Test with non-existent user_key\n        with patch('user_service.user_directories', {'user1': self.user1_root}):\n            from user_service import retrieve_user_file\n            with self.assertRaises(KeyError):\n                retrieve_user_file('user2', 'file1.txt')\n    \n    def test_file_not_found(self):\n        # Test with non-existent file\n        with patch('user_service.user_directories', {'user1': self.user1_root}):\n            from user_service import retrieve_user_file\n            with self.assertRaises(FileNotFoundError):\n                retrieve_user_file('user1', 'nonexistent.txt')\n    \n    def test_path_traversal_escape(self):\n        # Test escaping user root via relative path\n        with patch('user_service.user_directories', {'user1': self.user1_root}):\n            from user_service import retrieve_user_file\n            with self.assertRaises(Exception):\n                retrieve_user_file('user1', '../outside.txt')\n    \n    def test_path_dot_dot_inside(self):\n        # Test relative path with '..' that stays inside user root\n        with patch('user_service.user_directories', {'user1': self.user1_root}):\n            from user_service import retrieve_user_file\n            result = retrieve_user_file('user1', 'sub/../file1.txt')\n            self.assertEqual(result, self.file1)\n    \n    def test_empty_relative_path(self):\n        # Test with empty relative path (returns root directory)\n        with patch('user_service.user_directories', {'user1': self.user1_root}):\n            from user_service import retrieve_user_file\n            result = retrieve_user_file('user1', '')\n            self.assertEqual(result, self.user1_root)\n    \n    def test_dot_relative_path(self):\n        # Test with '.' relative path (returns root directory)\n        with patch('user_service.user_directories', {'user1': self.user1_root}):\n            from user_service import retrieve_user_file\n            result = retrieve_user_file('user1', '.')\n            self.assertEqual(result, self.user1_root)\n    \n    def test_absolute_path(self):\n        # Test with absolute path for rel_path\n        with patch('user_service.user_directories', {'user1': self.user1_root}):\n            from user_service import retrieve_user_file\n            abs_path = self.file1.resolve().as_posix()\n            with self.assertRaises(Exception):\n                retrieve_user_file('user1', abs_path)\n    \n    def test_non_string_user_key(self):\n        # Test with non-string user_key (integer)\n        with patch('user_service.user_directories', {'user1': self.user1_root}):\n            from user_service import retrieve_user_file\n            with self.assertRaises(KeyError):\n                retrieve_user_file(123, 'file1.txt')\n    \n    def test_non_string_rel_path(self):\n        # Test with non-string rel_path (integer)\n        with patch('user_service.user_directories', {'user1': self.user1_root}):\n            from user_service import retrieve_user_file\n            with self.assertRaises(TypeError):\n                retrieve_user_file('user1', 123)\n    \n    def test_user_key_none(self):\n        # Test with None for user_key\n        with patch('user_service.user_directories', {'user1': self.user1_root}):\n            from user_service import retrieve_user_file\n            with self.assertRaises(KeyError):\n                retrieve_user_file(None, 'file1.txt')\n    \n    def test_rel_path_none(self):\n        # Test with None for rel_path\n        with patch('user_service.user_directories', {'user1': self.user1_root}):\n            from user_service import retrieve_user_file\n            with self.assertRaises(TypeError):\n                retrieve_user_file('user1', None)\n    \n    def test_complex_relative_path_inside(self):\n        # Test complex relative path that stays inside\n        with patch('user_service.user_directories', {'user1': self.user1_root}):\n            from user_service import retrieve_user_file\n            result = retrieve_user_file('user1', 'a/b/../c')\n            self.assertEqual(result, self.file3)\n    \n    def test_symlink_to_outside(self):\n        # Test symlink pointing outside user root\n        with patch('user_service.user_directories', {'user1': self.user1_root}):\n            from user_service import retrieve_user_file\n            with self.assertRaises(Exception):\n                retrieve_user_file('user1', 'symlink_outside')\n    \n    def test_symlink_inside(self):\n        # Test symlink pointing inside user root\n        with patch('user_service.user_directories', {'user1': self.user1_root}):\n            from user_service import retrieve_user_file\n            result = retrieve_user_file('user1', 'symlink_inside')\n            self.assertEqual(result, self.symlink_inside)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 17, "task_id": "81cec4ab"}
{"test": "import unittest\nimport tempfile\nfrom pathlib import Path\nimport shutil\nimport user_service\n\nclass TestLoadUserData(unittest.TestCase):\n\n    @classmethod\n    def setUpClass(cls):\n        # Create a temporary directory structure\n        cls.test_dir = Path(tempfile.mkdtemp())\n        cls.user1_dir = cls.test_dir / 'user1'\n        cls.user1_dir.mkdir()\n        cls.user2_dir = cls.test_dir / 'user2'\n        cls.user2_dir.mkdir()\n        \n        # Create files for user1\n        (cls.user1_dir / 'file1.txt').touch()\n        (cls.user1_dir / 'empty.txt').touch()\n        subdir = cls.user1_dir / 'subdir'\n        subdir.mkdir()\n        (subdir / 'file2.txt').touch()\n        \n        # Create files for user2\n        (cls.user2_dir / 'secret.txt').touch()\n        \n        # Initialize user_directories in the user_service module\n        user_service.user_directories = {\n            'user1': cls.user1_dir,\n            'user2': cls.user2_dir\n        }\n\n    @classmethod\n    def tearDownClass(cls):\n        # Clean up the temporary directory\n        shutil.rmtree(cls.test_dir)\n\n    def test_valid_file_in_root(self):\n        # Test loading a file in the root directory of a valid user\n        result = user_service.load_user_data('user1', 'file1.txt')\n        self.assertEqual(result, self.user1_dir / 'file1.txt')\n        self.assertTrue(result.exists())\n\n    def test_valid_file_in_subdir(self):\n        # Test loading a file in a subdirectory of a valid user\n        result = user_service.load_user_data('user1', 'subdir/file2.txt')\n        self.assertEqual(result, self.user1_dir / 'subdir' / 'file2.txt')\n        self.assertTrue(result.exists())\n\n    def test_uid_not_found(self):\n        # Test with a uid that doesn't exist in user_directories\n        with self.assertRaises(KeyError):\n            user_service.load_user_data('user3', 'file1.txt')\n\n    def test_file_not_found(self):\n        # Test with a valid user but non-existent file path\n        with self.assertRaises(FileNotFoundError):\n            user_service.load_user_data('user1', 'non_existent.txt')\n\n    def test_path_traversal_attempt(self):\n        # Test path traversal attempt using '../'\n        with self.assertRaises(Exception) as context:\n            user_service.load_user_data('user1', '../user2/secret.txt')\n        self.assertIn('Access to path', str(context.exception))\n\n    def test_absolute_path_input(self):\n        # Test with absolute path as file_path argument\n        abs_path = self.user2_dir / 'secret.txt'\n        with self.assertRaises(Exception) as context:\n            user_service.load_user_data('user1', str(abs_path))\n        self.assertIn('Access to path', str(context.exception))\n\n    def test_empty_file_path(self):\n        # Test with empty file_path (should return user root directory)\n        result = user_service.load_user_data('user1', '')\n        self.assertEqual(result, self.user1_dir)\n        self.assertTrue(result.exists())\n\n    def test_directory_path(self):\n        # Test with a directory path instead of a file\n        result = user_service.load_user_data('user1', 'subdir')\n        self.assertEqual(result, self.user1_dir / 'subdir')\n        self.assertTrue(result.exists())", "num_test_cases": 8, "task_id": "7eff4eb8"}
{"test": "import unittest\nfrom pathlib import Path\nimport tempfile\n\ntry:\n    import user_service\nexcept ImportError:\n    user_service = None\n\nclass TestGetUserData(unittest.TestCase):\n    @classmethod\n    def setUpClass(cls):\n        cls.test_dir = tempfile.TemporaryDirectory()\n        cls.user_root = Path(cls.test_dir.name)\n        cls.user_id = \"test_user\"\n        cls.user_dir = cls.user_root / cls.user_id\n        cls.user_dir.mkdir()\n        cls.test_file = cls.user_dir / \"test.txt\"\n        cls.test_file.write_text(\"Hello, World!\")\n        cls.sub_dir = cls.user_dir / \"sub\"\n        cls.sub_dir.mkdir()\n        cls.sub_file = cls.sub_dir / \"subfile.txt\"\n        cls.sub_file.write_text(\"Sub file\")\n        cls.outside_file = cls.user_root / \"outside.txt\"\n        cls.outside_file.write_text(\"Outside\")\n        if user_service is not None:\n            user_service.user_record = {cls.user_id: cls.user_dir}\n    \n    @classmethod\n    def tearDownClass(cls):\n        cls.test_dir.cleanup()\n    \n    def setUp(self):\n        if user_service is None:\n            self.skipTest(\"user_service module not found\")\n    \n    def test_happy_path(self):\n        # Happy path: existing user and file\n        result = user_service.get_user_data(self.user_id, \"test.txt\")\n        self.assertEqual(result, self.test_file)\n    \n    def test_user_not_found(self):\n        # Non-existent user ID\n        with self.assertRaises(KeyError):\n            user_service.get_user_data(\"non_existent_user\", \"test.txt\")\n    \n    def test_file_not_found(self):\n        # Valid user but non-existent file\n        with self.assertRaises(FileNotFoundError):\n            user_service.get_user_data(self.user_id, \"non_existent.txt\")\n    \n    def test_path_traversal_outside(self):\n        # File path escapes user directory\n        with self.assertRaises(Exception) as context:\n            user_service.get_user_data(self.user_id, \"../outside.txt\")\n        self.assertIn(\"Access to path\", str(context.exception))\n    \n    def test_path_traversal_inside(self):\n        # Path with '..' staying within user directory\n        result = user_service.get_user_data(self.user_id, \"sub/../test.txt\")\n        self.assertEqual(result, self.test_file)\n    \n    def test_empty_filepath(self):\n        # Empty filepath returns user directory\n        result = user_service.get_user_data(self.user_id, \"\")\n        self.assertEqual(result, self.user_dir)\n    \n    def test_filepath_with_absolute_path(self):\n        # Absolute path outside user directory\n        with self.assertRaises(Exception) as context:\n            user_service.get_user_data(self.user_id, str(self.outside_file))\n        self.assertIn(\"Access to path\", str(context.exception))\n    \n    def test_file_in_subdirectory(self):\n        # File in nested directory\n        result = user_service.get_user_data(self.user_id, \"sub/subfile.txt\")\n        self.assertEqual(result, self.sub_file)\n    \n    def test_empty_uid(self):\n        # Empty user ID not in user_record\n        with self.assertRaises(KeyError):\n            user_service.get_user_data(\"\", \"test.txt\")\n    \n    def test_symlink_security(self):\n        # Symlink pointing outside user directory (resolve() follows symlinks)\n        symlink_path = self.user_dir / \"malicious_symlink\"\n        symlink_path.symlink_to(self.outside_file)\n        with self.assertRaises(Exception) as context:\n            user_service.get_user_data(self.user_id, \"malicious_symlink\")\n        self.assertIn(\"Access to path\", str(context.exception))", "num_test_cases": 10, "task_id": "730e401d"}
{"test": "import unittest\nimport tempfile\nfrom pathlib import Path\n\n# Global user_profiles dictionary required by the function\nuser_profiles = {}\n\nclass TestCases(unittest.TestCase):\n    @classmethod\n    def setUpClass(cls):\n        # Create a temporary directory structure\n        cls.temp_dir = tempfile.TemporaryDirectory()\n        cls.base_path = Path(cls.temp_dir.name)\n        \n        # Setup user1 directory and files\n        cls.user1_dir = cls.base_path / 'user1'\n        cls.user1_dir.mkdir()\n        (cls.user1_dir / 'file1.txt').touch()\n        cls.user1_subdir = cls.user1_dir / 'allowed_dir'\n        cls.user1_subdir.mkdir()\n        (cls.user1_subdir / 'file2.txt').touch()\n        \n        # Setup user2 directory and files\n        cls.user2_dir = cls.base_path / 'user2'\n        cls.user2_dir.mkdir()\n        (cls.user2_dir / 'file3.txt').touch()\n        \n        # Create a file outside all user directories\n        cls.outside_file = cls.base_path / 'outside.txt'\n        cls.outside_file.touch()\n        \n        # Backup original user_profiles and set test data\n        cls.original_user_profiles = globals().get('user_profiles', {})\n        globals()['user_profiles'] = {\n            'user1': cls.user1_dir,\n            'user2': cls.user2_dir\n        }\n    \n    @classmethod\n    def tearDownClass(cls):\n        # Restore original user_profiles and clean up\n        globals()['user_profiles'] = cls.original_user_profiles\n        cls.temp_dir.cleanup()\n    \n    def test_existing_file_in_root(self):\n        # Happy path: existing file in user's root directory\n        result = retrieve_profile_data('user1', 'file1.txt')\n        self.assertEqual(result, self.user1_dir / 'file1.txt')\n    \n    def test_existing_file_in_subdirectory(self):\n        # Happy path: existing file in user's subdirectory\n        result = retrieve_profile_data('user1', 'allowed_dir/file2.txt')\n        self.assertEqual(result, self.user1_subdir / 'file2.txt')\n    \n    def test_non_existent_user(self):\n        # KeyError: user not found in user_profiles\n        with self.assertRaises(KeyError):\n            retrieve_profile_data('user3', 'file1.txt')\n    \n    def test_non_existent_file(self):\n        # FileNotFoundError: file does not exist in user's directory\n        with self.assertRaises(FileNotFoundError):\n            retrieve_profile_data('user1', 'non_existent.txt')\n    \n    def test_relative_traversal_outside_exists(self):\n        # Exception: relative path escapes user directory (file exists)\n        with self.assertRaises(Exception) as context:\n            retrieve_profile_data('user1', '../outside.txt')\n        self.assertIn('Access to path ../outside.txt is not allowed', str(context.exception))\n    \n    def test_relative_traversal_outside_not_exists(self):\n        # Exception: relative path escapes user directory (file doesn't exist)\n        with self.assertRaises(Exception) as context:\n            retrieve_profile_data('user1', '../../nonexistent')\n        self.assertIn('Access to path ../../nonexistent is not allowed', str(context.exception))\n    \n    def test_absolute_path_outside(self):\n        # Exception: absolute path outside user directory\n        abs_path = str(self.outside_file.resolve())\n        with self.assertRaises(Exception) as context:\n            retrieve_profile_data('user1', abs_path)\n        self.assertIn(f'Access to path {abs_path} is not allowed', str(context.exception))\n    \n    def test_empty_file_request(self):\n        # Edge case: empty file_request returns user directory\n        result = retrieve_profile_data('user1', '')\n        self.assertEqual(result, self.user1_dir)\n    \n    def test_dot_file_request(self):\n        # Edge case: '.' returns user directory\n        result = retrieve_profile_data('user1', '.')\n        self.assertEqual(result, self.user1_dir)\n    \n    def test_relative_path_within_user(self):\n        # Valid relative path using '..' that stays within user directory\n        result = retrieve_profile_data('user1', 'allowed_dir/../file1.txt')\n        self.assertEqual(result, self.user1_dir / 'file1.txt')\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 10, "task_id": "021b47fd"}
{"test": "import unittest\nfrom pathlib import Path\nimport tempfile\nfrom unittest.mock import patch\n\nclass TestCases(unittest.TestCase):\n    def test_basic_file(self):\n        # Test accessing a basic file in the user directory\n        with tempfile.TemporaryDirectory() as tmpdir:\n            base_path = Path(tmpdir)\n            user_dir = base_path / 'user1'\n            user_dir.mkdir()\n            file_path = user_dir / 'test.txt'\n            file_path.write_text('test')\n            with patch('__main__.users_mapping', {'user1': user_dir}):\n                result = access_user_file('user1', 'test.txt')\n                self.assertEqual(result, file_path)\n    \n    def test_directory_itself(self):\n        # Test accessing the user directory itself (empty rel_path)\n        with tempfile.TemporaryDirectory() as tmpdir:\n            base_path = Path(tmpdir)\n            user_dir = base_path / 'user1'\n            user_dir.mkdir()\n            with patch('__main__.users_mapping', {'user1': user_dir}):\n                result = access_user_file('user1', '')\n                self.assertEqual(result, user_dir)\n    \n    def test_file_in_subdirectory(self):\n        # Test accessing a file in a subdirectory\n        with tempfile.TemporaryDirectory() as tmpdir:\n            base_path = Path(tmpdir)\n            user_dir = base_path / 'user1'\n            user_dir.mkdir()\n            subdir = user_dir / 'sub'\n            subdir.mkdir()\n            file_path = subdir / 'file.txt'\n            file_path.write_text('test')\n            with patch('__main__.users_mapping', {'user1': user_dir}):\n                result = access_user_file('user1', 'sub/file.txt')\n                self.assertEqual(result, file_path)\n    \n    def test_user_not_found(self):\n        # Test accessing a non-existent user\n        with patch('__main__.users_mapping', {}):\n            with self.assertRaises(KeyError) as context:\n                access_user_file('user1', 'test.txt')\n            self.assertEqual(str(context.exception), \"User user1 not found\")\n    \n    def test_file_not_found(self):\n        # Test accessing a non-existent file\n        with tempfile.TemporaryDirectory() as tmpdir:\n            base_path = Path(tmpdir)\n            user_dir = base_path / 'user1'\n            user_dir.mkdir()\n            with patch('__main__.users_mapping', {'user1': user_dir}):\n                with self.assertRaises(FileNotFoundError) as context:\n                    access_user_file('user1', 'non_existent.txt')\n                self.assertEqual(str(context.exception), f\"File {user_dir / 'non_existent.txt'} does not exist\")\n    \n    def test_escaping_path(self):\n        # Test accessing a file outside the user directory\n        with tempfile.TemporaryDirectory() as tmpdir:\n            base_path = Path(tmpdir)\n            user_dir = base_path / 'user1'\n            user_dir.mkdir()\n            outside_file = base_path / 'outside.txt'\n            outside_file.write_text('secret')\n            with patch('__main__.users_mapping', {'user1': user_dir}):\n                with self.assertRaises(Exception) as context:\n                    access_user_file('user1', '../outside.txt')\n                self.assertEqual(str(context.exception), \"Access to path ../outside.txt is not allowed\")\n    \n    def test_rel_path_integer(self):\n        # Test non-string rel_path (integer)\n        with tempfile.TemporaryDirectory() as tmpdir:\n            base_path = Path(tmpdir)\n            user_dir = base_path / 'user1'\n            user_dir.mkdir()\n            with patch('__main__.users_mapping', {'user1': user_dir}):\n                with self.assertRaises(TypeError):\n                    access_user_file('user1', 123)\n    \n    def test_rel_path_none(self):\n        # Test non-string rel_path (None)\n        with tempfile.TemporaryDirectory() as tmpdir:\n            base_path = Path(tmpdir)\n            user_dir = base_path / 'user1'\n            user_dir.mkdir()\n            with patch('__main__.users_mapping', {'user1': user_dir}):\n                with self.assertRaises(TypeError):\n                    access_user_file('user1', None)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 8, "task_id": "aefc1f0f"}
{"test": "import unittest\nimport tempfile\nfrom pathlib import Path\nimport __main__\nfrom __main__ import fetch_file_content\n\n\nclass TestFetchFileContent(unittest.TestCase):\n    def setUp(self):\n        self.temp_dir = tempfile.TemporaryDirectory()\n        self.temp_path = Path(self.temp_dir.name)\n        self.user1_dir = self.temp_path / 'user1'\n        self.user2_dir = self.temp_path / 'user2'\n        self.user1_dir.mkdir()\n        self.user2_dir.mkdir()\n        self.file1 = self.user1_dir / 'file1.txt'\n        self.file1.write_text('Content of file1')\n        self.file2 = self.user2_dir / 'file2.txt'\n        self.file2.write_text('Content of file2')\n        self.original_users = getattr(__main__, 'users', None)\n        __main__.users = {\n            'user1': self.user1_dir,\n            'user2': self.user2_dir\n        }\n    \n    def tearDown(self):\n        self.temp_dir.cleanup()\n        if self.original_users is not None:\n            __main__.users = self.original_users\n        else:\n            if hasattr(__main__, 'users'):\n                del __main__.users\n    \n    def test_case_1(self):\n        # Happy path: read existing file for user1\n        content = fetch_file_content('user1', 'file1.txt')\n        self.assertEqual(content, 'Content of file1')\n    \n    def test_case_2(self):\n        # Happy path: read existing file for user2\n        content = fetch_file_content('user2', 'file2.txt')\n        self.assertEqual(content, 'Content of file2')\n    \n    def test_case_3(self):\n        # Edge: non-existent user raises KeyError\n        with self.assertRaises(KeyError):\n            fetch_file_content('user3', 'file1.txt')\n    \n    def test_case_4(self):\n        # Edge: non-existent file for valid user raises ValueError\n        with self.assertRaises(ValueError):\n            fetch_file_content('user1', 'nonexistent.txt')\n    \n    def test_case_5(self):\n        # Security: relative path escaping user directory raises Exception\n        with self.assertRaises(Exception) as context:\n            fetch_file_content('user1', '../user2/file2.txt')\n        self.assertIn('Access to path', str(context.exception))\n    \n    def test_case_6(self):\n        # Edge: read file in subdirectory\n        subdir = self.user1_dir / 'subdir'\n        subdir.mkdir()\n        file3 = subdir / 'file3.txt'\n        file3.write_text('Content of file3')\n        content = fetch_file_content('user1', 'subdir/file3.txt')\n        self.assertEqual(content, 'Content of file3')\n    \n    def test_case_7(self):\n        # Security: absolute path outside user directory raises Exception\n        abs_path = str(self.file2.resolve())\n        with self.assertRaises(Exception) as context:\n            fetch_file_content('user1', abs_path)\n        self.assertIn('Access to path', str(context.exception))\n\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 7, "task_id": "30877d4d"}
{"test": "import unittest\nimport tempfile\nimport shutil\nfrom pathlib import Path\nfrom unittest.mock import patch\nimport sys\n\nclass TestGetFileContents(unittest.TestCase):\n    def setUp(self):\n        # Create a temporary directory structure\n        self.test_dir = Path(tempfile.mkdtemp())\n        \n        # Set up user directories\n        self.user1_dir = self.test_dir / 'user1'\n        self.user1_dir.mkdir()\n        self.user2_dir = self.test_dir / 'user2'\n        self.user2_dir.mkdir()\n        \n        # Create files for user1\n        self.file1 = self.user1_dir / 'file1.txt'\n        self.file1.write_text('User1 file1 content')\n        \n        self.nested_dir = self.user1_dir / 'nested'\n        self.nested_dir.mkdir()\n        self.nested_file = self.nested_dir / 'file2.txt'\n        self.nested_file.write_text('Nested content')\n        \n        # Create file for user2\n        self.user2_file = self.user2_dir / 'file2.txt'\n        self.user2_file.write_text('User2 file2 content')\n        \n        # Prepare users dictionary for patching\n        self.users_dict = {\n            'user1': self.user1_dir,\n            'user2': self.user2_dir\n        }\n        \n        # Patch the global 'users' in the module where get_file_contents is defined\n        module_name = get_file_contents.__module__\n        self.patcher = patch(f'{module_name}.users', self.users_dict)\n        self.patcher.start()\n    \n    def tearDown(self):\n        # Stop patching and clean up temporary directory\n        self.patcher.stop()\n        shutil.rmtree(self.test_dir)\n    \n    def test_valid_user_and_file(self):\n        # Test reading existing file in root directory\n        content = get_file_contents('user1', 'file1.txt')\n        self.assertEqual(content, 'User1 file1 content')\n    \n    def test_valid_user_nested_file(self):\n        # Test reading existing file in nested directory\n        content = get_file_contents('user1', 'nested/file2.txt')\n        self.assertEqual(content, 'Nested content')\n    \n    def test_non_existent_file(self):\n        # Test non-existent file path\n        with self.assertRaises(ValueError):\n            get_file_contents('user1', 'non_existent.txt')\n    \n    def test_invalid_user(self):\n        # Test non-existent user\n        with self.assertRaises(KeyError):\n            get_file_contents('user3', 'file1.txt')\n    \n    def test_relative_path_traversal(self):\n        # Test relative path escaping user directory\n        with self.assertRaises(Exception) as context:\n            get_file_contents('user1', '../user2/file2.txt')\n        self.assertIn('Access to path', str(context.exception))\n    \n    def test_absolute_path_traversal(self):\n        # Test absolute path outside user directory\n        abs_path = self.user2_file.resolve()\n        with self.assertRaises(Exception) as context:\n            get_file_contents('user1', str(abs_path))\n        self.assertIn('Access to path', str(context.exception))\n    \n    def test_directory_path(self):\n        # Test path is a directory (should fail during file open)\n        with self.assertRaises(Exception):\n            get_file_contents('user1', 'nested')\n    \n    def test_empty_username(self):\n        # Test empty username\n        with self.assertRaises(KeyError):\n            get_file_contents('', 'file1.txt')\n    \n    def test_empty_rel_path(self):\n        # Test empty relative path\n        with self.assertRaises(ValueError):\n            get_file_contents('user1', '')\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 9, "task_id": "b92ee560"}
{"test": "import unittest\nfrom unittest.mock import patch, MagicMock, mock_open\n\nclass TestLoadUserFile(unittest.TestCase):\n\n    def test_happy_path_simple(self):\n        \"\"\"Test reading a file with valid user and simple filepath.\"\"\"\n        mock_user_folder = MagicMock()\n        mock_user_folder_resolved = MagicMock()\n        mock_user_folder.resolve.return_value = mock_user_folder_resolved\n        \n        mock_abs_path = MagicMock()\n        mock_abs_path_resolved = MagicMock()\n        mock_abs_path.resolve.return_value = mock_abs_path_resolved\n        \n        with patch('__main__.userdirs', {'test_user': mock_user_folder}):\n            mock_user_folder.__truediv__.return_value = mock_abs_path\n            mock_abs_path_resolved.relative_to.return_value = MagicMock()\n            mock_abs_path.exists.return_value = True\n            \n            with patch('builtins.open', mock_open(read_data='hello world')) as mock_file:\n                result = load_user_file('test_user', 'test.txt')\n                self.assertEqual(result, 'hello world')\n                mock_file.assert_called_once_with(mock_abs_path, 'r')\n\n    def test_happy_path_normalized_relative_path(self):\n        \"\"\"Test reading a file with normalized relative path staying within user directory.\"\"\"\n        mock_user_folder = MagicMock()\n        mock_user_folder_resolved = MagicMock()\n        mock_user_folder.resolve.return_value = mock_user_folder_resolved\n        \n        mock_abs_path = MagicMock()\n        mock_abs_path_resolved = MagicMock()\n        mock_abs_path.resolve.return_value = mock_abs_path_resolved\n        \n        with patch('__main__.userdirs', {'test_user': mock_user_folder}):\n            mock_user_folder.__truediv__.return_value = mock_abs_path\n            mock_abs_path_resolved.relative_to.return_value = MagicMock()\n            mock_abs_path.exists.return_value = True\n            \n            with patch('builtins.open', mock_open(read_data='content')):\n                result = load_user_file('test_user', 'a/../b.txt')\n                self.assertEqual(result, 'content')\n\n    def test_user_not_found(self):\n        \"\"\"Test non-existent user raises KeyError.\"\"\"\n        with patch('__main__.userdirs', {}):\n            with self.assertRaises(KeyError) as context:\n                load_user_file('test_user', 'test.txt')\n            self.assertEqual(str(context.exception), \"'User test_user not found'\")\n\n    def test_file_not_exist(self):\n        \"\"\"Test non-existent file raises ValueError.\"\"\"\n        mock_user_folder = MagicMock()\n        mock_user_folder_resolved = MagicMock()\n        mock_user_folder.resolve.return_value = mock_user_folder_resolved\n        \n        mock_abs_path = MagicMock()\n        mock_abs_path_resolved = MagicMock()\n        mock_abs_path.resolve.return_value = mock_abs_path_resolved\n        \n        with patch('__main__.userdirs', {'test_user': mock_user_folder}):\n            mock_user_folder.__truediv__.return_value = mock_abs_path\n            mock_abs_path_resolved.relative_to.return_value = MagicMock()\n            mock_abs_path.exists.return_value = False\n            \n            with self.assertRaises(ValueError) as context:\n                load_user_file('test_user', 'test.txt')\n            self.assertEqual(str(context.exception), f\"File {mock_abs_path} does not exist\")\n\n    def test_path_traversal_outside(self):\n        \"\"\"Test path escaping user directory raises Exception with correct message.\"\"\"\n        mock_user_folder = MagicMock()\n        mock_user_folder_resolved = MagicMock()\n        mock_user_folder.resolve.return_value = mock_user_folder_resolved\n        \n        mock_abs_path = MagicMock()\n        mock_abs_path_resolved = MagicMock()\n        mock_abs_path.resolve.return_value = mock_abs_path_resolved\n        \n        with patch('__main__.userdirs', {'test_user': mock_user_folder}):\n            mock_user_folder.__truediv__.return_value = mock_abs_path\n            mock_abs_path_resolved.relative_to.side_effect = ValueError\n            \n            with self.assertRaises(Exception) as context:\n                load_user_file('test_user', '../outside.txt')\n            self.assertEqual(str(context.exception), \"Access to path ../outside.txt is not allowed\")\n\n    def test_filepath_empty_string(self):\n        \"\"\"Test empty filepath raises ValueError (file does not exist).\"\"\"\n        mock_user_folder = MagicMock()\n        mock_user_folder_resolved = MagicMock()\n        mock_user_folder.resolve.return_value = mock_user_folder_resolved\n        \n        mock_abs_path = MagicMock()\n        mock_abs_path_resolved = MagicMock()\n        mock_abs_path.resolve.return_value = mock_abs_path_resolved\n        \n        with patch('__main__.userdirs', {'test_user': mock_user_folder}):\n            mock_user_folder.__truediv__.return_value = mock_abs_path\n            mock_abs_path_resolved.relative_to.return_value = MagicMock()\n            mock_abs_path.exists.return_value = False\n            \n            with self.assertRaises(ValueError) as context:\n                load_user_file('test_user', '')\n            self.assertEqual(str(context.exception), f\"File {mock_abs_path} does not exist\")\n\n    def test_filepath_none(self):\n        \"\"\"Test None filepath raises TypeError during path operations.\"\"\"\n        mock_user_folder = MagicMock()\n        with patch('__main__.userdirs', {'test_user': mock_user_folder}):\n            mock_user_folder.__truediv__.side_effect = TypeError\n            \n            with self.assertRaises(TypeError):\n                load_user_file('test_user', None)", "num_test_cases": 7, "task_id": "9220ab01"}
{"test": "import unittest\nimport tempfile\nfrom pathlib import Path\nimport os\n\n# Global users dictionary that the function uses\nusers = {}\n\nclass TestFetchUserFile(unittest.TestCase):\n    def setUp(self):\n        # Create a temporary directory and user directory\n        self.temp_dir = tempfile.TemporaryDirectory()\n        self.temp_dir_path = Path(self.temp_dir.name)\n        self.user_dir = self.temp_dir_path / \"user1\"\n        self.user_dir.mkdir()\n        \n        # Set the global users dictionary for the test\n        global users\n        users = {'user1': self.user_dir}\n    \n    def tearDown(self):\n        # Clean up the temporary directory and reset global users\n        self.temp_dir.cleanup()\n        global users\n        users = {}\n    \n    def test_case_1(self):\n        # Test reading an existing file with content\n        test_file = self.user_dir / \"test.txt\"\n        test_file.write_text(\"Hello, World!\")\n        content = fetch_user_file('user1', 'test.txt')\n        self.assertEqual(content, \"Hello, World!\")\n    \n    def test_case_2(self):\n        # Test user not found\n        with self.assertRaises(KeyError):\n            fetch_user_file('user2', 'test.txt')\n    \n    def test_case_3(self):\n        # Test file does not exist\n        with self.assertRaises(ValueError):\n            fetch_user_file('user1', 'nonexistent.txt')\n    \n    def test_case_4(self):\n        # Test path traversal outside user directory\n        outside_file = self.temp_dir_path / \"outside.txt\"\n        outside_file.write_text(\"Secret\")\n        with self.assertRaises(Exception) as context:\n            fetch_user_file('user1', '../outside.txt')\n        self.assertIn(\"Access to path\", str(context.exception))\n    \n    def test_case_5(self):\n        # Test reading an empty file\n        test_file = self.user_dir / \"empty.txt\"\n        test_file.touch()\n        content = fetch_user_file('user1', 'empty.txt')\n        self.assertEqual(content, \"\")\n    \n    def test_case_6(self):\n        # Test file with special characters\n        test_file = self.user_dir / \"special.txt\"\n        text = \"öäüß@µ¶§£€\"\n        test_file.write_text(text)\n        content = fetch_user_file('user1', 'special.txt')\n        self.assertEqual(content, text)\n    \n    def test_case_7(self):\n        # Test relative path with dot (current directory)\n        test_file = self.user_dir / \"test.txt\"\n        test_file.write_text(\"Hello\")\n        content = fetch_user_file('user1', './test.txt')\n        self.assertEqual(content, \"Hello\")\n    \n    def test_case_8(self):\n        # Test valid symlink within user directory\n        target_file = self.user_dir / \"target.txt\"\n        target_file.write_text(\"Target\")\n        symlink = self.user_dir / \"link.txt\"\n        try:\n            symlink.symlink_to(target_file)\n        except OSError as e:\n            self.skipTest(f\"Symlinks not supported: {e}\")\n        content = fetch_user_file('user1', 'link.txt')\n        self.assertEqual(content, \"Target\")\n    \n    def test_case_9(self):\n        # Test symlink pointing outside user directory\n        outside_file = self.temp_dir_path / \"outside.txt\"\n        outside_file.write_text(\"Outside\")\n        symlink = self.user_dir / \"link.txt\"\n        try:\n            symlink.symlink_to(outside_file)\n        except OSError as e:\n            self.skipTest(f\"Symlinks not supported: {e}\")\n        with self.assertRaises(Exception) as context:\n            fetch_user_file('user1', 'link.txt')\n        self.assertIn(\"Access to path\", str(context.exception))\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 9, "task_id": "3e760678"}
{"test": "import unittest\nimport tempfile\nimport shutil\nfrom pathlib import Path\nimport solution\n\nclass TestLoadUserFile(unittest.TestCase):\n    @classmethod\n    def setUpClass(cls):\n        # Create a temporary directory structure\n        cls.test_dir = Path(tempfile.mkdtemp())\n        \n        # Create user directories\n        cls.user1_dir = cls.test_dir / 'user1'\n        cls.user1_dir.mkdir()\n        cls.user2_dir = cls.test_dir / 'user2'\n        cls.user2_dir.mkdir()\n        \n        # Create files for user1\n        (cls.user1_dir / 'file1.txt').write_text('Hello, World!')\n        (cls.user1_dir / 'file2.txt').write_text('Another file')\n        \n        # Create a subdirectory and file\n        subdir = cls.user1_dir / 'docs'\n        subdir.mkdir()\n        (subdir / 'notes.txt').write_text('Important notes')\n        \n        # Create a valid symlink within user directory\n        (cls.user1_dir / 'valid_symlink').symlink_to(cls.user1_dir / 'file1.txt')\n        \n        # Create an external file and symlink pointing outside\n        cls.external_file = cls.test_dir / 'external.txt'\n        cls.external_file.write_text('External content')\n        (cls.user1_dir / 'invalid_symlink').symlink_to(cls.external_file)\n        \n        # Set up the global users dictionary in the solution module\n        solution.users = {\n            'user1': cls.user1_dir,\n            'user2': cls.user2_dir\n        }\n    \n    @classmethod\n    def tearDownClass(cls):\n        # Clean up the temporary directory\n        shutil.rmtree(cls.test_dir)\n    \n    def test_existing_user_and_file(self):\n        # Test reading an existing file in user directory\n        content = solution.load_user_file('user1', 'file1.txt')\n        self.assertEqual(content, 'Hello, World!')\n    \n    def test_existing_user_subdirectory_file(self):\n        # Test reading a file in a subdirectory\n        content = solution.load_user_file('user1', 'docs/notes.txt')\n        self.assertEqual(content, 'Important notes')\n    \n    def test_valid_symlink_within_directory(self):\n        # Test reading through a symlink pointing to a valid internal file\n        content = solution.load_user_file('user1', 'valid_symlink')\n        self.assertEqual(content, 'Hello, World!')\n    \n    def test_non_existing_user(self):\n        # Test with a non-existent user account\n        with self.assertRaises(KeyError) as cm:\n            solution.load_user_file('unknown_user', 'file.txt')\n        self.assertEqual(str(cm.exception), \"'unknown_user'\")\n    \n    def test_non_existing_file(self):\n        # Test with a non-existent file path\n        with self.assertRaises(ValueError) as cm:\n            solution.load_user_file('user1', 'missing.txt')\n        expected_path = self.user1_dir / 'missing.txt'\n        self.assertEqual(str(cm.exception), f\"File {expected_path} does not exist\")\n    \n    def test_path_traversal_outside_directory(self):\n        # Test path escaping using ../ sequence\n        with self.assertRaises(Exception) as cm:\n            solution.load_user_file('user1', '../../external.txt')\n        self.assertEqual(str(cm.exception), \"Access to path ../../external.txt is not allowed\")\n    \n    def test_symlink_escape_outside_directory(self):\n        # Test symlink pointing outside user directory\n        with self.assertRaises(Exception) as cm:\n            solution.load_user_file('user1', 'invalid_symlink')\n        self.assertEqual(str(cm.exception), \"Access to path invalid_symlink is not allowed\")\n    \n    def test_empty_file_path(self):\n        # Test empty relative file path (attempt to access directory)\n        with self.assertRaises(IsADirectoryError):\n            solution.load_user_file('user1', '')\n    \n    def test_normalized_path_within_directory(self):\n        # Test path with .. that stays within user directory\n        content = solution.load_user_file('user1', 'docs/../file2.txt')\n        self.assertEqual(content, 'Another file')\n    \n    def test_large_file_handling(self):\n        # Test reading a large file\n        large_content = 'A' * 10**6  # 1MB\n        large_file = self.user1_dir / 'large.txt'\n        large_file.write_text(large_content)\n        \n        content = solution.load_user_file('user1', 'large.txt')\n        self.assertEqual(content, large_content)\n    \n    def test_special_characters(self):\n        # Test file name with special characters\n        file_name = 'special@file!name.txt'\n        special_file = self.user1_dir / file_name\n        special_content = 'Special content'\n        special_file.write_text(special_content)\n        \n        content = solution.load_user_file('user1', file_name)\n        self.assertEqual(content, special_content)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 12, "task_id": "806086ba"}
{"test": "import unittest\nimport os\nimport tempfile\nfrom pathlib import Path\nfrom unittest.mock import patch\n\n# Import the function assuming it's in a module named 'solution'\nfrom solution import access_user_file\n\nclass TestAccessUserFile(unittest.TestCase):\n    def setUp(self):\n        # Create a temporary directory structure\n        self.temp_dir = tempfile.TemporaryDirectory()\n        self.temp_path = Path(self.temp_dir.name)\n        \n        # Create user directory\n        self.user_dir = self.temp_path / 'user1'\n        self.user_dir.mkdir()\n        \n        # Create a test file in user directory\n        self.test_file = self.user_dir / 'test.txt'\n        with open(self.test_file, 'w') as f:\n            f.write('Test file content')\n            \n        # Create a subdirectory and file\n        self.sub_dir = self.user_dir / 'docs'\n        self.sub_dir.mkdir()\n        self.sub_file = self.sub_dir / 'note.txt'\n        with open(self.sub_file, 'w') as f:\n            f.write('Subdirectory file content')\n            \n        # Create a file outside the user directory\n        self.outside_file = self.temp_path / 'outside.txt'\n        with open(self.outside_file, 'w') as f:\n            f.write('Outside content')\n            \n        # Define the users dictionary for testing\n        self.users = {'user1': self.user_dir}\n    \n    def tearDown(self):\n        # Clean up the temporary directory\n        self.temp_dir.cleanup()\n    \n    def test_valid_file_in_root(self):\n        # Test reading a valid file in the root of the user directory\n        with patch('solution.users', self.users):\n            content = access_user_file('user1', 'test.txt')\n            self.assertEqual(content, 'Test file content')\n    \n    def test_valid_file_in_subdirectory(self):\n        # Test reading a valid file in a subdirectory\n        with patch('solution.users', self.users):\n            content = access_user_file('user1', 'docs/note.txt')\n            self.assertEqual(content, 'Subdirectory file content')\n    \n    def test_user_not_found(self):\n        # Test with a non-existing user (KeyError expected)\n        with patch('solution.users', self.users):\n            with self.assertRaises(KeyError) as context:\n                access_user_file('user2', 'test.txt')\n            self.assertEqual(str(context.exception), \"User user2 not found\")\n    \n    def test_file_not_found(self):\n        # Test with a non-existing file (ValueError expected)\n        with patch('solution.users', self.users):\n            with self.assertRaises(ValueError) as context:\n                access_user_file('user1', 'missing.txt')\n            self.assertEqual(str(context.exception), f\"File {self.user_dir / 'missing.txt'} does not exist\")\n    \n    def test_path_traversal_attempt(self):\n        # Test path traversal attempt using '../' (Exception expected)\n        with patch('solution.users', self.users):\n            with self.assertRaises(Exception) as context:\n                access_user_file('user1', '../outside.txt')\n            self.assertEqual(str(context.exception), \"Access to path ../outside.txt is not allowed\")\n    \n    def test_absolute_path_attempt(self):\n        # Test using absolute path (Exception expected)\n        with patch('solution.users', self.users):\n            abs_path = os.path.abspath(self.outside_file)\n            with self.assertRaises(Exception) as context:\n                access_user_file('user1', abs_path)\n            self.assertEqual(str(context.exception), f\"Access to path {abs_path} is not allowed\")\n    \n    def test_non_string_user_id(self):\n        # Test with non-string user_id (KeyError expected)\n        with patch('solution.users', self.users):\n            with self.assertRaises(KeyError) as context:\n                access_user_file(123, 'test.txt')\n            self.assertEqual(str(context.exception), \"User 123 not found\")\n    \n    def test_non_string_file_location(self):\n        # Test with non-string file_location (TypeError expected)\n        with patch('solution.users', self.users):\n            with self.assertRaises(TypeError):\n                access_user_file('user1', 456)\n    \n    def test_empty_file_location(self):\n        # Test with empty file_location (OSError expected - directory access)\n        with patch('solution.users', self.users):\n            with self.assertRaises(OSError):\n                access_user_file('user1', '')\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 9, "task_id": "a1575085"}
{"test": "import unittest\nimport tempfile\nimport shutil\nfrom pathlib import Path\nfrom unittest.mock import patch\n\n# Assuming the function is imported from a module named 'solution'\nfrom solution import retrieve_user_file\n\nclass TestRetrieveUserFile(unittest.TestCase):\n\n    def setUp(self):\n        # Create a temporary directory structure\n        self.test_dir = Path(tempfile.mkdtemp())\n        \n        # Setup user1 directory and files\n        self.user1_dir = self.test_dir / 'user1'\n        self.user1_dir.mkdir()\n        \n        # Create a regular file\n        self.file1 = self.user1_dir / 'file1.txt'\n        self.file1.write_text('content1')\n        \n        # Create a nested file\n        self.subdir = self.user1_dir / 'subdir'\n        self.subdir.mkdir()\n        self.nested_file = self.subdir / 'file2.txt'\n        self.nested_file.write_text('content2')\n        \n        # Create an empty file\n        self.empty_file = self.user1_dir / 'empty.txt'\n        self.empty_file.write_text('')\n        \n        # Create a file outside user directory (for traversal test)\n        self.outside_file = self.test_dir / 'outside.txt'\n        self.outside_file.write_text('outside content')\n        \n        # Setup user2 directory (empty)\n        self.user2_dir = self.test_dir / 'user2'\n        self.user2_dir.mkdir()\n        \n        # Mock the global 'users' dictionary\n        self.users = {\n            'user1': self.user1_dir,\n            'user2': self.user2_dir\n        }\n\n    def tearDown(self):\n        # Clean up temporary directory\n        shutil.rmtree(self.test_dir)\n\n    def test_happy_path(self):\n        # Test reading existing file in user's root directory\n        with patch('solution.users', self.users):\n            content = retrieve_user_file('user1', 'file1.txt')\n            self.assertEqual(content, 'content1')\n            \n    def test_nested_file(self):\n        # Test reading a nested file within the user's directory\n        with patch('solution.users', self.users):\n            content = retrieve_user_file('user1', 'subdir/file2.txt')\n            self.assertEqual(content, 'content2')\n            \n    def test_user_not_found(self):\n        # Test with non-existent user\n        with patch('solution.users', self.users):\n            with self.assertRaises(KeyError):\n                retrieve_user_file('user3', 'file1.txt')\n                \n    def test_file_not_found(self):\n        # Test with non-existent file in user's directory\n        with patch('solution.users', self.users):\n            with self.assertRaises(ValueError):\n                retrieve_user_file('user1', 'nonexistent.txt')\n                \n    def test_empty_file(self):\n        # Test reading an empty file\n        with patch('solution.users', self.users):\n            content = retrieve_user_file('user1', 'empty.txt')\n            self.assertEqual(content, '')\n            \n    def test_path_traversal_attempt(self):\n        # Test relative path escaping user directory\n        with patch('solution.users', self.users):\n            with self.assertRaises(Exception) as context:\n                retrieve_user_file('user1', '../outside.txt')\n            self.assertIn('Access to path', str(context.exception))\n            \n    def test_relative_path_escape_within_directory(self):\n        # Test valid relative path that stays within user directory\n        with patch('solution.users', self.users):\n            # Create a file with dot in name\n            dot_file = self.user1_dir / '..test.txt'\n            dot_file.write_text('dot_content')\n            content = retrieve_user_file('user1', '..test.txt')\n            self.assertEqual(content, 'dot_content')\n            \n    def test_invalid_path_type(self):\n        # Test invalid relative path type\n        with patch('solution.users', self.users):\n            with self.assertRaises(Exception):\n                # Pass a non-string path\n                retrieve_user_file('user1', 123)\n                \n    def test_directory_path(self):\n        # Test providing a directory path instead of a file\n        with patch('solution.users', self.users):\n            with self.assertRaises(Exception):\n                retrieve_user_file('user1', 'subdir')", "num_test_cases": 9, "task_id": "70b2c566"}
{"test": "import unittest\nfrom pathlib import Path\nimport tempfile\nimport __main__\n\nclass TestFetchUserData(unittest.TestCase):\n    def setUp(self):\n        self.base_dir = tempfile.TemporaryDirectory()\n        self.base_path = Path(self.base_dir.name)\n        self.user1_dir = self.base_path / \"user1\"\n        self.user1_dir.mkdir()\n        self.user2_dir = self.base_path / \"user2\"\n        self.user2_dir.mkdir()\n        (self.user1_dir / \"file1.txt\").write_text(\"Content of user1 file1\")\n        subdir = self.user1_dir / \"subdir\"\n        subdir.mkdir()\n        (subdir / \"file2.txt\").write_text(\"Content of user1 file2\")\n        (self.user2_dir / \"another.txt\").write_text(\"Content of user2 another\")\n        __main__.users = {\"user1\": self.user1_dir, \"user2\": self.user2_dir}\n    \n    def tearDown(self):\n        self.base_dir.cleanup()\n    \n    def test_happy_path_root_file(self):\n        # Test reading a file in the root directory of a valid user\n        content = fetch_user_data(\"user1\", \"file1.txt\")\n        self.assertEqual(content, \"Content of user1 file1\")\n    \n    def test_happy_path_subdir_file(self):\n        # Test reading a file in a subdirectory of a valid user\n        content = fetch_user_data(\"user1\", \"subdir/file2.txt\")\n        self.assertEqual(content, \"Content of user1 file2\")\n    \n    def test_non_existing_user(self):\n        # Test with a user_id not present in the users mapping\n        with self.assertRaises(KeyError):\n            fetch_user_data(\"user3\", \"file1.txt\")\n    \n    def test_non_existing_file(self):\n        # Test with a valid user but non-existent file\n        with self.assertRaises(ValueError):\n            fetch_user_data(\"user1\", \"non_existing.txt\")\n    \n    def test_path_traversal_simple(self):\n        # Test relative path attempting to access another user's file\n        with self.assertRaises(Exception) as context:\n            fetch_user_data(\"user1\", \"../user2/another.txt\")\n        self.assertIn(\"Access to path\", str(context.exception))\n    \n    def test_empty_relative_path(self):\n        # Test with empty relative_path (file does not exist)\n        with self.assertRaises(ValueError):\n            fetch_user_data(\"user1\", \"\")\n    \n    def test_absolute_path(self):\n        # Test with an absolute path (should be blocked by security check)\n        abs_path = self.user1_dir / \"file1.txt\"\n        with self.assertRaises(Exception) as context:\n            fetch_user_data(\"user1\", str(abs_path))\n        self.assertIn(\"Access to path\", str(context.exception))\n    \n    def test_path_traversal_complex(self):\n        # Test complex path traversal (multiple ../) to access another user's file\n        with self.assertRaises(Exception) as context:\n            fetch_user_data(\"user1\", \"subdir/../../user2/another.txt\")\n        self.assertIn(\"Access to path\", str(context.exception))\n\nif __name__ == \"__main__\":\n    unittest.main()", "num_test_cases": 8, "task_id": "4d7096fd"}
{"test": "import unittest\nimport tempfile\nimport shutil\nimport os\nfrom pathlib import Path\nimport __main__\n\nclass TestGetUserFile(unittest.TestCase):\n    def setUp(self):\n        # Create a temporary base directory\n        self.test_dir = tempfile.mkdtemp()\n        # Setup user directories\n        self.user1_dir = os.path.join(self.test_dir, 'user1')\n        self.user2_dir = os.path.join(self.test_dir, 'user2')\n        os.makedirs(self.user1_dir)\n        os.makedirs(self.user2_dir)\n        # Create files for user1\n        with open(os.path.join(self.user1_dir, 'file1.txt'), 'w') as f:\n            f.write('User1 File1 Content')\n        with open(os.path.join(self.user1_dir, 'empty.txt'), 'w') as f:\n            pass  # Empty file\n        # Create a large file for user1\n        large_content = 'A' * 1000000  # 1MB\n        with open(os.path.join(self.user1_dir, 'large.txt'), 'w') as f:\n            f.write(large_content)\n        # Create a file for user2\n        with open(os.path.join(self.user2_dir, 'file2.txt'), 'w') as f:\n            f.write('User2 File2 Content')\n        # Configure the global 'users' mapping in __main__\n        __main__.users = {\n            'user1': Path(self.user1_dir),\n            'user2': Path(self.user2_dir)\n        }\n    \n    def tearDown(self):\n        # Cleanup the temporary directory\n        shutil.rmtree(self.test_dir)\n    \n    def test_valid_user_and_file(self):\n        # Test reading an existing file for a valid user\n        content = get_user_file('user1', 'file1.txt')\n        self.assertEqual(content, 'User1 File1 Content')\n    \n    def test_empty_file(self):\n        # Test reading an empty file\n        content = get_user_file('user1', 'empty.txt')\n        self.assertEqual(content, '')\n    \n    def test_large_file(self):\n        # Test reading a large file (1MB)\n        large_content = 'A' * 1000000\n        content = get_user_file('user1', 'large.txt')\n        self.assertEqual(content, large_content)\n    \n    def test_user_not_found(self):\n        # Test with a non-existent user\n        with self.assertRaises(KeyError):\n            get_user_file('user3', 'file1.txt')\n    \n    def test_file_not_found(self):\n        # Test with a non-existent file\n        with self.assertRaises(ValueError):\n            get_user_file('user1', 'nonexistent.txt')\n    \n    def test_path_traversal_attempt(self):\n        # Test path traversal (attempt to access another user's file)\n        with self.assertRaises(Exception) as context:\n            get_user_file('user1', '../user2/file2.txt')\n        self.assertIn('Access to path', str(context.exception))\n    \n    def test_non_string_path(self):\n        # Test with non-string path_to_file\n        with self.assertRaises(Exception):\n            get_user_file('user1', 123)\n    \n    def test_non_string_user(self):\n        # Test with non-string person_name\n        with self.assertRaises(Exception):\n            get_user_file(123, 'file1.txt')\n    \n    def test_none_user(self):\n        # Test with None as user\n        with self.assertRaises(Exception):\n            get_user_file(None, 'file1.txt')\n    \n    def test_none_path(self):\n        # Test with None as path\n        with self.assertRaises(Exception):\n            get_user_file('user1', None)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 10, "task_id": "3d42d700"}
{"test": "import unittest\nimport tempfile\nfrom pathlib import Path\nimport document_access\n\nclass TestFindDocument(unittest.TestCase):\n\n    def setUp(self):\n        # Create a temporary directory for testing\n        self.temp_dir = tempfile.TemporaryDirectory()\n        self.allowed_dir_path = Path(self.temp_dir.name).resolve()\n        # Create test files and directories\n        self.test_file = self.allowed_dir_path / 'test_file.txt'\n        self.test_file.write_text('Hello, World!')\n        self.subdir = self.allowed_dir_path / 'subdir'\n        self.subdir.mkdir()\n        self.test_file2 = self.subdir / 'test_file2.txt'\n        self.test_file2.write_text('Another file')\n        self.empty_dir = self.allowed_dir_path / 'empty_dir'\n        self.empty_dir.mkdir()\n        # Set the global allowed_dir in the module\n        document_access.allowed_dir = self.allowed_dir_path\n\n    def tearDown(self):\n        # Clean up the temporary directory\n        self.temp_dir.cleanup()\n\n    def test_existing_file_root(self):\n        # Test existing file at root directory\n        result = document_access.find_document('test_file.txt')\n        self.assertEqual(result, self.test_file)\n\n    def test_existing_file_subdir(self):\n        # Test existing file in a subdirectory\n        result = document_access.find_document('subdir/test_file2.txt')\n        self.assertEqual(result, self.test_file2)\n\n    def test_existing_directory(self):\n        # Test existing directory (should return path even though it's not a file)\n        result = document_access.find_document('empty_dir')\n        self.assertEqual(result, self.empty_dir)\n\n    def test_non_existing_file_root(self):\n        # Test non-existent file at root\n        with self.assertRaises(FileNotFoundError):\n            document_access.find_document('non_existent.txt')\n\n    def test_non_existing_file_subdir(self):\n        # Test non-existent file in a subdirectory\n        with self.assertRaises(FileNotFoundError):\n            document_access.find_document('subdir/non_existent.txt')\n\n    def test_traversal_outside(self):\n        # Test traversal outside allowed_dir with '../'\n        with self.assertRaises(ValueError):\n            document_access.find_document('../outside.txt')\n\n    def test_absolute_path_outside(self):\n        # Test absolute path outside allowed_dir\n        outside_path = Path(self.temp_dir.name).parent / 'outside.txt'\n        with self.assertRaises(ValueError):\n            document_access.find_document(str(outside_path))\n\n    def test_absolute_path_inside(self):\n        # Test absolute path inside allowed_dir\n        abs_path = self.test_file.resolve()\n        result = document_access.find_document(str(abs_path))\n        self.assertEqual(result, abs_path)\n\n    def test_relative_path_with_dot(self):\n        # Test relative path with './' prefix\n        result = document_access.find_document('./test_file.txt')\n        self.assertEqual(result, self.test_file)\n\n    def test_relative_path_with_dotdot_inside(self):\n        # Test relative path with '../' that stays inside allowed_dir\n        result = document_access.find_document('subdir/../test_file.txt')\n        self.assertEqual(result, self.test_file)\n\n    def test_relative_path_with_dotdot_outside(self):\n        # Test relative path with excessive '../' that escapes allowed_dir\n        with self.assertRaises(ValueError):\n            document_access.find_document('subdir/../../outside.txt')\n\n    def test_empty_string(self):\n        # Test empty string as path (points to allowed_dir)\n        result = document_access.find_document('')\n        self.assertEqual(result, self.allowed_dir_path)\n\n    def test_non_string_input(self):\n        # Test non-string input (None)\n        with self.assertRaises(TypeError):\n            document_access.find_document(None)\n", "num_test_cases": 13, "task_id": "b6954a7f"}
{"test": "import unittest\nimport tempfile\nfrom pathlib import Path\n\n# Global variable to be set in test setup\ndocuments_dir = None\n\nclass TestAccessDocument(unittest.TestCase):\n    def setUp(self):\n        \"\"\"Create a temporary directory and set documents_dir.\"\"\"\n        self.temp_dir = tempfile.TemporaryDirectory()\n        global documents_dir\n        documents_dir = Path(self.temp_dir.name)\n    \n    def tearDown(self):\n        \"\"\"Clean up temporary directory after each test.\"\"\"\n        self.temp_dir.cleanup()\n    \n    def test_valid_document(self):\n        \"\"\"Test accessing an existing document in the allowed directory.\"\"\"\n        # Create a test file\n        test_file = documents_dir / 'document.txt'\n        test_file.touch()\n        \n        # Access the document\n        result = access_document('document.txt')\n        self.assertEqual(result, test_file)\n    \n    def test_nonexistent_document(self):\n        \"\"\"Test accessing a non-existent document within the allowed directory.\"\"\"\n        # Attempt to access non-existent file\n        with self.assertRaises(FileNotFoundError) as context:\n            access_document('missing.txt')\n        self.assertIn('Document not found', str(context.exception))\n    \n    def test_relative_path_traversal(self):\n        \"\"\"Test path traversal outside allowed directory using relative path.\"\"\"\n        # Attempt to access a file outside the directory\n        with self.assertRaises(ValueError) as context:\n            access_document('../illegal.txt')\n        self.assertIn('Document path ../illegal.txt is not allowed', str(context.exception))\n    \n    def test_absolute_path_outside_directory(self):\n        \"\"\"Test accessing an absolute path outside allowed directory.\"\"\"\n        # Create a temporary directory outside documents_dir\n        with tempfile.TemporaryDirectory() as outside_dir:\n            outside_path = Path(outside_dir) / 'external.txt'\n            # Attempt to access external file\n            with self.assertRaises(ValueError) as context:\n                access_document(str(outside_path))\n            self.assertIn(f'Document path {outside_path} is not allowed', str(context.exception))\n    \n    def test_empty_document_path(self):\n        \"\"\"Test accessing the base directory with an empty path.\"\"\"\n        result = access_document('')\n        self.assertEqual(result, documents_dir)\n        self.assertTrue(result.exists())\n    \n    def test_subdirectory_document(self):\n        \"\"\"Test accessing a document in a valid subdirectory.\"\"\"\n        # Create subdirectory and file\n        subdir = documents_dir / 'subdir'\n        subdir.mkdir()\n        test_file = subdir / 'file.txt'\n        test_file.touch()\n        \n        # Access the document\n        result = access_document('subdir/file.txt')\n        self.assertEqual(result, test_file)\n    \n    def test_invalid_path_type(self):\n        \"\"\"Test passing non-string path raises TypeError.\"\"\"\n        with self.assertRaises(TypeError):\n            access_document(123)\n    \n    def test_path_with_symlink(self):\n        \"\"\"Test path containing symlink pointing within allowed directory.\"\"\"\n        # Create a file and a symlink within documents_dir\n        target_file = documents_dir / 'target.txt'\n        target_file.touch()\n        symlink_path = documents_dir / 'link.txt'\n        symlink_path.symlink_to(target_file)\n        \n        # Access via symlink\n        result = access_document('link.txt')\n        self.assertEqual(result.resolve(), target_file.resolve())\n    \n    def test_symlink_outside_directory(self):\n        \"\"\"Test symlink pointing outside allowed directory is blocked.\"\"\"\n        with tempfile.TemporaryDirectory() as outside_dir:\n            # Create a file outside documents_dir\n            outside_file = Path(outside_dir) / 'external.txt'\n            outside_file.touch()\n            \n            # Create symlink inside documents_dir pointing outside\n            symlink_path = documents_dir / 'malicious_link.txt'\n            symlink_path.symlink_to(outside_file)\n            \n            # Attempt to access via symlink\n            with self.assertRaises(ValueError) as context:\n                access_document('malicious_link.txt')\n            self.assertIn('Document path malicious_link.txt is not allowed', str(context.exception))", "num_test_cases": 9, "task_id": "a01885d8"}
{"test": "import unittest\nimport tempfile\nfrom pathlib import Path\n\n# Global variable as required by the function\nallowed_directory = None\n\nclass TestLocateDocument(unittest.TestCase):\n    def setUp(self):\n        \"\"\"Set up a temporary directory and set global allowed_directory.\"\"\"\n        global allowed_directory\n        self.temp_dir = tempfile.TemporaryDirectory()\n        allowed_directory = Path(self.temp_dir.name)\n        \n    def tearDown(self):\n        \"\"\"Clean up the temporary directory after each test.\"\"\"\n        self.temp_dir.cleanup()\n    \n    def test_existing_file_root(self):\n        \"\"\"Test locating a file in the root directory.\"\"\"\n        file_path = allowed_directory / \"test.txt\"\n        file_path.touch()\n        result = locate_document(\"test.txt\")\n        self.assertEqual(result, file_path)\n    \n    def test_existing_file_subdirectory(self):\n        \"\"\"Test locating a file in a subdirectory.\"\"\"\n        sub_dir = allowed_directory / \"sub\"\n        sub_dir.mkdir()\n        file_path = sub_dir / \"file.txt\"\n        file_path.touch()\n        result = locate_document(\"sub/file.txt\")\n        self.assertEqual(result, file_path)\n    \n    def test_relative_path_with_dot_dot_inside(self):\n        \"\"\"Test a relative path with '..' that stays inside allowed directory.\"\"\"\n        sub_dir = allowed_directory / \"sub\"\n        sub_dir.mkdir()\n        file_path = allowed_directory / \"target.txt\"\n        file_path.touch()\n        result = locate_document(\"sub/../target.txt\")\n        self.assertEqual(result, allowed_directory / \"sub/../target.txt\")\n    \n    def test_empty_string(self):\n        \"\"\"Test providing an empty string as requested_path.\"\"\"\n        with self.assertRaises(FileNotFoundError):\n            locate_document(\"\")\n    \n    def test_none_path(self):\n        \"\"\"Test providing None as requested_path (invalid type).\"\"\"\n        with self.assertRaises(TypeError):\n            locate_document(None)\n    \n    def test_integer_path(self):\n        \"\"\"Test providing an integer as requested_path (invalid type).\"\"\"\n        with self.assertRaises(TypeError):\n            locate_document(123)\n    \n    def test_absolute_path_inside(self):\n        \"\"\"Test an absolute path that is inside allowed directory.\"\"\"\n        file_path = allowed_directory / \"inside.txt\"\n        file_path.touch()\n        abs_path_inside = str(file_path)\n        result = locate_document(abs_path_inside)\n        self.assertEqual(result, Path(abs_path_inside))\n    \n    def test_absolute_path_outside(self):\n        \"\"\"Test an absolute path that is outside allowed directory.\"\"\"\n        with tempfile.TemporaryDirectory() as outside_dir:\n            abs_path_outside = Path(outside_dir) / \"outside.txt\"\n            abs_path_outside.touch()\n            with self.assertRaises(ValueError):\n                locate_document(str(abs_path_outside))\n    \n    def test_relative_path_outside(self):\n        \"\"\"Test a relative path that attempts to go outside allowed directory.\"\"\"\n        with self.assertRaises(ValueError):\n            locate_document(\"../outside.txt\")\n    \n    def test_non_existing_file_inside(self):\n        \"\"\"Test a non-existing file within allowed directory.\"\"\"\n        with self.assertRaises(FileNotFoundError):\n            locate_document(\"non_existent.txt\")\n    \n    def test_special_characters(self):\n        \"\"\"Test a filename with spaces and non-ASCII characters.\"\"\"\n        file_name = \"file with spaces and ünicöde.txt\"\n        file_path = allowed_directory / file_name\n        file_path.touch()\n        result = locate_document(file_name)\n        self.assertEqual(result, file_path)\n    \n    def test_very_long_path(self):\n        \"\"\"Test a very long filename within allowed directory.\"\"\"\n        long_name = \"a\" * 300 + \".txt\"\n        file_path = allowed_directory / long_name\n        file_path.touch()\n        result = locate_document(long_name)\n        self.assertEqual(result, file_path)\n    \n    def test_existing_directory(self):\n        \"\"\"Test an existing directory (should return the path).\"\"\"\n        dir_name = \"docs\"\n        dir_path = allowed_directory / dir_name\n        dir_path.mkdir()\n        result = locate_document(dir_name)\n        self.assertEqual(result, dir_path)\n", "num_test_cases": 13, "task_id": "59cec4f7"}
{"test": "import unittest\nimport tempfile\nfrom pathlib import Path\n\n# Define the global variable for the test module\nroot_dir = None\n\n# Function implementation for testing\ndef fetch_file(file_path: str) -> Path:\n    full_file_path = root_dir / file_path\n    try:\n        full_file_path.resolve().relative_to(root_dir.resolve())\n    except ValueError:\n        raise ValueError(f\"Document path {file_path} is not allowed\")\n    if not full_file_path.exists():\n        raise FileNotFoundError(f\"Document {full_file_path} not found\")\n    return full_file_path\n\nclass TestFetchFile(unittest.TestCase):\n    def setUp(self):\n        # Create a temporary directory for each test\n        self.temp_dir = tempfile.TemporaryDirectory()\n        global root_dir\n        root_dir = Path(self.temp_dir.name)\n        \n        # Create test files and directories\n        self.file1 = root_dir / 'file1.txt'\n        self.file1.touch()\n        \n        self.subdir = root_dir / 'subdir'\n        self.subdir.mkdir()\n        \n        self.file2 = self.subdir / 'file2.txt'\n        self.file2.touch()\n        \n        self.dir1 = self.subdir / 'dir1'\n        self.dir1.mkdir()\n        \n        self.file3 = root_dir / 'file_ñ.txt'\n        self.file3.touch()\n        \n        # Create a file for normalized path test\n        self.norm_file = root_dir / 'norm.txt'\n        self.norm_file.touch()\n    \n    def tearDown(self):\n        # Clean up the temporary directory\n        self.temp_dir.cleanup()\n    \n    def test_file_in_root(self):\n        # Test fetching a file in root directory\n        result = fetch_file('file1.txt')\n        self.assertEqual(result, self.file1)\n    \n    def test_file_in_subdir(self):\n        # Test fetching a file in subdirectory\n        result = fetch_file('subdir/file2.txt')\n        self.assertEqual(result, self.file2)\n    \n    def test_non_existent_file(self):\n        # Test non-existent file raises FileNotFoundError\n        file_name = 'missing.txt'\n        abs_path = root_dir / file_name\n        with self.assertRaises(FileNotFoundError) as context:\n            fetch_file(file_name)\n        self.assertEqual(str(context.exception), f\"Document {abs_path} not found\")\n    \n    def test_directory_access(self):\n        # Test accessing a directory (should succeed as per implementation)\n        result = fetch_file('subdir/dir1')\n        self.assertEqual(result, self.dir1)\n    \n    def test_empty_path(self):\n        # Test empty path returns root directory\n        result = fetch_file('')\n        self.assertEqual(result, root_dir)\n    \n    def test_normalized_path(self):\n        # Test path with normalization (valid: stays within root)\n        result = fetch_file('subdir/../norm.txt')\n        self.assertEqual(result, self.norm_file)\n    \n    def test_outside_root(self):\n        # Test path escapes root directory\n        with self.assertRaises(ValueError) as context:\n            fetch_file('../external.txt')\n        self.assertEqual(str(context.exception), \"Document path ../external.txt is not allowed\")\n    \n    def test_absolute_path(self):\n        # Test absolute path input (treated as outside root)\n        abs_path = str(self.file1.resolve())\n        with self.assertRaises(ValueError) as context:\n            fetch_file(abs_path)\n        self.assertEqual(str(context.exception), f\"Document path {abs_path} is not allowed\")\n    \n    def test_non_ascii_filename(self):\n        # Test filename with non-ASCII characters\n        result = fetch_file('file_ñ.txt')\n        self.assertEqual(result, self.file3)\n    \n    def test_non_string_input(self):\n        # Test non-string input raises TypeError\n        with self.assertRaises(TypeError):\n            fetch_file(123)\n    \n    def test_symlink_within_root(self):\n        # Test valid symlink within root directory\n        link_path = root_dir / 'link.txt'\n        link_path.symlink_to(self.file1)\n        result = fetch_file('link.txt')\n        self.assertEqual(result, link_path)\n    \n    def test_symlink_outside_root(self):\n        # Test symlink pointing outside root directory\n        external_file = Path(self.temp_dir.name) / 'external'\n        external_file.touch()\n        link_path = root_dir / 'external_link'\n        link_path.symlink_to(external_file)\n        with self.assertRaises(ValueError) as context:\n            fetch_file('external_link')\n        self.assertEqual(str(context.exception), \"Document path external_link is not allowed\")\n    \n    def test_dot_path(self):\n        # Test '.' path (current directory)\n        result = fetch_file('.')\n        self.assertEqual(result, root_dir)\n    \n    def test_dot_dot_path(self):\n        # Test '..' path (parent directory - escapes root)\n        with self.assertRaises(ValueError) as context:\n            fetch_file('..')\n        self.assertEqual(str(context.exception), \"Document path .. is not allowed\")", "num_test_cases": 15, "task_id": "13056fac"}
{"test": "import unittest\nimport tempfile\nfrom pathlib import Path\nfrom unittest.mock import patch\n\nclass TestAccessDocument(unittest.TestCase):\n    def setUp(self):\n        # Create a temporary directory for the secure_dir\n        self.temp_dir = tempfile.TemporaryDirectory()\n        self.temp_dir_path = Path(self.temp_dir.name)\n        # Patch the secure_dir in the module where access_document is defined\n        self.patcher = patch('document_access.secure_dir', self.temp_dir_path)\n        self.patcher.start()\n\n    def tearDown(self):\n        # Clean up the temporary directory and stop patching\n        self.temp_dir.cleanup()\n        self.patcher.stop()\n\n    def test_existing_file_root(self):\n        # Test accessing a file in the root of secure_dir\n        file_path = self.temp_dir_path / 'test.txt'\n        file_path.touch()\n        result = access_document('test.txt')\n        self.assertEqual(result, file_path)\n\n    def test_existing_file_subdir(self):\n        # Test accessing a file in a subdirectory\n        subdir = self.temp_dir_path / 'subdir'\n        subdir.mkdir()\n        file_path = subdir / 'test.txt'\n        file_path.touch()\n        result = access_document('subdir/test.txt')\n        self.assertEqual(result, file_path)\n\n    def test_non_existent_file(self):\n        # Test accessing a non-existent file\n        with self.assertRaises(FileNotFoundError):\n            access_document('nonexistent.txt')\n\n    def test_escape_path(self):\n        # Test path escaping with '../'\n        with self.assertRaises(ValueError):\n            access_document('../outside.txt')\n\n    def test_empty_string(self):\n        # Test with empty string as doc (resolves to secure_dir)\n        result = access_document('')\n        self.assertEqual(result, self.temp_dir_path)\n\n    def test_dot_path(self):\n        # Test path with '.' (current directory)\n        file_path = self.temp_dir_path / 'test.txt'\n        file_path.touch()\n        result = access_document('./test.txt')\n        self.assertEqual(result, file_path)\n\n    def test_normalization_within(self):\n        # Test path with normalization that stays within secure_dir\n        a_dir = self.temp_dir_path / 'a'\n        a_dir.mkdir()\n        c_file = a_dir / 'c.txt'\n        c_file.touch()\n        result = access_document('a/./b/../c.txt')\n        self.assertEqual(result, c_file)\n\n    def test_directory(self):\n        # Test accessing a directory (not a file)\n        subdir = self.temp_dir_path / 'subdir'\n        subdir.mkdir()\n        result = access_document('subdir')\n        self.assertEqual(result, subdir)\n\n    def test_absolute_path_inside(self):\n        # Test absolute path that is inside secure_dir\n        file_path = self.temp_dir_path / 'test.txt'\n        file_path.touch()\n        abs_path_inside = file_path.resolve()\n        result = access_document(str(abs_path_inside))\n        self.assertEqual(result, abs_path_inside)\n\n    def test_absolute_path_outside(self):\n        # Test absolute path that is outside secure_dir\n        with tempfile.TemporaryDirectory() as outside_dir:\n            outside_path = Path(outside_dir) / 'outside.txt'\n            outside_path.touch()\n            with self.assertRaises(ValueError):\n                access_document(str(outside_path))\n\n    def test_non_string_input(self):\n        # Test non-string input (invalid type)\n        with self.assertRaises(TypeError):\n            access_document(123)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 11, "task_id": "15476511"}
{"test": "import unittest\nimport tempfile\nfrom pathlib import Path\nimport sys\n\n# Import the function. Replace 'your_module' with the actual module name.\n# Example: from your_module import get_document\nfrom your_module import get_document\n\nclass TestGetDocument(unittest.TestCase):\n    def setUp(self):\n        # Create a temporary directory\n        self.temp_dir = tempfile.TemporaryDirectory()\n        self.temp_path = Path(self.temp_dir.name)\n        \n        # Get the module where get_document is defined\n        module = sys.modules[get_document.__module__]\n        # Save the original document_root to restore later\n        self.original_document_root = getattr(module, 'document_root', None)\n        # Set document_root to the temporary directory\n        module.document_root = self.temp_path\n        \n        # Create a sample file in the root\n        self.file1 = self.temp_path / 'file1.txt'\n        with open(self.file1, 'w') as f:\n            f.write('Content')\n            \n        # Create a subdirectory and a file in it\n        self.subdir = self.temp_path / 'subdir'\n        self.subdir.mkdir()\n        self.file2 = self.subdir / 'file2.txt'\n        with open(self.file2, 'w') as f:\n            f.write('Content')\n            \n        # Create an empty directory\n        self.empty_dir = self.temp_path / 'empty_dir'\n        self.empty_dir.mkdir()\n        \n        # Define an outside file path (not created)\n        self.outside_file = self.temp_path.parent / 'outside.txt'\n    \n    def tearDown(self):\n        # Clean up the temporary directory\n        self.temp_dir.cleanup()\n        # Restore the original document_root\n        module = sys.modules[get_document.__module__]\n        if self.original_document_root is not None:\n            module.document_root = self.original_document_root\n        else:\n            del module.document_root\n    \n    def test_existing_file_at_root(self):\n        # Test an existing file in the root directory\n        result = get_document('file1.txt')\n        self.assertEqual(result, self.file1)\n    \n    def test_existing_file_in_subdirectory(self):\n        # Test an existing file in a subdirectory\n        result = get_document('subdir/file2.txt')\n        self.assertEqual(result, self.file2)\n    \n    def test_absolute_path_inside_document_root(self):\n        # Test a valid absolute path within the document root\n        result = get_document(str(self.file1))\n        self.assertEqual(result, self.file1)\n    \n    def test_empty_string(self):\n        # Test empty string input (should return document root)\n        result = get_document('')\n        self.assertEqual(result, self.temp_path)\n    \n    def test_non_existent_file_in_root(self):\n        # Test a non-existent file in the root\n        with self.assertRaises(FileNotFoundError) as context:\n            get_document('non_existent.txt')\n        self.assertEqual(str(context.exception), f'Document {self.temp_path/\"non_existent.txt\"} not found')\n    \n    def test_non_existent_file_in_subdirectory(self):\n        # Test a non-existent file in a subdirectory\n        with self.assertRaises(FileNotFoundError) as context:\n            get_document('subdir/non_existent.txt')\n        self.assertEqual(str(context.exception), f'Document {self.subdir/\"non_existent.txt\"} not found')\n    \n    def test_current_directory_dot(self):\n        # Test dot (current directory) input (should return document root)\n        result = get_document('.')\n        self.assertEqual(result, self.temp_path)\n    \n    def test_existing_directory(self):\n        # Test an existing directory (not a file)\n        result = get_document('empty_dir')\n        self.assertEqual(result, self.empty_dir)\n    \n    def test_parent_directory_traversal(self):\n        # Test parent directory traversal (..)\n        with self.assertRaises(ValueError) as context:\n            get_document('..')\n        self.assertEqual(str(context.exception), 'Document path .. is not allowed')\n    \n    def test_parent_directory_traversal_with_file(self):\n        # Test parent directory traversal with a file (../file)\n        with self.assertRaises(ValueError) as context:\n            get_document('../file')\n        self.assertEqual(str(context.exception), 'Document path ../file is not allowed')\n    \n    def test_absolute_path_outside_document_root(self):\n        # Test an absolute path outside the document root\n        with self.assertRaises(ValueError) as context:\n            get_document(str(self.outside_file))\n        self.assertEqual(str(context.exception), f'Document path {self.outside_file} is not allowed')", "num_test_cases": 11, "task_id": "85f2dcca"}
{"test": "import os\nimport sys\nimport tempfile\nimport shutil\nimport unittest\nfrom unittest import mock\nfrom pathlib import Path\n\n# Import the function to test - replace 'your_module' with actual module name\ntry:\n    from your_module import fetch_file\n    module_name = fetch_file.__module__\nexcept ImportError:\n    from __main__ import fetch_file\n    module_name = '__main__'\n\nclass TestFetchFile(unittest.TestCase):\n    def setUp(self):\n        # Create temporary directory structure\n        self.temp_dir = tempfile.mkdtemp()\n        self.root_path = Path(self.temp_dir)\n        \n        # Patch root_dir in the module where fetch_file is defined\n        self.module = sys.modules[module_name]\n        self.patcher = mock.patch.object(self.module, 'root_dir', self.root_path)\n        self.patcher.start()\n        \n        # Create test files and directories\n        (self.root_path / 'file1.txt').touch()\n        self.subdir = self.root_path / 'subdir'\n        self.subdir.mkdir()\n        (self.subdir / 'file2.txt').touch()\n        \n        # Create file outside root\n        self.outside_file = Path(self.temp_dir).parent / 'outside.txt'\n        self.outside_file.touch()\n        \n        # Setup symlinks if supported\n        self.symlink_in = self.root_path / 'sym_in.txt'\n        self.symlink_out = self.root_path / 'sym_out.txt'\n        if hasattr(os, 'symlink'):\n            self.symlink_in.symlink_to(self.root_path / 'file1.txt')\n            self.symlink_out.symlink_to(self.outside_file)\n\n    def tearDown(self):\n        self.patcher.stop()\n        shutil.rmtree(self.temp_dir)\n        self.outside_file.unlink()\n\n    def test_valid_file_at_root(self):\n        # Test existing file at root directory\n        result = fetch_file('file1.txt')\n        self.assertEqual(result, self.root_path / 'file1.txt')\n\n    def test_valid_file_in_subdir(self):\n        # Test existing file in subdirectory\n        result = fetch_file('subdir/file2.txt')\n        self.assertEqual(result, self.subdir / 'file2.txt')\n\n    def test_non_existent_file(self):\n        # Test non-existent file\n        with self.assertRaises(FileNotFoundError):\n            fetch_file('missing.txt')\n\n    def test_empty_file_path(self):\n        # Test empty string file path\n        result = fetch_file('')\n        self.assertEqual(result, self.root_path)\n\n    def test_directory_path(self):\n        # Test path pointing to directory\n        result = fetch_file('subdir')\n        self.assertEqual(result, self.subdir)\n\n    def test_parent_reference_escape(self):\n        # Test path escaping root using '..'\n        with self.assertRaises(ValueError):\n            fetch_file('../outside.txt')\n\n    def test_absolute_path_escape(self):\n        # Test absolute path escaping root\n        abs_path = str(self.outside_file)\n        with self.assertRaises(ValueError):\n            fetch_file(abs_path)\n\n    def test_complex_escape_attempt(self):\n        # Test multiple '../' escaping root\n        with self.assertRaises(ValueError):\n            fetch_file('subdir/../../outside.txt')\n\n    def test_parent_ref_still_in_root(self):\n        # Test '..' that remains within root\n        result = fetch_file('subdir/../file1.txt')\n        self.assertEqual(result, self.root_path / 'file1.txt')\n\n    def test_non_string_input(self):\n        # Test non-string input type\n        with self.assertRaises(TypeError):\n            fetch_file(123)\n\n    def test_none_input(self):\n        # Test None input\n        with self.assertRaises(TypeError):\n            fetch_file(None)\n\n    @unittest.skipIf(not hasattr(os, 'symlink'), \"OS doesn't support symlinks\")\n    def test_valid_symlink_in_root(self):\n        # Test symlink within root directory\n        result = fetch_file('sym_in.txt')\n        self.assertEqual(result, self.symlink_in)\n\n    @unittest.skipIf(not hasattr(os, 'symlink'), \"OS doesn't support symlinks\")\n    def test_symlink_escaping_root(self):\n        # Test symlink pointing outside root\n        with self.assertRaises(ValueError):\n            fetch_file('sym_out.txt')\n\n    def test_very_long_path(self):\n        # Test excessively long file path\n        long_path = 'a' * 1000\n        with self.assertRaises(FileNotFoundError):\n            fetch_file(long_path)\n\n    def test_path_with_dot(self):\n        # Test path containing '.'\n        result = fetch_file('./file1.txt')\n        self.assertEqual(result, self.root_path / 'file1.txt')\n\n    def test_path_with_consecutive_slashes(self):\n        # Test path with redundant slashes\n        result = fetch_file('subdir//file2.txt')\n        self.assertEqual(result, self.subdir / 'file2.txt')", "num_test_cases": 16, "task_id": "e959102d"}
{"test": "import unittest\nimport tempfile\nfrom pathlib import Path\nfrom unittest.mock import patch\n\n# Assume the function is defined in a module named 'module'\nfrom module import get_file\n\nclass TestGetFile(unittest.TestCase):\n\n    def setUp(self):\n        # Create a temporary directory for documents\n        self.temp_dir = tempfile.TemporaryDirectory()\n        self.temp_dir_path = Path(self.temp_dir.name)\n        \n        # Create an outside temporary directory and file\n        self.outside_dir = tempfile.TemporaryDirectory()\n        self.outside_file = Path(self.outside_dir.name) / 'outside.txt'\n        self.outside_file.touch()\n        \n        # Create files and subdirectories in the documents directory\n        (self.temp_dir_path / 'test.txt').touch()\n        self.subdir = self.temp_dir_path / 'subdir'\n        self.subdir.mkdir()\n        (self.subdir / 'sub_test.txt').touch()\n        \n        # Create a directory for testing\n        self.empty_dir = self.temp_dir_path / 'empty_dir'\n        self.empty_dir.mkdir()\n        \n        # Create a file for absolute path testing\n        self.abs_file = self.temp_dir_path / 'abs_test.txt'\n        self.abs_file.touch()\n        \n        # Patch the global documents_dir in the module\n        self.patcher = patch('module.documents_dir', self.temp_dir_path)\n        self.patcher.start()\n\n    def tearDown(self):\n        self.patcher.stop()\n        self.temp_dir.cleanup()\n        self.outside_dir.cleanup()\n\n    def test_existing_file_in_root(self):\n        # Test an existing file in the root directory\n        result = get_file('test.txt')\n        self.assertEqual(result, self.temp_dir_path / 'test.txt')\n\n    def test_existing_file_in_subdirectory(self):\n        # Test an existing file in a subdirectory\n        result = get_file('subdir/sub_test.txt')\n        self.assertEqual(result, self.temp_dir_path / 'subdir' / 'sub_test.txt')\n\n    def test_empty_string_path(self):\n        # Test empty string returns the base documents directory\n        result = get_file('')\n        self.assertEqual(result, self.temp_dir_path)\n\n    def test_dotdot_path_within_directory(self):\n        # Test path with '..' that stays within documents_dir\n        result = get_file('subdir/../test.txt')\n        self.assertEqual(result, self.temp_dir_path / 'test.txt')\n\n    def test_path_traversal_outside_directory(self):\n        # Test path that escapes the documents_dir\n        with self.assertRaises(ValueError):\n            get_file('../outside.txt')\n\n    def test_non_existent_file(self):\n        # Test non-existent file raises FileNotFoundError\n        with self.assertRaises(FileNotFoundError):\n            get_file('non_existent.txt')\n\n    def test_absolute_path_inside_directory(self):\n        # Test absolute path that is within documents_dir\n        result = get_file(str(self.abs_file))\n        self.assertEqual(result, self.abs_file)\n\n    def test_absolute_path_outside_directory(self):\n        # Test absolute path outside documents_dir raises ValueError\n        with self.assertRaises(ValueError):\n            get_file(str(self.outside_file))\n\n    def test_existing_directory(self):\n        # Test existing directory returns its path\n        result = get_file('empty_dir')\n        self.assertEqual(result, self.temp_dir_path / 'empty_dir')\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 9, "task_id": "ceffdcde"}
{"test": "import unittest\nimport tempfile\nfrom pathlib import Path\n\n# Global variable for the designated directory\ndesignated_dir = None\n\ndef access_file(rel_path: str) -> Path:\n    final_document_path = designated_dir / rel_path\n    try:\n        final_document_path.resolve().relative_to(designated_dir.resolve())\n    except ValueError:\n        raise ValueError(f\"Document path {rel_path} is not allowed\")\n    if not final_document_path.exists():\n        raise FileNotFoundError(f\"Document {final_document_path} not found\")\n    return final_document_path\n\nclass TestAccessFile(unittest.TestCase):\n    def setUp(self):\n        # Create a temporary directory\n        self.test_dir = tempfile.TemporaryDirectory()\n        # Create a designated directory inside the temporary directory\n        self.designated_path = Path(self.test_dir.name) / 'docs'\n        self.designated_path.mkdir()\n        # Set the global designated_dir to the designated_path\n        global designated_dir\n        designated_dir = self.designated_path\n    \n    def tearDown(self):\n        # Clean up the temporary directory\n        self.test_dir.cleanup()\n    \n    def test_existing_file_root(self):\n        # Test accessing a file in the root of the designated directory\n        file_path = designated_dir / 'test.txt'\n        file_path.touch()\n        result = access_file('test.txt')\n        self.assertEqual(result, file_path)\n    \n    def test_existing_file_subdir(self):\n        # Test accessing a file in a subdirectory\n        subdir = designated_dir / 'sub'\n        subdir.mkdir()\n        file_path = subdir / 'test.txt'\n        file_path.touch()\n        result = access_file('sub/test.txt')\n        self.assertEqual(result, file_path)\n    \n    def test_non_existing_file(self):\n        # Test accessing a non-existent file\n        with self.assertRaises(FileNotFoundError):\n            access_file('non_existent.txt')\n    \n    def test_escape_sequence(self):\n        # Test a path that escapes the designated directory\n        with self.assertRaises(ValueError):\n            access_file('../outside.txt')\n    \n    def test_empty_string(self):\n        # Test an empty string as the relative path\n        result = access_file('')\n        self.assertEqual(result, designated_dir)\n    \n    def test_non_string_none(self):\n        # Test None input\n        with self.assertRaises(TypeError):\n            access_file(None)\n    \n    def test_non_string_int(self):\n        # Test integer input\n        with self.assertRaises(TypeError):\n            access_file(123)\n    \n    def test_absolute_path_inside(self):\n        # Test an absolute path within the designated directory\n        file_path = designated_dir / 'inside.txt'\n        file_path.touch()\n        abs_path = str(file_path)\n        result = access_file(abs_path)\n        self.assertEqual(result, file_path)\n    \n    def test_absolute_path_outside(self):\n        # Test an absolute path outside the designated directory\n        parent_dir = designated_dir.parent\n        outside_file = parent_dir / 'outside.txt'\n        abs_path = str(outside_file)\n        with self.assertRaises(ValueError):\n            access_file(abs_path)\n    \n    def test_dot_dot_within(self):\n        # Test a path with '..' that stays within the designated directory\n        file_path = designated_dir / 'test.txt'\n        file_path.touch()\n        result = access_file('subdir/../test.txt')\n        self.assertEqual(result, file_path)\n    \n    def test_single_dot(self):\n        # Test '.' as the relative path\n        result = access_file('.')\n        self.assertEqual(result, designated_dir)\n    \n    def test_long_path(self):\n        # Test a very long relative path\n        current = designated_dir\n        long_path = []\n        for i in range(100):\n            dir_name = f'dir{i}'\n            long_path.append(dir_name)\n            current = current / dir_name\n        current.mkdir(parents=True, exist_ok=True)\n        file_path = current / 'file.txt'\n        file_path.touch()\n        rel_path = '/'.join(long_path) + '/file.txt'\n        result = access_file(rel_path)\n        self.assertEqual(result, file_path)\n", "num_test_cases": 12, "task_id": "d59bbaba"}
{"test": "import unittest\nimport tempfile\nimport os\nimport sys\nfrom pathlib import Path\nfrom unittest import TestCase\n\nclass TestFetchFile(TestCase):\n    @classmethod\n    def setUpClass(cls):\n        # Create a temporary directory\n        cls.temp_dir = tempfile.TemporaryDirectory()\n        cls.dl_dir_path = Path(cls.temp_dir.name)\n        \n        # Create test files\n        cls.valid_file = cls.dl_dir_path / \"test.txt\"\n        with open(cls.valid_file, 'w') as f:\n            f.write(\"test content\")\n            \n        cls.valid_subdir = cls.dl_dir_path / \"subdir\"\n        cls.valid_subdir.mkdir()\n        cls.valid_subfile = cls.valid_subdir / \"subfile.txt\"\n        with open(cls.valid_subfile, 'w') as f:\n            f.write(\"subfile content\")\n            \n        cls.file_with_space = cls.dl_dir_path / \"file with space.txt\"\n        with open(cls.file_with_space, 'w') as f:\n            f.write(\"space content\")\n            \n        # Attempt to create a symlink to outside (if supported)\n        cls.symlink_file = None\n        try:\n            # Create a file outside the download directory\n            cls.outside_file = cls.dl_dir_path.parent / \"outside.txt\"\n            with open(cls.outside_file, 'w') as f:\n                f.write(\"outside content\")\n            \n            # Create symlink inside download_dir to outside file\n            cls.symlink_file = cls.dl_dir_path / \"outside_link.txt\"\n            if hasattr(os, 'symlink'):\n                cls.symlink_file.symlink_to(cls.outside_file)\n        except (OSError, NotImplementedError):\n            # Skip symlink tests if not supported\n            pass\n\n    @classmethod\n    def tearDownClass(cls):\n        cls.temp_dir.cleanup()\n        if hasattr(cls, 'outside_file') and cls.outside_file.exists():\n            cls.outside_file.unlink()\n\n    def setUp(self):\n        # Setup to modify the global dl_dir in the module containing fetch_file\n        # Determine which module defines fetch_file\n        if 'fetch_file' in globals():\n            self.module = sys.modules[__name__]\n        else:\n            # Attempt to import from a module named 'app' as a fallback\n            import app\n            self.module = app\n        \n        # Set dl_dir in the module to our temporary path\n        self.original_dl_dir = getattr(self.module, 'dl_dir', None)\n        self.module.dl_dir = self.dl_dir_path\n\n    def tearDown(self):\n        # Restore original dl_dir in the module\n        if self.original_dl_dir is not None:\n            self.module.dl_dir = self.original_dl_dir\n        else:\n            del self.module.dl_dir\n\n    def test_valid_file_root(self):\n        # Test fetching a valid file in root directory\n        result = fetch_file(\"test.txt\")\n        self.assertEqual(result, self.valid_file)\n        self.assertTrue(result.exists())\n\n    def test_valid_file_subdir(self):\n        # Test fetching a valid file in subdirectory\n        result = fetch_file(\"subdir/subfile.txt\")\n        self.assertEqual(result, self.valid_subfile)\n        self.assertTrue(result.exists())\n\n    def test_empty_filename(self):\n        # Test with empty filename (should point to directory)\n        result = fetch_file(\"\")\n        self.assertEqual(result, self.dl_dir_path)\n        self.assertTrue(result.exists())\n\n    def test_filename_none(self):\n        # Test with None filename (should raise TypeError)\n        with self.assertRaises(TypeError):\n            fetch_file(None)\n\n    def test_traversal_attempt_double_dot(self):\n        # Test directory traversal with '../'\n        with self.assertRaises(PermissionError):\n            fetch_file(\"../test.txt\")\n\n    def test_traversal_attempt_double_dot_subdir(self):\n        # Test traversal from subdirectory\n        with self.assertRaises(PermissionError):\n            fetch_file(\"subdir/../../test.txt\")\n\n    def test_non_existent_file(self):\n        # Test with non-existent file\n        with self.assertRaises(FileNotFoundError):\n            fetch_file(\"non_existent.txt\")\n\n    def test_file_with_spaces(self):\n        # Test filename with spaces\n        result = fetch_file(\"file with space.txt\")\n        self.assertEqual(result, self.file_with_space)\n        self.assertTrue(result.exists())\n\n    def test_dot_filename(self):\n        # Test with '.' (current directory)\n        result = fetch_file(\".\")\n        self.assertEqual(result, self.dl_dir_path)\n        self.assertTrue(result.exists())\n\n    def test_double_dot_filename(self):\n        # Test with '..' (parent directory - should be blocked)\n        with self.assertRaises(PermissionError):\n            fetch_file(\"..\")\n\n    def test_absolute_path(self):\n        # Test with absolute path (should be blocked)\n        abs_path = os.path.abspath(__file__)\n        with self.assertRaises(PermissionError):\n            fetch_file(abs_path)\n\n    def test_symlink_to_outside(self):\n        # Test symlink pointing outside download directory\n        if self.symlink_file and self.symlink_file.exists():\n            with self.assertRaises(PermissionError):\n                fetch_file(\"outside_link.txt\")\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 12, "task_id": "de1f636f"}
{"test": "import unittest\nimport tempfile\nfrom pathlib import Path\nimport file_server\nfrom file_server import retrieve_file\n\nclass TestRetrieveFile(unittest.TestCase):\n    def setUp(self):\n        # Create a temporary directory and set as download_directory\n        self.test_dir = tempfile.TemporaryDirectory()\n        self.original_download_directory = file_server.download_directory\n        file_server.download_directory = Path(self.test_dir.name)\n    \n    def tearDown(self):\n        # Clean up temporary directory and reset global state\n        file_server.download_directory = self.original_download_directory\n        self.test_dir.cleanup()\n    \n    def test_existing_file(self):\n        # Test retrieving an existing file\n        test_file = Path(self.test_dir.name) / 'test.txt'\n        test_file.write_text('Hello')\n        result = retrieve_file('test.txt')\n        self.assertEqual(result, test_file)\n    \n    def test_non_existent_file(self):\n        # Test file not found\n        with self.assertRaises(FileNotFoundError):\n            retrieve_file('non_existent.txt')\n    \n    def test_directory_traversal_attack(self):\n        # Test path escaping download directory via '../'\n        with self.assertRaises(PermissionError):\n            retrieve_file('../outside.txt')\n    \n    def test_empty_filename(self):\n        # Test empty filename (points to directory)\n        result = retrieve_file('')\n        self.assertEqual(result, Path(self.test_dir.name))\n    \n    def test_subdirectory_file(self):\n        # Test file in subdirectory\n        subdir = Path(self.test_dir.name) / 'subdir'\n        subdir.mkdir()\n        test_file = subdir / 'file.txt'\n        test_file.write_text('Content')\n        result = retrieve_file('subdir/file.txt')\n        self.assertEqual(result, test_file)\n    \n    def test_absolute_path(self):\n        # Test absolute path input\n        with self.assertRaises(PermissionError):\n            retrieve_file('/etc/passwd')\n    \n    def test_long_filename(self):\n        # Test very long filename\n        long_name = 'a' * 500 + '.txt'\n        test_file = Path(self.test_dir.name) / long_name\n        test_file.write_text('Long file')\n        result = retrieve_file(long_name)\n        self.assertEqual(result, test_file)\n    \n    def test_non_ascii_filename(self):\n        # Test non-ASCII filename\n        filename = '测试文件.txt'\n        test_file = Path(self.test_dir.name) / filename\n        test_file.write_text('Non-ASCII')\n        result = retrieve_file(filename)\n        self.assertEqual(result, test_file)\n    \n    def test_non_string_input(self):\n        # Test non-string input type\n        with self.assertRaises(TypeError):\n            retrieve_file(123)\n    \n    def test_none_input(self):\n        # Test None input\n        with self.assertRaises(TypeError):\n            retrieve_file(None)\n    \n    def test_hidden_file(self):\n        # Test hidden file access\n        hidden_file = Path(self.test_dir.name) / '.hidden'\n        hidden_file.write_text('Secret')\n        result = retrieve_file('.hidden')\n        self.assertEqual(result, hidden_file)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 12, "task_id": "0660b549"}
{"test": "import unittest\nimport tempfile\nimport shutil\nimport os\nfrom pathlib import Path\n\n# Import the function and module where file_downloader is defined\nimport file_server\nfrom file_server import file_downloader\n\nclass TestFileDownloader(unittest.TestCase):\n    @classmethod\n    def setUpClass(cls):\n        # Create a temporary directory for downloads\n        cls.test_dir = tempfile.mkdtemp()\n        cls.downloads_folder = Path(cls.test_dir)\n        \n        # Create test files and directories inside downloads_folder\n        (cls.downloads_folder / 'test.txt').write_text('test')\n        \n        subdir = cls.downloads_folder / 'subdir'\n        subdir.mkdir()\n        (subdir / 'subfile.txt').write_text('subfile')\n        \n        (cls.downloads_folder / 'café.txt').write_text('café')\n        \n        (cls.downloads_folder / 'file with spaces.txt').write_text('spaces')\n        \n        # Create a file outside the downloads_folder\n        parent_dir = Path(cls.test_dir).parent\n        cls.outside_file = parent_dir / 'outside_file.txt'\n        cls.outside_file.write_text('outside')\n        \n        # Create symlinks\n        (cls.downloads_folder / 'link_inside').symlink_to('test.txt')\n        relative_outside_path = os.path.relpath(cls.outside_file, cls.downloads_folder)\n        (cls.downloads_folder / 'link_outside').symlink_to(relative_outside_path)\n    \n    @classmethod\n    def tearDownClass(cls):\n        # Clean up temporary directory and outside file\n        shutil.rmtree(cls.test_dir)\n        if cls.outside_file.exists():\n            cls.outside_file.unlink()\n    \n    def setUp(self):\n        # Set the global downloads_folder in file_server to our test folder\n        file_server.downloads_folder = self.downloads_folder\n    \n    def test_existing_file(self):\n        # Test fetching an existing file in root directory\n        result = file_downloader('test.txt')\n        self.assertEqual(result, self.downloads_folder / 'test.txt')\n    \n    def test_file_not_found(self):\n        # Test non-existent file raises FileNotFoundError\n        with self.assertRaises(FileNotFoundError):\n            file_downloader('nonexistent.txt')\n    \n    def test_traversal_outside(self):\n        # Test path with '..' attempting to traverse outside\n        with self.assertRaises(PermissionError):\n            file_downloader('../../etc/passwd')\n    \n    def test_empty_string(self):\n        # Test empty file name returns download directory path\n        result = file_downloader('')\n        self.assertEqual(result, self.downloads_folder)\n    \n    def test_file_in_subdir(self):\n        # Test file in subdirectory\n        result = file_downloader('subdir/subfile.txt')\n        self.assertEqual(result, self.downloads_folder / 'subdir' / 'subfile.txt')\n    \n    def test_non_ascii_filename(self):\n        # Test filename with non-ASCII characters\n        result = file_downloader('café.txt')\n        self.assertEqual(result, self.downloads_folder / 'café.txt')\n    \n    def test_absolute_inside(self):\n        # Test absolute path within downloads_folder\n        abs_path = self.downloads_folder / 'test.txt'\n        result = file_downloader(str(abs_path))\n        self.assertEqual(result, abs_path)\n    \n    def test_absolute_outside(self):\n        # Test absolute path outside downloads_folder\n        with self.assertRaises(PermissionError):\n            file_downloader(str(self.outside_file))\n    \n    def test_relative_traversal_to_outside_file(self):\n        # Test relative path traversing to outside file\n        relative_path = os.path.join('..', self.outside_file.name)\n        with self.assertRaises(PermissionError):\n            file_downloader(relative_path)\n    \n    def test_symlink_inside(self):\n        # Test symlink pointing to file inside downloads_folder\n        result = file_downloader('link_inside')\n        self.assertEqual(result, self.downloads_folder / 'link_inside')\n    \n    def test_symlink_outside(self):\n        # Test symlink pointing to file outside downloads_folder\n        with self.assertRaises(PermissionError):\n            file_downloader('link_outside')\n    \n    def test_file_with_spaces(self):\n        # Test filename with spaces\n        result = file_downloader('file with spaces.txt')\n        self.assertEqual(result, self.downloads_folder / 'file with spaces.txt')", "num_test_cases": 13, "task_id": "a27d6456"}
{"test": "import unittest\nimport tempfile\nfrom pathlib import Path\nimport os\nimport platform\n\n# Import the module containing fetch_file\nimport file_server\nfrom file_server import fetch_file\n\nclass TestFetchFile(unittest.TestCase):\n    def setUp(self):\n        # Create a temporary directory for the download_dir\n        self.temp_dir = tempfile.TemporaryDirectory()\n        file_server.download_dir = Path(self.temp_dir.name)\n        \n        # Create test files and directories\n        self.file1 = Path(self.temp_dir.name) / \"test_file1.txt\"\n        self.file1.touch()\n        \n        self.subdir = Path(self.temp_dir.name) / \"subdir\"\n        self.subdir.mkdir()\n        \n        self.file2 = self.subdir / \"test_file2.txt\"\n        self.file2.touch()\n        \n        self.dir1 = self.subdir / \"mydir\"\n        self.dir1.mkdir()\n        \n        # Create a file for symlink tests (inside)\n        self.file3 = Path(self.temp_dir.name) / \"target.txt\"\n        self.file3.touch()\n        \n        # Create a temporary directory outside the download_dir\n        self.outside_temp_dir = tempfile.TemporaryDirectory()\n        self.outside_file = Path(self.outside_temp_dir.name) / \"outside.txt\"\n        self.outside_file.touch()\n        \n        # Create file with special characters\n        self.special_file = Path(self.temp_dir.name) / \"file with spaces.txt\"\n        self.special_file.touch()\n        \n        # Create file with long name\n        self.long_file = Path(self.temp_dir.name) / (\"a\" * 200 + \".txt\")\n        self.long_file.touch()\n        \n        # Create file with non-ASCII name\n        self.unicode_file = Path(self.temp_dir.name) / \"ファイル.txt\"\n        self.unicode_file.touch()\n    \n    def tearDown(self):\n        self.temp_dir.cleanup()\n        self.outside_temp_dir.cleanup()\n    \n    def test_existing_file_root(self):\n        # Test existing file in the root directory\n        result = fetch_file(\"test_file1.txt\")\n        self.assertEqual(result, self.file1)\n    \n    def test_existing_file_subdir(self):\n        # Test existing file in a subdirectory\n        result = fetch_file(\"subdir/test_file2.txt\")\n        self.assertEqual(result, self.file2)\n    \n    def test_non_existing_file(self):\n        # Test non-existent file\n        with self.assertRaises(FileNotFoundError):\n            fetch_file(\"non_existent.txt\")\n    \n    def test_escape_with_parent(self):\n        # Test path traversal with '..' escaping download_dir\n        with self.assertRaises(PermissionError):\n            fetch_file(\"../../etc/passwd\")\n    \n    def test_absolute_path_outside(self):\n        # Test absolute path to a file outside download_dir\n        with self.assertRaises(PermissionError):\n            fetch_file(str(self.outside_file))\n    \n    def test_existing_directory(self):\n        # Test existing directory by name (should return path)\n        result = fetch_file(\"subdir/mydir\")\n        self.assertEqual(result, self.dir1)\n    \n    def test_symlink_inside(self):\n        # Test symlink to a file inside download_dir\n        if platform.system() == 'Windows':\n            self.skipTest(\"Symlink test skipped on Windows\")\n        try:\n            symlink_path = Path(self.temp_dir.name) / \"inside_symlink.txt\"\n            symlink_path.symlink_to(self.file3)\n            result = fetch_file(\"inside_symlink.txt\")\n            self.assertEqual(result, symlink_path)\n        except (OSError, NotImplementedError):\n            self.skipTest(\"System does not support symlinks\")\n    \n    def test_symlink_outside(self):\n        # Test symlink to a file outside download_dir\n        if platform.system() == 'Windows':\n            self.skipTest(\"Symlink test skipped on Windows\")\n        try:\n            symlink_path = Path(self.temp_dir.name) / \"outside_symlink.txt\"\n            symlink_path.symlink_to(self.outside_file)\n            with self.assertRaises(PermissionError):\n                fetch_file(\"outside_symlink.txt\")\n        except (OSError, NotImplementedError):\n            self.skipTest(\"System does not support symlinks\")\n    \n    def test_broken_symlink(self):\n        # Test broken symlink within download_dir\n        if platform.system() == 'Windows':\n            self.skipTest(\"Symlink test skipped on Windows\")\n        try:\n            broken_symlink = Path(self.temp_dir.name) / \"broken_symlink.txt\"\n            broken_symlink.symlink_to(\"non_existent_target\")\n            with self.assertRaises(FileNotFoundError):\n                fetch_file(\"broken_symlink.txt\")\n        except (OSError, NotImplementedError):\n            self.skipTest(\"System does not support symlinks\")\n    \n    def test_special_characters(self):\n        # Test file name with special characters (spaces)\n        result = fetch_file(\"file with spaces.txt\")\n        self.assertEqual(result, self.special_file)\n    \n    def test_long_filename(self):\n        # Test very long file name\n        result = fetch_file(\"a\" * 200 + \".txt\")\n        self.assertEqual(result, self.long_file)\n    \n    def test_unicode_filename(self):\n        # Test non-ASCII (Unicode) file name\n        result = fetch_file(\"ファイル.txt\")\n        self.assertEqual(result, self.unicode_file)\n    \n    def test_empty_string(self):\n        # Test empty string as file name (returns download_dir)\n        result = fetch_file(\"\")\n        self.assertEqual(result, Path(self.temp_dir.name))\n    \n    def test_dot(self):\n        # Test '.' as file name (returns download_dir)\n        result = fetch_file(\".\")\n        self.assertEqual(result, Path(self.temp_dir.name))\n", "num_test_cases": 14, "task_id": "5fb937a7"}
{"test": "import unittest\nimport tempfile\nfrom pathlib import Path\nimport solution\nfrom solution import retrieve_file\n\nclass TestRetrieveFile(unittest.TestCase):\n    def setUp(self):\n        # Create a temporary directory\n        self.temp_dir = tempfile.TemporaryDirectory()\n        # Set the download_dir in the solution module to this temp directory\n        solution.download_dir = Path(self.temp_dir.name)\n        # Create some files and directories for testing\n        self.download_path = Path(self.temp_dir.name)\n        # Create a file in the root\n        self.file1 = self.download_path / 'file1.txt'\n        with open(self.file1, 'w') as f:\n            f.write('content')\n        # Create a subdirectory and a file in it\n        self.subdir = self.download_path / 'subdir'\n        self.subdir.mkdir()\n        self.file2 = self.subdir / 'file2.txt'\n        with open(self.file2, 'w') as f:\n            f.write('content')\n        # Create a non-ASCII file\n        self.file3 = self.download_path / '\\u6587\\u4ef6.txt'\n        with open(self.file3, 'w') as f:\n            f.write('content')\n        # Create a directory\n        self.dir1 = self.download_path / 'mydir'\n        self.dir1.mkdir()\n        # Create a long file name\n        long_name = 'a' * 300 + '.txt'\n        self.long_file = self.download_path / long_name\n        with open(self.long_file, 'w') as f:\n            f.write('content')\n\n    def tearDown(self):\n        # Clean up the temporary directory\n        self.temp_dir.cleanup()\n\n    def test_existing_file_root(self):\n        # Test existing file in root directory\n        result = retrieve_file('file1.txt')\n        self.assertEqual(result, self.download_path / 'file1.txt')\n\n    def test_existing_file_subdir(self):\n        # Test existing file in subdirectory\n        result = retrieve_file('subdir/file2.txt')\n        self.assertEqual(result, self.download_path / 'subdir' / 'file2.txt')\n\n    def test_non_existent_file_root(self):\n        # Test non-existent file in root directory\n        with self.assertRaises(FileNotFoundError):\n            retrieve_file('non_existent.txt')\n\n    def test_non_existent_file_subdir(self):\n        # Test non-existent file in subdirectory\n        with self.assertRaises(FileNotFoundError):\n            retrieve_file('subdir/non_existent.txt')\n\n    def test_relative_path_escape(self):\n        # Test escaping download_dir with relative path (../)\n        with self.assertRaises(PermissionError):\n            retrieve_file('../outside.txt')\n\n    def test_absolute_path_outside(self):\n        # Test absolute path outside download_dir\n        outside_path = Path(self.temp_dir.name).parent / 'outside.txt'\n        with self.assertRaises(PermissionError):\n            retrieve_file(str(outside_path))\n\n    def test_empty_string(self):\n        # Test empty string input (returns download_dir)\n        result = retrieve_file('')\n        self.assertEqual(result, self.download_path)\n\n    def test_dot(self):\n        # Test dot input (returns current directory)\n        result = retrieve_file('.')\n        self.assertEqual(result, self.download_path / '.')\n\n    def test_non_ascii_file(self):\n        # Test non-ASCII file name\n        result = retrieve_file('\\u6587\\u4ef6.txt')\n        self.assertEqual(result, self.download_path / '\\u6587\\u4ef6.txt')\n\n    def test_absolute_path_inside(self):\n        # Test absolute path inside download_dir\n        abs_path = self.file1.resolve()\n        result = retrieve_file(str(abs_path))\n        self.assertEqual(result, abs_path)\n\n    def test_existing_directory(self):\n        # Test existing directory (non-dot, non-empty)\n        result = retrieve_file('mydir')\n        self.assertEqual(result, self.download_path / 'mydir')\n\n    def test_absolute_path_directory(self):\n        # Test absolute path of directory inside download_dir\n        abs_path = self.dir1.resolve()\n        result = retrieve_file(str(abs_path))\n        self.assertEqual(result, abs_path)\n\n    def test_long_file_name(self):\n        # Test very long file name\n        long_name = 'a' * 300 + '.txt'\n        result = retrieve_file(long_name)\n        self.assertEqual(result, self.download_path / long_name)\n\n    def test_none_input(self):\n        # Test None input (invalid type)\n        with self.assertRaises(TypeError):\n            retrieve_file(None)\n\n    def test_integer_input(self):\n        # Test integer input (invalid type)\n        with self.assertRaises(TypeError):\n            retrieve_file(123)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 16, "task_id": "658bf27f"}
{"test": "import unittest\nfrom pathlib import Path\nimport tempfile\nimport os\n\n# We assume the function is defined in a module named 'service'\nimport service\nfrom service import get_file\n\nclass TestGetFile(unittest.TestCase):\n    def setUp(self):\n        # Create a temporary directory\n        self.temp_dir = tempfile.TemporaryDirectory()\n        self.download_dir_path = Path(self.temp_dir.name)\n        service.download_dir = self.download_dir_path\n\n    def tearDown(self):\n        self.temp_dir.cleanup()\n\n    def test_case_1(self):\n        # Happy path: existing file in the root\n        file_name = 'test.txt'\n        file_path = self.download_dir_path / file_name\n        file_path.touch()  # create the file\n        result = get_file(file_name)\n        self.assertEqual(result, file_path)\n\n    def test_case_2(self):\n        # File not found\n        with self.assertRaises(FileNotFoundError):\n            get_file('non_existent.txt')\n\n    def test_case_3(self):\n        # File in a subdirectory\n        sub_dir = self.download_dir_path / 'sub'\n        sub_dir.mkdir()\n        file_name = 'sub/test.txt'\n        file_path = sub_dir / 'test.txt'\n        file_path.touch()\n        result = get_file(file_name)\n        self.assertEqual(result, file_path)\n\n    def test_case_4(self):\n        # Non-ASCII filename\n        file_name = '测试.txt'\n        file_path = self.download_dir_path / file_name\n        file_path.touch()\n        result = get_file(file_name)\n        self.assertEqual(result, file_path)\n\n    def test_case_5(self):\n        # Empty string: returns the download_dir (which is a directory)\n        result = get_file('')\n        self.assertEqual(result, self.download_dir_path)\n\n    def test_case_6(self):\n        # Escape with relative path: '../outside.txt'\n        with self.assertRaises(PermissionError):\n            get_file('../outside.txt')\n\n    def test_case_7(self):\n        # Escape with absolute path: create an absolute path that is outside the download_dir\n        with tempfile.TemporaryDirectory() as outside_temp:\n            outside_abs = Path(outside_temp) / 'outside.txt'\n            with self.assertRaises(PermissionError):\n                get_file(str(outside_abs))\n\n    def test_case_8(self):\n        # Long filename\n        long_name = 'a' * 255  # maximum filename length in some systems\n        file_path = self.download_dir_path / long_name\n        file_path.touch()\n        result = get_file(long_name)\n        self.assertEqual(result, file_path)\n\n    def test_case_9(self):\n        # File name with spaces\n        file_name = 'file with spaces.txt'\n        file_path = self.download_dir_path / file_name\n        file_path.touch()\n        result = get_file(file_name)\n        self.assertEqual(result, file_path)\n\n    def test_case_10(self):\n        # File name with special characters\n        file_name = '!@#$%^&*()_+.txt'\n        file_path = self.download_dir_path / file_name\n        file_path.touch()\n        result = get_file(file_name)\n        self.assertEqual(result, file_path)", "num_test_cases": 10, "task_id": "5258cac1"}
{"test": "import unittest\nimport tempfile\nimport shutil\nfrom pathlib import Path\n\n# Replace 'your_module' with the actual module name where the function and downloads_folder are defined\nfrom your_module import serve_file, downloads_folder\n\nclass TestServeFile(unittest.TestCase):\n    def setUp(self):\n        # Create a common parent temporary directory\n        self.common_parent = Path(tempfile.mkdtemp())\n        # Create the downloads directory inside the parent\n        self.temp_dir = self.common_parent / 'downloads'\n        self.temp_dir.mkdir()\n        # Create a test file outside the downloads directory\n        self.outside_file = self.common_parent / 'outside_file.txt'\n        self.outside_file.write_text('Outside file content')\n        # Create files inside downloads directory\n        self.file1 = self.temp_dir / 'test_file1.txt'\n        self.file1.write_text('File 1 content')\n        self.sub_dir = self.temp_dir / 'subdir'\n        self.sub_dir.mkdir()\n        self.file2 = self.sub_dir / 'test_file2.txt'\n        self.file2.write_text('File 2 content')\n        # Create a symlink inside pointing to an internal file\n        self.internal_symlink = self.temp_dir / 'internal_link.txt'\n        self.internal_symlink.symlink_to('test_file1.txt')\n        # Create a symlink pointing to an external file\n        self.external_symlink = self.temp_dir / 'external_link.txt'\n        self.external_symlink.symlink_to('../outside_file.txt')\n        # Create a file with a long name\n        self.long_name = 'a' * 200 + '.txt'\n        self.long_file = self.temp_dir / self.long_name\n        self.long_file.write_text('Long file content')\n        # Save original downloads_folder and replace with test directory\n        self.original_downloads_folder = downloads_folder\n        downloads_folder = self.temp_dir\n\n    def tearDown(self):\n        # Remove the entire temporary structure\n        shutil.rmtree(self.common_parent)\n        # Restore original downloads_folder\n        downloads_folder = self.original_downloads_folder\n\n    def test_happy_path_root_file(self):\n        # Test existing file in root directory\n        result = serve_file('test_file1.txt')\n        self.assertEqual(result, self.file1)\n\n    def test_happy_path_subdir_file(self):\n        # Test existing file in subdirectory\n        result = serve_file('subdir/test_file2.txt')\n        self.assertEqual(result, self.file2)\n\n    def test_file_not_found(self):\n        # Test non-existent file\n        with self.assertRaises(FileNotFoundError):\n            serve_file('non_existent.txt')\n\n    def test_outside_absolute_path(self):\n        # Test absolute path outside downloads directory\n        with self.assertRaises(PermissionError):\n            serve_file(str(self.outside_file.resolve()))\n\n    def test_outside_relative_path(self):\n        # Test relative path traversing outside\n        with self.assertRaises(PermissionError):\n            serve_file('../outside_file.txt')\n\n    def test_outside_relative_complex(self):\n        # Test complex relative path going outside\n        with self.assertRaises(PermissionError):\n            serve_file('subdir/../../outside_file.txt')\n\n    def test_symlink_pointing_outside(self):\n        # Test symlink to external file\n        with self.assertRaises(PermissionError):\n            serve_file('external_link.txt')\n\n    def test_valid_relative_with_dot_dot(self):\n        # Test valid path with '..' staying inside\n        result = serve_file('subdir/../test_file1.txt')\n        self.assertEqual(result, self.file1)\n\n    def test_empty_filename(self):\n        # Test empty string filename\n        result = serve_file('')\n        self.assertEqual(result, self.temp_dir)\n\n    def test_long_filename(self):\n        # Test very long filename\n        result = serve_file(self.long_name)\n        self.assertEqual(result, self.long_file)\n\n    def test_none_input(self):\n        # Test None input\n        with self.assertRaises(TypeError):\n            serve_file(None)\n\n    def test_non_string_input(self):\n        # Test non-string input\n        with self.assertRaises(TypeError):\n            serve_file(123)\n\n    def test_symlink_pointing_inside(self):\n        # Test valid symlink to internal file\n        result = serve_file('internal_link.txt')\n        self.assertEqual(result, self.internal_symlink)\n        self.assertTrue(result.exists())", "num_test_cases": 13, "task_id": "cab99f59"}
{"test": "import unittest\nimport tempfile\nfrom pathlib import Path\nimport os\n\nclass TestCases(unittest.TestCase):\n    def setUp(self):\n        # Set up a temporary directory and define the download directory within it\n        global download_directory\n        self.temp_dir = tempfile.TemporaryDirectory()\n        self.base_path = Path(self.temp_dir.name)\n        self.download_path = self.base_path / \"downloads\"\n        self.download_path.mkdir()\n        download_directory = self.download_path\n        \n        # Create a file inside the download directory\n        self.file1 = self.download_path / \"file1.txt\"\n        self.file1.write_text(\"Content of file1\")\n        \n        # Create a file outside the download directory (in the base temp directory)\n        self.file_outside = self.base_path / \"outside.txt\"\n        self.file_outside.write_text(\"Outside file\")\n\n    def tearDown(self):\n        # Clean up the temporary directory\n        self.temp_dir.cleanup()\n\n    def test_case_1(self):\n        # Test existing file in download directory\n        result = fetch_file(\"file1.txt\")\n        self.assertEqual(result, self.file1)\n\n    def test_case_2(self):\n        # Test non-existing file\n        with self.assertRaises(FileNotFoundError):\n            fetch_file(\"non_existent.txt\")\n\n    def test_case_3(self):\n        # Test empty string (returns the download directory)\n        result = fetch_file('')\n        self.assertEqual(result, self.download_path)\n\n    def test_case_4(self):\n        # Test dot (returns the download directory)\n        result = fetch_file('.')\n        self.assertEqual(result, self.download_path)\n\n    def test_case_5(self):\n        # Test two dots (should raise PermissionError)\n        with self.assertRaises(PermissionError):\n            fetch_file('..')\n\n    def test_case_6(self):\n        # Test absolute path to a file outside the download directory\n        abs_path = os.path.abspath(self.file_outside)\n        with self.assertRaises(PermissionError):\n            fetch_file(abs_path)\n\n    def test_case_7(self):\n        # Test relative path traversing outside the download directory\n        with self.assertRaises(PermissionError):\n            fetch_file(\"../outside.txt\")\n\n    def test_case_8(self):\n        # Test path that normalizes to a file within the directory\n        subdir = self.download_path / \"a\"\n        subdir.mkdir()\n        target_file = self.download_path / \"b.txt\"\n        target_file.write_text(\"Content\")\n        result = fetch_file(\"a/../b.txt\")\n        self.assertEqual(result, self.download_path / \"a/../b.txt\")\n\n    def test_case_9(self):\n        # Test file in a subdirectory\n        subdir = self.download_path / \"sub\"\n        subdir.mkdir()\n        file_in_sub = subdir / \"data.txt\"\n        file_in_sub.write_text(\"Data\")\n        result = fetch_file(\"sub/data.txt\")\n        self.assertEqual(result, file_in_sub)\n\n    def test_case_10(self):\n        # Test non-string input (integer)\n        with self.assertRaises(TypeError):\n            fetch_file(123)\n\n    def test_case_11(self):\n        # Test None input\n        with self.assertRaises(TypeError):\n            fetch_file(None)\n\n    def test_case_12(self):\n        # Test filename with special characters\n        special_name = \"file@#!$%^&()_+-=[]{}|;',.~`\"\n        special_file = self.download_path / special_name\n        special_file.write_text(\"Special\")\n        result = fetch_file(special_name)\n        self.assertEqual(result, special_file)\n\n    def test_case_13(self):\n        # Test very long filename\n        long_name = \"a\" * 300 + \".txt\"\n        long_file = self.download_path / long_name\n        long_file.write_text(\"Long file\")\n        result = fetch_file(long_name)\n        self.assertEqual(result, long_file)\n\n    def test_case_14(self):\n        # Test hidden file (starting with dot)\n        hidden_file = self.download_path / \".hidden\"\n        hidden_file.write_text(\"Hidden content\")\n        result = fetch_file(\".hidden\")\n        self.assertEqual(result, hidden_file)\n\n    def test_case_15(self):\n        # Test symlink to a file within the download directory\n        target_file = self.download_path / \"target.txt\"\n        target_file.write_text(\"Target\")\n        link_file = self.download_path / \"link\"\n        try:\n            link_file.symlink_to(target_file)\n        except (OSError, AttributeError):\n            self.skipTest(\"Symlinks not supported in this system\")\n        result = fetch_file(\"link\")\n        self.assertEqual(result, link_file)\n\n    def test_case_16(self):\n        # Test symlink to a file outside the download directory\n        try:\n            link_file = self.download_path / \"link\"\n            link_file.symlink_to(self.file_outside)\n        except (OSError, AttributeError):\n            self.skipTest(\"Symlinks not supported in this system\")\n        with self.assertRaises(PermissionError):\n            fetch_file(\"link\")\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 16, "task_id": "204bce5b"}
{"test": "import unittest\nimport tempfile\nfrom pathlib import Path\nimport solution\n\nclass TestGetFile(unittest.TestCase):\n    \n    def setUp(self):\n        # Create a temporary directory and set solution.download_folder\n        self.temp_dir = tempfile.TemporaryDirectory()\n        solution.download_folder = Path(self.temp_dir.name)\n        \n        # Create a test file inside the download folder\n        self.test_file = Path(self.temp_dir.name) / 'test.txt'\n        with open(self.test_file, 'w') as f:\n            f.write('test content')\n            \n        # Create a subdirectory and file inside\n        self.sub_dir = Path(self.temp_dir.name) / 'sub'\n        self.sub_dir.mkdir()\n        self.sub_file = self.sub_dir / 'sub_test.txt'\n        with open(self.sub_file, 'w') as f:\n            f.write('sub content')\n            \n        # Create a file outside the download folder\n        self.outside_file = Path(self.temp_dir.name).parent / 'outside.txt'\n        with open(self.outside_file, 'w') as f:\n            f.write('outside content')\n            \n        # Create a file with space in name\n        self.space_file = Path(self.temp_dir.name) / ' '\n        self.space_file.touch()\n    \n    def tearDown(self):\n        # Clean up the temporary directory and outside file\n        self.temp_dir.cleanup()\n        if self.outside_file.exists():\n            self.outside_file.unlink()\n    \n    def test_existing_file(self):\n        # Happy path: existing file in download folder\n        result = solution.get_file('test.txt')\n        self.assertEqual(result, self.test_file)\n    \n    def test_non_existing_file(self):\n        # File not found in download folder\n        non_exist = 'non_existing.txt'\n        with self.assertRaises(FileNotFoundError) as cm:\n            solution.get_file(non_exist)\n        self.assertEqual(str(cm.exception), f\"File {solution.download_folder / non_exist} does not exist\")\n    \n    def test_directory_traversal_outside(self):\n        # Filename attempts to access outside file via relative path\n        with self.assertRaises(PermissionError) as cm:\n            solution.get_file('../outside.txt')\n        self.assertEqual(str(cm.exception), \"Access to the file ../outside.txt is denied\")\n    \n    def test_empty_filename(self):\n        # Empty filename returns the download_folder itself\n        result = solution.get_file('')\n        self.assertEqual(result, solution.download_folder)\n    \n    def test_dot_filename(self):\n        # Filename '.' returns the current directory\n        result = solution.get_file('.')\n        self.assertEqual(result, solution.download_folder / '.')\n    \n    def test_double_dot_filename(self):\n        # Filename '..' attempts to access parent directory\n        with self.assertRaises(PermissionError) as cm:\n            solution.get_file('..')\n        self.assertEqual(str(cm.exception), \"Access to the file .. is denied\")\n    \n    def test_subdirectory_file(self):\n        # File in a subdirectory within download folder\n        result = solution.get_file('sub/sub_test.txt')\n        self.assertEqual(result, self.sub_file)\n    \n    def test_absolute_path_inside(self):\n        # Absolute path to a file inside download folder\n        result = solution.get_file(str(self.test_file))\n        self.assertEqual(result, self.test_file)\n    \n    def test_absolute_path_outside(self):\n        # Absolute path to a file outside download folder\n        with self.assertRaises(PermissionError) as cm:\n            solution.get_file(str(self.outside_file))\n        self.assertEqual(str(cm.exception), f\"Access to the file {str(self.outside_file)} is denied\")\n    \n    def test_subdirectory_as_file(self):\n        # Subdirectory name (without file) returns the directory\n        result = solution.get_file('sub')\n        self.assertEqual(result, self.sub_dir)\n    \n    def test_space_filename(self):\n        # Filename with space\n        result = solution.get_file(' ')\n        self.assertEqual(result, self.space_file)\n    \n    def test_non_string_filename(self):\n        # Non-string filename raises TypeError\n        with self.assertRaises(TypeError):\n            solution.get_file(None)\n        with self.assertRaises(TypeError):\n            solution.get_file(123)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 12, "task_id": "83a52b7d"}
{"test": "import unittest\nimport tempfile\nfrom pathlib import Path\nfrom unittest.mock import patch\n\nclass TestLoadConfig(unittest.TestCase):\n    def setUp(self):\n        # Create a temporary directory and set up test files\n        self.test_dir = tempfile.TemporaryDirectory()\n        self.test_dir_path = Path(self.test_dir.name)\n        \n        # Create valid key directory\n        self.valid_key_dir = self.test_dir_path / \"valid_key\"\n        self.valid_key_dir.mkdir()\n        \n        # Create valid file with content\n        self.valid_file = self.valid_key_dir / \"valid_file.txt\"\n        with open(self.valid_file, 'w') as f:\n            f.write(\"valid content\")\n            \n        # Create empty file\n        self.empty_file = self.valid_key_dir / \"empty.txt\"\n        self.empty_file.touch()\n        \n        # Create multiline file\n        self.multiline_file = self.valid_key_dir / \"multiline.txt\"\n        with open(self.multiline_file, 'w') as f:\n            f.write(\"line1\\nline2\\nline3\")\n            \n        # Create special character file\n        self.special_file = self.valid_key_dir / \"special.txt\"\n        with open(self.special_file, 'w', encoding='utf-8') as f:\n            f.write(\"éèàç€\")\n            \n        # Create subdirectory (to test directory access)\n        self.subdir = self.valid_key_dir / \"subdir\"\n        self.subdir.mkdir()\n        \n        # Create file outside the valid_key directory\n        self.outside_file = self.test_dir_path / \"outside.txt\"\n        with open(self.outside_file, 'w') as f:\n            f.write(\"outside\")\n        \n        # Define test config_dirs\n        self.config_dirs = {\n            \"valid_key\": self.valid_key_dir\n        }\n    \n    def tearDown(self):\n        # Clean up temporary directory\n        self.test_dir.cleanup()\n    \n    def test_happy_path(self):\n        # Test valid key and existing file\n        with patch('solution.config_dirs', self.config_dirs):\n            result = load_config(\"valid_key\", \"valid_file.txt\")\n            self.assertEqual(result, \"valid content\")\n    \n    def test_key_not_found(self):\n        # Test non-existent key (non-empty string)\n        with patch('solution.config_dirs', self.config_dirs):\n            with self.assertRaises(KeyError):\n                load_config(\"invalid_key\", \"anyfile.txt\")\n    \n    def test_key_empty_string(self):\n        # Test empty string key not in config_dirs\n        with patch('solution.config_dirs', self.config_dirs):\n            with self.assertRaises(KeyError):\n                load_config(\"\", \"anyfile.txt\")\n    \n    def test_file_not_found(self):\n        # Test valid key but non-existent file\n        with patch('solution.config_dirs', self.config_dirs):\n            with self.assertRaises(ValueError) as context:\n                load_config(\"valid_key\", \"nonexistent.txt\")\n            self.assertIn(\"does not exist\", str(context.exception))\n    \n    def test_path_traversal_attempt(self):\n        # Test file path escaping directory (security)\n        with patch('solution.config_dirs', self.config_dirs):\n            with self.assertRaises(Exception) as context:\n                load_config(\"valid_key\", \"../outside.txt\")\n            self.assertIn(\"is not allowed\", str(context.exception))\n    \n    def test_empty_file(self):\n        # Test reading empty file\n        with patch('solution.config_dirs', self.config_dirs):\n            result = load_config(\"valid_key\", \"empty.txt\")\n            self.assertEqual(result, \"\")\n    \n    def test_multiline_file(self):\n        # Test file with multiple lines\n        with patch('solution.config_dirs', self.config_dirs):\n            result = load_config(\"valid_key\", \"multiline.txt\")\n            self.assertEqual(result, \"line1\\nline2\\nline3\")\n    \n    def test_special_characters(self):\n        # Test file with special characters\n        with patch('solution.config_dirs', self.config_dirs):\n            result = load_config(\"valid_key\", \"special.txt\")\n            self.assertEqual(result, \"éèàç€\")\n    \n    def test_empty_filename(self):\n        # Test empty filename (points to directory)\n        with patch('solution.config_dirs', self.config_dirs):\n            with self.assertRaises(IsADirectoryError):\n                load_config(\"valid_key\", \"\")\n    \n    def test_directory_instead_of_file(self):\n        # Test filename is a directory\n        with patch('solution.config_dirs', self.config_dirs):\n            with self.assertRaises(IsADirectoryError):\n                load_config(\"valid_key\", \"subdir\")\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 10, "task_id": "dca9147a"}
{"test": "import unittest\nimport tempfile\nimport shutil\nimport os\nfrom pathlib import Path\nfrom unittest.mock import patch\n\n# Import the function assuming it's in a module named 'config_utils'\nfrom config_utils import retrieve_config\n\nclass TestRetrieveConfig(unittest.TestCase):\n\n    def setUp(self):\n        # Create a temporary directory\n        self.temp_dir = tempfile.mkdtemp()\n        \n        # Create valid_config directory\n        self.valid_dir = os.path.join(self.temp_dir, 'valid_config')\n        os.mkdir(self.valid_dir)\n        # Create a test file\n        self.valid_file = os.path.join(self.valid_dir, 'test.txt')\n        with open(self.valid_file, 'w') as f:\n            f.write('Hello, World!')\n            \n        # Create a subdirectory and a file\n        self.inner_dir = os.path.join(self.valid_dir, 'inner')\n        os.mkdir(self.inner_dir)\n        self.inner_file = os.path.join(self.inner_dir, 'inner.txt')\n        with open(self.inner_file, 'w') as f:\n            f.write('Inner content')\n            \n        # Create another config directory (empty)\n        self.another_dir = os.path.join(self.temp_dir, 'another_config')\n        os.mkdir(self.another_dir)\n        \n        # Create an outside directory and file\n        self.outside_dir = os.path.join(self.temp_dir, 'outside')\n        os.mkdir(self.outside_dir)\n        self.outside_file = os.path.join(self.outside_dir, 'secret.txt')\n        with open(self.outside_file, 'w') as f:\n            f.write('Secret')\n            \n        # Prepare the config_dirs dictionary for patching\n        self.config_dirs = {\n            'valid_id': Path(self.valid_dir),\n            'another_id': Path(self.another_dir)\n        }\n    \n    def tearDown(self):\n        # Clean up temporary directory\n        shutil.rmtree(self.temp_dir)\n    \n    def test_valid_config_and_file(self):\n        # Happy path: valid config_id and existing file\n        with patch('config_utils.config_dirs', self.config_dirs):\n            content = retrieve_config('valid_id', 'test.txt')\n            self.assertEqual(content, 'Hello, World!')\n    \n    def test_valid_config_non_existent_file(self):\n        # Valid config_id but file doesn't exist\n        with patch('config_utils.config_dirs', self.config_dirs):\n            with self.assertRaises(ValueError):\n                retrieve_config('valid_id', 'nonexistent.txt')\n    \n    def test_invalid_config_id(self):\n        # Invalid config_id (not in config_dirs)\n        with patch('config_utils.config_dirs', self.config_dirs):\n            with self.assertRaises(KeyError):\n                retrieve_config('invalid_id', 'test.txt')\n    \n    def test_relative_path_traversal(self):\n        # Attempt to escape directory via relative path\n        with patch('config_utils.config_dirs', self.config_dirs):\n            with self.assertRaises(Exception) as context:\n                retrieve_config('valid_id', '../outside/secret.txt')\n            self.assertIn('Path ../outside/secret.txt is not allowed', str(context.exception))\n    \n    def test_absolute_path_traversal(self):\n        # Attempt to access file outside allowed directory via absolute path\n        abs_outside_file = os.path.abspath(self.outside_file)\n        with patch('config_utils.config_dirs', self.config_dirs):\n            with self.assertRaises(Exception) as context:\n                retrieve_config('valid_id', abs_outside_file)\n            self.assertIn(f'Path {abs_outside_file} is not allowed', str(context.exception))\n    \n    def test_file_in_subdirectory(self):\n        # Valid file within a subdirectory of config_dir\n        with patch('config_utils.config_dirs', self.config_dirs):\n            content = retrieve_config('valid_id', 'inner/inner.txt')\n            self.assertEqual(content, 'Inner content')\n    \n    def test_non_existent_file_in_subdirectory(self):\n        # Non-existent file in a valid subdirectory\n        with patch('config_utils.config_dirs', self.config_dirs):\n            with self.assertRaises(ValueError):\n                retrieve_config('valid_id', 'inner/nonexistent.txt')\n    \n    def test_config_id_none(self):\n        # None as config_id\n        with patch('config_utils.config_dirs', self.config_dirs):\n            with self.assertRaises(KeyError) as context:\n                retrieve_config(None, 'test.txt')\n            self.assertEqual(str(context.exception), \"Configuration directory None not found\")\n    \n    def test_target_file_none(self):\n        # None as target_file\n        with patch('config_utils.config_dirs', self.config_dirs):\n            with self.assertRaises(TypeError):\n                retrieve_config('valid_id', None)\n    \n    def test_target_file_integer(self):\n        # Integer as target_file\n        with patch('config_utils.config_dirs', self.config_dirs):\n            with self.assertRaises(TypeError):\n                retrieve_config('valid_id', 123)\n    \n    def test_empty_config_id(self):\n        # Empty string as config_id\n        with patch('config_utils.config_dirs', self.config_dirs):\n            with self.assertRaises(KeyError) as context:\n                retrieve_config('', 'test.txt')\n            self.assertEqual(str(context.exception), \"Configuration directory  not found\")\n    \n    def test_empty_target_file(self):\n        # Empty string as target_file\n        with patch('config_utils.config_dirs', self.config_dirs):\n            # Should be treated as a non-existent file (since empty filenames aren't created)\n            with self.assertRaises(ValueError):\n                retrieve_config('valid_id', '')\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 12, "task_id": "4388436a"}
{"test": "import unittest\nimport tempfile\nfrom pathlib import Path\nimport solution\n\nclass TestGetConfig(unittest.TestCase):\n    def setUp(self):\n        try:\n            self.old_config_dirs = solution.config_dirs\n        except AttributeError:\n            self.old_config_dirs = None\n        self.temp_dir = tempfile.TemporaryDirectory()\n        self.temp_dir_path = Path(self.temp_dir.name)\n        self.test_file = self.temp_dir_path / 'test.txt'\n        with open(self.test_file, 'w') as f:\n            f.write('hello world')\n        self.subdir = self.temp_dir_path / 'subdir'\n        self.subdir.mkdir()\n        self.subdir_file = self.subdir / 'test.txt'\n        with open(self.subdir_file, 'w') as f:\n            f.write('subdir content')\n        solution.config_dirs = {'test_config': self.temp_dir_path}\n\n    def tearDown(self):\n        if self.old_config_dirs is not None:\n            solution.config_dirs = self.old_config_dirs\n        else:\n            if hasattr(solution, 'config_dirs'):\n                del solution.config_dirs\n        self.temp_dir.cleanup()\n\n    def test_valid_config_and_file(self):\n        # Test with valid config and existing file\n        content = solution.get_config('test_config', 'test.txt')\n        self.assertEqual(content, 'hello world')\n\n    def test_config_name_not_found(self):\n        # Test with non-existent config_name (KeyError)\n        with self.assertRaises(KeyError):\n            solution.get_config('missing_config', 'test.txt')\n\n    def test_file_does_not_exist(self):\n        # Test with non-existent file (ValueError)\n        with self.assertRaises(ValueError):\n            solution.get_config('test_config', 'non_existent.txt')\n\n    def test_path_traversal(self):\n        # Test path traversal attempt (Exception)\n        with self.assertRaises(Exception) as context:\n            solution.get_config('test_config', '../../test.txt')\n        self.assertIn('Path ../../test.txt is not allowed', str(context.exception))\n\n    def test_absolute_path(self):\n        # Test absolute path outside config dir (Exception)\n        with tempfile.TemporaryDirectory() as outside_temp:\n            outside_path = Path(outside_temp) / 'outside.txt'\n            with open(outside_path, 'w') as f:\n                f.write('outside')\n            with self.assertRaises(Exception) as context:\n                solution.get_config('test_config', str(outside_path))\n            self.assertIn(f'Path {str(outside_path)} is not allowed', str(context.exception))\n\n    def test_empty_file_name(self):\n        # Test empty file name (ValueError)\n        with self.assertRaises(ValueError):\n            solution.get_config('test_config', '')\n\n    def test_empty_config_name(self):\n        # Test empty config name (KeyError)\n        with self.assertRaises(KeyError):\n            solution.get_config('', 'test.txt')\n\n    def test_file_in_subdirectory(self):\n        # Test file in subdirectory (valid)\n        content = solution.get_config('test_config', 'subdir/test.txt')\n        self.assertEqual(content, 'subdir content')\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 8, "task_id": "522dc411"}
{"test": "import unittest\nimport tempfile\nfrom pathlib import Path\nfrom unittest.mock import patch\n\nclass TestLoadConfig(unittest.TestCase):\n    \n    @classmethod\n    def setUpClass(cls):\n        # Create a temporary directory structure\n        cls.temp_dir = tempfile.TemporaryDirectory()\n        cls.base_path = Path(cls.temp_dir.name)\n        \n        # Create config directories\n        cls.config1_dir = cls.base_path / \"CONFIG1\"\n        cls.config1_dir.mkdir()\n        cls.config2_dir = cls.base_path / \"CONFIG2\"\n        cls.config2_dir.mkdir()\n        \n        # Create files\n        file1 = cls.config1_dir / \"file1.txt\"\n        file1.write_text(\"Hello, World!\")\n        \n        sub_dir = cls.config1_dir / \"sub\"\n        sub_dir.mkdir()\n        file2 = sub_dir / \"file2.txt\"\n        file2.write_text(\"File in subdirectory\")\n        \n        # Build config_dirs mapping\n        cls.config_dirs = {\n            \"CONFIG1\": cls.config1_dir,\n            \"CONFIG2\": cls.config2_dir\n        }\n    \n    @classmethod\n    def tearDownClass(cls):\n        cls.temp_dir.cleanup()\n    \n    def test_valid_config_and_file(self):\n        # Test reading existing file in valid config directory\n        with patch('config_utils.config_dirs', self.config_dirs):\n            content = load_config(\"CONFIG1\", \"file1.txt\")\n            self.assertEqual(content, \"Hello, World!\")\n    \n    def test_valid_config_subdirectory_file(self):\n        # Test reading file in subdirectory\n        with patch('config_utils.config_dirs', self.config_dirs):\n            content = load_config(\"CONFIG1\", \"sub/file2.txt\")\n            self.assertEqual(content, \"File in subdirectory\")\n    \n    def test_normalized_path_within_directory(self):\n        # Test path with '..' that stays within directory\n        with patch('config_utils.config_dirs', self.config_dirs):\n            content = load_config(\"CONFIG1\", \"sub/../file1.txt\")\n            self.assertEqual(content, \"Hello, World!\")\n    \n    def test_file_not_found(self):\n        # Test non-existent file in existing config\n        with patch('config_utils.config_dirs', self.config_dirs):\n            with self.assertRaises(ValueError):\n                load_config(\"CONFIG1\", \"nonexistent.txt\")\n    \n    def test_empty_file_title(self):\n        # Test empty file name\n        with patch('config_utils.config_dirs', self.config_dirs):\n            with self.assertRaises(ValueError):\n                load_config(\"CONFIG1\", \"\")\n    \n    def test_config_code_not_found(self):\n        # Test invalid config code\n        with patch('config_utils.config_dirs', self.config_dirs):\n            with self.assertRaises(KeyError):\n                load_config(\"INVALID_CONFIG\", \"file1.txt\")\n    \n    def test_directory_traversal_blocked(self):\n        # Test path escaping directory\n        with patch('config_utils.config_dirs', self.config_dirs):\n            with self.assertRaises(Exception) as context:\n                load_config(\"CONFIG1\", \"../CONFIG2/file.txt\")\n            self.assertIn(\"Path ../CONFIG2/file.txt is not allowed\", str(context.exception))\n    \n    def test_directory_traversal_from_subdir(self):\n        # Test traversal from subdirectory\n        with patch('config_utils.config_dirs', self.config_dirs):\n            with self.assertRaises(Exception) as context:\n                load_config(\"CONFIG1\", \"sub/../../CONFIG2\")\n            self.assertIn(\"Path sub/../../CONFIG2 is not allowed\", str(context.exception))\n    \n    def test_dot_file(self):\n        # Test special '.' file name\n        with patch('config_utils.config_dirs', self.config_dirs):\n            with self.assertRaises(ValueError):\n                load_config(\"CONFIG1\", \".\")\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 9, "task_id": "e66857d5"}
{"test": "import unittest\nimport tempfile\nfrom pathlib import Path\n\n# Global config_dirs dictionary required by the function\nconfig_dirs = {}\n\ndef retrieve_config(key: str, fname: str) -> str:\n    if key in config_dirs:\n        config_dir = config_dirs[key]\n        file_path = config_dir / fname\n        try:\n            file_path.resolve().relative_to(config_dir.resolve())\n        except ValueError:\n            raise Exception(f\"Path {fname} is not allowed\")\n        if not file_path.exists():\n            raise ValueError(f\"File {file_path} does not exist\")\n        return file_path.read_text()\n    else:\n        raise KeyError(f\"Configuration directory {key} not found\")\n\nclass TestRetrieveConfig(unittest.TestCase):\n    @classmethod\n    def setUpClass(cls):\n        # Create a temporary directory and directory structure\n        cls.temp_dir = tempfile.TemporaryDirectory()\n        cls.temp_path = Path(cls.temp_dir.name)\n        \n        # Create valid_key directory and files\n        cls.valid_key_dir = cls.temp_path / 'valid_key'\n        cls.valid_key_dir.mkdir()\n        \n        # Create test files\n        (cls.valid_key_dir / 'test.txt').write_text(\"Hello, World!\")\n        (cls.valid_key_dir / 'empty.txt').write_text(\"\")\n        \n        # Create nested directory and file\n        nested_dir = cls.valid_key_dir / 'nested'\n        nested_dir.mkdir()\n        (nested_dir / 'file.txt').write_text(\"Nested content\")\n        \n        # Create large file\n        large_content = 'A' * 10000  # 10KB content\n        (cls.valid_key_dir / 'large.txt').write_text(large_content)\n        \n        # Create other_key directory for traversal tests\n        cls.other_key_dir = cls.temp_path / 'other_key'\n        cls.other_key_dir.mkdir()\n        (cls.other_key_dir / 'external.txt').write_text(\"External content\")\n        \n        # Set global config_dirs\n        global config_dirs\n        config_dirs = {'valid_key': cls.valid_key_dir}\n    \n    @classmethod\n    def tearDownClass(cls):\n        # Clean up temporary directory\n        cls.temp_dir.cleanup()\n        \n    def test_valid_file(self):\n        # Test reading a valid file\n        content = retrieve_config('valid_key', 'test.txt')\n        self.assertEqual(content, \"Hello, World!\")\n        \n    def test_empty_file(self):\n        # Test reading an empty file\n        content = retrieve_config('valid_key', 'empty.txt')\n        self.assertEqual(content, \"\")\n        \n    def test_nested_file(self):\n        # Test reading a file in a subdirectory\n        content = retrieve_config('valid_key', 'nested/file.txt')\n        self.assertEqual(content, \"Nested content\")\n        \n    def test_large_file(self):\n        # Test reading a large file\n        expected = 'A' * 10000\n        content = retrieve_config('valid_key', 'large.txt')\n        self.assertEqual(content, expected)\n        \n    def test_non_existent_file(self):\n        # Test non-existent file in valid directory\n        with self.assertRaises(ValueError) as context:\n            retrieve_config('valid_key', 'missing.txt')\n        self.assertIn(\"File\", str(context.exception))\n        self.assertIn(\"does not exist\", str(context.exception))\n        \n    def test_invalid_key(self):\n        # Test with invalid configuration key\n        with self.assertRaises(KeyError) as context:\n            retrieve_config('invalid_key', 'test.txt')\n        self.assertIn(\"Configuration directory invalid_key not found\", str(context.exception))\n        \n    def test_directory_traversal_relative(self):\n        # Test path traversal with relative path\n        with self.assertRaises(Exception) as context:\n            retrieve_config('valid_key', '../other_key/external.txt')\n        self.assertIn(\"Path ../other_key/external.txt is not allowed\", str(context.exception))\n        \n    def test_directory_traversal_absolute(self):\n        # Test path traversal with absolute path\n        abs_path = (self.other_key_dir / 'external.txt').resolve()\n        with self.assertRaises(Exception) as context:\n            retrieve_config('valid_key', str(abs_path))\n        self.assertIn(f\"Path {abs_path} is not allowed\", str(context.exception))", "num_test_cases": 8, "task_id": "7525433f"}
{"test": "import unittest\nimport tempfile\nfrom pathlib import Path\nfrom unittest.mock import patch\n\n# Import the function from the module where it is defined (adjust module name if necessary)\n# Assuming the function is in a module named 'config_utils'\nfrom config_utils import retrieve_config\n\nclass TestRetrieveConfig(unittest.TestCase):\n    @classmethod\n    def setUpClass(cls):\n        # Create a temporary directory\n        cls.temp_dir = tempfile.TemporaryDirectory()\n        cls.base_path = Path(cls.temp_dir.name)\n        \n        # Create configuration directories\n        cls.dir1 = cls.base_path / 'key1'\n        cls.dir2 = cls.base_path / 'key2'\n        cls.dir1.mkdir()\n        cls.dir2.mkdir()\n        \n        # Create test files\n        (cls.dir1 / 'file1.txt').write_text('Content for file1')\n        (cls.dir1 / 'file2.txt').write_text('Content for file2')\n        (cls.dir1 / 'empty.txt').write_text('')  # Empty file\n        (cls.dir2 / 'config.txt').write_text('Config in dir2')\n        (cls.base_path / 'outside.txt').write_text('Outside file')\n        \n        # Define the configuration directories mapping\n        cls.config_dirs = {\n            'key1': cls.dir1,\n            'key2': cls.dir2\n        }\n        \n        # Patch the global config_dirs in the target module\n        cls.patcher = patch('config_utils.config_dirs', cls.config_dirs)\n        cls.patcher.start()\n    \n    @classmethod\n    def tearDownClass(cls):\n        # Stop patching and clean up temporary directory\n        cls.patcher.stop()\n        cls.temp_dir.cleanup()\n    \n    def test_happy_path_key1_non_empty(self):\n        # Test reading a non-empty file with valid key\n        result = retrieve_config('key1', 'file1.txt')\n        self.assertEqual(result, 'Content for file1')\n    \n    def test_happy_path_key2(self):\n        # Test reading a file from a different key\n        result = retrieve_config('key2', 'config.txt')\n        self.assertEqual(result, 'Config in dir2')\n    \n    def test_empty_file(self):\n        # Test reading an empty file\n        result = retrieve_config('key1', 'empty.txt')\n        self.assertEqual(result, '')\n    \n    def test_key_not_found(self):\n        # Test with a non-existent key\n        with self.assertRaises(KeyError) as context:\n            retrieve_config('key3', 'file1.txt')\n        self.assertIn(\"Configuration directory key3 not found\", str(context.exception))\n    \n    def test_file_not_found(self):\n        # Test with a non-existent file in an existing directory\n        with self.assertRaises(ValueError) as context:\n            retrieve_config('key1', 'non_existent.txt')\n        self.assertIn(\"File\", str(context.exception))\n        self.assertIn(\"does not exist\", str(context.exception))\n    \n    def test_security_escape_directory(self):\n        # Test path traversal attempt (security)\n        with self.assertRaises(Exception) as context:\n            retrieve_config('key1', '../outside.txt')\n        self.assertIn(\"Path ../outside.txt is not allowed\", str(context.exception))\n    \n    def test_empty_file_name(self):\n        # Test with empty file name\n        with self.assertRaises(ValueError) as context:\n            retrieve_config('key1', '')\n        self.assertIn(\"File\", str(context.exception))\n        self.assertIn(\"does not exist\", str(context.exception))", "num_test_cases": 7, "task_id": "48d98ef7"}
{"test": "import unittest\nimport tempfile\nfrom pathlib import Path\nfrom unittest.mock import patch\n\n# Assume the function is imported from 'config_loader' module\nfrom config_loader import load_config\n\nclass TestLoadConfig(unittest.TestCase):\n    @classmethod\n    def setUpClass(cls):\n        # Create a temporary directory structure\n        cls.test_dir = tempfile.TemporaryDirectory()\n        cls.base_path = Path(cls.test_dir.name)\n        \n        # Create valid configuration directory\n        cls.valid_dir = cls.base_path / \"valid_config\"\n        cls.valid_dir.mkdir()\n        \n        # Create valid configuration file\n        cls.config_file = cls.valid_dir / \"config.txt\"\n        cls.config_file.write_text(\"Hello, World!\")\n        \n        # Create subdirectory and file\n        cls.sub_dir = cls.valid_dir / \"subdir\"\n        cls.sub_dir.mkdir()\n        cls.sub_file = cls.sub_dir / \"sub_config.txt\"\n        cls.sub_file.write_text(\"Sub content\")\n        \n        # Create a file outside the valid directory\n        cls.outside_file = cls.base_path / \"outside.txt\"\n        cls.outside_file.write_text(\"Outside content\")\n        \n        # Mock configuration directories dictionary\n        cls.config_dirs_mock = {\n            'valid_key': cls.valid_dir\n        }\n    \n    @classmethod\n    def tearDownClass(cls):\n        # Clean up temporary directory\n        cls.test_dir.cleanup()\n    \n    def test_valid_key_and_file(self):\n        # Test happy path: valid key and existing file\n        with patch('config_loader.config_dirs', self.config_dirs_mock):\n            result = load_config('valid_key', 'config.txt')\n            self.assertEqual(result, \"Hello, World!\")\n    \n    def test_valid_key_subdir_file(self):\n        # Test valid key and file in subdirectory\n        with patch('config_loader.config_dirs', self.config_dirs_mock):\n            result = load_config('valid_key', 'subdir/sub_config.txt')\n            self.assertEqual(result, \"Sub content\")\n    \n    def test_valid_key_nonexistent_file(self):\n        # Test valid key but non-existent file\n        with patch('config_loader.config_dirs', self.config_dirs_mock):\n            with self.assertRaises(ValueError) as context:\n                load_config('valid_key', 'nonexistent.txt')\n            self.assertIn(\"does not exist\", str(context.exception))\n    \n    def test_invalid_key(self):\n        # Test invalid directory key\n        with patch('config_loader.config_dirs', self.config_dirs_mock):\n            with self.assertRaises(KeyError) as context:\n                load_config('invalid_key', 'config.txt')\n            self.assertIn(\"Configuration directory invalid_key not found\", str(context.exception))\n    \n    def test_path_traversal_attempt(self):\n        # Test path traversal attempt (using ../)\n        with patch('config_loader.config_dirs', self.config_dirs_mock):\n            with self.assertRaises(Exception) as context:\n                load_config('valid_key', '../outside.txt')\n            self.assertIn(\"is not allowed\", str(context.exception))\n    \n    def test_absolute_path_inside(self):\n        # Test absolute path that remains inside config directory\n        with patch('config_loader.config_dirs', self.config_dirs_mock):\n            # Convert to relative path from valid_dir to simulate absolute path\n            abs_path_inside = str(self.config_file.resolve())\n            result = load_config('valid_key', abs_path_inside)\n            self.assertEqual(result, \"Hello, World!\")\n    \n    def test_absolute_path_outside(self):\n        # Test absolute path that points outside config directory\n        with patch('config_loader.config_dirs', self.config_dirs_mock):\n            abs_path_outside = str(self.outside_file.resolve())\n            with self.assertRaises(Exception) as context:\n                load_config('valid_key', abs_path_outside)\n            self.assertIn(\"is not allowed\", str(context.exception))\n    \n    def test_empty_file_title(self):\n        # Test with empty file title\n        with patch('config_loader.config_dirs', self.config_dirs_mock):\n            with self.assertRaises(ValueError) as context:\n                load_config('valid_key', '')\n            self.assertIn(\"does not exist\", str(context.exception))\n    \n    def test_none_file_title(self):\n        # Test with None file title\n        with patch('config_loader.config_dirs', self.config_dirs_mock):\n            with self.assertRaises(Exception):\n                load_config('valid_key', None)\n    \n    def test_large_filename(self):\n        # Test with a very long filename\n        with patch('config_loader.config_dirs', self.config_dirs_mock):\n            long_name = 'a' * 1000 + '.txt'\n            with self.assertRaises(ValueError) as context:\n                load_config('valid_key', long_name)\n            self.assertIn(\"does not exist\", str(context.exception))", "num_test_cases": 10, "task_id": "0415c09f"}
{"test": "import unittest\nimport tempfile\nimport shutil\nfrom pathlib import Path\nfrom unittest.mock import patch\n\n# Assume the function is in a module named 'solution'\nfrom solution import get_config_content\n\nclass TestGetConfigContent(unittest.TestCase):\n    def setUp(self):\n        # Create temporary directories\n        self.temp_dir1 = Path(tempfile.mkdtemp())\n        self.temp_dir2 = Path(tempfile.mkdtemp())\n        \n        # Create valid file in temp_dir1\n        self.valid_file = self.temp_dir1 / \"test.txt\"\n        self.valid_file.write_text(\"Hello, World!\")\n        \n        # Create subdirectory and file in temp_dir1\n        self.subdir = self.temp_dir1 / \"subdir\"\n        self.subdir.mkdir()\n        self.sub_file = self.subdir / \"subfile.txt\"\n        self.sub_file.write_text(\"Subdirectory file\")\n        \n        # Create file in temp_dir2 (outside)\n        self.outside_file = self.temp_dir2 / \"outside.txt\"\n        self.outside_file.write_text(\"Outside file\")\n        \n        # Prepare config_dirs dictionary\n        self.config_dirs = {\n            'test_key': self.temp_dir1\n        }\n        \n        # Patch solution.config_dirs to use our test dictionary\n        self.patcher = patch('solution.config_dirs', self.config_dirs)\n        self.patcher.start()\n    \n    def tearDown(self):\n        # Stop patcher and clean up temporary directories\n        self.patcher.stop()\n        shutil.rmtree(self.temp_dir1, ignore_errors=True)\n        shutil.rmtree(self.temp_dir2, ignore_errors=True)\n    \n    def test_happy_path(self):\n        # Test with valid key and existing file\n        content = get_config_content('test_key', 'test.txt')\n        self.assertEqual(content, \"Hello, World!\")\n    \n    def test_key_not_found(self):\n        # Test with non-existent key\n        with self.assertRaises(KeyError):\n            get_config_content('invalid_key', 'test.txt')\n    \n    def test_file_not_found(self):\n        # Test with valid key but non-existent file\n        with self.assertRaises(ValueError):\n            get_config_content('test_key', 'nonexistent.txt')\n    \n    def test_path_traversal_outside(self):\n        # Test path traversal attempt (relative path leaving config_dir)\n        traversal_path = '../' + self.temp_dir2.name + '/outside.txt'\n        with self.assertRaises(Exception) as context:\n            get_config_content('test_key', traversal_path)\n        self.assertIn(f\"Path {traversal_path} is not allowed\", str(context.exception))\n    \n    def test_file_in_subdirectory(self):\n        # Test accessing file in valid subdirectory\n        content = get_config_content('test_key', 'subdir/subfile.txt')\n        self.assertEqual(content, \"Subdirectory file\")\n    \n    def test_absolute_path_inside(self):\n        # Test absolute path within config_dir\n        abs_path = str(self.sub_file.absolute())\n        content = get_config_content('test_key', abs_path)\n        self.assertEqual(content, \"Subdirectory file\")\n    \n    def test_absolute_path_outside(self):\n        # Test absolute path outside config_dir\n        abs_path = str(self.outside_file.absolute())\n        with self.assertRaises(Exception) as context:\n            get_config_content('test_key', abs_path)\n        self.assertIn(f\"Path {abs_path} is not allowed\", str(context.exception))\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 7, "task_id": "39bb37c6"}
{"test": "import unittest\nfrom pathlib import Path\nimport tempfile\nimport os\n\ndirectories = {}\n\nclass TestFetchLogFile(unittest.TestCase):\n    def setUp(self):\n        # Create a temporary directory\n        self.temp_dir = tempfile.TemporaryDirectory()\n        self.temp_path = Path(self.temp_dir.name)\n        \n        # Create directory structure\n        self.test_key_dir = self.temp_path / 'test_key'\n        self.test_key_dir.mkdir()\n        \n        # Create files\n        self.log_file = self.test_key_dir / 'test.log'\n        self.log_file.write_text('Log content')\n        \n        self.subdir = self.test_key_dir / 'subdir'\n        self.subdir.mkdir()\n        self.subdir_file = self.subdir / 'subdir_file.log'\n        self.subdir_file.write_text('Subdir content')\n        \n        # Set global directories\n        global directories\n        directories = {'test_key': self.test_key_dir}\n    \n    def tearDown(self):\n        self.temp_dir.cleanup()\n    \n    def test_happy_path_file_in_root(self):\n        # Test valid key and file in root directory\n        global directories\n        result = fetch_log_file('test_key', 'test.log')\n        self.assertEqual(result, self.test_key_dir / 'test.log')\n        self.assertTrue(result.exists())\n    \n    def test_happy_path_file_in_subdir(self):\n        # Test valid key and file in subdirectory\n        global directories\n        result = fetch_log_file('test_key', 'subdir/subdir_file.log')\n        self.assertEqual(result, self.test_key_dir / 'subdir' / 'subdir_file.log')\n        self.assertTrue(result.exists())\n    \n    def test_empty_relative_path(self):\n        # Test empty relative_path (points to directory)\n        global directories\n        result = fetch_log_file('test_key', '')\n        self.assertEqual(result, self.test_key_dir)\n        self.assertTrue(result.exists())\n    \n    def test_key_error(self):\n        # Test non-existent key\n        global directories\n        with self.assertRaises(KeyError) as context:\n            fetch_log_file('invalid_key', 'test.log')\n        self.assertEqual(str(context.exception), \"Directory key invalid_key not found\")\n    \n    def test_file_not_found_error(self):\n        # Test non-existent file\n        global directories\n        non_existent = self.test_key_dir / 'missing.log'\n        with self.assertRaises(FileNotFoundError) as context:\n            fetch_log_file('test_key', 'missing.log')\n        self.assertEqual(str(context.exception), f\"Log file {non_existent} does not exist\")\n    \n    def test_security_check_failure(self):\n        # Test path traversal attempt\n        global directories\n        with self.assertRaises(Exception) as context:\n            fetch_log_file('test_key', '../outside.txt')\n        self.assertEqual(str(context.exception), \"Access to path ../outside.txt is not allowed\")\n    \n    def test_absolute_path_security_check(self):\n        # Test absolute path in relative_path\n        global directories\n        abs_path = os.path.abspath(os.path.join(self.temp_path, 'outside.txt'))\n        with self.assertRaises(Exception) as context:\n            fetch_log_file('test_key', abs_path)\n        self.assertEqual(str(context.exception), f\"Access to path {abs_path} is not allowed\")\n    \n    def test_symlink_escape(self):\n        # Test symlink pointing outside directory\n        global directories\n        # Create a symlink inside test_key that points to temp_path's parent\n        symlink = self.test_key_dir / 'escape_symlink'\n        symlink.symlink_to(self.temp_path.parent)\n        \n        # Try to access a file through the symlink\n        target_file = symlink / 'outside.txt'\n        target_file.touch()\n        \n        # Should fail security check because resolved path is outside\n        with self.assertRaises(Exception) as context:\n            fetch_log_file('test_key', 'escape_symlink/outside.txt')\n        self.assertEqual(str(context.exception), \"Access to path escape_symlink/outside.txt is not allowed\")\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 8, "task_id": "4353db7e"}
{"test": "import unittest\nimport tempfile\nfrom pathlib import Path\nimport sys\n\n# Assume the function is in a module named 'log_utils'\nclass TestLocateLogFile(unittest.TestCase):\n    def setUp(self):\n        # Create a temporary directory\n        self.temp_dir = tempfile.TemporaryDirectory()\n        self.temp_path = Path(self.temp_dir.name)\n        \n        # Create a base directory for LOG_DIR\n        self.base_dir = self.temp_path / \"logs\"\n        self.base_dir.mkdir()\n        \n        # Create an existing file in the base directory\n        self.existing_file = self.base_dir / \"app.log\"\n        self.existing_file.touch()\n        \n        # Create a subdirectory and a file within\n        self.sub_dir = self.base_dir / \"subdir\"\n        self.sub_dir.mkdir()\n        self.deep_file = self.sub_dir / \"deep.log\"\n        self.deep_file.touch()\n        \n        # Create a long path\n        self.long_dir = self.base_dir / (\"a\" * 100)\n        self.long_dir.mkdir()\n        self.long_file = self.long_dir / \"long.log\"\n        self.long_file.touch()\n        \n        # Set the global directory_list for the 'log_utils' module\n        import log_utils\n        log_utils.directory_list = {\n            \"LOG_DIR\": self.base_dir\n        }\n    \n    def tearDown(self):\n        self.temp_dir.cleanup()\n    \n    def test_happy_path(self):\n        # Test existing file in base directory\n        from log_utils import locate_log_file\n        result = locate_log_file(\"LOG_DIR\", \"app.log\")\n        self.assertEqual(result, self.existing_file)\n    \n    def test_key_error(self):\n        # Test invalid directory key\n        from log_utils import locate_log_file\n        with self.assertRaises(KeyError):\n            locate_log_file(\"INVALID_KEY\", \"app.log\")\n    \n    def test_file_not_found(self):\n        # Test non-existent file\n        from log_utils import locate_log_file\n        with self.assertRaises(FileNotFoundError):\n            locate_log_file(\"LOG_DIR\", \"nonexistent.log\")\n    \n    def test_security_check_path_traversal(self):\n        # Test path traversal attempt\n        from log_utils import locate_log_file\n        with self.assertRaises(Exception) as cm:\n            locate_log_file(\"LOG_DIR\", \"../../etc/passwd\")\n        self.assertIn(\"Access to path ../../etc/passwd is not allowed\", str(cm.exception))\n    \n    def test_empty_relative_path(self):\n        # Test empty relative path (points to base directory)\n        from log_utils import locate_log_file\n        result = locate_log_file(\"LOG_DIR\", \"\")\n        self.assertEqual(result, self.base_dir)\n    \n    def test_long_relative_path(self):\n        # Test long relative path that exists\n        from log_utils import locate_log_file\n        rel_path = Path(\"a\" * 100) / \"long.log\"\n        result = locate_log_file(\"LOG_DIR\", str(rel_path))\n        self.assertEqual(result, self.long_file)\n    \n    def test_subdirectory_file(self):\n        # Test file in subdirectory\n        from log_utils import locate_log_file\n        result = locate_log_file(\"LOG_DIR\", \"subdir/deep.log\")\n        self.assertEqual(result, self.deep_file)\n    \n    def test_absolute_path_in_relative(self):\n        # Test absolute path in relative path argument\n        from log_utils import locate_log_file\n        abs_path = \"/absolute/path\"\n        with self.assertRaises(Exception) as cm:\n            locate_log_file(\"LOG_DIR\", abs_path)\n        self.assertIn(f\"Access to path {abs_path} is not allowed\", str(cm.exception))\n", "num_test_cases": 8, "task_id": "bb6de12c"}
{"test": "import unittest\nfrom unittest.mock import patch\nfrom pathlib import Path\nimport tempfile\n\nclass TestResolveLogFile(unittest.TestCase):\n    def setUp(self):\n        # Create a temporary directory structure\n        self.temp_dir = tempfile.TemporaryDirectory()\n        self.temp_path = Path(self.temp_dir.name)\n        \n        # Create files and subdirectories\n        self.file1 = self.temp_path / \"file1.txt\"\n        self.file1.touch()\n        \n        self.subdir = self.temp_path / \"subdir\"\n        self.subdir.mkdir()\n        self.file2 = self.subdir / \"file2.txt\"\n        self.file2.touch()\n        \n        self.empty_dir = self.temp_path / \"empty_dir\"\n        self.empty_dir.mkdir()\n        \n        self.non_ascii_file = self.temp_path / \"ñ.txt\"\n        self.non_ascii_file.touch()\n        \n        # Directory keys for testing\n        self.test_directories = {\n            \"key1\": self.temp_path,\n            \"empty_key\": self.empty_dir,\n            \"\": self.temp_path / \"empty_string_key_dir\"  # Add key for empty string\n        }\n        # Create directory for empty string key\n        self.test_directories[\"\"] = self.temp_path / \"empty_string_key_dir\"\n        self.test_directories[\"\"].mkdir()\n        \n        # Create a file for empty key\n        self.empty_key_file = self.test_directories[\"\"] / \"empty_key_file.txt\"\n        self.empty_key_file.touch()\n        \n    def tearDown(self):\n        self.temp_dir.cleanup()\n\n    def test_happy_path_root_file(self):\n        # Test valid dir_identifier and relative path to file in root\n        with patch('log_resolver.log_directories', self.test_directories):\n            result = resolve_log_file(\"key1\", \"file1.txt\")\n            self.assertEqual(result, self.file1)\n    \n    def test_happy_path_subdirectory_file(self):\n        # Test valid dir_identifier and relative path to file in subdirectory\n        with patch('log_resolver.log_directories', self.test_directories):\n            result = resolve_log_file(\"key1\", \"subdir/file2.txt\")\n            self.assertEqual(result, self.file2)\n    \n    def test_key_not_found(self):\n        # Test invalid dir_identifier (KeyError)\n        with patch('log_resolver.log_directories', self.test_directories):\n            with self.assertRaises(KeyError):\n                resolve_log_file(\"invalid_key\", \"any.txt\")\n    \n    def test_file_not_found(self):\n        # Test valid dir_identifier but non-existent file\n        with patch('log_resolver.log_directories', self.test_directories):\n            with self.assertRaises(FileNotFoundError):\n                resolve_log_file(\"key1\", \"nonexistent.txt\")\n    \n    def test_path_traversal_attempt(self):\n        # Test relative path that escapes root directory\n        with patch('log_resolver.log_directories', self.test_directories):\n            with self.assertRaises(Exception) as context:\n                resolve_log_file(\"key1\", \"../outside.txt\")\n            self.assertIn(\"Access to path\", str(context.exception))\n    \n    def test_empty_dir_identifier_not_found(self):\n        # Test empty string dir_identifier when not present (removed from test_directories)\n        # Temporarily remove the empty string key\n        del self.test_directories[\"\"]\n        with patch('log_resolver.log_directories', self.test_directories):\n            with self.assertRaises(KeyError):\n                resolve_log_file(\"\", \"any.txt\")\n    \n    def test_empty_dir_identifier_valid(self):\n        # Test empty string dir_identifier when present\n        with patch('log_resolver.log_directories', self.test_directories):\n            result = resolve_log_file(\"\", \"empty_key_file.txt\")\n            self.assertEqual(result, self.empty_key_file)\n    \n    def test_empty_relative_path(self):\n        # Test empty relative path (should return the root directory)\n        with patch('log_resolver.log_directories', self.test_directories):\n            result = resolve_log_file(\"key1\", \"\")\n            self.assertEqual(result, self.temp_path)\n    \n    def test_non_ascii_path(self):\n        # Test relative path with non-ASCII characters\n        with patch('log_resolver.log_directories', self.test_directories):\n            result = resolve_log_file(\"key1\", \"ñ.txt\")\n            self.assertEqual(result, self.non_ascii_file)\n    \n    def test_absolute_path_input(self):\n        # Test absolute path for file_relative_path (security violation)\n        abs_path = str(self.temp_path / \"file1.txt\")\n        with patch('log_resolver.log_directories', self.test_directories):\n            with self.assertRaises(Exception) as context:\n                resolve_log_file(\"key1\", abs_path)\n            self.assertIn(\"Access to path\", str(context.exception))\n    \n    def test_normalization_within_root(self):\n        # Test relative path with . and .. that stays within root\n        with patch('log_resolver.log_directories', self.test_directories):\n            result = resolve_log_file(\"key1\", \"./subdir/../file1.txt\")\n            self.assertEqual(result, self.temp_path / \"./subdir/../file1.txt\")\n    \n    def test_directory_path_instead_of_file(self):\n        # Test existing directory path instead of file (should not raise FileNotFoundError)\n        with patch('log_resolver.log_directories', self.test_directories):\n            result = resolve_log_file(\"key1\", \"subdir\")\n            self.assertEqual(result, self.subdir)", "num_test_cases": 13, "task_id": "68e2739a"}
{"test": "import unittest\nfrom pathlib import Path\nimport tempfile\nimport shutil\nfrom unittest.mock import patch\nfrom solution import retrieve_log_file\n\nclass TestRetrieveLogFile(unittest.TestCase):\n    \n    def setUp(self):\n        # Create a temporary directory\n        self.test_dir = tempfile.mkdtemp()\n        # Create a base directory for logs\n        self.base_dir = Path(self.test_dir) / \"logs\"\n        self.base_dir.mkdir()\n        # Create a log file\n        self.log_file = self.base_dir / \"app.log\"\n        self.log_file.touch()\n        # Create a subdirectory and file\n        self.subdir = self.base_dir / \"subdir\"\n        self.subdir.mkdir()\n        self.sub_file = self.subdir / \"file.log\"\n        self.sub_file.touch()\n        # Define the directories dictionary\n        self.directories = {\n            \"logs\": self.base_dir,\n            \"temp\": Path(self.test_dir) / \"temp\"  # Does not exist\n        }\n        # Patch the 'solution.directories' with our test dictionary\n        self.patcher = patch('solution.directories', self.directories)\n        self.patcher.start()\n    \n    def tearDown(self):\n        # Stop patching and clean up\n        self.patcher.stop()\n        shutil.rmtree(self.test_dir)\n    \n    def test_happy_path(self):\n        # Test existing file in base directory\n        result = retrieve_log_file(\"logs\", \"app.log\")\n        self.assertEqual(result, self.base_dir / \"app.log\")\n    \n    def test_subdirectory_file(self):\n        # Test existing file in subdirectory\n        result = retrieve_log_file(\"logs\", \"subdir/file.log\")\n        self.assertEqual(result, self.base_dir / \"subdir\" / \"file.log\")\n    \n    def test_key_error(self):\n        # Test non-existent directory key\n        with self.assertRaises(KeyError):\n            retrieve_log_file(\"non_existent\", \"any.log\")\n    \n    def test_file_not_found(self):\n        # Test non-existent file in valid directory\n        with self.assertRaises(FileNotFoundError):\n            retrieve_log_file(\"logs\", \"missing.log\")\n    \n    def test_base_directory_not_exist(self):\n        # Test valid key but base directory doesn't exist\n        with self.assertRaises(FileNotFoundError):\n            retrieve_log_file(\"temp\", \"any.log\")\n    \n    def test_path_traversal_attempt(self):\n        # Test path traversal outside allowed directory\n        with self.assertRaises(Exception) as context:\n            retrieve_log_file(\"logs\", \"../temp/temp.log\")\n        self.assertIn(\"Access to path\", str(context.exception))\n    \n    def test_empty_relative_path(self):\n        # Test empty string as relative path\n        result = retrieve_log_file(\"logs\", \"\")\n        self.assertEqual(result, self.base_dir)\n    \n    def test_nested_traversal_attempt(self):\n        # Test complex path traversal attempt\n        with self.assertRaises(Exception) as context:\n            retrieve_log_file(\"logs\", \"subdir/../../etc/passwd\")\n        self.assertIn(\"Access to path\", str(context.exception))", "num_test_cases": 8, "task_id": "52c26245"}
{"test": "import unittest\nfrom pathlib import Path\nimport tempfile\n\n# Global variable as per the function's requirement\ndirectories = {}\n\ndef fetch_log_file(directory_key: str, relative_path: str) -> Path:\n    if directory_key in directories:\n        base_folder = directories[directory_key]\n        log_file = base_folder / relative_path\n        try:\n            log_file.resolve().relative_to(base_folder.resolve())\n        except ValueError:\n            raise Exception(f\"Access to path {relative_path} is not allowed\")\n        if not log_file.exists():\n            raise FileNotFoundError(f\"Log file {log_file} does not exist\")\n        return log_file\n    else:\n        raise KeyError(f\"Directory key {directory_key} not found\")\n\nclass TestFetchLogFile(unittest.TestCase):\n    @classmethod\n    def setUpClass(cls):\n        # Create a temporary directory\n        cls.temp_dir = tempfile.TemporaryDirectory()\n        cls.temp_dir_path = Path(cls.temp_dir.name)\n        \n        # Create base directories\n        cls.base_dir1 = cls.temp_dir_path / 'dir1'\n        cls.base_dir1.mkdir()\n        cls.base_dir2 = cls.temp_dir_path / 'dir2'\n        cls.base_dir2.mkdir()\n        \n        # Create files in base_dir1\n        (cls.base_dir1 / 'file1.log').touch()\n        (cls.base_dir1 / 'subdir').mkdir()\n        (cls.base_dir1 / 'subdir' / 'file2.log').touch()\n        \n        # Create a file in base_dir2\n        (cls.base_dir2 / 'file3.log').touch()\n        \n        # Create a file outside base_dir1\n        (cls.temp_dir_path / 'outside.txt').touch()\n        \n        # Define the directories dictionary\n        cls.directories = {\n            'key1': cls.base_dir1,\n            'key2': cls.base_dir2\n        }\n    \n    @classmethod\n    def tearDownClass(cls):\n        # Clean up the temporary directory\n        cls.temp_dir.cleanup()\n    \n    def setUp(self):\n        # Set the global directories to the test directories\n        global directories\n        directories = self.directories\n    \n    def test_valid_key_and_file(self):\n        # Test with a valid key and existing file\n        result = fetch_log_file('key1', 'file1.log')\n        self.assertEqual(result, self.base_dir1 / 'file1.log')\n    \n    def test_valid_key_and_subdir_file(self):\n        # Test with a valid key and file in a subdirectory\n        result = fetch_log_file('key1', 'subdir/file2.log')\n        self.assertEqual(result, self.base_dir1 / 'subdir' / 'file2.log')\n    \n    def test_invalid_key(self):\n        # Test with an invalid directory key\n        with self.assertRaises(KeyError):\n            fetch_log_file('key3', 'file1.log')\n    \n    def test_file_not_found(self):\n        # Test with a valid key but non-existent file\n        with self.assertRaises(FileNotFoundError):\n            fetch_log_file('key1', 'non_existent.log')\n    \n    def test_path_traversal_attempt(self):\n        # Test with a relative path attempting to escape the base directory\n        with self.assertRaises(Exception) as context:\n            fetch_log_file('key1', '../outside.txt')\n        self.assertIn('Access to path', str(context.exception))\n    \n    def test_absolute_path_inside(self):\n        # Test with an absolute path that is within the base directory\n        abs_path = (self.base_dir1 / 'file1.log').resolve()\n        result = fetch_log_file('key1', str(abs_path))\n        self.assertEqual(result, abs_path)\n    \n    def test_absolute_path_outside(self):\n        # Test with an absolute path outside the base directory\n        abs_path = (self.temp_dir_path / 'outside.txt').resolve()\n        with self.assertRaises(Exception) as context:\n            fetch_log_file('key1', str(abs_path))\n        self.assertIn('Access to path', str(context.exception))\n    \n    def test_empty_relative_path(self):\n        # Test with an empty relative path (points to the base directory)\n        result = fetch_log_file('key1', '')\n        self.assertEqual(result, self.base_dir1)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 8, "task_id": "c0be1d0c"}
{"test": "import unittest\nimport tempfile\nfrom pathlib import Path\nfrom unittest.mock import patch\n\n# Import the function from its module\n# Note: This test assumes the function is in 'log_retriever' module\nfrom log_retriever import retrieve_log_path\n\nclass TestRetrieveLogPath(unittest.TestCase):\n    def setUp(self):\n        # Create a temporary directory structure\n        self.temp_dir = tempfile.TemporaryDirectory()\n        self.base_path = Path(self.temp_dir.name)\n        \n        # Create test files\n        self.file_base = self.base_path / \"base_file.log\"\n        self.file_base.touch()\n        \n        self.subdir = self.base_path / \"subdir\"\n        self.subdir.mkdir()\n        self.file_subdir = self.subdir / \"sub_file.log\"\n        self.file_subdir.touch()\n        \n        self.valid_key = \"valid_key\"\n        \n        # Create a file that will be accessed via absolute path inside base\n        self.inside_abs_file = self.base_path / \"inside_abs.log\"\n        self.inside_abs_file.touch()\n        \n        # Path for an absolute file outside the base\n        self.outside_abs_file = Path(self.temp_dir.name).parent / \"outside.log\"\n    \n    def tearDown(self):\n        self.temp_dir.cleanup()\n\n    @patch('log_retriever.directories')\n    def test_happy_path_base_file(self, mock_dirs):\n        # Test valid key and relative path to file in base directory\n        mock_dirs.__contains__.return_value = True\n        mock_dirs.__getitem__.return_value = self.base_path\n        \n        result = retrieve_log_path(self.valid_key, \"base_file.log\")\n        self.assertEqual(result, self.file_base)\n\n    @patch('log_retriever.directories')\n    def test_happy_path_subdir_file(self, mock_dirs):\n        # Test valid key and relative path to file in subdirectory\n        mock_dirs.__contains__.return_value = True\n        mock_dirs.__getitem__.return_value = self.base_path\n        \n        result = retrieve_log_path(self.valid_key, \"subdir/sub_file.log\")\n        self.assertEqual(result, self.file_subdir)\n\n    @patch('log_retriever.directories')\n    def test_key_error(self, mock_dirs):\n        # Test invalid directory key\n        mock_dirs.__contains__.return_value = False\n        \n        with self.assertRaises(KeyError):\n            retrieve_log_path(\"invalid_key\", \"any.log\")\n\n    @patch('log_retriever.directories')\n    def test_file_not_found(self, mock_dirs):\n        # Test valid key but non-existent file\n        mock_dirs.__contains__.return_value = True\n        mock_dirs.__getitem__.return_value = self.base_path\n        \n        with self.assertRaises(FileNotFoundError):\n            retrieve_log_path(self.valid_key, \"nonexistent.log\")\n\n    @patch('log_retriever.directories')\n    def test_escape_relative_path(self, mock_dirs):\n        # Test relative path that escapes base directory (security)\n        mock_dirs.__contains__.return_value = True\n        mock_dirs.__getitem__.return_value = self.base_path\n        \n        with self.assertRaises(Exception) as context:\n            retrieve_log_path(self.valid_key, \"../escape.log\")\n        self.assertIn(\"Access to path\", str(context.exception))\n\n    @patch('log_retriever.directories')\n    def test_absolute_path_outside(self, mock_dirs):\n        # Test absolute path outside base directory (security)\n        mock_dirs.__contains__.return_value = True\n        mock_dirs.__getitem__.return_value = self.base_path\n        \n        with self.assertRaises(Exception) as context:\n            retrieve_log_path(self.valid_key, str(self.outside_abs_file))\n        self.assertIn(\"Access to path\", str(context.exception))\n\n    @patch('log_retriever.directories')\n    def test_absolute_path_inside(self, mock_dirs):\n        # Test absolute path inside base directory\n        mock_dirs.__contains__.return_value = True\n        mock_dirs.__getitem__.return_value = self.base_path\n        \n        result = retrieve_log_path(self.valid_key, str(self.inside_abs_file))\n        self.assertEqual(result, self.inside_abs_file)\n\n    @patch('log_retriever.directories')\n    def test_empty_relative_path(self, mock_dirs):\n        # Test empty relative path (points to base directory)\n        mock_dirs.__contains__.return_value = True\n        mock_dirs.__getitem__.return_value = self.base_path\n        \n        result = retrieve_log_path(self.valid_key, \"\")\n        self.assertEqual(result, self.base_path)\n\n    @patch('log_retriever.directories')\n    def test_non_string_file_relative_path(self, mock_dirs):\n        # Test non-string file_relative_path (TypeError expected)\n        mock_dirs.__contains__.return_value = True\n        mock_dirs.__getitem__.return_value = self.base_path\n        \n        with self.assertRaises(TypeError):\n            retrieve_log_path(self.valid_key, 123)\n\n    @patch('log_retriever.directories')\n    def test_relative_path_with_dot(self, mock_dirs):\n        # Test relative path with '.' (current directory)\n        mock_dirs.__contains__.return_value = True\n        mock_dirs.__getitem__.return_value = self.base_path\n        \n        result = retrieve_log_path(self.valid_key, \"./base_file.log\")\n        self.assertEqual(result, self.file_base)\n\n    @patch('log_retriever.directories')\n    def test_relative_path_with_dot_dot_inside(self, mock_dirs):\n        # Test relative path with '../' that stays inside base\n        mock_dirs.__contains__.return_value = True\n        mock_dirs.__getitem__.return_value = self.base_path\n        \n        result = retrieve_log_path(self.valid_key, \"subdir/../base_file.log\")\n        self.assertEqual(result, self.file_base)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 11, "task_id": "377c977f"}
{"test": "import unittest\nfrom unittest.mock import patch\nfrom pathlib import Path\nimport tempfile\nimport os\n\nfrom solution import fetch_log_file\n\nclass TestFetchLogFile(unittest.TestCase):\n\n    def setUp(self):\n        self.temp_dir = tempfile.TemporaryDirectory()\n        self.base_dir = Path(self.temp_dir.name)\n        self.existing_file = self.base_dir / 'existing.log'\n        self.existing_file.touch()\n        self.sub_dir = self.base_dir / 'sub'\n        self.sub_dir.mkdir()\n        self.file_in_sub = self.sub_dir / 'app.log'\n        self.file_in_sub.touch()\n\n    def tearDown(self):\n        self.temp_dir.cleanup()\n\n    def test_key_error(self):\n        \"\"\"Test KeyError when directory key does not exist.\"\"\"\n        with patch('solution.list_of_directories', {}):\n            with self.assertRaises(KeyError):\n                fetch_log_file('test_dir', 'existing.log')\n\n    def test_happy_path(self):\n        \"\"\"Test with valid directory key and existing file.\"\"\"\n        with patch('solution.list_of_directories', {'test_dir': self.base_dir}):\n            result = fetch_log_file('test_dir', 'existing.log')\n            self.assertEqual(result, self.base_dir / 'existing.log')\n\n    def test_file_not_found(self):\n        \"\"\"Test FileNotFoundError when file does not exist.\"\"\"\n        with patch('solution.list_of_directories', {'test_dir': self.base_dir}):\n            with self.assertRaises(FileNotFoundError):\n                fetch_log_file('test_dir', 'nonexistent.log')\n\n    def test_path_traversal_escape(self):\n        \"\"\"Test path traversal attempt using '../'.\"\"\"\n        with patch('solution.list_of_directories', {'test_dir': self.base_dir}):\n            with self.assertRaises(Exception) as context:\n                fetch_log_file('test_dir', '../external.log')\n            self.assertIn(\"Access to path\", str(context.exception))\n\n    def test_absolute_path_escape(self):\n        \"\"\"Test absolute path outside the base directory.\"\"\"\n        with patch('solution.list_of_directories', {'test_dir': self.base_dir}):\n            outside_file = self.base_dir.parent / 'external.log'\n            outside_file.touch()\n            try:\n                with self.assertRaises(Exception) as context:\n                    fetch_log_file('test_dir', str(outside_file))\n                self.assertIn(\"Access to path\", str(context.exception))\n            finally:\n                outside_file.unlink()\n\n    def test_subdirectory_file(self):\n        \"\"\"Test valid file in a subdirectory.\"\"\"\n        with patch('solution.list_of_directories', {'test_dir': self.base_dir}):\n            result = fetch_log_file('test_dir', 'sub/app.log')\n            self.assertEqual(result, self.file_in_sub)\n\n    def test_existing_directory(self):\n        \"\"\"Test existing directory path instead of file.\"\"\"\n        with patch('solution.list_of_directories', {'test_dir': self.base_dir}):\n            result = fetch_log_file('test_dir', '')\n            self.assertEqual(result, self.base_dir)\n\n    def test_dot_in_path(self):\n        \"\"\"Test relative path with './' notation.\"\"\"\n        with patch('solution.list_of_directories', {'test_dir': self.base_dir}):\n            result = fetch_log_file('test_dir', './existing.log')\n            self.assertEqual(result, self.base_dir / 'existing.log')\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 8, "task_id": "d3ba1cd7"}
{"test": "import unittest\nfrom unittest.mock import patch\nfrom pathlib import Path\nimport tempfile\n\nclass TestRetrieveLogPath(unittest.TestCase):\n    def setUp(self):\n        # Create a temporary directory\n        self.test_dir = tempfile.TemporaryDirectory()\n        self.test_path = Path(self.test_dir.name)\n        # Create a file at the root\n        (self.test_path / 'test.log').touch()\n        # Create a subdirectory with a file\n        subdir = self.test_path / 'subdir'\n        subdir.mkdir()\n        (subdir / 'file.log').touch()\n        # Define the log directories dictionary for testing\n        self.log_dirs = {\n            'valid_key': self.test_path\n        }\n        \n    def tearDown(self):\n        self.test_dir.cleanup()\n        \n    def test_valid_file(self):\n        # Test with valid key and existing file\n        module_name = retrieve_log_path.__module__\n        with patch(f\"{module_name}.log_directories\", self.log_dirs):\n            result = retrieve_log_path('valid_key', 'test.log')\n            self.assertEqual(result, self.test_path / 'test.log')\n            \n    def test_file_not_found(self):\n        # Test with valid key but non-existent file\n        module_name = retrieve_log_path.__module__\n        with patch(f\"{module_name}.log_directories\", self.log_dirs):\n            file_name = 'non_existent.log'\n            expected_path = self.test_path / file_name\n            with self.assertRaises(FileNotFoundError) as cm:\n                retrieve_log_path('valid_key', file_name)\n            self.assertEqual(str(cm.exception), f\"Log file {expected_path} does not exist\")\n            \n    def test_escape_with_double_dot(self):\n        # Test escaping base directory using '..'\n        module_name = retrieve_log_path.__module__\n        with patch(f\"{module_name}.log_directories\", self.log_dirs):\n            relative_path = '../outside.txt'\n            with self.assertRaises(Exception) as cm:\n                retrieve_log_path('valid_key', relative_path)\n            self.assertEqual(str(cm.exception), f\"Access to path {relative_path} is not allowed\")\n            \n    def test_escape_with_multiple_dots(self):\n        # Test escaping using multiple '..'\n        module_name = retrieve_log_path.__module__\n        with patch(f\"{module_name}.log_directories\", self.log_dirs):\n            relative_path = 'subdir/../../outside.txt'\n            with self.assertRaises(Exception) as cm:\n                retrieve_log_path('valid_key', relative_path)\n            self.assertEqual(str(cm.exception), f\"Access to path {relative_path} is not allowed\")\n            \n    def test_invalid_key(self):\n        # Test with invalid directory key\n        module_name = retrieve_log_path.__module__\n        with patch(f\"{module_name}.log_directories\", self.log_dirs):\n            invalid_key = 'invalid_key'\n            with self.assertRaises(KeyError) as cm:\n                retrieve_log_path(invalid_key, 'test.log')\n            self.assertEqual(str(cm.exception), f\"Directory key {invalid_key} not found\")\n            \n    def test_empty_relative_path(self):\n        # Test with empty relative path (should return base directory)\n        module_name = retrieve_log_path.__module__\n        with patch(f\"{module_name}.log_directories\", self.log_dirs):\n            result = retrieve_log_path('valid_key', '')\n            self.assertEqual(result, self.test_path)\n            \n    def test_dot_relative_path(self):\n        # Test with '.' relative path (should return base directory)\n        module_name = retrieve_log_path.__module__\n        with patch(f\"{module_name}.log_directories\", self.log_dirs):\n            result = retrieve_log_path('valid_key', '.')\n            self.assertEqual(result, self.test_path)\n            \n    def test_subdir_file(self):\n        # Test file in subdirectory\n        module_name = retrieve_log_path.__module__\n        with patch(f\"{module_name}.log_directories\", self.log_dirs):\n            result = retrieve_log_path('valid_key', 'subdir/file.log')\n            self.assertEqual(result, self.test_path / 'subdir' / 'file.log')\n            \n    def test_absolute_path(self):\n        # Test with absolute path (should escape base directory)\n        module_name = retrieve_log_path.__module__\n        with patch(f\"{module_name}.log_directories\", self.log_dirs):\n            abs_path = '/absolute/path'\n            with self.assertRaises(Exception) as cm:\n                retrieve_log_path('valid_key', abs_path)\n            self.assertEqual(str(cm.exception), f\"Access to path {abs_path} is not allowed\")\n            \n    def test_nonexistent_nested_file(self):\n        # Test non-existent file in nested directory\n        module_name = retrieve_log_path.__module__\n        with patch(f\"{module_name}.log_directories\", self.log_dirs):\n            file_path = 'nonexistent_dir/nonexistent.log'\n            expected_path = self.test_path / file_path\n            with self.assertRaises(FileNotFoundError) as cm:\n                retrieve_log_path('valid_key', file_path)\n            self.assertEqual(str(cm.exception), f\"Log file {expected_path} does not exist\")\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 10, "task_id": "1d4502d7"}
{"test": "import unittest\nfrom pathlib import Path\nfrom tempfile import TemporaryDirectory\nfrom unittest.mock import patch\nfrom log_utils import find_log_file\n\nclass TestFindLogFile(unittest.TestCase):\n    def setUp(self):\n        self.temp_dir = TemporaryDirectory()\n        self.base_path = Path(self.temp_dir.name)\n        self.test_directory_map = {'valid_key': self.base_path}\n    \n    def tearDown(self):\n        self.temp_dir.cleanup()\n\n    def test_happy_relative_root(self):\n        # Test with file in root of base directory\n        file_path = self.base_path / 'test.log'\n        file_path.touch()\n        with patch('log_utils.directory_map', self.test_directory_map):\n            result = find_log_file('valid_key', 'test.log')\n            self.assertEqual(result, file_path)\n            self.assertTrue(result.exists())\n\n    def test_happy_relative_subdir(self):\n        # Test with file in subdirectory of base\n        subdir = self.base_path / 'sub'\n        subdir.mkdir()\n        file_path = subdir / 'test.log'\n        file_path.touch()\n        with patch('log_utils.directory_map', self.test_directory_map):\n            result = find_log_file('valid_key', 'sub/test.log')\n            self.assertEqual(result, file_path)\n\n    def test_key_error(self):\n        # Test with invalid directory key\n        with patch('log_utils.directory_map', self.test_directory_map):\n            with self.assertRaises(KeyError):\n                find_log_file('invalid_key', 'test.log')\n\n    def test_file_not_found(self):\n        # Test with non-existent file\n        with patch('log_utils.directory_map', self.test_directory_map):\n            with self.assertRaises(FileNotFoundError):\n                find_log_file('valid_key', 'non_existent.log')\n\n    def test_relative_path_traversal_escape(self):\n        # Test relative path escaping base directory with '..'\n        relative_path = '../outside.log'\n        with patch('log_utils.directory_map', self.test_directory_map):\n            with self.assertRaises(Exception) as context:\n                find_log_file('valid_key', relative_path)\n            self.assertIn('Access to path', str(context.exception))\n\n    def test_happy_absolute_inside(self):\n        # Test absolute path within base directory\n        file_path = self.base_path / 'inside.log'\n        file_path.touch()\n        abs_path = str(file_path.resolve())\n        with patch('log_utils.directory_map', self.test_directory_map):\n            result = find_log_file('valid_key', abs_path)\n            self.assertEqual(result, file_path)\n\n    def test_absolute_path_outside(self):\n        # Test absolute path outside base directory\n        outside_file = self.base_path.parent / 'outside.log'\n        abs_path = str(outside_file.resolve())\n        with patch('log_utils.directory_map', self.test_directory_map):\n            with self.assertRaises(Exception) as context:\n                find_log_file('valid_key', abs_path)\n            self.assertIn('Access to path', str(context.exception))\n\n    def test_empty_relative_path(self):\n        # Test empty relative path returns base directory\n        with patch('log_utils.directory_map', self.test_directory_map):\n            result = find_log_file('valid_key', '')\n            self.assertEqual(result, self.base_path)\n            self.assertTrue(result.exists())\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 8, "task_id": "f03ce5d2"}
{"test": "import unittest\nimport tempfile\nfrom pathlib import Path\n\n# Global variable that the function uses\nresources = {}\n\ndef fetch_resource(resource_key: str, resource_path: str) -> Path:\n    if resource_key in resources:\n        directory_path = resources[resource_key]\n        file_path = directory_path / resource_path\n        try:\n            file_path.resolve().relative_to(directory_path.resolve())\n        except ValueError:\n            raise Exception(f\"Path {resource_path} is not allowed\")\n        if not file_path.exists():\n            raise ValueError(f\"File {file_path} is not existed\")\n        return file_path\n    else:\n        raise KeyError(f\"Resource {resource_key} not found\")\n\nclass TestFetchResource(unittest.TestCase):\n    def setUp(self):\n        # Create temporary directories and files\n        self.temp_dir1 = tempfile.TemporaryDirectory()\n        self.temp_dir1_path = Path(self.temp_dir1.name)\n        \n        # Create files in temp_dir1\n        self.file1 = self.temp_dir1_path / \"test.txt\"\n        self.file1.write_text(\"content\")\n        \n        self.subdir = self.temp_dir1_path / \"subdir\"\n        self.subdir.mkdir()\n        self.file2 = self.subdir / \"file2.txt\"\n        self.file2.write_text(\"content\")\n        \n        self.temp_dir2 = tempfile.TemporaryDirectory()\n        self.temp_dir2_path = Path(self.temp_dir2.name)\n        \n        # Create a file in temp_dir2\n        self.file3 = self.temp_dir2_path / \"file3.txt\"\n        self.file3.write_text(\"content\")\n        \n        # Set global resources\n        global resources\n        resources = {\n            \"resource1\": self.temp_dir1_path,\n            \"resource2\": self.temp_dir2_path\n        }\n    \n    def tearDown(self):\n        # Clean up temporary directories\n        self.temp_dir1.cleanup()\n        self.temp_dir2.cleanup()\n    \n    def test_valid_file_root(self):\n        # Valid file at root of resource1\n        result = fetch_resource(\"resource1\", \"test.txt\")\n        self.assertEqual(result, self.file1)\n        self.assertTrue(result.exists())\n    \n    def test_valid_file_subdir(self):\n        # Valid file in subdirectory of resource1\n        result = fetch_resource(\"resource1\", \"subdir/file2.txt\")\n        self.assertEqual(result, self.file2)\n        self.assertTrue(result.exists())\n    \n    def test_valid_directory(self):\n        # Valid directory (should return directory path)\n        result = fetch_resource(\"resource1\", \"subdir\")\n        self.assertEqual(result, self.subdir)\n        self.assertTrue(result.exists())\n    \n    def test_invalid_resource_key(self):\n        # Invalid resource key\n        with self.assertRaises(KeyError):\n            fetch_resource(\"invalid_key\", \"test.txt\")\n    \n    def test_non_existent_file(self):\n        # Non-existent file in resource1\n        with self.assertRaises(ValueError):\n            fetch_resource(\"resource1\", \"non_existent.txt\")\n    \n    def test_path_traversal_escape(self):\n        # Path traversal escaping resource directory\n        with self.assertRaises(Exception):\n            fetch_resource(\"resource1\", \"../escape.txt\")\n    \n    def test_relative_path_within_directory(self):\n        # Relative path that remains within resource\n        result = fetch_resource(\"resource1\", \"subdir/../test.txt\")\n        self.assertEqual(result, self.file1)\n        self.assertTrue(result.exists())\n    \n    def test_absolute_path(self):\n        # Absolute path not allowed\n        abs_path = str(Path.cwd() / \"test.txt\")\n        with self.assertRaises(Exception):\n            fetch_resource(\"resource1\", abs_path)\n    \n    def test_empty_resource_path(self):\n        # Empty resource_path (points to base directory)\n        result = fetch_resource(\"resource1\", \"\")\n        self.assertEqual(result, self.temp_dir1_path)\n        self.assertTrue(result.exists())\n    \n    def test_file_in_other_resource(self):\n        # Attempt to access file in resource2 via resource1 (should be blocked)\n        file_in_resource2 = \"../\" + self.temp_dir2_path.name + \"/file3.txt\"\n        with self.assertRaises(Exception):\n            fetch_resource(\"resource1\", file_in_resource2)\n    \n    def test_large_resource_path(self):\n        # Very long resource path\n        long_path = \"a\" * 1000 + \".txt\"\n        file_path = self.temp_dir1_path / long_path\n        file_path.write_text(\"content\")\n        result = fetch_resource(\"resource1\", long_path)\n        self.assertEqual(result, file_path)\n        self.assertTrue(result.exists())\n    \n    def test_resource_path_with_special_chars(self):\n        # Resource path with special characters\n        special_path = \"!@#$%^&()_+-=[]{};',.~` \".strip() + \".txt\"\n        file_path = self.temp_dir1_path / special_path\n        file_path.write_text(\"content\")\n        result = fetch_resource(\"resource1\", special_path)\n        self.assertEqual(result, file_path)\n        self.assertTrue(result.exists())\n    \n    def test_none_resource_key(self):\n        # None as resource_key\n        with self.assertRaises(KeyError):\n            fetch_resource(None, \"test.txt\")\n    \n    def test_none_resource_path(self):\n        # None as resource_path\n        with self.assertRaises(Exception):\n            fetch_resource(\"resource1\", None)\n\nif __name__ == \"__main__\":\n    unittest.main()", "num_test_cases": 14, "task_id": "6646f7fe"}
{"test": "import unittest\nfrom unittest import mock\nfrom pathlib import Path\nimport tempfile\n\nclass TestGetFile(unittest.TestCase):\n    def setUp(self):\n        # Setup temporary directories\n        self.temp_dir1 = tempfile.TemporaryDirectory()\n        self.addCleanup(self.temp_dir1.cleanup)\n        self.temp_dir2 = tempfile.TemporaryDirectory()\n        self.addCleanup(self.temp_dir2.cleanup)\n        \n        # Create test files\n        self.file1 = Path(self.temp_dir1.name) / 'test.txt'\n        self.file1.touch()\n        \n        self.nested_dir = Path(self.temp_dir1.name) / 'nested'\n        self.nested_dir.mkdir()\n        self.nested_file = self.nested_dir / 'nested_file.txt'\n        self.nested_file.touch()\n        \n        self.outside_file = Path(self.temp_dir2.name) / 'outside.txt'\n        self.outside_file.touch()\n        \n        # Patch resources in 'app' module\n        self.resources_patcher = mock.patch('app.resources', {\n            'resource1': Path(self.temp_dir1.name)\n        })\n        self.resources_patcher.start()\n        self.addCleanup(self.resources_patcher.stop)\n        \n    def test_happy_path(self):\n        # Test valid resource key and existing file\n        result = get_file('resource1', 'test.txt')\n        self.assertEqual(result, Path(self.temp_dir1.name) / 'test.txt')\n        \n    def test_nested_file(self):\n        # Test nested file within resource directory\n        result = get_file('resource1', 'nested/nested_file.txt')\n        self.assertEqual(result, self.nested_file)\n        \n    def test_key_error(self):\n        # Test invalid resource key\n        with self.assertRaises(KeyError):\n            get_file('invalid_key', 'test.txt')\n            \n    def test_file_not_found(self):\n        # Test non-existent file in valid resource\n        with self.assertRaises(ValueError):\n            get_file('resource1', 'non_existent.txt')\n            \n    def test_path_traversal_attempt(self):\n        # Test path attempting to escape resource directory\n        traversal_path = Path('..') / Path(self.temp_dir2.name).name / 'outside.txt'\n        with self.assertRaises(Exception) as context:\n            get_file('resource1', str(traversal_path))\n        self.assertIn('is not allowed', str(context.exception))\n        \n    def test_absolute_path(self):\n        # Test absolute path as file_path (should be blocked)\n        abs_path = str(Path(self.temp_dir1.name) / 'test.txt')\n        with self.assertRaises(Exception) as context:\n            get_file('resource1', abs_path)\n        self.assertIn('is not allowed', str(context.exception))\n        \n    def test_empty_file_path(self):\n        # Test empty file_path (accessing resource directory)\n        result = get_file('resource1', '')\n        self.assertEqual(result, Path(self.temp_dir1.name))\n        \n    def test_normalization_within_directory(self):\n        # Test path normalization staying within resource\n        result = get_file('resource1', 'nested/../test.txt')\n        self.assertEqual(result, self.file1)\n", "num_test_cases": 8, "task_id": "72362bf9"}
{"test": "import unittest\nimport tempfile\nimport shutil\nfrom pathlib import Path\nfrom unittest.mock import patch\n\n# Import the function under test (assuming it's defined in 'implementation' module)\nfrom implementation import retrieve_file\n\nclass TestRetrieveFile(unittest.TestCase):\n    def setUp(self):\n        # Create a temporary directory structure\n        self.test_dir = Path(tempfile.mkdtemp())\n        \n        # Create resource directories and files\n        self.resource1_dir = self.test_dir / \"resource1\"\n        self.resource1_dir.mkdir()\n        \n        # Valid file in resource1\n        self.valid_file = self.resource1_dir / \"test.txt\"\n        self.valid_file.write_text(\"Hello\")\n        \n        # Subdirectory and file in resource1\n        self.subdir = self.resource1_dir / \"sub\"\n        self.subdir.mkdir()\n        self.sub_file = self.subdir / \"file.txt\"\n        self.sub_file.write_text(\"Sub file\")\n        \n        # Resource2 directory\n        self.resource2_dir = self.test_dir / \"resource2\"\n        self.resource2_dir.mkdir()\n        \n        # Create the resources dictionary for testing\n        self.resources = {\n            \"resource1\": self.resource1_dir,\n            \"resource2\": self.resource2_dir\n        }\n    \n    def tearDown(self):\n        # Clean up temporary directory\n        shutil.rmtree(self.test_dir)\n    \n    @patch('implementation.resources', new_callable=dict)\n    def test_valid_file(self, mock_resources):\n        \"\"\"Test retrieval with valid resource_id and existing relative path.\"\"\"\n        mock_resources.update(self.resources)\n        result = retrieve_file(\"resource1\", \"test.txt\")\n        self.assertEqual(result, self.valid_file)\n    \n    @patch('implementation.resources', new_callable=dict)\n    def test_file_in_subdirectory(self, mock_resources):\n        \"\"\"Test retrieval of file in a subdirectory.\"\"\"\n        mock_resources.update(self.resources)\n        result = retrieve_file(\"resource1\", \"sub/file.txt\")\n        self.assertEqual(result, self.sub_file)\n    \n    @patch('implementation.resources', new_callable=dict)\n    def test_key_error_invalid_resource(self, mock_resources):\n        \"\"\"Test KeyError when resource_id doesn't exist.\"\"\"\n        mock_resources.update(self.resources)\n        with self.assertRaises(KeyError):\n            retrieve_file(\"invalid_resource\", \"test.txt\")\n    \n    @patch('implementation.resources', new_callable=dict)\n    def test_value_error_missing_file(self, mock_resources):\n        \"\"\"Test ValueError when file doesn't exist.\"\"\"\n        mock_resources.update(self.resources)\n        with self.assertRaises(ValueError):\n            retrieve_file(\"resource1\", \"missing.txt\")\n    \n    @patch('implementation.resources', new_callable=dict)\n    def test_path_traversal_attack(self, mock_resources):\n        \"\"\"Test security check blocks path traversal (../ escape).\"\"\"\n        mock_resources.update(self.resources)\n        with self.assertRaises(Exception) as context:\n            retrieve_file(\"resource1\", \"../../etc/passwd\")\n        self.assertIn(\"not allowed\", str(context.exception))\n    \n    @patch('implementation.resources', new_callable=dict)\n    def test_absolute_path_rejected(self, mock_resources):\n        \"\"\"Test absolute paths are rejected by security check.\"\"\"\n        mock_resources.update(self.resources)\n        abs_path = self.valid_file.resolve()\n        with self.assertRaises(Exception) as context:\n            retrieve_file(\"resource1\", str(abs_path))\n        self.assertIn(\"not allowed\", str(context.exception))\n    \n    @patch('implementation.resources', new_callable=dict)\n    def test_empty_relative_path(self, mock_resources):\n        \"\"\"Test empty rel_path results in ValueError (file doesn't exist).\"\"\"\n        mock_resources.update(self.resources)\n        with self.assertRaises(ValueError):\n            retrieve_file(\"resource1\", \"\")\n    \n    @patch('implementation.resources', new_callable=dict)\n    def test_none_relative_path(self, mock_resources):\n        \"\"\"Test TypeError when rel_path is None.\"\"\"\n        mock_resources.update(self.resources)\n        with self.assertRaises(TypeError):\n            retrieve_file(\"resource1\", None)\n\nif __name__ == \"__main__\":\n    unittest.main()", "num_test_cases": 8, "task_id": "2ef096c7"}
{"test": "import unittest\nimport tempfile\nimport shutil\nfrom pathlib import Path\n\n# Global resources dictionary needed by the function\nresources = {}\n\nclass TestDeliverFile(unittest.TestCase):\n    def setUp(self):\n        \"\"\"Set up temporary directories and global resources.\"\"\"\n        global resources\n        # Create a temporary resource directory\n        self.resource_dir = Path(tempfile.mkdtemp())\n        # Create files and subdirectories\n        self.file1 = self.resource_dir / 'file1.txt'\n        self.file1.touch()\n        self.subdir = self.resource_dir / 'subdir'\n        self.subdir.mkdir()\n        self.file2 = self.subdir / 'file2.txt'\n        self.file2.touch()\n        \n        # Create a directory outside the resource\n        self.outside_dir = Path(tempfile.mkdtemp())\n        self.outside_file = self.outside_dir / 'outside.txt'\n        self.outside_file.touch()\n        \n        # Configure global resources\n        resources = {\n            'test_resource': self.resource_dir\n        }\n    \n    def tearDown(self):\n        \"\"\"Clean up temporary directories.\"\"\"\n        shutil.rmtree(self.resource_dir)\n        shutil.rmtree(self.outside_dir)\n    \n    def test_valid_file_in_root(self):\n        \"\"\"Test retrieving a file in the resource root.\"\"\"\n        result = deliver_file('test_resource', 'file1.txt')\n        self.assertEqual(result, self.file1)\n    \n    def test_valid_file_in_subdirectory(self):\n        \"\"\"Test retrieving a file in a subdirectory.\"\"\"\n        result = deliver_file('test_resource', 'subdir/file2.txt')\n        self.assertEqual(result, self.file2)\n    \n    def test_non_existent_resource(self):\n        \"\"\"Test with a resource name not in resources (KeyError).\"\"\"\n        with self.assertRaises(KeyError):\n            deliver_file('invalid_resource', 'file1.txt')\n    \n    def test_non_existent_file(self):\n        \"\"\"Test with a valid resource but non-existent file (ValueError).\"\"\"\n        with self.assertRaises(ValueError):\n            deliver_file('test_resource', 'non_existent.txt')\n    \n    def test_path_traversal_attempt(self):\n        \"\"\"Test path traversal outside resource directory (Exception).\"\"\"\n        # Create a relative path that escapes the resource directory\n        relative_path = f'../{self.outside_dir.name}/outside.txt'\n        with self.assertRaises(Exception) as context:\n            deliver_file('test_resource', relative_path)\n        self.assertIn('is not allowed', str(context.exception))\n    \n    def test_empty_relative_path(self):\n        \"\"\"Test with empty relative path (points to directory).\"\"\"\n        # Empty path points to resource directory\n        result = deliver_file('test_resource', '')\n        self.assertEqual(result, self.resource_dir)\n    \n    def test_relative_path_as_dot(self):\n        \"\"\"Test relative path as current directory (points to directory).\"\"\"\n        # Path '.' points to resource directory\n        result = deliver_file('test_resource', '.')\n        self.assertEqual(result, self.resource_dir)\n    \n    def test_directory_instead_of_file(self):\n        \"\"\"Test accessing a directory instead of a file.\"\"\"\n        # Should return directory since it exists\n        result = deliver_file('test_resource', 'subdir')\n        self.assertEqual(result, self.subdir)\n    \n    def test_none_resource_name(self):\n        \"\"\"Test resource_name as None (KeyError).\"\"\"\n        with self.assertRaises(KeyError):\n            deliver_file(None, 'file1.txt')\n    \n    def test_none_relative_path(self):\n        \"\"\"Test relative_path as None (Exception).\"\"\"\n        with self.assertRaises(Exception) as context:\n            deliver_file('test_resource', None)\n        self.assertIn('not allowed', str(context.exception).lower())", "num_test_cases": 10, "task_id": "841936cc"}
{"test": "import unittest\nimport tempfile\nfrom pathlib import Path\n\n# Define the function as provided\ndef fetch_file(directory_key: str, file_path: str) -> Path:\n    if directory_key in resources:\n        dir_path = resources[directory_key]\n        target_path = dir_path / file_path\n        try:\n            target_path.resolve().relative_to(dir_path.resolve())\n        except ValueError:\n            raise Exception(f\"Path {file_path} is not allowed\")\n        if not target_path.exists():\n            raise ValueError(f\"File {target_path} is not existed\")\n        return target_path\n    else:\n        raise KeyError(f\"Resource {directory_key} not found\")\n\nclass TestFetchFile(unittest.TestCase):\n    resources_backup = None\n\n    @classmethod\n    def setUpClass(cls):\n        # Create a temporary directory and resource structure\n        cls.temp_dir = tempfile.TemporaryDirectory()\n        cls.base_path = Path(cls.temp_dir.name)\n        cls.resource_dir = cls.base_path / \"resource1\"\n        cls.resource_dir.mkdir()\n        \n        # Create a file in the resource directory\n        cls.file1 = cls.resource_dir / \"file1.txt\"\n        cls.file1.touch()\n        \n        # Create a subdirectory with a file\n        cls.subdir = cls.resource_dir / \"subdir\"\n        cls.subdir.mkdir()\n        cls.file2 = cls.subdir / \"file2.txt\"\n        cls.file2.touch()\n        \n        # Create an empty directory\n        cls.empty_dir = cls.resource_dir / \"empty_dir\"\n        cls.empty_dir.mkdir()\n        \n        # Backup the current global resources (if any) and set our resource\n        global resources\n        if 'resources' in globals():\n            cls.resources_backup = globals().get('resources')\n        resources = {'resource1': cls.resource_dir}\n\n    @classmethod\n    def tearDownClass(cls):\n        cls.temp_dir.cleanup()\n        global resources\n        if cls.resources_backup is not None:\n            resources = cls.resources_backup\n        else:\n            # If there was no backup, remove the global variable we created\n            if 'resources' in globals():\n                del globals()['resources']\n\n    def test_valid_file(self):\n        # Test fetching a valid file in the resource directory\n        result = fetch_file('resource1', 'file1.txt')\n        self.assertEqual(result, self.file1)\n        self.assertTrue(result.exists())\n\n    def test_valid_file_in_subdir(self):\n        # Test fetching a valid file in a subdirectory\n        result = fetch_file('resource1', 'subdir/file2.txt')\n        self.assertEqual(result, self.file2)\n        self.assertTrue(result.exists())\n\n    def test_key_not_found(self):\n        # Test with a non-existent resource key\n        with self.assertRaises(KeyError):\n            fetch_file('invalid_key', 'file1.txt')\n\n    def test_file_not_found(self):\n        # Test with a non-existent file\n        with self.assertRaises(ValueError):\n            fetch_file('resource1', 'non_existent.txt')\n\n    def test_path_traversal_parent(self):\n        # Test path traversal using '..'\n        with self.assertRaises(Exception) as context:\n            fetch_file('resource1', '../file1.txt')\n        self.assertIn(\"is not allowed\", str(context.exception))\n\n    def test_absolute_path_outside(self):\n        # Test with an absolute path outside the resource directory\n        root_path = Path.cwd().root\n        outside_file = root_path / \"outside.txt\"\n        with self.assertRaises(Exception) as context:\n            fetch_file('resource1', str(outside_file))\n        self.assertIn(\"is not allowed\", str(context.exception))\n\n    def test_complex_path_traversal(self):\n        # Test complex path traversal\n        with self.assertRaises(Exception) as context:\n            fetch_file('resource1', 'subdir/../../file1.txt')\n        self.assertIn(\"is not allowed\", str(context.exception))\n\n    def test_empty_file_path(self):\n        # Test with empty file path (should return the resource directory)\n        result = fetch_file('resource1', '')\n        self.assertEqual(result, self.resource_dir)\n        self.assertTrue(result.exists())\n\n    def test_directory_instead_of_file(self):\n        # Test with a directory path instead of a file\n        result = fetch_file('resource1', 'subdir')\n        self.assertEqual(result, self.subdir)\n        self.assertTrue(result.exists())\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 9, "task_id": "8fb62703"}
{"test": "import unittest\nfrom pathlib import Path\nimport tempfile\nimport shutil\n\n# Define the function and global resources for a self-contained test\nresources = {}\n\ndef retrieve_file(identifier: str, resource_path: str) -> Path:\n    if identifier in resources:\n        base_path = resources[identifier]\n        requested_file = base_path / resource_path\n        try:\n            requested_file.resolve().relative_to(base_path.resolve())\n        except ValueError:\n            raise Exception(f\"Path {resource_path} is not allowed\")\n        if not requested_file.exists():\n            raise ValueError(f\"File {requested_file} is not existed\")\n        return requested_file\n    else:\n        raise KeyError(f\"Resource {identifier} not found\")\n\nclass TestRetrieveFile(unittest.TestCase):\n    def setUp(self):\n        # Create a temporary directory for the resource\n        self.temp_dir = tempfile.TemporaryDirectory()\n        self.resource_path = Path(self.temp_dir.name)\n        # Create files and subdirectories\n        (self.resource_path / 'file1.txt').write_text('content')\n        self.subdir = self.resource_path / 'subdir'\n        self.subdir.mkdir()\n        (self.subdir / 'file2.txt').write_text('content')\n        \n        # Create a file outside the resource directory\n        self.outside_dir = tempfile.TemporaryDirectory()\n        self.outside_file = Path(self.outside_dir.name) / 'outside.txt'\n        self.outside_file.write_text('outside')\n        \n        # Set the global resources dictionary\n        global resources\n        resources = {'test_resource': self.resource_path}\n    \n    def tearDown(self):\n        # Clean up temporary directories\n        self.temp_dir.cleanup()\n        self.outside_dir.cleanup()\n\n    def test_valid_file_root(self):\n        # Test valid file in resource root\n        result = retrieve_file('test_resource', 'file1.txt')\n        self.assertEqual(result, self.resource_path / 'file1.txt')\n        self.assertTrue(result.exists())\n\n    def test_valid_file_subdir(self):\n        # Test valid file in subdirectory\n        result = retrieve_file('test_resource', 'subdir/file2.txt')\n        self.assertEqual(result, self.resource_path / 'subdir' / 'file2.txt')\n        self.assertTrue(result.exists())\n\n    def test_key_error(self):\n        # Test invalid identifier (KeyError)\n        with self.assertRaises(KeyError):\n            retrieve_file('invalid_id', 'file1.txt')\n\n    def test_value_error_nonexistent_file(self):\n        # Test non-existent file (ValueError)\n        with self.assertRaises(ValueError):\n            retrieve_file('test_resource', 'non_existent.txt')\n\n    def test_path_escape_relative(self):\n        # Test escaping with relative path (Exception)\n        with self.assertRaises(Exception) as context:\n            retrieve_file('test_resource', '../outside.txt')\n        self.assertIn('is not allowed', str(context.exception))\n\n    def test_path_escape_absolute(self):\n        # Test escaping with absolute path (Exception)\n        abs_path = self.outside_file.resolve()\n        with self.assertRaises(Exception) as context:\n            retrieve_file('test_resource', str(abs_path))\n        self.assertIn('is not allowed', str(context.exception))\n\n    def test_directory_path(self):\n        # Test existing directory path\n        result = retrieve_file('test_resource', 'subdir')\n        self.assertEqual(result, self.resource_path / 'subdir')\n        self.assertTrue(result.exists())\n\n    def test_empty_resource_path(self):\n        # Test empty resource_path returns base directory\n        result = retrieve_file('test_resource', '')\n        self.assertEqual(result, self.resource_path)\n        self.assertTrue(result.exists())\n\n    def test_dot_in_path(self):\n        # Test path with './' prefix\n        result = retrieve_file('test_resource', './file1.txt')\n        self.assertEqual(result, self.resource_path / 'file1.txt')\n        self.assertTrue(result.exists())\n\n    def test_non_string_identifier(self):\n        # Test non-string identifier (KeyError)\n        with self.assertRaises(KeyError):\n            retrieve_file(123, 'file1.txt')\n\n    def test_non_string_resource_path(self):\n        # Test non-string resource_path (TypeError)\n        with self.assertRaises(TypeError):\n            retrieve_file('test_resource', 123)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 11, "task_id": "d3c076a0"}
{"test": "import unittest\nfrom pathlib import Path\nimport tempfile\nimport os\n\n# Global variable as used in the function\nresources = {}\n\ndef retrieve_file(resource_id: str, file_path: str) -> Path:\n    if resource_id in resources:\n        resource_dir = resources[resource_id]\n        full_file_path = resource_dir / file_path\n        try:\n            full_file_path.resolve().relative_to(resource_dir.resolve())\n        except ValueError:\n            raise Exception(f\"Path {file_path} is not allowed\")\n        if not full_file_path.exists():\n            raise ValueError(f\"File {full_file_path} is not existed\")\n        return full_file_path\n    else:\n        raise KeyError(f\"Resource {resource_id} not found\")\n\nclass TestRetrieveFile(unittest.TestCase):\n    def setUp(self):\n        # Create a temporary directory\n        self.test_dir = tempfile.TemporaryDirectory()\n        self.test_dir_path = Path(self.test_dir.name)\n        \n        # Create resource directories and files\n        self.resource_dir = self.test_dir_path / \"resource\"\n        self.resource_dir.mkdir()\n        (self.resource_dir / \"test.txt\").write_text(\"Hello\")\n        (self.resource_dir / \"spa ce.txt\").write_text(\"Space\")\n        (self.resource_dir / \"éà.txt\").write_text(\"Special\")\n        \n        self.sub_dir = self.resource_dir / \"sub\"\n        self.sub_dir.mkdir()\n        (self.sub_dir / \"file.txt\").write_text(\"Subfile\")\n        \n        self.another_dir = self.test_dir_path / \"another\"\n        self.another_dir.mkdir()\n        (self.another_dir / \"another.txt\").write_text(\"Another\")\n        \n        # Create a file outside the resource directory\n        self.outside_file = self.test_dir_path / \"outside.txt\"\n        self.outside_file.write_text(\"Outside\")\n        \n        # Set up the resources dictionary\n        self.resources_dict = {\n            \"test_resource\": self.resource_dir,\n            \"another_resource\": self.another_dir,\n            \"empty_resource\": self.resource_dir  # Same as test_resource for empty file_path test\n        }\n        \n        # Set the global 'resources' to our test dictionary\n        global resources\n        self.old_resources = resources\n        resources = self.resources_dict\n\n    def tearDown(self):\n        # Clean up the temporary directory\n        self.test_dir.cleanup()\n        # Restore the global 'resources'\n        global resources\n        resources = self.old_resources\n\n    def test_valid_file(self):\n        # Test with existing resource and file\n        result = retrieve_file(\"test_resource\", \"test.txt\")\n        expected = self.resource_dir / \"test.txt\"\n        self.assertEqual(result, expected.resolve())\n        self.assertTrue(result.exists())\n    \n    def test_resource_id_not_found(self):\n        # Test with non-existent resource_id\n        with self.assertRaises(KeyError):\n            retrieve_file(\"missing_resource\", \"test.txt\")\n    \n    def test_file_does_not_exist(self):\n        # Test with existent resource_id but non-existent file\n        with self.assertRaises(ValueError):\n            retrieve_file(\"test_resource\", \"missing.txt\")\n    \n    def test_path_traversal_attempt(self):\n        # Test with file_path trying to escape resource directory\n        with self.assertRaises(Exception) as cm:\n            retrieve_file(\"test_resource\", \"../outside.txt\")\n        self.assertIn(\"is not allowed\", str(cm.exception))\n    \n    def test_empty_file_path(self):\n        # Test with empty file_path (should return the resource directory)\n        result = retrieve_file(\"test_resource\", \"\")\n        self.assertEqual(result, self.resource_dir)\n        self.assertTrue(result.exists())\n    \n    def test_file_in_subdirectory(self):\n        # Test file in a subdirectory\n        result = retrieve_file(\"test_resource\", \"sub/file.txt\")\n        expected = self.sub_dir / \"file.txt\"\n        self.assertEqual(result, expected.resolve())\n        self.assertTrue(result.exists())\n    \n    def test_path_with_dot(self):\n        # Test file_path with current directory (./)\n        result = retrieve_file(\"test_resource\", \"./test.txt\")\n        expected = self.resource_dir / \"test.txt\"\n        self.assertEqual(result, expected.resolve())\n    \n    def test_path_with_dot_dot_inside(self):\n        # Test file_path with .. but staying within resource\n        result = retrieve_file(\"test_resource\", \"sub/../test.txt\")\n        expected = self.resource_dir / \"test.txt\"\n        self.assertEqual(result, expected.resolve())\n    \n    def test_resource_id_none(self):\n        # Test resource_id as None\n        with self.assertRaises(KeyError):\n            retrieve_file(None, \"test.txt\")\n    \n    def test_file_path_none(self):\n        # Test file_path as None (expects a TypeError from Path operation)\n        with self.assertRaises(TypeError):\n            retrieve_file(\"test_resource\", None)\n    \n    def test_empty_resource_id(self):\n        # Test empty resource_id\n        with self.assertRaises(KeyError):\n            retrieve_file(\"\", \"test.txt\")\n    \n    def test_absolute_file_path(self):\n        # Test with absolute file_path (should escape and be disallowed)\n        abs_path = os.path.abspath(str(self.outside_file))\n        with self.assertRaises(Exception) as cm:\n            retrieve_file(\"test_resource\", abs_path)\n        self.assertIn(\"is not allowed\", str(cm.exception))\n    \n    def test_special_characters(self):\n        # Test file_path with special characters\n        result = retrieve_file(\"test_resource\", \"spa ce.txt\")\n        expected = self.resource_dir / \"spa ce.txt\"\n        self.assertEqual(result, expected.resolve())\n        \n        result = retrieve_file(\"test_resource\", \"éà.txt\")\n        expected = self.resource_dir / \"éà.txt\"\n        self.assertEqual(result, expected.resolve())\n    \n    def test_directory_path(self):\n        # Test file_path pointing to a directory\n        result = retrieve_file(\"test_resource\", \"sub\")\n        self.assertEqual(result, self.sub_dir)\n        self.assertTrue(result.exists())\n    \n    def test_another_resource(self):\n        # Test with a different resource\n        result = retrieve_file(\"another_resource\", \"another.txt\")\n        expected = self.another_dir / \"another.txt\"\n        self.assertEqual(result, expected.resolve())\n        self.assertTrue(result.exists())\n        \n        # Test traversal from another_resource to resource\n        with self.assertRaises(Exception):\n            retrieve_file(\"another_resource\", \"../resource/test.txt\")\n", "num_test_cases": 15, "task_id": "8b4b7b0d"}
{"test": "import unittest\nimport tempfile\nfrom pathlib import Path\n\n# Global resources dictionary\nresources = {}\n\n# Define the function under test\ndef get_file(identifier: str, relative_path: str) -> Path:\n    if identifier in resources:\n        base_directory = resources[identifier]\n        potential_path = base_directory / relative_path\n        try:\n            potential_path.resolve().relative_to(base_directory.resolve())\n        except ValueError:\n            raise Exception(f\"Path {relative_path} is not allowed\")\n        if not potential_path.exists():\n            raise ValueError(f\"File {potential_path} is not existed\")\n        return potential_path\n    else:\n        raise KeyError(f\"Resource {identifier} not found\")\n\nclass TestGetFile(unittest.TestCase):\n    def setUp(self):\n        # Create a temporary directory and file structure\n        self.test_dir = tempfile.TemporaryDirectory()\n        self.temp_path = Path(self.test_dir.name)\n        \n        # Resource1 directory structure\n        self.res1 = self.temp_path / 'resource1'\n        self.res1.mkdir()\n        (self.res1 / 'file1.txt').touch()\n        self.subdir = self.res1 / 'subdir'\n        self.subdir.mkdir()\n        (self.subdir / 'file2.txt').touch()\n        \n        # Resource2 directory structure\n        self.res2 = self.temp_path / 'resource2'\n        self.res2.mkdir()\n        (self.res2 / 'file3.txt').touch()\n        \n        # Outside file\n        (self.temp_path / 'outside.txt').touch()\n        \n        # Set global resources\n        global resources\n        resources = {\n            'res1': self.res1,\n            'res2': self.res2\n        }\n    \n    def tearDown(self):\n        # Clean up temporary directory\n        self.test_dir.cleanup()\n    \n    def test_happy_path_file1(self):\n        # Test existing file in resource1 root\n        result = get_file('res1', 'file1.txt')\n        self.assertEqual(result, self.res1 / 'file1.txt')\n        self.assertTrue(result.exists())\n    \n    def test_happy_path_file2(self):\n        # Test existing file in resource1 subdirectory\n        result = get_file('res1', 'subdir/file2.txt')\n        self.assertEqual(result, self.subdir / 'file2.txt')\n        self.assertTrue(result.exists())\n    \n    def test_happy_path_file3(self):\n        # Test existing file in resource2\n        result = get_file('res2', 'file3.txt')\n        self.assertEqual(result, self.res2 / 'file3.txt')\n        self.assertTrue(result.exists())\n    \n    def test_nonexistent_identifier(self):\n        # Test non-existent resource identifier\n        with self.assertRaises(KeyError) as context:\n            get_file('res3', 'file1.txt')\n        self.assertEqual(str(context.exception), \"'Resource res3 not found'\")\n    \n    def test_nonexistent_file(self):\n        # Test non-existent file within valid resource\n        with self.assertRaises(ValueError) as context:\n            get_file('res1', 'nonexistent.txt')\n        self.assertIn(\"is not existed\", str(context.exception))\n    \n    def test_directory_traversal_simple(self):\n        # Test simple path traversal (../)\n        with self.assertRaises(Exception) as context:\n            get_file('res1', '../outside.txt')\n        self.assertEqual(str(context.exception), \"Path ../outside.txt is not allowed\")\n    \n    def test_directory_traversal_complex(self):\n        # Test nested path traversal (subdir/../../)\n        with self.assertRaises(Exception) as context:\n            get_file('res1', 'subdir/../../outside.txt')\n        self.assertEqual(str(context.exception), \"Path subdir/../../outside.txt is not allowed\")\n    \n    def test_absolute_path(self):\n        # Test absolute path as relative_path\n        abs_path = str(self.temp_path / 'outside.txt')\n        with self.assertRaises(Exception) as context:\n            get_file('res1', abs_path)\n        self.assertEqual(str(context.exception), f\"Path {abs_path} is not allowed\")\n    \n    def test_empty_relative_path(self):\n        # Test empty relative_path (points to resource directory)\n        result = get_file('res1', '')\n        self.assertEqual(result, self.res1)\n        self.assertTrue(result.exists())\n    \n    def test_dot_relative_path(self):\n        # Test '.' as relative_path (points to resource directory)\n        result = get_file('res1', '.')\n        self.assertEqual(result, self.res1)\n        self.assertTrue(result.exists())\n    \n    def test_normalization_within_resource(self):\n        # Test path normalization within resource (subdir/../file1.txt)\n        result = get_file('res1', 'subdir/../file1.txt')\n        self.assertEqual(result, self.res1 / 'file1.txt')\n        self.assertTrue(result.exists())\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 11, "task_id": "518c775c"}
{"test": "import unittest\nimport tempfile\nfrom pathlib import Path\n\n# Define the function to be tested\ndef load_file(tag: str, file_name: str) -> Path:\n    if tag in resources:\n        directory_path = resources[tag]\n        target_path = directory_path / file_name\n        try:\n            target_path.resolve().relative_to(directory_path.resolve())\n        except ValueError:\n            raise Exception(f\"Path {file_name} is not allowed\")\n        if not target_path.exists():\n            raise ValueError(f\"File {target_path} is not existed\")\n        return target_path\n    else:\n        raise KeyError(f\"Resource {tag} not found\")\n\nclass TestLoadFile(unittest.TestCase):\n    @classmethod\n    def setUpClass(cls):\n        # Create a temporary directory structure\n        cls.temp_dir = tempfile.TemporaryDirectory()\n        cls.temp_path = Path(cls.temp_dir.name)\n        \n        # Set up resource directories and files\n        res1 = cls.temp_path / 'res1'\n        res1.mkdir()\n        (res1 / 'file1.txt').write_text(\"Content\")\n        (res1 / 'subdir').mkdir()\n        (res1 / 'subdir' / 'file2.txt').write_text(\"Content\")\n        (res1 / 'empty_subdir').mkdir()\n        \n        res2 = cls.temp_path / 'res2'\n        res2.mkdir()\n        (res2 / 'file3.txt').write_text(\"Content\")\n        \n        # Set the global resources dictionary\n        global resources\n        resources = {\n            'res1': res1,\n            'res2': res2\n        }\n    \n    @classmethod\n    def tearDownClass(cls):\n        # Clean up the temporary directory\n        cls.temp_dir.cleanup()\n    \n    def test_valid_file_in_root(self):\n        # Test loading a file in the root of a resource directory\n        result = load_file('res1', 'file1.txt')\n        expected = resources['res1'] / 'file1.txt'\n        self.assertEqual(result, expected)\n    \n    def test_valid_file_in_subdirectory(self):\n        # Test loading a file in a subdirectory\n        result = load_file('res1', 'subdir/file2.txt')\n        expected = resources['res1'] / 'subdir' / 'file2.txt'\n        self.assertEqual(result, expected)\n    \n    def test_valid_directory_resource(self):\n        # Test loading a resource directory itself (empty file_name)\n        result = load_file('res1', '')\n        expected = resources['res1']\n        self.assertEqual(result, expected)\n    \n    def test_valid_subdirectory_resource(self):\n        # Test loading a subdirectory within a resource\n        result = load_file('res1', 'empty_subdir')\n        expected = resources['res1'] / 'empty_subdir'\n        self.assertEqual(result, expected)\n    \n    def test_missing_tag(self):\n        # Test with a non-existent resource tag\n        with self.assertRaises(KeyError):\n            load_file('res3', 'file1.txt')\n    \n    def test_missing_file(self):\n        # Test with a non-existent file in a valid resource\n        with self.assertRaises(ValueError):\n            load_file('res1', 'non_existent.txt')\n    \n    def test_path_traversal_escape(self):\n        # Test path traversal outside resource directory\n        with self.assertRaises(Exception):\n            load_file('res1', '../res2/file3.txt')\n    \n    def test_normalized_safe_path(self):\n        # Test path with '..' that stays within resource after normalization\n        result = load_file('res1', 'subdir/../file1.txt')\n        expected = resources['res1'] / 'subdir/../file1.txt'\n        self.assertEqual(result, expected)\n    \n    def test_absolute_path_escape(self):\n        # Test with absolute path that escapes resource directory\n        abs_path = str(Path.home() / 'file.txt')\n        with self.assertRaises(Exception):\n            load_file('res1', abs_path)\n    \n    def test_empty_tag(self):\n        # Test with empty tag string\n        with self.assertRaises(KeyError):\n            load_file('', 'file1.txt')\n    \n    def test_empty_file_name_in_missing_resource(self):\n        # Test empty file_name with a non-existent tag\n        with self.assertRaises(KeyError):\n            load_file('res3', '')\n    \n    def test_file_name_none(self):\n        # Test None as file_name\n        with self.assertRaises(Exception):\n            load_file('res1', None)\n    \n    def test_tag_none(self):\n        # Test None as tag\n        with self.assertRaises(KeyError):\n            load_file(None, 'file1.txt')\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 13, "task_id": "f17fea34"}
{"test": "import unittest\nimport tempfile\nfrom pathlib import Path\nfrom unittest.mock import patch\n\nclass TestFetchUserData(unittest.TestCase):\n    def setUp(self):\n        # Create a temporary directory with test structure\n        self.temp_dir = tempfile.TemporaryDirectory()\n        self.temp_path = Path(self.temp_dir.name)\n        \n        # Create user directories and files\n        self.user1_dir = self.temp_path / 'user1'\n        self.user1_dir.mkdir()\n        self.user1_file = self.user1_dir / 'file1.txt'\n        self.user1_file.touch()\n        \n        self.subdir = self.user1_dir / 'subdir'\n        self.subdir.mkdir()\n        self.sub_file = self.subdir / 'subfile.txt'\n        self.sub_file.touch()\n        \n        self.user2_dir = self.temp_path / 'user2'\n        self.user2_dir.mkdir()\n        self.user2_file = self.user2_dir / 'file2.txt'\n        self.user2_file.touch()\n        \n        # Setup test user_directories mapping\n        self.test_user_directories = {\n            'user1': self.user1_dir,\n            'user2': self.user2_dir\n        }\n    \n    def tearDown(self):\n        # Clean up temporary directory\n        self.temp_dir.cleanup()\n    \n    def test_valid_user_and_file(self):\n        # Test fetching existing file in user directory\n        with patch('user_service.user_directories', self.test_user_directories):\n            result = fetch_user_data('user1', 'file1.txt')\n            self.assertEqual(result, self.user1_file)\n    \n    def test_valid_user_and_subdir_file(self):\n        # Test fetching file in subdirectory\n        with patch('user_service.user_directories', self.test_user_directories):\n            result = fetch_user_data('user1', 'subdir/subfile.txt')\n            self.assertEqual(result, self.sub_file)\n    \n    def test_user_not_found(self):\n        # Test with non-existent user ID\n        with patch('user_service.user_directories', self.test_user_directories):\n            with self.assertRaises(KeyError):\n                fetch_user_data('user3', 'file1.txt')\n    \n    def test_file_not_found(self):\n        # Test with non-existent file path\n        with patch('user_service.user_directories', self.test_user_directories):\n            with self.assertRaises(FileNotFoundError):\n                fetch_user_data('user1', 'nonexistent.txt')\n    \n    def test_relative_path_escape(self):\n        # Test relative path escaping user directory\n        with patch('user_service.user_directories', self.test_user_directories):\n            with self.assertRaises(Exception) as context:\n                fetch_user_data('user1', '../user2/file2.txt')\n            self.assertIn('Access to path', str(context.exception))\n    \n    def test_absolute_path_escape(self):\n        # Test absolute path outside user directory\n        with patch('user_service.user_directories', self.test_user_directories):\n            abs_path = self.user2_file.resolve()\n            with self.assertRaises(Exception) as context:\n                fetch_user_data('user1', str(abs_path))\n            self.assertIn('Access to path', str(context.exception))\n    \n    def test_empty_path(self):\n        # Test empty path returning user directory\n        with patch('user_service.user_directories', self.test_user_directories):\n            result = fetch_user_data('user1', '')\n            self.assertEqual(result, self.user1_dir)\n    \n    def test_dot_path(self):\n        # Test '.' path returning user directory\n        with patch('user_service.user_directories', self.test_user_directories):\n            result = fetch_user_data('user1', '.')\n            self.assertEqual(result, self.user1_dir)\n    \n    def test_path_with_dot_components(self):\n        # Test path with './' prefix\n        with patch('user_service.user_directories', self.test_user_directories):\n            result = fetch_user_data('user1', './file1.txt')\n            self.assertEqual(result, self.user1_file)\n    \n    def test_valid_dot_dot_path(self):\n        # Test valid path with '..' within user directory\n        with patch('user_service.user_directories', self.test_user_directories):\n            result = fetch_user_data('user1', 'subdir/../file1.txt')\n            self.assertEqual(result, self.user1_file)\n    \n    def test_invalid_dot_dot_escape(self):\n        # Test path with '..' escaping user directory\n        with patch('user_service.user_directories', self.test_user_directories):\n            with self.assertRaises(Exception) as context:\n                fetch_user_data('user1', 'subdir/../../file1.txt')\n            self.assertIn('Access to path', str(context.exception))\n    \n    def test_nonexistent_user_directory(self):\n        # Test when user directory doesn't exist\n        self.test_user_directories['user3'] = self.temp_path / 'nonexistent_dir'\n        with patch('user_service.user_directories', self.test_user_directories):\n            with self.assertRaises(FileNotFoundError):\n                fetch_user_data('user3', 'anyfile.txt')\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 12, "task_id": "67b6da9d"}
{"test": "import unittest\nfrom unittest.mock import patch, Mock\nfrom pathlib import Path\nimport tempfile\nimport solution\n\nclass TestCases(unittest.TestCase):\n    \n    def test_case_1(self):\n        # Test KeyError when username is not found in users dictionary\n        with patch('solution.users', {}):\n            with self.assertRaises(KeyError):\n                solution.read_user_file('unknown_user', 'file.txt')\n    \n    def test_case_2(self):\n        # Test security check failure when file path is outside user directory\n        mock_user_dir = Mock()\n        mock_full_path = Mock()\n        mock_user_dir.__truediv__.return_value = mock_full_path\n        mock_user_dir.resolve.return_value = Path('/safe/path/user_dir')\n        mock_full_path.resolve.return_value = Path('/unsafe/path')\n        mock_full_path.resolve.return_value.relative_to.side_effect = ValueError\n        \n        with patch('solution.users', {'test_user': mock_user_dir}):\n            with self.assertRaises(Exception) as context:\n                solution.read_user_file('test_user', '../outside.txt')\n            self.assertIn('Access to path', str(context.exception))\n    \n    def test_case_3(self):\n        # Test ValueError when file does not exist\n        mock_user_dir = Mock()\n        mock_full_path = Mock()\n        mock_user_dir.__truediv__.return_value = mock_full_path\n        mock_full_path.exists.return_value = False\n        \n        with patch('solution.users', {'test_user': mock_user_dir}):\n            with self.assertRaises(ValueError) as context:\n                solution.read_user_file('test_user', 'nonexistent.txt')\n            self.assertIn('does not exist', str(context.exception))\n    \n    def test_case_4(self):\n        # Test happy path with simple content\n        with tempfile.TemporaryDirectory() as base_dir:\n            user_dir = Path(base_dir) / 'test_user'\n            user_dir.mkdir()\n            file_path = user_dir / 'test.txt'\n            file_path.write_text('Hello, World!')\n            \n            with patch('solution.users', {'test_user': user_dir}):\n                result = solution.read_user_file('test_user', 'test.txt')\n                self.assertEqual(result, 'Hello, World!')\n    \n    def test_case_5(self):\n        # Test reading an empty file\n        with tempfile.TemporaryDirectory() as base_dir:\n            user_dir = Path(base_dir) / 'test_user'\n            user_dir.mkdir()\n            file_path = user_dir / 'empty.txt'\n            file_path.touch()\n            \n            with patch('solution.users', {'test_user': user_dir}):\n                result = solution.read_user_file('test_user', 'empty.txt')\n                self.assertEqual(result, '')\n    \n    def test_case_6(self):\n        # Test reading non-ASCII content\n        with tempfile.TemporaryDirectory() as base_dir:\n            user_dir = Path(base_dir) / 'test_user'\n            user_dir.mkdir()\n            file_path = user_dir / 'file.txt'\n            content = 'r\\xe9sum\\xe9'  # 'résumé'\n            file_path.write_text(content, encoding='utf-8')\n            \n            with patch('solution.users', {'test_user': user_dir}):\n                result = solution.read_user_file('test_user', 'file.txt')\n                self.assertEqual(result, content)\n    \n    def test_case_7(self):\n        # Test reading multi-line content\n        with tempfile.TemporaryDirectory() as base_dir:\n            user_dir = Path(base_dir) / 'test_user'\n            user_dir.mkdir()\n            file_path = user_dir / 'multiline.txt'\n            content = 'Line 1\\nLine 2\\nLine 3'\n            file_path.write_text(content)\n            \n            with patch('solution.users', {'test_user': user_dir}):\n                result = solution.read_user_file('test_user', 'multiline.txt')\n                self.assertEqual(result, content)\n", "num_test_cases": 7, "task_id": "2cf4a9cf"}
{"test": "import unittest\nimport tempfile\nfrom pathlib import Path\nfrom unittest.mock import patch\n\ntry:\n    import document_retrieval\n    from document_retrieval import retrieve_document\nexcept ImportError:\n    document_retrieval = object()\n    def retrieve_document(doc_path):\n        pass\n\nclass TestRetrieveDocument(unittest.TestCase):\n    def setUp(self):\n        self.temp_dir = tempfile.TemporaryDirectory()\n        self.temp_path = Path(self.temp_dir.name)\n        self.patcher = patch('document_retrieval.base_dir', self.temp_path)\n        self.patcher.start()\n        \n    def tearDown(self):\n        self.temp_dir.cleanup()\n        self.patcher.stop()\n    \n    def test_happy_path_file_in_root(self):\n        # Test retrieving a file in the root directory\n        file_path = self.temp_path / 'test.txt'\n        file_path.touch()\n        result = retrieve_document('test.txt')\n        self.assertEqual(result, file_path)\n    \n    def test_happy_path_file_in_subdir(self):\n        # Test retrieving a file in a subdirectory\n        subdir = self.temp_path / 'subdir'\n        subdir.mkdir()\n        file_path = subdir / 'file.txt'\n        file_path.touch()\n        result = retrieve_document('subdir/file.txt')\n        self.assertEqual(result, file_path)\n    \n    def test_retrieve_directory(self):\n        # Test retrieving a directory (should succeed)\n        dir_path = self.temp_path / 'mydir'\n        dir_path.mkdir()\n        result = retrieve_document('mydir')\n        self.assertEqual(result, dir_path)\n    \n    def test_empty_path(self):\n        # Test with empty path (resolves to base_dir)\n        result = retrieve_document('')\n        self.assertEqual(result, self.temp_path)\n    \n    def test_file_not_found(self):\n        # Test non-existent file\n        with self.assertRaises(FileNotFoundError):\n            retrieve_document('nonexistent.txt')\n    \n    def test_path_outside_base_dir(self):\n        # Test path escaping base_dir with '..'\n        with self.assertRaises(ValueError):\n            retrieve_document('../external.txt')\n    \n    def test_normalized_path_within_base_dir(self):\n        # Test path with '..' that stays within base_dir\n        file_path = self.temp_path / 'test.txt'\n        file_path.touch()\n        result = retrieve_document('subdir/../test.txt')\n        self.assertEqual(result, file_path)\n    \n    def test_none_path(self):\n        # Test None as doc_path\n        with self.assertRaises(TypeError):\n            retrieve_document(None)\n    \n    def test_absolute_path(self):\n        # Test absolute path input\n        abs_path = '/absolute/path'\n        with self.assertRaises(ValueError):\n            retrieve_document(abs_path)\n    \n    def test_leading_slash_path(self):\n        # Test path with leading slash\n        with self.assertRaises(ValueError):\n            retrieve_document('/file.txt')\n    \n    def test_very_long_path(self):\n        # Test very long valid path\n        long_name = 'a' * 200\n        file_path = self.temp_path / long_name\n        file_path.touch()\n        result = retrieve_document(long_name)\n        self.assertEqual(result, file_path)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 11, "task_id": "2d73c9f0"}
{"test": "import unittest\nimport tempfile\nfrom pathlib import Path\n\n# Import the function from its module (replace 'file_utils' with actual module name)\nimport file_utils\nfrom file_utils import download_file\n\nclass TestDownloadFile(unittest.TestCase):\n\n    def setUp(self):\n        # Create a temporary download directory and set it in the module\n        self.test_dir = tempfile.TemporaryDirectory()\n        self.download_dir_path = Path(self.test_dir.name)\n        file_utils.download_dir = self.download_dir_path\n\n    def tearDown(self):\n        # Clean up temporary directory\n        self.test_dir.cleanup()\n\n    def test_existing_file(self):\n        # Test existing file in root directory\n        file_name = \"test_file.txt\"\n        file_path = self.download_dir_path / file_name\n        file_path.touch()\n        result = download_file(file_name)\n        self.assertEqual(result, file_path)\n\n    def test_non_existing_file(self):\n        # Test non-existing file\n        with self.assertRaises(FileNotFoundError):\n            download_file(\"non_existent.txt\")\n\n    def test_path_traversal(self):\n        # Test path traversal attempt (../)\n        with self.assertRaises(PermissionError):\n            download_file(\"../outside.txt\")\n\n    def test_absolute_path(self):\n        # Test absolute path outside download directory\n        with tempfile.TemporaryDirectory() as outside_temp:\n            outside_file = Path(outside_temp) / \"outside.txt\"\n            outside_file.touch()\n            with self.assertRaises(PermissionError):\n                download_file(str(outside_file.absolute()))\n\n    def test_empty_string(self):\n        # Test empty filename\n        result = download_file(\"\")\n        self.assertEqual(result, self.download_dir_path)\n\n    def test_file_in_subdirectory(self):\n        # Test file in subdirectory\n        subdir = self.download_dir_path / \"sub\"\n        subdir.mkdir()\n        file_name = \"sub/test.txt\"\n        file_path = subdir / \"test.txt\"\n        file_path.touch()\n        result = download_file(file_name)\n        self.assertEqual(result, file_path)\n\n    def test_non_existing_in_subdirectory(self):\n        # Test non-existing file in subdirectory\n        subdir = self.download_dir_path / \"sub\"\n        subdir.mkdir()\n        with self.assertRaises(FileNotFoundError):\n            download_file(\"sub/nonexistent.txt\")\n\n    def test_special_characters(self):\n        # Test filename with special characters\n        file_name = \"file!@#$%^&()_+-=[]{};',.~` \"\n        file_path = self.download_dir_path / file_name\n        file_path.touch()\n        result = download_file(file_name)\n        self.assertEqual(result, file_path)\n\n    def test_dot_filename(self):\n        # Test '.' as filename\n        result = download_file(\".\")\n        self.assertEqual(result, self.download_dir_path / \".\")\n\n    def test_large_filename(self):\n        # Test very long filename\n        file_name = \"a\" * 1000\n        file_path = self.download_dir_path / file_name\n        file_path.touch()\n        result = download_file(file_name)\n        self.assertEqual(result, file_path)\n\n    def test_none_input(self):\n        # Test None input\n        with self.assertRaises(TypeError):\n            download_file(None)\n\n    def test_integer_input(self):\n        # Test integer input\n        with self.assertRaises(TypeError):\n            download_file(123)\n\n    def test_directory_traversal_inside(self):\n        # Test valid traversal within download directory\n        subdir = self.download_dir_path / \"sub\"\n        subdir.mkdir()\n        file_path = subdir / \"file.txt\"\n        file_path.touch()\n        result = download_file(\"sub/../sub/file.txt\")\n        self.assertEqual(result, file_path)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 14, "task_id": "89711713"}
{"test": "import unittest\nimport tempfile\nimport os\nfrom pathlib import Path\nimport solution\n\nclass TestFetchConfig(unittest.TestCase):\n    def setUp(self):\n        # Create a temporary directory structure\n        self.test_dir = tempfile.TemporaryDirectory()\n        self.test_dir_path = self.test_dir.name\n        \n        # Create valid configuration directory\n        self.valid_config_dir = os.path.join(self.test_dir_path, 'valid_config')\n        os.mkdir(self.valid_config_dir)\n        \n        # Create a file in valid config directory\n        self.valid_file = 'config.txt'\n        self.valid_file_path = os.path.join(self.valid_config_dir, self.valid_file)\n        with open(self.valid_file_path, 'w') as f:\n            f.write('config content')\n        \n        # Create subdirectory and file\n        self.subdir = 'subdir'\n        self.subdir_path = os.path.join(self.valid_config_dir, self.subdir)\n        os.mkdir(self.subdir_path)\n        self.sub_file = os.path.join(self.subdir, 'sub_config.txt')\n        self.sub_file_path = os.path.join(self.subdir_path, 'sub_config.txt')\n        with open(self.sub_file_path, 'w') as f:\n            f.write('sub config content')\n        \n        # Configure global config_dirs\n        solution.config_dirs = {\n            'valid_key': Path(self.valid_config_dir),\n            'empty_key': Path(self.valid_config_dir)  # For empty filename test\n        }\n    \n    def tearDown(self):\n        self.test_dir.cleanup()\n    \n    def test_valid_config_and_file(self):\n        # Happy path: valid config_key and existing file\n        content = solution.fetch_config('valid_key', self.valid_file)\n        self.assertEqual(content, 'config content')\n    \n    def test_valid_config_subdirectory_file(self):\n        # Valid config_key and file in subdirectory\n        content = solution.fetch_config('valid_key', self.sub_file)\n        self.assertEqual(content, 'sub config content')\n    \n    def test_nonexistent_file(self):\n        # Valid config_key but non-existent file\n        with self.assertRaises(ValueError):\n            solution.fetch_config('valid_key', 'non_existent.txt')\n    \n    def test_invalid_config_key(self):\n        # Invalid config_key\n        with self.assertRaises(KeyError):\n            solution.fetch_config('invalid_key', self.valid_file)\n    \n    def test_relative_path_traversal(self):\n        # Filename with relative path traversal\n        with self.assertRaises(Exception) as context:\n            solution.fetch_config('valid_key', '../outside.txt')\n        self.assertIn('Path ../outside.txt is not allowed', str(context.exception))\n    \n    def test_absolute_path_outside_directory(self):\n        # Absolute path outside allowed directory\n        abs_path = os.path.abspath(os.path.join(self.test_dir_path, '..', 'outside.txt'))\n        with self.assertRaises(Exception) as context:\n            solution.fetch_config('valid_key', abs_path)\n        self.assertIn(f'Path {abs_path} is not allowed', str(context.exception))\n    \n    def test_absolute_path_inside_directory(self):\n        # Absolute path within allowed directory\n        abs_path = os.path.abspath(self.valid_file_path)\n        content = solution.fetch_config('valid_key', abs_path)\n        self.assertEqual(content, 'config content')\n    \n    def test_empty_filename(self):\n        # Empty filename (points to directory)\n        with self.assertRaises(OSError):\n            solution.fetch_config('empty_key', '')\n    \n    def test_large_filename(self):\n        # Very long filename\n        long_name = 'a' * 1000 + '.txt'\n        long_path = os.path.join(self.valid_config_dir, long_name)\n        with open(long_path, 'w') as f:\n            f.write('long filename content')\n        content = solution.fetch_config('valid_key', long_name)\n        self.assertEqual(content, 'long filename content')\n    \n    def test_non_string_input(self):\n        # Invalid input types\n        with self.assertRaises(Exception):\n            solution.fetch_config(None, 'file.txt')\n        with self.assertRaises(Exception):\n            solution.fetch_config('valid_key', None)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 10, "task_id": "c65cfdf1"}
{"test": "import unittest\nfrom unittest.mock import patch\nfrom pathlib import Path\nimport tempfile\nfrom solution import get_log_file\n\nclass TestGetLogFile(unittest.TestCase):\n    def setUp(self):\n        self.temp_dir = tempfile.TemporaryDirectory()\n        self.temp_dir_path = Path(self.temp_dir.name)\n        self.base_dir1 = self.temp_dir_path / \"dir1\"\n        self.base_dir1.mkdir()\n        self.base_dir2 = self.temp_dir_path / \"dir2\"\n        self.base_dir2.mkdir()\n        \n        # Create files and directories for testing\n        self.file1 = self.base_dir1 / \"file1.log\"\n        self.file1.touch()\n        \n        self.subdir1 = self.base_dir1 / \"subdir\"\n        self.subdir1.mkdir()\n        self.file2 = self.subdir1 / \"file2.log\"\n        self.file2.touch()\n        \n        self.dir1 = self.base_dir1 / \"mydir\"\n        self.dir1.mkdir()\n        \n        self.directories = {\n            'key1': self.base_dir1,\n            'key2': self.base_dir2\n        }\n        \n        # Ensure cleanup\n        self.addCleanup(self.temp_dir.cleanup)\n    \n    def test_valid_file_exists(self):\n        # Test with valid key and existing file\n        with patch('solution.directories', self.directories):\n            result = get_log_file('key1', 'file1.log')\n            self.assertEqual(result, self.file1)\n    \n    def test_directory_exists(self):\n        # Test with valid key and existing directory\n        with patch('solution.directories', self.directories):\n            result = get_log_file('key1', 'mydir')\n            self.assertEqual(result, self.dir1)\n    \n    def test_file_in_subdirectory(self):\n        # Test with valid key and file in subdirectory\n        with patch('solution.directories', self.directories):\n            result = get_log_file('key1', 'subdir/file2.log')\n            self.assertEqual(result, self.file2)\n    \n    def test_invalid_dir_key(self):\n        # Test with invalid directory key\n        with patch('solution.directories', self.directories):\n            with self.assertRaises(KeyError):\n                get_log_file('key3', 'file1.log')\n    \n    def test_file_not_found(self):\n        # Test with valid key but non-existent file\n        with patch('solution.directories', self.directories):\n            with self.assertRaises(FileNotFoundError):\n                get_log_file('key1', 'nonexistent.log')\n    \n    def test_path_traversal_escape(self):\n        # Test with relative path escaping base directory\n        with patch('solution.directories', self.directories):\n            with self.assertRaises(Exception) as context:\n                get_log_file('key1', '../file2.log')\n            self.assertIn(\"Access to path\", str(context.exception))\n    \n    def test_absolute_path(self):\n        # Test with absolute path as relative path\n        abs_path = Path('/outside.txt')\n        with patch('solution.directories', self.directories):\n            with self.assertRaises(Exception) as context:\n                get_log_file('key1', str(abs_path))\n            self.assertIn(\"Access to path\", str(context.exception))\n    \n    def test_normalized_path_within(self):\n        # Test with normalized path staying within base directory\n        with patch('solution.directories', self.directories):\n            result = get_log_file('key1', 'subdir/../file1.log')\n            self.assertEqual(result, self.file1)\n    \n    def test_rel_path_empty_string(self):\n        # Test with empty string as relative path\n        with patch('solution.directories', self.directories):\n            result = get_log_file('key1', '')\n            self.assertEqual(result, self.base_dir1)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 9, "task_id": "89fd4f23"}
{"test": "import unittest\nimport tempfile\nfrom pathlib import Path\nimport sys\n\nclass TestServeFile(unittest.TestCase):\n    def setUp(self):\n        # Create a temporary directory and resource structure\n        self.temp_dir = tempfile.TemporaryDirectory()\n        self.temp_path = Path(self.temp_dir.name)\n        \n        # Resource directory setup\n        self.resource_dir = self.temp_path / \"resource1\"\n        self.resource_dir.mkdir()\n        \n        # Create files and directories\n        self.valid_file = self.resource_dir / \"file1.txt\"\n        self.valid_file.write_text(\"content\")\n        \n        self.subdir = self.resource_dir / \"sub\"\n        self.subdir.mkdir()\n        self.file_in_sub = self.subdir / \"file2.txt\"\n        self.file_in_sub.write_text(\"content\")\n        \n        self.outside_file = self.temp_path / \"outside.txt\"\n        self.outside_file.write_text(\"outside\")\n        \n        # Get the module where serve_file is defined and backup/update resources\n        module = sys.modules[serve_file.__module__]\n        self.old_resources = getattr(module, 'resources', None)\n        module.resources = {'res1': self.resource_dir}\n    \n    def tearDown(self):\n        # Cleanup temporary directory and restore resources\n        self.temp_dir.cleanup()\n        module = sys.modules[serve_file.__module__]\n        if self.old_resources is not None:\n            module.resources = self.old_resources\n        else:\n            del module.resources\n    \n    def test_valid_file(self):\n        # Test valid key and existing file\n        result = serve_file('res1', 'file1.txt')\n        self.assertEqual(result, self.valid_file)\n    \n    def test_key_not_found(self):\n        # Test non-existent key\n        with self.assertRaises(KeyError):\n            serve_file('invalid_key', 'file1.txt')\n    \n    def test_file_does_not_exist(self):\n        # Test valid key but non-existent file\n        with self.assertRaises(ValueError) as context:\n            serve_file('res1', 'non_existent.txt')\n        self.assertIn(\"File\", str(context.exception))\n        self.assertIn(\"non_existent.txt\", str(context.exception))\n    \n    def test_path_traversal_outside(self):\n        # Test path escaping resource directory\n        with self.assertRaises(Exception) as context:\n            serve_file('res1', '../outside.txt')\n        self.assertIn(\"Path ../outside.txt is not allowed\", str(context.exception))\n    \n    def test_file_in_subdirectory(self):\n        # Test file in subdirectory\n        result = serve_file('res1', 'sub/file2.txt')\n        self.assertEqual(result, self.file_in_sub)\n    \n    def test_empty_path(self):\n        # Test empty path (returns resource directory)\n        result = serve_file('res1', '')\n        self.assertEqual(result, self.resource_dir)\n    \n    def test_dot_path(self):\n        # Test '.' path (returns resource directory)\n        result = serve_file('res1', '.')\n        self.assertEqual(result, self.resource_dir)\n    \n    def test_directory_path(self):\n        # Test existing directory path\n        result = serve_file('res1', 'sub')\n        self.assertEqual(result, self.subdir)\n    \n    def test_empty_key_valid(self):\n        # Test empty string key\n        module = sys.modules[serve_file.__module__]\n        resource_empty = self.temp_path / \"empty_key_resource\"\n        resource_empty.mkdir()\n        module.resources[''] = resource_empty\n        self.addCleanup(lambda: module.resources.pop(''))\n        \n        valid_file = resource_empty / \"file.txt\"\n        valid_file.write_text(\"content\")\n        \n        result = serve_file('', 'file.txt')\n        self.assertEqual(result, valid_file)\n    \n    def test_key_with_special_chars(self):\n        # Test key with special characters\n        module = sys.modules[serve_file.__module__]\n        key = '!@#$%^&*()'\n        resource_special = self.temp_path / \"special\"\n        resource_special.mkdir()\n        module.resources[key] = resource_special\n        self.addCleanup(lambda: module.resources.pop(key))\n        \n        valid_file = resource_special / \"file.txt\"\n        valid_file.write_text(\"content\")\n        \n        result = serve_file(key, 'file.txt')\n        self.assertEqual(result, valid_file)\n    \n    def test_absolute_path(self):\n        # Test absolute path not in resource\n        abs_path = str(self.outside_file)\n        with self.assertRaises(Exception) as context:\n            serve_file('res1', abs_path)\n        self.assertIn(f\"Path {abs_path} is not allowed\", str(context.exception))\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 11, "task_id": "753446aa"}
{"test": "import unittest\nfrom unittest.mock import patch\n\n# Define the global and the function as per the input\nALLOWED_COMMANDS = set()\n\ndef check_and_run_command(command: str) -> str | None:\n    if command in ALLOWED_COMMANDS:\n        return command\n    return None\n\nclass TestCases(unittest.TestCase):\n    def test_case_1(self):\n        # Test with a command that is in the allowed set\n        with patch('__main__.ALLOWED_COMMANDS', {'ls', 'echo', 'pwd'}):\n            result = check_and_run_command('ls')\n            self.assertEqual(result, 'ls')\n\n    def test_case_2(self):\n        # Test with a command that is not in the allowed set\n        with patch('__main__.ALLOWED_COMMANDS', {'ls', 'echo', 'pwd'}):\n            result = check_and_run_command('rm')\n            self.assertIsNone(result)\n\n    def test_case_3(self):\n        # Test empty string when allowed set contains empty string\n        with patch('__main__.ALLOWED_COMMANDS', {'', 'ls'}):\n            result = check_and_run_command('')\n            self.assertEqual(result, '')\n\n    def test_case_4(self):\n        # Test empty string when not in allowed set\n        with patch('__main__.ALLOWED_COMMANDS', {'ls'}):\n            result = check_and_run_command('')\n            self.assertIsNone(result)\n\n    def test_case_5(self):\n        # Test with an empty allowed set\n        with patch('__main__.ALLOWED_COMMANDS', set()):\n            result = check_and_run_command('ls')\n            self.assertIsNone(result)\n\n    def test_case_6(self):\n        # Test with None as command\n        with patch('__main__.ALLOWED_COMMANDS', {'ls', 'echo', 'pwd'}):\n            result = check_and_run_command(None)\n            self.assertIsNone(result)\n\n    def test_case_7(self):\n        # Test with non-string command (integer)\n        with patch('__main__.ALLOWED_COMMANDS', {'ls', 'echo', 'pwd'}):\n            result = check_and_run_command(123)\n            self.assertIsNone(result)\n\n    def test_case_8(self):\n        # Test case sensitivity: command in different case\n        with patch('__main__.ALLOWED_COMMANDS', {'ls', 'echo', 'pwd'}):\n            result = check_and_run_command('LS')\n            self.assertIsNone(result)\n\n    def test_case_9(self):\n        # Test command with trailing space\n        with patch('__main__.ALLOWED_COMMANDS', {'ls', 'echo', 'pwd'}):\n            result = check_and_run_command('ls ')\n            self.assertIsNone(result)\n\n    def test_case_10(self):\n        # Test command with special characters that is allowed\n        allowed = {'echo \"Hello\"', 'cat /tmp/file.txt'}\n        with patch('__main__.ALLOWED_COMMANDS', allowed):\n            result = check_and_run_command('echo \"Hello\"')\n            self.assertEqual(result, 'echo \"Hello\"')\n\n    def test_case_11(self):\n        # Test command with special characters that is not allowed\n        allowed = {'echo \"Hello\"', 'cat /tmp/file.txt'}\n        with patch('__main__.ALLOWED_COMMANDS', allowed):\n            result = check_and_run_command('rm -rf /')\n            self.assertIsNone(result)\n", "num_test_cases": 11, "task_id": "204f0edd"}
{"test": "import unittest\nfrom unittest.mock import patch\n\nclass TestVerifyAndRunCommand(unittest.TestCase):\n    \n    def setUp(self):\n        # Define a fixed set of allowed commands for testing\n        self.allowed_commands = {'ls', 'pwd', 'echo', 'date'}\n        # Patch ALLOWED_COMMANDS in the main module context\n        self.patcher = patch('__main__.ALLOWED_COMMANDS', new=self.allowed_commands)\n        self.patcher.start()\n    \n    def tearDown(self):\n        # Stop patching after each test\n        self.patcher.stop()\n    \n    def test_valid_command(self):\n        # Test valid command (ls) returns the same command string\n        result = verify_and_run_command('ls')\n        self.assertEqual(result, 'ls')\n    \n    def test_another_valid_command(self):\n        # Test another valid command (echo) returns the same command string\n        result = verify_and_run_command('echo')\n        self.assertEqual(result, 'echo')\n    \n    def test_invalid_command(self):\n        # Test invalid command (rm) returns None\n        result = verify_and_run_command('rm')\n        self.assertIsNone(result)\n    \n    def test_empty_string(self):\n        # Test empty string input returns None\n        result = verify_and_run_command('')\n        self.assertIsNone(result)\n    \n    def test_case_sensitivity(self):\n        # Test case sensitivity (LS vs ls) returns None\n        result = verify_and_run_command('LS')\n        self.assertIsNone(result)\n    \n    def test_command_with_whitespace(self):\n        # Test command with trailing space returns None\n        result = verify_and_run_command('pwd ')\n        self.assertIsNone(result)\n    \n    def test_none_input(self):\n        # Test None input returns None\n        result = verify_and_run_command(None)\n        self.assertIsNone(result)\n    \n    def test_non_string_input_integer(self):\n        # Test non-string input (integer) returns None\n        result = verify_and_run_command(123)\n        self.assertIsNone(result)\n    \n    def test_long_string(self):\n        # Test a long string not in the allowed commands returns None\n        long_string = 'a' * 1000\n        result = verify_and_run_command(long_string)\n        self.assertIsNone(result)", "num_test_cases": 9, "task_id": "898a90cc"}
{"test": "import unittest\n\n# Define the ALLOWED_COMMANDS set as required by the function\nALLOWED_COMMANDS = {'ls', 'echo', 'date', 'cat', 'grep', 'pwd'}\n\n# The function implementation (as provided)\ndef run_command_if_safe(user_command: str) -> str | None:\n    if user_command in ALLOWED_COMMANDS:\n        return user_command\n    return None\n\nclass TestRunCommandIfSafe(unittest.TestCase):\n    \n    def test_valid_command_1(self):\n        # Test a basic valid command\n        self.assertEqual(run_command_if_safe('ls'), 'ls')\n    \n    def test_valid_command_2(self):\n        # Test another valid command\n        self.assertEqual(run_command_if_safe('echo'), 'echo')\n    \n    def test_case_sensitivity(self):\n        # Test that commands are case-sensitive (should not match)\n        self.assertIsNone(run_command_if_safe('LS'))\n    \n    def test_invalid_command(self):\n        # Test a command not in the allowed set\n        self.assertIsNone(run_command_if_safe('rm'))\n    \n    def test_empty_string(self):\n        # Test empty string input\n        self.assertIsNone(run_command_if_safe(''))\n    \n    def test_whitespace_command(self):\n        # Test command with leading/trailing whitespace\n        self.assertIsNone(run_command_if_safe('  ls  '))\n    \n    def test_command_substring(self):\n        # Test a substring of an allowed command\n        self.assertIsNone(run_command_if_safe('ec'))\n    \n    def test_command_superset(self):\n        # Test a superset of an allowed command\n        self.assertIsNone(run_command_if_safe('echo_extra'))\n    \n    def test_none_input(self):\n        # Test None input\n        self.assertIsNone(run_command_if_safe(None))\n    \n    def test_non_string_input(self):\n        # Test non-string input (integer)\n        self.assertIsNone(run_command_if_safe(123))\n    \n    def test_long_string(self):\n        # Test a very long string\n        long_str = 'a' * 1000\n        self.assertIsNone(run_command_if_safe(long_str))\n    \n    def test_partial_match(self):\n        # Test a command partially matching an allowed command\n        self.assertIsNone(run_command_if_safe('datex'))\n    \n    def test_special_characters(self):\n        # Test command with special characters\n        self.assertIsNone(run_command_if_safe('ls; rm -rf /'))\n    \n    def test_concatenated_commands(self):\n        # Test multiple commands concatenated\n        self.assertIsNone(run_command_if_safe('ls; echo'))\n    \n    def test_unicode_command(self):\n        # Test unicode command\n        self.assertIsNone(run_command_if_safe('åäö'))\n    \n    def test_command_injection_attempt(self):\n        # Test a command injection attempt\n        self.assertIsNone(run_command_if_safe('ls && rm -rf /'))\n    \n    def test_whitespace_only(self):\n        # Test whitespace-only input\n        self.assertIsNone(run_command_if_safe('   '))", "num_test_cases": 17, "task_id": "dd74f02d"}
{"test": "import unittest\nfrom unittest.mock import patch\nfrom solution import verify_and_run_command\n\nclass TestVerifyAndRunCommand(unittest.TestCase):\n    \n    @patch('solution.ALLOWED_COMMANDS', ['ls', 'echo', 'date', 'pwd'])\n    def test_valid_command(self):\n        # Test that a command in the allowed list returns the same command\n        result = verify_and_run_command('ls')\n        self.assertEqual(result, 'ls')\n    \n    @patch('solution.ALLOWED_COMMANDS', ['ls', 'echo', 'date', 'pwd'])\n    def test_command_not_in_list(self):\n        # Test a command not in the allowed list returns None\n        result = verify_and_run_command('grep')\n        self.assertIsNone(result)\n    \n    @patch('solution.ALLOWED_COMMANDS', ['ls', 'echo', 'date', 'pwd'])\n    def test_empty_string_not_allowed(self):\n        # Test empty string when not in the list returns None\n        result = verify_and_run_command('')\n        self.assertIsNone(result)\n    \n    @patch('solution.ALLOWED_COMMANDS', ['', 'ls', 'echo', 'date', 'pwd'])\n    def test_empty_string_allowed(self):\n        # Test empty string when in the list returns empty string\n        result = verify_and_run_command('')\n        self.assertEqual(result, '')\n    \n    @patch('solution.ALLOWED_COMMANDS', ['ls', 'echo', 'date', 'pwd'])\n    def test_command_with_whitespace_not_in_list(self):\n        # Test a command with whitespace (not in the list) returns None\n        result = verify_and_run_command('ls -l')\n        self.assertIsNone(result)\n    \n    @patch('solution.ALLOWED_COMMANDS', ['ls -l', 'echo', 'date', 'pwd'])\n    def test_command_with_whitespace_in_list(self):\n        # Test a command with whitespace (in the list) returns the command\n        result = verify_and_run_command('ls -l')\n        self.assertEqual(result, 'ls -l')\n    \n    @patch('solution.ALLOWED_COMMANDS', ['ls', 'echo', 'date', 'pwd'])\n    def test_case_sensitivity(self):\n        # Test that command is case-sensitive: 'LS' vs 'ls'\n        result = verify_and_run_command('LS')\n        self.assertIsNone(result)\n    \n    @patch('solution.ALLOWED_COMMANDS', ['ls', 'echo', 'date', 'pwd'])\n    def test_none_input(self):\n        # Test that None input raises TypeError\n        with self.assertRaises(TypeError):\n            verify_and_run_command(None)\n    \n    @patch('solution.ALLOWED_COMMANDS', ['ls', 'echo', 'date', 'pwd'])\n    def test_non_string_input(self):\n        # Test that non-string input (integer) raises TypeError\n        with self.assertRaises(TypeError):\n            verify_and_run_command(123)\n    \n    @patch('solution.ALLOWED_COMMANDS', ['caf\\u00e9', 'ls'])\n    def test_non_ascii_command(self):\n        # Test a non-ASCII command that is in the list\n        result = verify_and_run_command('caf\\u00e9')\n        self.assertEqual(result, 'caf\\u00e9')\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 10, "task_id": "febf2d61"}
{"test": "import unittest\nfrom unittest.mock import patch\n\n# We assume the function 'check_and_run_command' is available for import\n# We'll dynamically get the function's module name for patching\n\nclass TestCheckAndRunCommand(unittest.TestCase):\n    \n    def test_command_in_allowed_list(self):\n        # Test that command in allowed list returns the same command\n        with patch(f'check_and_run_command.__module__.ALLOWED_COMMANDS', ['ls', 'echo', 'pwd']):\n            from check_and_run_command import check_and_run_command\n            self.assertEqual(check_and_run_command('ls'), 'ls')\n    \n    def test_command_not_in_allowed_list(self):\n        # Test that command not in allowed list returns None\n        with patch(f'check_and_run_command.__module__.ALLOWED_COMMANDS', ['ls', 'echo', 'pwd']):\n            from check_and_run_command import check_and_run_command\n            self.assertIsNone(check_and_run_command('grep'))\n    \n    def test_empty_string_command(self):\n        # Test empty string command returns None\n        with patch(f'check_and_run_command.__module__.ALLOWED_COMMANDS', ['ls', 'echo', 'pwd']):\n            from check_and_run_command import check_and_run_command\n            self.assertIsNone(check_and_run_command(''))\n    \n    def test_none_input(self):\n        # Test None input returns None\n        with patch(f'check_and_run_command.__module__.ALLOWED_COMMANDS', ['ls', 'echo', 'pwd']):\n            from check_and_run_command import check_and_run_command\n            self.assertIsNone(check_and_run_command(None))\n    \n    def test_non_string_input(self):\n        # Test non-string input returns None\n        with patch(f'check_and_run_command.__module__.ALLOWED_COMMANDS', ['ls', 'echo', 'pwd']):\n            from check_and_run_command import check_and_run_command\n            self.assertIsNone(check_and_run_command(123))\n            self.assertIsNone(check_and_run_command(['ls']))\n    \n    def test_case_sensitivity(self):\n        # Test case sensitivity (allowed commands are case-sensitive)\n        with patch(f'check_and_run_command.__module__.ALLOWED_COMMANDS', ['ls', 'echo', 'pwd']):\n            from check_and_run_command import check_and_run_command\n            self.assertIsNone(check_and_run_command('LS'))\n            self.assertIsNone(check_and_run_command('Echo'))\n    \n    def test_special_characters_in_command(self):\n        # Test command with special characters not in allowed list\n        with patch(f'check_and_run_command.__module__.ALLOWED_COMMANDS', ['ls', 'echo', 'pwd']):\n            from check_and_run_command import check_and_run_command\n            self.assertIsNone(check_and_run_command('ls; rm -rf /'))\n            self.assertIsNone(check_and_run_command('echo \"hello\"'))\n    \n    def test_whitespace_commands(self):\n        # Test commands with whitespace variations\n        with patch(f'check_and_run_command.__module__.ALLOWED_COMMANDS', ['ls', 'echo', 'pwd']):\n            from check_and_run_command import check_and_run_command\n            self.assertIsNone(check_and_run_command(' ls'))\n            self.assertIsNone(check_and_run_command('ls '))\n            self.assertIsNone(check_and_run_command(' ls '))\n    \n    def test_long_command(self):\n        # Test very long command string not in allowed list\n        long_command = 'a' * 1000\n        with patch(f'check_and_run_command.__module__.ALLOWED_COMMANDS', ['ls', 'echo', 'pwd']):\n            from check_and_run_command import check_and_run_command\n            self.assertIsNone(check_and_run_command(long_command))\n    \n    def test_multiple_valid_commands(self):\n        # Test multiple commands that are in the allowed list\n        with patch(f'check_and_run_command.__module__.ALLOWED_COMMANDS', ['ls', 'echo', 'pwd', 'cd']):\n            from check_and_run_command import check_and_run_command\n            self.assertEqual(check_and_run_command('cd'), 'cd')\n            self.assertEqual(check_and_run_command('echo'), 'echo')\n    \n    def test_duplicate_commands(self):\n        # Test when allowed commands have duplicates\n        with patch(f'check_and_run_command.__module__.ALLOWED_COMMANDS', ['ls', 'ls', 'echo']):\n            from check_and_run_command import check_and_run_command\n            self.assertEqual(check_and_run_command('ls'), 'ls')\n    \n    def test_empty_allowed_commands(self):\n        # Test when allowed commands list is empty\n        with patch(f'check_and_run_command.__module__.ALLOWED_COMMANDS', []):\n            from check_and_run_command import check_and_run_command\n            self.assertIsNone(check_and_run_command('ls'))\n            self.assertIsNone(check_and_run_command(''))", "num_test_cases": 12, "task_id": "fac38a7d"}
{"test": "import unittest\nfrom unittest.mock import patch\n\n# Import the function to be tested (assumed to be in a module named 'command_module')\nfrom command_module import check_and_execute_command\n\nclass TestCheckAndExecuteCommand(unittest.TestCase):\n    def test_valid_command(self):\n        # Test a command present in the allowed list returns the command\n        with patch('command_module.ALLOWED_COMMANDS', ['ls', 'cd', 'pwd']):\n            cmd = 'ls'\n            result = check_and_execute_command(cmd)\n            self.assertEqual(result, cmd)\n\n    def test_invalid_command(self):\n        # Test a command not in the allowed list returns None\n        with patch('command_module.ALLOWED_COMMANDS', ['ls', 'cd', 'pwd']):\n            cmd = 'rm'\n            result = check_and_execute_command(cmd)\n            self.assertIsNone(result)\n\n    def test_case_sensitivity(self):\n        # Test commands are case sensitive (uppercase not matching lowercase)\n        with patch('command_module.ALLOWED_COMMANDS', ['ls', 'cd', 'pwd']):\n            cmd = 'LS'\n            result = check_and_execute_command(cmd)\n            self.assertIsNone(result)\n\n    def test_empty_string_valid(self):\n        # Test empty string command when allowed returns empty string\n        with patch('command_module.ALLOWED_COMMANDS', ['', 'exit']):\n            cmd = ''\n            result = check_and_execute_command(cmd)\n            self.assertEqual(result, cmd)\n\n    def test_empty_string_invalid(self):\n        # Test empty string command when not allowed returns None\n        with patch('command_module.ALLOWED_COMMANDS', ['ls', 'cd']):\n            cmd = ''\n            result = check_and_execute_command(cmd)\n            self.assertIsNone(result)\n\n    def test_command_with_spaces_valid(self):\n        # Test command with spaces present in allowed list returns command\n        with patch('command_module.ALLOWED_COMMANDS', ['ls -l', 'cd /']):\n            cmd = 'ls -l'\n            result = check_and_execute_command(cmd)\n            self.assertEqual(result, cmd)\n\n    def test_command_with_spaces_invalid(self):\n        # Test command with spaces not in allowed list returns None\n        with patch('command_module.ALLOWED_COMMANDS', ['ls -l', 'cd /']):\n            cmd = 'rm -rf'\n            result = check_and_execute_command(cmd)\n            self.assertIsNone(result)\n\n    def test_long_command_valid(self):\n        # Test a long command string present in allowed list returns command\n        long_cmd = 'a' * 1000\n        with patch('command_module.ALLOWED_COMMANDS', [long_cmd, 'exit']):\n            result = check_and_execute_command(long_cmd)\n            self.assertEqual(result, long_cmd)\n\n    def test_long_command_invalid(self):\n        # Test a long command string not in allowed list returns None\n        long_cmd = 'a' * 1000\n        with patch('command_module.ALLOWED_COMMANDS', ['ls', 'exit']):\n            result = check_and_execute_command(long_cmd)\n            self.assertIsNone(result)\n\n    def test_command_substring(self):\n        # Test a command that is a substring of an allowed command returns None\n        with patch('command_module.ALLOWED_COMMANDS', ['list', 'delete']):\n            cmd = 'lis'\n            result = check_and_execute_command(cmd)\n            self.assertIsNone(result)", "num_test_cases": 10, "task_id": "85366ea8"}
{"test": "import unittest\nfrom unittest.mock import patch\nfrom solution import check_and_run_command\n\nclass TestCheckAndRunCommand(unittest.TestCase):\n    \n    def test_command_in_list(self):\n        # Test when the command is in the trusted list\n        with patch('solution.TRUSTED_COMMANDS', ['ls', 'echo', 'date']):\n            result = check_and_run_command('ls')\n            self.assertEqual(result, 'ls')\n    \n    def test_command_not_in_list(self):\n        # Test when the command is not in the trusted list\n        with patch('solution.TRUSTED_COMMANDS', ['ls', 'echo', 'date']):\n            result = check_and_run_command('rm')\n            self.assertIsNone(result)\n    \n    def test_empty_string_in_list(self):\n        # Test empty string when it is in the trusted list\n        with patch('solution.TRUSTED_COMMANDS', ['', 'ls']):\n            result = check_and_run_command('')\n            self.assertEqual(result, '')\n    \n    def test_empty_string_not_in_list(self):\n        # Test empty string when it is not in the trusted list\n        with patch('solution.TRUSTED_COMMANDS', ['ls', 'echo']):\n            result = check_and_run_command('')\n            self.assertIsNone(result)\n    \n    def test_command_with_spaces_in_list(self):\n        # Test a command with spaces that is in the trusted list\n        with patch('solution.TRUSTED_COMMANDS', ['ls -l', 'echo']):\n            result = check_and_run_command('ls -l')\n            self.assertEqual(result, 'ls -l')\n    \n    def test_command_with_special_chars_in_list(self):\n        # Test a command with special characters that is in the trusted list\n        with patch('solution.TRUSTED_COMMANDS', ['echo $HOME', 'date']):\n            result = check_and_run_command('echo $HOME')\n            self.assertEqual(result, 'echo $HOME')\n    \n    def test_trusted_commands_empty_list(self):\n        # Test when the trusted commands list is empty\n        with patch('solution.TRUSTED_COMMANDS', []):\n            result = check_and_run_command('ls')\n            self.assertIsNone(result)\n            result = check_and_run_command('')\n            self.assertIsNone(result)\n    \n    def test_trusted_commands_single_element(self):\n        # Test when the trusted commands list has one element\n        with patch('solution.TRUSTED_COMMANDS', ['ls']):\n            result = check_and_run_command('ls')\n            self.assertEqual(result, 'ls')\n            result = check_and_run_command('echo')\n            self.assertIsNone(result)\n    \n    def test_case_sensitivity(self):\n        # Test that the command is case sensitive\n        with patch('solution.TRUSTED_COMMANDS', ['ls']):\n            result = check_and_run_command('LS')\n            self.assertIsNone(result)\n    \n    def test_none_input(self):\n        # Test when input is None\n        with patch('solution.TRUSTED_COMMANDS', ['ls']):\n            result = check_and_run_command(None)\n            self.assertIsNone(result)\n    \n    def test_integer_input(self):\n        # Test when input is an integer\n        with patch('solution.TRUSTED_COMMANDS', ['ls']):\n            result = check_and_run_command(123)\n            self.assertIsNone(result)\n    \n    def test_long_string_in_list(self):\n        # Test a very long command string that is in the trusted list\n        long_command = 'a' * 1000\n        with patch('solution.TRUSTED_COMMANDS', ['ls', long_command]):\n            result = check_and_run_command(long_command)\n            self.assertEqual(result, long_command)\n    \n    def test_long_string_not_in_list(self):\n        # Test a very long command string that is not in the trusted list\n        long_command = 'a' * 1000\n        with patch('solution.TRUSTED_COMMANDS', ['ls']):\n            result = check_and_run_command(long_command)\n            self.assertIsNone(result)", "num_test_cases": 13, "task_id": "c4c9c696"}
{"test": "import unittest\nfrom unittest.mock import patch\nfrom commands import authorize_and_run_cmd\n\nmodule_name = authorize_and_run_cmd.__module__\n\nclass TestAuthorizeAndRunCmd(unittest.TestCase):\n    def test_command_in_trusted_list(self):\n        # Test command present in TRUSTED_COMMANDS returns the command\n        with patch(f'{module_name}.TRUSTED_COMMANDS', ['ls', 'cd', 'pwd']):\n            cmd = 'ls'\n            result = authorize_and_run_cmd(cmd)\n            self.assertEqual(result, cmd)\n\n    def test_command_not_in_trusted_list(self):\n        # Test command not in TRUSTED_COMMANDS returns None\n        with patch(f'{module_name}.TRUSTED_COMMANDS', ['ls', 'cd', 'pwd']):\n            cmd = 'rm'\n            result = authorize_and_run_cmd(cmd)\n            self.assertIsNone(result)\n\n    def test_empty_string_in_trusted_list(self):\n        # Test empty string command in TRUSTED_COMMANDS returns the empty string\n        with patch(f'{module_name}.TRUSTED_COMMANDS', ['', 'ls']):\n            cmd = ''\n            result = authorize_and_run_cmd(cmd)\n            self.assertEqual(result, cmd)\n\n    def test_empty_string_not_in_trusted_list(self):\n        # Test empty string command not in TRUSTED_COMMANDS returns None\n        with patch(f'{module_name}.TRUSTED_COMMANDS', ['ls', 'cd']):\n            cmd = ''\n            result = authorize_and_run_cmd(cmd)\n            self.assertIsNone(result)\n\n    def test_special_characters_in_trusted_list(self):\n        # Test command with special characters in TRUSTED_COMMANDS returns the command\n        with patch(f'{module_name}.TRUSTED_COMMANDS', ['echo $HOME', 'ls']):\n            cmd = 'echo $HOME'\n            result = authorize_and_run_cmd(cmd)\n            self.assertEqual(result, cmd)\n\n    def test_special_characters_not_in_trusted_list(self):\n        # Test command with special characters not in TRUSTED_COMMANDS returns None\n        with patch(f'{module_name}.TRUSTED_COMMANDS', ['ls', 'cd']):\n            cmd = 'echo $HOME'\n            result = authorize_and_run_cmd(cmd)\n            self.assertIsNone(result)\n\n    def test_numeric_string_in_trusted_list(self):\n        # Test numeric string command in TRUSTED_COMMANDS returns the command\n        with patch(f'{module_name}.TRUSTED_COMMANDS', ['123', 'ls']):\n            cmd = '123'\n            result = authorize_and_run_cmd(cmd)\n            self.assertEqual(result, cmd)\n\n    def test_numeric_string_not_in_trusted_list(self):\n        # Test numeric string command not in TRUSTED_COMMANDS returns None\n        with patch(f'{module_name}.TRUSTED_COMMANDS', ['ls', 'cd']):\n            cmd = '123'\n            result = authorize_and_run_cmd(cmd)\n            self.assertIsNone(result)\n\n    def test_non_string_hashable_input(self):\n        # Test non-string but hashable input (e.g., integer) returns None\n        with patch(f'{module_name}.TRUSTED_COMMANDS', ['ls', 'cd']):\n            cmd = 123\n            result = authorize_and_run_cmd(cmd)\n            self.assertIsNone(result)\n\n    def test_non_string_non_hashable_input(self):\n        # Test non-string and non-hashable input (e.g., list) raises TypeError\n        with patch(f'{module_name}.TRUSTED_COMMANDS', ['ls', 'cd']):\n            cmd = ['ls']\n            with self.assertRaises(TypeError):\n                authorize_and_run_cmd(cmd)\n\n    def test_long_string_in_trusted_list(self):\n        # Test long string command in TRUSTED_COMMANDS returns the command\n        long_cmd = 'a' * 1000\n        with patch(f'{module_name}.TRUSTED_COMMANDS', [long_cmd, 'ls']):\n            result = authorize_and_run_cmd(long_cmd)\n            self.assertEqual(result, long_cmd)\n\n    def test_long_string_not_in_trusted_list(self):\n        # Test long string command not in TRUSTED_COMMANDS returns None\n        long_cmd = 'a' * 1000\n        with patch(f'{module_name}.TRUSTED_COMMANDS', ['ls', 'cd']):\n            result = authorize_and_run_cmd(long_cmd)\n            self.assertIsNone(result)\n\n    def test_substring_of_trusted_command(self):\n        # Test command that is a substring of a trusted command returns None\n        trusted_cmd = 'ls -l'\n        substring_cmd = 'ls'\n        with patch(f'{module_name}.TRUSTED_COMMANDS', [trusted_cmd]):\n            result = authorize_and_run_cmd(substring_cmd)\n            self.assertIsNone(result)\n\n    def test_superstring_of_trusted_command(self):\n        # Test command that is a superstring of a trusted command returns None\n        trusted_cmd = 'ls'\n        superstring_cmd = 'ls -l'\n        with patch(f'{module_name}.TRUSTED_COMMANDS', [trusted_cmd]):\n            result = authorize_and_run_cmd(superstring_cmd)\n            self.assertIsNone(result)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 14, "task_id": "fa5b6b1c"}
{"test": "import unittest\nfrom unittest.mock import patch\n\n# Import the function from its module\nfrom command_validator import validate_and_run_cmd\n\n# Get the module name for patching\nMODULE_NAME = validate_and_run_cmd.__module__\n\nclass TestValidateAndRunCmd(unittest.TestCase):\n\n    def test_command_present(self):\n        # Test when command is in the allowed list\n        with patch(f'{MODULE_NAME}.APPROVED_COMMANDS', ['ls', 'echo']):\n            self.assertEqual(validate_and_run_cmd('ls'), 'ls')\n\n    def test_command_absent(self):\n        # Test when command is not in the allowed list\n        with patch(f'{MODULE_NAME}.APPROVED_COMMANDS', ['ls', 'echo']):\n            self.assertIsNone(validate_and_run_cmd('pwd'))\n\n    def test_empty_string_present(self):\n        # Test empty string when it is in the allowed list\n        with patch(f'{MODULE_NAME}.APPROVED_COMMANDS', ['', 'ls']):\n            self.assertEqual(validate_and_run_cmd(''), '')\n\n    def test_empty_string_absent(self):\n        # Test empty string when not in the allowed list\n        with patch(f'{MODULE_NAME}.APPROVED_COMMANDS', ['ls']):\n            self.assertIsNone(validate_and_run_cmd(''))\n\n    def test_non_string_inputs(self):\n        # Test non-string inputs (integer, None, list, dict)\n        with patch(f'{MODULE_NAME}.APPROVED_COMMANDS', ['ls']):\n            self.assertIsNone(validate_and_run_cmd(123))\n            self.assertIsNone(validate_and_run_cmd(None))\n            self.assertIsNone(validate_and_run_cmd(['ls']))\n            self.assertIsNone(validate_and_run_cmd({'cmd': 'ls'}))\n\n    def test_whitespace_commands_not_in_list(self):\n        # Test commands with whitespace not matching exact list entries\n        allowed_commands = ['ls']\n        test_cases = [\n            (' ls', None),\n            ('ls ', None),\n            ('  ls  ', None),\n            ('\\tls', None),\n            ('ls\\t', None)\n        ]\n        with patch(f'{MODULE_NAME}.APPROVED_COMMANDS', allowed_commands):\n            for cmd, expected in test_cases:\n                self.assertEqual(validate_and_run_cmd(cmd), expected)\n\n    def test_case_sensitivity(self):\n        # Test case sensitivity of command matching\n        allowed_commands = ['ls']\n        test_cases = [\n            ('ls', 'ls'),\n            ('LS', None),\n            ('lS', None),\n            ('Ls', None)\n        ]\n        with patch(f'{MODULE_NAME}.APPROVED_COMMANDS', allowed_commands):\n            for cmd, expected in test_cases:\n                self.assertEqual(validate_and_run_cmd(cmd), expected)\n\n    def test_long_command(self):\n        # Test a very long command that is allowed\n        long_cmd = 'a' * 1000\n        with patch(f'{MODULE_NAME}.APPROVED_COMMANDS', [long_cmd, 'ls']):\n            self.assertEqual(validate_and_run_cmd(long_cmd), long_cmd)\n\n    def test_substring_command(self):\n        # Test commands that are substrings of allowed commands\n        allowed_commands = ['longcommand', 'ls']\n        with patch(f'{MODULE_NAME}.APPROVED_COMMANDS', allowed_commands):\n            self.assertIsNone(validate_and_run_cmd('long'))\n            self.assertIsNone(validate_and_run_cmd('command'))\n            self.assertIsNone(validate_and_run_cmd('longcommandX'))\n\n    def test_empty_allowed_list(self):\n        # Test behavior when allowed commands list is empty\n        with patch(f'{MODULE_NAME}.APPROVED_COMMANDS', []):\n            self.assertIsNone(validate_and_run_cmd('ls'))\n            self.assertIsNone(validate_and_run_cmd(''))\n\n    def test_command_with_whitespace_in_list(self):\n        # Test when allowed list contains a whitespace command\n        with patch(f'{MODULE_NAME}.APPROVED_COMMANDS', ['  ls  ', 'echo']):\n            self.assertEqual(validate_and_run_cmd('  ls  '), '  ls  ')\n\n    def test_command_with_whitespace_not_in_list(self):\n        # Test command without exact whitespace match\n        with patch(f'{MODULE_NAME}.APPROVED_COMMANDS', ['  ls  ', 'echo']):\n            self.assertIsNone(validate_and_run_cmd('ls'))\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 12, "task_id": "676e40eb"}
{"test": "import unittest\nimport re\n\nclass TestInsertCustomHeader(unittest.TestCase):\n    def test_normal_string(self):\n        # Test with a typical valid header value\n        result = insert_custom_header(\"StandardValue\")\n        self.assertEqual(result, \"Custom-Header: StandardValue\")\n\n    def test_string_with_newline(self):\n        # Test with newline character in header value\n        result = insert_custom_header(\"Value\\nWithNewline\")\n        self.assertEqual(result, \"Custom-Header: ValueWithNewline\")\n\n    def test_string_with_carriage_return(self):\n        # Test with carriage return character in header value\n        result = insert_custom_header(\"Value\\rWithCarriageReturn\")\n        self.assertEqual(result, \"Custom-Header: ValueWithCarriageReturn\")\n\n    def test_string_with_newline_and_carriage_return(self):\n        # Test with mixed newline and carriage return\n        result = insert_custom_header(\"\\r\\nStart\\rMiddle\\nEnd\\r\\n\")\n        self.assertEqual(result, \"Custom-Header: StartMiddleEnd\")\n\n    def test_empty_string(self):\n        # Test with empty header value\n        result = insert_custom_header(\"\")\n        self.assertEqual(result, \"Custom-Header: \")\n\n    def test_long_string(self):\n        # Test with very long input string\n        long_str = \"A\" * 10000\n        result = insert_custom_header(long_str)\n        self.assertEqual(result, f\"Custom-Header: {long_str}\")\n\n    def test_non_string_integer(self):\n        # Test non-string input (integer)\n        with self.assertRaises(TypeError):\n            insert_custom_header(123)\n\n    def test_non_string_none(self):\n        # Test non-string input (None)\n        with self.assertRaises(TypeError):\n            insert_custom_header(None)\n\n    def test_non_string_list(self):\n        # Test non-string input (list)\n        with self.assertRaises(TypeError):\n            insert_custom_header([\"item1\", \"item2\"])", "num_test_cases": 9, "task_id": "dca463cc"}
{"test": "import unittest\n\nclass TestAppendUserHeader(unittest.TestCase):\n    def test_simple_string(self):\n        # Test typical valid string without special characters\n        result = append_user_header('Hello, World!')\n        self.assertEqual(result, 'Custom-Header: Hello, World!')\n\n    def test_string_with_newline(self):\n        # Test string containing newline character\n        input_str = 'Hello' + chr(10) + 'World'\n        result = append_user_header(input_str)\n        self.assertEqual(result, 'Custom-Header: HelloWorld')\n\n    def test_string_with_carriage_return(self):\n        # Test string containing carriage return character\n        input_str = 'Hello' + chr(13) + 'World'\n        result = append_user_header(input_str)\n        self.assertEqual(result, 'Custom-Header: HelloWorld')\n\n    def test_string_with_mixed_special_chars(self):\n        # Test string with mixed newline and carriage return\n        input_str = 'Line1' + chr(13) + chr(10) + 'Line2' + chr(10) + 'Line3' + chr(13) + 'Line4'\n        result = append_user_header(input_str)\n        self.assertEqual(result, 'Custom-Header: Line1Line2Line3Line4')\n\n    def test_empty_string(self):\n        # Test empty input string\n        result = append_user_header('')\n        self.assertEqual(result, 'Custom-Header: ')\n\n    def test_long_string_without_special_chars(self):\n        # Test long string without special characters\n        long_str = 'A' * 10000\n        result = append_user_header(long_str)\n        self.assertEqual(result, 'Custom-Header: ' + long_str)\n\n    def test_long_string_with_special_chars(self):\n        # Test long string containing special characters\n        base_str = 'Hello' + chr(13) + chr(10) + 'World' + chr(10)\n        long_str = base_str * 1000\n        expected = 'Custom-Header: ' + long_str.replace(chr(13), '').replace(chr(10), '')\n        result = append_user_header(long_str)\n        self.assertEqual(result, expected)\n\n    def test_none_input(self):\n        # Test None input (invalid type)\n        with self.assertRaises(TypeError):\n            append_user_header(None)\n\n    def test_integer_input(self):\n        # Test integer input (invalid type)\n        with self.assertRaises(TypeError):\n            append_user_header(123)\n\n    def test_float_input(self):\n        # Test float input (invalid type)\n        with self.assertRaises(TypeError):\n            append_user_header(123.45)\n\n    def test_list_input(self):\n        # Test list input (invalid type)\n        with self.assertRaises(TypeError):\n            append_user_header(['header_value'])\n\n    def test_dict_input(self):\n        # Test dictionary input (invalid type)\n        with self.assertRaises(TypeError):\n            append_user_header({'key': 'value'})", "num_test_cases": 12, "task_id": "f3d059aa"}
{"test": "import unittest\n\nclass TestCases(unittest.TestCase):\n    def test_case_1(self):\n        # Test with a normal string\n        header = 'HelloWorld'\n        result = add_response_header(header)\n        self.assertEqual(result, 'Custom-Header: HelloWorld')\n        self.assertIsInstance(result, str)\n\n    def test_case_2(self):\n        # Test with a string containing carriage return and newline at various positions\n        cr = chr(13)\n        lf = chr(10)\n        header = cr + lf + 'Start' + cr + 'Middle' + lf + 'End' + cr + lf\n        result = add_response_header(header)\n        self.assertEqual(result, 'Custom-Header: StartMiddleEnd')\n\n    def test_case_3(self):\n        # Test with an empty string\n        header = ''\n        result = add_response_header(header)\n        self.assertEqual(result, 'Custom-Header: ')\n\n    def test_case_4(self):\n        # Test with a string of only carriage return and newline\n        cr = chr(13)\n        lf = chr(10)\n        header = cr + lf + cr + lf\n        result = add_response_header(header)\n        self.assertEqual(result, 'Custom-Header: ')\n\n    def test_case_5(self):\n        # Test with a string containing spaces (and no control characters)\n        header = '  Hello  World  '\n        result = add_response_header(header)\n        self.assertEqual(result, 'Custom-Header:   Hello  World  ')\n\n    def test_case_6(self):\n        # Test with None (non-string) which should raise TypeError\n        with self.assertRaises(TypeError):\n            add_response_header(None)\n\n    def test_case_7(self):\n        # Test with integer (non-string) which should raise TypeError\n        with self.assertRaises(TypeError):\n            add_response_header(123)", "num_test_cases": 7, "task_id": "2f076eae"}
{"test": "import unittest\n\nclass TestCases(unittest.TestCase):\n    def test_normal_string(self):\n        \"\"\"Test with a normal string without control characters.\"\"\"\n        input_val = \"HelloWorld\"\n        expected = \"Custom-Header: HelloWorld\"\n        self.assertEqual(insert_header_with_sanitization(input_val), expected)\n    \n    def test_string_with_newline(self):\n        \"\"\"Test removal of newline character.\"\"\"\n        input_val = \"Hello\\nWorld\"\n        expected = \"Custom-Header: HelloWorld\"\n        self.assertEqual(insert_header_with_sanitization(input_val), expected)\n    \n    def test_string_with_carriage_return(self):\n        \"\"\"Test removal of carriage return character.\"\"\"\n        input_val = \"Hello\\rWorld\"\n        expected = \"Custom-Header: HelloWorld\"\n        self.assertEqual(insert_header_with_sanitization(input_val), expected)\n    \n    def test_string_with_crlf(self):\n        \"\"\"Test removal of CRLF sequence.\"\"\"\n        input_val = \"Hello\\r\\nWorld\"\n        expected = \"Custom-Header: HelloWorld\"\n        self.assertEqual(insert_header_with_sanitization(input_val), expected)\n    \n    def test_string_with_newline_at_ends(self):\n        \"\"\"Test removal of newlines at the start and end.\"\"\"\n        input_val = \"\\nHelloWorld\\n\"\n        expected = \"Custom-Header: HelloWorld\"\n        self.assertEqual(insert_header_with_sanitization(input_val), expected)\n    \n    def test_empty_string(self):\n        \"\"\"Test with an empty string input.\"\"\"\n        input_val = \"\"\n        expected = \"Custom-Header: \"\n        self.assertEqual(insert_header_with_sanitization(input_val), expected)\n    \n    def test_multiple_cr_nl(self):\n        \"\"\"Test removal of multiple consecutive CR and LF.\"\"\"\n        input_val = \"A\\r\\r\\n\\nB\"\n        expected = \"Custom-Header: AB\"\n        self.assertEqual(insert_header_with_sanitization(input_val), expected)\n    \n    def test_long_string(self):\n        \"\"\"Test with a long string containing CR and LF.\"\"\"\n        long_str = \"A\" * 500\n        modified_str = long_str[:100] + \"\\r\\n\" + long_str[100:200] + \"\\n\" + long_str[200:300] + \"\\r\" + long_str[300:]\n        sanitized_str = modified_str.replace('\\r', '').replace('\\n', '')\n        input_val = modified_str\n        expected = \"Custom-Header: \" + sanitized_str\n        self.assertEqual(insert_header_with_sanitization(input_val), expected)\n    \n    def test_non_ascii(self):\n        \"\"\"Test with non-ASCII characters.\"\"\"\n        input_val = \"Hëllö Wørld\"\n        expected = \"Custom-Header: Hëllö Wørld\"\n        self.assertEqual(insert_header_with_sanitization(input_val), expected)\n    \n    def test_tab_character(self):\n        \"\"\"Test that tab character is not removed.\"\"\"\n        input_val = \"Hello\\tWorld\"\n        expected = \"Custom-Header: Hello\\tWorld\"\n        self.assertEqual(insert_header_with_sanitization(input_val), expected)\n    \n    def test_none_input(self):\n        \"\"\"Test with None input (non-string).\"\"\"\n        with self.assertRaises(TypeError):\n            insert_header_with_sanitization(None)\n    \n    def test_non_string_input(self):\n        \"\"\"Test with non-string input (integer).\"\"\"\n        with self.assertRaises(TypeError):\n            insert_header_with_sanitization(123)", "num_test_cases": 12, "task_id": "b07a9617"}
{"test": "import unittest\n\nclass TestAddSafeHeader(unittest.TestCase):\n    \n    def test_case_1(self):\n        # Test normal string without special characters\n        result = add_safe_header('HelloWorld')\n        self.assertEqual(result, 'Custom-Header: HelloWorld')\n    \n    def test_case_2(self):\n        # Test string with newline in the middle\n        result = add_safe_header('Hello\\nWorld')\n        self.assertEqual(result, 'Custom-Header: HelloWorld')\n    \n    def test_case_3(self):\n        # Test string with carriage return at the end\n        result = add_safe_header('Hello World\\r')\n        self.assertEqual(result, 'Custom-Header: Hello World')\n    \n    def test_case_4(self):\n        # Test string with \\r\\n (Windows newline) in the middle\n        result = add_safe_header('Header\\r\\nInjection')\n        self.assertEqual(result, 'Custom-Header: HeaderInjection')\n    \n    def test_case_5(self):\n        # Test empty string\n        result = add_safe_header('')\n        self.assertEqual(result, 'Custom-Header: ')\n    \n    def test_case_6(self):\n        # Test string of only \\r\\n (so becomes empty after sanitization)\n        result = add_safe_header('\\r\\n')\n        self.assertEqual(result, 'Custom-Header: ')\n    \n    def test_case_7(self):\n        # Test non-ASCII string\n        result = add_safe_header('Héllø Wörld')\n        self.assertEqual(result, 'Custom-Header: Héllø Wörld')\n    \n    def test_case_8(self):\n        # Test long string without newlines\n        long_str = 'a' * 1000\n        result = add_safe_header(long_str)\n        self.assertEqual(result, 'Custom-Header: ' + long_str)\n    \n    def test_case_9(self):\n        # Test long string with newlines\n        long_str1 = 'a' * 500\n        long_str2 = 'b' * 500\n        input_str = long_str1 + '\\r\\n' + long_str2\n        result = add_safe_header(input_str)\n        self.assertEqual(result, 'Custom-Header: ' + long_str1 + long_str2)\n    \n    def test_case_10(self):\n        # Test non-string input: integer\n        with self.assertRaises(TypeError):\n            add_safe_header(123)\n    \n    def test_case_11(self):\n        # Test non-string input: None\n        with self.assertRaises(TypeError):\n            add_safe_header(None)\n    \n    def test_case_12(self):\n        # Test non-string input: list\n        with self.assertRaises(TypeError):\n            add_safe_header(['hello', 'world'])\n    \n    def test_case_13(self):\n        # Test string with null byte and newline\n        result = add_safe_header('Hello\\0\\nWorld')\n        self.assertEqual(result, 'Custom-Header: Hello\\0World')", "num_test_cases": 13, "task_id": "488785c6"}
{"test": "import unittest\nimport re\n\nclass TestCases(unittest.TestCase):\n    def test_case_1(self):\n        # Test normal string without special characters\n        result = inject_custom_header('Hello, World!')\n        self.assertIsInstance(result, str)\n        self.assertEqual(result, 'Custom-Header: Hello, World!')\n    \n    def test_case_2(self):\n        # Test string with newlines and carriage returns\n        result = inject_custom_header('Hello\\r\\nWorld')\n        self.assertIsInstance(result, str)\n        self.assertEqual(result, 'Custom-Header: HelloWorld')\n    \n    def test_case_3(self):\n        # Test empty string\n        result = inject_custom_header('')\n        self.assertIsInstance(result, str)\n        self.assertEqual(result, 'Custom-Header: ')\n    \n    def test_case_4(self):\n        # Test string with only newlines and carriage returns\n        result = inject_custom_header('\\r\\n\\r\\n')\n        self.assertIsInstance(result, str)\n        self.assertEqual(result, 'Custom-Header: ')\n    \n    def test_case_5(self):\n        # Test string with special characters\n        result = inject_custom_header('!@#$%^&*()_+')\n        self.assertIsInstance(result, str)\n        self.assertEqual(result, 'Custom-Header: !@#$%^&*()_+')\n    \n    def test_case_6(self):\n        # Test attempted header injection\n        result = inject_custom_header('value\\r\\nInjected-Header: injected')\n        self.assertIsInstance(result, str)\n        self.assertEqual(result, 'Custom-Header: valueInjected-Header: injected')\n    \n    def test_case_7(self):\n        # Test non-string input (integer)\n        with self.assertRaises(TypeError):\n            inject_custom_header(123)\n    \n    def test_case_8(self):\n        # Test non-string input (None)\n        with self.assertRaises(TypeError):\n            inject_custom_header(None)\n    \n    def test_case_9(self):\n        # Test long string without newlines\n        long_str = 'A' * 10000\n        result = inject_custom_header(long_str)\n        self.assertIsInstance(result, str)\n        self.assertEqual(result, 'Custom-Header: ' + long_str)\n    \n    def test_case_10(self):\n        # Test long string with newlines\n        long_str = 'A\\r\\n' * 10000\n        expected = 'Custom-Header: ' + ('A' * 10000)\n        result = inject_custom_header(long_str)\n        self.assertIsInstance(result, str)\n        self.assertEqual(result, expected)\n    \n    def test_case_11(self):\n        # Test string with tabs and spaces\n        result = inject_custom_header('Hello\\t \\r\\nWorld')\n        self.assertIsInstance(result, str)\n        self.assertEqual(result, 'Custom-Header: Hello\\t World')\n    \n    def test_case_12(self):\n        # Test non-ASCII string\n        result = inject_custom_header('Hëllö\\r\\nWörld')\n        self.assertIsInstance(result, str)\n        self.assertEqual(result, 'Custom-Header: HëllöWörld')", "num_test_cases": 12, "task_id": "280025c6"}
{"test": "import unittest\nfrom solution import insert_custom_header\n\nclass TestInsertCustomHeader(unittest.TestCase):\n    def test_normal_string(self):\n        # Test with normal string (no newlines or carriage returns)\n        result = insert_custom_header('Hello')\n        self.assertEqual(result, 'Custom-Header: Hello')\n\n    def test_string_with_newline(self):\n        # Test string containing a newline\n        s = 'Hello' + chr(10) + 'World'\n        result = insert_custom_header(s)\n        self.assertEqual(result, 'Custom-Header: HelloWorld')\n\n    def test_string_with_carriage_return(self):\n        # Test string containing a carriage return\n        s = 'Hello' + chr(13) + 'World'\n        result = insert_custom_header(s)\n        self.assertEqual(result, 'Custom-Header: HelloWorld')\n\n    def test_string_with_both(self):\n        # Test string containing both carriage return and newline\n        s = 'Hello' + chr(13) + chr(10) + 'World'\n        result = insert_custom_header(s)\n        self.assertEqual(result, 'Custom-Header: HelloWorld')\n\n    def test_string_with_leading_trailing_newlines(self):\n        # Test string with leading and trailing newlines and carriage returns\n        s = chr(10) + 'Hello' + chr(13)\n        result = insert_custom_header(s)\n        self.assertEqual(result, 'Custom-Header: Hello')\n\n    def test_empty_string(self):\n        # Test empty string\n        result = insert_custom_header('')\n        self.assertEqual(result, 'Custom-Header: ')\n\n    def test_long_string(self):\n        # Test a long string without any newlines\n        long_str = 'A' * 1000\n        result = insert_custom_header(long_str)\n        self.assertEqual(result, 'Custom-Header: ' + long_str)\n\n    def test_non_string_integer(self):\n        # Test non-string input (integer)\n        with self.assertRaises(TypeError):\n            insert_custom_header(123)\n\n    def test_non_string_none(self):\n        # Test non-string input (None)\n        with self.assertRaises(TypeError):\n            insert_custom_header(None)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 9, "task_id": "df2113a6"}
