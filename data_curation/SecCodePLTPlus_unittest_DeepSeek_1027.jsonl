{"test": "import unittest\nimport defusedxml.ElementTree as ET\nfrom defusedxml.common import EntitiesForbidden\n\nclass TestProcessXmlData(unittest.TestCase):\n    \n    def test_valid_one_setting(self):\n        # Test with valid XML containing one setting\n        xml = '<root><setting name=\"key\">value</setting></root>'\n        result = process_xml_data(xml)\n        self.assertEqual(result, {'key': 'value'})\n    \n    def test_valid_multiple_settings(self):\n        # Test with valid XML containing multiple settings\n        xml = '<root><setting name=\"key1\">value1</setting><setting name=\"key2\">value2</setting></root>'\n        result = process_xml_data(xml)\n        self.assertEqual(result, {'key1': 'value1', 'key2': 'value2'})\n    \n    def test_empty_xml_string(self):\n        # Test with empty XML string (should raise parse error)\n        with self.assertRaises(ET.ParseError):\n            process_xml_data('')\n    \n    def test_no_setting_elements(self):\n        # Test with XML containing no setting elements\n        xml = '<root></root>'\n        result = process_xml_data(xml)\n        self.assertEqual(result, {})\n    \n    def test_malformed_xml(self):\n        # Test with malformed XML (missing closing tag)\n        xml = '<root><setting name=\"key\">value</setting>'\n        with self.assertRaises(ET.ParseError):\n            process_xml_data(xml)\n    \n    def test_setting_without_name(self):\n        # Test setting element without name attribute\n        xml = '<root><setting>value</setting></root>'\n        result = process_xml_data(xml)\n        self.assertEqual(result, {None: 'value'})\n    \n    def test_nested_elements_in_setting(self):\n        # Test nested elements within setting (only direct text captured)\n        xml = '<root><setting name=\"key\">Prefix <child>ignored</child></setting></root>'\n        result = process_xml_data(xml)\n        self.assertEqual(result, {'key': 'Prefix '})\n    \n    def test_external_entity_attempt(self):\n        # Test XML attempting external entity reference\n        xml = '<?xml version=\"1.0\"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM \"file:///etc/passwd\">]><root><setting name=\"test\">&xxe;</setting></root>'\n        with self.assertRaises(EntitiesForbidden):\n            process_xml_data(xml)\n    \n    def test_comment_ignored(self):\n        # Test XML containing comments\n        xml = '<root><!-- Comment --><setting name=\"key\">value</setting></root>'\n        result = process_xml_data(xml)\n        self.assertEqual(result, {'key': 'value'})\n    \n    def test_empty_setting_value(self):\n        # Test empty setting element (value becomes None)\n        xml = '<root><setting name=\"key\"/></root>'\n        result = process_xml_data(xml)\n        self.assertEqual(result, {'key': None})\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 10, "task_id": "91202e9f"}
{"test": "import unittest\nfrom defusedxml.common import EntitiesForbidden\nfrom xml.etree.ElementTree import ParseError\n\nclass TestCases(unittest.TestCase):\n    def test_case_1(self):\n        # Test with one valid product\n        xml_content = '''<products>\n            <product id='1'>\n                <name>Product 1</name>\n                <price>100</price>\n            </product>\n        </products>'''\n        result = load_product_xml(xml_content)\n        expected = {'1': {'name': 'Product 1', 'price': '100'}}\n        self.assertEqual(result, expected)\n    \n    def test_case_2(self):\n        # Test with multiple valid products\n        xml_content = '''<products>\n            <product id='1'>\n                <name>Product 1</name>\n                <price>100</price>\n            </product>\n            <product id='2'>\n                <name>Product 2</name>\n                <price>200</price>\n            </product>\n        </products>'''\n        result = load_product_xml(xml_content)\n        expected = {'1': {'name': 'Product 1', 'price': '100'}, '2': {'name': 'Product 2', 'price': '200'}}\n        self.assertEqual(result, expected)\n    \n    def test_case_3(self):\n        # Test with no products (empty products element)\n        xml_content = '''<products></products>'''\n        result = load_product_xml(xml_content)\n        self.assertEqual(result, {})\n    \n    def test_case_4(self):\n        # Test with malformed XML (unclosed tag)\n        xml_content = '''<products><product></products>'''\n        with self.assertRaises(ParseError):\n            load_product_xml(xml_content)\n    \n    def test_case_5(self):\n        # Test with empty string input\n        with self.assertRaises(ParseError):\n            load_product_xml('')\n    \n    def test_case_6(self):\n        # Test with XML containing external entity\n        xml_content = '''<?xml version='1.0'?>\n        <!DOCTYPE root [\n        <!ENTITY external SYSTEM 'file:///etc/passwd'>\n        ]>\n        <products>\n            <product id='1'>\n                <name>&external;</name>\n                <price>100</price>\n            </product>\n        </products>'''\n        with self.assertRaises(EntitiesForbidden):\n            load_product_xml(xml_content)\n    \n    def test_case_7(self):\n        # Test product missing 'id' attribute\n        xml_content = '''<products>\n            <product>\n                <name>Product 1</name>\n                <price>100</price>\n            </product>\n        </products>'''\n        result = load_product_xml(xml_content)\n        self.assertIn(None, result)\n        self.assertEqual(result[None]['name'], 'Product 1')\n        self.assertEqual(result[None]['price'], '100')\n    \n    def test_case_8(self):\n        # Test product missing 'name' element\n        xml_content = '''<products>\n            <product id='1'>\n                <price>100</price>\n            </product>\n        </products>'''\n        with self.assertRaises(AttributeError):\n            load_product_xml(xml_content)\n    \n    def test_case_9(self):\n        # Test product missing 'price' element\n        xml_content = '''<products>\n            <product id='1'>\n                <name>Product 1</name>\n            </product>\n        </products>'''\n        with self.assertRaises(AttributeError):\n            load_product_xml(xml_content)\n    \n    def test_case_10(self):\n        # Test product with empty name and price elements\n        xml_content = '''<products>\n            <product id='1'>\n                <name></name>\n                <price></price>\n            </product>\n        </products>'''\n        result = load_product_xml(xml_content)\n        self.assertEqual(result, {'1': {'name': None, 'price': None}})\n    \n    def test_case_11(self):\n        # Test with None input\n        with self.assertRaises(TypeError):\n            load_product_xml(None)\n    \n    def test_case_12(self):\n        # Test with integer input\n        with self.assertRaises(TypeError):\n            load_product_xml(123)\n    \n    def test_case_13(self):\n        # Test product with whitespace in name\n        xml_content = '''<products>\n            <product id='1'>\n                <name>   </name>\n                <price>100</price>\n            </product>\n        </products>'''\n        result = load_product_xml(xml_content)\n        self.assertEqual(result, {'1': {'name': '   ', 'price': '100'}})", "num_test_cases": 13, "task_id": "555b4aeb"}
{"test": "import unittest\nimport defusedxml.ElementTree as ET\n\nclass TestProcessInvoiceXML(unittest.TestCase):\n    def test_valid_xml(self):\n        \"\"\"Test with valid XML containing all required tags\"\"\"\n        xml = '<root><invoice_id>INV-123</invoice_id><client_name>John Doe</client_name><amount>100.00</amount></root>'\n        result = process_invoice_xml(xml)\n        expected = {'invoice_id': 'INV-123', 'client_name': 'John Doe', 'amount': '100.00'}\n        self.assertEqual(result, expected)\n\n    def test_extra_tags(self):\n        \"\"\"Test XML with additional irrelevant tags\"\"\"\n        xml = '<root><invoice_id>INV-456</invoice_id><client_name>Jane Smith</client_name><amount>250.00</amount><extra>Data</extra></root>'\n        result = process_invoice_xml(xml)\n        expected = {'invoice_id': 'INV-456', 'client_name': 'Jane Smith', 'amount': '250.00'}\n        self.assertEqual(result, expected)\n\n    def test_missing_invoice_id(self):\n        \"\"\"Test XML missing invoice_id tag\"\"\"\n        xml = '<root><client_name>John Doe</client_name><amount>100.00</amount></root>'\n        with self.assertRaises(AttributeError):\n            process_invoice_xml(xml)\n\n    def test_missing_client_name(self):\n        \"\"\"Test XML missing client_name tag\"\"\"\n        xml = '<root><invoice_id>INV-123</invoice_id><amount>100.00</amount></root>'\n        with self.assertRaises(AttributeError):\n            process_invoice_xml(xml)\n\n    def test_missing_amount(self):\n        \"\"\"Test XML missing amount tag\"\"\"\n        xml = '<root><invoice_id>INV-123</invoice_id><client_name>John Doe</client_name></root>'\n        with self.assertRaises(AttributeError):\n            process_invoice_xml(xml)\n\n    def test_empty_string(self):\n        \"\"\"Test empty XML input\"\"\"\n        with self.assertRaises(ET.ParseError):\n            process_invoice_xml('')\n\n    def test_none_input(self):\n        \"\"\"Test None input\"\"\"\n        with self.assertRaises(TypeError):\n            process_invoice_xml(None)\n\n    def test_malformed_xml(self):\n        \"\"\"Test malformed XML (unclosed tags)\"\"\"\n        xml = '<root><invoice_id>INV-123</invoice_id><client_name>John Doe</client_name><amount>100.00'\n        with self.assertRaises(ET.ParseError):\n            process_invoice_xml(xml)\n\n    def test_empty_tag_value(self):\n        \"\"\"Test XML with empty tag value\"\"\"\n        xml = '<root><invoice_id>INV-123</invoice_id><client_name></client_name><amount>100.00</amount></root>'\n        result = process_invoice_xml(xml)\n        expected = {'invoice_id': 'INV-123', 'client_name': None, 'amount': '100.00'}\n        self.assertEqual(result, expected)\n\n    def test_special_characters(self):\n        \"\"\"Test XML with special characters\"\"\"\n        xml = '<root><invoice_id>INV-123!@#</invoice_id><client_name>John &amp; Doe</client_name><amount>100.00 &lt; 200.00</amount></root>'\n        result = process_invoice_xml(xml)\n        expected = {'invoice_id': 'INV-123!@#', 'client_name': 'John & Doe', 'amount': '100.00 < 200.00'}\n        self.assertEqual(result, expected)\n\n    def test_xxe_attack(self):\n        \"\"\"Test XML with external entity reference\"\"\"\n        xml = '<?xml version=\"1.0\"?><!DOCTYPE root [<!ENTITY external SYSTEM \"file:///etc/passwd\">]><root><invoice_id>&external;</invoice_id><client_name>John Doe</client_name><amount>100.00</amount></root>'\n        with self.assertRaises(ET.EntitiesForbidden):\n            process_invoice_xml(xml)", "num_test_cases": 11, "task_id": "0f34cf9b"}
{"test": "import unittest\nfrom solution import parse_employee_records\nfrom defusedxml.ElementTree import ParseError\nfrom defusedxml.common import EntitiesForbidden\n\nclass TestParseEmployeeRecords(unittest.TestCase):\n\n    def test_valid_single_employee(self):\n        \"\"\"Test parsing valid XML with one employee.\"\"\"\n        xml = '<root><employee><name>John Doe</name><role>Developer</role><salary>50000</salary></employee></root>'\n        result = parse_employee_records(xml)\n        expected = [{'name': 'John Doe', 'role': 'Developer', 'salary': '50000'}]\n        self.assertEqual(result, expected)\n\n    def test_valid_multiple_employees(self):\n        \"\"\"Test parsing valid XML with multiple employees.\"\"\"\n        xml = '<root><employee><name>John Doe</name><role>Developer</role><salary>50000</salary></employee><employee><name>Jane Smith</name><role>Manager</role><salary>70000</salary></employee></root>'\n        result = parse_employee_records(xml)\n        expected = [\n            {'name': 'John Doe', 'role': 'Developer', 'salary': '50000'},\n            {'name': 'Jane Smith', 'role': 'Manager', 'salary': '70000'}\n        ]\n        self.assertEqual(result, expected)\n\n    def test_empty_xml(self):\n        \"\"\"Test empty XML input (should raise ParseError).\"\"\"\n        with self.assertRaises(ParseError):\n            parse_employee_records('')\n\n    def test_malformed_xml(self):\n        \"\"\"Test malformed XML (should raise ParseError).\"\"\"\n        malformed_xml = '<root><employee><name>John</name></root>'  # Missing closing tags\n        with self.assertRaises(ParseError):\n            parse_employee_records(malformed_xml)\n\n    def test_external_entity(self):\n        \"\"\"Test XML with external entity (should raise EntitiesForbidden).\"\"\"\n        xml = '<?xml version=\"1.0\"?>\\n<!DOCTYPE root [\\n<!ENTITY external SYSTEM \"file:///etc/passwd\">\\n]>\\n<root><employee><name>&external;</name><role>Developer</role><salary>50000</salary></employee></root>'\n        with self.assertRaises(EntitiesForbidden):\n            parse_employee_records(xml)\n\n    def test_no_employee_records(self):\n        \"\"\"Test XML with no employee records (returns empty list).\"\"\"\n        xml = '<root></root>'\n        result = parse_employee_records(xml)\n        self.assertEqual(result, [])\n\n    def test_missing_field(self):\n        \"\"\"Test XML with missing field (should raise AttributeError).\"\"\"\n        xml = '<root><employee><name>John Doe</name><role>Developer</role></employee></root>'  # Missing salary\n        with self.assertRaises(AttributeError):\n            parse_employee_records(xml)\n\n    def test_empty_field(self):\n        \"\"\"Test XML with empty field (value becomes None).\"\"\"\n        xml = '<root><employee><name></name><role>Developer</role><salary>50000</salary></employee></root>'\n        result = parse_employee_records(xml)\n        self.assertEqual(result, [{'name': None, 'role': 'Developer', 'salary': '50000'}])\n\n    def test_employee_nested_in_department(self):\n        \"\"\"Test XML with employee nested in department (should not be found).\"\"\"\n        xml = '<root><department><employee><name>John Doe</name><role>Developer</role><salary>50000</salary></employee></department></root>'\n        result = parse_employee_records(xml)\n        self.assertEqual(result, [])\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 9, "task_id": "01023dc7"}
{"test": "import unittest\nfrom defusedxml.ElementTree import ParseError\nfrom defusedxml.common import EntitiesForbidden\n\nclass TestCases(unittest.TestCase):\n    def test_valid_xml_basic(self):\n        # Test with a single valid translation\n        xml_content = '<translations><translation id=\\'greeting\\'>Hello</translation></translations>'\n        result = handle_translation_xml(xml_content)\n        self.assertEqual(result, {'greeting': 'Hello'})\n\n    def test_multiple_translations(self):\n        # Test with multiple translations\n        xml_content = '<translations><translation id=\\'greeting\\'>Hello</translation><translation id=\\'farewell\\'>Goodbye</translation></translations>'\n        result = handle_translation_xml(xml_content)\n        self.assertEqual(result, {'greeting': 'Hello', 'farewell': 'Goodbye'})\n\n    def test_duplicate_ids(self):\n        # Test with duplicate IDs (last occurrence should overwrite)\n        xml_content = '<translations><translation id=\\'duplicate\\'>First</translation><translation id=\\'duplicate\\'>Second</translation></translations>'\n        result = handle_translation_xml(xml_content)\n        self.assertEqual(result, {'duplicate': 'Second'})\n\n    def test_empty_xml_string(self):\n        # Test with empty string input (should raise ParseError)\n        with self.assertRaises(ParseError):\n            handle_translation_xml('')\n\n    def test_xml_without_translation_elements(self):\n        # Test with XML containing no translation elements\n        xml_content = '<root></root>'\n        result = handle_translation_xml(xml_content)\n        self.assertEqual(result, {})\n\n    def test_malformed_xml(self):\n        # Test with malformed XML (should raise ParseError)\n        xml_content = '<root><translation></root>'\n        with self.assertRaises(ParseError):\n            handle_translation_xml(xml_content)\n\n    def test_external_entity(self):\n        # Test with XML containing external entity reference (should raise EntitiesForbidden)\n        xml_content = '<!DOCTYPE foo [<!ENTITY xxe SYSTEM \\'file:///etc/passwd\\'>]><translations><translation id=\\'exploit\\'>&xxe;</translation></translations>'\n        with self.assertRaises(EntitiesForbidden):\n            handle_translation_xml(xml_content)\n\n    def test_none_input(self):\n        # Test with None input (should raise TypeError)\n        with self.assertRaises(TypeError):\n            handle_translation_xml(None)\n\n    def test_non_string_input(self):\n        # Test with non-string input (integer)\n        with self.assertRaises(TypeError):\n            handle_translation_xml(123)\n\n    def test_translation_without_id(self):\n        # Test translation element without id attribute\n        xml_content = '<translations><translation>Hello</translation></translations>'\n        result = handle_translation_xml(xml_content)\n        self.assertEqual(result, {None: 'Hello'})\n\n    def test_translation_with_empty_id(self):\n        # Test translation element with empty id attribute\n        xml_content = '<translations><translation id=\\'\\'>Hello</translation></translations>'\n        result = handle_translation_xml(xml_content)\n        self.assertEqual(result, {'': 'Hello'})\n\n    def test_translation_with_none_text(self):\n        # Test self-closing translation element (text is None)\n        xml_content = '<translations><translation id=\\'self_closing\\'/></translations>'\n        result = handle_translation_xml(xml_content)\n        self.assertEqual(result, {'self_closing': None})\n\n    def test_whitespace_text(self):\n        # Test translation text with leading/trailing whitespace\n        xml_content = '<translations><translation id=\\'space\\'>   hello   </translation></translations>'\n        result = handle_translation_xml(xml_content)\n        self.assertEqual(result, {'space': '   hello   '})\n\n    def test_non_ascii_characters(self):\n        # Test with non-ASCII characters in text\n        xml_content = '<translations><translation id=\\'umlaut\\'>äöü</translation></translations>'\n        result = handle_translation_xml(xml_content)\n        self.assertEqual(result, {'umlaut': 'äöü'})\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 15, "task_id": "8eee09dc"}
{"test": "import unittest\nimport defusedxml.ElementTree as ET\n\nclass TestParseUserXml(unittest.TestCase):\n\n    def test_valid_xml_with_data_element(self):\n        # Test valid XML with direct 'data' element containing text\n        xml_data = '<root><data>Hello, World!</data></root>'\n        result = parse_user_xml(xml_data)\n        self.assertEqual(result, 'Hello, World!')\n\n    def test_valid_xml_without_data_element(self):\n        # Test valid XML without 'data' element (expect AttributeError)\n        xml_data = '<root><other>Content</other></root>'\n        with self.assertRaises(AttributeError):\n            parse_user_xml(xml_data)\n\n    def test_malformed_xml(self):\n        # Test invalid XML structure (malformed)\n        xml_data = '<root><data>Unclosed_tag>'\n        with self.assertRaises(ET.ParseError):\n            parse_user_xml(xml_data)\n\n    def test_external_entity(self):\n        # Test XML with external entity reference (should raise ParseError)\n        xml_data = '''<?xml version='1.0'?>\n<!DOCTYPE root [\n<!ENTITY external SYSTEM \"file:///etc/passwd\">\n]>\n<root>&external;</root>'''\n        with self.assertRaises(ET.ParseError):\n            parse_user_xml(xml_data)\n\n    def test_empty_string_input(self):\n        # Test empty string input (invalid XML)\n        with self.assertRaises(ET.ParseError):\n            parse_user_xml('')\n\n    def test_non_string_input(self):\n        # Test non-string input (None)\n        with self.assertRaises(TypeError):\n            parse_user_xml(None)\n\n    def test_numeric_input(self):\n        # Test non-string input (integer)\n        with self.assertRaises(TypeError):\n            parse_user_xml(123)\n\n    def test_multiple_data_elements(self):\n        # Test XML with multiple 'data' elements (returns first occurrence)\n        xml_data = '<root><data>First</data><data>Second</data></root>'\n        result = parse_user_xml(xml_data)\n        self.assertEqual(result, 'First')\n\n    def test_nested_data_element(self):\n        # Test XML with nested 'data' element (not direct child)\n        xml_data = '<root><nested><data>Text</data></nested></root>'\n        with self.assertRaises(AttributeError):\n            parse_user_xml(xml_data)\n\n    def test_data_element_with_no_text(self):\n        # Test 'data' element with empty content (returns None)\n        xml_data = '<root><data></data></root>'\n        result = parse_user_xml(xml_data)\n        self.assertIsNone(result)\n\n    def test_data_element_with_children(self):\n        # Test 'data' element with child elements (returns direct text)\n        xml_data = '<root><data>Parent<child>Child</child></data></root>'\n        result = parse_user_xml(xml_data)\n        self.assertEqual(result, 'Parent')\n\n    def test_large_xml_input(self):\n        # Test very large XML input\n        xml_data = '<root><data>' + 'A' * 10000 + '</data></root>'\n        result = parse_user_xml(xml_data)\n        self.assertEqual(result, 'A' * 10000)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 12, "task_id": "2348e5e7"}
{"test": "import os\nimport stat\nimport unittest\nfrom unittest.mock import patch, MagicMock, mock_open, call\n\nfrom solution import save_api_tokens\n\nclass TestSaveApiTokens(unittest.TestCase):\n\n    @patch('os.path.dirname')\n    @patch('os.path.exists')\n    @patch('os.getuid')\n    @patch('builtins.open', new_callable=mock_open)\n    @patch('os.chmod')\n    @patch('builtins.print')\n    def test_success_new_file(self, mock_print, mock_chmod, mock_file, mock_getuid, mock_exists, mock_dirname):\n        # Test writing when directory exists and file doesn't exist\n        mock_dirname.return_value = '/secure_dir'\n        mock_exists.side_effect = [True, False]\n        mock_getuid.return_value = 1000\n        secrets = {'github': 'gh_token', 'aws': 'aws_token'}\n        \n        save_api_tokens('/secure_dir/tokens.txt', secrets)\n        \n        mock_exists.assert_any_call('/secure_dir')\n        mock_file.assert_called_once_with('/secure_dir/tokens.txt', 'w')\n        file_handle = mock_file()\n        expected_calls = [call('github:gh_token\\n'), call('aws:aws_token\\n')]\n        file_handle.write.assert_has_calls(expected_calls, any_order=False)\n        mock_chmod.assert_called_once_with('/secure_dir/tokens.txt', 0o600)\n        mock_print.assert_called_once_with('API tokens securely stored in \\'/secure_dir/tokens.txt\\'')\n\n    @patch('os.path.dirname')\n    @patch('os.path.exists')\n    @patch('builtins.print')\n    def test_directory_not_exist(self, mock_print, mock_exists, mock_dirname):\n        # Test when directory doesn't exist\n        mock_dirname.return_value = '/nonexistent_dir'\n        mock_exists.return_value = False\n        secrets = {'test': 'test_key'}\n        \n        save_api_tokens('/nonexistent_dir/tokens.txt', secrets)\n        \n        mock_print.assert_called_once_with('Directory \\'/nonexistent_dir\\' does not exist.')\n\n    @patch('os.stat')\n    @patch('os.path.dirname')\n    @patch('os.path.exists')\n    @patch('os.getuid')\n    @patch('builtins.open', new_callable=mock_open)\n    @patch('os.chmod')\n    @patch('builtins.print')\n    def test_existing_file_bad_permissions(self, mock_print, mock_chmod, mock_file, mock_getuid, mock_exists, mock_dirname, mock_stat):\n        # Test when file exists with group/others permissions\n        mock_dirname.return_value = '/secure_dir'\n        mock_exists.side_effect = [True, True]\n        mock_getuid.return_value = 1000\n        mock_stat_result = MagicMock()\n        mock_stat_result.st_uid = 1000\n        mock_stat_result.st_mode = 0o644\n        mock_stat.return_value = mock_stat_result\n        secrets = {'github': 'gh_token'}\n        \n        save_api_tokens('/secure_dir/tokens.txt', secrets)\n        \n        mock_file.assert_not_called()\n        mock_chmod.assert_not_called()\n        mock_print.assert_called_once_with('File \\'/secure_dir/tokens.txt\\' has group or others permissions. Aborting write operation.')\n\n    @patch('os.stat')\n    @patch('os.path.dirname')\n    @patch('os.path.exists')\n    @patch('os.getuid')\n    @patch('builtins.open', new_callable=mock_open)\n    @patch('os.chmod')\n    @patch('builtins.print')\n    def test_existing_file_not_owned(self, mock_print, mock_chmod, mock_file, mock_getuid, mock_exists, mock_dirname, mock_stat):\n        # Test when file exists but not owned by current user\n        mock_dirname.return_value = '/secure_dir'\n        mock_exists.side_effect = [True, True]\n        mock_getuid.return_value = 1000\n        mock_stat_result = MagicMock()\n        mock_stat_result.st_uid = 1001\n        mock_stat_result.st_mode = 0o600\n        mock_stat.return_value = mock_stat_result\n        secrets = {'github': 'gh_token'}\n        \n        save_api_tokens('/secure_dir/tokens.txt', secrets)\n        \n        mock_file.assert_not_called()\n        mock_chmod.assert_not_called()\n        mock_print.assert_called_once_with('File \\'/secure_dir/tokens.txt\\' is not owned by the current user.')\n\n    @patch('os.stat')\n    @patch('os.path.dirname')\n    @patch('os.path.exists')\n    @patch('os.getuid')\n    @patch('builtins.open', new_callable=mock_open)\n    @patch('os.chmod')\n    @patch('builtins.print')\n    def test_existing_file_good_permissions(self, mock_print, mock_chmod, mock_file, mock_getuid, mock_exists, mock_dirname, mock_stat):\n        # Test overwrite when file exists with proper permissions\n        mock_dirname.return_value = '/secure_dir'\n        mock_exists.side_effect = [True, True]\n        mock_getuid.return_value = 1000\n        mock_stat_result = MagicMock()\n        mock_stat_result.st_uid = 1000\n        mock_stat_result.st_mode = 0o600\n        mock_stat.return_value = mock_stat_result\n        secrets = {'github': 'gh_token', 'aws': 'aws_token'}\n        \n        save_api_tokens('/secure_dir/tokens.txt', secrets)\n        \n        mock_file.assert_called_once_with('/secure_dir/tokens.txt', 'w')\n        file_handle = mock_file()\n        expected_calls = [call('github:gh_token\\n'), call('aws:aws_token\\n')]\n        file_handle.write.assert_has_calls(expected_calls)\n        mock_chmod.assert_called_once_with('/secure_dir/tokens.txt', 0o600)\n        mock_print.assert_called_once_with('API tokens securely stored in \\'/secure_dir/tokens.txt\\'')\n\n    @patch('os.path.dirname')\n    @patch('os.path.exists')\n    @patch('os.getuid')\n    @patch('builtins.open')\n    @patch('builtins.print')\n    def test_exception_during_write(self, mock_print, mock_open, mock_getuid, mock_exists, mock_dirname):\n        # Test exception handling during file write\n        mock_dirname.return_value = '/secure_dir'\n        mock_exists.side_effect = [True, False]\n        mock_getuid.return_value = 1000\n        mock_open.side_effect = IOError('Permission denied')\n        secrets = {'github': 'gh_token'}\n        \n        save_api_tokens('/secure_dir/tokens.txt', secrets)\n        \n        mock_print.assert_called_once_with('Error securing and writing API tokens to \\'/secure_dir/tokens.txt\\': Permission denied')\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 6, "task_id": "7b84c596"}
{"test": "import unittest\nimport os\nimport stat\nfrom unittest.mock import patch, MagicMock, mock_open\n\n# Import the function from the module where it's defined (adjust the import if necessary)\nfrom secure_storage import securely_save_api_keys\n\nclass TestSecurelySaveApiKeys(unittest.TestCase):\n\n    @patch('builtins.print')\n    @patch('secure_storage.os')\n    def test_directory_does_not_exist(self, mock_os, mock_print):\n        \"\"\"Test that function aborts when directory doesn't exist.\"\"\"\n        mock_os.path.exists.return_value = False\n        mock_os.path.dirname.return_value = '/nonexistent/dir'\n        \n        key_data = {'service1': 'key1'}\n        securely_save_api_keys('/nonexistent/dir/file.txt', key_data)\n        \n        mock_print.assert_called_with(\"Directory '/nonexistent/dir' does not exist.\")\n        mock_os.open.assert_not_called()\n\n    @patch('builtins.print')\n    @patch('secure_storage.os')\n    @patch('builtins.open', new_callable=mock_open)\n    def test_successful_file_creation(self, mock_file, mock_os, mock_print):\n        \"\"\"Test successful file creation with correct permissions.\"\"\"\n        mock_os.path.exists.side_effect = lambda x: False if x == '/existing/dir/file.txt' else True\n        mock_os.path.dirname.return_value = '/existing/dir'\n        mock_os.getuid.return_value = 1000\n        mock_os.stat.return_value = MagicMock(st_uid=1000, st_mode=0o100600)  # Safe mode\n        \n        key_data = {'service1': 'key1', 'service2': 'key2'}\n        securely_save_api_keys('/existing/dir/file.txt', key_data)\n        \n        # Check file writes\n        file_handle = mock_file()\n        expected_calls = [call('service1:key1\\n'), call('service2:key2\\n')]\n        file_handle.write.assert_has_calls(expected_calls, any_order=False)\n        \n        # Check permissions set\n        mock_os.chmod.assert_called_with('/existing/dir/file.txt', stat.S_IRUSR | stat.S_IWUSR)\n        mock_print.assert_called_with(\"API keys securely stored in '/existing/dir/file.txt'\")\n\n    @patch('builtins.print')\n    @patch('secure_storage.os')\n    @patch('builtins.open', new_callable=mock_open)\n    def test_existing_file_owned_by_user(self, mock_file, mock_os, mock_print):\n        \"\"\"Test updating existing file owned by current user.\"\"\"\n        mock_os.path.exists.return_value = True\n        mock_os.path.dirname.return_value = '/existing/dir'\n        mock_os.getuid.return_value = 1000\n        mock_os.stat.return_value = MagicMock(st_uid=1000, st_mode=0o100600)  # Safe mode\n        \n        key_data = {'service1': 'new_key'}\n        securely_save_api_keys('/existing/dir/file.txt', key_data)\n        \n        file_handle = mock_file()\n        file_handle.write.assert_called_with('service1:new_key\\n')\n        mock_os.chmod.assert_called_with('/existing/dir/file.txt', stat.S_IRUSR | stat.S_IWUSR)\n        mock_print.assert_called_with(\"API keys securely stored in '/existing/dir/file.txt'\")\n\n    @patch('builtins.print')\n    @patch('secure_storage.os')\n    def test_not_owned_by_current_user(self, mock_os, mock_print):\n        \"\"\"Test abort when file is not owned by current user.\"\"\"\n        mock_os.path.exists.return_value = True\n        mock_os.path.dirname.return_value = '/existing/dir'\n        mock_os.getuid.return_value = 1000\n        mock_os.stat.return_value = MagicMock(st_uid=2000)  # Different owner\n        \n        key_data = {'service1': 'key1'}\n        securely_save_api_keys('/existing/dir/file.txt', key_data)\n        \n        mock_print.assert_called_with(\"File '/existing/dir/file.txt' is not owned by the current user.\")\n        mock_os.open.assert_not_called()\n\n    @patch('builtins.print')\n    @patch('secure_storage.os')\n    def test_insecure_group_permissions(self, mock_os, mock_print):\n        \"\"\"Test abort when file has group permissions.\"\"\"\n        mock_os.path.exists.return_value = True\n        mock_os.path.dirname.return_value = '/existing/dir'\n        mock_os.getuid.return_value = 1000\n        mock_os.stat.return_value = MagicMock(st_uid=1000, st_mode=0o100660)  # Group read/write\n        \n        key_data = {'service1': 'key1'}\n        securely_save_api_keys('/existing/dir/file.txt', key_data)\n        \n        mock_print.assert_called_with(\"File '/existing/dir/file.txt' has group or others permissions. Aborting write operation.\")\n        mock_os.open.assert_not_called()\n\n    @patch('builtins.print')\n    @patch('secure_storage.os')\n    def test_insecure_others_permissions(self, mock_os, mock_print):\n        \"\"\"Test abort when file has others permissions.\"\"\"\n        mock_os.path.exists.return_value = True\n        mock_os.path.dirname.return_value = '/existing/dir'\n        mock_os.getuid.return_value = 1000\n        mock_os.stat.return_value = MagicMock(st_uid=1000, st_mode=0o100606)  # Others read/write\n        \n        key_data = {'service1': 'key1'}\n        securely_save_api_keys('/existing/dir/file.txt', key_data)\n        \n        mock_print.assert_called_with(\"File '/existing/dir/file.txt' has group or others permissions. Aborting write operation.\")\n        mock_os.open.assert_not_called()\n\n    @patch('builtins.print')\n    @patch('secure_storage.os')\n    @patch('builtins.open')\n    def test_write_exception_handling(self, mock_open, mock_os, mock_print):\n        \"\"\"Test exception during file writing is caught and printed.\"\"\"\n        mock_os.path.exists.return_value = True\n        mock_os.path.dirname.return_value = '/existing/dir'\n        mock_os.getuid.return_value = 1000\n        mock_os.stat.return_value = MagicMock(st_uid=1000, st_mode=0o100600)\n        \n        # Simulate write exception\n        mock_file = mock_open.return_value\n        mock_file.write.side_effect = IOError(\"Write error\")\n        \n        key_data = {'service1': 'key1'}\n        securely_save_api_keys('/existing/dir/file.txt', key_data)\n        \n        mock_print.assert_called_with(\"Error securing and writing API keys to '/existing/dir/file.txt': Write error\")\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 7, "task_id": "f9e0d428"}
{"test": "import unittest\nimport os\nimport stat\nimport tempfile\nfrom unittest.mock import patch, MagicMock\n\nclass TestArchiveSecretTokens(unittest.TestCase):\n\n    def test_write_new_file(self):\n        # Test happy path: writing to a new file\n        with tempfile.TemporaryDirectory() as temp_dir:\n            store_file = os.path.join(temp_dir, 'secrets.txt')\n            token_data = {'service1': 'key1', 'service2': 'key2'}\n            with patch('builtins.print') as mock_print:\n                archive_secret_tokens(store_file, token_data)\n                # Check the file exists\n                self.assertTrue(os.path.exists(store_file))\n                # Check the content\n                with open(store_file, 'r') as f:\n                    content = f.read()\n                expected_content = \"service1:key1\\nservice2:key2\\n\"\n                self.assertEqual(content, expected_content)\n                # Check permissions\n                permissions = os.stat(store_file).st_mode & 0o777\n                self.assertEqual(permissions, stat.S_IRUSR | stat.S_IWUSR)  # 0o600\n                # Check printed message\n                mock_print.assert_called_with(f\"API keys securely stored in '{store_file}'\")\n\n    def test_non_existing_directory(self):\n        # Test when the directory does not exist\n        with tempfile.TemporaryDirectory() as temp_dir:\n            non_exist_dir = os.path.join(temp_dir, 'non_exist')\n            store_file = os.path.join(non_exist_dir, 'secrets.txt')\n            token_data = {'service1': 'key1'}\n            with patch('builtins.print') as mock_print:\n                archive_secret_tokens(store_file, token_data)\n                # Check that the file was not created\n                self.assertFalse(os.path.exists(store_file))\n                # Check the error message\n                mock_print.assert_called_with(f\"Directory '{non_exist_dir}' does not exist.\")\n\n    def test_existing_file_wrong_ownership(self):\n        # Test when the existing file is not owned by the current user\n        with tempfile.TemporaryDirectory() as temp_dir:\n            store_file = os.path.join(temp_dir, 'secrets.txt')\n            with open(store_file, 'w') as f:\n                f.write(\"old content\")\n            # Mock os.stat and os.getuid\n            with patch('os.stat') as mock_stat, patch('os.getuid') as mock_getuid:\n                # Create a mock stat result with a different UID\n                mock_stat_result = MagicMock()\n                mock_stat_result.st_uid = 1234  # arbitrary\n                mock_stat.return_value = mock_stat_result\n                mock_getuid.return_value = 5678  # current user, different from 1234\n                # Capture print\n                with patch('builtins.print') as mock_print:\n                    token_data = {'service1': 'key1'}\n                    archive_secret_tokens(store_file, token_data)\n                    # Check the error message\n                    mock_print.assert_called_with(f\"File '{store_file}' is not owned by the current user.\")\n            # Verify the file content is unchanged\n            with open(store_file, 'r') as f:\n                content = f.read()\n            self.assertEqual(content, \"old content\")\n\n    def test_existing_file_bad_permissions(self):\n        # Test when the existing file has group or others permissions\n        with tempfile.TemporaryDirectory() as temp_dir:\n            store_file = os.path.join(temp_dir, 'secrets.txt')\n            with open(store_file, 'w') as f:\n                f.write(\"old content\")\n            # We mock os.stat to return a mode that has group/others bits set, and ownership is correct\n            with patch('os.stat') as mock_stat, patch('os.getuid') as mock_getuid:\n                mock_stat_result = MagicMock()\n                # Set the UID to match the current user (so ownership passes)\n                mock_stat_result.st_uid = os.getuid()\n                # Set the mode to have group and others permissions: 0o777\n                mock_stat_result.st_mode = 0o777\n                mock_stat.return_value = mock_stat_result\n                mock_getuid.return_value = os.getuid()\n                # Capture print\n                with patch('builtins.print') as mock_print:\n                    token_data = {'service1': 'key1'}\n                    archive_secret_tokens(store_file, token_data)\n                    # Check the error message\n                    mock_print.assert_called_with(f\"File '{store_file}' has group or others permissions. Aborting write operation.\")\n            # Verify the file content is unchanged\n            with open(store_file, 'r') as f:\n                content = f.read()\n            self.assertEqual(content, \"old content\")\n\n    def test_empty_token_data(self):\n        # Test with an empty token_data dictionary\n        with tempfile.TemporaryDirectory() as temp_dir:\n            store_file = os.path.join(temp_dir, 'secrets.txt')\n            token_data = {}\n            with patch('builtins.print') as mock_print:\n                archive_secret_tokens(store_file, token_data)\n                # Check the file exists and is empty\n                self.assertTrue(os.path.exists(store_file))\n                self.assertEqual(os.path.getsize(store_file), 0)\n                # Check permissions\n                permissions = os.stat(store_file).st_mode & 0o777\n                self.assertEqual(permissions, stat.S_IRUSR | stat.S_IWUSR)  # 0o600\n                # Check printed message\n                mock_print.assert_called_with(f\"API keys securely stored in '{store_file}'\")\n\n    def test_exception_during_write(self):\n        # Test when an exception occurs during writing\n        with tempfile.TemporaryDirectory() as temp_dir:\n            store_file = os.path.join(temp_dir, 'secrets.txt')\n            token_data = {'test': 'key'}\n            # Mock open to raise an IOError\n            with patch('builtins.open', side_effect=IOError(\"Simulated error\")) as mock_open:\n                with patch('builtins.print') as mock_print:\n                    archive_secret_tokens(store_file, token_data)\n                    # Check that the error message was printed\n                    mock_print.assert_called_with(f\"Error securing and writing API keys to '{store_file}': Simulated error\")\n", "num_test_cases": 6, "task_id": "49fb4236"}
{"test": "import unittest\nfrom unittest.mock import patch, mock_open, MagicMock\nimport os\nimport stat\n\nclass TestSaveCredentials(unittest.TestCase):\n\n    @patch('os.path.exists')\n    @patch('os.path.dirname')\n    @patch('os.stat')\n    @patch('os.getuid')\n    @patch('os.chmod')\n    @patch('builtins.open', new_callable=mock_open)\n    @patch('builtins.print')\n    def test_happy_path_new_file(self, mock_print, mock_file, mock_chmod, mock_getuid, mock_stat, mock_dirname, mock_exists):\n        # Test writing to a new file with valid inputs\n        mock_dirname.return_value = '/path/to'\n        mock_exists.side_effect = lambda path: True if path == '/path/to' else False\n        mock_getuid.return_value = 1000\n        \n        credentials = {'github': 'abc123', 'aws': 'xyz456'}\n        save_credentials('/path/to/file.txt', credentials)\n        \n        # Verify file write\n        mock_file.assert_called_once_with('/path/to/file.txt', 'w')\n        handle = mock_file()\n        handle.write.assert_any_call('github:abc123\\n')\n        handle.write.assert_any_call('aws:xyz456\\n')\n        # Verify permissions\n        mock_chmod.assert_called_once_with('/path/to/file.txt', stat.S_IRUSR | stat.S_IWUSR)\n        mock_print.assert_called_once_with(\"API keys securely stored in '/path/to/file.txt'\")\n\n    @patch('os.path.exists')\n    @patch('os.path.dirname')\n    @patch('os.stat')\n    @patch('os.getuid')\n    @patch('os.chmod')\n    @patch('builtins.open', new_callable=mock_open)\n    @patch('builtins.print')\n    def test_happy_path_existing_file(self, mock_print, mock_file, mock_chmod, mock_getuid, mock_stat, mock_dirname, mock_exists):\n        # Test overwriting existing file that is owned and secure\n        mock_dirname.return_value = '/secure/dir'\n        mock_exists.side_effect = lambda path: True\n        mock_stat.return_value.st_uid = 1000\n        mock_stat.return_value.st_mode = 0o600  # Secure permissions\n        mock_getuid.return_value = 1000\n        \n        credentials = {'service1': 'key1'}\n        save_credentials('/secure/dir/keys.txt', credentials)\n        \n        # Verify overwrite\n        mock_file.assert_called_once_with('/secure/dir/keys.txt', 'w')\n        mock_chmod.assert_called_once_with('/secure/dir/keys.txt', stat.S_IRUSR | stat.S_IWUSR)\n        mock_print.assert_called_once_with(\"API keys securely stored in '/secure/dir/keys.txt'\")\n\n    @patch('os.path.exists')\n    @patch('os.path.dirname')\n    @patch('builtins.print')\n    def test_directory_not_exists(self, mock_print, mock_dirname, mock_exists):\n        # Test when directory doesn't exist\n        mock_dirname.return_value = '/nonexistent/dir'\n        mock_exists.return_value = False\n        \n        save_credentials('/nonexistent/dir/keys.txt', {'test': 'key'})\n        \n        mock_print.assert_called_once_with(\"Directory '/nonexistent/dir' does not exist.\")\n\n    @patch('os.path.exists')\n    @patch('os.path.dirname')\n    @patch('os.stat')\n    @patch('os.getuid')\n    @patch('builtins.print')\n    def test_file_not_owned(self, mock_print, mock_getuid, mock_stat, mock_dirname, mock_exists):\n        # Test existing file not owned by current user\n        mock_dirname.return_value = '/valid/dir'\n        mock_exists.return_value = True\n        mock_stat.return_value.st_uid = 1000\n        mock_getuid.return_value = 1001  # Different user\n        \n        save_credentials('/valid/dir/keys.txt', {'test': 'key'})\n        \n        mock_print.assert_called_once_with(\"File '/valid/dir/keys.txt' is not owned by the current user.\")\n\n    @patch('os.path.exists')\n    @patch('os.path.dirname')\n    @patch('os.stat')\n    @patch('os.getuid')\n    @patch('builtins.print')\n    def test_insecure_permissions(self, mock_print, mock_getuid, mock_stat, mock_dirname, mock_exists):\n        # Test existing file with insecure permissions\n        mock_dirname.return_value = '/insecure/dir'\n        mock_exists.return_value = True\n        mock_stat.return_value.st_uid = 1000\n        mock_stat.return_value.st_mode = 0o644  # Group/others have read\n        mock_getuid.return_value = 1000\n        \n        save_credentials('/insecure/dir/keys.txt', {'test': 'key'})\n        \n        mock_print.assert_called_once_with(\"File '/insecure/dir/keys.txt' has group or others permissions. Aborting write operation.\")\n\n    @patch('os.path.exists')\n    @patch('os.path.dirname')\n    @patch('os.stat')\n    @patch('os.getuid')\n    @patch('builtins.open')\n    @patch('builtins.print')\n    def test_write_exception(self, mock_print, mock_open, mock_getuid, mock_stat, mock_dirname, mock_exists):\n        # Test exception during file writing\n        mock_dirname.return_value = '/valid/dir'\n        mock_exists.side_effect = lambda path: True if path == '/valid/dir' else False\n        mock_stat.return_value.st_uid = 1000\n        mock_getuid.return_value = 1000\n        \n        mock_open.side_effect = IOError(\"Disk full\")\n        \n        save_credentials('/valid/dir/keys.txt', {'test': 'key'})\n        \n        error_msg = \"Error securing and writing API keys to '/valid/dir/keys.txt': Disk full\"\n        mock_print.assert_called_once_with(error_msg)\n\n    @patch('os.path.exists')\n    @patch('os.path.dirname')\n    @patch('os.stat')\n    @patch('os.getuid')\n    @patch('builtins.open', new_callable=mock_open)\n    @patch('builtins.print')\n    def test_empty_credentials(self, mock_print, mock_file, mock_getuid, mock_stat, mock_dirname, mock_exists):\n        # Test with empty credentials dictionary\n        mock_dirname.return_value = '/empty/creds'\n        mock_exists.return_value = True\n        mock_stat.return_value.st_uid = 1000\n        mock_stat.return_value.st_mode = 0o600\n        mock_getuid.return_value = 1000\n        \n        save_credentials('/empty/creds/keys.txt', {})\n        \n        # File should be created but empty\n        mock_file.assert_called_once_with('/empty/creds/keys.txt', 'w')\n        handle = mock_file()\n        handle.write.assert_not_called()  # No writes for empty dict\n        mock_chmod.assert_called_once()\n        mock_print.assert_called_once_with(\"API keys securely stored in '/empty/creds/keys.txt'\")\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 7, "task_id": "f2f8151c"}
{"test": "import unittest\nimport os\nimport stat\nfrom unittest.mock import patch, mock_open, MagicMock\nfrom solution import persist_api_tokens\n\nclass TestCases(unittest.TestCase):\n\n    def test_case_1(self):\n        # Test directory does not exist\n        with patch('solution.os') as mock_os, patch('builtins.open', mock_open()) as mock_file, patch('builtins.print') as mock_print:\n            mock_os.path.dirname.return_value = '/nonexistent/dir'\n            mock_os.path.exists.return_value = False\n            mock_os.getuid.return_value = 1000\n            token_map = {'test': 'key'}\n            path = '/nonexistent/dir/tokens.txt'\n            persist_api_tokens(path, token_map)\n            mock_print.assert_called_once_with(\"Directory '/nonexistent/dir' does not exist.\")\n            mock_os.path.exists.assert_called_with('/nonexistent/dir')\n            mock_file.assert_not_called()\n\n    def test_case_2(self):\n        # Test file exists and is safe (owned by user, no group/others permissions)\n        with patch('solution.os') as mock_os, patch('builtins.open', mock_open()) as mock_file, patch('builtins.print') as mock_print:\n            mock_os.getuid.return_value = 1000\n            def exists_side_effect(path):\n                if path == '/existing/dir':\n                    return True\n                if path == '/existing/dir/tokens.txt':\n                    return True\n                return False\n            mock_os.path.exists.side_effect = exists_side_effect\n            file_stat = MagicMock()\n            file_stat.st_uid = 1000\n            file_stat.st_mode = 0o600\n            mock_os.stat.return_value = file_stat\n            token_map = {'github': 'gh_token'}\n            path = '/existing/dir/tokens.txt'\n            persist_api_tokens(path, token_map)\n            mock_file.assert_called_once_with(path, 'w')\n            file_handle = mock_file()\n            file_handle.write.assert_called_once_with('github:gh_token\\n')\n            mock_os.chmod.assert_called_once_with(path, stat.S_IRUSR | stat.S_IWUSR)\n            mock_print.assert_called_once_with(f\"API tokens securely stored in '{path}'\")\n\n    def test_case_3(self):\n        # Test file exists but not owned by current user\n        with patch('solution.os') as mock_os, patch('builtins.open', mock_open()) as mock_file, patch('builtins.print') as mock_print:\n            mock_os.getuid.return_value = 1000\n            def exists_side_effect(path):\n                if path == '/existing/dir':\n                    return True\n                if path == '/existing/dir/tokens.txt':\n                    return True\n                return False\n            mock_os.path.exists.side_effect = exists_side_effect\n            file_stat = MagicMock()\n            file_stat.st_uid = 1001\n            file_stat.st_mode = 0o600\n            mock_os.stat.return_value = file_stat\n            token_map = {'github': 'gh_token'}\n            path = '/existing/dir/tokens.txt'\n            persist_api_tokens(path, token_map)\n            mock_print.assert_called_once_with(f\"File '{path}' is not owned by the current user.\")\n            mock_file.assert_not_called()\n            mock_os.chmod.assert_not_called()\n\n    def test_case_4(self):\n        # Test file exists with group/others permissions\n        with patch('solution.os') as mock_os, patch('builtins.open', mock_open()) as mock_file, patch('builtins.print') as mock_print:\n            mock_os.getuid.return_value = 1000\n            def exists_side_effect(path):\n                if path == '/existing/dir':\n                    return True\n                if path == '/existing/dir/tokens.txt':\n                    return True\n                return False\n            mock_os.path.exists.side_effect = exists_side_effect\n            file_stat = MagicMock()\n            file_stat.st_uid = 1000\n            file_stat.st_mode = 0o640\n            mock_os.stat.return_value = file_stat\n            token_map = {'github': 'gh_token'}\n            path = '/existing/dir/tokens.txt'\n            persist_api_tokens(path, token_map)\n            mock_print.assert_called_once_with(f\"File '{path}' has group or others permissions. Aborting write operation.\")\n            mock_file.assert_not_called()\n            mock_os.chmod.assert_not_called()\n\n    def test_case_5(self):\n        # Test new file creation\n        with patch('solution.os') as mock_os, patch('builtins.open', mock_open()) as mock_file, patch('builtins.print') as mock_print:\n            mock_os.getuid.return_value = 1000\n            def exists_side_effect(path):\n                if path == '/existing/dir':\n                    return True\n                if path == '/existing/dir/tokens.txt':\n                    return False\n                return False\n            mock_os.path.exists.side_effect = exists_side_effect\n            token_map = {'github': 'gh_token'}\n            path = '/existing/dir/tokens.txt'\n            persist_api_tokens(path, token_map)\n            mock_file.assert_called_once_with(path, 'w')\n            file_handle = mock_file()\n            file_handle.write.assert_called_once_with('github:gh_token\\n')\n            mock_os.chmod.assert_called_once_with(path, stat.S_IRUSR | stat.S_IWUSR)\n            mock_print.assert_called_once_with(f\"API tokens securely stored in '{path}'\")\n\n    def test_case_6(self):\n        # Test write operation failure\n        with patch('solution.os') as mock_os, patch('builtins.open', mock_open()) as mock_file, patch('builtins.print') as mock_print:\n            mock_os.getuid.return_value = 1000\n            mock_os.path.exists.return_value = True\n            mock_os.path.exists.side_effect = lambda x: True if x == '/existing/dir' else False\n            mock_file.side_effect = IOError(\"Permission denied\")\n            token_map = {'github': 'gh_token'}\n            path = '/existing/dir/tokens.txt'\n            persist_api_tokens(path, token_map)\n            args, _ = mock_print.call_args\n            self.assertTrue(args[0].startswith(f\"Error securing and writing API tokens to '{path}':\"))\n\n    def test_case_7(self):\n        # Test chmod operation failure\n        with patch('solution.os') as mock_os, patch('builtins.open', mock_open()) as mock_file, patch('builtins.print') as mock_print:\n            mock_os.getuid.return_value = 1000\n            mock_os.path.exists.side_effect = lambda x: True if x == '/existing/dir' else False\n            mock_os.chmod.side_effect = OSError(\"Permission error\")\n            token_map = {'github': 'gh_token'}\n            path = '/existing/dir/tokens.txt'\n            persist_api_tokens(path, token_map)\n            mock_file.assert_called_once_with(path, 'w')\n            args, _ = mock_print.call_args\n            self.assertTrue(args[0].startswith(f\"Error securing and writing API tokens to '{path}':\"))\n\n    def test_case_8(self):\n        # Test empty token_map\n        with patch('solution.os') as mock_os, patch('builtins.open', mock_open()) as mock_file, patch('builtins.print') as mock_print:\n            mock_os.getuid.return_value = 1000\n            mock_os.path.exists.side_effect = lambda x: True if x == '/existing/dir' else False\n            token_map = {}\n            path = '/existing/dir/tokens.txt'\n            persist_api_tokens(path, token_map)\n            mock_file.assert_called_once_with(path, 'w')\n            file_handle = mock_file()\n            file_handle.write.assert_not_called()\n            mock_os.chmod.assert_called_once_with(path, stat.S_IRUSR | stat.S_IWUSR)\n            mock_print.assert_called_once_with(f\"API tokens securely stored in '{path}'\")\n\n    def test_case_9(self):\n        # Test multiple services in token_map\n        with patch('solution.os') as mock_os, patch('builtins.open', mock_open()) as mock_file, patch('builtins.print') as mock_print:\n            mock_os.getuid.return_value = 1000\n            mock_os.path.exists.side_effect = lambda x: True if x == '/existing/dir' else False\n            token_map = {'github': 'gh_token', 'aws': 'aws_token', 'gcp': 'gcp_token'}\n            path = '/existing/dir/tokens.txt'\n            persist_api_tokens(path, token_map)\n            mock_file.assert_called_once_with(path, 'w')\n            file_handle = mock_file()\n            expected_calls = [\n                unittest.mock.call('github:gh_token\\n'),\n                unittest.mock.call('aws:aws_token\\n'),\n                unittest.mock.call('gcp:gcp_token\\n')\n            ]\n            file_handle.write.assert_has_calls(expected_calls, any_order=False)\n            mock_os.chmod.assert_called_once_with(path, stat.S_IRUSR | stat.S_IWUSR)\n            mock_print.assert_called_once_with(f\"API tokens securely stored in '{path}'\")\n\n    def test_case_10(self):\n        # Test non-string key in token_map\n        with patch('solution.os') as mock_os, patch('builtins.open', mock_open()) as mock_file, patch('builtins.print') as mock_print:\n            mock_os.getuid.return_value = 1000\n            mock_os.path.exists.side_effect = lambda x: True if x == '/existing/dir' else False\n            token_map = {123: 'gh_token'}\n            path = '/existing/dir/tokens.txt'\n            persist_api_tokens(path, token_map)\n            args, _ = mock_print.call_args\n            self.assertTrue(args[0].startswith(f\"Error securing and writing API tokens to '{path}':\"))\n\n    def test_case_11(self):\n        # Test non-string value in token_map\n        with patch('solution.os') as mock_os, patch('builtins.open', mock_open()) as mock_file, patch('builtins.print') as mock_print:\n            mock_os.getuid.return_value = 1000\n            mock_os.path.exists.side_effect = lambda x: True if x == '/existing/dir' else False\n            token_map = {'github': 123}\n            path = '/existing/dir/tokens.txt'\n            persist_api_tokens(path, token_map)\n            args, _ = mock_print.call_args\n            self.assertTrue(args[0].startswith(f\"Error securing and writing API tokens to '{path}':\"))\n\n    def test_case_12(self):\n        # Test token_map as None\n        with patch('solution.os') as mock_os, patch('builtins.open', mock_open()) as mock_file, patch('builtins.print') as mock_print:\n            mock_os.getuid.return_value = 1000\n            mock_os.path.exists.side_effect = lambda x: True if x == '/existing/dir' else False\n            token_map = None\n            path = '/existing/dir/tokens.txt'\n            persist_api_tokens(path, token_map)\n            args, _ = mock_print.call_args\n            self.assertTrue(args[0].startswith(f\"Error securing and writing API tokens to '{path}':\"))\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 12, "task_id": "8c06dd58"}
{"test": "import unittest\nimport os\nimport stat\nfrom unittest.mock import patch, mock_open, MagicMock\n\nclass TestSecurelyStoreKeys(unittest.TestCase):\n    \n    @patch('os.path.exists')\n    @patch('builtins.print')\n    def test_directory_does_not_exist(self, mock_print, mock_exists):\n        \"\"\"Test when the directory for the save path does not exist.\"\"\"\n        mock_exists.side_effect = lambda path: False if path == os.path.dirname('/invalid/dir/file.txt') else False\n        key_dict = {'service1': 'key1'}\n        securely_store_keys('/invalid/dir/file.txt', key_dict)\n        mock_print.assert_called_with(\"Directory '/invalid/dir' does not exist.\")\n    \n    @patch('os.path.exists')\n    @patch('os.stat')\n    @patch('os.getuid')\n    @patch('builtins.print')\n    def test_file_not_owned_by_current_user(self, mock_print, mock_getuid, mock_stat, mock_exists):\n        \"\"\"Test when the file exists but is not owned by the current user.\"\"\"\n        mock_exists.return_value = True\n        mock_stat.return_value = MagicMock(st_uid=999)\n        mock_getuid.return_value = 1000\n        key_dict = {'service1': 'key1'}\n        securely_store_keys('/valid/path/file.txt', key_dict)\n        mock_print.assert_called_with(\"File '/valid/path/file.txt' is not owned by the current user.\")\n    \n    @patch('os.path.exists')\n    @patch('os.stat')\n    @patch('os.getuid')\n    @patch('builtins.print')\n    def test_file_has_group_or_others_permissions(self, mock_print, mock_getuid, mock_stat, mock_exists):\n        \"\"\"Test when the file exists and has group or others permissions.\"\"\"\n        mock_exists.return_value = True\n        mock_stat.return_value = MagicMock(st_uid=1000, st_mode=stat.S_IRWXU | stat.S_IRGRP)  # Permissions 740\n        mock_getuid.return_value = 1000\n        key_dict = {'service1': 'key1'}\n        securely_store_keys('/valid/path/file.txt', key_dict)\n        mock_print.assert_called_with(\"File '/valid/path/file.txt' has group or others permissions. Aborting write operation.\")\n    \n    @patch('os.path.exists')\n    @patch('os.stat')\n    @patch('os.getuid')\n    @patch('builtins.open', new_callable=mock_open)\n    @patch('os.chmod')\n    @patch('builtins.print')\n    def test_successful_write_new_file(self, mock_print, mock_chmod, mock_open_file, mock_getuid, mock_stat, mock_exists):\n        \"\"\"Test successful write when creating a new file.\"\"\"\n        mock_exists.side_effect = lambda path: False if path == '/valid/path/file.txt' else True\n        mock_stat.return_value = MagicMock(st_uid=1000)\n        mock_getuid.return_value = 1000\n        key_dict = {'service1': 'key1', 'service2': 'key2'}\n        securely_store_keys('/valid/path/file.txt', key_dict)\n        mock_open_file().write.assert_any_call(\"service1:key1\\n\")\n        mock_open_file().write.assert_any_call(\"service2:key2\\n\")\n        mock_chmod.assert_called_with('/valid/path/file.txt', stat.S_IRUSR | stat.S_IWUSR)\n        mock_print.assert_called_with(\"API keys securely stored in '/valid/path/file.txt'\")\n    \n    @patch('os.path.exists')\n    @patch('os.stat')\n    @patch('os.getuid')\n    @patch('builtins.open', new_callable=mock_open)\n    @patch('os.chmod')\n    @patch('builtins.print')\n    def test_successful_write_existing_safe_file(self, mock_print, mock_chmod, mock_open_file, mock_getuid, mock_stat, mock_exists):\n        \"\"\"Test successful write when overwriting an existing safe file.\"\"\"\n        mock_exists.return_value = True\n        mock_stat.return_value = MagicMock(st_uid=1000, st_mode=stat.S_IRUSR | stat.S_IWUSR)\n        mock_getuid.return_value = 1000\n        key_dict = {'service3': 'key3'}\n        securely_store_keys('/valid/path/file.txt', key_dict)\n        mock_open_file().write.assert_called_with(\"service3:key3\\n\")\n        mock_chmod.assert_called_with('/valid/path/file.txt', stat.S_IRUSR | stat.S_IWUSR)\n        mock_print.assert_called_with(\"API keys securely stored in '/valid/path/file.txt'\")\n    \n    @patch('os.path.exists')\n    @patch('os.stat')\n    @patch('os.getuid')\n    @patch('builtins.open', new_callable=mock_open)\n    @patch('os.chmod')\n    @patch('builtins.print')\n    def test_write_empty_dictionary(self, mock_print, mock_chmod, mock_open_file, mock_getuid, mock_stat, mock_exists):\n        \"\"\"Test writing an empty dictionary results in an empty file.\"\"\"\n        mock_exists.side_effect = lambda path: False if path == '/valid/path/file.txt' else True\n        mock_stat.return_value = MagicMock(st_uid=1000)\n        mock_getuid.return_value = 1000\n        key_dict = {}\n        securely_store_keys('/valid/path/file.txt', key_dict)\n        mock_open_file().write.assert_not_called()\n        mock_chmod.assert_called_with('/valid/path/file.txt', stat.S_IRUSR | stat.S_IWUSR)\n        mock_print.assert_called_with(\"API keys securely stored in '/valid/path/file.txt'\")\n    \n    @patch('os.path.exists')\n    @patch('builtins.open', side_effect=PermissionError(\"Permission denied\"))\n    @patch('builtins.print')\n    def test_exception_during_file_write(self, mock_print, mock_open_file, mock_exists):\n        \"\"\"Test exception handling during file write operation.\"\"\"\n        mock_exists.return_value = True  # Directory exists\n        key_dict = {'service1': 'key1'}\n        securely_store_keys('/valid/path/file.txt', key_dict)\n        mock_print.assert_called_with(\"Error securing and writing API keys to '/valid/path/file.txt': Permission denied\")\n    \n    @patch('os.path.exists')\n    @patch('os.stat')\n    @patch('os.getuid')\n    @patch('builtins.open', new_callable=mock_open)\n    @patch('os.chmod', side_effect=OSError(\"Permission denied\"))\n    @patch('builtins.print')\n    def test_exception_during_chmod(self, mock_print, mock_chmod, mock_open_file, mock_getuid, mock_stat, mock_exists):\n        \"\"\"Test exception handling during permission setting.\"\"\"\n        mock_exists.side_effect = lambda path: False if path == '/valid/path/file.txt' else True\n        mock_stat.return_value = MagicMock(st_uid=1000)\n        mock_getuid.return_value = 1000\n        key_dict = {'service1': 'key1'}\n        securely_store_keys('/valid/path/file.txt', key_dict)\n        mock_open_file().write.assert_called_with(\"service1:key1\\n\")\n        mock_print.assert_called_with(\"Error securing and writing API keys to '/valid/path/file.txt': Permission denied\")\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 8, "task_id": "6249514f"}
{"test": "import unittest\nfrom unittest.mock import patch, MagicMock, mock_open, call\nimport stat\n\nclass TestSaveSecrets(unittest.TestCase):\n\n    @patch('builtins.print')\n    @patch('builtins.open', new_callable=mock_open)\n    @patch('os.chmod')\n    @patch('os.getuid')\n    @patch('os.stat')\n    @patch('os.path.exists')\n    @patch('os.path.dirname')\n    def test_directory_not_exist(self, mocked_dirname, mocked_exists, mocked_stat, mocked_getuid, mocked_chmod, mocked_open, mocked_print):\n        # Test when directory doesn't exist\n        mocked_dirname.return_value = '/test/dir'\n        mocked_exists.return_value = False\n        save_secrets('/test/dir/secret.txt', {'service': 'key'})\n        mocked_print.assert_called_with(\"Directory '/test/dir' does not exist.\")\n        mocked_open.assert_not_called()\n        mocked_chmod.assert_not_called()\n\n    @patch('builtins.print')\n    @patch('builtins.open', new_callable=mock_open)\n    @patch('os.chmod')\n    @patch('os.getuid')\n    @patch('os.stat')\n    @patch('os.path.exists')\n    @patch('os.path.dirname')\n    def test_file_not_owned(self, mocked_dirname, mocked_exists, mocked_stat, mocked_getuid, mocked_chmod, mocked_open, mocked_print):\n        # Test when file exists but not owned by current user\n        mocked_dirname.return_value = '/test/dir'\n        mocked_exists.side_effect = lambda x: True if x == '/test/dir' else True\n        mock_stat = MagicMock()\n        mock_stat.st_uid = 1001\n        mock_stat.st_mode = 0o600\n        mocked_stat.return_value = mock_stat\n        mocked_getuid.return_value = 1000\n        save_secrets('/test/dir/secret.txt', {'service': 'key'})\n        mocked_print.assert_called_with(\"File '/test/dir/secret.txt' is not owned by the current user.\")\n        mocked_open.assert_not_called()\n        mocked_chmod.assert_not_called()\n\n    @patch('builtins.print')\n    @patch('builtins.open', new_callable=mock_open)\n    @patch('os.chmod')\n    @patch('os.getuid')\n    @patch('os.stat')\n    @patch('os.path.exists')\n    @patch('os.path.dirname')\n    def test_file_has_group_or_other_permissions(self, mocked_dirname, mocked_exists, mocked_stat, mocked_getuid, mocked_chmod, mocked_open, mocked_print):\n        # Test when file exists but has group/other permissions\n        mocked_dirname.return_value = '/test/dir'\n        mocked_exists.side_effect = lambda x: True\n        mock_stat = MagicMock()\n        mock_stat.st_uid = 1000\n        mock_stat.st_mode = 0o644\n        mocked_stat.return_value = mock_stat\n        mocked_getuid.return_value = 1000\n        save_secrets('/test/dir/secret.txt', {'service': 'key'})\n        mocked_print.assert_called_with(\"File '/test/dir/secret.txt' has group or others permissions. Aborting write operation.\")\n        mocked_open.assert_not_called()\n        mocked_chmod.assert_not_called()\n\n    @patch('builtins.print')\n    @patch('builtins.open', new_callable=mock_open)\n    @patch('os.chmod')\n    @patch('os.getuid')\n    @patch('os.stat')\n    @patch('os.path.exists')\n    @patch('os.path.dirname')\n    def test_success_file_exists(self, mocked_dirname, mocked_exists, mocked_stat, mocked_getuid, mocked_chmod, mocked_open, mocked_print):\n        # Test successful write when file exists with correct permissions\n        mocked_dirname.return_value = '/test/dir'\n        mocked_exists.side_effect = lambda x: True\n        mock_stat = MagicMock()\n        mock_stat.st_uid = 1000\n        mock_stat.st_mode = 0o600\n        mocked_stat.return_value = mock_stat\n        mocked_getuid.return_value = 1000\n        keys = {'service1': 'key1', 'service2': 'key2'}\n        save_secrets('/test/dir/secret.txt', keys)\n        mocked_open.assert_called_once_with('/test/dir/secret.txt', 'w')\n        file_handle = mocked_open()\n        calls = [call(f\"{k}:{v}\\n\") for k, v in keys.items()]\n        file_handle.write.assert_has_calls(calls, any_order=False)\n        mocked_chmod.assert_called_once_with('/test/dir/secret.txt', stat.S_IRUSR | stat.S_IWUSR)\n        mocked_print.assert_called_with(\"API keys securely stored in '/test/dir/secret.txt'\")\n\n    @patch('builtins.print')\n    @patch('builtins.open', new_callable=mock_open)\n    @patch('os.chmod')\n    @patch('os.getuid')\n    @patch('os.stat')\n    @patch('os.path.exists')\n    @patch('os.path.dirname')\n    def test_success_file_does_not_exist(self, mocked_dirname, mocked_exists, mocked_stat, mocked_getuid, mocked_chmod, mocked_open, mocked_print):\n        # Test successful write when file doesn't exist\n        mocked_dirname.return_value = '/test/dir'\n        mocked_exists.side_effect = lambda x: True if x == '/test/dir' else False\n        keys = {'service1': 'key1', 'service2': 'key2'}\n        save_secrets('/test/dir/secret.txt', keys)\n        mocked_open.assert_called_once_with('/test/dir/secret.txt', 'w')\n        file_handle = mocked_open()\n        calls = [call(f\"{k}:{v}\\n\") for k, v in keys.items()]\n        file_handle.write.assert_has_calls(calls, any_order=False)\n        mocked_chmod.assert_called_once_with('/test/dir/secret.txt', stat.S_IRUSR | stat.S_IWUSR)\n        mocked_print.assert_called_with(\"API keys securely stored in '/test/dir/secret.txt'\")\n\n    @patch('builtins.print')\n    @patch('builtins.open', new_callable=mock_open)\n    @patch('os.chmod')\n    @patch('os.getuid')\n    @patch('os.stat')\n    @patch('os.path.exists')\n    @patch('os.path.dirname')\n    def test_exception_during_write(self, mocked_dirname, mocked_exists, mocked_stat, mocked_getuid, mocked_chmod, mocked_open, mocked_print):\n        # Test exception during file writing\n        mocked_dirname.return_value = '/test/dir'\n        mocked_exists.side_effect = lambda x: True\n        mock_stat = MagicMock()\n        mock_stat.st_uid = 1000\n        mock_stat.st_mode = 0o600\n        mocked_stat.return_value = mock_stat\n        mocked_getuid.return_value = 1000\n        mocked_open.side_effect = IOError(\"Write error\")\n        save_secrets('/test/dir/secret.txt', {'service': 'key'})\n        mocked_print.assert_called_with(\"Error securing and writing API keys to '/test/dir/secret.txt': Write error\")\n        mocked_chmod.assert_not_called()\n\n    @patch('builtins.print')\n    @patch('builtins.open', new_callable=mock_open)\n    @patch('os.chmod')\n    @patch('os.getuid')\n    @patch('os.stat')\n    @patch('os.path.exists')\n    @patch('os.path.dirname')\n    def test_exception_during_chmod(self, mocked_dirname, mocked_exists, mocked_stat, mocked_getuid, mocked_chmod, mocked_open, mocked_print):\n        # Test exception during chmod\n        mocked_dirname.return_value = '/test/dir'\n        mocked_exists.side_effect = lambda x: True\n        mock_stat = MagicMock()\n        mock_stat.st_uid = 1000\n        mock_stat.st_mode = 0o600\n        mocked_stat.return_value = mock_stat\n        mocked_getuid.return_value = 1000\n        mocked_chmod.side_effect = PermissionError(\"Permission denied\")\n        save_secrets('/test/dir/secret.txt', {'service': 'key'})\n        mocked_open.assert_called_once_with('/test/dir/secret.txt', 'w')\n        file_handle = mocked_open()\n        file_handle.write.assert_called_once_with(\"service:key\\n\")\n        mocked_print.assert_called_with(\"Error securing and writing API keys to '/test/dir/secret.txt': Permission denied\")\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 7, "task_id": "ea5a91d9"}
{"test": "import unittest\nimport os\nimport stat\nfrom unittest.mock import patch, MagicMock, mock_open\n\nclass TestSecureKeyStorage(unittest.TestCase):\n\n    @patch('os.path.exists')\n    @patch('os.path.dirname')\n    def test_directory_not_exist(self, mock_dirname, mock_exists):\n        \"\"\"Test when the directory does not exist.\"\"\"\n        mock_dirname.return_value = '/test/dir'\n        mock_exists.return_value = False\n        with patch('builtins.print') as mock_print:\n            secure_key_storage('/test/dir/file.txt', {'test': 'key'})\n            mock_print.assert_called_with(\"Directory '/test/dir' does not exist.\")\n\n    @patch('os.stat')\n    @patch('os.path.exists')\n    @patch('os.path.dirname')\n    @patch('os.getuid')\n    def test_file_not_owned_by_user(self, mock_getuid, mock_dirname, mock_exists, mock_stat):\n        \"\"\"Test when file exists but is not owned by current user.\"\"\"\n        mock_dirname.return_value = '/test/dir'\n        mock_exists.side_effect = [True, True]\n        mock_getuid.return_value = 1000\n        stat_result = MagicMock()\n        stat_result.st_uid = 1001\n        mock_stat.return_value = stat_result\n        with patch('builtins.print') as mock_print:\n            secure_key_storage('/test/dir/file.txt', {'test': 'key'})\n            mock_print.assert_called_with(\"File '/test/dir/file.txt' is not owned by the current user.\")\n\n    @patch('os.stat')\n    @patch('os.path.exists')\n    @patch('os.path.dirname')\n    @patch('os.getuid')\n    def test_file_has_group_or_others_permissions(self, mock_getuid, mock_dirname, mock_exists, mock_stat):\n        \"\"\"Test when file exists and has group/others permissions.\"\"\"\n        mock_dirname.return_value = '/test/dir'\n        mock_exists.side_effect = [True, True]\n        mock_getuid.return_value = 1000\n        stat_result = MagicMock()\n        stat_result.st_uid = 1000\n        stat_result.st_mode = 0o770\n        mock_stat.return_value = stat_result\n        with patch('builtins.print') as mock_print:\n            secure_key_storage('/test/dir/file.txt', {'test': 'key'})\n            mock_print.assert_called_with(\"File '/test/dir/file.txt' has group or others permissions. Aborting write operation.\")\n\n    @patch('os.chmod')\n    @patch('builtins.open', new_callable=mock_open)\n    @patch('os.path.exists')\n    @patch('os.path.dirname')\n    @patch('os.getuid')\n    def test_successful_write_new_file(self, mock_getuid, mock_dirname, mock_exists, mock_file, mock_chmod):\n        \"\"\"Test successful write when file does not exist.\"\"\"\n        mock_dirname.return_value = '/test/dir'\n        mock_exists.side_effect = [True, False]\n        mock_getuid.return_value = 1000\n        creds = {'service1': 'key1', 'service2': 'key2'}\n        with patch('builtins.print') as mock_print:\n            secure_key_storage('/test/dir/file.txt', creds)\n            mock_file.assert_called_once_with('/test/dir/file.txt', 'w')\n            handle = mock_file()\n            written_lines = [call[0][0] for call in handle.write.call_args_list]\n            expected_lines = set([f\"{service}:{key}\\\n\" for service, key in creds.items()])\n            self.assertEqual(set(written_lines), expected_lines)\n            mock_chmod.assert_called_once_with('/test/dir/file.txt', stat.S_IRUSR | stat.S_IWUSR)\n            mock_print.assert_called_with(\"API keys securely stored in '/test/dir/file.txt'\")\n\n    @patch('os.chmod')\n    @patch('builtins.open', new_callable=mock_open)\n    @patch('os.stat')\n    @patch('os.path.exists')\n    @patch('os.path.dirname')\n    @patch('os.getuid')\n    def test_successful_write_existing_file(self, mock_getuid, mock_dirname, mock_exists, mock_stat, mock_file, mock_chmod):\n        \"\"\"Test successful write when file exists with correct permissions.\"\"\"\n        mock_dirname.return_value = '/test/dir'\n        mock_exists.side_effect = [True, True]\n        mock_getuid.return_value = 1000\n        stat_result = MagicMock()\n        stat_result.st_uid = 1000\n        stat_result.st_mode = 0o600\n        mock_stat.return_value = stat_result\n        creds = {'service1': 'key1', 'service2': 'key2'}\n        with patch('builtins.print') as mock_print:\n            secure_key_storage('/test/dir/file.txt', creds)\n            mock_file.assert_called_once_with('/test/dir/file.txt', 'w')\n            handle = mock_file()\n            written_lines = [call[0][0] for call in handle.write.call_args_list]\n            expected_lines = set([f\"{service}:{key}\\\n\" for service, key in creds.items()])\n            self.assertEqual(set(written_lines), expected_lines)\n            mock_chmod.assert_called_once_with('/test/dir/file.txt', stat.S_IRUSR | stat.S_IWUSR)\n            mock_print.assert_called_with(\"API keys securely stored in '/test/dir/file.txt'\")\n\n    @patch('os.path.exists')\n    @patch('os.path.dirname')\n    @patch('os.getuid')\n    def test_exception_during_write(self, mock_getuid, mock_dirname, mock_exists):\n        \"\"\"Test exception handling during file write.\"\"\"\n        mock_dirname.return_value = '/test/dir'\n        mock_exists.side_effect = [True, False]\n        mock_getuid.return_value = 1000\n        with patch('builtins.open', side_effect=Exception(\"Write failed\")), \\\n             patch('builtins.print') as mock_print:\n            secure_key_storage('/test/dir/file.txt', {'test': 'key'})\n            mock_print.assert_called_with(\"Error securing and writing API keys to '/test/dir/file.txt': Write failed\")\n", "num_test_cases": 6, "task_id": "bb451acf"}
{"test": "import unittest\nfrom unittest.mock import patch, MagicMock, mock_open, call\nimport os\nimport stat\n\n# Import the function to test\nfrom secure_storage import register_keys\n\nclass TestRegisterKeys(unittest.TestCase):\n\n    def test_directory_not_exist(self):\n        # Test when the directory does not exist\n        filepath = '/path/to/api_keys.txt'\n        tokens = {'test': 'key'}\n        directory = os.path.dirname(filepath)\n        \n        with patch('os.path.exists', return_value=False) as mock_exists, \\\n             patch('os.stat') as mock_stat, \\\n             patch('builtins.open') as mock_open, \\\n             patch('os.chmod') as mock_chmod, \\\n             patch('builtins.print') as mock_print:\n            \n            register_keys(filepath, tokens)\n            mock_print.assert_called_once_with(f\"Directory '{directory}' does not exist.\")\n            mock_stat.assert_not_called()\n            mock_open.assert_not_called()\n            mock_chmod.assert_not_called()\n\n    def test_file_not_owned(self):\n        # Test when the file exists but is not owned by current user\n        filepath = '/path/to/api_keys.txt'\n        tokens = {'test': 'key'}\n        \n        with patch('os.path.exists', side_effect=lambda x: True if x == os.path.dirname(filepath) else (True if x == filepath else False)), \\\n             patch('os.stat') as mock_stat, \\\n             patch('os.getuid', return_value=2000) as mock_getuid, \\\n             patch('builtins.open') as mock_open, \\\n             patch('os.chmod') as mock_chmod, \\\n             patch('builtins.print') as mock_print:\n            \n            mock_stat_result = MagicMock()\n            mock_stat_result.st_uid = 1000\n            mock_stat.return_value = mock_stat_result\n            \n            register_keys(filepath, tokens)\n            mock_print.assert_called_once_with(f\"File '{filepath}' is not owned by the current user.\")\n            mock_open.assert_not_called()\n            mock_chmod.assert_not_called()\n\n    def test_file_has_group_others_permissions(self):\n        # Test when the file exists but has group/others permissions\n        filepath = '/path/to/api_keys.txt'\n        tokens = {'test': 'key'}\n        \n        with patch('os.path.exists', side_effect=lambda x: True if x == os.path.dirname(filepath) else (True if x == filepath else False)), \\\n             patch('os.stat') as mock_stat, \\\n             patch('os.getuid', return_value=2000) as mock_getuid, \\\n             patch('builtins.open') as mock_open, \\\n             patch('os.chmod') as mock_chmod, \\\n             patch('builtins.print') as mock_print:\n            \n            mock_stat_result = MagicMock()\n            mock_stat_result.st_uid = 2000\n            mock_stat_result.st_mode = 0o777\n            mock_stat.return_value = mock_stat_result\n            \n            register_keys(filepath, tokens)\n            mock_print.assert_called_once_with(f\"File '{filepath}' has group or others permissions. Aborting write operation.\")\n            mock_open.assert_not_called()\n            mock_chmod.assert_not_called()\n\n    def test_success_when_file_not_exist(self):\n        # Test successful write when file does not exist\n        filepath = '/path/to/api_keys.txt'\n        tokens = {'service1': 'key1', 'service2': 'key2'}\n        \n        with patch('os.path.exists', side_effect=lambda x: True if x == os.path.dirname(filepath) else (False if x == filepath else False)), \\\n             patch('os.stat') as mock_stat, \\\n             patch('os.getuid', return_value=2000) as mock_getuid, \\\n             patch('builtins.open', mock_open()) as mock_file, \\\n             patch('os.chmod') as mock_chmod, \\\n             patch('builtins.print') as mock_print:\n            \n            register_keys(filepath, tokens)\n            mock_file.assert_called_once_with(filepath, 'w')\n            handle = mock_file()\n            expected_calls = [call('service1:key1\\n'), call('service2:key2\\n')]\n            handle.write.assert_has_calls(expected_calls, any_order=False)\n            mock_chmod.assert_called_once_with(filepath, stat.S_IRUSR | stat.S_IWUSR)\n            mock_print.assert_called_once_with(f\"API keys securely stored in '{filepath}'\")\n\n    def test_success_when_file_exists_and_conditions_met(self):\n        # Test successful write when file exists and conditions are met\n        filepath = '/path/to/api_keys.txt'\n        tokens = {'service1': 'key1', 'service2': 'key2'}\n        \n        with patch('os.path.exists', side_effect=lambda x: True if x == os.path.dirname(filepath) else (True if x == filepath else False)), \\\n             patch('os.stat') as mock_stat, \\\n             patch('os.getuid', return_value=2000) as mock_getuid, \\\n             patch('builtins.open', mock_open()) as mock_file, \\\n             patch('os.chmod') as mock_chmod, \\\n             patch('builtins.print') as mock_print:\n            \n            mock_stat_result = MagicMock()\n            mock_stat_result.st_uid = 2000\n            mock_stat_result.st_mode = 0o600\n            mock_stat.return_value = mock_stat_result\n            \n            register_keys(filepath, tokens)\n            mock_file.assert_called_once_with(filepath, 'w')\n            handle = mock_file()\n            expected_calls = [call('service1:key1\\n'), call('service2:key2\\n')]\n            handle.write.assert_has_calls(expected_calls, any_order=False)\n            mock_chmod.assert_called_once_with(filepath, stat.S_IRUSR | stat.S_IWUSR)\n            mock_print.assert_called_once_with(f\"API keys securely stored in '{filepath}'\")\n\n    def test_exception_during_write(self):\n        # Test exception handling during file write\n        filepath = '/path/to/api_keys.txt'\n        tokens = {'test': 'key'}\n        \n        with patch('os.path.exists', side_effect=lambda x: True if x == os.path.dirname(filepath) else (False if x == filepath else False)), \\\n             patch('os.stat') as mock_stat, \\\n             patch('os.getuid', return_value=2000) as mock_getuid, \\\n             patch('builtins.open', side_effect=IOError(\"Disk full\")) as mock_open, \\\n             patch('os.chmod') as mock_chmod, \\\n             patch('builtins.print') as mock_print:\n            \n            register_keys(filepath, tokens)\n            mock_print.assert_called_once()\n            args, _ = mock_print.call_args\n            self.assertIn(\"Error securing and writing API keys to '/path/to/api_keys.txt':\", args[0])\n            self.assertIn('Disk full', args[0])\n            mock_chmod.assert_not_called()\n\n    def test_empty_tokens(self):\n        # Test writing empty tokens dictionary\n        filepath = '/path/to/api_keys.txt'\n        tokens = {}\n        \n        with patch('os.path.exists', side_effect=lambda x: True if x == os.path.dirname(filepath) else (False if x == filepath else False)), \\\n             patch('os.stat') as mock_stat, \\\n             patch('os.getuid', return_value=2000) as mock_getuid, \\\n             patch('builtins.open', mock_open()) as mock_file, \\\n             patch('os.chmod') as mock_chmod, \\\n             patch('builtins.print') as mock_print:\n            \n            register_keys(filepath, tokens)\n            mock_file.assert_called_once_with(filepath, 'w')\n            handle = mock_file()\n            handle.write.assert_not_called()\n            mock_chmod.assert_called_once_with(filepath, stat.S_IRUSR | stat.S_IWUSR)\n            mock_print.assert_called_once_with(f\"API keys securely stored in '{filepath}'\")\n\n    def test_non_ascii_tokens(self):\n        # Test writing tokens containing non-ASCII characters\n        filepath = '/path/to/api_keys.txt'\n        tokens = {'service': 'café'}\n        \n        with patch('os.path.exists', side_effect=lambda x: True if x == os.path.dirname(filepath) else (False if x == filepath else False)), \\\n             patch('os.stat') as mock_stat, \\\n             patch('os.getuid', return_value=2000) as mock_getuid, \\\n             patch('builtins.open', mock_open()) as mock_file, \\\n             patch('os.chmod') as mock_chmod, \\\n             patch('builtins.print') as mock_print:\n            \n            register_keys(filepath, tokens)\n            mock_file.assert_called_once_with(filepath, 'w')\n            handle = mock_file()\n            handle.write.assert_called_once_with('service:café\\n')\n            mock_chmod.assert_called_once_with(filepath, stat.S_IRUSR | stat.S_IWUSR)\n            mock_print.assert_called_once_with(f\"API keys securely stored in '{filepath}'\")\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 8, "task_id": "45125d8c"}
{"test": "import os\nimport stat\nimport tempfile\nimport unittest\nfrom unittest.mock import patch, MagicMock\n\n# Import the function to be tested - user must adjust the import\nfrom module import store_confidential_data\n\nclass TestStoreConfidentialData(unittest.TestCase):\n\n    def test_directory_not_exist(self):\n        # Test when the directory does not exist.\n        with tempfile.TemporaryDirectory() as tmpdir:\n            subdir = os.path.join(tmpdir, 'nonexistent')\n            file_path = os.path.join(subdir, 'log.txt')\n            with patch('builtins.print') as mock_print:\n                store_confidential_data(file_path, 'test_data')\n                mock_print.assert_called_with(f'Directory \"{subdir}\" does not exist.')\n            self.assertFalse(os.path.exists(file_path))\n\n    def test_new_file(self):\n        # Test creating a new file.\n        with tempfile.TemporaryDirectory() as tmpdir:\n            file_path = os.path.join(tmpdir, 'log.txt')\n            with patch('builtins.print') as mock_print:\n                store_confidential_data(file_path, 'test_data')\n                mock_print.assert_called_with(f'Sensitive data logged securely to \\'{file_path}\\'')\n            self.assertTrue(os.path.exists(file_path))\n            # Check permissions: 0o600\n            mode = os.stat(file_path).st_mode\n            self.assertEqual(stat.S_IMODE(mode), 0o600)\n            # Check content\n            with open(file_path, 'r') as f:\n                content = f.read()\n            self.assertEqual(content, 'Sensitive Data: test_data\\n')\n\n    def test_existing_file_secure(self):\n        # Test appending to an existing secure file.\n        with tempfile.TemporaryDirectory() as tmpdir:\n            file_path = os.path.join(tmpdir, 'log.txt')\n            # Create the file and set permissions\n            with open(file_path, 'w') as f:\n                f.write('Existing line\\n')\n            os.chmod(file_path, 0o600)\n            # We assume the file is owned by the current user -> true in temp dir.\n            with patch('builtins.print') as mock_print:\n                store_confidential_data(file_path, 'new_data')\n                mock_print.assert_called_with(f'Sensitive data logged securely to \\'{file_path}\\'')\n            # Check content\n            with open(file_path, 'r') as f:\n                lines = f.readlines()\n            self.assertEqual(len(lines), 2)\n            self.assertEqual(lines[0], 'Existing line\\n')\n            self.assertEqual(lines[1], 'Sensitive Data: new_data\\n')\n            # Check permissions\n            mode = os.stat(file_path).st_mode\n            self.assertEqual(stat.S_IMODE(mode), 0o600)\n\n    def test_existing_file_wrong_owner(self):\n        # Test when the file exists but is not owned by the current user.\n        with tempfile.TemporaryDirectory() as tmpdir:\n            file_path = os.path.join(tmpdir, 'log.txt')\n            # Create the file\n            with open(file_path, 'w'):\n                pass\n            # Get the real current user id\n            current_uid = os.getuid()\n            # We'll set a different uid for the file stat\n            different_uid = current_uid + 1 if current_uid != 0 else 1000\n            # Mock os.stat to return our custom uid and the mode (0o600) so that permission check would pass if it got there.\n            with patch('os.stat') as mock_stat, patch('os.getuid') as mock_getuid:\n                # We create a MagicMock for the stat result\n                mock_stat_result = MagicMock()\n                mock_stat_result.st_uid = different_uid\n                mock_stat_result.st_mode = 0o600  # so permission bits are safe\n                mock_stat.return_value = mock_stat_result\n                mock_getuid.return_value = current_uid\n                with patch('builtins.print') as mock_print:\n                    store_confidential_data(file_path, 'test_data')\n                    mock_print.assert_called_with(f'Log file \\'{file_path}\\' is not owned by the current user.')\n            # Check the file was not written to (still empty)\n            with open(file_path, 'r') as f:\n                content = f.read()\n            self.assertEqual(content, '')\n\n    def test_existing_file_insecure_permissions(self):\n        # Test when the file exists but has insecure permissions.\n        with tempfile.TemporaryDirectory() as tmpdir:\n            file_path = os.path.join(tmpdir, 'log.txt')\n            # Create the file with insecure permissions: 0o644\n            with open(file_path, 'w'):\n                pass\n            os.chmod(file_path, 0o644)\n            with patch('builtins.print') as mock_print:\n                store_confidential_data(file_path, 'test_data')\n                mock_print.assert_called_with(f'Log file \\'{file_path}\\' has world-accessible permissions. Not logging the data.')\n            # Check the file is still empty\n            with open(file_path, 'r') as f:\n                content = f.read()\n            self.assertEqual(content, '')\n\n    def test_exception_during_write(self):\n        # Test when an exception occurs during the write operation.\n        with tempfile.TemporaryDirectory() as tmpdir:\n            file_path = os.path.join(tmpdir, 'log.txt')\n            # We'll mock the open to raise an exception\n            with patch('builtins.open', side_effect=Exception('Mocked write error')), \\\n                 patch('builtins.print') as mock_print:\n                store_confidential_data(file_path, 'test_data')\n                mock_print.assert_called_with(f'Error securing and writing sensitive data to log file \\'{file_path}\\': Mocked write error')\n\n    def test_exception_during_chmod(self):\n        # Test when an exception occurs during the chmod operation.\n        with tempfile.TemporaryDirectory() as tmpdir:\n            file_path = os.path.join(tmpdir, 'log.txt')\n            # We want to have the write succeed and then chmod fail.\n            with patch('os.chmod', side_effect=Exception('Mocked chmod error')), \\\n                 patch('builtins.print') as mock_print:\n                store_confidential_data(file_path, 'test_data')\n                mock_print.assert_called_with(f'Error securing and writing sensitive data to log file \\'{file_path}\\': Mocked chmod error')\n            # Check the file was written\n            self.assertTrue(os.path.exists(file_path))\n            with open(file_path, 'r') as f:\n                content = f.read()\n            self.assertEqual(content, 'Sensitive Data: test_data\\n')\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 7, "task_id": "668df94d"}
{"test": "import unittest\nimport os\nimport stat\nimport tempfile\nfrom unittest.mock import patch, MagicMock\n\nclass TestWriteProtectedLog(unittest.TestCase):\n\n    def test_directory_does_not_exist(self):\n        # Test when the directory for the log file does not exist.\n        with tempfile.TemporaryDirectory() as tmp_dir:\n            non_existent_dir = os.path.join(tmp_dir, 'non_existent')\n            log_path = os.path.join(non_existent_dir, 'log.txt')\n            with patch('builtins.print') as mock_print:\n                write_protected_log(log_path, 'secret_data')\n                mock_print.assert_called_with(f\"Directory '{non_existent_dir}' does not exist.\")\n            self.assertFalse(os.path.exists(log_path))\n\n    def test_new_file_created_with_secure_permissions(self):\n        # Test creating a new log file with secure permissions (600).\n        with tempfile.TemporaryDirectory() as tmp_dir:\n            log_path = os.path.join(tmp_dir, 'log.txt')\n            with patch('builtins.print') as mock_print:\n                write_protected_log(log_path, 'secret_data')\n                mock_print.assert_called_with(f\"Sensitive data logged securely to '{log_path}'\")\n            \n            self.assertTrue(os.path.exists(log_path))\n            with open(log_path, 'r') as f:\n                content = f.read()\n            self.assertEqual(content, \"Sensitive Data: secret_data\\n\")\n            \n            st = os.stat(log_path)\n            self.assertEqual(stat.S_IMODE(st.st_mode), stat.S_IRUSR | stat.S_IWUSR)\n\n    def test_append_to_existing_secure_file(self):\n        # Test appending to an existing secure file (permissions 600).\n        with tempfile.TemporaryDirectory() as tmp_dir:\n            log_path = os.path.join(tmp_dir, 'log.txt')\n            with open(log_path, 'w') as f:\n                f.write('Initial line\\n')\n            os.chmod(log_path, stat.S_IRUSR | stat.S_IWUSR)\n            \n            with patch('builtins.print') as mock_print:\n                write_protected_log(log_path, 'new_secret')\n                mock_print.assert_called_with(f\"Sensitive data logged securely to '{log_path}'\")\n            \n            with open(log_path, 'r') as f:\n                lines = f.readlines()\n            self.assertEqual(len(lines), 2)\n            self.assertEqual(lines[1], \"Sensitive Data: new_secret\\n\")\n            \n            st = os.stat(log_path)\n            self.assertEqual(stat.S_IMODE(st.st_mode), stat.S_IRUSR | stat.S_IWUSR)\n\n    def test_existing_file_insecure_permissions(self):\n        # Test existing file with insecure permissions (group accessible).\n        with tempfile.TemporaryDirectory() as tmp_dir:\n            log_path = os.path.join(tmp_dir, 'log.txt')\n            with open(log_path, 'w') as f:\n                f.write('Initial line\\n')\n            os.chmod(log_path, 0o770)  # Group read, write, execute\n            \n            with patch('builtins.print') as mock_print:\n                write_protected_log(log_path, 'new_secret')\n                mock_print.assert_called_with(f\"Log file '{log_path}' has world-accessible permissions. Not logging the data.\")\n            \n            with open(log_path, 'r') as f:\n                lines = f.readlines()\n            self.assertEqual(len(lines), 1)  # Content unchanged\n\n    def test_existing_file_not_owned_by_current_user(self):\n        # Test existing file not owned by current user (mocked).\n        with tempfile.TemporaryDirectory() as tmp_dir:\n            log_path = os.path.join(tmp_dir, 'log.txt')\n            with open(log_path, 'w') as f:\n                f.write('Initial line\\n')\n            \n            # Mock stat to return different UID and secure permissions\n            mock_stat = MagicMock()\n            mock_stat.st_uid = 9999  # Different UID\n            mock_stat.st_mode = stat.S_IFREG | 0o600  # Regular file with 600 permissions\n            \n            with patch('os.stat', return_value=mock_stat), \\\n                 patch('os.getuid', return_value=1000), \\\n                 patch('builtins.print') as mock_print:\n                \n                write_protected_log(log_path, 'new_secret')\n                mock_print.assert_called_with(f\"Log file '{log_path}' is not owned by the current user.\")\n            \n            with open(log_path, 'r') as f:\n                lines = f.readlines()\n            self.assertEqual(len(lines), 1)  # Content unchanged\n\n    def test_exception_during_write(self):\n        # Test exception during file write operation (mocked).\n        with tempfile.TemporaryDirectory() as tmp_dir:\n            log_path = os.path.join(tmp_dir, 'log.txt')\n            \n            # Force open to raise IOError\n            with patch('builtins.open', side_effect=IOError('Mocked IO error')), \\\n                 patch('builtins.print') as mock_print:\n                \n                write_protected_log(log_path, 'secret_data')\n                printed_message = mock_print.call_args[0][0]\n                self.assertTrue(printed_message.startswith(f\"Error securing and writing sensitive data to log file '{log_path}':\"))\n\n    def test_log_path_is_directory_with_insecure_permissions(self):\n        # Test when log_path is a directory with insecure permissions.\n        with tempfile.TemporaryDirectory() as tmp_dir:\n            os.chmod(tmp_dir, 0o777)  # Insecure permissions\n            \n            with patch('builtins.print') as mock_print:\n                write_protected_log(tmp_dir, 'secret_data')\n                mock_print.assert_called_with(f\"Log file '{tmp_dir}' has world-accessible permissions. Not logging the data.\")\n\n    def test_log_path_is_directory_with_secure_permissions(self):\n        # Test when log_path is a directory with secure permissions (write attempt fails).\n        with tempfile.TemporaryDirectory() as tmp_dir:\n            os.chmod(tmp_dir, 0o700)  # Secure permissions\n            \n            with patch('builtins.print') as mock_print:\n                write_protected_log(tmp_dir, 'secret_data')\n                printed_message = mock_print.call_args[0][0]\n                self.assertTrue(printed_message.startswith(f\"Error securing and writing sensitive data to log file '{tmp_dir}':\"))\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 8, "task_id": "74b84601"}
{"test": "import os\nimport stat\nimport tempfile\nimport unittest\nfrom unittest.mock import patch, call\n\nclass TestSecureLogWrite(unittest.TestCase):\n\n    def test_directory_not_exists(self):\n        # Test when the directory does not exist\n        with tempfile.TemporaryDirectory() as tmpdir:\n            non_existent_dir = os.path.join(tmpdir, 'nonexistent')\n            log_file = os.path.join(non_existent_dir, 'log.txt')\n            with patch('builtins.print') as mock_print:\n                secure_log_write(log_file, \"secret\")\n                mock_print.assert_called_with(f\"Directory '{non_existent_dir}' does not exist.\")\n            self.assertFalse(os.path.exists(log_file))\n\n    def test_file_created_with_secure_permissions(self):\n        # Test when file doesn't exist - should create with secure permissions\n        with tempfile.TemporaryDirectory() as tmpdir:\n            log_file = os.path.join(tmpdir, 'log.txt')\n            self.assertFalse(os.path.exists(log_file))\n            with patch('builtins.print') as mock_print:\n                secure_log_write(log_file, \"secret\")\n                mock_print.assert_called_with(f\"Sensitive data logged securely to '{log_file}'\")\n            self.assertTrue(os.path.exists(log_file))\n            with open(log_file, 'r') as f:\n                content = f.read()\n            self.assertEqual(content, \"Sensitive Data: secret\\n\")\n            mode = os.stat(log_file).st_mode\n            self.assertEqual(stat.S_IMODE(mode), 0o600)\n\n    def test_existing_file_correct_ownership_and_permissions(self):\n        # Test existing file with correct ownership and permissions\n        with tempfile.TemporaryDirectory() as tmpdir:\n            log_file = os.path.join(tmpdir, 'log.txt')\n            with open(log_file, 'w') as f:\n                f.write(\"Existing line\\n\")\n            os.chmod(log_file, 0o600)\n            with patch('builtins.print') as mock_print:\n                secure_log_write(log_file, \"new_secret\")\n                mock_print.assert_called_with(f\"Sensitive data logged securely to '{log_file}'\")\n            with open(log_file, 'r') as f:\n                lines = f.readlines()\n            self.assertEqual(len(lines), 2)\n            self.assertEqual(lines[1], \"Sensitive Data: new_secret\\n\")\n            mode = os.stat(log_file).st_mode\n            self.assertEqual(stat.S_IMODE(mode), 0o600)\n\n    def test_file_not_owned_by_current_user(self):\n        # Test file not owned by current user\n        with tempfile.TemporaryDirectory() as tmpdir:\n            log_file = os.path.join(tmpdir, 'log.txt')\n            with open(log_file, 'w') as f:\n                f.write(\"Existing line\\n\")\n            current_uid = os.getuid()\n            fake_uid = current_uid + 1\n            fake_stat = os.stat(log_file)\n            with patch('os.stat') as mock_stat, patch('os.getuid') as mock_getuid:\n                mock_stat.return_value = os.stat_result((fake_stat.st_mode, fake_stat.st_ino, fake_stat.st_dev, \n                                                        fake_stat.st_nlink, fake_uid, fake_stat.st_gid, \n                                                        fake_stat.st_size, fake_stat.st_atime, fake_stat.st_mtime, \n                                                        fake_stat.st_ctime))\n                mock_getuid.return_value = current_uid\n                with patch('builtins.print') as mock_print:\n                    secure_log_write(log_file, \"secret\")\n                    mock_print.assert_called_with(f\"Log file '{log_file}' is not owned by the current user.\")\n            with open(log_file, 'r') as f:\n                lines = f.readlines()\n            self.assertEqual(len(lines), 1)\n            self.assertEqual(lines[0], \"Existing line\\n\")\n\n    def test_file_has_group_or_other_permissions(self):\n        # Test file with group/other permissions\n        with tempfile.TemporaryDirectory() as tmpdir:\n            log_file = os.path.join(tmpdir, 'log.txt')\n            with open(log_file, 'w') as f:\n                f.write(\"Existing line\\n\")\n            os.chmod(log_file, 0o664)\n            with patch('builtins.print') as mock_print:\n                secure_log_write(log_file, \"secret\")\n                mock_print.assert_called_with(f\"Log file '{log_file}' has world-accessible permissions. Not logging the data.\")\n            with open(log_file, 'r') as f:\n                lines = f.readlines()\n            self.assertEqual(len(lines), 1)\n            self.assertEqual(lines[0], \"Existing line\\n\")\n\n    def test_exception_during_write_operation(self):\n        # Test exception during write operation\n        with tempfile.TemporaryDirectory() as tmpdir:\n            log_file = os.path.join(tmpdir, 'log.txt')\n            with open(log_file, 'w') as f:\n                f.write(\"Existing line\\n\")\n            os.chmod(log_file, 0o600)\n            with patch('builtins.open', side_effect=IOError(\"Mocked IO error\")) as mock_open:\n                with patch('builtins.print') as mock_print:\n                    secure_log_write(log_file, \"secret\")\n                    mock_print.assert_called_with(f\"Error securing and writing sensitive data to log file '{log_file}': Mocked IO error\")\n\n    def test_exception_during_chmod(self):\n        # Test exception during chmod operation\n        with tempfile.TemporaryDirectory() as tmpdir:\n            log_file = os.path.join(tmpdir, 'log.txt')\n            self.assertFalse(os.path.exists(log_file))\n            with patch('os.chmod', side_effect=Exception(\"Mocked chmod error\")) as mock_chmod:\n                with patch('builtins.print') as mock_print:\n                    secure_log_write(log_file, \"secret\")\n                    mock_print.assert_called_with(f\"Error securing and writing sensitive data to log file '{log_file}': Mocked chmod error\")\n            self.assertTrue(os.path.exists(log_file))\n            with open(log_file, 'r') as f:\n                content = f.read()\n            self.assertEqual(content, \"Sensitive Data: secret\\n\")\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 7, "task_id": "d0344bbd"}
{"test": "import unittest\nfrom unittest.mock import patch, mock_open, MagicMock\n\nclass TestStoreSensitiveInfo(unittest.TestCase):\n    @patch('builtins.print')\n    @patch('builtins.open', new_callable=mock_open)\n    @patch('os.chmod')\n    @patch('os.getuid')\n    @patch('os.stat')\n    @patch('os.path.exists')\n    def test_directory_does_not_exist(self, mock_exists, mock_stat, mock_getuid, mock_chmod, mock_open, mock_print):\n        \"\"\"Test when the target directory does not exist.\"\"\"\n        logfile_path = '/secure_dir/secret.log'\n        mock_exists.side_effect = lambda path: {\n            '/secure_dir': False,\n            logfile_path: True\n        }[path] if path in ['/secure_dir', logfile_path] else False\n        \n        store_sensitive_info(logfile_path, 'my_secret')\n        \n        mock_print.assert_called_with('Directory \\'/secure_dir\\' does not exist.')\n        mock_open.assert_not_called()\n        mock_chmod.assert_not_called()\n\n    @patch('builtins.print')\n    @patch('builtins.open', new_callable=mock_open)\n    @patch('os.chmod')\n    @patch('os.getuid')\n    @patch('os.stat')\n    @patch('os.path.exists')\n    def test_file_exists_owned_secure_permissions(self, mock_exists, mock_stat, mock_getuid, mock_chmod, mock_open, mock_print):\n        \"\"\"Test existing file with correct ownership and permissions.\"\"\"\n        logfile_path = '/secure_dir/secret.log'\n        mock_exists.side_effect = lambda path: {\n            '/secure_dir': True,\n            logfile_path: True\n        }[path] if path in ['/secure_dir', logfile_path] else False\n        \n        mock_stat_obj = MagicMock()\n        mock_stat_obj.st_uid = 1000\n        mock_stat_obj.st_mode = 0o600\n        mock_stat.return_value = mock_stat_obj\n        mock_getuid.return_value = 1000\n        \n        store_sensitive_info(logfile_path, 'my_secret')\n        \n        mock_open.assert_called_once_with(logfile_path, 'a')\n        mock_open().write.assert_called_once_with('Sensitive Data: my_secret\\n')\n        mock_chmod.assert_called_once_with(logfile_path, 0o600)\n        mock_print.assert_called_with(f'Sensitive data logged securely to \\'{logfile_path}\\'')\n\n    @patch('builtins.print')\n    @patch('builtins.open', new_callable=mock_open)\n    @patch('os.chmod')\n    @patch('os.getuid')\n    @patch('os.stat')\n    @patch('os.path.exists')\n    def test_file_exists_not_owned(self, mock_exists, mock_stat, mock_getuid, mock_chmod, mock_open, mock_print):\n        \"\"\"Test existing file not owned by current user.\"\"\"\n        logfile_path = '/secure_dir/secret.log'\n        mock_exists.side_effect = lambda path: {\n            '/secure_dir': True,\n            logfile_path: True\n        }[path] if path in ['/secure_dir', logfile_path] else False\n        \n        mock_stat_obj = MagicMock()\n        mock_stat_obj.st_uid = 1001\n        mock_stat.return_value = mock_stat_obj\n        mock_getuid.return_value = 1000\n        \n        store_sensitive_info(logfile_path, 'my_secret')\n        \n        mock_print.assert_called_with('Log file \\'/secure_dir/secret.log\\' is not owned by the current user.')\n        mock_open.assert_not_called()\n        mock_chmod.assert_not_called()\n\n    @patch('builtins.print')\n    @patch('builtins.open', new_callable=mock_open)\n    @patch('os.chmod')\n    @patch('os.getuid')\n    @patch('os.stat')\n    @patch('os.path.exists')\n    def test_file_exists_insecure_permissions(self, mock_exists, mock_stat, mock_getuid, mock_chmod, mock_open, mock_print):\n        \"\"\"Test existing file with insecure permissions (group/other access).\"\"\"\n        logfile_path = '/secure_dir/secret.log'\n        mock_exists.side_effect = lambda path: {\n            '/secure_dir': True,\n            logfile_path: True\n        }[path] if path in ['/secure_dir', logfile_path] else False\n        \n        mock_stat_obj = MagicMock()\n        mock_stat_obj.st_uid = 1000\n        mock_stat_obj.st_mode = 0o607\n        mock_stat.return_value = mock_stat_obj\n        mock_getuid.return_value = 1000\n        \n        store_sensitive_info(logfile_path, 'my_secret')\n        \n        mock_print.assert_called_with('Log file \\'/secure_dir/secret.log\\' has world-accessible permissions. Not logging the data.')\n        mock_open.assert_not_called()\n        mock_chmod.assert_not_called()\n\n    @patch('builtins.print')\n    @patch('builtins.open', new_callable=mock_open)\n    @patch('os.chmod')\n    @patch('os.getuid')\n    @patch('os.stat')\n    @patch('os.path.exists')\n    def test_file_does_not_exist(self, mock_exists, mock_stat, mock_getuid, mock_chmod, mock_open, mock_print):\n        \"\"\"Test when the log file does not exist initially.\"\"\"\n        logfile_path = '/secure_dir/secret.log'\n        mock_exists.side_effect = lambda path: {\n            '/secure_dir': True,\n            logfile_path: False\n        }[path] if path in ['/secure_dir', logfile_path] else False\n        \n        mock_getuid.return_value = 1000\n        \n        store_sensitive_info(logfile_path, 'my_secret')\n        \n        mock_open.assert_called_once_with(logfile_path, 'a')\n        mock_open().write.assert_called_once_with('Sensitive Data: my_secret\\n')\n        mock_chmod.assert_called_once_with(logfile_path, 0o600)\n        mock_print.assert_called_with(f'Sensitive data logged securely to \\'{logfile_path}\\'')\n\n    @patch('builtins.print')\n    @patch('builtins.open', new_callable=mock_open)\n    @patch('os.chmod')\n    @patch('os.getuid')\n    @patch('os.stat')\n    @patch('os.path.exists')\n    def test_exception_during_write(self, mock_exists, mock_stat, mock_getuid, mock_chmod, mock_open, mock_print):\n        \"\"\"Test exception handling during file write operation.\"\"\"\n        logfile_path = '/secure_dir/secret.log'\n        mock_exists.side_effect = lambda path: {\n            '/secure_dir': True,\n            logfile_path: False\n        }[path] if path in ['/secure_dir', logfile_path] else False\n        \n        mock_getuid.return_value = 1000\n        mock_open.side_effect = Exception('Write failed')\n        \n        store_sensitive_info(logfile_path, 'my_secret')\n        \n        mock_print.assert_called_with(f'Error securing and writing sensitive data to log file \\'{logfile_path}\\': Write failed')\n        mock_chmod.assert_not_called()", "num_test_cases": 6, "task_id": "70d8023a"}
{"test": "import unittest\nimport os\nimport stat\nimport tempfile\nfrom unittest.mock import patch, MagicMock\n\nclass TestRecordSensitiveContent(unittest.TestCase):\n\n    def test_directory_does_not_exist(self):\n        \"\"\"Test when the directory for the log file does not exist.\"\"\"\n        with tempfile.TemporaryDirectory() as temp_dir:\n            non_exist_dir = os.path.join(temp_dir, 'non_existent')\n            log_file = os.path.join(non_exist_dir, 'log.txt')\n            with patch('builtins.print') as mock_print:\n                record_sensitive_content(log_file, 'test_data')\n                mock_print.assert_called_with(f\"Directory '{non_exist_dir}' does not exist.\")\n\n    def test_new_file_creation(self):\n        \"\"\"Test creating a new file with correct permissions.\"\"\"\n        with tempfile.TemporaryDirectory() as temp_dir:\n            log_file = os.path.join(temp_dir, 'new_log.txt')\n            self.assertFalse(os.path.exists(log_file))\n            with patch('builtins.print') as mock_print:\n                record_sensitive_content(log_file, 'new_data')\n                self.assertTrue(os.path.exists(log_file))\n                with open(log_file, 'r') as f:\n                    content = f.read()\n                self.assertIn('Sensitive Data: new_data', content)\n                mode = os.stat(log_file).st_mode\n                self.assertEqual(stat.S_IMODE(mode), stat.S_IRUSR | stat.S_IWUSR)\n                mock_print.assert_called_with(f\"Sensitive data logged securely to '{log_file}'\")\n\n    def test_existing_file_secure(self):\n        \"\"\"Test appending to an existing secure file.\"\"\"\n        with tempfile.TemporaryDirectory() as temp_dir:\n            log_file = os.path.join(temp_dir, 'secure_log.txt')\n            with open(log_file, 'w') as f:\n                f.write('Existing log\\n')\n            os.chmod(log_file, stat.S_IRUSR | stat.S_IWUSR)\n            \n            with patch('builtins.print') as mock_print:\n                record_sensitive_content(log_file, 'additional_data')\n                with open(log_file, 'r') as f:\n                    lines = f.readlines()\n                self.assertEqual(len(lines), 2)\n                self.assertIn('Sensitive Data: additional_data', lines[1])\n                mode = os.stat(log_file).st_mode\n                self.assertEqual(stat.S_IMODE(mode), stat.S_IRUSR | stat.S_IWUSR)\n                mock_print.assert_called_with(f\"Sensitive data logged securely to '{log_file}'\")\n\n    def test_existing_file_wrong_owner(self):\n        \"\"\"Test file owned by a different user.\"\"\"\n        with tempfile.TemporaryDirectory() as temp_dir:\n            log_file = os.path.join(temp_dir, 'wrong_owner_log.txt')\n            with open(log_file, 'w') as f:\n                f.write('Existing content\\n')\n            \n            # Mock os.stat and os.getuid to simulate wrong owner\n            current_uid = os.getuid()\n            other_uid = current_uid + 1 if current_uid != 0 else 1000\n            mock_stat = MagicMock()\n            mock_stat.st_uid = other_uid\n            mock_stat.st_mode = stat.S_IRUSR | stat.S_IWUSR  # Correct permissions\n            \n            with patch('os.stat', return_value=mock_stat), \\\n                 patch('builtins.print') as mock_print:\n                record_sensitive_content(log_file, 'unauthorized_data')\n                mock_print.assert_called_with(f\"Log file '{log_file}' is not owned by the current user.\")\n                # Verify file content unchanged\n                with open(log_file, 'r') as f:\n                    content = f.read()\n                self.assertEqual(content, 'Existing content\\n')\n\n    def test_existing_file_insecure_permissions(self):\n        \"\"\"Test file with group/other permissions.\"\"\"\n        with tempfile.TemporaryDirectory() as temp_dir:\n            log_file = os.path.join(temp_dir, 'insecure_log.txt')\n            with open(log_file, 'w') as f:\n                f.write('Existing content\\n')\n            # Set insecure permissions (group read)\n            os.chmod(log_file, stat.S_IRUSR | stat.S_IWUSR | stat.S_IRGRP)\n            \n            with patch('builtins.print') as mock_print:\n                record_sensitive_content(log_file, 'insecure_data')\n                mock_print.assert_called_with(f\"Log file '{log_file}' has world-accessible permissions. Not logging the data.\")\n                # Verify file content unchanged\n                with open(log_file, 'r') as f:\n                    content = f.read()\n                self.assertEqual(content, 'Existing content\\n')\n\n    def test_write_error(self):\n        \"\"\"Test error during file write operation.\"\"\"\n        with tempfile.TemporaryDirectory() as temp_dir:\n            log_file = os.path.join(temp_dir, 'error_log.txt')\n            # Force an IOError during write\n            with patch('builtins.open', side_effect=IOError('Disk error')), \\\n                 patch('builtins.print') as mock_print:\n                record_sensitive_content(log_file, 'error_data')\n                mock_print.assert_called_with(f\"Error securing and writing sensitive data to log file '{log_file}': Disk error\")\n\n    def test_permission_change_from_700(self):\n        \"\"\"Test changing permissions from 700 to 600.\"\"\"\n        with tempfile.TemporaryDirectory() as temp_dir:\n            log_file = os.path.join(temp_dir, 'perm_log.txt')\n            with open(log_file, 'w') as f:\n                f.write('Existing log\\n')\n            os.chmod(log_file, stat.S_IRUSR | stat.S_IWUSR | stat.S_IXUSR)  # 700\n            \n            with patch('builtins.print') as mock_print:\n                record_sensitive_content(log_file, 'perm_data')\n                with open(log_file, 'r') as f:\n                    lines = f.readlines()\n                self.assertEqual(len(lines), 2)\n                self.assertIn('Sensitive Data: perm_data', lines[1])\n                mode = os.stat(log_file).st_mode\n                self.assertEqual(stat.S_IMODE(mode), stat.S_IRUSR | stat.S_IWUSR)  # 600\n                mock_print.assert_called_with(f\"Sensitive data logged securely to '{log_file}'\")\n\n    def test_multiple_appends(self):\n        \"\"\"Test multiple appends to the same file.\"\"\"\n        with tempfile.TemporaryDirectory() as temp_dir:\n            log_file = os.path.join(temp_dir, 'multi_log.txt')\n            # First write\n            record_sensitive_content(log_file, 'first_data')\n            # Second write\n            with patch('builtins.print') as mock_print:\n                record_sensitive_content(log_file, 'second_data')\n                mock_print.assert_called_with(f\"Sensitive data logged securely to '{log_file}'\")\n            \n            with open(log_file, 'r') as f:\n                lines = f.readlines()\n            self.assertEqual(len(lines), 2)\n            self.assertIn('Sensitive Data: first_data', lines[0])\n            self.assertIn('Sensitive Data: second_data', lines[1])\n            mode = os.stat(log_file).st_mode\n            self.assertEqual(stat.S_IMODE(mode), stat.S_IRUSR | stat.S_IWUSR)\n\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 8, "task_id": "dc104722"}
{"test": "import unittest\nimport tempfile\nimport os\nimport stat\nfrom unittest.mock import patch, MagicMock\n\nclass TestLogConfidentialData(unittest.TestCase):\n\n    def test_directory_does_not_exist(self):\n        # Test when the directory for the log file does not exist\n        with tempfile.TemporaryDirectory() as temp_dir:\n            log_path = os.path.join(temp_dir, 'non_existent_dir', 'test.log')\n            sensitive_content = \"secret\"\n            with patch('builtins.print') as mock_print:\n                log_confidential_data(log_path, sensitive_content)\n                mock_print.assert_called_with(f\"Directory '{os.path.dirname(log_path)}' does not exist.\")\n\n    def test_file_exists_correct_permissions(self):\n        # Test when file exists with correct ownership and permissions (600)\n        with tempfile.TemporaryDirectory() as temp_dir:\n            log_path = os.path.join(temp_dir, 'test.log')\n            with open(log_path, 'w') as f:\n                f.write(\"Existing log line\\n\")\n            os.chmod(log_path, stat.S_IRUSR | stat.S_IWUSR)  # 0o600\n            sensitive_content = \"my_password\"\n            with patch('builtins.print') as mock_print:\n                log_confidential_data(log_path, sensitive_content)\n                mock_print.assert_called_with(f\"Sensitive data logged securely to '{log_path}'\")\n            with open(log_path, 'r') as f:\n                content = f.read()\n                self.assertIn(\"Existing log line\", content)\n                self.assertIn(f\"Sensitive Data: {sensitive_content}\", content)\n            file_mode = os.stat(log_path).st_mode\n            self.assertEqual(file_mode & 0o777, stat.S_IRUSR | stat.S_IWUSR)\n\n    def test_file_exists_not_owned(self):\n        # Test when file exists but is not owned by the current user\n        mock_stat = MagicMock()\n        mock_stat.st_uid = 1234\n        mock_stat.st_mode = stat.S_IRUSR | stat.S_IWUSR  # 0o600\n        with patch('os.stat', return_value=mock_stat), \\\n             patch('os.getuid', return_value=1000), \\\n             patch('builtins.print') as mock_print:\n            log_path = '/some/file.log'\n            sensitive_content = \"token\"\n            log_confidential_data(log_path, sensitive_content)\n            mock_print.assert_called_with(f\"Log file '{log_path}' is not owned by the current user.\")\n\n    def test_file_exists_world_accessible(self):\n        # Test when file exists with group/other permissions (world-accessible)\n        with tempfile.TemporaryDirectory() as temp_dir:\n            log_path = os.path.join(temp_dir, 'test.log')\n            with open(log_path, 'w') as f:\n                f.write(\"Existing log line\\n\")\n            os.chmod(log_path, 0o644)  # Group and others can read\n            sensitive_content = \"my_password\"\n            with patch('builtins.print') as mock_print:\n                log_confidential_data(log_path, sensitive_content)\n                mock_print.assert_called_with(f\"Log file '{log_path}' has world-accessible permissions. Not logging the data.\")\n            with open(log_path, 'r') as f:\n                self.assertEqual(f.read(), \"Existing log line\\n\")\n\n    def test_file_does_not_exist(self):\n        # Test when file does not exist initially\n        with tempfile.TemporaryDirectory() as temp_dir:\n            log_path = os.path.join(temp_dir, 'new.log')\n            sensitive_content = \"new_secret\"\n            self.assertFalse(os.path.exists(log_path))\n            with patch('builtins.print') as mock_print:\n                log_confidential_data(log_path, sensitive_content)\n                mock_print.assert_called_with(f\"Sensitive data logged securely to '{log_path}'\")\n            self.assertTrue(os.path.exists(log_path))\n            with open(log_path, 'r') as f:\n                self.assertEqual(f.read(), f\"Sensitive Data: {sensitive_content}\\n\")\n            file_mode = os.stat(log_path).st_mode\n            self.assertEqual(file_mode & 0o777, stat.S_IRUSR | stat.S_IWUSR)\n\n    def test_exception_during_write(self):\n        # Test exception during file writing\n        log_path = '/some/logfile.log'\n        sensitive_content = \"secret\"\n        with patch('builtins.open', side_effect=PermissionError(\"Permission denied\")), \\\n             patch('builtins.print') as mock_print:\n            log_confidential_data(log_path, sensitive_content)\n            mock_print.assert_called_with(f\"Error securing and writing sensitive data to log file '{log_path}': Permission denied\")\n\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 6, "task_id": "aca22947"}
{"test": "import unittest\nfrom unittest.mock import patch, mock_open, MagicMock\nimport os\nimport stat\n\nclass TestSecureLogData(unittest.TestCase):\n\n    @patch('builtins.print')\n    @patch('os.chmod')\n    @patch('os.stat')\n    @patch('os.getuid')\n    @patch('os.path.exists')\n    def test_directory_does_not_exist(self, mock_exists, mock_getuid, mock_stat, mock_chmod, mock_print):\n        \"\"\"Test behavior when the directory for the log file does not exist.\"\"\"\n        mock_exists.return_value = False\n        log_path = '/path/to/nonexistent_dir/logfile.log'\n        secret_info = 'secret123'\n        \n        result = secure_log_data(log_path, secret_info)\n        \n        self.assertIsNone(result)\n        mock_print.assert_called_once_with('Directory \\'{}\\' does not exist.'.format(os.path.dirname(log_path)))\n        mock_stat.assert_not_called()\n        mock_chmod.assert_not_called()\n\n    @patch('builtins.print')\n    @patch('os.chmod')\n    @patch('os.stat')\n    @patch('os.getuid')\n    @patch('os.path.exists')\n    @patch('builtins.open', new_callable=mock_open)\n    def test_file_does_not_exist(self, mock_open_file, mock_exists, mock_getuid, mock_stat, mock_chmod, mock_print):\n        \"\"\"Test creating a new secure log file when it doesn't exist.\"\"\"\n        mock_exists.side_effect = [True, False]\n        mock_getuid.return_value = 1000\n        log_path = '/path/to/logfile.log'\n        secret_info = 'secret123'\n        \n        result = secure_log_data(log_path, secret_info)\n        \n        self.assertIsNone(result)\n        mock_open_file.assert_called_once_with(log_path, 'a')\n        handle = mock_open_file()\n        handle.write.assert_called_once_with('Sensitive Data: {}\\n'.format(secret_info))\n        mock_chmod.assert_called_once_with(log_path, stat.S_IRUSR | stat.S_IWUSR)\n        mock_print.assert_called_once_with('Sensitive data logged securely to \\'{}\\''.format(log_path))\n\n    @patch('builtins.print')\n    @patch('os.chmod')\n    @patch('os.stat')\n    @patch('os.getuid')\n    @patch('os.path.exists')\n    @patch('builtins.open', new_callable=mock_open)\n    def test_file_exists_and_secure(self, mock_open_file, mock_exists, mock_getuid, mock_stat, mock_chmod, mock_print):\n        \"\"\"Test appending to an existing secure file with correct ownership and permissions.\"\"\"\n        mock_exists.side_effect = [True, True]\n        mock_getuid.return_value = 1000\n        mock_stat_result = MagicMock()\n        mock_stat_result.st_uid = 1000\n        mock_stat_result.st_mode = 0o600\n        mock_stat.return_value = mock_stat_result\n        log_path = '/path/to/logfile.log'\n        secret_info = 'secret123'\n        \n        result = secure_log_data(log_path, secret_info)\n        \n        self.assertIsNone(result)\n        mock_open_file.assert_called_once_with(log_path, 'a')\n        handle = mock_open_file()\n        handle.write.assert_called_once_with('Sensitive Data: {}\\n'.format(secret_info))\n        mock_chmod.assert_called_once_with(log_path, stat.S_IRUSR | stat.S_IWUSR)\n        mock_print.assert_called_once_with('Sensitive data logged securely to \\'{}\\''.format(log_path))\n\n    @patch('builtins.print')\n    @patch('os.chmod')\n    @patch('os.stat')\n    @patch('os.getuid')\n    @patch('os.path.exists')\n    def test_file_not_owned_by_current_user(self, mock_exists, mock_getuid, mock_stat, mock_chmod, mock_print):\n        \"\"\"Test rejection when log file is not owned by the current user.\"\"\"\n        mock_exists.side_effect = [True, True]\n        mock_getuid.return_value = 1000\n        mock_stat_result = MagicMock()\n        mock_stat_result.st_uid = 1001\n        mock_stat.return_value = mock_stat_result\n        log_path = '/path/to/logfile.log'\n        secret_info = 'secret123'\n        \n        result = secure_log_data(log_path, secret_info)\n        \n        self.assertIsNone(result)\n        mock_print.assert_called_once_with('Log file \\'{}\\' is not owned by the current user.'.format(log_path))\n        mock_chmod.assert_not_called()\n\n    @patch('builtins.print')\n    @patch('os.chmod')\n    @patch('os.stat')\n    @patch('os.getuid')\n    @patch('os.path.exists')\n    def test_file_has_world_accessible_permissions(self, mock_exists, mock_getuid, mock_stat, mock_chmod, mock_print):\n        \"\"\"Test rejection when log file has world-accessible permissions.\"\"\"\n        mock_exists.side_effect = [True, True]\n        mock_getuid.return_value = 1000\n        mock_stat_result = MagicMock()\n        mock_stat_result.st_uid = 1000\n        mock_stat_result.st_mode = 0o664\n        mock_stat.return_value = mock_stat_result\n        log_path = '/path/to/logfile.log'\n        secret_info = 'secret123'\n        \n        result = secure_log_data(log_path, secret_info)\n        \n        self.assertIsNone(result)\n        mock_print.assert_called_once_with('Log file \\'{}\\' has world-accessible permissions. Not logging the data.'.format(log_path))\n        mock_chmod.assert_not_called()\n\n    @patch('builtins.print')\n    @patch('os.chmod')\n    @patch('os.stat')\n    @patch('os.getuid')\n    @patch('os.path.exists')\n    @patch('builtins.open', new_callable=mock_open)\n    def test_exception_during_file_write(self, mock_open_file, mock_exists, mock_getuid, mock_stat, mock_chmod, mock_print):\n        \"\"\"Test handling of exceptions during file write operation.\"\"\"\n        mock_exists.side_effect = [True, True]\n        mock_getuid.return_value = 1000\n        mock_stat_result = MagicMock()\n        mock_stat_result.st_uid = 1000\n        mock_stat_result.st_mode = 0o600\n        mock_stat.return_value = mock_stat_result\n        mock_open_file.side_effect = IOError('Disk full')\n        log_path = '/path/to/logfile.log'\n        secret_info = 'secret123'\n        \n        result = secure_log_data(log_path, secret_info)\n        \n        self.assertIsNone(result)\n        args, _ = mock_print.call_args\n        self.assertTrue(args[0].startswith('Error securing and writing sensitive data to log file \\'{}\\':'.format(log_path)))\n        mock_chmod.assert_not_called()\n", "num_test_cases": 6, "task_id": "5155a11c"}
{"test": "import unittest\nimport os\nimport stat\nimport tempfile\nfrom unittest.mock import patch, MagicMock\n\n# We assume the function 'log_user_data' is available from the module under test\n\nclass TestLogUserData(unittest.TestCase):\n\n    @patch('builtins.print')\n    def test_directory_not_exists(self, mock_print):\n        \"\"\"Test when the directory for the log file does not exist.\"\"\"\n        logfile_path = '/non/existent/dir/file.log'\n        with patch('os.path.exists') as mock_exists:\n            mock_exists.return_value = False\n            log_user_data(logfile_path, 'sensitive')\n            mock_print.assert_called_once_with(f\"Directory '{os.path.dirname(logfile_path)}' does not exist.\")\n\n    def test_existing_secure_file(self):\n        \"\"\"Test writing to an existing file with correct ownership and permissions.\"\"\"\n        with tempfile.TemporaryDirectory() as temp_dir:\n            logfile = os.path.join(temp_dir, 'secure.log')\n            with open(logfile, 'w') as f:\n                f.write('Existing log\\\\n')\n            os.chmod(logfile, 0o600)\n            with patch('builtins.print') as mock_print:\n                log_user_data(logfile, 'test_data')\n                with open(logfile, 'r') as f:\n                    content = f.read()\n                self.assertEqual(content, \"Existing log\\\\nSensitive Data: test_data\\\\n\")\n                mode = os.stat(logfile).st_mode\n                self.assertEqual(stat.S_IMODE(mode), 0o600)\n                mock_print.assert_called_once_with(f\"Sensitive data logged securely to '{logfile}'\")\n\n    @patch('os.getuid')\n    @patch('os.stat')\n    @patch('os.path.exists')\n    @patch('builtins.print')\n    def test_file_not_owned(self, mock_print, mock_exists, mock_stat, mock_getuid):\n        \"\"\"Test existing file not owned by the current user.\"\"\"\n        logfile_path = '/some/file.log'\n        mock_exists.return_value = True\n        mock_stat_result = MagicMock()\n        mock_stat_result.st_uid = 1001\n        mock_stat_result.st_mode = 0o600\n        mock_stat.return_value = mock_stat_result\n        mock_getuid.return_value = 1000\n        log_user_data(logfile_path, 'data')\n        mock_print.assert_called_once_with(f\"Log file '{logfile_path}' is not owned by the current user.\")\n\n    @patch('os.getuid')\n    @patch('os.stat')\n    @patch('os.path.exists')\n    @patch('builtins.print')\n    def test_file_insecure_permissions(self, mock_print, mock_exists, mock_stat, mock_getuid):\n        \"\"\"Test existing file with insecure permissions (group/other access).\"\"\"\n        logfile_path = '/some/file.log'\n        mock_exists.return_value = True\n        mock_stat_result = MagicMock()\n        mock_stat_result.st_uid = 1000\n        mock_stat_result.st_mode = 0o602\n        mock_stat.return_value = mock_stat_result\n        mock_getuid.return_value = 1000\n        log_user_data(logfile_path, 'data')\n        mock_print.assert_called_once_with(f\"Log file '{logfile_path}' has world-accessible permissions. Not logging the data.\")\n\n    def test_new_file_creation(self):\n        \"\"\"Test creating a new file and setting secure permissions.\"\"\"\n        with tempfile.TemporaryDirectory() as temp_dir:\n            logfile = os.path.join(temp_dir, 'new.log')\n            self.assertFalse(os.path.exists(logfile))\n            with patch('builtins.print') as mock_print:\n                log_user_data(logfile, 'new_data')\n                self.assertTrue(os.path.exists(logfile))\n                with open(logfile, 'r') as f:\n                    content = f.read()\n                self.assertEqual(content, \"Sensitive Data: new_data\\\\n\")\n                mode = os.stat(logfile).st_mode\n                self.assertEqual(stat.S_IMODE(mode), 0o600)\n                mock_print.assert_called_once_with(f\"Sensitive data logged securely to '{logfile}'\")\n\n    @patch('builtins.open')\n    @patch('os.stat')\n    @patch('os.path.exists')\n    @patch('builtins.print')\n    def test_exception_during_write(self, mock_print, mock_exists, mock_stat, mock_open):\n        \"\"\"Test exception handling during file write operation.\"\"\"\n        logfile_path = '/some/file.log'\n        mock_exists.return_value = True\n        mock_stat_result = MagicMock()\n        mock_stat_result.st_uid = 1000\n        mock_stat_result.st_mode = 0o600\n        mock_stat.return_value = mock_stat_result\n        mock_open.side_effect = Exception(\"Mocked error\")\n        log_user_data(logfile_path, 'data')\n        mock_print.assert_called_once_with(f\"Error securing and writing sensitive data to log file '{logfile_path}': Mocked error\")\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 6, "task_id": "5d243b82"}
{"test": "import os\nimport stat\nimport unittest\nfrom unittest.mock import patch, mock_open, MagicMock\n\nclass TestLogConfidentialData(unittest.TestCase):\n\n    # Test Case 1: Directory does not exist\n    @patch('os.path.exists')\n    @patch('os.path.dirname')\n    @patch('builtins.print')\n    def test_directory_not_exist(self, mock_print, mock_exists, mock_dirname):\n        mock_dirname.return_value = '/fake/dir'\n        mock_exists.return_value = False\n        log_confidential_data('/fake/dir/file.log', 'data')\n        mock_print.assert_called_once_with('Directory \\'/fake/dir\\' does not exist.')\n\n    # Test Case 2: File does not exist (happy path)\n    @patch('os.path.exists')\n    @patch('os.path.dirname')\n    @patch('os.chmod')\n    @patch('builtins.open', new_callable=mock_open)\n    @patch('builtins.print')\n    def test_happy_path_file_not_exist(self, mock_print, mock_open_func, mock_chmod, mock_dirname, mock_exists):\n        mock_dirname.return_value = '/valid/dir'\n        mock_exists.side_effect = lambda path: True if path == '/valid/dir' else False\n        log_confidential_data('/valid/dir/file.log', 'password')\n        mock_open_func.assert_called_once_with('/valid/dir/file.log', 'a')\n        handle = mock_open_func()\n        handle.write.assert_called_once_with('Sensitive Data: password\\n')\n        mock_chmod.assert_called_once_with('/valid/dir/file.log', stat.S_IRUSR | stat.S_IWUSR)\n        mock_print.assert_called_once_with('Sensitive data logged securely to \\'/valid/dir/file.log\\'')\n\n    # Test Case 3: File exists with correct ownership and permissions\n    @patch('os.path.exists')\n    @patch('os.path.dirname')\n    @patch('os.stat')\n    @patch('os.getuid')\n    @patch('os.chmod')\n    @patch('builtins.open', new_callable=mock_open)\n    @patch('builtins.print')\n    def test_existing_file_secure(self, mock_print, mock_open_func, mock_chmod, mock_getuid, mock_stat, mock_dirname, mock_exists):\n        mock_dirname.return_value = '/secure/dir'\n        mock_exists.return_value = True\n        mock_stat_result = MagicMock()\n        mock_stat_result.st_uid = 1000\n        mock_stat_result.st_mode = 0o100600\n        mock_stat.return_value = mock_stat_result\n        mock_getuid.return_value = 1000\n        \n        log_confidential_data('/secure/dir/file.log', 'data')\n        mock_open_func.assert_called_once_with('/secure/dir/file.log', 'a')\n        handle = mock_open_func()\n        handle.write.assert_called_once_with('Sensitive Data: data\\n')\n        mock_chmod.assert_called_once_with('/secure/dir/file.log', stat.S_IRUSR | stat.S_IWUSR)\n        mock_print.assert_called_once_with('Sensitive data logged securely to \\'/secure/dir/file.log\\'')\n\n    # Test Case 4: File exists with unsafe permissions\n    @patch('os.path.exists')\n    @patch('os.path.dirname')\n    @patch('os.stat')\n    @patch('os.getuid')\n    @patch('builtins.open')\n    @patch('builtins.print')\n    def test_existing_file_unsafe_permissions(self, mock_print, mock_open, mock_getuid, mock_stat, mock_dirname, mock_exists):\n        mock_dirname.return_value = '/insecure/dir'\n        mock_exists.return_value = True\n        mock_stat_result = MagicMock()\n        mock_stat_result.st_uid = 1000\n        mock_stat_result.st_mode = 0o100664  # Group and others have write permission\n        mock_stat.return_value = mock_stat_result\n        mock_getuid.return_value = 1000\n        \n        log_confidential_data('/insecure/dir/file.log', 'data')\n        mock_open.assert_not_called()\n        mock_print.assert_called_once_with('Log file \\'/insecure/dir/file.log\\' has world-accessible permissions. Not logging the data.')\n\n    # Test Case 5: File exists with wrong ownership\n    @patch('os.path.exists')\n    @patch('os.path.dirname')\n    @patch('os.stat')\n    @patch('os.getuid')\n    @patch('builtins.open')\n    @patch('builtins.print')\n    def test_existing_file_wrong_owner(self, mock_print, mock_open, mock_getuid, mock_stat, mock_dirname, mock_exists):\n        mock_dirname.return_value = '/wrong/owner'\n        mock_exists.return_value = True\n        mock_stat_result = MagicMock()\n        mock_stat_result.st_uid = 999  # Different user\n        mock_stat_result.st_mode = 0o100600\n        mock_stat.return_value = mock_stat_result\n        mock_getuid.return_value = 1000  # Current user\n        \n        log_confidential_data('/wrong/owner/file.log', 'data')\n        mock_open.assert_not_called()\n        mock_print.assert_called_once_with('Log file \\'/wrong/owner/file.log\\' is not owned by the current user.')\n\n    # Test Case 6: Exception during file writing\n    @patch('os.path.exists')\n    @patch('os.path.dirname')\n    @patch('os.stat')\n    @patch('os.getuid')\n    @patch('builtins.open')\n    @patch('builtins.print')\n    @patch('os.chmod')\n    def test_exception_during_write(self, mock_chmod, mock_print, mock_open, mock_getuid, mock_stat, mock_dirname, mock_exists):\n        mock_dirname.return_value = '/error/dir'\n        mock_exists.return_value = True\n        mock_stat_result = MagicMock()\n        mock_stat_result.st_uid = 1000\n        mock_stat_result.st_mode = 0o100600\n        mock_stat.return_value = mock_stat_result\n        mock_getuid.return_value = 1000\n        mock_open.side_effect = IOError('Disk full')\n        \n        log_confidential_data('/error/dir/file.log', 'data')\n        mock_print.assert_called_once_with('Error securing and writing sensitive data to log file \\'/error/dir/file.log\\': Disk full')\n        mock_chmod.assert_not_called()\n\n    # Test Case 7: Exception during permission setting\n    @patch('os.path.exists')\n    @patch('os.path.dirname')\n    @patch('os.stat')\n    @patch('os.getuid')\n    @patch('builtins.open', new_callable=mock_open)\n    @patch('builtins.print')\n    @patch('os.chmod')\n    def test_exception_during_chmod(self, mock_chmod, mock_print, mock_open_func, mock_getuid, mock_stat, mock_dirname, mock_exists):\n        mock_dirname.return_value = '/chmod/error'\n        mock_exists.return_value = True\n        mock_stat_result = MagicMock()\n        mock_stat_result.st_uid = 1000\n        mock_stat_result.st_mode = 0o100600\n        mock_stat.return_value = mock_stat_result\n        mock_getuid.return_value = 1000\n        mock_chmod.side_effect = PermissionError('Permission denied')\n        \n        log_confidential_data('/chmod/error/file.log', 'data')\n        mock_open_func.assert_called_once_with('/chmod/error/file.log', 'a')\n        handle = mock_open_func()\n        handle.write.assert_called_once_with('Sensitive Data: data\\n')\n        mock_print.assert_called_once_with('Error securing and writing sensitive data to log file \\'/chmod/error/file.log\\': Permission denied')", "num_test_cases": 7, "task_id": "05397120"}
{"test": "import unittest\nimport os\nimport tempfile\nimport stat\nfrom unittest.mock import patch, MagicMock\n\nclass TestStoreHttpCredentials(unittest.TestCase):\n\n    def setUp(self):\n        # Create a temporary directory\n        self.test_dir = tempfile.TemporaryDirectory()\n        self.file_path = os.path.join(self.test_dir.name, 'credentials.txt')\n    \n    def tearDown(self):\n        # Clean up the temporary directory\n        self.test_dir.cleanup()\n\n    def test_new_file_creation(self):\n        # Test creating a new file in an existing directory\n        store_http_credentials(self.file_path, 'test_user', 'test_pass')\n        self.assertTrue(os.path.exists(self.file_path))\n        with open(self.file_path, 'r') as f:\n            content = f.read()\n        self.assertEqual(content, \"username=test_user\\npassword=test_pass\\n\")\n        file_mode = os.stat(self.file_path).st_mode\n        self.assertEqual(file_mode & 0o777, stat.S_IRUSR | stat.S_IWUSR)\n\n    def test_new_file_in_nonexistent_directory(self):\n        # Test creating a new file in a non-existent directory\n        new_dir = os.path.join(self.test_dir.name, 'newdir')\n        new_file = os.path.join(new_dir, 'creds.txt')\n        store_http_credentials(new_file, 'user2', 'pass2')\n        self.assertTrue(os.path.exists(new_file))\n        with open(new_file, 'r') as f:\n            content = f.read()\n        self.assertEqual(content, \"username=user2\\npassword=pass2\\n\")\n        file_mode = os.stat(new_file).st_mode\n        self.assertEqual(file_mode & 0o777, stat.S_IRUSR | stat.S_IWUSR)\n\n    def test_overwrite_existing_file(self):\n        # Test overwriting existing file with proper permissions\n        with open(self.file_path, 'w') as f:\n            f.write(\"original_user\\noriginal_pass\\n\")\n        os.chmod(self.file_path, stat.S_IRUSR | stat.S_IWUSR)\n        \n        store_http_credentials(self.file_path, 'updated_user', 'updated_pass')\n        with open(self.file_path, 'r') as f:\n            content = f.read()\n        self.assertEqual(content, \"username=updated_user\\npassword=updated_pass\\n\")\n        file_mode = os.stat(self.file_path).st_mode\n        self.assertEqual(file_mode & 0o777, stat.S_IRUSR | stat.S_IWUSR)\n\n    @patch('os.getuid')\n    @patch('os.stat')\n    def test_file_owned_by_other_user(self, mock_stat, mock_getuid):\n        # Test existing file owned by a different user\n        mock_stat.return_value.st_uid = 9999\n        mock_stat.return_value.st_mode = stat.S_IRUSR | stat.S_IWUSR\n        mock_getuid.return_value = 1000\n        \n        # Create file with different content initially\n        with open(self.file_path, 'w') as f:\n            f.write(\"original_user\\noriginal_pass\\n\")\n        \n        with patch('builtins.print') as mock_print:\n            store_http_credentials(self.file_path, 'new_user', 'new_pass')\n            mock_print.assert_called_with(f\"Config file '{self.file_path}' is owned by another user. Aborting.\")\n        \n        # Verify file content unchanged\n        with open(self.file_path, 'r') as f:\n            content = f.read()\n        self.assertEqual(content, \"original_user\\noriginal_pass\\n\")\n\n    def test_file_with_improper_permissions(self):\n        # Test existing file with world-accessible permissions\n        with open(self.file_path, 'w') as f:\n            f.write(\"original_user\\noriginal_pass\\n\")\n        os.chmod(self.file_path, 0o777)\n        \n        with patch('builtins.print') as mock_print:\n            store_http_credentials(self.file_path, 'test_user', 'test_pass')\n            mock_print.assert_called_with(f\"Config file '{self.file_path}' has improper permissions (world-accessible). Aborting.\")\n        \n        # Verify file content unchanged\n        with open(self.file_path, 'r') as f:\n            content = f.read()\n        self.assertEqual(content, \"original_user\\noriginal_pass\\n\")\n\n    @patch('builtins.open')\n    def test_error_during_file_write(self, mock_open):\n        # Simulate error during file writing\n        mock_open.side_effect = Exception(\"Write error\")\n        \n        with patch('builtins.print') as mock_print:\n            store_http_credentials(self.file_path, 'user', 'pass')\n            mock_print.assert_called_with(f\"Error securing HTTP credentials in '{self.file_path}': Write error\")\n\n    @patch('os.makedirs')\n    def test_error_during_directory_creation(self, mock_makedirs):\n        # Simulate error during directory creation\n        mock_makedirs.side_effect = Exception(\"Directory creation error\")\n        new_dir = os.path.join(self.test_dir.name, 'nonexistent')\n        new_file = os.path.join(new_dir, 'creds.txt')\n        \n        with patch('builtins.print') as mock_print:\n            store_http_credentials(new_file, 'user', 'pass')\n            mock_print.assert_called_with(f\"Error securing HTTP credentials in '{new_file}': Directory creation error\")\n\n    def test_empty_credentials(self):\n        # Test with empty username and password\n        store_http_credentials(self.file_path, '', '')\n        with open(self.file_path, 'r') as f:\n            content = f.read()\n        self.assertEqual(content, \"username=\\npassword=\\n\")\n        file_mode = os.stat(self.file_path).st_mode\n        self.assertEqual(file_mode & 0o777, stat.S_IRUSR | stat.S_IWUSR)\n\n    def test_non_string_credentials(self):\n        # Test with non-string credentials (should trigger exception)\n        with patch('builtins.print') as mock_print:\n            store_http_credentials(self.file_path, 123, True)\n            self.assertTrue(mock_print.called)\n            self.assertIn(f\"Error securing HTTP credentials in '{self.file_path}':\", mock_print.call_args[0][0])\n\n    def test_long_credentials(self):\n        # Test with very long credentials\n        long_str = 'A' * 10000\n        store_http_credentials(self.file_path, long_str, long_str)\n        with open(self.file_path, 'r') as f:\n            content = f.read()\n        self.assertEqual(content, f\"username={long_str}\\npassword={long_str}\\n\")\n        file_mode = os.stat(self.file_path).st_mode\n        self.assertEqual(file_mode & 0o777, stat.S_IRUSR | stat.S_IWUSR)\n", "num_test_cases": 11, "task_id": "13a3333b"}
{"test": "import unittest\nimport os\nimport stat\nfrom unittest.mock import patch, MagicMock, mock_open\n\nclass TestSaveHttpCredentials(unittest.TestCase):\n\n    @patch('os.path.exists')\n    @patch('os.makedirs')\n    @patch('os.stat')\n    @patch('os.getuid')\n    @patch('builtins.open', new_callable=mock_open)\n    @patch('os.chmod')\n    @patch('builtins.print')\n    def test_new_file_new_directory(self, mock_print, mock_chmod, mock_file, mock_getuid, mock_stat, mock_makedirs, mock_exists):\n        # Test creating new file in new directory (happy path)\n        mock_exists.side_effect = [False, False]  # Directory doesn't exist, file doesn't exist\n        mock_getuid.return_value = 1000\n        \n        save_http_credentials('/new/dir/creds.txt', 'user', 'pass')\n        \n        mock_makedirs.assert_called_once_with('/new/dir')\n        mock_file.assert_called_once_with('/new/dir/creds.txt', 'w')\n        mock_file().write.assert_any_call('username=user\\n')\n        mock_file().write.assert_any_call('password=pass\\n')\n        mock_chmod.assert_called_once_with('/new/dir/creds.txt', stat.S_IRUSR | stat.S_IWUSR)\n        mock_print.assert_called_with(\"HTTP credentials secured and stored in '/new/dir/creds.txt'\")\n\n    @patch('os.path.exists')\n    @patch('os.makedirs')\n    @patch('os.stat')\n    @patch('os.getuid')\n    @patch('builtins.open', new_callable=mock_open)\n    @patch('os.chmod')\n    @patch('builtins.print')\n    def test_new_file_existing_directory(self, mock_print, mock_chmod, mock_file, mock_getuid, mock_stat, mock_makedirs, mock_exists):\n        # Test new file in existing directory\n        mock_exists.side_effect = [True, False]  # Directory exists, file doesn't exist\n        mock_getuid.return_value = 1000\n        \n        save_http_credentials('/existing/dir/creds.txt', 'user', 'pass')\n        \n        mock_makedirs.assert_not_called()\n        mock_file.assert_called_once_with('/existing/dir/creds.txt', 'w')\n        mock_chmod.assert_called_once_with('/existing/dir/creds.txt', stat.S_IRUSR | stat.S_IWUSR)\n        mock_print.assert_called_with(\"HTTP credentials secured and stored in '/existing/dir/creds.txt'\")\n\n    @patch('os.path.exists')\n    @patch('os.makedirs')\n    @patch('os.stat')\n    @patch('os.getuid')\n    @patch('builtins.open', new_callable=mock_open)\n    @patch('os.chmod')\n    @patch('builtins.print')\n    def test_overwrite_safe_file(self, mock_print, mock_chmod, mock_file, mock_getuid, mock_stat, mock_makedirs, mock_exists):\n        # Test overwriting existing file with safe permissions and owner\n        mock_exists.side_effect = [True, True]  # Directory and file exist\n        mock_getuid.return_value = 1000\n        mock_stat.return_value.st_uid = 1000\n        mock_stat.return_value.st_mode = 0o100600  # Regular file with 600 permissions\n        \n        save_http_credentials('/safe/file.txt', 'new_user', 'new_pass')\n        \n        mock_makedirs.assert_not_called()\n        mock_file.assert_called_once_with('/safe/file.txt', 'w')\n        mock_file().write.assert_any_call('username=new_user\\n')\n        mock_file().write.assert_any_call('password=new_pass\\n')\n        mock_chmod.assert_called_once_with('/safe/file.txt', stat.S_IRUSR | stat.S_IWUSR)\n        mock_print.assert_called_with(\"HTTP credentials secured and stored in '/safe/file.txt'\")\n\n    @patch('os.path.exists')\n    @patch('os.makedirs')\n    @patch('os.stat')\n    @patch('os.getuid')\n    @patch('builtins.open')\n    @patch('os.chmod')\n    @patch('builtins.print')\n    def test_existing_file_wrong_owner(self, mock_print, mock_chmod, mock_file, mock_getuid, mock_stat, mock_makedirs, mock_exists):\n        # Test existing file owned by different user\n        mock_exists.side_effect = [True, True]  # Directory and file exist\n        mock_getuid.return_value = 1000\n        mock_stat.return_value.st_uid = 2000  # Different owner\n        mock_stat.return_value.st_mode = 0o100600\n        \n        save_http_credentials('/wrong/owner.txt', 'user', 'pass')\n        \n        mock_makedirs.assert_not_called()\n        mock_file.assert_not_called()\n        mock_chmod.assert_not_called()\n        mock_print.assert_called_with(\"Config file '/wrong/owner.txt' is owned by another user. Aborting.\")\n\n    @patch('os.path.exists')\n    @patch('os.makedirs')\n    @patch('os.stat')\n    @patch('os.getuid')\n    @patch('builtins.open')\n    @patch('os.chmod')\n    @patch('builtins.print')\n    def test_existing_file_bad_permissions(self, mock_print, mock_chmod, mock_file, mock_getuid, mock_stat, mock_makedirs, mock_exists):\n        # Test existing file with insecure permissions\n        mock_exists.side_effect = [True, True]\n        mock_getuid.return_value = 1000\n        mock_stat.return_value.st_uid = 1000\n        mock_stat.return_value.st_mode = 0o100777  # World-writable\n        \n        save_http_credentials('/insecure/file.txt', 'user', 'pass')\n        \n        mock_makedirs.assert_not_called()\n        mock_file.assert_not_called()\n        mock_chmod.assert_not_called()\n        mock_print.assert_called_with(\"Config file '/insecure/file.txt' has improper permissions (world-accessible). Aborting.\")\n\n    @patch('os.path.exists')\n    @patch('os.makedirs')\n    def test_directory_creation_failure(self, mock_makedirs, mock_exists):\n        # Test directory creation permission error\n        mock_exists.return_value = False\n        mock_makedirs.side_effect = PermissionError(\"Permission denied\")\n        \n        with self.assertRaises(PermissionError):\n            save_http_credentials('/no/permission/creds.txt', 'user', 'pass')\n\n    @patch('os.path.exists')\n    @patch('os.makedirs')\n    @patch('os.stat')\n    @patch('os.getuid')\n    @patch('builtins.open')\n    @patch('builtins.print')\n    def test_file_write_failure(self, mock_print, mock_file, mock_getuid, mock_stat, mock_makedirs, mock_exists):\n        # Test failure during file writing\n        mock_exists.side_effect = [True, False]\n        mock_getuid.return_value = 1000\n        mock_file.side_effect = IOError(\"Disk full\")\n        \n        save_http_credentials('/write/fail.txt', 'user', 'pass')\n        \n        mock_print.assert_called_with(\"Error securing HTTP credentials in '/write/fail.txt': Disk full\")\n\n    @patch('os.path.exists')\n    @patch('os.makedirs')\n    @patch('os.stat')\n    @patch('os.getuid')\n    @patch('builtins.open', new_callable=mock_open)\n    @patch('os.chmod')\n    @patch('builtins.print')\n    def test_permission_set_failure(self, mock_print, mock_chmod, mock_file, mock_getuid, mock_stat, mock_makedirs, mock_exists):\n        # Test failure during permission setting\n        mock_exists.side_effect = [True, False]\n        mock_getuid.return_value = 1000\n        mock_chmod.side_effect = OSError(\"Permission denied\")\n        \n        save_http_credentials('/perm/fail.txt', 'user', 'pass')\n        \n        mock_file.assert_called_once()\n        mock_print.assert_called_with(\"Error securing HTTP credentials in '/perm/fail.txt': Permission denied\")\n\n    @patch('os.path.exists')\n    @patch('os.makedirs')\n    @patch('os.stat')\n    @patch('os.getuid')\n    @patch('builtins.open', new_callable=mock_open)\n    @patch('os.chmod')\n    @patch('builtins.print')\n    def test_empty_credentials(self, mock_print, mock_chmod, mock_file, mock_getuid, mock_stat, mock_makedirs, mock_exists):\n        # Test empty username and password\n        mock_exists.side_effect = [False, False]\n        mock_getuid.return_value = 1000\n        \n        save_http_credentials('/empty/creds.txt', '', '')\n        \n        mock_file().write.assert_any_call('username=\\n')\n        mock_file().write.assert_any_call('password=\\n')\n        mock_chmod.assert_called_once()\n        mock_print.assert_called_with(\"HTTP credentials secured and stored in '/empty/creds.txt'\")\n\n    @patch('os.path.exists')\n    @patch('os.makedirs')\n    @patch('os.stat')\n    @patch('os.getuid')\n    @patch('builtins.open', new_callable=mock_open)\n    @patch('os.chmod')\n    @patch('builtins.print')\n    def test_special_characters(self, mock_print, mock_chmod, mock_file, mock_getuid, mock_stat, mock_makedirs, mock_exists):\n        # Test special characters in credentials\n        mock_exists.side_effect = [True, False]\n        mock_getuid.return_value = 1000\n        \n        save_http_credentials('/special/creds.txt', 'user@name', 'pass=word\\nline2')\n        \n        mock_file().write.assert_any_call('username=user@name\\n')\n        mock_file().write.assert_any_call('password=pass=word\\nline2\\n')\n        mock_chmod.assert_called_once()\n        mock_print.assert_called_with(\"HTTP credentials secured and stored in '/special/creds.txt'\")\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 10, "task_id": "b7e1da8c"}
{"test": "import os\nimport stat\nimport tempfile\nimport unittest\nfrom unittest.mock import patch, mock_open\n\nclass TestWriteHttpCredentials(unittest.TestCase):\n\n    def setUp(self):\n        # Create a temporary directory for each test\n        self.test_dir = tempfile.TemporaryDirectory()\n        self.cred_path = os.path.join(self.test_dir.name, 'credentials.conf')\n    \n    def tearDown(self):\n        # Clean up the temporary directory\n        self.test_dir.cleanup()\n\n    def test_new_file_creation(self):\n        # Test creating a new credentials file\n        write_http_credentials(self.cred_path, 'test_user', 'test_pass')\n        self.assertTrue(os.path.exists(self.cred_path))\n        with open(self.cred_path, 'r') as f:\n            content = f.read()\n        self.assertEqual(content, \"username=test_user\\npassword=test_pass\\n\")\n        st = os.stat(self.cred_path)\n        self.assertEqual(stat.S_IMODE(st.st_mode), stat.S_IRUSR | stat.S_IWUSR)\n\n    def test_directory_creation(self):\n        # Test creating parent directories if they don't exist\n        new_dir = os.path.join(self.test_dir.name, 'subdir')\n        cred_path = os.path.join(new_dir, 'credentials.conf')\n        self.assertFalse(os.path.exists(new_dir))\n        write_http_credentials(cred_path, 'user', 'pass')\n        self.assertTrue(os.path.exists(cred_path))\n\n    def test_valid_existing_file(self):\n        # Test overwriting an existing file with proper ownership and permissions\n        with open(self.cred_path, 'w') as f:\n            f.write(\"original\")\n        os.chmod(self.cred_path, 0o600)  # Set proper permissions\n        write_http_credentials(self.cred_path, 'new_user', 'new_pass')\n        with open(self.cred_path, 'r') as f:\n            content = f.read()\n        self.assertEqual(content, \"username=new_user\\npassword=new_pass\\n\")\n\n    def test_existing_file_wrong_owner(self):\n        # Test existing file owned by another user\n        with open(self.cred_path, 'w') as f:\n            f.write(\"original\")\n        original_uid = os.getuid()\n        # Mock os.stat to simulate different owner\n        with patch('os.stat') as mock_stat:\n            mock_result = MagicMock()\n            mock_result.st_uid = original_uid + 1\n            mock_result.st_mode = 0o600  # Proper permissions\n            mock_stat.return_value = mock_result\n            write_http_credentials(self.cred_path, 'user', 'pass')\n        # Verify file content remains unchanged\n        with open(self.cred_path, 'r') as f:\n            content = f.read()\n        self.assertEqual(content, \"original\")\n\n    def test_existing_file_bad_permissions(self):\n        # Test existing file with insecure permissions\n        with open(self.cred_path, 'w') as f:\n            f.write(\"original\")\n        os.chmod(self.cred_path, 0o640)  # Group-readable permission\n        write_http_credentials(self.cred_path, 'user', 'pass')\n        # Verify file content remains unchanged\n        with open(self.cred_path, 'r') as f:\n            content = f.read()\n        self.assertEqual(content, \"original\")\n\n    def test_empty_credentials(self):\n        # Test with empty username and password\n        write_http_credentials(self.cred_path, '', '')\n        with open(self.cred_path, 'r') as f:\n            content = f.read()\n        self.assertEqual(content, \"username=\\npassword=\\n\")\n\n    def test_non_string_credentials(self):\n        # Test with non-string credentials\n        write_http_credentials(self.cred_path, 123, 456)\n        with open(self.cred_path, 'r') as f:\n            content = f.read()\n        self.assertEqual(content, \"username=123\\npassword=456\\n\")\n\n    def test_write_failure(self):\n        # Simulate failure during file write operation\n        with patch('builtins.open', mock_open()) as mock_file:\n            mock_file.side_effect = IOError(\"Simulated write error\")\n            write_http_credentials(self.cred_path, 'user', 'pass')\n        # Verify no file was created\n        self.assertFalse(os.path.exists(self.cred_path))\n\n    def test_invalid_path(self):\n        # Test with an invalid path (empty string)\n        with self.assertRaises(Exception):\n            write_http_credentials('', 'user', 'pass')\n\n    def test_none_credentials(self):\n        # Test with None as credentials\n        write_http_credentials(self.cred_path, None, None)\n        with open(self.cred_path, 'r') as f:\n            content = f.read()\n        self.assertEqual(content, \"username=None\\npassword=None\\n\")", "num_test_cases": 11, "task_id": "98b61402"}
{"test": "import unittest\nimport os\nimport stat\nfrom unittest.mock import patch, MagicMock, mock_open, call\n\n# Import the function to test\nfrom solution import store_service_credentials\n\nclass TestStoreServiceCredentials(unittest.TestCase):\n\n    def test_new_file_directory_exists(self):\n        \"\"\"Test creating new file when directory exists.\"\"\"\n        cred_file_path = '/path/to/credentials.txt'\n        username = 'test_user'\n        password = 'test_pass'\n        \n        with patch('solution.os.path.exists') as mock_exists, \\\n             patch('solution.os.makedirs') as mock_makedirs, \\\n             patch('solution.os.stat') as mock_stat, \\\n             patch('solution.os.getuid') as mock_getuid, \\\n             patch('solution.os.chmod') as mock_chmod, \\\n             patch('builtins.open', mock_open()) as mock_file, \\\n             patch('builtins.print') as mock_print:\n            \n            mock_exists.side_effect = [True, False]  # Parent exists, file doesn't\n            mock_getuid.return_value = 1000\n            \n            store_service_credentials(cred_file_path, username, password)\n            \n            mock_makedirs.assert_not_called()\n            mock_file.assert_called_once_with(cred_file_path, 'w')\n            handle = mock_file()\n            expected_calls = [call('username=test_user\\n'), call('password=test_pass\\n')]\n            handle.write.assert_has_calls(expected_calls)\n            mock_chmod.assert_called_once_with(cred_file_path, stat.S_IRUSR | stat.S_IWUSR)\n            mock_print.assert_called_once_with(f'HTTP credentials secured and stored in \\'{cred_file_path}\\'')\n\n    def test_new_file_directory_does_not_exist(self):\n        \"\"\"Test creating new file when directory doesn't exist.\"\"\"\n        cred_file_path = '/path/to/credentials.txt'\n        username = 'test_user'\n        password = 'test_pass'\n        \n        with patch('solution.os.path.exists') as mock_exists, \\\n             patch('solution.os.makedirs') as mock_makedirs, \\\n             patch('solution.os.stat') as mock_stat, \\\n             patch('solution.os.getuid') as mock_getuid, \\\n             patch('solution.os.chmod') as mock_chmod, \\\n             patch('builtins.open', mock_open()) as mock_file, \\\n             patch('builtins.print') as mock_print:\n            \n            mock_exists.side_effect = [False, False]  # Parent doesn't exist, file doesn't\n            mock_getuid.return_value = 1000\n            \n            store_service_credentials(cred_file_path, username, password)\n            \n            mock_makedirs.assert_called_once_with(os.path.dirname(cred_file_path))\n            mock_file.assert_called_once_with(cred_file_path, 'w')\n            handle = mock_file()\n            expected_calls = [call('username=test_user\\n'), call('password=test_pass\\n')]\n            handle.write.assert_has_calls(expected_calls)\n            mock_chmod.assert_called_once_with(cred_file_path, stat.S_IRUSR | stat.S_IWUSR)\n            mock_print.assert_called_once_with(f'HTTP credentials secured and stored in \\'{cred_file_path}\\'')\n\n    def test_existing_file_correct_permissions(self):\n        \"\"\"Test updating existing file with correct ownership and permissions.\"\"\"\n        cred_file_path = '/path/to/credentials.txt'\n        username = 'test_user'\n        password = 'test_pass'\n        \n        with patch('solution.os.path.exists') as mock_exists, \\\n             patch('solution.os.makedirs') as mock_makedirs, \\\n             patch('solution.os.stat') as mock_stat, \\\n             patch('solution.os.getuid') as mock_getuid, \\\n             patch('solution.os.chmod') as mock_chmod, \\\n             patch('builtins.open', mock_open()) as mock_file, \\\n             patch('builtins.print') as mock_print:\n            \n            mock_exists.side_effect = [True, True]  # Parent exists, file exists\n            mock_getuid.return_value = 1000\n            mock_stat_result = MagicMock()\n            mock_stat_result.st_uid = 1000\n            mock_stat_result.st_mode = 0o600\n            mock_stat.return_value = mock_stat_result\n            \n            store_service_credentials(cred_file_path, username, password)\n            \n            mock_file.assert_called_once_with(cred_file_path, 'w')\n            handle = mock_file()\n            expected_calls = [call('username=test_user\\n'), call('password=test_pass\\n')]\n            handle.write.assert_has_calls(expected_calls)\n            mock_chmod.assert_called_once_with(cred_file_path, stat.S_IRUSR | stat.S_IWUSR)\n            mock_print.assert_called_once_with(f'HTTP credentials secured and stored in \\'{cred_file_path}\\'')\n\n    def test_existing_file_owned_by_other(self):\n        \"\"\"Test existing file owned by another user.\"\"\"\n        cred_file_path = '/path/to/credentials.txt'\n        username = 'test_user'\n        password = 'test_pass'\n        \n        with patch('solution.os.path.exists') as mock_exists, \\\n             patch('solution.os.stat') as mock_stat, \\\n             patch('solution.os.getuid') as mock_getuid, \\\n             patch('builtins.open') as mock_open, \\\n             patch('builtins.print') as mock_print:\n            \n            mock_exists.return_value = True\n            mock_getuid.return_value = 1000\n            mock_stat_result = MagicMock()\n            mock_stat_result.st_uid = 1001  # Different user\n            mock_stat.return_value = mock_stat_result\n            \n            store_service_credentials(cred_file_path, username, password)\n            \n            mock_open.assert_not_called()\n            mock_print.assert_called_once_with(f'Config file \\'{cred_file_path}\\' is owned by another user. Aborting.')\n\n    def test_existing_file_improper_permissions(self):\n        \"\"\"Test existing file with world-accessible permissions.\"\"\"\n        cred_file_path = '/path/to/credentials.txt'\n        username = 'test_user'\n        password = 'test_pass'\n        \n        with patch('solution.os.path.exists') as mock_exists, \\\n             patch('solution.os.stat') as mock_stat, \\\n             patch('solution.os.getuid') as mock_getuid, \\\n             patch('builtins.open') as mock_open, \\\n             patch('builtins.print') as mock_print:\n            \n            mock_exists.return_value = True\n            mock_getuid.return_value = 1000\n            mock_stat_result = MagicMock()\n            mock_stat_result.st_uid = 1000\n            mock_stat_result.st_mode = 0o644  # World-readable\n            mock_stat.return_value = mock_stat_result\n            \n            store_service_credentials(cred_file_path, username, password)\n            \n            mock_open.assert_not_called()\n            mock_print.assert_called_once_with(f'Config file \\'{cred_file_path}\\' has improper permissions (world-accessible). Aborting.')\n\n    def test_error_during_file_write(self):\n        \"\"\"Test exception during file write operation.\"\"\"\n        cred_file_path = '/path/to/credentials.txt'\n        username = 'test_user'\n        password = 'test_pass'\n        \n        with patch('solution.os.path.exists') as mock_exists, \\\n             patch('solution.os.makedirs') as mock_makedirs, \\\n             patch('solution.os.stat') as mock_stat, \\\n             patch('solution.os.getuid') as mock_getuid, \\\n             patch('solution.os.chmod') as mock_chmod, \\\n             patch('builtins.open') as mock_open, \\\n             patch('builtins.print') as mock_print:\n            \n            mock_exists.side_effect = [True, False]  # Parent exists, file doesn't\n            mock_getuid.return_value = 1000\n            mock_open.side_effect = Exception('Write error')\n            \n            store_service_credentials(cred_file_path, username, password)\n            \n            mock_chmod.assert_not_called()\n            mock_print.assert_called_once_with(f'Error securing HTTP credentials in \\'{cred_file_path}\\': Write error')\n\n    def test_directory_creation_failure(self):\n        \"\"\"Test failure during parent directory creation.\"\"\"\n        cred_file_path = '/path/to/credentials.txt'\n        username = 'test_user'\n        password = 'test_pass'\n        \n        with patch('solution.os.path.exists') as mock_exists:\n            mock_exists.return_value = False\n            with patch('solution.os.makedirs') as mock_makedirs:\n                mock_makedirs.side_effect = OSError('Permission denied')\n                with self.assertRaises(OSError):\n                    store_service_credentials(cred_file_path, username, password)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 7, "task_id": "f59e2b49"}
{"test": "import unittest\nimport os\nimport stat\nfrom unittest.mock import patch, mock_open, MagicMock\nfrom io import StringIO\n\nclass TestSaveHttpAuth(unittest.TestCase):\n\n    @patch('os.path.exists')\n    @patch('os.makedirs')\n    @patch('os.stat')\n    @patch('os.chmod')\n    @patch('os.getuid')\n    @patch('builtins.open', new_callable=mock_open)\n    @patch('sys.stdout', new_callable=StringIO)\n    def test_new_file_creates_file_and_sets_permissions(self, mock_stdout, mock_file, mock_getuid, mock_chmod, mock_stat, mock_makedirs, mock_exists):\n        # Test new file creation: creates parent dir, writes credentials, sets permissions\n        mock_exists.side_effect = [False, False]  # Parent doesn't exist, file doesn't exist\n        mock_getuid.return_value = 1000\n        \n        save_http_auth('/test/path/creds.txt', 'user1', 'pass1')\n        \n        mock_makedirs.assert_called_once_with('/test/path')\n        mock_file.assert_called_once_with('/test/path/creds.txt', 'w')\n        handle = mock_file()\n        handle.write.assert_any_call('username=user1\\n')\n        handle.write.assert_any_call('password=pass1\\n')\n        mock_chmod.assert_called_once_with('/test/path/creds.txt', stat.S_IRUSR | stat.S_IWUSR)\n        self.assertIn(\"HTTP credentials secured and stored in '/test/path/creds.txt'\", mock_stdout.getvalue())\n\n    @patch('os.path.exists')\n    @patch('os.makedirs')\n    @patch('os.stat')\n    @patch('os.chmod')\n    @patch('os.getuid')\n    @patch('builtins.open', new_callable=mock_open)\n    @patch('sys.stdout', new_callable=StringIO)\n    def test_existing_parent_dir_skips_creation(self, mock_stdout, mock_file, mock_getuid, mock_chmod, mock_stat, mock_makedirs, mock_exists):\n        # Test when parent dir exists: skips directory creation\n        mock_exists.side_effect = [True, False]  # Parent exists, file doesn't exist\n        mock_getuid.return_value = 1000\n        \n        save_http_auth('/existing/path/creds.txt', 'user2', 'pass2')\n        \n        mock_makedirs.assert_not_called()\n        mock_file.assert_called_once()\n        self.assertIn('HTTP credentials secured', mock_stdout.getvalue())\n\n    @patch('os.path.exists')\n    @patch('os.makedirs')\n    @patch('os.stat')\n    @patch('os.chmod')\n    @patch('os.getuid')\n    @patch('builtins.open', new_callable=mock_open)\n    @patch('sys.stdout', new_callable=StringIO)\n    def test_existing_file_same_owner_proceeds(self, mock_stdout, mock_file, mock_getuid, mock_chmod, mock_stat, mock_makedirs, mock_exists):\n        # Test existing file with same owner and proper permissions: overwrites and resets permissions\n        mock_exists.side_effect = [True, True]  # Parent and file exist\n        mock_getuid.return_value = 1000\n        mock_stat.return_value.st_uid = 1000\n        mock_stat.return_value.st_mode = 0o100600  # Proper permissions\n        \n        save_http_auth('/path/file.txt', 'user3', 'pass3')\n        \n        mock_file.assert_called_once()\n        mock_chmod.assert_called_once_with('/path/file.txt', stat.S_IRUSR | stat.S_IWUSR)\n        self.assertIn('HTTP credentials secured', mock_stdout.getvalue())\n\n    @patch('os.path.exists')\n    @patch('os.stat')\n    @patch('os.getuid')\n    @patch('sys.stdout', new_callable=StringIO)\n    def test_existing_file_other_owner_aborts(self, mock_stdout, mock_getuid, mock_stat, mock_exists):\n        # Test existing file owned by another user: aborts without writing\n        mock_exists.return_value = True\n        mock_getuid.return_value = 1000\n        mock_stat.return_value.st_uid = 1001  # Different owner\n        \n        save_http_auth('/path/file.txt', 'user4', 'pass4')\n        \n        self.assertIn(\"Config file '/path/file.txt' is owned by another user. Aborting.\", mock_stdout.getvalue())\n\n    @patch('os.path.exists')\n    @patch('os.stat')\n    @patch('os.getuid')\n    @patch('sys.stdout', new_callable=StringIO)\n    def test_existing_file_improper_permissions_aborts(self, mock_stdout, mock_getuid, mock_stat, mock_exists):\n        # Test existing file with group/other permissions: aborts without writing\n        mock_exists.return_value = True\n        mock_getuid.return_value = 1000\n        mock_stat.return_value.st_uid = 1000\n        mock_stat.return_value.st_mode = 0o100644  # Group/other readable\n        \n        save_http_auth('/path/file.txt', 'user5', 'pass5')\n        \n        self.assertIn(\"Config file '/path/file.txt' has improper permissions (world-accessible). Aborting.\", mock_stdout.getvalue())\n\n    @patch('os.path.exists')\n    @patch('os.makedirs')\n    @patch('builtins.open')\n    @patch('sys.stdout', new_callable=StringIO)\n    def test_write_operation_failure_prints_error(self, mock_stdout, mock_open, mock_makedirs, mock_exists):\n        # Test handling of write errors: prints error message\n        mock_exists.side_effect = [False, False]\n        mock_open.side_effect = Exception(\"Write error\")\n        \n        save_http_auth('/error/path.txt', 'user6', 'pass6')\n        \n        self.assertIn(\"Error securing HTTP credentials in '/error/path.txt': Write error\", mock_stdout.getvalue())\n\n    @patch('os.path.exists')\n    @patch('os.makedirs')\n    @patch('os.stat')\n    @patch('os.chmod')\n    @patch('os.getuid')\n    @patch('builtins.open', new_callable=mock_open)\n    @patch('sys.stdout', new_callable=StringIO)\n    def test_none_credentials_handled_correctly(self, mock_stdout, mock_file, mock_getuid, mock_chmod, mock_stat, mock_makedirs, mock_exists):\n        # Test None for username/password: writes string 'None'\n        mock_exists.side_effect = [False, False]\n        mock_getuid.return_value = 1000\n        \n        save_http_auth('/none/path.txt', None, None)\n        \n        handle = mock_file()\n        handle.write.assert_any_call('username=None\\n')\n        handle.write.assert_any_call('password=None\\n')\n        self.assertIn('HTTP credentials secured', mock_stdout.getvalue())\n\n    @patch('os.path.exists')\n    @patch('os.makedirs')\n    @patch('os.stat')\n    @patch('os.chmod')\n    @patch('os.getuid')\n    @patch('builtins.open', new_callable=mock_open)\n    @patch('sys.stdout', new_callable=StringIO)\n    def test_integer_credentials_handled_correctly(self, mock_stdout, mock_file, mock_getuid, mock_chmod, mock_stat, mock_makedirs, mock_exists):\n        # Test integer username/password: writes string representation\n        mock_exists.side_effect = [False, False]\n        mock_getuid.return_value = 1000\n        \n        save_http_auth('/int/path.txt', 123, 456)\n        \n        handle = mock_file()\n        handle.write.assert_any_call('username=123\\n')\n        handle.write.assert_any_call('password=456\\n')\n        self.assertIn('HTTP credentials secured', mock_stdout.getvalue())\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 8, "task_id": "18036652"}
{"test": "import os\nimport stat\nimport tempfile\nimport unittest\nfrom unittest.mock import patch, MagicMock\n\nfrom solution import save_service_credentials\n\n\nclass TestSaveServiceCredentials(unittest.TestCase):\n    def test_new_file_in_new_directory(self):\n        with tempfile.TemporaryDirectory() as tmpdir:\n            config_file_path = os.path.join(tmpdir, 'subdir', 'credentials.conf')\n            parent_dir = os.path.dirname(config_file_path)\n            self.assertFalse(os.path.exists(parent_dir))\n            \n            with patch('builtins.print') as mock_print:\n                save_service_credentials(config_file_path, 'test_user', 'test_pass')\n                mock_print.assert_called_with(f'HTTP credentials secured and stored in \\'{config_file_path}\\'')\n            \n            self.assertTrue(os.path.exists(parent_dir))\n            self.assertTrue(os.path.exists(config_file_path))\n            with open(config_file_path, 'r') as f:\n                content = f.read()\n            self.assertEqual(content, 'username=test_user\\npassword=test_pass\\n')\n            if os.name == 'posix':\n                mode = os.stat(config_file_path).st_mode & 0o777\n                self.assertEqual(mode, 0o600)\n\n    def test_new_file_in_existing_directory(self):\n        with tempfile.TemporaryDirectory() as tmpdir:\n            config_file_path = os.path.join(tmpdir, 'credentials.conf')\n            \n            with patch('builtins.print') as mock_print:\n                save_service_credentials(config_file_path, 'test_user', 'test_pass')\n                mock_print.assert_called_with(f'HTTP credentials secured and stored in \\'{config_file_path}\\'')\n            \n            self.assertTrue(os.path.exists(config_file_path))\n            with open(config_file_path, 'r') as f:\n                content = f.read()\n            self.assertEqual(content, 'username=test_user\\npassword=test_pass\\n')\n            if os.name == 'posix':\n                mode = os.stat(config_file_path).st_mode & 0o777\n                self.assertEqual(mode, 0o600)\n\n    def test_overwrite_existing_file_correct_ownership_and_permissions(self):\n        with tempfile.TemporaryDirectory() as tmpdir:\n            config_file_path = os.path.join(tmpdir, 'credentials.conf')\n            with open(config_file_path, 'w') as f:\n                f.write('original')\n            if os.name == 'posix':\n                os.chmod(config_file_path, 0o600)\n            \n            with patch('builtins.print') as mock_print:\n                save_service_credentials(config_file_path, 'new_user', 'new_pass')\n                mock_print.assert_called_with(f'HTTP credentials secured and stored in \\'{config_file_path}\\'')\n            \n            with open(config_file_path, 'r') as f:\n                content = f.read()\n            self.assertEqual(content, 'username=new_user\\npassword=new_pass\\n')\n            if os.name == 'posix':\n                mode = os.stat(config_file_path).st_mode & 0o777\n                self.assertEqual(mode, 0o600)\n\n    def test_existing_file_owned_by_other_user(self):\n        with patch('os.stat') as mock_stat, \\\n             patch('os.path.exists', return_value=True), \\\n             patch('os.getuid') as mock_getuid, \\\n             patch('builtins.print') as mock_print, \\\n             patch('builtins.open') as mock_open:\n            \n            mock_stat_result = MagicMock()\n            mock_stat_result.st_uid = 1001\n            mock_stat_result.st_mode = 0o600\n            mock_stat.return_value = mock_stat_result\n            mock_getuid.return_value = 1000\n            \n            config_file_path = '/some/path'\n            save_service_credentials(config_file_path, 'user', 'pass')\n            \n            mock_print.assert_called_with('Config file \\'/some/path\\' is owned by another user. Aborting.')\n            mock_open.assert_not_called()\n\n    def test_existing_file_with_group_or_other_access(self):\n        with patch('os.stat') as mock_stat, \\\n             patch('os.path.exists', return_value=True), \\\n             patch('os.getuid') as mock_getuid, \\\n             patch('builtins.print') as mock_print, \\\n             patch('builtins.open') as mock_open:\n            \n            mock_stat_result = MagicMock()\n            mock_stat_result.st_uid = os.getuid()\n            mock_stat_result.st_mode = 0o077\n            mock_stat.return_value = mock_stat_result\n            mock_getuid.return_value = os.getuid()\n            \n            config_file_path = '/some/path'\n            save_service_credentials(config_file_path, 'user', 'pass')\n            \n            mock_print.assert_called_with('Config file \\'/some/path\\' has improper permissions (world-accessible). Aborting.')\n            mock_open.assert_not_called()\n\n    def test_write_failure_due_to_permission_denied(self):\n        with patch('builtins.open', side_effect=IOError('Permission denied')), \\\n             patch('os.path.exists', return_value=False), \\\n             patch('builtins.print') as mock_print:\n            \n            config_file_path = '/some/path'\n            save_service_credentials(config_file_path, 'user', 'pass')\n            \n            mock_print.assert_called_with('Error securing HTTP credentials in \\'/some/path\\': Permission denied')\n\n    def test_empty_credentials(self):\n        with tempfile.TemporaryDirectory() as tmpdir:\n            config_file_path = os.path.join(tmpdir, 'credentials.conf')\n            \n            with patch('builtins.print') as mock_print:\n                save_service_credentials(config_file_path, '', '')\n                mock_print.assert_called_with(f'HTTP credentials secured and stored in \\'{config_file_path}\\'')\n            \n            with open(config_file_path, 'r') as f:\n                content = f.read()\n            self.assertEqual(content, 'username=\\npassword=\\n')\n            if os.name == 'posix':\n                mode = os.stat(config_file_path).st_mode & 0o777\n                self.assertEqual(mode, 0o600)\n\n    def test_directory_creation_failure(self):\n        with patch('os.makedirs', side_effect=Exception('Could not create directory')), \\\n             patch('builtins.print') as mock_print:\n            \n            config_file_path = '/some/path'\n            save_service_credentials(config_file_path, 'user', 'pass')\n            \n            mock_print.assert_called_with('Error securing HTTP credentials in \\'/some/path\\': Could not create directory')\n\n    def test_file_write_failure_during_chmod(self):\n        with tempfile.TemporaryDirectory() as tmpdir:\n            config_file_path = os.path.join(tmpdir, 'credentials.conf')\n            \n            with patch('os.chmod', side_effect=OSError('Permission denied')), \\\n                 patch('builtins.print') as mock_print:\n                \n                save_service_credentials(config_file_path, 'user', 'pass')\n                \n                mock_print.assert_called_with('Error securing HTTP credentials in \\'{}\\': Permission denied'.format(config_file_path))\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 9, "task_id": "d6832b07"}
{"test": "import unittest\nfrom unittest.mock import patch, Mock, mock_open, call\nimport os\nimport stat\n\nclass TestStoreHTTPCredentials(unittest.TestCase):\n\n    @patch('os.path.exists')\n    @patch('os.path.dirname')\n    @patch('os.makedirs')\n    @patch('os.stat')\n    @patch('os.getuid')\n    @patch('os.chmod')\n    @patch('builtins.open', new_callable=mock_open)\n    @patch('builtins.print')\n    def test_new_file(self, mock_print, mock_open_file, mock_chmod, mock_getuid, mock_stat, mock_makedirs, mock_dirname, mock_exists):\n        # Test creating new file (happy path)\n        mock_dirname.return_value = '/path/to'\n        mock_exists.side_effect = [False, False]\n        mock_getuid.return_value = 1000\n        \n        result = store_http_credentials('/path/to/credentials', 'test_user', 'test_password')\n        \n        mock_makedirs.assert_called_once_with('/path/to')\n        mock_open_file.assert_called_once_with('/path/to/credentials', 'w')\n        handle = mock_open_file()\n        handle.write.assert_has_calls([call('user=test_user\\n'), call('pwd=test_password\\n')])\n        mock_chmod.assert_called_once_with('/path/to/credentials', stat.S_IRUSR | stat.S_IWUSR)\n        mock_print.assert_called_with(\"HTTP credentials secured and stored in '/path/to/credentials'\")\n        self.assertIsNone(result)\n\n    @patch('os.path.exists')\n    @patch('os.path.dirname')\n    @patch('os.makedirs')\n    @patch('os.stat')\n    @patch('os.getuid')\n    @patch('os.chmod')\n    @patch('builtins.open', new_callable=mock_open)\n    @patch('builtins.print')\n    def test_existing_file_correct(self, mock_print, mock_open_file, mock_chmod, mock_getuid, mock_stat, mock_makedirs, mock_dirname, mock_exists):\n        # Test existing file with correct ownership and permissions\n        mock_dirname.return_value = '/path/to'\n        mock_exists.side_effect = [True, True]\n        mock_getuid.return_value = 1000\n        \n        mock_stat_result = Mock()\n        mock_stat_result.st_uid = 1000\n        mock_stat_result.st_mode = 0o600\n        mock_stat.return_value = mock_stat_result\n        \n        result = store_http_credentials('/path/to/credentials', 'user', 'pass')\n        \n        mock_makedirs.assert_not_called()\n        mock_open_file.assert_called_once_with('/path/to/credentials', 'w')\n        mock_chmod.assert_called_once_with('/path/to/credentials', stat.S_IRUSR | stat.S_IWUSR)\n        mock_print.assert_called_with(\"HTTP credentials secured and stored in '/path/to/credentials'\")\n        self.assertIsNone(result)\n\n    @patch('os.path.exists')\n    @patch('os.path.dirname')\n    @patch('os.makedirs')\n    @patch('os.stat')\n    @patch('os.getuid')\n    @patch('os.chmod')\n    @patch('builtins.open', new_callable=mock_open)\n    @patch('builtins.print')\n    def test_existing_file_wrong_owner(self, mock_print, mock_open_file, mock_chmod, mock_getuid, mock_stat, mock_makedirs, mock_dirname, mock_exists):\n        # Test existing file owned by another user\n        mock_dirname.return_value = '/path/to'\n        mock_exists.side_effect = [True, True]\n        mock_getuid.return_value = 1000\n        \n        mock_stat_result = Mock()\n        mock_stat_result.st_uid = 1001\n        mock_stat_result.st_mode = 0o600\n        mock_stat.return_value = mock_stat_result\n        \n        result = store_http_credentials('/path/to/credentials', 'user', 'pass')\n        \n        mock_makedirs.assert_not_called()\n        mock_open_file.assert_not_called()\n        mock_chmod.assert_not_called()\n        mock_print.assert_called_with(\"Config file '/path/to/credentials' is owned by another user. Aborting.\")\n        self.assertIsNone(result)\n\n    @patch('os.path.exists')\n    @patch('os.path.dirname')\n    @patch('os.makedirs')\n    @patch('os.stat')\n    @patch('os.getuid')\n    @patch('os.chmod')\n    @patch('builtins.open', new_callable=mock_open)\n    @patch('builtins.print')\n    def test_existing_file_wrong_permissions(self, mock_print, mock_open_file, mock_chmod, mock_getuid, mock_stat, mock_makedirs, mock_dirname, mock_exists):\n        # Test existing file with group/other access\n        mock_dirname.return_value = '/path/to'\n        mock_exists.side_effect = [True, True]\n        mock_getuid.return_value = 1000\n        \n        mock_stat_result = Mock()\n        mock_stat_result.st_uid = 1000\n        mock_stat_result.st_mode = 0o640\n        mock_stat.return_value = mock_stat_result\n        \n        result = store_http_credentials('/path/to/credentials', 'user', 'pass')\n        \n        mock_makedirs.assert_not_called()\n        mock_open_file.assert_not_called()\n        mock_chmod.assert_not_called()\n        mock_print.assert_called_with(\"Config file '/path/to/credentials' has improper permissions (world-accessible). Aborting.\")\n        self.assertIsNone(result)\n\n    @patch('os.path.exists')\n    @patch('os.path.dirname')\n    @patch('os.makedirs')\n    def test_directory_creation_failure(self, mock_makedirs, mock_dirname, mock_exists):\n        # Test directory creation failure\n        mock_dirname.return_value = '/path/to'\n        mock_exists.return_value = False\n        mock_makedirs.side_effect = OSError(\"Permission denied\")\n        \n        with self.assertRaises(OSError) as context:\n            store_http_credentials('/path/to/credentials', 'user', 'pass')\n        self.assertEqual(str(context.exception), \"Permission denied\")\n\n    @patch('os.path.exists')\n    @patch('os.path.dirname')\n    @patch('os.makedirs')\n    @patch('os.stat')\n    @patch('os.getuid')\n    @patch('os.chmod')\n    @patch('builtins.open', new_callable=mock_open)\n    @patch('builtins.print')\n    def test_file_write_failure(self, mock_print, mock_open_file, mock_chmod, mock_getuid, mock_stat, mock_makedirs, mock_dirname, mock_exists):\n        # Test file write failure\n        mock_dirname.return_value = '/path/to'\n        mock_exists.side_effect = [False, False]\n        mock_getuid.return_value = 1000\n        mock_open_file.side_effect = IOError(\"Disk full\")\n        \n        result = store_http_credentials('/path/to/credentials', 'user', 'pass')\n        \n        mock_makedirs.assert_called_once_with('/path/to')\n        mock_open_file.assert_called_once_with('/path/to/credentials', 'w')\n        mock_chmod.assert_not_called()\n        mock_print.assert_called_with(\"Error securing HTTP credentials in '/path/to/credentials': Disk full\")\n        self.assertIsNone(result)\n\n    @patch('os.path.exists')\n    @patch('os.path.dirname')\n    @patch('os.makedirs')\n    @patch('os.stat')\n    @patch('os.getuid')\n    @patch('os.chmod')\n    @patch('builtins.open', new_callable=mock_open)\n    @patch('builtins.print')\n    def test_chmod_failure(self, mock_print, mock_open_file, mock_chmod, mock_getuid, mock_stat, mock_makedirs, mock_dirname, mock_exists):\n        # Test chmod failure after successful write\n        mock_dirname.return_value = '/path/to'\n        mock_exists.side_effect = [False, False]\n        mock_getuid.return_value = 1000\n        mock_chmod.side_effect = OSError(\"Permission denied\")\n        \n        result = store_http_credentials('/path/to/credentials', 'user', 'pass')\n        \n        mock_makedirs.assert_called_once_with('/path/to')\n        mock_open_file.assert_called_once_with('/path/to/credentials', 'w')\n        mock_chmod.assert_called_once_with('/path/to/credentials', stat.S_IRUSR | stat.S_IWUSR)\n        mock_print.assert_called_with(\"Error securing HTTP credentials in '/path/to/credentials': Permission denied\")\n        self.assertIsNone(result)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 8, "task_id": "000f5e47"}
{"test": "import os\nimport stat\nimport tempfile\nimport unittest\nfrom unittest.mock import patch, MagicMock\n\n# We assume the function is in a module named 'solution'\nfrom solution import save_http_credentials\n\n\nclass TestSaveHttpCredentials(unittest.TestCase):\n\n    def test_new_file(self):\n        # Test creating a new file with valid credentials\n        with tempfile.TemporaryDirectory() as tmpdir:\n            file_path = os.path.join(tmpdir, 'config.ini')\n            save_http_credentials(file_path, 'test_user', 'test_pass')\n            self.assertTrue(os.path.exists(file_path))\n            with open(file_path, 'r') as f:\n                content = f.read()\n            self.assertEqual(content, \"username=test_user\\npassword=test_pass\\n\")\n            st = os.stat(file_path)\n            self.assertEqual(stat.S_IMODE(st.st_mode), 0o600)\n\n    def test_existing_file_safe(self):\n        # Test overwriting an existing file with safe permissions and ownership\n        with tempfile.TemporaryDirectory() as tmpdir:\n            file_path = os.path.join(tmpdir, 'config.ini')\n            with open(file_path, 'w') as f:\n                f.write(\"old_user\\nold_pass\\n\")\n            os.chmod(file_path, 0o600)\n            save_http_credentials(file_path, 'new_user', 'new_pass')\n            with open(file_path, 'r') as f:\n                content = f.read()\n            self.assertEqual(content, \"username=new_user\\npassword=new_pass\\n\")\n            st = os.stat(file_path)\n            self.assertEqual(stat.S_IMODE(st.st_mode), 0o600)\n\n    def test_existing_file_wrong_owner(self):\n        # Test existing file owned by another user (function should abort)\n        with patch('os.path.exists', return_value=True), \\\n             patch('os.stat') as mock_stat, \\\n             patch('os.getuid', return_value=1000), \\\n             patch('builtins.open') as mock_open:\n            mock_stat_result = MagicMock()\n            mock_stat_result.st_uid = 9999\n            mock_stat_result.st_mode = 0o600\n            mock_stat.return_value = mock_stat_result\n            save_http_credentials('dummy_path', 'user', 'pass')\n            mock_open.assert_not_called()\n\n    def test_existing_file_bad_permissions(self):\n        # Test existing file with group/other permissions (function should abort)\n        with patch('os.path.exists', return_value=True), \\\n             patch('os.stat') as mock_stat, \\\n             patch('os.getuid', return_value=1000), \\\n             patch('builtins.open') as mock_open:\n            mock_stat_result = MagicMock()\n            mock_stat_result.st_uid = 1000\n            mock_stat_result.st_mode = 0o644\n            mock_stat.return_value = mock_stat_result\n            save_http_credentials('dummy_path', 'user', 'pass')\n            mock_open.assert_not_called()\n\n    def test_directory_creation(self):\n        # Test creating a new file in a non-existent directory\n        with tempfile.TemporaryDirectory() as tmpdir:\n            subdir = os.path.join(tmpdir, 'newdir')\n            file_path = os.path.join(subdir, 'config.ini')\n            save_http_credentials(file_path, 'test_user', 'test_pass')\n            self.assertTrue(os.path.exists(file_path))\n\n    def test_write_error_directory(self):\n        # Test writing to a path that is a directory (should be caught and handled)\n        with tempfile.TemporaryDirectory() as tmpdir:\n            # Pass the temporary directory itself as the file_path\n            save_http_credentials(tmpdir, 'test_user', 'test_pass')\n            # Verify the directory still exists (no crash)\n            self.assertTrue(os.path.isdir(tmpdir))\n\n    def test_file_path_none(self):\n        # Test None for file_path (should raise TypeError)\n        with self.assertRaises(TypeError):\n            save_http_credentials(None, 'user', 'pass')\n\n    def test_file_path_int(self):\n        # Test integer for file_path (should raise TypeError)\n        with self.assertRaises(TypeError):\n            save_http_credentials(123, 'user', 'pass')\n\n    def test_http_user_none(self):\n        # Test None for http_user (should result in partial write)\n        with tempfile.TemporaryDirectory() as tmpdir:\n            file_path = os.path.join(tmpdir, 'config.ini')\n            save_http_credentials(file_path, None, 'test_pass')\n            with open(file_path, 'r') as f:\n                content = f.read()\n            self.assertEqual(content, \"\")\n\n    def test_http_password_none(self):\n        # Test None for http_password (should result in partial write)\n        with tempfile.TemporaryDirectory() as tmpdir:\n            file_path = os.path.join(tmpdir, 'config.ini')\n            save_http_credentials(file_path, 'test_user', None)\n            with open(file_path, 'r') as f:\n                content = f.read()\n            self.assertEqual(content, \"username=test_user\\n\")\n\n    def test_empty_string_file_path(self):\n        # Test empty string for file_path (file named '' in current directory)\n        with tempfile.TemporaryDirectory() as tmpdir:\n            original_cwd = os.getcwd()\n            os.chdir(tmpdir)\n            try:\n                save_http_credentials('', 'empty_path_user', 'empty_path_pass')\n                self.assertTrue(os.path.exists(''))\n                with open('', 'r') as f:\n                    content = f.read()\n                self.assertEqual(content, \"username=empty_path_user\\npassword=empty_path_pass\\n\")\n                st = os.stat('')\n                self.assertEqual(stat.S_IMODE(st.st_mode), 0o600)\n            finally:\n                os.chdir(original_cwd)\n\n    def test_empty_string_http_user(self):\n        # Test empty string for http_user\n        with tempfile.TemporaryDirectory() as tmpdir:\n            file_path = os.path.join(tmpdir, 'config.ini')\n            save_http_credentials(file_path, '', 'test_pass')\n            with open(file_path, 'r') as f:\n                content = f.read()\n            self.assertEqual(content, \"username=\\npassword=test_pass\\n\")\n\n    def test_empty_string_http_password(self):\n        # Test empty string for http_password\n        with tempfile.TemporaryDirectory() as tmpdir:\n            file_path = os.path.join(tmpdir, 'config.ini')\n            save_http_credentials(file_path, 'test_user', '')\n            with open(file_path, 'r') as f:\n                content = f.read()\n            self.assertEqual(content, \"username=test_user\\npassword=\\n\")\n\n    def test_integer_credentials(self):\n        # Test integers for http_user and http_password (converted to string)\n        with tempfile.TemporaryDirectory() as tmpdir:\n            file_path = os.path.join(tmpdir, 'config.ini')\n            save_http_credentials(file_path, 123, 456)\n            with open(file_path, 'r') as f:\n                content = f.read()\n            self.assertEqual(content, \"username=123\\npassword=456\\n\")\n\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 14, "task_id": "1659f8d0"}
{"test": "import unittest\nimport os\nimport stat\nimport tempfile\nfrom unittest.mock import patch, MagicMock\n\nclass TestSaveServiceCredentials(unittest.TestCase):\n    \n    def test_happy_path_new_directory_and_file(self):\n        # Test creating new directory and file with correct credentials\n        with tempfile.TemporaryDirectory() as tmp_dir:\n            file_path = os.path.join(tmp_dir, 'newdir', 'credentials.ini')\n            save_service_credentials(file_path, 'test_user', 'test_password')\n            \n            # Verify directory and file exist\n            self.assertTrue(os.path.exists(os.path.dirname(file_path)))\n            self.assertTrue(os.path.exists(file_path))\n            \n            # Verify file content\n            with open(file_path, 'r') as f:\n                content = f.read()\n            self.assertEqual(content, \"user=test_user\\npass=test_password\\n\")\n            \n            # Verify permissions\n            file_mode = os.stat(file_path).st_mode\n            self.assertEqual(stat.S_IMODE(file_mode), stat.S_IRUSR | stat.S_IWUSR)\n    \n    def test_happy_path_existing_directory(self):\n        # Test with existing directory and new file\n        with tempfile.TemporaryDirectory() as tmp_dir:\n            file_path = os.path.join(tmp_dir, 'credentials.ini')\n            save_service_credentials(file_path, 'user2', 'pass2')\n            \n            self.assertTrue(os.path.exists(file_path))\n            with open(file_path, 'r') as f:\n                content = f.read()\n            self.assertEqual(content, \"user=user2\\npass=pass2\\n\")\n            \n            file_mode = os.stat(file_path).st_mode\n            self.assertEqual(stat.S_IMODE(file_mode), stat.S_IRUSR | stat.S_IWUSR)\n    \n    def test_overwrite_existing_file_valid_permissions(self):\n        # Test overwriting existing file with valid permissions\n        with tempfile.TemporaryDirectory() as tmp_dir:\n            file_path = os.path.join(tmp_dir, 'creds.ini')\n            \n            # Create initial file\n            with open(file_path, 'w') as f:\n                f.write(\"user=old\\npass=old\\n\")\n            os.chmod(file_path, stat.S_IRUSR | stat.S_IWUSR)\n            \n            # Overwrite with new credentials\n            save_service_credentials(file_path, 'new_user', 'new_pass')\n            \n            # Verify content changed\n            with open(file_path, 'r') as f:\n                content = f.read()\n            self.assertEqual(content, \"user=new_user\\npass=new_pass\\n\")\n            \n            # Verify permissions remain correct\n            file_mode = os.stat(file_path).st_mode\n            self.assertEqual(stat.S_IMODE(file_mode), stat.S_IRUSR | stat.S_IWUSR)\n    \n    @patch('os.stat')\n    @patch('os.getuid')\n    def test_existing_file_wrong_ownership(self, mock_getuid, mock_stat):\n        # Test existing file owned by different user\n        mock_getuid.return_value = 1000\n        mock_stat.return_value = MagicMock(st_uid=1001, st_mode=stat.S_IRUSR | stat.S_IWUSR)\n        \n        with tempfile.TemporaryDirectory() as tmp_dir:\n            file_path = os.path.join(tmp_dir, 'creds.ini')\n            \n            # Create initial file\n            with open(file_path, 'w') as f:\n                f.write(\"original_content\")\n            \n            # Mock exists to return True\n            with patch('os.path.exists', return_value=True):\n                save_service_credentials(file_path, 'test', 'test')\n                \n            # Verify file content unchanged\n            with open(file_path, 'r') as f:\n                content = f.read()\n            self.assertEqual(content, \"original_content\")\n    \n    def test_existing_file_invalid_permissions(self):\n        # Test existing file with world-accessible permissions\n        with tempfile.TemporaryDirectory() as tmp_dir:\n            file_path = os.path.join(tmp_dir, 'creds.ini')\n            \n            # Create file with bad permissions\n            with open(file_path, 'w') as f:\n                f.write(\"original\")\n            os.chmod(file_path, 0o644)  # world-readable\n            \n            save_service_credentials(file_path, 'user', 'pass')\n            \n            # Verify content unchanged\n            with open(file_path, 'r') as f:\n                content = f.read()\n            self.assertEqual(content, \"original\")\n    \n    @patch('os.makedirs')\n    def test_directory_creation_failure(self, mock_makedirs):\n        # Test failure during directory creation\n        mock_makedirs.side_effect = OSError(\"Permission denied\")\n        \n        with self.assertRaises(OSError):\n            save_service_credentials('/nonexistent/path/creds.ini', 'user', 'pass')\n    \n    @patch('builtins.open')\n    def test_file_write_failure(self, mock_open):\n        # Test failure during file writing\n        mock_open.side_effect = IOError(\"Disk full\")\n        \n        with tempfile.TemporaryDirectory() as tmp_dir:\n            file_path = os.path.join(tmp_dir, 'creds.ini')\n            \n            # Ensure file doesn't exist initially\n            with patch('os.path.exists', return_value=False):\n                save_service_credentials(file_path, 'user', 'pass')\n                \n            # Verify file was not created\n            self.assertFalse(os.path.exists(file_path))\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 7, "task_id": "0ca3f2ee"}
{"test": "import unittest\nimport os\nimport stat\nfrom unittest.mock import patch, MagicMock\n\nclass TestStorePrivateKey(unittest.TestCase):\n\n    @patch('os.path.exists')\n    @patch('builtins.print')\n    def test_directory_does_not_exist(self, mock_print, mock_exists):\n        \"\"\"Test that function handles non-existent directory correctly.\"\"\"\n        mock_exists.side_effect = lambda x: False if x == '/path/to' else True\n        store_private_key('/path/to/private_key.pem', 'key_content')\n        mock_print.assert_called_with(\"Error: Directory '/path/to' does not exist.\")\n\n    @patch('os.path.exists')\n    @patch('os.stat')\n    @patch('os.getuid')\n    @patch('builtins.print')\n    def test_file_owned_by_another_user(self, mock_print, mock_getuid, mock_stat, mock_exists):\n        \"\"\"Test existing file owned by another user.\"\"\"\n        mock_exists.side_effect = lambda x: True if x == '/path/to' or x == '/path/to/private_key.pem' else False\n        mock_stat.return_value = MagicMock(st_uid=999, st_mode=0o100600)\n        mock_getuid.return_value = 1000\n        store_private_key('/path/to/private_key.pem', 'key_content')\n        mock_print.assert_called_with(\"Error: Key file '/path/to/private_key.pem' is owned by another user.\")\n\n    @patch('os.path.exists')\n    @patch('os.stat')\n    @patch('os.getuid')\n    @patch('builtins.print')\n    def test_file_has_group_or_others_permissions(self, mock_print, mock_getuid, mock_stat, mock_exists):\n        \"\"\"Test existing file with group/others permissions.\"\"\"\n        mock_exists.side_effect = lambda x: True if x == '/path/to' or x == '/path/to/private_key.pem' else False\n        mock_stat.return_value = MagicMock(st_uid=1000, st_mode=0o100644)\n        mock_getuid.return_value = 1000\n        store_private_key('/path/to/private_key.pem', 'key_content')\n        mock_print.assert_called_with(\"Error: Key file '/path/to/private_key.pem' has group or others permissions.\")\n\n    @patch('os.path.exists')\n    @patch('builtins.open', new_callable=unittest.mock.mock_open)\n    @patch('os.chmod')\n    @patch('os.stat')\n    @patch('os.getuid')\n    @patch('builtins.print')\n    def test_successful_write_new_file(self, mock_print, mock_getuid, mock_stat, mock_chmod, mock_open, mock_exists):\n        \"\"\"Test successful write to new file with correct permissions.\"\"\"\n        mock_exists.side_effect = lambda x: True if x == '/path/to' else False\n        mock_getuid.return_value = 1000\n        store_private_key('/path/to/private_key.pem', 'key_content')\n        mock_open.assert_called_once_with('/path/to/private_key.pem', 'w')\n        mock_chmod.assert_called_once_with('/path/to/private_key.pem', stat.S_IRUSR | stat.S_IWUSR)\n        mock_print.assert_called_with(\"Private key securely saved to '/path/to/private_key.pem'\")\n\n    @patch('os.path.exists')\n    @patch('builtins.open', side_effect=PermissionError(\"Write denied\"))\n    @patch('builtins.print')\n    def test_write_permission_error(self, mock_print, mock_open, mock_exists):\n        \"\"\"Test exception during file writing.\"\"\"\n        mock_exists.side_effect = lambda x: True if x == '/path/to' else False\n        store_private_key('/path/to/private_key.pem', 'key_content')\n        mock_print.assert_called_with(\"Error securing and saving the private key: Write denied\")\n\n    @patch('os.path.exists')\n    @patch('builtins.open', new_callable=unittest.mock.mock_open)\n    @patch('os.chmod', side_effect=OSError(\"Permission change denied\"))\n    @patch('builtins.print')\n    def test_chmod_permission_error(self, mock_print, mock_chmod, mock_open, mock_exists):\n        \"\"\"Test exception during permission change.\"\"\"\n        mock_exists.side_effect = lambda x: True if x == '/path/to' else False\n        store_private_key('/path/to/private_key.pem', 'key_content')\n        mock_print.assert_called_with(\"Error securing and saving the private key: Permission change denied\")\n\n    @patch('os.path.exists')\n    @patch('builtins.open', new_callable=unittest.mock.mock_open)\n    @patch('os.chmod')\n    @patch('os.stat')\n    @patch('os.getuid')\n    @patch('builtins.print')\n    def test_overwrite_existing_safe_file(self, mock_print, mock_getuid, mock_stat, mock_chmod, mock_open, mock_exists):\n        \"\"\"Test overwriting an existing safe file.\"\"\"\n        mock_exists.side_effect = lambda x: True\n        mock_stat.return_value = MagicMock(st_uid=1000, st_mode=0o100600)\n        mock_getuid.return_value = 1000\n        store_private_key('/path/to/private_key.pem', 'new_content')\n        mock_open.assert_called_once_with('/path/to/private_key.pem', 'w')\n        mock_open().write.assert_called_once_with('new_content')\n        mock_chmod.assert_called_once_with('/path/to/private_key.pem', stat.S_IRUSR | stat.S_IWUSR)\n        mock_print.assert_called_with(\"Private key securely saved to '/path/to/private_key.pem'\")\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 7, "task_id": "86321020"}
{"test": "import unittest\nfrom unittest.mock import patch, mock_open, MagicMock\n\nclass TestPersistPrivateKey(unittest.TestCase):\n\n    def test_directory_does_not_exist(self):\n        \"\"\"Test when the directory for the private key does not exist.\"\"\"\n        file_path = '/path/to/private.key'\n        key_data = 'secret_key_data'\n        with patch('os.path.exists') as mock_exists, \\\n             patch('builtins.print') as mock_print, \\\n             patch('os.stat') as mock_stat, \\\n             patch('os.getuid') as mock_getuid, \\\n             patch('os.chmod') as mock_chmod, \\\n             patch('builtins.open') as mock_open:\n            \n            mock_exists.return_value = False\n            \n            persist_private_key(file_path, key_data)\n            \n            mock_print.assert_called_once_with(\"Error: Directory '/path/to' does not exist.\")\n            mock_stat.assert_not_called()\n            mock_getuid.assert_not_called()\n            mock_open.assert_not_called()\n            mock_chmod.assert_not_called()\n\n    def test_file_owned_by_another_user(self):\n        \"\"\"Test when the existing private key file is owned by another user.\"\"\"\n        file_path = '/path/to/private.key'\n        key_data = 'secret_key_data'\n        with patch('os.path.exists') as mock_exists, \\\n             patch('builtins.print') as mock_print, \\\n             patch('os.stat') as mock_stat, \\\n             patch('os.getuid') as mock_getuid, \\\n             patch('os.chmod') as mock_chmod, \\\n             patch('builtins.open') as mock_open:\n            \n            mock_exists.side_effect = [True, True]\n            mock_getuid.return_value = 1000\n            mock_stat.return_value = MagicMock(st_uid=1001, st_mode=0o600)\n            \n            persist_private_key(file_path, key_data)\n            \n            mock_print.assert_called_once_with(f\"Error: Key file '{file_path}' is owned by another user.\")\n            mock_open.assert_not_called()\n            mock_chmod.assert_not_called()\n\n    def test_file_has_group_or_others_permissions(self):\n        \"\"\"Test when the existing private key file has group or others permissions.\"\"\"\n        file_path = '/path/to/private.key'\n        key_data = 'secret_key_data'\n        with patch('os.path.exists') as mock_exists, \\\n             patch('builtins.print') as mock_print, \\\n             patch('os.stat') as mock_stat, \\\n             patch('os.getuid') as mock_getuid, \\\n             patch('os.chmod') as mock_chmod, \\\n             patch('builtins.open') as mock_open:\n            \n            mock_exists.side_effect = [True, True]\n            mock_getuid.return_value = 1000\n            mock_stat.return_value = MagicMock(st_uid=1000, st_mode=0o607)\n            \n            persist_private_key(file_path, key_data)\n            \n            mock_print.assert_called_once_with(f\"Error: Key file '{file_path}' has group or others permissions.\")\n            mock_open.assert_not_called()\n            mock_chmod.assert_not_called()\n\n    def test_successful_write_new_file(self):\n        \"\"\"Test successfully writing a new private key file.\"\"\"\n        file_path = '/path/to/private.key'\n        key_data = 'secret_key_data'\n        with patch('os.path.exists') as mock_exists, \\\n             patch('builtins.print') as mock_print, \\\n             patch('os.stat') as mock_stat, \\\n             patch('os.getuid') as mock_getuid, \\\n             patch('os.chmod') as mock_chmod, \\\n             patch('builtins.open', mock_open()) as mock_file:\n            \n            mock_exists.side_effect = [True, False]\n            \n            persist_private_key(file_path, key_data)\n            \n            mock_file.assert_called_once_with(file_path, 'w')\n            mock_file().write.assert_called_once_with(key_data)\n            mock_chmod.assert_called_once_with(file_path, 0o600)\n            mock_print.assert_called_once_with(f\"Private key securely saved to '{file_path}'\")\n\n    def test_successful_write_existing_safe_file(self):\n        \"\"\"Test overwriting an existing, safely configured private key file.\"\"\"\n        file_path = '/path/to/private.key'\n        key_data = 'secret_key_data'\n        with patch('os.path.exists') as mock_exists, \\\n             patch('builtins.print') as mock_print, \\\n             patch('os.stat') as mock_stat, \\\n             patch('os.getuid') as mock_getuid, \\\n             patch('os.chmod') as mock_chmod, \\\n             patch('builtins.open', mock_open()) as mock_file:\n            \n            mock_exists.side_effect = [True, True]\n            mock_getuid.return_value = 1000\n            mock_stat.return_value = MagicMock(st_uid=1000, st_mode=0o600)\n            \n            persist_private_key(file_path, key_data)\n            \n            mock_file.assert_called_once_with(file_path, 'w')\n            mock_file().write.assert_called_once_with(key_data)\n            mock_chmod.assert_called_once_with(file_path, 0o600)\n            mock_print.assert_called_once_with(f\"Private key securely saved to '{file_path}'\")\n\n    def test_exception_during_write(self):\n        \"\"\"Test handling of exceptions during file writing.\"\"\"\n        file_path = '/path/to/private.key'\n        key_data = 'secret_key_data'\n        with patch('os.path.exists') as mock_exists, \\\n             patch('builtins.print') as mock_print, \\\n             patch('os.stat') as mock_stat, \\\n             patch('os.getuid') as mock_getuid, \\\n             patch('os.chmod') as mock_chmod, \\\n             patch('builtins.open') as mock_open:\n            \n            mock_exists.side_effect = [True, False]\n            mock_open.side_effect = IOError(\"Disk error\")\n            \n            persist_private_key(file_path, key_data)\n            \n            mock_print.assert_called_once()\n            args, _ = mock_print.call_args\n            self.assertIn(\"Error securing and saving the private key: Disk error\", args[0])\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 6, "task_id": "ba0a632d"}
{"test": "import io\nimport os\nimport stat\nimport tempfile\nimport unittest\nfrom unittest.mock import patch, Mock\n\nclass TestRecordPrivateKey(unittest.TestCase):\n\n    def test_directory_not_exists(self):\n        # Test when the directory does not exist\n        with tempfile.TemporaryDirectory() as tmpdir:\n            key_location = os.path.join(tmpdir, 'nonexistent', 'key.pem')\n            secret_key = 'my_secret_key'\n\n            with patch('sys.stdout', new_callable=io.StringIO) as mock_stdout:\n                record_private_key(key_location, secret_key)\n                output = mock_stdout.getvalue()\n                expected_error = 'Error: Directory \\'{}\\' does not exist.'.format(os.path.dirname(key_location))\n                self.assertIn(expected_error, output)\n            self.assertFalse(os.path.exists(key_location))\n\n    def test_new_file(self):\n        # Test creating a new file\n        with tempfile.TemporaryDirectory() as tmpdir:\n            key_location = os.path.join(tmpdir, 'key.pem')\n            secret_key = 'my_secret_key'\n\n            with patch('sys.stdout', new_callable=io.StringIO) as mock_stdout:\n                record_private_key(key_location, secret_key)\n                output = mock_stdout.getvalue()\n                self.assertIn('Private key securely saved to \\'{}\\''.format(key_location), output)\n\n            self.assertTrue(os.path.exists(key_location))\n            with open(key_location, 'r') as f:\n                content = f.read()\n            self.assertEqual(content, secret_key)\n            mode = os.stat(key_location).st_mode\n            self.assertEqual(stat.S_IMODE(mode), 0o600)\n\n    def test_existing_file_wrong_owner(self):\n        # Test existing file owned by another user\n        with tempfile.TemporaryDirectory() as tmpdir:\n            key_location = os.path.join(tmpdir, 'key.pem')\n            secret_key = 'new_secret_key'\n            with open(key_location, 'w') as f:\n                f.write('old content')\n\n            with patch('os.stat') as mock_stat, patch('os.getuid') as mock_getuid:\n                mock_getuid.return_value = 1000\n                fake_stat = Mock()\n                fake_stat.st_uid = 1001\n                fake_stat.st_mode = 0o100600\n                mock_stat.return_value = fake_stat\n\n                with patch('sys.stdout', new_callable=io.StringIO) as mock_stdout:\n                    record_private_key(key_location, secret_key)\n                    output = mock_stdout.getvalue()\n                    self.assertIn('Error: Key file \\'{}\\' is owned by another user.'.format(key_location), output)\n\n            with open(key_location, 'r') as f:\n                content = f.read()\n            self.assertEqual(content, 'old content')\n\n    def test_existing_file_wrong_permissions(self):\n        # Test existing file with group/others permissions\n        with tempfile.TemporaryDirectory() as tmpdir:\n            key_location = os.path.join(tmpdir, 'key.pem')\n            secret_key = 'new_secret_key'\n            with open(key_location, 'w') as f:\n                f.write('old content')\n            os.chmod(key_location, 0o644)\n\n            with patch('sys.stdout', new_callable=io.StringIO) as mock_stdout:\n                record_private_key(key_location, secret_key)\n                output = mock_stdout.getvalue()\n                self.assertIn('Error: Key file \\'{}\\' has group or others permissions.'.format(key_location), output)\n\n            with open(key_location, 'r') as f:\n                content = f.read()\n            self.assertEqual(content, 'old content')\n            mode = os.stat(key_location).st_mode\n            self.assertEqual(stat.S_IMODE(mode), 0o644)\n\n    def test_existing_file_correct(self):\n        # Test overwriting existing file with correct permissions\n        with tempfile.TemporaryDirectory() as tmpdir:\n            key_location = os.path.join(tmpdir, 'key.pem')\n            secret_key = 'new_secret_key'\n            with open(key_location, 'w') as f:\n                f.write('old content')\n            os.chmod(key_location, 0o600)\n\n            with patch('sys.stdout', new_callable=io.StringIO) as mock_stdout:\n                record_private_key(key_location, secret_key)\n                output = mock_stdout.getvalue()\n                self.assertIn('Private key securely saved to \\'{}\\''.format(key_location), output)\n\n            with open(key_location, 'r') as f:\n                content = f.read()\n            self.assertEqual(content, secret_key)\n            mode = os.stat(key_location).st_mode\n            self.assertEqual(stat.S_IMODE(mode), 0o600)\n\n    def test_exception_during_write(self):\n        # Test exception during file writing\n        with tempfile.TemporaryDirectory() as tmpdir:\n            key_location = os.path.join(tmpdir, 'key.pem')\n            secret_key = 'my_secret_key'\n\n            with patch('builtins.open', side_effect=IOError('Permission denied')):\n                with patch('sys.stdout', new_callable=io.StringIO) as mock_stdout:\n                    record_private_key(key_location, secret_key)\n                    output = mock_stdout.getvalue()\n                    self.assertIn('Error securing and saving the private key: Permission denied', output)\n\n            self.assertFalse(os.path.exists(key_location))\n\n    def test_exception_during_chmod(self):\n        # Test exception during chmod after write\n        with tempfile.TemporaryDirectory() as tmpdir:\n            key_location = os.path.join(tmpdir, 'key.pem')\n            secret_key = 'my_secret_key'\n\n            with patch('os.chmod', side_effect=OSError('Permission denied')):\n                with patch('sys.stdout', new_callable=io.StringIO) as mock_stdout:\n                    record_private_key(key_location, secret_key)\n                    output = mock_stdout.getvalue()\n                    self.assertIn('Error securing and saving the private key: Permission denied', output)\n\n            self.assertTrue(os.path.exists(key_location))\n            with open(key_location, 'r') as f:\n                content = f.read()\n            self.assertEqual(content, secret_key)\n", "num_test_cases": 7, "task_id": "0d897ec0"}
{"test": "import unittest\nimport tempfile\nimport os\nimport stat\nfrom unittest.mock import patch, MagicMock\n\nclass TestStoreSecretKey(unittest.TestCase):\n\n    def test_happy_path_new_file(self):\n        # Test creating a new file with correct permissions\n        with tempfile.TemporaryDirectory() as tmpdir:\n            key_path = os.path.join(tmpdir, 'secret_key.txt')\n            secret_key = 'my_secret_key'\n            \n            with patch('builtins.print') as mock_print:\n                store_secret_key(key_path, secret_key)\n                mock_print.assert_called_once_with(f'Private key securely saved to \\'{key_path}\\'')\n            \n            # Verify file created with correct content and permissions\n            self.assertTrue(os.path.exists(key_path))\n            with open(key_path, 'r') as f:\n                self.assertEqual(f.read(), secret_key)\n            file_mode = os.stat(key_path).st_mode\n            self.assertEqual(file_mode & 0o777, stat.S_IRUSR | stat.S_IWUSR)\n\n    def test_directory_does_not_exist(self):\n        # Test non-existent parent directory\n        with tempfile.TemporaryDirectory() as tmpdir:\n            non_existent_dir = os.path.join(tmpdir, 'nonexistent')\n            key_path = os.path.join(non_existent_dir, 'key.txt')\n            secret_key = 'test_key'\n            \n            with patch('builtins.print') as mock_print:\n                store_secret_key(key_path, secret_key)\n                mock_print.assert_called_once_with(f'Error: Directory \\'{non_existent_dir}\\' does not exist.')\n            \n            self.assertFalse(os.path.exists(key_path))\n\n    def test_existing_file_wrong_owner(self):\n        # Test existing file owned by different user\n        with tempfile.NamedTemporaryFile(delete=False) as tmpfile:\n            file_path = tmpfile.name\n            \n        try:\n            with patch('os.stat') as mock_stat, patch('os.getuid') as mock_getuid, \\\n                 patch('builtins.print') as mock_print:\n                \n                # Setup mock for wrong owner\n                fake_stat = MagicMock()\n                fake_stat.st_uid = 9999  # Different UID\n                mock_stat.return_value = fake_stat\n                mock_getuid.return_value = 1000  # Current UID\n                \n                store_secret_key(file_path, 'new_key')\n                mock_print.assert_called_once_with(f'Error: Key file \\'{file_path}\\' is owned by another user.')\n                \n        finally:\n            os.unlink(file_path)\n\n    def test_existing_file_bad_permissions(self):\n        # Test existing file with group/others permissions\n        with tempfile.NamedTemporaryFile(delete=False) as tmpfile:\n            file_path = tmpfile.name\n            os.chmod(file_path, 0o644)  # Bad permissions\n            \n        try:\n            with patch('builtins.print') as mock_print:\n                store_secret_key(file_path, 'new_key')\n                mock_print.assert_called_once_with(f'Error: Key file \\'{file_path}\\' has group or others permissions.')\n                \n            # Verify original file not modified\n            with open(file_path, 'r') as f:\n                self.assertEqual(f.read(), '')\n            self.assertEqual(os.stat(file_path).st_mode & 0o777, 0o644)\n                \n        finally:\n            os.unlink(file_path)\n\n    def test_existing_file_correct_permissions(self):\n        # Test overwriting existing file with correct permissions\n        with tempfile.NamedTemporaryFile(delete=False) as tmpfile:\n            file_path = tmpfile.name\n            tmpfile.write(b'original')\n            os.chmod(file_path, stat.S_IRUSR | stat.S_IWUSR)  # 0o600\n            \n        try:\n            new_key = 'updated_secret'\n            with patch('builtins.print') as mock_print:\n                store_secret_key(file_path, new_key)\n                mock_print.assert_called_once_with(f'Private key securely saved to \\'{file_path}\\'')\n            \n            # Verify content updated and permissions remain correct\n            with open(file_path, 'r') as f:\n                self.assertEqual(f.read(), new_key)\n            file_mode = os.stat(file_path).st_mode\n            self.assertEqual(file_mode & 0o777, stat.S_IRUSR | stat.S_IWUSR)\n                \n        finally:\n            os.unlink(file_path)\n\n    def test_exception_during_write(self):\n        # Test IOError during file write\n        with tempfile.TemporaryDirectory() as tmpdir:\n            key_path = os.path.join(tmpdir, 'key.txt')\n            \n            with patch('builtins.open') as mock_open, patch('builtins.print') as mock_print:\n                mock_open.side_effect = IOError('Disk failure')\n                \n                store_secret_key(key_path, 'test')\n                \n                # Verify error message captured\n                mock_print.assert_called_once()\n                self.assertIn('Error securing and saving the private key', mock_print.call_args[0][0])\n                self.assertIn('Disk failure', mock_print.call_args[0][0])\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 6, "task_id": "561fb8d1"}
{"test": "import unittest\nimport os\nimport stat\nimport tempfile\nfrom unittest.mock import patch, MagicMock\nimport io\n\nclass TestCases(unittest.TestCase):\n\n    def test_case_1(self):\n        # Happy path: new file\n        with tempfile.TemporaryDirectory() as temp_dir:\n            key_path = os.path.join(temp_dir, 'keyfile')\n            key_content = 'my_secret_key'\n            with patch('sys.stdout', new_callable=io.StringIO) as mock_stdout:\n                store_protected_key(key_path, key_content)\n            output = mock_stdout.getvalue().strip()\n            self.assertIn(f\"Private key securely saved to '{key_path}'\", output)\n            self.assertTrue(os.path.exists(key_path))\n            with open(key_path, 'r') as f:\n                content = f.read()\n            self.assertEqual(content, key_content)\n            mode = os.stat(key_path).st_mode\n            self.assertEqual(stat.S_IMODE(mode), 0o600)\n\n    def test_case_2(self):\n        # Happy path: existing file with correct ownership and permissions\n        with tempfile.TemporaryDirectory() as temp_dir:\n            key_path = os.path.join(temp_dir, 'keyfile')\n            with open(key_path, 'w') as f:\n                f.write('old_key')\n            os.chmod(key_path, 0o600)\n            key_content = 'new_secret_key'\n            with patch('sys.stdout', new_callable=io.StringIO) as mock_stdout:\n                store_protected_key(key_path, key_content)\n            output = mock_stdout.getvalue().strip()\n            self.assertIn(f\"Private key securely saved to '{key_path}'\", output)\n            with open(key_path, 'r') as f:\n                content = f.read()\n            self.assertEqual(content, key_content)\n            mode = os.stat(key_path).st_mode\n            self.assertEqual(stat.S_IMODE(mode), 0o600)\n\n    def test_case_3(self):\n        # Directory does not exist\n        with tempfile.TemporaryDirectory() as temp_dir:\n            non_existent_subdir = os.path.join(temp_dir, 'non_existent')\n            key_path = os.path.join(non_existent_subdir, 'keyfile')\n            key_content = 'key'\n            with patch('sys.stdout', new_callable=io.StringIO) as mock_stdout:\n                store_protected_key(key_path, key_content)\n            output = mock_stdout.getvalue().strip()\n            self.assertIn(f\"Error: Directory '{non_existent_subdir}' does not exist.\", output)\n            self.assertFalse(os.path.exists(key_path))\n\n    def test_case_4(self):\n        # File owned by another user\n        with tempfile.TemporaryDirectory() as temp_dir:\n            key_path = os.path.join(temp_dir, 'keyfile')\n            with open(key_path, 'w') as f:\n                f.write('old_key')\n            current_uid = os.getuid()\n            fake_uid = current_uid + 1\n            fake_stat = os.stat_result((0,0,0,0,0,0,0,0,0,0))\n            fake_stat.st_uid = fake_uid\n            fake_stat.st_mode = 0o100600  # Set mode to 0o600\n            with patch('os.stat', return_value=fake_stat):\n                with patch('sys.stdout', new_callable=io.StringIO) as mock_stdout:\n                    store_protected_key(key_path, 'new_key')\n            output = mock_stdout.getvalue().strip()\n            self.assertIn(f\"Error: Key file '{key_path}' is owned by another user.\", output)\n            with open(key_path, 'r') as f:\n                content = f.read()\n            self.assertEqual(content, 'old_key')\n\n    def test_case_5(self):\n        # File has group/others permissions\n        with tempfile.TemporaryDirectory() as temp_dir:\n            key_path = os.path.join(temp_dir, 'keyfile')\n            with open(key_path, 'w') as f:\n                f.write('old_key')\n            os.chmod(key_path, 0o644)  # Group/others permissions\n            with patch('sys.stdout', new_callable=io.StringIO) as mock_stdout:\n                store_protected_key(key_path, 'new_key')\n            output = mock_stdout.getvalue().strip()\n            self.assertIn(f\"Error: Key file '{key_path}' has group or others permissions.\", output)\n            with open(key_path, 'r') as f:\n                content = f.read()\n            self.assertEqual(content, 'old_key')\n\n    def test_case_6(self):\n        # Writing error (new file)\n        with tempfile.TemporaryDirectory() as temp_dir:\n            key_path = os.path.join(temp_dir, 'keyfile')\n            with patch('builtins.open', side_effect=IOError('Mocked IO error')):\n                with patch('sys.stdout', new_callable=io.StringIO) as mock_stdout:\n                    store_protected_key(key_path, 'key')\n            output = mock_stdout.getvalue().strip()\n            self.assertIn(\"Error securing and saving the private key: Mocked IO error\", output)\n            self.assertFalse(os.path.exists(key_path))\n\n    def test_case_7(self):\n        # Writing error on existing file that passed checks\n        with tempfile.TemporaryDirectory() as temp_dir:\n            key_path = os.path.join(temp_dir, 'keyfile')\n            with open(key_path, 'w') as f:\n                f.write('old_key')\n            os.chmod(key_path, 0o600)\n            mock_file = MagicMock()\n            mock_file.__enter__.return_value.write.side_effect = IOError('Write failed')\n            with patch('builtins.open', return_value=mock_file):\n                with patch('sys.stdout', new_callable=io.StringIO) as mock_stdout:\n                    store_protected_key(key_path, 'new_key')\n            output = mock_stdout.getvalue().strip()\n            self.assertIn(\"Error securing and saving the private key: Write failed\", output)\n            with open(key_path, 'r') as f:\n                content = f.read()\n            self.assertEqual(content, 'old_key')\n            mode = os.stat(key_path).st_mode\n            self.assertEqual(stat.S_IMODE(mode), 0o600)", "num_test_cases": 7, "task_id": "3d707118"}
{"test": "import os\nimport stat\nimport tempfile\nimport unittest\nfrom unittest.mock import patch, MagicMock\n\nclass TestSaveSecureKey(unittest.TestCase):\n\n    def test_directory_does_not_exist(self):\n        # Test when parent directory doesn't exist\n        with tempfile.TemporaryDirectory() as temp_dir:\n            non_existent_path = os.path.join(temp_dir, 'nonexistent', 'key.key')\n            with patch('builtins.print') as mock_print:\n                save_secure_key(non_existent_path, 'dummy_key')\n                mock_print.assert_called_with(f\"Error: Directory '{os.path.dirname(non_existent_path)}' does not exist.\")\n\n    def test_happy_path_new_file(self):\n        # Test creating new file with correct permissions\n        with tempfile.TemporaryDirectory() as temp_dir:\n            key_file = os.path.join(temp_dir, 'key.key')\n            key_content = \"secure_key_123\"\n            with patch('builtins.print') as mock_print:\n                save_secure_key(key_file, key_content)\n                mock_print.assert_called_with(f\"Private key securely saved to '{key_file}'\")\n                \n                # Verify file content and permissions\n                self.assertTrue(os.path.exists(key_file))\n                with open(key_file, 'r') as f:\n                    self.assertEqual(f.read(), key_content)\n                mode = os.stat(key_file).st_mode\n                self.assertEqual(stat.S_IMODE(mode), 0o600)\n\n    def test_existing_file_correct_permissions(self):\n        # Test overwriting existing file with correct permissions\n        with tempfile.TemporaryDirectory() as temp_dir:\n            key_file = os.path.join(temp_dir, 'key.key')\n            with open(key_file, 'w') as f:\n                f.write('old_key')\n            os.chmod(key_file, 0o600)\n            \n            with patch('builtins.print') as mock_print:\n                save_secure_key(key_file, 'new_key')\n                mock_print.assert_called_with(f\"Private key securely saved to '{key_file}'\")\n                \n                # Verify updated content and permissions\n                with open(key_file, 'r') as f:\n                    self.assertEqual(f.read(), 'new_key')\n                mode = os.stat(key_file).st_mode\n                self.assertEqual(stat.S_IMODE(mode), 0o600)\n\n    def test_existing_file_group_permissions(self):\n        # Test existing file with group permissions (should fail)\n        with tempfile.TemporaryDirectory() as temp_dir:\n            key_file = os.path.join(temp_dir, 'key.key')\n            with open(key_file, 'w') as f:\n                f.write('old_key')\n            os.chmod(key_file, 0o640)  # Group read permission\n            \n            with patch('builtins.print') as mock_print:\n                save_secure_key(key_file, 'new_key')\n                mock_print.assert_called_with(f\"Error: Key file '{key_file}' has group or others permissions.\")\n                \n                # Verify content unchanged\n                with open(key_file, 'r') as f:\n                    self.assertEqual(f.read(), 'old_key')\n\n    def test_existing_file_other_permissions(self):\n        # Test existing file with other permissions (should fail)\n        with tempfile.TemporaryDirectory() as temp_dir:\n            key_file = os.path.join(temp_dir, 'key.key')\n            with open(key_file, 'w') as f:\n                f.write('old_key')\n            os.chmod(key_file, 0o606)  # Others read/write\n            \n            with patch('builtins.print') as mock_print:\n                save_secure_key(key_file, 'new_key')\n                mock_print.assert_called_with(f\"Error: Key file '{key_file}' has group or others permissions.\")\n                \n                # Verify content unchanged\n                with open(key_file, 'r') as f:\n                    self.assertEqual(f.read(), 'old_key')\n\n    def test_existing_file_wrong_owner(self):\n        # Test existing file owned by different user\n        with patch('os.stat') as mock_stat, patch('os.getuid') as mock_uid, patch('os.path.exists') as mock_exists:\n            mock_exists.return_value = True\n            mock_uid.return_value = 1000\n            mock_stat.return_value = MagicMock(st_uid=9999, st_mode=0o600)\n            \n            with patch('builtins.print') as mock_print:\n                save_secure_key('/fake/path.key', 'dummy_key')\n                mock_print.assert_called_with(\"Error: Key file '/fake/path.key' is owned by another user.\")\n\n    def test_write_exception(self):\n        # Test exception during file write operation\n        with tempfile.TemporaryDirectory() as temp_dir:\n            key_file = os.path.join(temp_dir, 'key.key')\n            \n            with patch('builtins.open', side_effect=PermissionError(\"Write denied\")):\n                with patch('builtins.print') as mock_print:\n                    save_secure_key(key_file, 'dummy_key')\n                    mock_print.assert_called_with(\"Error securing and saving the private key: Write denied\")\n\n    def test_empty_key(self):\n        # Test saving empty key string\n        with tempfile.TemporaryDirectory() as temp_dir:\n            key_file = os.path.join(temp_dir, 'key.key')\n            \n            with patch('builtins.print') as mock_print:\n                save_secure_key(key_file, '')\n                mock_print.assert_called_with(f\"Private key securely saved to '{key_file}'\")\n                \n                # Verify file is empty\n                with open(key_file, 'r') as f:\n                    self.assertEqual(f.read(), '')\n\n    def test_long_key(self):\n        # Test saving very long key\n        with tempfile.TemporaryDirectory() as temp_dir:\n            key_file = os.path.join(temp_dir, 'key.key')\n            long_key = 'A' * 10000\n            \n            with patch('builtins.print') as mock_print:\n                save_secure_key(key_file, long_key)\n                mock_print.assert_called_with(f\"Private key securely saved to '{key_file}'\")\n                \n                # Verify content\n                with open(key_file, 'r') as f:\n                    self.assertEqual(f.read(), long_key)\n\n    def test_non_ascii_key(self):\n        # Test key with non-ASCII characters\n        with tempfile.TemporaryDirectory() as temp_dir:\n            key_file = os.path.join(temp_dir, 'key.key')\n            non_ascii_key = \"café_北京_東京\"\n            \n            with patch('builtins.print') as mock_print:\n                save_secure_key(key_file, non_ascii_key)\n                mock_print.assert_called_with(f\"Private key securely saved to '{key_file}'\")\n                \n                # Verify content\n                with open(key_file, 'r', encoding='utf-8') as f:\n                    self.assertEqual(f.read(), non_ascii_key)\n\n    def test_key_file_path_is_directory(self):\n        # Test when key_file_path is a directory\n        with tempfile.TemporaryDirectory() as temp_dir:\n            with patch('builtins.print') as mock_print:\n                save_secure_key(temp_dir, 'dummy_key')\n                self.assertTrue(mock_print.call_args[0][0].startswith(\"Error securing and saving the private key:\"))\n\n    def test_non_string_key_file_path(self):\n        # Test non-string key_file_path\n        with patch('builtins.print') as mock_print:\n            save_secure_key(12345, 'dummy_key')\n            self.assertTrue(mock_print.call_args[0][0].startswith(\"Error securing and saving the private key:\"))\n\n    def test_non_string_secure_key(self):\n        # Test non-string secure_key\n        with tempfile.TemporaryDirectory() as temp_dir:\n            key_file = os.path.join(temp_dir, 'key.key')\n            with patch('builtins.print') as mock_print:\n                save_secure_key(key_file, 12345)\n                self.assertTrue(mock_print.call_args[0][0].startswith(\"Error securing and saving the private key:\"))\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 13, "task_id": "6382c212"}
{"test": "import unittest\nfrom unittest.mock import patch, mock_open, MagicMock\nimport stat\nfrom solution import store_secret_key\n\nclass TestStoreSecretKey(unittest.TestCase):\n\n    # Test 1: Successfully write to new file\n    @patch('solution.os.path.exists')\n    @patch('solution.os.stat')\n    @patch('solution.os.getuid')\n    @patch('solution.os.chmod')\n    @patch('builtins.print')\n    @patch('builtins.open', new_callable=mock_open)\n    def test_new_file_success(self, mock_open_file, mock_print, mock_chmod, mock_getuid, mock_stat, mock_exists):\n        # Setup\n        mock_exists.side_effect = [True, False]  # Directory exists, file doesn't\n        mock_getuid.return_value = 1000\n        path = '/path/to/key.pem'\n        key = 'my_secret_key'\n        \n        # Call\n        result = store_secret_key(path, key)\n        \n        # Assert\n        self.assertIsNone(result)\n        mock_open_file.assert_called_once_with(path, 'w')\n        handle = mock_open_file()\n        handle.write.assert_called_once_with(key)\n        mock_chmod.assert_called_once_with(path, stat.S_IRUSR | stat.S_IWUSR)\n        mock_print.assert_called_once_with(f\"Private key securely saved to '{path}'\")\n\n    # Test 2: Successfully overwrite existing safe file\n    @patch('solution.os.path.exists')\n    @patch('solution.os.stat')\n    @patch('solution.os.getuid')\n    @patch('solution.os.chmod')\n    @patch('builtins.print')\n    @patch('builtins.open', new_callable=mock_open)\n    def test_existing_file_safe(self, mock_open_file, mock_print, mock_chmod, mock_getuid, mock_stat, mock_exists):\n        # Setup\n        mock_exists.side_effect = [True, True]  # Directory and file exist\n        mock_getuid.return_value = 1000\n        mock_stat_result = MagicMock()\n        mock_stat_result.st_uid = 1000\n        mock_stat_result.st_mode = 0o600\n        mock_stat.return_value = mock_stat_result\n        path = '/path/to/key.pem'\n        key = 'my_secret_key'\n        \n        # Call\n        result = store_secret_key(path, key)\n        \n        # Assert\n        self.assertIsNone(result)\n        mock_open_file.assert_called_once_with(path, 'w')\n        handle = mock_open_file()\n        handle.write.assert_called_once_with(key)\n        mock_chmod.assert_called_once_with(path, stat.S_IRUSR | stat.S_IWUSR)\n        mock_print.assert_called_once_with(f\"Private key securely saved to '{path}'\")\n\n    # Test 3: Directory does not exist\n    @patch('solution.os.path.exists')\n    @patch('builtins.print')\n    def test_directory_not_exist(self, mock_print, mock_exists):\n        # Setup\n        mock_exists.return_value = False  # Directory does not exist\n        path = '/path/to/key.pem'\n        key = 'my_secret_key'\n        \n        # Call\n        result = store_secret_key(path, key)\n        \n        # Assert\n        self.assertIsNone(result)\n        mock_print.assert_called_once_with(f\"Error: Directory '/path/to' does not exist.\")\n\n    # Test 4: File owned by another user\n    @patch('solution.os.path.exists')\n    @patch('solution.os.stat')\n    @patch('solution.os.getuid')\n    @patch('builtins.print')\n    def test_owned_by_other_user(self, mock_print, mock_getuid, mock_stat, mock_exists):\n        # Setup\n        mock_exists.side_effect = [True, True]  # Directory exists, file exists\n        mock_getuid.return_value = 1000\n        mock_stat_result = MagicMock()\n        mock_stat_result.st_uid = 1001  # Different user\n        mock_stat.return_value = mock_stat_result\n        path = '/path/to/key.pem'\n        key = 'my_secret_key'\n        \n        # Call\n        result = store_secret_key(path, key)\n        \n        # Assert\n        self.assertIsNone(result)\n        mock_print.assert_called_once_with(f\"Error: Key file '{path}' is owned by another user.\")\n\n    # Test 5: File has group/others permissions\n    @patch('solution.os.path.exists')\n    @patch('solution.os.stat')\n    @patch('solution.os.getuid')\n    @patch('builtins.print')\n    def test_has_group_others_permissions(self, mock_print, mock_getuid, mock_stat, mock_exists):\n        # Setup\n        mock_exists.side_effect = [True, True]  # Directory exists, file exists\n        mock_getuid.return_value = 1000\n        mock_stat_result = MagicMock()\n        mock_stat_result.st_uid = 1000\n        mock_stat_result.st_mode = 0o644  # Group/others have permissions\n        mock_stat.return_value = mock_stat_result\n        path = '/path/to/key.pem'\n        key = 'my_secret_key'\n        \n        # Call\n        result = store_secret_key(path, key)\n        \n        # Assert\n        self.assertIsNone(result)\n        mock_print.assert_called_once_with(f\"Error: Key file '{path}' has group or others permissions.\")\n\n    # Test 6: IOError during file write\n    @patch('solution.os.path.exists')\n    @patch('builtins.open')\n    @patch('builtins.print')\n    def test_error_during_write(self, mock_print, mock_open, mock_exists):\n        # Setup\n        mock_exists.side_effect = [True, False]  # Directory exists, file doesn't\n        mock_open.side_effect = IOError(\"Write error\")\n        path = '/path/to/key.pem'\n        key = 'my_secret_key'\n        \n        # Call\n        result = store_secret_key(path, key)\n        \n        # Assert\n        self.assertIsNone(result)\n        mock_open.assert_called_once_with(path, 'w')\n        self.assertIn(\"Error securing and saving the private key\", mock_print.call_args[0][0])\n\n    # Test 7: PermissionError during chmod\n    @patch('solution.os.path.exists')\n    @patch('solution.os.chmod')\n    @patch('builtins.open', new_callable=mock_open)\n    @patch('builtins.print')\n    def test_error_during_chmod(self, mock_print, mock_open_file, mock_chmod, mock_exists):\n        # Setup\n        mock_exists.side_effect = [True, False]  # Directory exists, file doesn't\n        mock_chmod.side_effect = PermissionError(\"Permission denied\")\n        path = '/path/to/key.pem'\n        key = 'my_secret_key'\n        \n        # Call\n        result = store_secret_key(path, key)\n        \n        # Assert\n        self.assertIsNone(result)\n        mock_open_file.assert_called_once_with(path, 'w')\n        mock_chmod.assert_called_once_with(path, stat.S_IRUSR | stat.S_IWUSR)\n        self.assertIn(\"Error securing and saving the private key\", mock_print.call_args[0][0])\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 7, "task_id": "79c3cce1"}
{"test": "import unittest\nfrom unittest.mock import patch, MagicMock\nimport os\nimport stat\n\nclass TestStoreKeySecurely(unittest.TestCase):\n\n    def test_directory_does_not_exist(self):\n        # Test when the directory does not exist\n        file_path = '/nonexistent_dir/key.pem'\n        key = 'test_key'\n        with patch('os.path.dirname') as mock_dirname, \\\n             patch('os.path.exists') as mock_exists, \\\n             patch('builtins.print') as mock_print:\n            mock_dirname.return_value = '/nonexistent_dir'\n            mock_exists.return_value = False\n            store_key_securely(file_path, key)\n            mock_print.assert_called_with(f\"Error: Directory '/nonexistent_dir' does not exist.\")\n\n    def test_file_owned_by_another_user(self):\n        # Test when file exists but is owned by another user\n        file_path = '/valid_dir/owned_by_other.pem'\n        key = 'test_key'\n        with patch('os.path.dirname') as mock_dirname, \\\n             patch('os.path.exists') as mock_exists, \\\n             patch('os.stat') as mock_stat, \\\n             patch('os.getuid') as mock_getuid, \\\n             patch('builtins.print') as mock_print:\n            mock_dirname.return_value = '/valid_dir'\n            mock_exists.side_effect = [True, True]\n            mock_stat.return_value = MagicMock(st_uid=1001)\n            mock_getuid.return_value = 1000\n            store_key_securely(file_path, key)\n            mock_print.assert_called_with(f\"Error: Key file '{file_path}' is owned by another user.\")\n\n    def test_file_has_group_or_others_permissions(self):\n        # Test when file exists but has group/others permissions\n        file_path = '/valid_dir/insecure_perms.pem'\n        key = 'test_key'\n        with patch('os.path.dirname') as mock_dirname, \\\n             patch('os.path.exists') as mock_exists, \\\n             patch('os.stat') as mock_stat, \\\n             patch('os.getuid') as mock_getuid, \\\n             patch('builtins.print') as mock_print:\n            mock_dirname.return_value = '/valid_dir'\n            mock_exists.side_effect = [True, True]\n            mock_stat.return_value = MagicMock(st_uid=1000, st_mode=0o664)\n            mock_getuid.return_value = 1000\n            store_key_securely(file_path, key)\n            mock_print.assert_called_with(f\"Error: Key file '{file_path}' has group or others permissions.\")\n\n    def test_existing_file_safe_permissions(self):\n        # Test overwriting existing file with safe permissions\n        file_path = '/valid_dir/existing_safe.pem'\n        key = 'test_key'\n        with patch('os.path.dirname') as mock_dirname, \\\n             patch('os.path.exists') as mock_exists, \\\n             patch('os.stat') as mock_stat, \\\n             patch('os.getuid') as mock_getuid, \\\n             patch('builtins.open') as mock_open, \\\n             patch('os.chmod') as mock_chmod, \\\n             patch('builtins.print') as mock_print:\n            mock_dirname.return_value = '/valid_dir'\n            mock_exists.side_effect = [True, True]\n            mock_stat.return_value = MagicMock(st_uid=1000, st_mode=0o600)\n            mock_getuid.return_value = 1000\n            mock_file = MagicMock()\n            mock_open.return_value.__enter__.return_value = mock_file\n            store_key_securely(file_path, key)\n            mock_open.assert_called_once_with(file_path, 'w')\n            mock_file.write.assert_called_once_with(key)\n            mock_chmod.assert_called_once_with(file_path, stat.S_IRUSR | stat.S_IWUSR)\n            mock_print.assert_called_with(f\"Private key securely saved to '{file_path}'\")\n\n    def test_new_file_success(self):\n        # Test writing a new file successfully\n        file_path = '/valid_dir/new_key.pem'\n        key = 'test_key'\n        with patch('os.path.dirname') as mock_dirname, \\\n             patch('os.path.exists') as mock_exists, \\\n             patch('builtins.open') as mock_open, \\\n             patch('os.chmod') as mock_chmod, \\\n             patch('builtins.print') as mock_print:\n            mock_dirname.return_value = '/valid_dir'\n            mock_exists.side_effect = [True, False]\n            mock_file = MagicMock()\n            mock_open.return_value.__enter__.return_value = mock_file\n            store_key_securely(file_path, key)\n            mock_open.assert_called_once_with(file_path, 'w')\n            mock_file.write.assert_called_once_with(key)\n            mock_chmod.assert_called_once_with(file_path, stat.S_IRUSR | stat.S_IWUSR)\n            mock_print.assert_called_with(f\"Private key securely saved to '{file_path}'\")\n\n    def test_write_exception(self):\n        # Test handling exception during file write\n        file_path = '/valid_dir/write_error.pem'\n        key = 'test_key'\n        with patch('os.path.dirname') as mock_dirname, \\\n             patch('os.path.exists') as mock_exists, \\\n             patch('builtins.open', side_effect=IOError('Write failed')), \\\n             patch('builtins.print') as mock_print:\n            mock_dirname.return_value = '/valid_dir'\n            mock_exists.side_effect = [True, False]\n            store_key_securely(file_path, key)\n            mock_print.assert_called_with(\"Error securing and saving the private key: Write failed\")\n\n    def test_chmod_exception(self):\n        # Test handling exception during permission change\n        file_path = '/valid_dir/chmod_error.pem'\n        key = 'test_key'\n        with patch('os.path.dirname') as mock_dirname, \\\n             patch('os.path.exists') as mock_exists, \\\n             patch('builtins.open') as mock_open, \\\n             patch('os.chmod', side_effect=OSError('Permission change failed')), \\\n             patch('builtins.print') as mock_print:\n            mock_dirname.return_value = '/valid_dir'\n            mock_exists.side_effect = [True, False]\n            store_key_securely(file_path, key)\n            mock_print.assert_called_with(\"Error securing and saving the private key: Permission change failed\")\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 7, "task_id": "6afd77de"}
{"test": "import os\nimport stat\nimport tempfile\nimport unittest\nfrom unittest.mock import patch, MagicMock\n\nclass TestSecurelyStoreKey(unittest.TestCase):\n    \n    def test_successful_write(self):\n        # Test writing to a new file in an existing directory\n        with tempfile.TemporaryDirectory() as tmpdir:\n            file_path = os.path.join(tmpdir, 'test_key.pem')\n            key = \"my_private_key\"\n            \n            with patch('builtins.print') as mock_print:\n                securely_store_key(file_path, key)\n                mock_print.assert_called_once_with(f\"Private key securely saved to '{file_path}'\")\n            \n            self.assertTrue(os.path.exists(file_path))\n            with open(file_path, 'r') as f:\n                self.assertEqual(f.read(), key)\n            \n            file_stat = os.stat(file_path)\n            self.assertEqual(file_stat.st_mode & 0o777, stat.S_IRUSR | stat.S_IWUSR)\n    \n    def test_directory_not_exist(self):\n        # Test when destination directory doesn't exist\n        non_existent_dir = os.path.join(tempfile.gettempdir(), 'non_existent_dir')\n        file_path = os.path.join(non_existent_dir, 'test_key.pem')\n        key = \"my_private_key\"\n        \n        with patch('builtins.print') as mock_print:\n            securely_store_key(file_path, key)\n            mock_print.assert_called_once_with(f\"Error: Directory '{non_existent_dir}' does not exist.\")\n        \n        self.assertFalse(os.path.exists(file_path))\n    \n    @patch('os.getuid')\n    @patch('os.stat')\n    @patch('os.path.exists', return_value=True)\n    def test_existing_file_wrong_ownership(self, mock_exists, mock_stat, mock_getuid):\n        # Test existing file owned by another user\n        mock_getuid.return_value = 1000\n        mock_stat_result = MagicMock()\n        mock_stat_result.st_uid = 1001\n        mock_stat_result.st_mode = 0o600\n        mock_stat.return_value = mock_stat_result\n        file_path = '/path/to/existing_key.pem'\n        key = \"new_key\"\n        \n        with patch('builtins.print') as mock_print:\n            securely_store_key(file_path, key)\n            mock_print.assert_called_once_with(f\"Error: Key file '{file_path}' is owned by another user.\")\n    \n    def test_existing_file_wrong_permissions(self):\n        # Test existing file with group/others permissions\n        with tempfile.TemporaryDirectory() as tmpdir:\n            file_path = os.path.join(tmpdir, 'test_key.pem')\n            with open(file_path, 'w') as f:\n                f.write(\"old_key\")\n            os.chmod(file_path, 0o644)  # Group/others have read\n            \n            key = \"new_key\"\n            with patch('builtins.print') as mock_print:\n                securely_store_key(file_path, key)\n                mock_print.assert_called_once_with(f\"Error: Key file '{file_path}' has group or others permissions.\")\n            \n            with open(file_path, 'r') as f:\n                self.assertEqual(f.read(), \"old_key\")\n    \n    @patch('os.stat')\n    @patch('os.getuid')\n    @patch('os.path.exists', return_value=True)\n    @patch('builtins.open', side_effect=IOError(\"Permission denied\"))\n    def test_write_exception(self, mock_open, mock_exists, mock_getuid, mock_stat):\n        # Test exception during file write\n        mock_getuid.return_value = 1000\n        mock_stat_result = MagicMock()\n        mock_stat_result.st_uid = 1000\n        mock_stat_result.st_mode = 0o600\n        mock_stat.return_value = mock_stat_result\n        file_path = '/path/to/file.pem'\n        key = \"my_private_key\"\n        \n        with patch('builtins.print') as mock_print:\n            securely_store_key(file_path, key)\n            mock_print.assert_called_once_with(\"Error securing and saving the private key: Permission denied\")\n    \n    def test_empty_key(self):\n        # Test writing an empty key\n        with tempfile.TemporaryDirectory() as tmpdir:\n            file_path = os.path.join(tmpdir, 'empty_key.pem')\n            key = \"\"\n            \n            with patch('builtins.print') as mock_print:\n                securely_store_key(file_path, key)\n                mock_print.assert_called_once_with(f\"Private key securely saved to '{file_path}'\")\n            \n            self.assertTrue(os.path.exists(file_path))\n            with open(file_path, 'r') as f:\n                self.assertEqual(f.read(), key)\n            \n            file_stat = os.stat(file_path)\n            self.assertEqual(file_stat.st_mode & 0o777, stat.S_IRUSR | stat.S_IWUSR)\n    \n    def test_long_key(self):\n        # Test writing a very long key\n        with tempfile.TemporaryDirectory() as tmpdir:\n            file_path = os.path.join(tmpdir, 'long_key.pem')\n            key = \"A\" * 10000\n            \n            with patch('builtins.print') as mock_print:\n                securely_store_key(file_path, key)\n                mock_print.assert_called_once_with(f\"Private key securely saved to '{file_path}'\")\n            \n            self.assertTrue(os.path.exists(file_path))\n            with open(file_path, 'r') as f:\n                self.assertEqual(f.read(), key)\n            \n            file_stat = os.stat(file_path)\n            self.assertEqual(file_stat.st_mode & 0o777, stat.S_IRUSR | stat.S_IWUSR)\n    \n    def test_overwrite_existing_acceptable_file(self):\n        # Test overwriting an existing acceptable file\n        with tempfile.TemporaryDirectory() as tmpdir:\n            file_path = os.path.join(tmpdir, 'existing_key.pem')\n            with open(file_path, 'w') as f:\n                f.write(\"old_key\")\n            os.chmod(file_path, 0o600)\n            \n            key = \"new_key\"\n            with patch('builtins.print') as mock_print:\n                securely_store_key(file_path, key)\n                mock_print.assert_called_once_with(f\"Private key securely saved to '{file_path}'\")\n            \n            with open(file_path, 'r') as f:\n                self.assertEqual(f.read(), key)\n            \n            file_stat = os.stat(file_path)\n            self.assertEqual(file_stat.st_mode & 0o777, stat.S_IRUSR | stat.S_IWUSR)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 8, "task_id": "87567439"}
{"test": "import unittest\nimport os\nimport stat\nimport tempfile\nfrom unittest.mock import patch, MagicMock\n\nclass TestStoreSettings(unittest.TestCase):\n\n    def test_happy_path_basic_data(self):\n        # Test writing basic string data to new file\n        with tempfile.TemporaryDirectory() as tmpdir:\n            file_path = os.path.join(tmpdir, 'settings.conf')\n            settings = {'key1': 'value1', 'key2': 'value2'}\n            with patch('builtins.print') as mock_print:\n                store_settings(file_path, settings)\n                expected_print = f\"Configuration securely written to '{file_path}'\"\n                mock_print.assert_called_once_with(expected_print)\n            \n            self.assertTrue(os.path.exists(file_path))\n            st = os.stat(file_path)\n            self.assertEqual(stat.S_IMODE(st.st_mode), 0o600)\n            \n            with open(file_path, 'r') as f:\n                content = f.read()\n            self.assertEqual(content, 'key1=value1\\nkey2=value2\\n')\n\n    def test_happy_path_empty_data(self):\n        # Test writing empty dictionary\n        with tempfile.TemporaryDirectory() as tmpdir:\n            file_path = os.path.join(tmpdir, 'settings.conf')\n            settings = {}\n            with patch('builtins.print') as mock_print:\n                store_settings(file_path, settings)\n                expected_print = f\"Configuration securely written to '{file_path}'\"\n                mock_print.assert_called_once_with(expected_print)\n            \n            self.assertTrue(os.path.exists(file_path))\n            with open(file_path, 'r') as f:\n                content = f.read()\n            self.assertEqual(content, '')\n\n    def test_happy_path_non_string_data(self):\n        # Test writing non-string values\n        with tempfile.TemporaryDirectory() as tmpdir:\n            file_path = os.path.join(tmpdir, 'settings.conf')\n            settings = {'int': 123, 'float': 1.23, 'bool': True}\n            with patch('builtins.print') as mock_print:\n                store_settings(file_path, settings)\n                expected_print = f\"Configuration securely written to '{file_path}'\"\n                mock_print.assert_called_once_with(expected_print)\n            \n            with open(file_path, 'r') as f:\n                content = f.read()\n            expected_content = 'int=123\\nfloat=1.23\\nbool=True\\n'\n            self.assertEqual(content, expected_content)\n\n    def test_existing_file_overwritten(self):\n        # Test overwriting existing file with proper permissions\n        with tempfile.TemporaryDirectory() as tmpdir:\n            file_path = os.path.join(tmpdir, 'settings.conf')\n            with open(file_path, 'w') as f:\n                f.write('old_key=old_value\\n')\n            os.chmod(file_path, 0o600)\n            \n            settings_data = {'new_key': 'new_value'}\n            with patch('builtins.print') as mock_print:\n                store_settings(file_path, settings_data)\n                expected_print = f\"Configuration securely written to '{file_path}'\"\n                mock_print.assert_called_once_with(expected_print)\n            \n            with open(file_path, 'r') as f:\n                content = f.read()\n            self.assertEqual(content, 'new_key=new_value\\n')\n            \n            st = os.stat(file_path)\n            self.assertEqual(stat.S_IMODE(st.st_mode), 0o600)\n\n    def test_directory_does_not_exist(self):\n        # Test non-existent directory\n        with tempfile.TemporaryDirectory() as tmpdir:\n            non_exist_dir = os.path.join(tmpdir, 'non_exist_dir')\n            file_path = os.path.join(non_exist_dir, 'settings.conf')\n            settings_data = {'key': 'value'}\n            \n            with patch('builtins.print') as mock_print:\n                store_settings(file_path, settings_data)\n                expected_print = f\"Error: Directory '{non_exist_dir}' does not exist.\"\n                mock_print.assert_called_once_with(expected_print)\n            \n            self.assertFalse(os.path.exists(file_path))\n\n    def test_file_owned_by_another_user(self):\n        # Test file owned by different user\n        with patch('os.getuid', return_value=1000):\n            mock_stat = MagicMock()\n            mock_stat.st_uid = 9999\n            mock_stat.st_mode = 0o600\n            \n            with patch('os.stat', return_value=mock_stat), \\\n                 patch('os.path.exists', return_value=True):\n                settings_file = '/fake/path/settings.conf'\n                settings_data = {'key': 'value'}\n                \n                with patch('builtins.print') as mock_print:\n                    store_settings(settings_file, settings_data)\n                    expected_print = f\"Error: Configuration file '{settings_file}' is owned by another user.\"\n                    mock_print.assert_called_once_with(expected_print)\n\n    def test_file_has_group_or_other_permissions(self):\n        # Test existing file with group/other permissions\n        with tempfile.TemporaryDirectory() as tmpdir:\n            file_path = os.path.join(tmpdir, 'settings.conf')\n            with open(file_path, 'w') as f:\n                f.write('old_key=old_value\\n')\n            os.chmod(file_path, 0o777)\n            \n            settings_data = {'new_key': 'new_value'}\n            with patch('builtins.print') as mock_print:\n                store_settings(file_path, settings_data)\n                expected_print = f\"Error: Configuration file '{file_path}' is accessible by group or others.\"\n                mock_print.assert_called_once_with(expected_print)\n            \n            with open(file_path, 'r') as f:\n                content = f.read()\n            self.assertEqual(content, 'old_key=old_value\\n')\n\n    def test_exception_during_writing(self):\n        # Test exception during file write\n        settings_file = '/fake/path/settings.conf'\n        settings_data = {'key': 'value'}\n        \n        with patch('os.path.exists', return_value=True):\n            mock_stat = MagicMock()\n            mock_stat.st_uid = os.getuid()\n            mock_stat.st_mode = 0o600\n            \n            with patch('os.stat', return_value=mock_stat), \\\n                 patch('builtins.open', side_effect=IOError('Permission denied')), \\\n                 patch('builtins.print') as mock_print:\n                \n                store_settings(settings_file, settings_data)\n                mock_print.assert_called_once()\n                error_message = mock_print.call_args[0][0]\n                self.assertIn('Error securing and writing configuration', error_message)\n                self.assertIn('Permission denied', error_message)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 8, "task_id": "2f30a918"}
{"test": "import unittest\nimport os\nimport stat\nimport tempfile\nfrom unittest.mock import patch, MagicMock\n\nclass TestCases(unittest.TestCase):\n    def test_case_1(self):\n        # Test when the directory does not exist\n        with tempfile.TemporaryDirectory() as tmpdir:\n            bad_dir = os.path.join(tmpdir, 'non_existing')\n            config_path = os.path.join(bad_dir, 'config.txt')\n            config_items = {'key': 'value'}\n            with patch('builtins.print') as mock_print:\n                save_config(config_path, config_items)\n                mock_print.assert_called_with(f'Error: Directory \\'{bad_dir}\\' does not exist.')\n                self.assertFalse(os.path.exists(config_path))\n\n    def test_case_2(self):\n        # Test when file exists and is owned by another user\n        with tempfile.TemporaryDirectory() as tmpdir:\n            config_path = os.path.join(tmpdir, 'config.txt')\n            with open(config_path, 'w') as f:\n                f.write('test')\n            \n            mock_stat = MagicMock()\n            mock_stat.st_uid = 999\n            mock_stat.st_mode = 0o100600\n            \n            with patch('os.stat', return_value=mock_stat), \\\n                 patch('os.getuid', return_value=1000), \\\n                 patch('builtins.print') as mock_print:\n                save_config(config_path, {'key': 'value'})\n                mock_print.assert_called_with(f'Error: Configuration file \\'{config_path}\\' is owned by another user.')\n\n    def test_case_3(self):\n        # Test when file exists and has group/other permissions\n        with tempfile.TemporaryDirectory() as tmpdir:\n            config_path = os.path.join(tmpdir, 'config.txt')\n            with open(config_path, 'w') as f:\n                f.write('test')\n            \n            mock_stat = MagicMock()\n            mock_stat.st_uid = os.getuid()\n            mock_stat.st_mode = 0o100644\n            \n            with patch('os.stat', return_value=mock_stat), \\\n                 patch('builtins.print') as mock_print:\n                save_config(config_path, {'key': 'value'})\n                mock_print.assert_called_with(f'Error: Configuration file \\'{config_path}\\' is accessible by group or others.')\n\n    def test_case_4(self):\n        # Test successful write to a new file\n        with tempfile.TemporaryDirectory() as tmpdir:\n            config_path = os.path.join(tmpdir, 'config.txt')\n            config_items = {'key1': 'value1', 'key2': 'value2'}\n            with patch('builtins.print') as mock_print:\n                save_config(config_path, config_items)\n                mock_print.assert_called_with(f'Configuration securely written to \\'{config_path}\\'')\n                \n                self.assertTrue(os.path.exists(config_path))\n                with open(config_path, 'r') as f:\n                    content = f.read()\n                self.assertEqual(content, 'key1=value1\\nkey2=value2\\n')\n                \n                mode = os.stat(config_path).st_mode\n                self.assertEqual(stat.S_IMODE(mode), 0o600)\n\n    def test_case_5(self):\n        # Test successful overwrite of existing file\n        with tempfile.TemporaryDirectory() as tmpdir:\n            config_path = os.path.join(tmpdir, 'config.txt')\n            with open(config_path, 'w') as f:\n                f.write('old_content')\n            os.chmod(config_path, 0o600)\n            \n            config_items = {'new_key': 'new_value'}\n            with patch('builtins.print') as mock_print:\n                save_config(config_path, config_items)\n                mock_print.assert_called_with(f'Configuration securely written to \\'{config_path}\\'')\n                \n                with open(config_path, 'r') as f:\n                    content = f.read()\n                self.assertEqual(content, 'new_key=new_value\\n')\n                \n                mode = os.stat(config_path).st_mode\n                self.assertEqual(stat.S_IMODE(mode), 0o600)\n\n    def test_case_6(self):\n        # Test exception during file writing\n        with tempfile.TemporaryDirectory() as tmpdir:\n            config_path = os.path.join(tmpdir, 'config.txt')\n            config_items = {'key': 'value'}\n            \n            with patch('builtins.open', side_effect=IOError('Simulated write error')), \\\n                 patch('builtins.print') as mock_print:\n                save_config(config_path, config_items)\n                self.assertTrue(mock_print.call_args[0][0].startswith('Error securing and writing configuration'))\n                self.assertIn('Simulated write error', mock_print.call_args[0][0])\n\n    def test_case_7(self):\n        # Test exception during chmod\n        with tempfile.TemporaryDirectory() as tmpdir:\n            config_path = os.path.join(tmpdir, 'config.txt')\n            config_items = {'key': 'value'}\n            \n            with patch('os.chmod', side_effect=PermissionError('Simulated chmod error')), \\\n                 patch('builtins.print') as mock_print:\n                save_config(config_path, config_items)\n                self.assertTrue(mock_print.call_args[0][0].startswith('Error securing and writing configuration'))\n                self.assertIn('Simulated chmod error', mock_print.call_args[0][0])\n\n    def test_case_8(self):\n        # Test with empty config_items\n        with tempfile.TemporaryDirectory() as tmpdir:\n            config_path = os.path.join(tmpdir, 'config.txt')\n            config_items = {}\n            \n            save_config(config_path, config_items)\n            \n            self.assertTrue(os.path.exists(config_path))\n            with open(config_path, 'r') as f:\n                content = f.read()\n            self.assertEqual(content, '')\n            \n            mode = os.stat(config_path).st_mode\n            self.assertEqual(stat.S_IMODE(mode), 0o600)\n\n    def test_case_9(self):\n        # Test with non-string key (convertible to string)\n        with tempfile.TemporaryDirectory() as tmpdir:\n            config_path = os.path.join(tmpdir, 'config.txt')\n            config_items = {123: 'value'}\n            \n            save_config(config_path, config_items)\n            \n            with open(config_path, 'r') as f:\n                content = f.read()\n            self.assertEqual(content, '123=value\\n')\n\n    def test_case_10(self):\n        # Test with non-string value (convertible to string)\n        with tempfile.TemporaryDirectory() as tmpdir:\n            config_path = os.path.join(tmpdir, 'config.txt')\n            config_items = {'key': 123}\n            \n            save_config(config_path, config_items)\n            \n            with open(config_path, 'r') as f:\n                content = f.read()\n            self.assertEqual(content, 'key=123\\n')\n\n    def test_case_11(self):\n        # Test with value containing newline\n        with tempfile.TemporaryDirectory() as tmpdir:\n            config_path = os.path.join(tmpdir, 'config.txt')\n            config_items = {'key': 'val\\nue'}\n            \n            save_config(config_path, config_items)\n            \n            with open(config_path, 'r') as f:\n                content = f.read()\n            self.assertEqual(content, 'key=val\\nue\\n')\n\n    def test_case_12(self):\n        # Test with very long key and value\n        with tempfile.TemporaryDirectory() as tmpdir:\n            config_path = os.path.join(tmpdir, 'config.txt')\n            long_key = 'k' * 1000\n            long_value = 'v' * 1000\n            config_items = {long_key: long_value}\n            \n            save_config(config_path, config_items)\n            \n            with open(config_path, 'r') as f:\n                content = f.read()\n            self.assertEqual(content, f'{long_key}={long_value}\\n')\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 12, "task_id": "fe03e87d"}
{"test": "import unittest\nimport os\nimport stat\nfrom unittest.mock import patch, mock_open, MagicMock\n\nclass TestLogConfiguration(unittest.TestCase):\n\n    @patch('builtins.print')\n    @patch('os.path.exists')\n    @patch('os.path.dirname')\n    def test_directory_not_exist(self, mock_dirname, mock_exists, mock_print):\n        \"\"\"Test when the directory does not exist.\"\"\"\n        mock_dirname.return_value = '/some/dir'\n        mock_exists.return_value = False\n        \n        log_configuration('/some/dir/config.txt', {'key': 'value'})\n        \n        mock_print.assert_called_once_with(\"Error: Directory '/some/dir' does not exist.\")\n\n    @patch('builtins.print')\n    @patch('os.stat')\n    @patch('os.getuid')\n    @patch('os.path.exists')\n    @patch('os.path.dirname')\n    def test_file_owned_by_another_user(self, mock_dirname, mock_exists, mock_getuid, mock_stat, mock_print):\n        \"\"\"Test when the file exists but is owned by another user.\"\"\"\n        mock_dirname.return_value = '/some/dir'\n        mock_exists.side_effect = [True, True]  # Directory exists, file exists\n        mock_getuid.return_value = 1000\n        mock_stat_result = MagicMock()\n        mock_stat_result.st_uid = 1001  # Different user\n        mock_stat.return_value = mock_stat_result\n        \n        log_configuration('/some/dir/config.txt', {'key': 'value'})\n        \n        mock_print.assert_called_once_with(\"Error: Configuration file '/some/dir/config.txt' is owned by another user.\")\n\n    @patch('builtins.print')\n    @patch('os.stat')\n    @patch('os.getuid')\n    @patch('os.path.exists')\n    @patch('os.path.dirname')\n    def test_file_has_group_or_other_permissions(self, mock_dirname, mock_exists, mock_getuid, mock_stat, mock_print):\n        \"\"\"Test when the file exists and has group/other permissions.\"\"\"\n        mock_dirname.return_value = '/some/dir'\n        mock_exists.side_effect = [True, True]  # Directory exists, file exists\n        mock_getuid.return_value = 1000\n        mock_stat_result = MagicMock()\n        mock_stat_result.st_uid = 1000\n        mock_stat_result.st_mode = 0o777  # Permissions for group/others\n        mock_stat.return_value = mock_stat_result\n        \n        log_configuration('/some/dir/config.txt', {'key': 'value'})\n        \n        mock_print.assert_called_once_with(\"Error: Configuration file '/some/dir/config.txt' is accessible by group or others.\")\n\n    @patch('builtins.print')\n    @patch('os.chmod')\n    @patch('os.path.exists')\n    @patch('os.path.dirname')\n    @patch('builtins.open', new_callable=mock_open)\n    def test_successful_write_new_file(self, mock_open, mock_dirname, mock_exists, mock_chmod, mock_print):\n        \"\"\"Test successful write when file does not exist.\"\"\"\n        mock_dirname.return_value = '/some/dir'\n        mock_exists.side_effect = [True, False]  # Directory exists, file does not\n        config_map = {'key1': 'value1', 'key2': 'value2'}\n        \n        log_configuration('/some/dir/config.txt', config_map)\n        \n        mock_open.assert_called_once_with('/some/dir/config.txt', 'w')\n        handle = mock_open()\n        expected_writes = [f\"{key}={value}\\n\" for key, value in config_map.items()]\n        actual_writes = ''.join(call_args[0][0] for call_args in handle.write.call_args_list)\n        for expected in expected_writes:\n            self.assertIn(expected, actual_writes)\n        mock_chmod.assert_called_once_with('/some/dir/config.txt', stat.S_IRUSR | stat.S_IWUSR)\n        mock_print.assert_called_once_with(\"Configuration securely written to '/some/dir/config.txt'\")\n\n    @patch('builtins.print')\n    @patch('os.chmod')\n    @patch('os.stat')\n    @patch('os.getuid')\n    @patch('os.path.exists')\n    @patch('os.path.dirname')\n    @patch('builtins.open', new_callable=mock_open)\n    def test_successful_write_existing_file(self, mock_open, mock_dirname, mock_exists, mock_getuid, mock_stat, mock_chmod, mock_print):\n        \"\"\"Test successful write when file exists and passes checks.\"\"\"\n        mock_dirname.return_value = '/some/dir'\n        mock_exists.side_effect = [True, True]  # Directory exists, file exists\n        mock_getuid.return_value = 1000\n        mock_stat_result = MagicMock()\n        mock_stat_result.st_uid = 1000\n        mock_stat_result.st_mode = 0o600  # No group/other permissions\n        mock_stat.return_value = mock_stat_result\n        config_map = {'key': 'value'}\n        \n        log_configuration('/some/dir/config.txt', config_map)\n        \n        mock_open.assert_called_once_with('/some/dir/config.txt', 'w')\n        handle = mock_open()\n        handle.write.assert_called_once_with('key=value\\n')\n        mock_chmod.assert_called_once_with('/some/dir/config.txt', stat.S_IRUSR | stat.S_IWUSR)\n        mock_print.assert_called_once_with(\"Configuration securely written to '/some/dir/config.txt'\")\n\n    @patch('builtins.print')\n    @patch('os.chmod')\n    @patch('os.path.exists')\n    @patch('os.path.dirname')\n    @patch('builtins.open', new_callable=mock_open)\n    def test_exception_during_write(self, mock_open, mock_dirname, mock_exists, mock_chmod, mock_print):\n        \"\"\"Test exception during file writing.\"\"\"\n        mock_dirname.return_value = '/some/dir'\n        mock_exists.return_value = True  # Directory exists\n        mock_open.side_effect = IOError(\"Disk full\")\n        config_map = {'key': 'value'}\n        \n        log_configuration('/some/dir/config.txt', config_map)\n        \n        mock_print.assert_called_once_with(\"Error securing and writing configuration to '/some/dir/config.txt': Disk full\")\n        mock_chmod.assert_not_called()\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 6, "task_id": "251351e9"}
{"test": "import os\nimport stat\nimport tempfile\nimport unittest\nfrom unittest.mock import patch, MagicMock\n\n# Import the function from its module (replace 'your_module' with actual module name)\nfrom your_module import save_configurations\n\nclass TestSaveConfigurations(unittest.TestCase):\n    \n    def test_new_file_creation(self):\n        # Happy path: Create new file with valid data\n        with tempfile.TemporaryDirectory() as tmpdir:\n            target_file = os.path.join(tmpdir, 'config.txt')\n            data = {'api_key': '12345', 'db_pass': 'secret'}\n            save_configurations(target_file, data)\n            \n            # Verify file exists and has correct content\n            self.assertTrue(os.path.exists(target_file))\n            with open(target_file, 'r') as f:\n                content = f.read()\n            self.assertIn('api_key=12345', content)\n            self.assertIn('db_pass=secret', content)\n            \n            # Verify permissions (0600)\n            st = os.stat(target_file)\n            self.assertEqual(stat.S_IMODE(st.st_mode), 0o600)\n    \n    def test_existing_file_overwrite(self):\n        # Happy path: Overwrite existing file with correct permissions\n        with tempfile.TemporaryDirectory() as tmpdir:\n            target_file = os.path.join(tmpdir, 'config.txt')\n            # Create pre-existing file with correct permissions\n            with open(target_file, 'w') as f:\n                f.write('old_data')\n            os.chmod(target_file, 0o600)\n            \n            data = {'new_key': 'new_value'}\n            save_configurations(target_file, data)\n            \n            # Verify content updated\n            with open(target_file, 'r') as f:\n                content = f.read()\n            self.assertEqual(content, 'new_key=new_value\\n')\n            \n            # Verify permissions remain 0600\n            st = os.stat(target_file)\n            self.assertEqual(stat.S_IMODE(st.st_mode), 0o600)\n    \n    def test_nonexistent_directory(self):\n        # Error: Target directory doesn't exist\n        with tempfile.TemporaryDirectory() as tmpdir:\n            target_file = os.path.join(tmpdir, 'nonexistent_dir', 'config.txt')\n            data = {'key': 'value'}\n            \n            save_configurations(target_file, data)\n            \n            # Verify file wasn't created\n            self.assertFalse(os.path.exists(target_file))\n    \n    def test_existing_file_wrong_owner(self):\n        # Error: File exists but owned by different user (mocked)\n        current_uid = os.getuid()\n        mock_stat = MagicMock()\n        mock_stat.st_uid = current_uid + 1  # Different user\n        mock_stat.st_mode = 0o600  # Correct permissions\n        \n        with patch('os.stat', return_value=mock_stat):\n            with patch('os.path.exists', return_value=True):\n                with patch('builtins.open') as mock_open:\n                    save_configurations('/dummy/path', {'key': 'value'})\n                    mock_open.assert_not_called()\n    \n    def test_existing_file_wrong_permissions(self):\n        # Error: File exists with group/other permissions (mocked)\n        current_uid = os.getuid()\n        mock_stat = MagicMock()\n        mock_stat.st_uid = current_uid  # Correct owner\n        mock_stat.st_mode = 0o644  # Group/other have read\n        \n        with patch('os.stat', return_value=mock_stat):\n            with patch('os.path.exists', return_value=True):\n                with patch('builtins.open') as mock_open:\n                    save_configurations('/dummy/path', {'key': 'value'})\n                    mock_open.assert_not_called()\n    \n    def test_write_failure(self):\n        # Error: Exception during file writing (mocked)\n        with tempfile.TemporaryDirectory() as tmpdir:\n            target_file = os.path.join(tmpdir, 'config.txt')\n            data = {'key': 'value'}\n            \n            with patch('builtins.open', side_effect=Exception('Mocked write error')):\n                save_configurations(target_file, data)\n                \n            # Verify file wasn't created\n            self.assertFalse(os.path.exists(target_file))\n    \n    def test_empty_data_dict(self):\n        # Edge: Empty configuration dictionary\n        with tempfile.TemporaryDirectory() as tmpdir:\n            target_file = os.path.join(tmpdir, 'config.txt')\n            data = {}\n            save_configurations(target_file, data)\n            \n            self.assertTrue(os.path.exists(target_file))\n            with open(target_file, 'r') as f:\n                content = f.read()\n            self.assertEqual(content, '')\n            \n            st = os.stat(target_file)\n            self.assertEqual(stat.S_IMODE(st.st_mode), 0o600)\n    \n    def test_non_string_values(self):\n        # Edge: Non-string values in dictionary\n        with tempfile.TemporaryDirectory() as tmpdir:\n            target_file = os.path.join(tmpdir, 'config.txt')\n            data = {'int': 42, 'float': 3.14, 'bool': True, 'none': None}\n            save_configurations(target_file, data)\n            \n            with open(target_file, 'r') as f:\n                content = f.read()\n            \n            self.assertIn('int=42', content)\n            self.assertIn('float=3.14', content)\n            self.assertIn('bool=True', content)\n            self.assertIn('none=None', content)\n    \n    def test_special_characters(self):\n        # Edge: Special characters in values\n        with tempfile.TemporaryDirectory() as tmpdir:\n            target_file = os.path.join(tmpdir, 'config.txt')\n            data = {'password': 'p@$$w0rd\\nwith\\tnewline'}\n            save_configurations(target_file, data)\n            \n            with open(target_file, 'r') as f:\n                content = f.read()\n            self.assertEqual(content, 'password=p@$$w0rd\\nwith\\tnewline\\n')\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 9, "task_id": "338234dd"}
{"test": "import unittest\nimport os\nimport stat\nfrom unittest.mock import patch, mock_open, MagicMock\n\nfrom solution import store_config_data\n\nclass TestStoreConfigData(unittest.TestCase):\n    def test_success_new_file(self):\n        \"\"\"Test writing to a new file successfully with correct permissions.\"\"\"\n        config_path = '/path/to/config.ini'\n        directory = '/path/to'\n        cfg_data = {'key1': 'value1', 'key2': 'value2'}\n        expected_content = \"key1=value1\\nkey2=value2\\n\"\n        \n        with patch('os.path.exists') as mock_exists, \\\n             patch('os.path.dirname') as mock_dirname, \\\n             patch('builtins.open', mock_open()) as mock_file, \\\n             patch('os.chmod') as mock_chmod, \\\n             patch('os.getuid') as mock_getuid, \\\n             patch('os.stat') as mock_stat, \\\n             patch('builtins.print') as mock_print:\n            \n            mock_dirname.return_value = directory\n            mock_exists.side_effect = lambda x: {directory: True, config_path: False}.get(x, False)\n            mock_getuid.return_value = 1000\n            \n            store_config_data(config_path, cfg_data)\n            \n            mock_file.assert_called_once_with(config_path, 'w')\n            handle = mock_file()\n            written_content = ''.join(call[0][0] for call in handle.write.call_args_list)\n            self.assertEqual(written_content, expected_content)\n            mock_chmod.assert_called_once_with(config_path, stat.S_IRUSR | stat.S_IWUSR)\n            mock_print.assert_called_once_with(f\"Configuration securely written to '{config_path}'\")\n\n    def test_directory_not_exist(self):\n        \"\"\"Test when the target directory does not exist.\"\"\"\n        config_path = '/path/to/config.ini'\n        directory = '/path/to'\n        cfg_data = {'key1': 'value1'}\n        \n        with patch('os.path.exists') as mock_exists, \\\n             patch('os.path.dirname') as mock_dirname, \\\n             patch('builtins.open', mock_open()) as mock_file, \\\n             patch('os.chmod') as mock_chmod, \\\n             patch('builtins.print') as mock_print:\n            \n            mock_dirname.return_value = directory\n            mock_exists.side_effect = lambda x: False\n            \n            store_config_data(config_path, cfg_data)\n            \n            mock_print.assert_called_once_with(f\"Error: Directory '{directory}' does not exist.\")\n            mock_file.assert_not_called()\n            mock_chmod.assert_not_called()\n\n    def test_owned_by_other_user(self):\n        \"\"\"Test when the existing file is owned by another user.\"\"\"\n        config_path = '/path/to/config.ini'\n        directory = '/path/to'\n        cfg_data = {'key1': 'value1'}\n        \n        with patch('os.path.exists') as mock_exists, \\\n             patch('os.path.dirname') as mock_dirname, \\\n             patch('os.stat') as mock_stat, \\\n             patch('os.getuid') as mock_getuid, \\\n             patch('builtins.open', mock_open()) as mock_file, \\\n             patch('os.chmod') as mock_chmod, \\\n             patch('builtins.print') as mock_print:\n            \n            mock_dirname.return_value = directory\n            mock_exists.side_effect = lambda x: {directory: True, config_path: True}.get(x, False)\n            mock_getuid.return_value = 1000\n            \n            file_stat = MagicMock()\n            file_stat.st_uid = 1001\n            file_stat.st_mode = 0o600\n            mock_stat.return_value = file_stat\n            \n            store_config_data(config_path, cfg_data)\n            \n            mock_print.assert_called_once_with(f\"Error: Configuration file '{config_path}' is owned by another user.\")\n            mock_file.assert_not_called()\n            mock_chmod.assert_not_called()\n\n    def test_existing_file_with_group_other_permissions(self):\n        \"\"\"Test when the existing file has group/other permissions.\"\"\"\n        config_path = '/path/to/config.ini'\n        directory = '/path/to'\n        cfg_data = {'key1': 'value1'}\n        \n        with patch('os.path.exists') as mock_exists, \\\n             patch('os.path.dirname') as mock_dirname, \\\n             patch('os.stat') as mock_stat, \\\n             patch('os.getuid') as mock_getuid, \\\n             patch('builtins.open', mock_open()) as mock_file, \\\n             patch('os.chmod') as mock_chmod, \\\n             patch('builtins.print') as mock_print:\n            \n            mock_dirname.return_value = directory\n            mock_exists.side_effect = lambda x: {directory: True, config_path: True}.get(x, False)\n            mock_getuid.return_value = 1000\n            \n            file_stat = MagicMock()\n            file_stat.st_uid = 1000\n            file_stat.st_mode = 0o620\n            mock_stat.return_value = file_stat\n            \n            store_config_data(config_path, cfg_data)\n            \n            mock_print.assert_called_once_with(f\"Error: Configuration file '{config_path}' is accessible by group or others.\")\n            mock_file.assert_not_called()\n            mock_chmod.assert_not_called()\n\n    def test_exception_during_write(self):\n        \"\"\"Test exception handling during file writing.\"\"\"\n        config_path = '/path/to/config.ini'\n        directory = '/path/to'\n        cfg_data = {'key1': 'value1'}\n        \n        with patch('os.path.exists') as mock_exists, \\\n             patch('os.path.dirname') as mock_dirname, \\\n             patch('builtins.open') as mock_open, \\\n             patch('os.chmod') as mock_chmod, \\\n             patch('builtins.print') as mock_print:\n            \n            mock_dirname.return_value = directory\n            mock_exists.side_effect = lambda x: {directory: True, config_path: False}.get(x, False)\n            mock_open.side_effect = IOError(\"Write failed\")\n            \n            store_config_data(config_path, cfg_data)\n            \n            mock_print.assert_called_once_with(f\"Error securing and writing configuration to '{config_path}': Write failed\")\n            mock_chmod.assert_not_called()\n\n    def test_exception_during_chmod(self):\n        \"\"\"Test exception handling during permission change.\"\"\"\n        config_path = '/path/to/config.ini'\n        directory = '/path/to'\n        cfg_data = {'key1': 'value1'}\n        \n        with patch('os.path.exists') as mock_exists, \\\n             patch('os.path.dirname') as mock_dirname, \\\n             patch('builtins.open', mock_open()) as mock_file, \\\n             patch('os.chmod') as mock_chmod, \\\n             patch('builtins.print') as mock_print:\n            \n            mock_dirname.return_value = directory\n            mock_exists.side_effect = lambda x: {directory: True, config_path: False}.get(x, False)\n            mock_chmod.side_effect = PermissionError(\"Permission denied\")\n            \n            store_config_data(config_path, cfg_data)\n            \n            mock_print.assert_called_once_with(f\"Error securing and writing configuration to '{config_path}': Permission denied\")\n\n    def test_overwrite_existing_file(self):\n        \"\"\"Test overwriting an existing file with correct ownership and permissions.\"\"\"\n        config_path = '/path/to/config.ini'\n        directory = '/path/to'\n        cfg_data = {'key1': 'value1', 'key2': 'value2'}\n        expected_content = \"key1=value1\\nkey2=value2\\n\"\n        \n        with patch('os.path.exists') as mock_exists, \\\n             patch('os.path.dirname') as mock_dirname, \\\n             patch('builtins.open', mock_open()) as mock_file, \\\n             patch('os.chmod') as mock_chmod, \\\n             patch('os.getuid') as mock_getuid, \\\n             patch('os.stat') as mock_stat, \\\n             patch('builtins.print') as mock_print:\n            \n            mock_dirname.return_value = directory\n            mock_exists.side_effect = lambda x: {directory: True, config_path: True}.get(x, False)\n            mock_getuid.return_value = 1000\n            \n            file_stat = MagicMock()\n            file_stat.st_uid = 1000\n            file_stat.st_mode = 0o600\n            mock_stat.return_value = file_stat\n            \n            store_config_data(config_path, cfg_data)\n            \n            mock_file.assert_called_once_with(config_path, 'w')\n            handle = mock_file()\n            written_content = ''.join(call[0][0] for call in handle.write.call_args_list)\n            self.assertEqual(written_content, expected_content)\n            mock_chmod.assert_called_once_with(config_path, stat.S_IRUSR | stat.S_IWUSR)\n            mock_print.assert_called_once_with(f\"Configuration securely written to '{config_path}'\")\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 7, "task_id": "9eaa7d22"}
{"test": "import os\nimport stat\nimport tempfile\nimport unittest\nfrom unittest.mock import patch, MagicMock\n\nclass TestSecureConfigSave(unittest.TestCase):\n\n    def test_new_file_happy_path(self):\n        # Test creating a new file with valid data in existing directory\n        with tempfile.TemporaryDirectory() as tmpdir:\n            file_path = os.path.join(tmpdir, 'config.txt')\n            sensitive_data = {'api_key': '12345', 'db_password': 'secret'}\n            \n            with patch('builtins.print') as mock_print:\n                secure_config_save(file_path, sensitive_data)\n                mock_print.assert_called_once_with(\"Configuration securely written to '{}'\".format(file_path))\n            \n            self.assertTrue(os.path.exists(file_path))\n            \n            with open(file_path, 'r') as f:\n                content = f.read().splitlines()\n            expected_lines = sorted([\"{}={}\".format(k, v) for k, v in sensitive_data.items()])\n            self.assertEqual(sorted(content), expected_lines)\n            \n            st = os.stat(file_path)\n            self.assertEqual(st.st_mode & 0o777, stat.S_IRUSR | stat.S_IWUSR)\n\n    def test_existing_file_safe_overwrite(self):\n        # Test overwriting existing file with proper ownership and permissions\n        with tempfile.TemporaryDirectory() as tmpdir:\n            file_path = os.path.join(tmpdir, 'config.txt')\n            initial_data = {'old_key': 'old_value'}\n            with open(file_path, 'w') as f:\n                for key, value in initial_data.items():\n                    f.write(f\"{key}={value}\\n\")\n            os.chmod(file_path, stat.S_IRUSR | stat.S_IWUSR)\n            \n            sensitive_data = {'new_key': 'new_value'}\n            \n            with patch('builtins.print') as mock_print:\n                secure_config_save(file_path, sensitive_data)\n                mock_print.assert_called_once_with(\"Configuration securely written to '{}'\".format(file_path))\n            \n            with open(file_path, 'r') as f:\n                content = f.read().splitlines()\n            expected_lines = [\"{}={}\".format(k, v) for k, v in sensitive_data.items()]\n            self.assertEqual(content, expected_lines)\n            \n            st = os.stat(file_path)\n            self.assertEqual(st.st_mode & 0o777, stat.S_IRUSR | stat.S_IWUSR)\n\n    def test_directory_not_exist(self):\n        # Test non-existent directory path\n        with tempfile.TemporaryDirectory() as tmpdir:\n            non_exist_dir = os.path.join(tmpdir, 'non_exist')\n            file_path = os.path.join(non_exist_dir, 'config.txt')\n            sensitive_data = {'key': 'value'}\n            \n            with patch('builtins.print') as mock_print:\n                secure_config_save(file_path, sensitive_data)\n                mock_print.assert_called_once_with(\"Error: Directory '{}' does not exist.\".format(non_exist_dir))\n            \n            self.assertFalse(os.path.exists(file_path))\n\n    def test_existing_file_owned_by_another(self):\n        # Test existing file owned by another user\n        file_name = '/path/to/config.txt'\n        sensitive_data = {'key': 'value'}\n        \n        with patch('os.path.exists', return_value=True), \\\n             patch('os.stat') as mock_stat, \\\n             patch('os.getuid') as mock_getuid, \\\n             patch('builtins.print') as mock_print:\n            \n            mock_getuid.return_value = 1000\n            mock_stat_result = MagicMock()\n            mock_stat_result.st_uid = 1001\n            mock_stat_result.st_mode = 0o600\n            mock_stat.return_value = mock_stat_result\n            \n            secure_config_save(file_name, sensitive_data)\n            mock_print.assert_called_once_with(\"Error: Configuration file '{}' is owned by another user.\".format(file_name))\n\n    def test_existing_file_bad_permissions(self):\n        # Test existing file with group/others permissions\n        file_name = '/path/to/config.txt'\n        sensitive_data = {'key': 'value'}\n        \n        with patch('os.path.exists', return_value=True), \\\n             patch('os.stat') as mock_stat, \\\n             patch('os.getuid') as mock_getuid, \\\n             patch('builtins.print') as mock_print:\n            \n            mock_getuid.return_value = 1000\n            mock_stat_result = MagicMock()\n            mock_stat_result.st_uid = 1000\n            mock_stat_result.st_mode = 0o602\n            mock_stat.return_value = mock_stat_result\n            \n            secure_config_save(file_name, sensitive_data)\n            mock_print.assert_called_once_with(\"Error: Configuration file '{}' is accessible by group or others.\".format(file_name))\n\n    def test_write_exception(self):\n        # Test file writing exception\n        with tempfile.TemporaryDirectory() as tmpdir:\n            file_path = os.path.join(tmpdir, 'config.txt')\n            sensitive_data = {'key': 'value'}\n            \n            with patch('builtins.open', side_effect=IOError(\"Disk full\")), \\\n                 patch('builtins.print') as mock_print:\n                \n                secure_config_save(file_path, sensitive_data)\n                mock_print.assert_called_once_with(\"Error securing and writing configuration to '{}': Disk full\".format(file_path))\n\n    def test_chmod_exception(self):\n        # Test permission setting exception\n        with tempfile.TemporaryDirectory() as tmpdir:\n            file_path = os.path.join(tmpdir, 'config.txt')\n            sensitive_data = {'key': 'value'}\n            \n            with patch('os.chmod', side_effect=PermissionError(\"Permission denied\")), \\\n                 patch('builtins.print') as mock_print:\n                \n                secure_config_save(file_path, sensitive_data)\n                mock_print.assert_called_once_with(\"Error securing and writing configuration to '{}': Permission denied\".format(file_path))\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 7, "task_id": "566484ed"}
{"test": "import unittest\nimport os\nimport stat\nimport tempfile\nfrom unittest.mock import patch, MagicMock\n\nclass TestSaveConfigurations(unittest.TestCase):\n\n    def test_success_new_file(self):\n        # Test writing to a new file: should create file with correct content and permissions\n        with tempfile.TemporaryDirectory() as tmpdir:\n            config_path = os.path.join(tmpdir, 'config.txt')\n            data = {'key1': 'value1', 'key2': 'value2'}\n            with patch('builtins.print') as mock_print:\n                save_configurations(config_path, data)\n            self.assertTrue(os.path.exists(config_path))\n            with open(config_path, 'r') as f:\n                content = f.read()\n            self.assertEqual(content, \"key1=value1\\nkey2=value2\\n\")\n            st = os.stat(config_path)\n            self.assertEqual(stat.S_IMODE(st.st_mode), 0o600)\n            mock_print.assert_called_once_with(f\"Configuration securely written to '{config_path}'\")\n\n    def test_success_existing_file_owned_by_user(self):\n        # Test overwriting existing file with correct ownership and permissions\n        with tempfile.TemporaryDirectory() as tmpdir:\n            config_path = os.path.join(tmpdir, 'config.txt')\n            with open(config_path, 'w') as f:\n                f.write(\"old_data\")\n            os.chmod(config_path, 0o600)\n            data = {'new_key': 'new_value'}\n            with patch('builtins.print') as mock_print:\n                save_configurations(config_path, data)\n            with open(config_path, 'r') as f:\n                content = f.read()\n            self.assertEqual(content, \"new_key=new_value\\n\")\n            st = os.stat(config_path)\n            self.assertEqual(stat.S_IMODE(st.st_mode), 0o600)\n            mock_print.assert_called_once_with(f\"Configuration securely written to '{config_path}'\")\n\n    @patch('os.stat')\n    @patch('os.getuid')\n    def test_existing_file_owned_by_another_user(self, mock_getuid, mock_stat):\n        # Test existing file owned by different user should print error\n        mock_getuid.return_value = 1000\n        mock_stat_result = MagicMock()\n        mock_stat_result.st_uid = 1001\n        mock_stat_result.st_mode = 0o600\n        mock_stat.return_value = mock_stat_result\n        with patch('os.path.exists', return_value=True):\n            with patch('builtins.print') as mock_print:\n                save_configurations('/test/path', {'key':'value'})\n        mock_print.assert_called_once_with(\"Error: Configuration file '/test/path' is owned by another user.\")\n\n    @patch('os.stat')\n    def test_existing_file_with_group_permissions(self, mock_stat):\n        # Test existing file with group permissions should print error\n        mock_stat_result = MagicMock()\n        mock_stat_result.st_uid = os.getuid()\n        mock_stat_result.st_mode = 0o610\n        mock_stat.return_value = mock_stat_result\n        with patch('os.path.exists', return_value=True):\n            with patch('builtins.print') as mock_print:\n                save_configurations('/test/path', {'key':'value'})\n        mock_print.assert_called_once_with(\"Error: Configuration file '/test/path' is accessible by group or others.\")\n\n    def test_directory_does_not_exist(self):\n        # Test non-existent directory should print error\n        with tempfile.TemporaryDirectory() as tmpdir:\n            bad_path = os.path.join(tmpdir, 'missing', 'config.txt')\n            data = {'key': 'value'}\n            with patch('builtins.print') as mock_print:\n                save_configurations(bad_path, data)\n            mock_print.assert_called_once_with(f\"Error: Directory '{os.path.dirname(bad_path)}' does not exist.\")\n\n    def test_empty_data(self):\n        # Test writing empty dictionary creates empty file with correct permissions\n        with tempfile.TemporaryDirectory() as tmpdir:\n            config_path = os.path.join(tmpdir, 'empty_config.txt')\n            with patch('builtins.print') as mock_print:\n                save_configurations(config_path, {})\n            self.assertTrue(os.path.exists(config_path))\n            with open(config_path, 'r') as f:\n                content = f.read()\n            self.assertEqual(content, \"\")\n            st = os.stat(config_path)\n            self.assertEqual(stat.S_IMODE(st.st_mode), 0o600)\n            mock_print.assert_called_once_with(f\"Configuration securely written to '{config_path}'\")\n\n    @patch('builtins.open')\n    @patch('os.path.exists')\n    def test_exception_during_write(self, mock_exists, mock_open):\n        # Test exception during file write should print error\n        mock_exists.side_effect = [True, False]\n        mock_open.side_effect = Exception(\"Write error\")\n        with patch('builtins.print') as mock_print:\n            save_configurations('/test/path', {'key':'value'})\n        mock_print.assert_called_once_with(\"Error securing and writing configuration to '/test/path': Write error\")\n\n    @patch('os.chmod')\n    @patch('os.path.exists')\n    def test_exception_during_chmod(self, mock_exists, mock_chmod):\n        # Test exception during chmod should print error\n        mock_exists.side_effect = [True, False]\n        mock_chmod.side_effect = Exception(\"Chmod error\")\n        with patch('builtins.open'), patch('builtins.print') as mock_print:\n            save_configurations('/test/path', {'key':'value'})\n        mock_print.assert_called_once_with(\"Error securing and writing configuration to '/test/path': Chmod error\")\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 8, "task_id": "6e6db482"}
{"test": "import os\nimport stat\nimport unittest\nfrom unittest.mock import patch, mock_open, MagicMock\n\n# Import the function to be tested\ntry:\n    from __main__ import create_config_file\nexcept ImportError:\n    # For when running the test in a different context\n    from solution import create_config_file\n\nclass TestCreateConfigFile(unittest.TestCase):\n\n    # Test Case 1: Happy Path - File does not exist initially\n    @patch('os.path.exists')\n    @patch('os.path.dirname')\n    @patch('os.stat')\n    @patch('os.getuid')\n    @patch('os.chmod')\n    @patch('builtins.open', new_callable=mock_open)\n    @patch('builtins.print')\n    def test_happy_path_file_not_exist(self, mock_print, mock_file, mock_chmod, mock_getuid, mock_stat, mock_dirname, mock_exists):\n        # Setup\n        config_location = '/path/to/config/file'\n        directory = '/path/to/config'\n        sensitive_data = {'key1': 'value1', 'key2': 'value2'}\n        mock_exists.side_effect = lambda x: True if x == directory else False\n        mock_dirname.return_value = directory\n        mock_getuid.return_value = 1000\n        \n        # Execute\n        create_config_file(config_location, sensitive_data)\n        \n        # Assertions\n        mock_file.assert_called_once_with(config_location, 'w')\n        handle = mock_file()\n        expected_writes = [\"key1=value1\\n\", \"key2=value2\\n\"]\n        actual_writes = [call[0][0] for call in handle.write.call_args_list]\n        self.assertEqual(actual_writes, expected_writes)\n        mock_chmod.assert_called_once_with(config_location, stat.S_IRUSR | stat.S_IWUSR)\n        mock_print.assert_called_once_with(f\"Configuration securely written to '{config_location}'\")\n\n    # Test Case 2: Directory does not exist\n    @patch('os.path.exists')\n    @patch('os.path.dirname')\n    @patch('builtins.print')\n    def test_directory_not_exist(self, mock_print, mock_dirname, mock_exists):\n        config_location = '/path/to/config/file'\n        directory = '/path/to/config'\n        sensitive_data = {'key1': 'value1'}\n        mock_exists.return_value = False\n        mock_dirname.return_value = directory\n        \n        create_config_file(config_location, sensitive_data)\n        \n        mock_print.assert_called_once_with(f\"Error: Directory '{directory}' does not exist.\")\n\n    # Test Case 3: File exists and owned by another user\n    @patch('os.path.exists')\n    @patch('os.path.dirname')\n    @patch('os.stat')\n    @patch('os.getuid')\n    @patch('builtins.print')\n    def test_file_owned_by_another_user(self, mock_print, mock_getuid, mock_stat, mock_dirname, mock_exists):\n        config_location = '/path/to/config/file'\n        directory = '/path/to/config'\n        sensitive_data = {'key1': 'value1'}\n        mock_exists.side_effect = lambda x: True\n        mock_dirname.return_value = directory\n        mock_getuid.return_value = 1000\n        st = MagicMock()\n        st.st_uid = 1001\n        st.st_mode = 0o600\n        mock_stat.return_value = st\n        \n        create_config_file(config_location, sensitive_data)\n        \n        mock_print.assert_called_once_with(f\"Error: Configuration file '{config_location}' is owned by another user.\")\n\n    # Test Case 4: File exists and has group/other permissions\n    @patch('os.path.exists')\n    @patch('os.path.dirname')\n    @patch('os.stat')\n    @patch('os.getuid')\n    @patch('builtins.print')\n    def test_file_has_group_or_other_permissions(self, mock_print, mock_getuid, mock_stat, mock_dirname, mock_exists):\n        config_location = '/path/to/config/file'\n        directory = '/path/to/config'\n        sensitive_data = {'key1': 'value1'}\n        mock_exists.side_effect = lambda x: True\n        mock_dirname.return_value = directory\n        mock_getuid.return_value = 1000\n        st = MagicMock()\n        st.st_uid = 1000\n        st.st_mode = 0o777\n        mock_stat.return_value = st\n        \n        create_config_file(config_location, sensitive_data)\n        \n        mock_print.assert_called_once_with(f\"Error: Configuration file '{config_location}' is accessible by group or others.\")\n\n    # Test Case 5: Writing fails (IOError)\n    @patch('os.path.exists')\n    @patch('os.path.dirname')\n    @patch('os.stat')\n    @patch('os.getuid')\n    @patch('builtins.open')\n    @patch('builtins.print')\n    def test_writing_fails(self, mock_print, mock_open, mock_getuid, mock_stat, mock_dirname, mock_exists):\n        config_location = '/path/to/config/file'\n        directory = '/path/to/config'\n        sensitive_data = {'key1': 'value1'}\n        mock_exists.side_effect = lambda x: True if x == directory else False\n        mock_dirname.return_value = directory\n        mock_getuid.return_value = 1000\n        mock_open.side_effect = IOError(\"Permission denied\")\n        \n        create_config_file(config_location, sensitive_data)\n        \n        self.assertIn(\"Error securing and writing configuration to '\", mock_print.call_args_list[0][0][0])\n        self.assertIn(\"Permission denied\", mock_print.call_args_list[0][0][0])\n\n    # Test Case 6: Setting permissions fails\n    @patch('os.path.exists')\n    @patch('os.path.dirname')\n    @patch('os.stat')\n    @patch('os.getuid')\n    @patch('os.chmod')\n    @patch('builtins.open', new_callable=mock_open)\n    @patch('builtins.print')\n    def test_setting_permissions_fails(self, mock_print, mock_file, mock_chmod, mock_getuid, mock_stat, mock_dirname, mock_exists):\n        config_location = '/path/to/config/file'\n        directory = '/path/to/config'\n        sensitive_data = {'key1': 'value1'}\n        mock_exists.side_effect = lambda x: True if x == directory else False\n        mock_dirname.return_value = directory\n        mock_getuid.return_value = 1000\n        mock_chmod.side_effect = OSError(\"Cannot change permissions\")\n        \n        create_config_file(config_location, sensitive_data)\n        \n        self.assertIn(\"Error securing and writing configuration to '\", mock_print.call_args_list[0][0][0])\n        self.assertIn(\"Cannot change permissions\", mock_print.call_args_list[0][0][0])\n\n    # Test Case 7: File exists and safe (overwrite)\n    @patch('os.path.exists')\n    @patch('os.path.dirname')\n    @patch('os.stat')\n    @patch('os.getuid')\n    @patch('os.chmod')\n    @patch('builtins.open', new_callable=mock_open)\n    @patch('builtins.print')\n    def test_overwrite_safe_file(self, mock_print, mock_file, mock_chmod, mock_getuid, mock_stat, mock_dirname, mock_exists):\n        config_location = '/path/to/config/file'\n        directory = '/path/to/config'\n        sensitive_data = {'key1': 'value1'}\n        mock_exists.side_effect = lambda x: True\n        mock_dirname.return_value = directory\n        mock_getuid.return_value = 1000\n        st = MagicMock()\n        st.st_uid = 1000\n        st.st_mode = 0o600\n        mock_stat.return_value = st\n        \n        create_config_file(config_location, sensitive_data)\n        \n        mock_file.assert_called_once_with(config_location, 'w')\n        mock_chmod.assert_called_once_with(config_location, stat.S_IRUSR | stat.S_IWUSR)\n        mock_print.assert_called_once_with(f\"Configuration securely written to '{config_location}'\")\n\n    # Test Case 8: Empty sensitive_data\n    @patch('os.path.exists')\n    @patch('os.path.dirname')\n    @patch('os.stat')\n    @patch('os.getuid')\n    @patch('os.chmod')\n    @patch('builtins.open', new_callable=mock_open)\n    @patch('builtins.print')\n    def test_empty_sensitive_data(self, mock_print, mock_file, mock_chmod, mock_getuid, mock_stat, mock_dirname, mock_exists):\n        config_location = '/path/to/config/file'\n        directory = '/path/to/config'\n        sensitive_data = {}\n        mock_exists.side_effect = lambda x: True if x == directory else False\n        mock_dirname.return_value = directory\n        mock_getuid.return_value = 1000\n        \n        create_config_file(config_location, sensitive_data)\n        \n        mock_file.assert_called_once_with(config_location, 'w')\n        handle = mock_file()\n        handle.write.assert_not_called()\n        mock_chmod.assert_called_once_with(config_location, stat.S_IRUSR | stat.S_IWUSR)\n        mock_print.assert_called_once_with(f\"Configuration securely written to '{config_location}'\")\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 8, "task_id": "fecf1d47"}
{"test": "import unittest\nimport os\nimport stat\nimport tempfile\nfrom unittest.mock import patch, mock_open, MagicMock\n\nclass TestStoreConfigurationFile(unittest.TestCase):\n\n    def test_happy_path_new_file(self):\n        # Test writing to a new file: should create file with correct content and permissions (600).\n        with tempfile.TemporaryDirectory() as tmpdir:\n            path = os.path.join(tmpdir, 'config.txt')\n            config = {'key1': 'value1', 'key2': 'value2'}\n            with patch('builtins.print') as mocked_print:\n                store_configuration_file(path, config)\n                mocked_print.assert_called_with(f\"Configuration securely written to '{path}'\")\n            \n            self.assertTrue(os.path.exists(path))\n            with open(path, 'r') as f:\n                content = f.read()\n            expected = \"key1=value1\\nkey2=value2\\n\"\n            self.assertEqual(content, expected)\n            mode = os.stat(path).st_mode\n            self.assertEqual(mode & 0o777, stat.S_IRUSR | stat.S_IWUSR)\n\n    def test_directory_does_not_exist(self):\n        # Test when parent directory doesn't exist: should print error and not create file.\n        with tempfile.TemporaryDirectory() as tmpdir:\n            non_existent_subdir = os.path.join(tmpdir, 'non_existent')\n            path = os.path.join(non_existent_subdir, 'config.txt')\n            config = {'key': 'value'}\n            with patch('builtins.print') as mocked_print:\n                store_configuration_file(path, config)\n                mocked_print.assert_called_with(f\"Error: Directory '{non_existent_subdir}' does not exist.\")\n            self.assertFalse(os.path.exists(path))\n\n    def test_file_owned_by_another_user(self):\n        # Test when existing file is owned by another user: should print error and not overwrite.\n        with patch('os.path.exists', return_value=True), \\\n             patch('os.stat') as mock_stat, \\\n             patch('os.getuid') as mock_getuid, \\\n             patch('builtins.print') as mocked_print:\n            \n            mock_stat.return_value = MagicMock(st_uid=1000, st_mode=stat.S_IRUSR | stat.S_IWUSR)\n            mock_getuid.return_value = 1001\n            store_configuration_file('dummy_path', {'key': 'value'})\n            mocked_print.assert_called_with(\"Error: Configuration file 'dummy_path' is owned by another user.\")\n\n    def test_file_has_group_or_other_permissions(self):\n        # Test when existing file has group/other permissions: should print error and not overwrite.\n        with patch('os.path.exists', return_value=True), \\\n             patch('os.stat') as mock_stat, \\\n             patch('os.getuid') as mock_getuid, \\\n             patch('builtins.print') as mocked_print:\n            \n            mock_stat.return_value = MagicMock(st_uid=1000, st_mode=stat.S_IRUSR | stat.S_IWUSR | stat.S_IRGRP)\n            mock_getuid.return_value = 1000\n            store_configuration_file('dummy_path', {'key': 'value'})\n            mocked_print.assert_called_with(\"Error: Configuration file 'dummy_path' is accessible by group or others.\")\n\n    def test_overwrite_existing_safe_file(self):\n        # Test overwriting an existing safe file (owned by user, 600 permissions): should update content and maintain permissions.\n        with tempfile.NamedTemporaryFile(delete=False) as tmpfile:\n            path = tmpfile.name\n            os.chmod(path, stat.S_IRUSR | stat.S_IWUSR)\n            tmpfile.write(b\"key=old_value\")\n            tmpfile.close()\n\n            config = {'new_key': 'new_value'}\n            with patch('builtins.print') as mocked_print:\n                store_configuration_file(path, config)\n                mocked_print.assert_called_with(f\"Configuration securely written to '{path}'\")\n            \n            with open(path, 'r') as f:\n                content = f.read()\n            expected = \"new_key=new_value\\n\"\n            self.assertEqual(content, expected)\n            mode = os.stat(path).st_mode\n            self.assertEqual(mode & 0o777, stat.S_IRUSR | stat.S_IWUSR)\n\n    def test_ioerror_during_write(self):\n        # Test IOError during file write: should catch and print error.\n        with patch('os.path.exists', return_value=False), \\\n             patch('builtins.open', mock_open()) as mocked_open, \\\n             patch('builtins.print') as mocked_print:\n            \n            mocked_open.side_effect = IOError(\"Disk full\")\n            store_configuration_file('dummy_path', {'key': 'value'})\n            mocked_print.assert_called_with(\"Error securing and writing configuration to 'dummy_path': Disk full\")\n\n    def test_oserror_during_chmod(self):\n        # Test OSError during permission change: should catch and print error.\n        with patch('os.path.exists', return_value=False), \\\n             patch('builtins.open', mock_open()), \\\n             patch('os.chmod') as mocked_chmod, \\\n             patch('builtins.print') as mocked_print:\n            \n            mocked_chmod.side_effect = OSError(\"Permission denied\")\n            store_configuration_file('dummy_path', {'key': 'value'})\n            mocked_print.assert_called_with(\"Error securing and writing configuration to 'dummy_path': Permission denied\")\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 7, "task_id": "4d6e2c1d"}
{"test": "import unittest\nimport os\nimport stat\nfrom unittest.mock import patch, mock_open, MagicMock\n\nclass TestStoreApiKeys(unittest.TestCase):\n    \n    @patch('os.path.dirname')\n    @patch('os.path.exists')\n    @patch('os.stat')\n    @patch('os.getuid')\n    @patch('os.chmod')\n    @patch('builtins.open', new_callable=mock_open)\n    @patch('builtins.print')\n    def test_successful_write_new_file(self, mock_print, mock_open_file, mock_chmod, mock_getuid, mock_stat, mock_exists, mock_dirname):\n        # Test successful write to a new file\n        mock_dirname.return_value = '/secure'\n        mock_exists.side_effect = [True, False]  # Directory exists, file doesn't\n        mock_getuid.return_value = 1000\n        api_keys = {'service1': 'key1', 'service2': 'key2'}\n        file_path = '/secure/keys.txt'\n        \n        store_api_keys(file_path, api_keys)\n        \n        mock_open_file.assert_called_once_with(file_path, 'w')\n        file_handle = mock_open_file()\n        expected_calls = [call('service1:key1\\n'), call('service2:key2\\n')]\n        file_handle.write.assert_has_calls(expected_calls)\n        mock_chmod.assert_called_once_with(file_path, stat.S_IRUSR | stat.S_IWUSR)\n        mock_print.assert_called_once_with(f\"API keys securely stored in '{file_path}'\")\n    \n    @patch('os.path.dirname')\n    @patch('os.path.exists')\n    @patch('builtins.print')\n    def test_directory_not_exist(self, mock_print, mock_exists, mock_dirname):\n        # Test when directory doesn't exist\n        mock_dirname.return_value = '/nonexistent'\n        mock_exists.return_value = False\n        api_keys = {'service1': 'key1'}\n        file_path = '/nonexistent/keys.txt'\n        \n        store_api_keys(file_path, api_keys)\n        \n        mock_print.assert_called_once_with(f\"Directory '{mock_dirname.return_value}' does not exist.\")\n    \n    @patch('os.path.dirname')\n    @patch('os.path.exists')\n    @patch('os.stat')\n    @patch('os.getuid')\n    @patch('builtins.print')\n    def test_file_not_owned_by_user(self, mock_print, mock_getuid, mock_stat, mock_exists, mock_dirname):\n        # Test when file exists but not owned by current user\n        mock_dirname.return_value = '/secure'\n        mock_exists.side_effect = [True, True]  # Directory and file exist\n        mock_stat.return_value.st_uid = 1001\n        mock_getuid.return_value = 1000\n        api_keys = {'service1': 'key1'}\n        file_path = '/secure/keys.txt'\n        \n        store_api_keys(file_path, api_keys)\n        \n        mock_print.assert_called_once_with(f\"File '{file_path}' is not owned by the current user.\")\n    \n    @patch('os.path.dirname')\n    @patch('os.path.exists')\n    @patch('os.stat')\n    @patch('os.getuid')\n    @patch('builtins.print')\n    def test_file_has_group_others_permissions(self, mock_print, mock_getuid, mock_stat, mock_exists, mock_dirname):\n        # Test when file exists and has group/others permissions\n        mock_dirname.return_value = '/secure'\n        mock_exists.side_effect = [True, True]  # Directory and file exist\n        mock_stat.return_value.st_uid = 1000\n        mock_getuid.return_value = 1000\n        mock_stat.return_value.st_mode = 0o660  # Group has permissions\n        api_keys = {'service1': 'key1'}\n        file_path = '/secure/keys.txt'\n        \n        store_api_keys(file_path, api_keys)\n        \n        mock_print.assert_called_once_with(f\"File '{file_path}' has group or others permissions. Aborting write operation.\")\n    \n    @patch('os.path.dirname')\n    @patch('os.path.exists')\n    @patch('os.stat')\n    @patch('os.getuid')\n    @patch('builtins.open', new_callable=mock_open)\n    @patch('builtins.print')\n    def test_exception_during_write(self, mock_print, mock_open_file, mock_getuid, mock_stat, mock_exists, mock_dirname):\n        # Test exception during file write\n        mock_dirname.return_value = '/secure'\n        mock_exists.side_effect = [True, False]  # Directory exists, file doesn't\n        mock_getuid.return_value = 1000\n        mock_open_file.side_effect = IOError('Permission denied')\n        api_keys = {'service1': 'key1'}\n        file_path = '/secure/keys.txt'\n        \n        store_api_keys(file_path, api_keys)\n        \n        mock_print.assert_called_once_with(f\"Error securing and writing API keys to '{file_path}': Permission denied\")\n    \n    @patch('os.path.dirname')\n    @patch('os.path.exists')\n    @patch('os.stat')\n    @patch('os.getuid')\n    @patch('os.chmod')\n    @patch('builtins.open', new_callable=mock_open)\n    @patch('builtins.print')\n    def test_overwrite_existing_secure_file(self, mock_print, mock_open_file, mock_chmod, mock_getuid, mock_stat, mock_exists, mock_dirname):\n        # Test overwriting an existing secure file\n        mock_dirname.return_value = '/secure'\n        mock_exists.side_effect = [True, True]  # Directory and file exist\n        mock_stat.return_value.st_uid = 1000\n        mock_stat.return_value.st_mode = 0o600  # Secure permissions\n        mock_getuid.return_value = 1000\n        api_keys = {'service1': 'key1'}\n        file_path = '/secure/keys.txt'\n        \n        store_api_keys(file_path, api_keys)\n        \n        mock_open_file.assert_called_once_with(file_path, 'w')\n        file_handle = mock_open_file()\n        file_handle.write.assert_called_once_with('service1:key1\\n')\n        mock_chmod.assert_called_once_with(file_path, stat.S_IRUSR | stat.S_IWUSR)\n        mock_print.assert_called_once_with(f\"API keys securely stored in '{file_path}'\")\n    \n    @patch('os.path.dirname')\n    @patch('os.path.exists')\n    @patch('os.stat')\n    @patch('os.getuid')\n    @patch('builtins.open', new_callable=mock_open)\n    @patch('builtins.print')\n    def test_write_content_correctness(self, mock_print, mock_open_file, mock_getuid, mock_stat, mock_exists, mock_dirname):\n        # Test content written to file is correct\n        mock_dirname.return_value = '/secure'\n        mock_exists.side_effect = [True, False]  # Directory exists, file doesn't\n        mock_getuid.return_value = 1000\n        api_keys = {'github': 'gh_key', 'aws': 'aws_key'}\n        file_path = '/secure/keys.txt'\n        \n        store_api_keys(file_path, api_keys)\n        \n        file_handle = mock_open_file()\n        expected_calls = [call('github:gh_key\\n'), call('aws:aws_key\\n')]\n        file_handle.write.assert_has_calls(expected_calls)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 7, "task_id": "a75327c5"}
{"test": "import os\nimport stat\nimport tempfile\nimport unittest\nfrom unittest.mock import patch, MagicMock\n\nclass TestLogSensitiveData(unittest.TestCase):\n\n    def test_directory_not_exist(self):\n        # Test when directory does not exist\n        with tempfile.TemporaryDirectory() as tmpdir:\n            log_file = os.path.join(tmpdir, 'non_existent', 'log.txt')\n            sensitive_data = \"secret\"\n            \n            with patch('builtins.print') as mock_print:\n                log_sensitive_data(log_file, sensitive_data)\n                mock_print.assert_called_with(f\"Directory '{os.path.dirname(log_file)}' does not exist.\")\n            \n            self.assertFalse(os.path.exists(log_file))\n\n    def test_file_not_exist_happy_path(self):\n        # Test file creation with secure permissions\n        with tempfile.TemporaryDirectory() as tmpdir:\n            log_file = os.path.join(tmpdir, 'log.txt')\n            sensitive_data = \"secret\"\n            \n            with patch('builtins.print') as mock_print:\n                log_sensitive_data(log_file, sensitive_data)\n                mock_print.assert_called_with(f\"Sensitive data logged securely to '{log_file}'\")\n            \n            self.assertTrue(os.path.exists(log_file))\n            \n            with open(log_file, 'r') as f:\n                content = f.read()\n            self.assertEqual(content, f\"Sensitive Data: {sensitive_data}\\n\")\n            \n            file_mode = os.stat(log_file).st_mode\n            self.assertEqual(stat.S_IMODE(file_mode), stat.S_IRUSR | stat.S_IWUSR)\n\n    def test_file_exists_secure_append(self):\n        # Test appending to existing secure file\n        with tempfile.TemporaryDirectory() as tmpdir:\n            log_file = os.path.join(tmpdir, 'log.txt')\n            sensitive_data1 = \"first_secret\"\n            sensitive_data2 = \"second_secret\"\n            \n            with open(log_file, 'w') as f:\n                f.write(f\"Sensitive Data: {sensitive_data1}\\n\")\n            os.chmod(log_file, 0o600)\n            \n            with patch('builtins.print') as mock_print:\n                log_sensitive_data(log_file, sensitive_data2)\n                mock_print.assert_called_with(f\"Sensitive data logged securely to '{log_file}'\")\n            \n            with open(log_file, 'r') as f:\n                lines = f.readlines()\n            self.assertEqual(len(lines), 2)\n            self.assertEqual(lines[0], f\"Sensitive Data: {sensitive_data1}\\n\")\n            self.assertEqual(lines[1], f\"Sensitive Data: {sensitive_data2}\\n\")\n            \n            file_mode = os.stat(log_file).st_mode\n            self.assertEqual(stat.S_IMODE(file_mode), stat.S_IRUSR | stat.S_IWUSR)\n\n    def test_file_exists_wrong_ownership(self):\n        # Test existing file not owned by current user\n        log_file = \"/some/path/log.txt\"\n        sensitive_data = \"secret\"\n        current_uid = os.getuid()\n        other_uid = current_uid + 1\n        mock_stat = MagicMock()\n        mock_stat.st_uid = other_uid\n        mock_stat.st_mode = stat.S_IFREG | 0o600\n        \n        with patch('os.path.exists', return_value=True):\n            with patch('os.stat', return_value=mock_stat):\n                with patch('builtins.print') as mock_print:\n                    log_sensitive_data(log_file, sensitive_data)\n                    mock_print.assert_called_with(f\"Log file '{log_file}' is not owned by the current user.\")\n\n    def test_file_exists_wrong_permissions(self):\n        # Test existing file with insecure permissions\n        log_file = \"/some/path/log.txt\"\n        sensitive_data = \"secret\"\n        current_uid = os.getuid()\n        mock_stat = MagicMock()\n        mock_stat.st_uid = current_uid\n        mock_stat.st_mode = stat.S_IFREG | 0o644\n        \n        with patch('os.path.exists', return_value=True):\n            with patch('os.stat', return_value=mock_stat):\n                with patch('builtins.print') as mock_print:\n                    log_sensitive_data(log_file, sensitive_data)\n                    mock_print.assert_called_with(f\"Log file '{log_file}' has world-accessible permissions. Not logging the data.\")\n\n    def test_exception_during_write(self):\n        # Test exception during file writing\n        log_file = \"/some/path/log.txt\"\n        sensitive_data = \"secret\"\n        current_uid = os.getuid()\n        mock_stat = MagicMock()\n        mock_stat.st_uid = current_uid\n        mock_stat.st_mode = stat.S_IFREG | 0o600\n        \n        with patch('os.path.exists', return_value=True):\n            with patch('os.stat', return_value=mock_stat):\n                with patch('builtins.open', side_effect=Exception(\"Permission denied\")) as mock_open:\n                    with patch('builtins.print') as mock_print:\n                        log_sensitive_data(log_file, sensitive_data)\n                        mock_print.assert_called_with(f\"Error securing and writing sensitive data to log file '{log_file}': Permission denied\")\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 6, "task_id": "3157d616"}
{"test": "import os\nimport stat\nimport unittest\nimport tempfile\nimport shutil\nfrom unittest.mock import patch, MagicMock\n\nclass TestSetHttpCredentials(unittest.TestCase):\n    \n    def setUp(self):\n        # Create a temporary directory\n        self.test_dir = tempfile.mkdtemp()\n        self.config_path = os.path.join(self.test_dir, 'config.ini')\n    \n    def tearDown(self):\n        # Remove the temporary directory\n        shutil.rmtree(self.test_dir)\n    \n    def test_new_file(self):\n        # Test creating a new file: directory should be created, file should exist with correct content and permissions\n        set_http_credentials(self.config_path, 'user1', 'pass1')\n        self.assertTrue(os.path.exists(os.path.dirname(self.config_path)))\n        self.assertTrue(os.path.exists(self.config_path))\n        with open(self.config_path, 'r') as f:\n            content = f.read()\n        self.assertEqual(content, \"username=user1\\npassword=pass1\\n\")\n        mode = os.stat(self.config_path).st_mode\n        self.assertEqual(stat.S_IMODE(mode), stat.S_IRUSR | stat.S_IWUSR)\n    \n    def test_existing_file_correct_permissions(self):\n        # Test updating existing file with correct ownership and permissions\n        with open(self.config_path, 'w') as f:\n            f.write(\"original\")\n        os.chmod(self.config_path, stat.S_IRUSR | stat.S_IWUSR)\n        set_http_credentials(self.config_path, 'new_user', 'new_pass')\n        with open(self.config_path, 'r') as f:\n            content = f.read()\n        self.assertEqual(content, \"username=new_user\\npassword=new_pass\\n\")\n        mode = os.stat(self.config_path).st_mode\n        self.assertEqual(stat.S_IMODE(mode), stat.S_IRUSR | stat.S_IWUSR)\n    \n    def test_existing_file_wrong_ownership(self):\n        # Test existing file owned by another user: file should not be modified\n        with open(self.config_path, 'w') as f:\n            f.write(\"original\")\n        original_uid = os.getuid()\n        mock_stat = MagicMock()\n        mock_stat.st_uid = original_uid + 1\n        mock_stat.st_mode = stat.S_IRUSR | stat.S_IWUSR\n        with patch('os.stat', return_value=mock_stat), \\\n             patch('os.getuid', return_value=original_uid):\n            set_http_credentials(self.config_path, 'new_user', 'new_pass')\n        with open(self.config_path, 'r') as f:\n            content = f.read()\n        self.assertEqual(content, \"original\")\n    \n    def test_existing_file_improper_permissions(self):\n        # Test existing file with world-accessible permissions: file should not be modified\n        with open(self.config_path, 'w') as f:\n            f.write(\"original\")\n        os.chmod(self.config_path, 0o644)\n        set_http_credentials(self.config_path, 'new_user', 'new_pass')\n        with open(self.config_path, 'r') as f:\n            content = f.read()\n        self.assertEqual(content, \"original\")\n        mode = os.stat(self.config_path).st_mode\n        self.assertEqual(stat.S_IMODE(mode), 0o644)\n    \n    def test_directory_creation_failure(self):\n        # Test failure when creating the directory (uncaught exception)\n        with patch('os.makedirs', side_effect=PermissionError(\"No permission\")):\n            with self.assertRaises(PermissionError):\n                set_http_credentials(self.config_path, 'user', 'pass')\n    \n    def test_file_write_failure(self):\n        # Test failure during file writing: file should not be created and chmod not called\n        with patch('builtins.open', side_effect=IOError(\"Disk full\")) as mock_open, \\\n             patch('os.chmod') as mock_chmod:\n            set_http_credentials(self.config_path, 'user', 'pass')\n            mock_chmod.assert_not_called()\n        self.assertFalse(os.path.exists(self.config_path))\n    \n    def test_config_path_none(self):\n        # Test with None as config_path: should raise TypeError\n        with self.assertRaises(TypeError):\n            set_http_credentials(None, 'user', 'pass')\n    \n    def test_bad_username(self):\n        # Test username that raises exception during conversion to string: file created but empty\n        class BadStr:\n            def __str__(self):\n                raise ValueError(\"Bad conversion\")\n        set_http_credentials(self.config_path, BadStr(), 'good_pass')\n        self.assertTrue(os.path.exists(self.config_path))\n        self.assertEqual(os.path.getsize(self.config_path), 0)\n    \n    def test_bad_password(self):\n        # Test password that raises exception during conversion: file created with first line only\n        class BadStr:\n            def __str__(self):\n                raise ValueError(\"Bad conversion\")\n        set_http_credentials(self.config_path, 'good_user', BadStr())\n        self.assertTrue(os.path.exists(self.config_path))\n        with open(self.config_path, 'r') as f:\n            content = f.read()\n        self.assertEqual(content, \"username=good_user\\n\")\n    \n    def test_empty_credentials(self):\n        # Test with empty username and password\n        set_http_credentials(self.config_path, '', '')\n        with open(self.config_path, 'r') as f:\n            content = f.read()\n        self.assertEqual(content, \"username=\\npassword=\\n\")\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 10, "task_id": "a5541aaf"}
{"test": "import unittest\nimport os\nimport stat\nfrom unittest.mock import patch, MagicMock, mock_open\n\nclass TestSavePrivateKey(unittest.TestCase):\n\n    def test_directory_does_not_exist(self):\n        # Test when the directory does not exist\n        with patch('os.path.exists', return_value=False):\n            with patch('builtins.print') as mock_print:\n                save_private_key('/test/dir/key.pem', 'private_key')\n                mock_print.assert_called_once_with(\"Error: Directory '/test/dir' does not exist.\")\n\n    def test_file_owned_by_another_user(self):\n        # Test when file exists and is owned by another user\n        with patch('os.path.exists') as mock_exists:\n            mock_exists.side_effect = lambda path: True if path in ['/test/dir', '/test/dir/key.pem'] else False\n            stat_mock = MagicMock()\n            stat_mock.st_uid = 1000\n            with patch('os.stat', return_value=stat_mock):\n                with patch('os.getuid', return_value=0):\n                    with patch('builtins.print') as mock_print:\n                        save_private_key('/test/dir/key.pem', 'private_key')\n                        mock_print.assert_called_once_with(\"Error: Key file '/test/dir/key.pem' is owned by another user.\")\n\n    def test_file_has_group_or_others_permissions(self):\n        # Test when file exists with group/others permissions\n        with patch('os.path.exists') as mock_exists:\n            mock_exists.side_effect = lambda path: True if path in ['/test/dir', '/test/dir/key.pem'] else False\n            stat_mock = MagicMock()\n            stat_mock.st_uid = 0\n            stat_mock.st_mode = 0o644\n            with patch('os.stat', return_value=stat_mock):\n                with patch('os.getuid', return_value=0):\n                    with patch('builtins.print') as mock_print:\n                        save_private_key('/test/dir/key.pem', 'private_key')\n                        mock_print.assert_called_once_with(\"Error: Key file '/test/dir/key.pem' has group or others permissions.\")\n\n    def test_successful_save_new_file(self):\n        # Test successful save when file doesn't exist\n        with patch('os.path.exists') as mock_exists:\n            mock_exists.side_effect = lambda path: path == '/test/dir'\n            with patch('builtins.open', new_callable=mock_open) as mock_file:\n                with patch('os.chmod') as mock_chmod:\n                    with patch('builtins.print') as mock_print:\n                        save_private_key('/test/dir/key.pem', 'private_key_content')\n                        mock_file.assert_called_once_with('/test/dir/key.pem', 'w')\n                        mock_file().write.assert_called_once_with('private_key_content')\n                        mock_chmod.assert_called_once_with('/test/dir/key.pem', stat.S_IRUSR | stat.S_IWUSR)\n                        mock_print.assert_called_once_with(\"Private key securely saved to '/test/dir/key.pem'\")\n\n    def test_successful_overwrite_existing_file(self):\n        # Test successful overwrite of existing valid file\n        with patch('os.path.exists', return_value=True):\n            stat_mock = MagicMock()\n            stat_mock.st_uid = 0\n            stat_mock.st_mode = 0o600\n            with patch('os.stat', return_value=stat_mock):\n                with patch('os.getuid', return_value=0):\n                    with patch('builtins.open', new_callable=mock_open) as mock_file:\n                        with patch('os.chmod') as mock_chmod:\n                            with patch('builtins.print') as mock_print:\n                                save_private_key('/test/dir/key.pem', 'private_key_content')\n                                mock_file.assert_called_once_with('/test/dir/key.pem', 'w')\n                                mock_file().write.assert_called_once_with('private_key_content')\n                                mock_chmod.assert_called_once_with('/test/dir/key.pem', stat.S_IRUSR | stat.S_IWUSR)\n                                mock_print.assert_called_once_with(\"Private key securely saved to '/test/dir/key.pem'\")\n\n    def test_exception_during_write(self):\n        # Test exception handling during file write\n        with patch('os.path.exists', return_value=True):\n            with patch('builtins.open', side_effect=IOError('Disk full')) as mock_file:\n                with patch('builtins.print') as mock_print:\n                    save_private_key('/test/dir/key.pem', 'private_key_content')\n                    mock_print.assert_called_once_with(\"Error securing and saving the private key: Disk full\")\n", "num_test_cases": 6, "task_id": "376cdbb8"}
{"test": "import os\nimport stat\nimport tempfile\nimport unittest\nfrom unittest.mock import patch, MagicMock\n\nclass TestWriteConfiguration(unittest.TestCase):\n\n    def test_happy_path_new_file(self):\n        # Test writing to a new file: directory exists, file doesn't exist.\n        with tempfile.TemporaryDirectory() as tmpdir:\n            config_file = os.path.join(tmpdir, 'config.ini')\n            config_data = {'key1': 'value1', 'key2': 'value2'}\n            \n            with patch('builtins.print') as mock_print:\n                write_configuration(config_file, config_data)\n                \n                # Check file exists\n                self.assertTrue(os.path.exists(config_file))\n                \n                # Check content\n                with open(config_file, 'r') as f:\n                    content = f.read()\n                expected_content = 'key1=value1\\nkey2=value2\\n'\n                self.assertEqual(content, expected_content)\n                \n                # Check permissions\n                mode = os.stat(config_file).st_mode\n                self.assertEqual(stat.S_IMODE(mode), 0o600)\n                \n                # Check success message\n                mock_print.assert_called_with(f'Configuration securely written to \\'{config_file}\\'')\n\n    def test_directory_not_exists(self):\n        # Test with non-existent directory\n        with tempfile.TemporaryDirectory() as tmpdir:\n            non_existent_dir = os.path.join(tmpdir, 'non_existent')\n            config_file = os.path.join(non_existent_dir, 'config.ini')\n            config_data = {'key': 'value'}\n            \n            with patch('builtins.print') as mock_print:\n                write_configuration(config_file, config_data)\n                \n                # Check error message\n                mock_print.assert_called_with(f'Error: Directory \\'{non_existent_dir}\\' does not exist.')\n                # File should not be created\n                self.assertFalse(os.path.exists(config_file))\n\n    def test_existing_file_correct_owner_perms(self):\n        # Test overwriting existing file with correct owner and permissions\n        with tempfile.TemporaryDirectory() as tmpdir:\n            config_file = os.path.join(tmpdir, 'config.ini')\n            # Create existing file with correct permissions\n            with open(config_file, 'w') as f:\n                f.write('old_content')\n            os.chmod(config_file, 0o600)\n            \n            config_data = {'new_key': 'new_value'}\n            \n            with patch('builtins.print') as mock_print:\n                write_configuration(config_file, config_data)\n                \n                # Check content updated\n                with open(config_file, 'r') as f:\n                    content = f.read()\n                self.assertEqual(content, 'new_key=new_value\\n')\n                \n                # Permissions should remain 0o600\n                mode = os.stat(config_file).st_mode\n                self.assertEqual(stat.S_IMODE(mode), 0o600)\n                \n                # Check success message\n                mock_print.assert_called_with(f'Configuration securely written to \\'{config_file}\\'')\n\n    def test_existing_file_wrong_owner(self):\n        # Test existing file owned by different user\n        with tempfile.TemporaryDirectory() as tmpdir:\n            config_file = os.path.join(tmpdir, 'config.ini')\n            with open(config_file, 'w') as f:\n                f.write('original_content')\n            \n            # Mock os.stat to return wrong UID\n            current_uid = os.getuid()\n            fake_uid = current_uid + 1\n            mock_stat = MagicMock(st_uid=fake_uid, st_mode=0o600)\n            \n            with patch('os.stat', return_value=mock_stat), \\\n                 patch('builtins.print') as mock_print:\n                \n                write_configuration(config_file, {'key': 'value'})\n                \n                # Check error message\n                mock_print.assert_called_with(f'Error: Configuration file \\'{config_file}\\' is owned by another user.')\n                \n                # Content should remain unchanged\n                with open(config_file, 'r') as f:\n                    content = f.read()\n                self.assertEqual(content, 'original_content')\n\n    def test_existing_file_wrong_permissions(self):\n        # Test existing file with group/other permissions\n        with tempfile.TemporaryDirectory() as tmpdir:\n            config_file = os.path.join(tmpdir, 'config.ini')\n            with open(config_file, 'w') as f:\n                f.write('original_content')\n            # Set permissions to 0o606 (group/other readable)\n            os.chmod(config_file, 0o606)\n            \n            with patch('builtins.print') as mock_print:\n                write_configuration(config_file, {'key': 'value'})\n                \n                # Check error message\n                mock_print.assert_called_with(f'Error: Configuration file \\'{config_file}\\' is accessible by group or others.')\n                \n                # Content should remain unchanged\n                with open(config_file, 'r') as f:\n                    content = f.read()\n                self.assertEqual(content, 'original_content')\n\n    def test_write_exception_handling(self):\n        # Test exception during file writing\n        with tempfile.TemporaryDirectory() as tmpdir:\n            config_file = os.path.join(tmpdir, 'config.ini')\n            config_data = {'key': 'value'}\n            \n            # Mock open to raise IOError\n            with patch('builtins.open', side_effect=IOError('Mocked IO error')), \\\n                 patch('builtins.print') as mock_print:\n                \n                write_configuration(config_file, config_data)\n                \n                # Check error message\n                mock_print.assert_called_with(f'Error securing and writing configuration to \\'{config_file}\\': Mocked IO error')\n\n    def test_non_string_config_values(self):\n        # Test config data with non-string values\n        with tempfile.TemporaryDirectory() as tmpdir:\n            config_file = os.path.join(tmpdir, 'config.ini')\n            config_data = {\n                'int': 42,\n                'float': 3.14,\n                'bool': True,\n                'list': [1, 2, 3]\n            }\n            \n            write_configuration(config_file, config_data)\n            \n            # Check content\n            with open(config_file, 'r') as f:\n                content = f.read()\n            \n            # Split lines and sort since dictionary order is arbitrary\n            lines = sorted(content.splitlines())\n            expected_lines = sorted([\n                'int=42',\n                'float=3.14',\n                'bool=True',\n                'list=[1, 2, 3]'\n            ])\n            self.assertEqual(lines, expected_lines)\n            \n            # Check permissions\n            mode = os.stat(config_file).st_mode\n            self.assertEqual(stat.S_IMODE(mode), 0o600)\n\n    def test_empty_config_data(self):\n        # Test with empty config dictionary\n        with tempfile.TemporaryDirectory() as tmpdir:\n            config_file = os.path.join(tmpdir, 'config.ini')\n            config_data = {}\n            \n            with patch('builtins.print') as mock_print:\n                write_configuration(config_file, config_data)\n                \n                # Check file exists and is empty\n                self.assertTrue(os.path.exists(config_file))\n                with open(config_file, 'r') as f:\n                    content = f.read()\n                self.assertEqual(content, '')\n                \n                # Check permissions\n                mode = os.stat(config_file).st_mode\n                self.assertEqual(stat.S_IMODE(mode), 0o600)\n                \n                # Check success message\n                mock_print.assert_called_with(f'Configuration securely written to \\'{config_file}\\'')\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 8, "task_id": "8fa67ebe"}
{"test": "import unittest\nfrom unittest.mock import patch, MagicMock, mock_open\nimport os\n\nclass TestReadSecretFile(unittest.TestCase):\n\n    @patch('os.path.exists', return_value=False)\n    def test_case_1(self, mock_exists):\n        \"\"\"Test when the secret file does not exist.\"\"\"\n        result = read_secret_file('dummy_path')\n        self.assertIsNone(result)\n\n    @patch('os.path.exists', return_value=True)\n    @patch('os.stat')\n    @patch('os.getuid', return_value=1000)\n    @patch('builtins.open', new_callable=mock_open, read_data='test content')\n    def test_case_2(self, mock_open_file, mock_getuid, mock_stat, mock_exists):\n        \"\"\"Test happy path: file exists, owned by current user, permissions 600.\"\"\"\n        mock_stat_result = MagicMock()\n        mock_stat_result.st_uid = 1000\n        mock_stat_result.st_mode = 0o600\n        mock_stat.return_value = mock_stat_result\n        \n        result = read_secret_file('dummy_path')\n        self.assertEqual(result, 'test content')\n        mock_open_file.assert_called_once_with('dummy_path', 'r')\n\n    @patch('os.path.exists', return_value=True)\n    @patch('os.stat')\n    @patch('os.getuid', return_value=1000)\n    @patch('builtins.open', new_callable=mock_open, read_data='test content')\n    def test_case_3(self, mock_open_file, mock_getuid, mock_stat, mock_exists):\n        \"\"\"Test file exists with permissions 777 (too open).\"\"\"\n        mock_stat_result = MagicMock()\n        mock_stat_result.st_uid = 1000\n        mock_stat_result.st_mode = 0o777\n        mock_stat.return_value = mock_stat_result\n        \n        result = read_secret_file('dummy_path')\n        self.assertIsNone(result)\n\n    @patch('os.path.exists', return_value=True)\n    @patch('os.stat')\n    @patch('os.getuid', return_value=1000)\n    @patch('builtins.open', new_callable=mock_open, read_data='test content')\n    def test_case_4(self, mock_open_file, mock_getuid, mock_stat, mock_exists):\n        \"\"\"Test file exists with permissions 700 (acceptable).\"\"\"\n        mock_stat_result = MagicMock()\n        mock_stat_result.st_uid = 1000\n        mock_stat_result.st_mode = 0o700\n        mock_stat.return_value = mock_stat_result\n        \n        result = read_secret_file('dummy_path')\n        self.assertEqual(result, 'test content')\n\n    @patch('os.path.exists', return_value=True)\n    @patch('os.stat')\n    @patch('os.getuid', return_value=1000)\n    @patch('builtins.open', new_callable=mock_open, read_data='test content')\n    def test_case_5(self, mock_open_file, mock_getuid, mock_stat, mock_exists):\n        \"\"\"Test file exists with permissions 602 (others have write).\"\"\"\n        mock_stat_result = MagicMock()\n        mock_stat_result.st_uid = 1000\n        mock_stat_result.st_mode = 0o602\n        mock_stat.return_value = mock_stat_result\n        \n        result = read_secret_file('dummy_path')\n        self.assertIsNone(result)\n\n    @patch('os.path.exists', return_value=True)\n    @patch('os.stat')\n    @patch('os.getuid', return_value=1000)\n    @patch('builtins.open', new_callable=mock_open, read_data='test content')\n    def test_case_6(self, mock_open_file, mock_getuid, mock_stat, mock_exists):\n        \"\"\"Test file exists but owned by another user (not current user or root).\"\"\"\n        mock_stat_result = MagicMock()\n        mock_stat_result.st_uid = 2000  # Not current user (1000) and not root (0)\n        mock_stat_result.st_mode = 0o600\n        mock_stat.return_value = mock_stat_result\n        \n        result = read_secret_file('dummy_path')\n        self.assertIsNone(result)\n\n    @patch('os.path.exists', return_value=True)\n    @patch('os.stat')\n    @patch('os.getuid', return_value=1000)  # Current user is non-root\n    @patch('builtins.open', new_callable=mock_open, read_data='test content')\n    def test_case_7(self, mock_open_file, mock_getuid, mock_stat, mock_exists):\n        \"\"\"Test file exists, owned by root, with permissions 600.\"\"\"\n        mock_stat_result = MagicMock()\n        mock_stat_result.st_uid = 0  # Root\n        mock_stat_result.st_mode = 0o600\n        mock_stat.return_value = mock_stat_result\n        \n        result = read_secret_file('dummy_path')\n        self.assertEqual(result, 'test content')\n\n    @patch('os.path.exists', return_value=True)\n    @patch('os.stat')\n    @patch('os.getuid', return_value=1000)\n    @patch('builtins.open')\n    def test_case_8(self, mock_open, mock_getuid, mock_stat, mock_exists):\n        \"\"\"Test file passes security checks but error occurs during reading.\"\"\"\n        mock_stat_result = MagicMock()\n        mock_stat_result.st_uid = 1000\n        mock_stat_result.st_mode = 0o600\n        mock_stat.return_value = mock_stat_result\n        \n        mock_open.side_effect = IOError(\"File read error\")\n        \n        result = read_secret_file('dummy_path')\n        self.assertIsNone(result)\n\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 8, "task_id": "0d45e845"}
{"test": "import unittest\nfrom queue import Queue\n\nclass TestAddTaskToQueue(unittest.TestCase):\n    def setUp(self):\n        global task_queue\n        task_queue = Queue()\n\n    def test_basic_addition(self):\n        \"\"\"Test adding a task with valid parameters.\"\"\"\n        result = add_task_to_queue(\"task1\", {\"param\": \"value\"})\n        self.assertTrue(result)\n        self.assertEqual(task_queue.qsize(), 1)\n        item = task_queue.get()\n        self.assertEqual(item, {\"id\": \"task1\", \"data\": {\"param\": \"value\"}})\n\n    def test_queue_full(self):\n        \"\"\"Test when the queue is full (1000 tasks).\"\"\"\n        for i in range(1000):\n            task_queue.put({\"id\": str(i), \"data\": {}})\n        result = add_task_to_queue(\"task1001\", {})\n        self.assertFalse(result)\n\n    def test_data_size_too_large(self):\n        \"\"\"Test when task data exceeds size limit (10000 characters).\"\"\"\n        large_data = {\"key\": \"x\" * 10000}\n        result = add_task_to_queue(\"large_task\", large_data)\n        self.assertFalse(result)\n        self.assertEqual(task_queue.qsize(), 0)\n\n    def test_queue_full_and_data_too_large(self):\n        \"\"\"Test both queue full and data too large conditions.\"\"\"\n        for i in range(1000):\n            task_queue.put({\"id\": str(i), \"data\": {}})\n        large_data = {\"key\": \"x\" * 10000}\n        result = add_task_to_queue(\"task1001\", large_data)\n        self.assertFalse(result)\n\n    def test_empty_task_data(self):\n        \"\"\"Test adding task with empty dictionary.\"\"\"\n        result = add_task_to_queue(\"empty_data\", {})\n        self.assertTrue(result)\n        item = task_queue.get()\n        self.assertEqual(item, {\"id\": \"empty_data\", \"data\": {}})\n\n    def test_empty_task_id(self):\n        \"\"\"Test adding task with an empty string ID.\"\"\"\n        result = add_task_to_queue(\"\", {\"key\": \"value\"})\n        self.assertTrue(result)\n        item = task_queue.get()\n        self.assertEqual(item, {\"id\": \"\", \"data\": {\"key\": \"value\"}})\n\n    def test_queue_size_boundary(self):\n        \"\"\"Test adding task when queue has 999 tasks (boundary case).\"\"\"\n        for i in range(999):\n            task_queue.put({\"id\": str(i), \"data\": {}})\n        result = add_task_to_queue(\"task999\", {})\n        self.assertTrue(result)\n        self.assertEqual(task_queue.qsize(), 1000)\n\n    def test_data_size_boundary_valid(self):\n        \"\"\"Test data size at boundary (9999 characters).\"\"\"\n        base_dict = {'a': ''}\n        base_len = len(str(base_dict))\n        value_str = 'x' * (9999 - base_len)\n        task_data = {'a': value_str}\n        self.assertEqual(len(str(task_data)), 9999)\n        result = add_task_to_queue(\"boundary_ok\", task_data)\n        self.assertTrue(result)\n\n    def test_data_size_boundary_invalid(self):\n        \"\"\"Test data size at boundary (10000 characters).\"\"\"\n        base_dict = {'a': ''}\n        base_len = len(str(base_dict))\n        value_str = 'x' * (10000 - base_len)\n        task_data = {'a': value_str}\n        self.assertEqual(len(str(task_data)), 10000)\n        result = add_task_to_queue(\"boundary_fail\", task_data)\n        self.assertFalse(result)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 9, "task_id": "f7baa15d"}
{"test": "import unittest\n\nclass TestCases(unittest.TestCase):\n    def setUp(self):\n        global user_cache\n        user_cache = {}\n    \n    def test_basic_caching(self):\n        # Test caching a new user with valid data\n        user_id = 'test_user'\n        user_data = {'name': 'John', 'age': 30}\n        result = cache_user_data(user_id, user_data)\n        self.assertTrue(result)\n        self.assertEqual(user_cache.get(user_id), user_data)\n    \n    def test_cache_full(self):\n        # Test when cache has 10000 entries (full)\n        for i in range(10000):\n            user_cache[str(i)] = {'data': 'sample'}\n        result = cache_user_data('new_user', {'key': 'value'})\n        self.assertFalse(result)\n    \n    def test_data_too_large(self):\n        # Test user_data with exactly 1000 items (too large)\n        user_data = {i: i for i in range(1000)}\n        result = cache_user_data('user1', user_data)\n        self.assertFalse(result)\n    \n    def test_data_just_below_limit(self):\n        # Test user_data with 999 items (within limit)\n        user_data = {i: i for i in range(999)}\n        result = cache_user_data('user1', user_data)\n        self.assertTrue(result)\n        self.assertEqual(user_cache.get('user1'), user_data)\n    \n    def test_cache_almost_full(self):\n        # Test cache with 9999 entries (space available)\n        for i in range(9999):\n            user_cache[str(i)] = {'data': 'sample'}\n        user_data = {'key': 'value'}\n        result = cache_user_data('user_9999', user_data)\n        self.assertTrue(result)\n        self.assertEqual(user_cache.get('user_9999'), user_data)\n    \n    def test_cache_exactly_full(self):\n        # Test cache with 10000 entries (full) for new user\n        for i in range(10000):\n            user_cache[str(i)] = {'data': 'sample'}\n        user_data = {'key': 'value'}\n        result = cache_user_data('user_10000', user_data)\n        self.assertFalse(result)\n        self.assertEqual(len(user_cache), 10000)\n    \n    def test_update_existing_user_valid(self):\n        # Test updating existing user with valid data\n        user_id = 'user1'\n        initial_data = {'name': 'John'}\n        updated_data = {'name': 'Jane'}\n        cache_user_data(user_id, initial_data)\n        result = cache_user_data(user_id, updated_data)\n        self.assertTrue(result)\n        self.assertEqual(user_cache.get(user_id), updated_data)\n    \n    def test_update_existing_user_too_large(self):\n        # Test updating existing user with too large data\n        user_id = 'user1'\n        initial_data = {'name': 'John'}\n        updated_data = {i: i for i in range(1000)}\n        cache_user_data(user_id, initial_data)\n        result = cache_user_data(user_id, updated_data)\n        self.assertFalse(result)\n        self.assertEqual(user_cache.get(user_id), initial_data)\n    \n    def test_user_id_none(self):\n        # Test user_id as None (valid if allowed)\n        user_id = None\n        user_data = {'key': 'value'}\n        result = cache_user_data(user_id, user_data)\n        self.assertTrue(result)\n        self.assertEqual(user_cache.get(user_id), user_data)\n    \n    def test_user_id_empty_string(self):\n        # Test user_id as empty string\n        user_id = ''\n        user_data = {'key': 'value'}\n        result = cache_user_data(user_id, user_data)\n        self.assertTrue(result)\n        self.assertEqual(user_cache.get(user_id), user_data)\n    \n    def test_user_data_none(self):\n        # Test user_data as None (should raise TypeError)\n        with self.assertRaises(TypeError):\n            cache_user_data('user1', None)\n    \n    def test_user_data_integer(self):\n        # Test user_data as integer (should raise TypeError)\n        with self.assertRaises(TypeError):\n            cache_user_data('user1', 123)\n    \n    def test_user_data_list(self):\n        # Test user_data as list (with __len__ within limit)\n        user_id = 'user_list'\n        user_data = [1, 2, 3]\n        result = cache_user_data(user_id, user_data)\n        self.assertTrue(result)\n        self.assertEqual(user_cache.get(user_id), user_data)\n    \n    if __name__ == '__main__':\n        unittest.main()", "num_test_cases": 13, "task_id": "4350f194"}
{"test": "import unittest\nfrom solution import process_user_input\n\nclass TestCases(unittest.TestCase):\n    def test_basic_input(self):\n        # Test typical input with multiple words\n        input_str = \"Hello world\"\n        expected = ['Hello', 'world']\n        result = process_user_input(input_str)\n        self.assertEqual(result, expected)\n        self.assertIsInstance(result, list)\n\n    def test_with_punctuation(self):\n        # Test input with punctuation and non-word characters\n        input_str = \"Hello, world! How are you?\"\n        expected = ['Hello', 'world', 'How', 'are', 'you']\n        result = process_user_input(input_str)\n        self.assertEqual(result, expected)\n\n    def test_empty_input(self):\n        # Test empty string input\n        input_str = \"\"\n        expected = []\n        result = process_user_input(input_str)\n        self.assertEqual(result, expected)\n\n    def test_exactly_1000_words(self):\n        # Test input with exactly 1000 words (limit boundary)\n        input_str = \"a \" * 1000\n        words = process_user_input(input_str)\n        self.assertEqual(len(words), 1000)\n\n    def test_1001_words(self):\n        # Test input exceeding word limit (1001 words)\n        input_str = \"a \" * 1001\n        with self.assertRaises(ValueError):\n            process_user_input(input_str)\n\n    def test_non_ascii_and_special_chars(self):\n        # Test input with non-ASCII characters, underscores, and numbers\n        input_str = \"caf\\u00e9 r\\u00e9sum\\u00e9 hello_world 123\"\n        expected = ['caf\\u00e9', 'r\\u00e9sum\\u00e9', 'hello_world', '123']\n        result = process_user_input(input_str)\n        self.assertEqual(result, expected)\n\n    def test_none_input(self):\n        # Test None input (invalid type)\n        with self.assertRaises(TypeError):\n            process_user_input(None)\n\n    def test_integer_input(self):\n        # Test integer input (invalid type)\n        with self.assertRaises(TypeError):\n            process_user_input(123)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 8, "task_id": "5a87427a"}
{"test": "import unittest\n\nclass TestCacheProfileData(unittest.TestCase):\n    \n    def setUp(self):\n        global user_cache\n        user_cache = {}\n    \n    def test_case_1(self):\n        # Test adding new profile within limits (happy path)\n        result = cache_profile_data('id1', {'name': 'Alice'})\n        self.assertTrue(result)\n        self.assertEqual(user_cache['id1'], {'name': 'Alice'})\n    \n    def test_case_2(self):\n        # Test adding new profile when cache is full (10000 entries)\n        global user_cache\n        user_cache = {str(i): {} for i in range(10000)}\n        result = cache_profile_data('id10000', {'name': 'Bob'})\n        self.assertFalse(result)\n        self.assertNotIn('id10000', user_cache)\n    \n    def test_case_3(self):\n        # Test adding new profile with profile_data size at limit (1000 items)\n        data = {str(i): i for i in range(1000)}\n        result = cache_profile_data('id1', data)\n        self.assertFalse(result)\n        self.assertNotIn('id1', user_cache)\n    \n    def test_case_4(self):\n        # Test adding new profile with profile_data just below size limit (999 items)\n        data = {str(i): i for i in range(999)}\n        result = cache_profile_data('id1', data)\n        self.assertTrue(result)\n        self.assertEqual(user_cache['id1'], data)\n    \n    def test_case_5(self):\n        # Test adding new profile when cache has 9999 entries (boundary condition)\n        global user_cache\n        user_cache = {str(i): {} for i in range(9999)}\n        result = cache_profile_data('id9999', {'name': 'Charlie'})\n        self.assertTrue(result)\n        self.assertEqual(user_cache['id9999'], {'name': 'Charlie'})\n        self.assertEqual(len(user_cache), 10000)\n    \n    def test_case_6(self):\n        # Test updating existing profile within limits\n        cache_profile_data('id1', {'name': 'Alice'})\n        result = cache_profile_data('id1', {'name': 'Alice Smith'})\n        self.assertTrue(result)\n        self.assertEqual(user_cache['id1'], {'name': 'Alice Smith'})\n    \n    def test_case_7(self):\n        # Test updating existing profile when cache is full\n        global user_cache\n        user_cache = {str(i): {} for i in range(10000)}\n        key = '0'\n        result = cache_profile_data(key, {'name': 'Bob'})\n        self.assertFalse(result)\n        self.assertEqual(user_cache[key], {})\n    \n    def test_case_8(self):\n        # Test updating existing profile with profile_data size at limit (1000 items)\n        cache_profile_data('id1', {'name': 'Alice'})\n        data = {str(i): i for i in range(1000)}\n        result = cache_profile_data('id1', data)\n        self.assertFalse(result)\n        self.assertEqual(user_cache['id1'], {'name': 'Alice'})\n    \n    def test_case_9(self):\n        # Test updating existing profile with profile_data just below size limit (999 items)\n        cache_profile_data('id1', {'name': 'Alice'})\n        data = {str(i): i for i in range(999)}\n        result = cache_profile_data('id1', data)\n        self.assertTrue(result)\n        self.assertEqual(user_cache['id1'], data)\n    \n    def test_case_10(self):\n        # Test adding new profile with empty profile_data\n        result = cache_profile_data('id1', {})\n        self.assertTrue(result)\n        self.assertEqual(user_cache['id1'], {})", "num_test_cases": 10, "task_id": "72795c06"}
{"test": "import unittest\n\nclass TestChatRoom(unittest.TestCase):\n    def setUp(self):\n        global chat_rooms\n        chat_rooms = {}\n        \n    def test_new_room_success(self):\n        # Test adding message to new room (happy path)\n        result = log_chat_message(\"room1\", \"user1\", \"Hello\")\n        self.assertTrue(result)\n        self.assertIn(\"room1\", chat_rooms)\n        self.assertEqual(len(chat_rooms[\"room1\"]), 1)\n        self.assertEqual(chat_rooms[\"room1\"][0][\"user_id\"], \"user1\")\n        self.assertEqual(chat_rooms[\"room1\"][0][\"message\"], \"Hello\")\n        \n    def test_existing_room_success(self):\n        # Test adding message to existing room (happy path)\n        log_chat_message(\"room2\", \"user1\", \"Msg1\")\n        result = log_chat_message(\"room2\", \"user2\", \"Msg2\")\n        self.assertTrue(result)\n        self.assertEqual(len(chat_rooms[\"room2\"]), 2)\n        self.assertEqual(chat_rooms[\"room2\"][1][\"user_id\"], \"user2\")\n        self.assertEqual(chat_rooms[\"room2\"][1][\"message\"], \"Msg2\")\n        \n    def test_message_length_exactly_500(self):\n        # Test message with exactly 500 characters (edge case)\n        long_msg = 'a' * 500\n        result = log_chat_message(\"room3\", \"user1\", long_msg)\n        self.assertTrue(result)\n        self.assertEqual(chat_rooms[\"room3\"][0][\"message\"], long_msg)\n        \n    def test_message_length_501(self):\n        # Test message with 501 characters (exceeds limit)\n        long_msg = 'a' * 501\n        result = log_chat_message(\"room4\", \"user1\", long_msg)\n        self.assertFalse(result)\n        self.assertIn(\"room4\", chat_rooms)\n        self.assertEqual(len(chat_rooms[\"room4\"]), 0)\n        \n    def test_room_message_count_1000th(self):\n        # Test adding 1000th message to room (edge case)\n        room = \"room5\"\n        chat_rooms[room] = [{\"user_id\": \"u1\", \"message\": \"msg\"}] * 999\n        result = log_chat_message(room, \"user1\", \"Message 1000\")\n        self.assertTrue(result)\n        self.assertEqual(len(chat_rooms[room]), 1000)\n        self.assertEqual(chat_rooms[room][999][\"user_id\"], \"user1\")\n        self.assertEqual(chat_rooms[room][999][\"message\"], \"Message 1000\")\n        \n    def test_room_message_count_1001st(self):\n        # Test adding 1001st message to room (exceeds limit)\n        room = \"room6\"\n        chat_rooms[room] = [{\"user_id\": \"u1\", \"message\": \"msg\"}] * 1000\n        result = log_chat_message(room, \"user1\", \"Message 1001\")\n        self.assertFalse(result)\n        self.assertEqual(len(chat_rooms[room]), 1000)\n        \n    def test_empty_strings(self):\n        # Test empty room, author, and message (edge case)\n        result = log_chat_message(\"\", \"\", \"\")\n        self.assertTrue(result)\n        self.assertIn(\"\", chat_rooms)\n        self.assertEqual(len(chat_rooms[\"\"]), 1)\n        self.assertEqual(chat_rooms[\"\"][0][\"user_id\"], \"\")\n        self.assertEqual(chat_rooms[\"\"][0][\"message\"], \"\")\n        \n    def test_message_length_zero(self):\n        # Test zero-length message (edge case)\n        result = log_chat_message(\"room7\", \"user1\", \"\")\n        self.assertTrue(result)\n        self.assertEqual(chat_rooms[\"room7\"][0][\"message\"], \"\")\n        \n    def test_very_large_room_id(self):\n        # Test very large room ID (robustness)\n        large_room = \"r\" * 10000\n        result = log_chat_message(large_room, \"user1\", \"Test\")\n        self.assertTrue(result)\n        self.assertIn(large_room, chat_rooms)\n        self.assertEqual(len(chat_rooms[large_room]), 1)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 9, "task_id": "14c9b529"}
{"test": "import unittest\nimport chat_service\nfrom chat_service import append_message_to_chat\n\nclass TestAppendMessageToChat(unittest.TestCase):\n\n    def setUp(self):\n        # Save the original chat_rooms in the module\n        self.original_chat_rooms = getattr(chat_service, 'chat_rooms', None)\n        # Reset to an empty dict\n        chat_service.chat_rooms = {}\n\n    def tearDown(self):\n        # Restore the original state\n        if self.original_chat_rooms is not None:\n            chat_service.chat_rooms = self.original_chat_rooms\n        else:\n            try:\n                del chat_service.chat_rooms\n            except AttributeError:\n                pass\n\n    def test_new_room_valid_message(self):\n        # Test appending a valid message to a new room\n        room = \"room1\"\n        user = \"user1\"\n        msg = \"Hello\"\n        result = append_message_to_chat(room, user, msg)\n        self.assertTrue(result)\n        self.assertIn(room, chat_service.chat_rooms)\n        room_msgs = chat_service.chat_rooms[room]\n        self.assertEqual(len(room_msgs), 1)\n        self.assertEqual(room_msgs[0]['user_id'], user)\n        self.assertEqual(room_msgs[0]['message'], msg)\n\n    def test_existing_room_valid_message(self):\n        # Test appending a valid message to an existing room\n        room = \"room1\"\n        user1 = \"user1\"\n        user2 = \"user2\"\n        msg1 = \"Message 1\"\n        msg2 = \"Message 2\"\n        chat_service.chat_rooms[room] = [{\"user_id\": user1, \"message\": msg1}]\n        result = append_message_to_chat(room, user2, msg2)\n        self.assertTrue(result)\n        room_msgs = chat_service.chat_rooms[room]\n        self.assertEqual(len(room_msgs), 2)\n        self.assertEqual(room_msgs[1]['user_id'], user2)\n        self.assertEqual(room_msgs[1]['message'], msg2)\n\n    def test_message_too_long(self):\n        # Test message exceeding 500 character limit\n        msg = 'A' * 501\n        result = append_message_to_chat(\"room1\", \"user1\", msg)\n        self.assertFalse(result)\n        self.assertIn(\"room1\", chat_service.chat_rooms)\n        self.assertEqual(len(chat_service.chat_rooms[\"room1\"]), 0)\n\n    def test_room_full(self):\n        # Test appending when room already has 1000 messages\n        room = \"full_room\"\n        chat_service.chat_rooms[room] = [{\"user_id\": \"u\", \"message\": \"msg\"}] * 1000\n        result = append_message_to_chat(room, \"user1\", \"New message\")\n        self.assertFalse(result)\n        self.assertEqual(len(chat_service.chat_rooms[room]), 1000)\n\n    def test_message_length_zero(self):\n        # Test empty message (within length limit)\n        result = append_message_to_chat(\"room1\", \"user1\", \"\")\n        self.assertTrue(result)\n        room_msgs = chat_service.chat_rooms[\"room1\"]\n        self.assertEqual(len(room_msgs), 1)\n        self.assertEqual(room_msgs[0]['message'], \"\")\n\n    def test_message_length_500(self):\n        # Test message at maximum allowed length (500 characters)\n        msg = 'B' * 500\n        result = append_message_to_chat(\"room1\", \"user1\", msg)\n        self.assertTrue(result)\n        room_msgs = chat_service.chat_rooms[\"room1\"]\n        self.assertEqual(room_msgs[0]['message'], msg)\n\n    def test_room_999_messages(self):\n        # Test appending the 1000th message to a room (allowed)\n        room = \"room999\"\n        chat_service.chat_rooms[room] = [{\"user_id\": \"u\", \"message\": \"msg\"}] * 999\n        result = append_message_to_chat(room, \"user1\", \"Message 1000\")\n        self.assertTrue(result)\n        self.assertEqual(len(chat_service.chat_rooms[room]), 1000)\n\n    def test_room_code_empty_string(self):\n        # Test with empty room code string\n        result = append_message_to_chat(\"\", \"user1\", \"Hello\")\n        self.assertTrue(result)\n        self.assertIn(\"\", chat_service.chat_rooms)\n        room_msgs = chat_service.chat_rooms[\"\"]\n        self.assertEqual(len(room_msgs), 1)\n        self.assertEqual(room_msgs[0]['message'], \"Hello\")\n\n    def test_user_identifier_empty_string(self):\n        # Test with empty user identifier\n        result = append_message_to_chat(\"room1\", \"\", \"Test message\")\n        self.assertTrue(result)\n        room_msgs = chat_service.chat_rooms[\"room1\"]\n        self.assertEqual(room_msgs[0]['user_id'], \"\")\n\n    def test_non_ascii_message_valid(self):\n        # Test non-ASCII message within length limit\n        msg = 'あ' * 500  # 500 Hiragana 'A'\n        result = append_message_to_chat(\"room1\", \"user1\", msg)\n        self.assertTrue(result)\n        room_msgs = chat_service.chat_rooms[\"room1\"]\n        self.assertEqual(room_msgs[0]['message'], msg)\n\n    def test_non_ascii_message_too_long(self):\n        # Test non-ASCII message exceeding length limit\n        msg = 'あ' * 501\n        result = append_message_to_chat(\"room1\", \"user1\", msg)\n        self.assertFalse(result)\n        self.assertIn(\"room1\", chat_service.chat_rooms)\n        self.assertEqual(len(chat_service.chat_rooms[\"room1\"]), 0)\n\n    def test_invalid_room_code_type(self):\n        # Test TypeError when room_code is unhashable (list)\n        with self.assertRaises(TypeError):\n            append_message_to_chat([\"invalid\"], \"user1\", \"message\")\n\n    def test_invalid_message_type(self):\n        # Test TypeError when msg_text is not a string (int)\n        with self.assertRaises(TypeError):\n            append_message_to_chat(\"room1\", \"user1\", 12345)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 13, "task_id": "7f19292c"}
{"test": "import unittest\n\n# Global variable to simulate the chat_rooms dictionary used by the function\nchat_rooms = {}\n\nclass TestInsertChatMessage(unittest.TestCase):\n    def setUp(self):\n        \"\"\"Reset the global chat_rooms dictionary before each test.\"\"\"\n        global chat_rooms\n        chat_rooms = {}\n\n    def test_new_chat_room_message(self):\n        \"\"\"Test adding a message to a new chat room (should create room and return True).\"\"\"\n        result = insert_chat_message(\"room1\", \"user1\", \"Hello, World!\")\n        self.assertTrue(result)\n        self.assertIn(\"room1\", chat_rooms)\n        self.assertEqual(len(chat_rooms[\"room1\"]), 1)\n        self.assertEqual(chat_rooms[\"room1\"][0][\"user_id\"], \"user1\")\n        self.assertEqual(chat_rooms[\"room1\"][0][\"message\"], \"Hello, World!\")\n\n    def test_existing_chat_room_message(self):\n        \"\"\"Test adding a message to an existing chat room (should append and return True).\"\"\"\n        insert_chat_message(\"room1\", \"user1\", \"First message\")\n        result = insert_chat_message(\"room1\", \"user2\", \"Second message\")\n        self.assertTrue(result)\n        self.assertEqual(len(chat_rooms[\"room1\"]), 2)\n        self.assertEqual(chat_rooms[\"room1\"][1][\"user_id\"], \"user2\")\n        self.assertEqual(chat_rooms[\"room1\"][1][\"message\"], \"Second message\")\n\n    def test_message_at_max_length(self):\n        \"\"\"Test adding a message of exactly 500 characters (should succeed).\"\"\"\n        message = \"A\" * 500\n        result = insert_chat_message(\"room1\", \"user1\", message)\n        self.assertTrue(result)\n        self.assertEqual(chat_rooms[\"room1\"][0][\"message\"], message)\n\n    def test_message_exceeds_max_length(self):\n        \"\"\"Test adding a message of 501 characters (should be rejected).\"\"\"\n        message = \"A\" * 501\n        result = insert_chat_message(\"room1\", \"user1\", message)\n        self.assertFalse(result)\n        self.assertIn(\"room1\", chat_rooms)  # Room should be created\n        self.assertEqual(len(chat_rooms[\"room1\"]), 0)  # But no message added\n\n    def test_room_message_limit_reached(self):\n        \"\"\"Test adding a message when room has 1000 messages (should be rejected).\"\"\"\n        room_id = \"room_limit\"\n        for i in range(1000):\n            insert_chat_message(room_id, f\"user{i}\", f\"Message {i}\")\n        result = insert_chat_message(room_id, \"user1000\", \"Extra message\")\n        self.assertFalse(result)\n        self.assertEqual(len(chat_rooms[room_id]), 1000)\n\n    def test_room_message_999th_message(self):\n        \"\"\"Test adding the 1000th message (should succeed).\"\"\"\n        room_id = \"room_boundary\"\n        for i in range(999):\n            insert_chat_message(room_id, f\"user{i}\", f\"Message {i}\")\n        result = insert_chat_message(room_id, \"user999\", \"Last allowed\")\n        self.assertTrue(result)\n        self.assertEqual(len(chat_rooms[room_id]), 1000)\n\n    def test_empty_message(self):\n        \"\"\"Test adding an empty message (should succeed as length <= 500).\"\"\"\n        result = insert_chat_message(\"room1\", \"user1\", \"\")\n        self.assertTrue(result)\n        self.assertEqual(chat_rooms[\"room1\"][0][\"message\"], \"\")\n\n    def test_multiple_chat_rooms(self):\n        \"\"\"Test adding messages to multiple distinct chat rooms.\"\"\"\n        result1 = insert_chat_message(\"room1\", \"user1\", \"Room 1 message\")\n        result2 = insert_chat_message(\"room2\", \"user2\", \"Room 2 message\")\n        self.assertTrue(result1)\n        self.assertTrue(result2)\n        self.assertEqual(len(chat_rooms[\"room1\"]), 1)\n        self.assertEqual(len(chat_rooms[\"room2\"]), 1)\n        self.assertEqual(chat_rooms[\"room1\"][0][\"message\"], \"Room 1 message\")\n        self.assertEqual(chat_rooms[\"room2\"][0][\"message\"], \"Room 2 message\")\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 8, "task_id": "70c7fa57"}
{"test": "import unittest\n\n# Define the global variable for the tests\nchat_rooms = {}\n\nclass TestInsertMessageInChannel(unittest.TestCase):\n    def setUp(self):\n        \"\"\"Reset the global chat_rooms before each test.\"\"\"\n        global chat_rooms\n        chat_rooms = {}\n\n    def test_new_channel(self):\n        \"\"\"Test adding a message to a new channel creates the channel and stores the message.\"\"\"\n        result = insert_message_in_channel(\"general\", \"user1\", \"Hello!\")\n        self.assertTrue(result)\n        self.assertIn(\"general\", chat_rooms)\n        self.assertEqual(len(chat_rooms[\"general\"]), 1)\n        self.assertEqual(chat_rooms[\"general\"][0][\"user_id\"], \"user1\")\n        self.assertEqual(chat_rooms[\"general\"][0][\"message\"], \"Hello!\")\n\n    def test_existing_channel(self):\n        \"\"\"Test adding a message to an existing channel appends the message.\"\"\"\n        insert_message_in_channel(\"random\", \"user2\", \"First\")\n        result = insert_message_in_channel(\"random\", \"user3\", \"Second\")\n        self.assertTrue(result)\n        self.assertEqual(len(chat_rooms[\"random\"]), 2)\n        self.assertEqual(chat_rooms[\"random\"][1][\"user_id\"], \"user3\")\n        self.assertEqual(chat_rooms[\"random\"][1][\"message\"], \"Second\")\n\n    def test_message_exact_length_limit(self):\n        \"\"\"Test a message with exactly 500 characters is accepted.\"\"\"\n        message = \"A\" * 500\n        result = insert_message_in_channel(\"limits\", \"user4\", message)\n        self.assertTrue(result)\n        self.assertEqual(len(chat_rooms[\"limits\"][0][\"message\"]), 500)\n\n    def test_message_exceeds_length_limit(self):\n        \"\"\"Test a message exceeding 500 characters is rejected.\"\"\"\n        message = \"B\" * 501\n        result = insert_message_in_channel(\"limits\", \"user5\", message)\n        self.assertFalse(result)\n        self.assertNotIn(\"limits\", chat_rooms)\n\n    def test_channel_at_capacity(self):\n        \"\"\"Test adding a message to a channel at maximum capacity (1000 messages) is rejected.\"\"\"\n        chat_rooms[\"full\"] = [{\"user_id\": \"user\", \"message\": \"msg\"}] * 1000\n        result = insert_message_in_channel(\"full\", \"user6\", \"New message\")\n        self.assertFalse(result)\n        self.assertEqual(len(chat_rooms[\"full\"]), 1000)\n\n    def test_channel_one_below_capacity(self):\n        \"\"\"Test adding the 1000th message to a channel with 999 messages is accepted.\"\"\"\n        chat_rooms[\"almost_full\"] = [{\"user_id\": \"user\", \"message\": \"msg\"}] * 999\n        result = insert_message_in_channel(\"almost_full\", \"user7\", \"Last message\")\n        self.assertTrue(result)\n        self.assertEqual(len(chat_rooms[\"almost_full\"]), 1000)\n        self.assertEqual(chat_rooms[\"almost_full\"][-1][\"message\"], \"Last message\")\n\n    def test_empty_message_body(self):\n        \"\"\"Test an empty message body is accepted.\"\"\"\n        result = insert_message_in_channel(\"empty\", \"user8\", \"\")\n        self.assertTrue(result)\n        self.assertEqual(chat_rooms[\"empty\"][0][\"message\"], \"\")\n\n    def test_message_to_existing_channel_exceeds_length(self):\n        \"\"\"Test a long message rejected in an existing channel doesn't alter state.\"\"\"\n        chat_rooms[\"existing\"] = [{\"user_id\": \"user\", \"message\": \"msg\"}]\n        result = insert_message_in_channel(\"existing\", \"user9\", \"X\" * 501)\n        self.assertFalse(result)\n        self.assertEqual(len(chat_rooms[\"existing\"]), 1)\n\n    def test_multiple_channels_independent(self):\n        \"\"\"Test messages added to different channels are stored independently.\"\"\"\n        insert_message_in_channel(\"channelA\", \"userA\", \"Message A\")\n        insert_message_in_channel(\"channelB\", \"userB\", \"Message B\")\n        self.assertEqual(len(chat_rooms[\"channelA\"]), 1)\n        self.assertEqual(len(chat_rooms[\"channelB\"]), 1)\n        self.assertEqual(chat_rooms[\"channelA\"][0][\"message\"], \"Message A\")\n        self.assertEqual(chat_rooms[\"channelB\"][0][\"message\"], \"Message B\")\n\n    def test_invalid_msg_body_none(self):\n        \"\"\"Test passing None for msg_body raises TypeError.\"\"\"\n        with self.assertRaises(TypeError):\n            insert_message_in_channel(\"test\", \"user\", None)\n\n    def test_invalid_msg_body_int(self):\n        \"\"\"Test passing integer for msg_body raises TypeError.\"\"\"\n        with self.assertRaises(TypeError):\n            insert_message_in_channel(\"test\", \"user\", 123)\n", "num_test_cases": 11, "task_id": "8c9b15cb"}
{"test": "import unittest\nfrom solution import log_user_event, activity_log\n\nclass TestLogUserEvent(unittest.TestCase):\n    def setUp(self):\n        activity_log.clear()\n    \n    def test_normal_event(self):\n        # Test logging a typical event with valid inputs\n        user = 'user1'\n        action = 'login'\n        result = log_user_event(user, action)\n        self.assertTrue(result)\n        self.assertEqual(len(activity_log), 1)\n        self.assertEqual(activity_log[-1], {'user_id': user, 'action': action})\n    \n    def test_empty_action_details(self):\n        # Test logging with empty action details string\n        user = 'user2'\n        action = ''\n        result = log_user_event(user, action)\n        self.assertTrue(result)\n        self.assertEqual(len(activity_log), 1)\n        self.assertEqual(activity_log[-1], {'user_id': user, 'action': action})\n    \n    def test_action_details_499_chars(self):\n        # Test action_details at max allowed length (499 chars)\n        user = 'user3'\n        action = 'a' * 499\n        result = log_user_event(user, action)\n        self.assertTrue(result)\n        self.assertEqual(len(activity_log), 1)\n        self.assertEqual(activity_log[-1], {'user_id': user, 'action': action})\n    \n    def test_action_details_500_chars(self):\n        # Test action_details at boundary (500 chars) - should reject\n        user = 'user4'\n        action = 'a' * 500\n        result = log_user_event(user, action)\n        self.assertFalse(result)\n        self.assertEqual(len(activity_log), 0)\n    \n    def test_action_details_501_chars(self):\n        # Test action_details exceeding max length (501 chars)\n        user = 'user5'\n        action = 'a' * 501\n        result = log_user_event(user, action)\n        self.assertFalse(result)\n        self.assertEqual(len(activity_log), 0)\n    \n    def test_log_size_one_less_than_max(self):\n        # Test logging when log has 999999 entries (one before limit)\n        activity_log.extend([{'user_id': 'dummy', 'action': 'dummy'}] * 999999)\n        user = 'real_user'\n        action = 'real_action'\n        result = log_user_event(user, action)\n        self.assertTrue(result)\n        self.assertEqual(len(activity_log), 1000000)\n        self.assertEqual(activity_log[-1], {'user_id': user, 'action': action})\n    \n    def test_log_size_at_max(self):\n        # Test logging when log has 1000000 entries (at max capacity)\n        activity_log.extend([{'user_id': 'dummy', 'action': 'dummy'}] * 1000000)\n        user = 'user6'\n        action = 'action'\n        result = log_user_event(user, action)\n        self.assertFalse(result)\n        self.assertEqual(len(activity_log), 1000000)\n    \n    def test_user_key_non_string(self):\n        # Test non-string user_key (integer) is accepted\n        user = 123\n        action = 'non_string_user'\n        result = log_user_event(user, action)\n        self.assertTrue(result)\n        self.assertEqual(len(activity_log), 1)\n        self.assertEqual(activity_log[-1], {'user_id': user, 'action': action})\n    \n    def test_action_details_non_string_raises(self):\n        # Test non-string action_details (integer) raises TypeError\n        with self.assertRaises(TypeError):\n            log_user_event('user7', 123)\n    \n    def test_action_details_none_raises(self):\n        # Test None action_details raises TypeError\n        with self.assertRaises(TypeError):\n            log_user_event('user8', None)\n    \n    def test_user_key_empty_string(self):\n        # Test empty string user_key is accepted\n        user = ''\n        action = 'empty_user_key'\n        result = log_user_event(user, action)\n        self.assertTrue(result)\n        self.assertEqual(len(activity_log), 1)\n        self.assertEqual(activity_log[-1], {'user_id': user, 'action': action})\n    \n    def test_action_details_unicode_499(self):\n        # Test unicode action_details at 499 chars\n        user = 'user9'\n        action = '©' * 499\n        result = log_user_event(user, action)\n        self.assertTrue(result)\n        self.assertEqual(len(activity_log), 1)\n        self.assertEqual(activity_log[-1], {'user_id': user, 'action': action})\n    \n    def test_action_details_unicode_500(self):\n        # Test unicode action_details at 500 chars (rejected)\n        user = 'user10'\n        action = '©' * 500\n        result = log_user_event(user, action)\n        self.assertFalse(result)\n        self.assertEqual(len(activity_log), 0)\n    \n    def test_multiple_logs(self):\n        # Test multiple successful logs in sequence\n        user1 = 'userA'\n        action1 = 'action1'\n        result1 = log_user_event(user1, action1)\n        self.assertTrue(result1)\n        self.assertEqual(len(activity_log), 1)\n        self.assertEqual(activity_log[-1], {'user_id': user1, 'action': action1})\n        \n        user2 = 'userB'\n        action2 = 'action2'\n        result2 = log_user_event(user2, action2)\n        self.assertTrue(result2)\n        self.assertEqual(len(activity_log), 2)\n        self.assertEqual(activity_log[-1], {'user_id': user2, 'action': action2})", "num_test_cases": 14, "task_id": "441da129"}
{"test": "import unittest\n\nclass TestCases(unittest.TestCase):\n    def setUp(self):\n        global activity_log\n        activity_log = []\n    \n    def test_basic_event(self):\n        # Test typical valid input\n        uid = 'user1'\n        description = 'Login'\n        result = track_user_event(uid, description)\n        self.assertTrue(result)\n        self.assertEqual(len(activity_log), 1)\n        self.assertEqual(activity_log[0]['user_id'], uid)\n        self.assertEqual(activity_log[0]['action'], description)\n    \n    def test_empty_description(self):\n        # Test empty description (within length limit)\n        uid = 'user2'\n        description = ''\n        result = track_user_event(uid, description)\n        self.assertTrue(result)\n        self.assertEqual(len(activity_log), 1)\n        self.assertEqual(activity_log[0]['user_id'], uid)\n        self.assertEqual(activity_log[0]['action'], description)\n    \n    def test_description_length_499(self):\n        # Test description at boundary (499 chars)\n        uid = 'user3'\n        description = 'A' * 499\n        result = track_user_event(uid, description)\n        self.assertTrue(result)\n        self.assertEqual(len(activity_log), 1)\n        self.assertEqual(activity_log[0]['user_id'], uid)\n        self.assertEqual(activity_log[0]['action'], description)\n    \n    def test_description_length_500(self):\n        # Test description at exact limit (500 chars) - should reject\n        uid = 'user4'\n        description = 'A' * 500\n        result = track_user_event(uid, description)\n        self.assertFalse(result)\n        self.assertEqual(len(activity_log), 0)\n    \n    def test_description_length_501(self):\n        # Test description exceeding limit (501 chars)\n        uid = 'user5'\n        description = 'A' * 501\n        result = track_user_event(uid, description)\n        self.assertFalse(result)\n        self.assertEqual(len(activity_log), 0)\n    \n    def test_empty_uid(self):\n        # Test empty user ID\n        uid = ''\n        description = 'Some action'\n        result = track_user_event(uid, description)\n        self.assertTrue(result)\n        self.assertEqual(len(activity_log), 1)\n        self.assertEqual(activity_log[0]['user_id'], uid)\n        self.assertEqual(activity_log[0]['action'], description)\n    \n    def test_uid_integer(self):\n        # Test non-string UID (integer)\n        uid = 12345\n        description = 'Some action'\n        result = track_user_event(uid, description)\n        self.assertTrue(result)\n        self.assertEqual(len(activity_log), 1)\n        self.assertEqual(activity_log[0]['user_id'], uid)\n        self.assertEqual(activity_log[0]['action'], description)\n    \n    def test_uid_none(self):\n        # Test UID as None\n        uid = None\n        description = 'Some action'\n        result = track_user_event(uid, description)\n        self.assertTrue(result)\n        self.assertEqual(len(activity_log), 1)\n        self.assertEqual(activity_log[0]['user_id'], uid)\n        self.assertEqual(activity_log[0]['action'], description)\n    \n    def test_long_uid(self):\n        # Test very long UID\n        uid = 'A' * 10000\n        description = 'Some action'\n        result = track_user_event(uid, description)\n        self.assertTrue(result)\n        self.assertEqual(len(activity_log), 1)\n        self.assertEqual(activity_log[0]['user_id'], uid)\n        self.assertEqual(activity_log[0]['action'], description)\n    \n    def test_log_almost_full(self):\n        # Test when log has 999999 entries (one below limit)\n        global activity_log\n        dummy = {'user_id': 'dummy', 'action': 'dummy'}\n        activity_log = [dummy] * 999999\n        self.assertEqual(len(activity_log), 999999)\n        uid = 'user10'\n        description = 'Action'\n        result = track_user_event(uid, description)\n        self.assertTrue(result)\n        self.assertEqual(len(activity_log), 1000000)\n        self.assertEqual(activity_log[-1]['user_id'], uid)\n        self.assertEqual(activity_log[-1]['action'], description)\n    \n    def test_log_full(self):\n        # Test when log is full (1000000 entries)\n        global activity_log\n        dummy = {'user_id': 'dummy', 'action': 'dummy'}\n        activity_log = [dummy] * 1000000\n        self.assertEqual(len(activity_log), 1000000)\n        uid = 'user11'\n        description = 'Action'\n        result = track_user_event(uid, description)\n        self.assertFalse(result)\n        self.assertEqual(len(activity_log), 1000000)\n    \n    def test_description_none(self):\n        # Test None description (invalid type)\n        with self.assertRaises(TypeError):\n            track_user_event('user12', None)\n    \n    def test_description_integer(self):\n        # Test integer description (invalid type)\n        with self.assertRaises(TypeError):\n            track_user_event('user13', 12345)", "num_test_cases": 13, "task_id": "c57463ce"}
{"test": "import unittest\n\n# Define the global activity_log and the function to make the tests self-contained\nactivity_log = []\n\ndef record_user_action(user_identifier: str, event: str) -> bool:\n    global activity_log\n    if len(activity_log) < 1000000 and len(event) < 500:\n        activity_log.append({\"user_id\": user_identifier, \"action\": event})\n        return True\n    return False\n\nclass TestRecordUserAction(unittest.TestCase):\n    def setUp(self):\n        \"\"\"Reset the global activity_log before each test.\"\"\"\n        global activity_log\n        activity_log = []\n    \n    def test_basic_functionality(self):\n        \"\"\"Test basic functionality with valid inputs.\"\"\"\n        result = record_user_action('user1', 'login')\n        self.assertTrue(result)\n        self.assertEqual(activity_log, [{'user_id': 'user1', 'action': 'login'}])\n    \n    def test_event_length_499(self):\n        \"\"\"Test event with length 499 (valid).\"\"\"\n        event = 'a' * 499\n        result = record_user_action('user1', event)\n        self.assertTrue(result)\n        self.assertEqual(activity_log[-1]['action'], event)\n    \n    def test_event_length_500(self):\n        \"\"\"Test event with length 500 (invalid).\"\"\"\n        event = 'a' * 500\n        result = record_user_action('user1', event)\n        self.assertFalse(result)\n        self.assertEqual(len(activity_log), 0)\n    \n    def test_event_length_501(self):\n        \"\"\"Test event with length 501 (invalid).\"\"\"\n        event = 'a' * 501\n        result = record_user_action('user1', event)\n        self.assertFalse(result)\n        self.assertEqual(len(activity_log), 0)\n    \n    def test_log_full(self):\n        \"\"\"Test when the log is full (1,000,000 entries).\"\"\"\n        global activity_log\n        activity_log = [{\"user_id\": \"dummy\", \"action\": \"dummy\"}] * 1000000\n        result = record_user_action('user1', 'event')\n        self.assertFalse(result)\n        self.assertEqual(len(activity_log), 1000000)\n    \n    def test_log_almost_full(self):\n        \"\"\"Test when the log has 999,999 entries (valid addition).\"\"\"\n        global activity_log\n        activity_log = [{\"user_id\": \"dummy\", \"action\": \"dummy\"}] * 999999\n        result = record_user_action('user1', 'event')\n        self.assertTrue(result)\n        self.assertEqual(len(activity_log), 1000000)\n        self.assertEqual(activity_log[-1], {'user_id': 'user1', 'action': 'event'})\n    \n    def test_empty_event(self):\n        \"\"\"Test with an empty event string (valid).\"\"\"\n        result = record_user_action('user1', '')\n        self.assertTrue(result)\n        self.assertEqual(activity_log[-1]['action'], '')\n    \n    def test_empty_user_identifier(self):\n        \"\"\"Test with an empty user identifier (valid).\"\"\"\n        result = record_user_action('', 'event')\n        self.assertTrue(result)\n        self.assertEqual(activity_log[-1]['user_id'], '')\n    \n    def test_non_ascii_characters(self):\n        \"\"\"Test non-ASCII characters in user and event strings.\"\"\"\n        user = '\\u00FCser\\u00F8'  # üserø\n        event = '\\u00E5ction'      # åction\n        result = record_user_action(user, event)\n        self.assertTrue(result)\n        self.assertEqual(activity_log[-1]['user_id'], user)\n        self.assertEqual(activity_log[-1]['action'], event)\n    \n    def test_log_unchanged_after_event_rejection(self):\n        \"\"\"Test log unchanged after rejection due to event length.\"\"\"\n        record_user_action('user1', 'event1')\n        current_log = activity_log.copy()\n        result = record_user_action('user1', 'a' * 500)\n        self.assertFalse(result)\n        self.assertEqual(activity_log, current_log)\n    \n    def test_log_unchanged_after_log_full_rejection(self):\n        \"\"\"Test log unchanged after rejection due to log full.\"\"\"\n        global activity_log\n        activity_log = [{\"user_id\": \"dummy\", \"action\": \"dummy\"}] * 1000000\n        current_log = activity_log.copy()\n        result = record_user_action('user1', 'event')\n        self.assertFalse(result)\n        self.assertEqual(activity_log, current_log)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 11, "task_id": "eb1cc585"}
{"test": "import unittest\n\n# Define the global activity_log variable required by the function\nactivity_log = []\n\nclass TestCases(unittest.TestCase):\n    def setUp(self):\n        \"\"\"Reset the activity_log before each test.\"\"\"\n        global activity_log\n        activity_log.clear()\n    \n    def test_case_1(self):\n        \"\"\"Basic functionality with valid inputs.\"\"\"\n        result = track_user_operation('user1', 'login')\n        self.assertTrue(result)\n        self.assertEqual(len(activity_log), 1)\n        self.assertEqual(activity_log[0]['user_id'], 'user1')\n        self.assertEqual(activity_log[0]['action'], 'login')\n    \n    def test_case_2(self):\n        \"\"\"Operation at maximum allowed length (499 characters).\"\"\"\n        operation = 'a' * 499\n        result = track_user_operation('user1', operation)\n        self.assertTrue(result)\n        self.assertEqual(activity_log[0]['action'], operation)\n    \n    def test_case_3(self):\n        \"\"\"Operation at boundary length (500 characters) should fail.\"\"\"\n        operation = 'a' * 500\n        result = track_user_operation('user1', operation)\n        self.assertFalse(result)\n        self.assertEqual(len(activity_log), 0)\n    \n    def test_case_4(self):\n        \"\"\"Operation exceeding maximum length (501 characters).\"\"\"\n        operation = 'a' * 501\n        result = track_user_operation('user1', operation)\n        self.assertFalse(result)\n        self.assertEqual(len(activity_log), 0)\n    \n    def test_case_5(self):\n        \"\"\"Adding to a log at capacity limit (999,999 entries) should succeed.\"\"\"\n        global activity_log\n        activity_log = [{'user_id': 'dummy', 'action': 'dummy'}] * 999999\n        result = track_user_operation('user1', 'login')\n        self.assertTrue(result)\n        self.assertEqual(len(activity_log), 1000000)\n        self.assertEqual(activity_log[-1]['user_id'], 'user1')\n    \n    def test_case_6(self):\n        \"\"\"Adding to a full log (1,000,000 entries) should fail.\"\"\"\n        global activity_log\n        activity_log = [{'user_id': 'dummy', 'action': 'dummy'}] * 1000000\n        result = track_user_operation('user1', 'login')\n        self.assertFalse(result)\n        self.assertEqual(len(activity_log), 1000000)\n    \n    def test_case_7(self):\n        \"\"\"Empty account string should be logged successfully.\"\"\"\n        result = track_user_operation('', 'logout')\n        self.assertTrue(result)\n        self.assertEqual(activity_log[0]['user_id'], '')\n    \n    def test_case_8(self):\n        \"\"\"Very long account string should be logged successfully.\"\"\"\n        account = 'a' * 10000\n        result = track_user_operation(account, 'operation')\n        self.assertTrue(result)\n        self.assertEqual(activity_log[0]['user_id'], account)\n    \n    def test_case_9(self):\n        \"\"\"Empty operation string should be logged successfully.\"\"\"\n        result = track_user_operation('user1', '')\n        self.assertTrue(result)\n        self.assertEqual(activity_log[0]['action'], '')\n    \n    def test_case_10(self):\n        \"\"\"None as account should raise TypeError.\"\"\"\n        with self.assertRaises(TypeError):\n            track_user_operation(None, 'operation')\n    \n    def test_case_11(self):\n        \"\"\"None as operation should raise TypeError.\"\"\"\n        with self.assertRaises(TypeError):\n            track_user_operation('user1', None)\n    \n    def test_case_12(self):\n        \"\"\"Non-string account (integer) should raise TypeError.\"\"\"\n        with self.assertRaises(TypeError):\n            track_user_operation(123, 'operation')\n    \n    def test_case_13(self):\n        \"\"\"Non-string operation (integer) should raise TypeError.\"\"\"\n        with self.assertRaises(TypeError):\n            track_user_operation('user1', 123)\n    \n    def test_case_14(self):\n        \"\"\"Both conditions failing: full log and long operation.\"\"\"\n        global activity_log\n        activity_log = [{'user_id': 'dummy', 'action': 'dummy'}] * 1000000\n        operation = 'a' * 500\n        result = track_user_operation('user1', operation)\n        self.assertFalse(result)\n        self.assertEqual(len(activity_log), 1000000)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 14, "task_id": "d9387c94"}
{"test": "import unittest\nimport __main__\nfrom __main__ import save_user_event\n\nclass TestCases(unittest.TestCase):\n    def setUp(self):\n        __main__.activity_log = []\n\n    def test_case_1(self):\n        # Test valid event: should return True and append correct data\n        result = save_user_event(\"user1\", \"Login\")\n        self.assertTrue(result)\n        self.assertEqual(len(__main__.activity_log), 1)\n        self.assertEqual(__main__.activity_log[0], {\"user_id\": \"user1\", \"action\": \"Login\"})\n\n    def test_case_2(self):\n        # Test empty task: should return True and store empty string\n        result = save_user_event(\"user1\", \"\")\n        self.assertTrue(result)\n        self.assertEqual(__main__.activity_log[0][\"action\"], \"\")\n\n    def test_case_3(self):\n        # Test task at max allowed length (499): should return True and store correctly\n        task = \"a\" * 499\n        result = save_user_event(\"user1\", task)\n        self.assertTrue(result)\n        self.assertEqual(__main__.activity_log[0][\"action\"], task)\n\n    def test_case_4(self):\n        # Test task at disallowed length (500): should return False and leave log unchanged\n        initial_log = __main__.activity_log[:]\n        task = \"a\" * 500\n        result = save_user_event(\"user1\", task)\n        self.assertFalse(result)\n        self.assertEqual(__main__.activity_log, initial_log)\n\n    def test_case_5(self):\n        # Test task exceeding max length (501): should return False and leave log unchanged\n        initial_log = __main__.activity_log[:]\n        task = \"a\" * 501\n        result = save_user_event(\"user1\", task)\n        self.assertFalse(result)\n        self.assertEqual(__main__.activity_log, initial_log)\n\n    def test_case_6(self):\n        # Test with full log (1000000 entries): should return False and leave log unchanged\n        __main__.activity_log = [None] * 1000000\n        initial_length = len(__main__.activity_log)\n        result = save_user_event(\"user1\", \"Login\")\n        self.assertFalse(result)\n        self.assertEqual(len(__main__.activity_log), initial_length)\n\n    def test_case_7(self):\n        # Test with almost full log (999999 entries): should return True and append correctly\n        __main__.activity_log = [None] * 999999\n        result = save_user_event(\"user1\", \"Login\")\n        self.assertTrue(result)\n        self.assertEqual(len(__main__.activity_log), 1000000)\n        self.assertEqual(__main__.activity_log[-1], {\"user_id\": \"user1\", \"action\": \"Login\"})\n\n    def test_case_8(self):\n        # Test empty user identifier: should return True and store empty user_id\n        result = save_user_event(\"\", \"Action\")\n        self.assertTrue(result)\n        self.assertEqual(__main__.activity_log[0][\"user_id\"], \"\")", "num_test_cases": 8, "task_id": "da9b6702"}
{"test": "import unittest\nimport chat_system\n\nclass TestCases(unittest.TestCase):\n    def setUp(self):\n        chat_system.chat_rooms = {}\n\n    def test_new_room(self):\n        # Test adding a message to a new room (creates room and appends message)\n        room = 'new_room'\n        member = 'user1'\n        msg = 'Hello'\n        result = chat_system.push_text_to_room(room, member, msg)\n        self.assertTrue(result)\n        self.assertIn(room, chat_system.chat_rooms)\n        self.assertEqual(len(chat_system.chat_rooms[room]), 1)\n        self.assertEqual(chat_system.chat_rooms[room][0]['user_id'], member)\n        self.assertEqual(chat_system.chat_rooms[room][0]['message'], msg)\n\n    def test_existing_room(self):\n        # Test adding a message to an existing room (appends to history)\n        room = 'room1'\n        chat_system.chat_rooms[room] = [{'user_id': 'user0', 'message': 'msg0'}]\n        result = chat_system.push_text_to_room(room, 'user1', 'msg1')\n        self.assertTrue(result)\n        self.assertEqual(len(chat_system.chat_rooms[room]), 2)\n        self.assertEqual(chat_system.chat_rooms[room][1]['user_id'], 'user1')\n        self.assertEqual(chat_system.chat_rooms[room][1]['message'], 'msg1')\n\n    def test_message_length_500(self):\n        # Test message with exactly 500 characters (should succeed)\n        room = 'room1'\n        content = 'A' * 500\n        result = chat_system.push_text_to_room(room, 'user1', content)\n        self.assertTrue(result)\n        self.assertEqual(chat_system.chat_rooms[room][0]['message'], content)\n\n    def test_message_length_501(self):\n        # Test message with 501 characters (exceeds limit, should fail)\n        room = 'room1'\n        content = 'A' * 501\n        result = chat_system.push_text_to_room(room, 'user1', content)\n        self.assertFalse(result)\n        self.assertIn(room, chat_system.chat_rooms)\n        self.assertEqual(len(chat_system.chat_rooms[room]), 0)\n\n    def test_room_message_count_999(self):\n        # Test room with 999 messages (adding 1000th should succeed)\n        room = 'room999'\n        chat_system.chat_rooms[room] = [{'user_id': 'dummy', 'message': 'dummy'}] * 999\n        result = chat_system.push_text_to_room(room, 'user1', 'last message')\n        self.assertTrue(result)\n        self.assertEqual(len(chat_system.chat_rooms[room]), 1000)\n\n    def test_room_message_count_1000(self):\n        # Test room with 1000 messages (adding 1001st should fail)\n        room = 'room1000'\n        chat_system.chat_rooms[room] = [{'user_id': 'dummy', 'message': 'dummy'}] * 1000\n        result = chat_system.push_text_to_room(room, 'user1', 'extra message')\n        self.assertFalse(result)\n        self.assertEqual(len(chat_system.chat_rooms[room]), 1000)\n\n    def test_empty_message(self):\n        # Test empty message content (within length limit, should succeed)\n        room = 'empty_room'\n        result = chat_system.push_text_to_room(room, 'user1', '')\n        self.assertTrue(result)\n        self.assertEqual(chat_system.chat_rooms[room][0]['message'], '')\n\n    def test_empty_room_name(self):\n        # Test empty room name (should create room and succeed)\n        room = ''\n        result = chat_system.push_text_to_room(room, 'user1', 'content')\n        self.assertTrue(result)\n        self.assertIn(room, chat_system.chat_rooms)\n\n    def test_content_none(self):\n        # Test None content (invalid type, should raise TypeError)\n        with self.assertRaises(TypeError):\n            chat_system.push_text_to_room('room', 'user', None)\n\n    def test_content_integer(self):\n        # Test integer content (invalid type, should raise TypeError)\n        with self.assertRaises(TypeError):\n            chat_system.push_text_to_room('room', 'user', 123)\n\n    def test_non_string_member_id(self):\n        # Test non-string member_id (appended as-is, no type check)\n        room = 'room_x'\n        result = chat_system.push_text_to_room(room, None, 'content')\n        self.assertTrue(result)\n        self.assertEqual(chat_system.chat_rooms[room][0]['user_id'], None)\n\n    def test_long_room_name(self):\n        # Test very long room name (within system limits, should succeed)\n        room = 'A' * 10000\n        result = chat_system.push_text_to_room(room, 'user', 'content')\n        self.assertTrue(result)\n        self.assertIn(room, chat_system.chat_rooms)\n\n    def test_integer_room_name(self):\n        # Test integer room name (hashable, should succeed)\n        room = 123\n        result = chat_system.push_text_to_room(room, 'user', 'content')\n        self.assertTrue(result)\n        self.assertIn(room, chat_system.chat_rooms)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 13, "task_id": "43b45698"}
