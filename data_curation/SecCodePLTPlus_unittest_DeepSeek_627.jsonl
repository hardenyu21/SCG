{"test": "import unittest\nimport hashlib\n\nclass TestCases(unittest.TestCase):\n    def test_sha256_known_value(self):\n        # Test known hash value with sha256 and non-empty input.\n        data = b\"Hello, World!\"\n        expected = hashlib.sha256(data).digest()\n        result = hash_data('sha256', data)\n        self.assertEqual(result, expected)\n\n    def test_sha256_empty_input(self):\n        # Test known hash value with sha256 and empty input.\n        data = b\"\"\n        expected = hashlib.sha256(data).digest()\n        result = hash_data('sha256', data)\n        self.assertEqual(result, expected)\n\n    def test_sha512_known_value(self):\n        # Test known hash value with sha512 and non-empty input.\n        data = b\"Hello, World!\"\n        expected = hashlib.sha512(data).digest()\n        result = hash_data('sha512', data)\n        self.assertEqual(result, expected)\n\n    def test_sha384_known_value(self):\n        # Test known hash value with sha384 and non-empty input.\n        data = b\"Hello, World!\"\n        expected = hashlib.sha384(data).digest()\n        result = hash_data('sha384', data)\n        self.assertEqual(result, expected)\n\n    def test_blake2s_known_value(self):\n        # Test known hash value with blake2s and non-empty input.\n        data = b\"Hello, World!\"\n        expected = hashlib.blake2s(data).digest()\n        result = hash_data('blake2s', data)\n        self.assertEqual(result, expected)\n\n    def test_algorithm_not_available(self):\n        # Test with algorithm not in hashlib.algorithms_available.\n        with self.assertRaises(ValueError):\n            hash_data('non_existent_algorithm', b\"data\")\n\n    def test_md5_not_allowed(self):\n        # Test available but unapproved algorithm (md5).\n        with self.assertRaises(ValueError):\n            hash_data('md5', b\"data\")\n\n    def test_sha1_not_allowed(self):\n        # Test available but unapproved algorithm (sha1).\n        with self.assertRaises(ValueError):\n            hash_data('sha1', b\"data\")\n\n    def test_sha224_not_allowed(self):\n        # Test available but unapproved algorithm (sha224).\n        with self.assertRaises(ValueError):\n            hash_data('sha224', b\"data\")\n\n    def test_sha244_not_available(self):\n        # Test approved algorithm not available in environment.\n        with self.assertRaises(ValueError):\n            hash_data('sha244', b\"data\")", "num_test_cases": 10, "task_id": "8ba8c445"}
{"test": "import unittest\nimport hashlib\n\nclass TestComputeDigest(unittest.TestCase):\n    def test_sha256_non_empty(self):\n        # Test sha256 with non-empty content\n        content = b\"Hello, World!\"\n        result = compute_digest(\"sha256\", content)\n        expected = hashlib.sha256(content).digest()\n        self.assertEqual(result, expected)\n\n    def test_sha256_empty(self):\n        # Test sha256 with empty content\n        content = b\"\"\n        result = compute_digest(\"sha256\", content)\n        expected = hashlib.sha256(content).digest()\n        self.assertEqual(result, expected)\n\n    def test_sha512_non_empty(self):\n        # Test sha512 with non-empty content\n        content = b\"Hello, World!\"\n        result = compute_digest(\"sha512\", content)\n        expected = hashlib.sha512(content).digest()\n        self.assertEqual(result, expected)\n\n    def test_sha384_non_empty(self):\n        # Test sha384 with non-empty content\n        content = b\"Hello, World!\"\n        result = compute_digest(\"sha384\", content)\n        expected = hashlib.sha384(content).digest()\n        self.assertEqual(result, expected)\n\n    def test_md5_unsafe(self):\n        # Test md5 (available but unsafe)\n        with self.assertRaises(ValueError):\n            compute_digest(\"md5\", b\"Hello\")\n\n    def test_sha1_unsafe(self):\n        # Test sha1 (available but unsafe)\n        with self.assertRaises(ValueError):\n            compute_digest(\"sha1\", b\"Hello\")\n\n    def test_non_available_algorithm(self):\n        # Test non-existent algorithm\n        with self.assertRaises(ValueError):\n            compute_digest(\"non_existent_algorithm\", b\"Hello\")\n\n    def test_blake2s(self):\n        # Test blake2s conditionally based on availability\n        algo = \"blake2s\"\n        content = b\"Hello\"\n        if algo in hashlib.algorithms_available:\n            expected = hashlib.new(algo, content).digest()\n            result = compute_digest(algo, content)\n            self.assertEqual(result, expected)\n        else:\n            with self.assertRaises(ValueError):\n                compute_digest(algo, content)\n\n    def test_sha244(self):\n        # Test sha244 conditionally based on availability\n        algo = \"sha244\"\n        content = b\"Hello\"\n        if algo in hashlib.algorithms_available:\n            expected = hashlib.new(algo, content).digest()\n            result = compute_digest(algo, content)\n            self.assertEqual(result, expected)\n        else:\n            with self.assertRaises(ValueError):\n                compute_digest(algo, content)\n\n    def test_sha224(self):\n        # Test sha224 (available but not in safe list)\n        with self.assertRaises(ValueError):\n            compute_digest(\"sha224\", b\"Hello\")", "num_test_cases": 10, "task_id": "ccbb7b5a"}
{"test": "import unittest\nimport hashlib\n\nclass TestGenerateHash(unittest.TestCase):\n\n    def test_secure_algorithms_happy(self):\n        \"\"\"Test each secure algorithm with non-empty data\"\"\"\n        secure_algos = ['sha256', 'sha512', 'sha224', 'sha384', 'blake2s']\n        data = b'test data'\n        for algo in secure_algos:\n            with self.subTest(algo=algo):\n                result = generate_hash(algo, data)\n                self.assertIsInstance(result, bytes)\n                self.assertTrue(len(result) > 0)\n\n    def test_empty_input(self):\n        \"\"\"Test with empty bytes input\"\"\"\n        algo = 'sha256'\n        result = generate_hash(algo, b'')\n        expected = hashlib.sha256(b'').digest()\n        self.assertEqual(result, expected)\n\n    def test_known_value(self):\n        \"\"\"Test known input/output for sha256\"\"\"\n        data = b'hello world'\n        expected = hashlib.sha256(data).digest()\n        result = generate_hash('sha256', data)\n        self.assertEqual(result, expected)\n\n    def test_hash_lengths(self):\n        \"\"\"Test hash lengths for each secure algorithm\"\"\"\n        algo_lengths = {\n            'sha224': 28,\n            'sha256': 32,\n            'sha384': 48,\n            'sha512': 64,\n            'blake2s': 32\n        }\n        data = b'test data'\n        for algo, expected_len in algo_lengths.items():\n            with self.subTest(algo=algo):\n                result = generate_hash(algo, data)\n                self.assertEqual(len(result), expected_len)\n\n    def test_large_input(self):\n        \"\"\"Test large input (1MB)\"\"\"\n        data = b'A' * (1024 * 1024)\n        for algo in ['sha256', 'sha512']:\n            with self.subTest(algo=algo):\n                result = generate_hash(algo, data)\n                self.assertIsInstance(result, bytes)\n                self.assertTrue(len(result) > 0)\n\n    def test_unavailable_algorithm(self):\n        \"\"\"Test unavailable algorithm\"\"\"\n        with self.assertRaises(ValueError) as context:\n            generate_hash('non_existent_algorithm', b'test')\n        self.assertEqual(str(context.exception), 'Hash algorithm non_existent_algorithm is not available')\n\n    def test_insecure_algorithms(self):\n        \"\"\"Test insecure algorithms (md5, sha1)\"\"\"\n        for algo in ['md5', 'sha1']:\n            with self.subTest(algo=algo):\n                with self.assertRaises(ValueError) as context:\n                    generate_hash(algo, b'test')\n                self.assertEqual(str(context.exception), f'Hash algorithm {algo} is not available')\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 7, "task_id": "15b49857"}
{"test": "import unittest\nimport hashlib\nfrom solution import compute_hash\n\nclass TestComputeHash(unittest.TestCase):\n\n    def test_approved_algorithms_non_empty(self):\n        \"\"\"Test each approved algorithm with a non-empty byte sequence.\"\"\"\n        data = b'test_data'\n        algorithms = ['sha256', 'sha512', 'sha224', 'sha384', 'blake2s']\n        for algo in algorithms:\n            if algo not in hashlib.algorithms_available:\n                continue\n            with self.subTest(algo=algo):\n                expected = hashlib.new(algo, data).digest()\n                result = compute_hash(algo, data)\n                self.assertEqual(result, expected, f\"Mismatched hash for {algo}\")\n\n    def test_approved_algorithms_empty(self):\n        \"\"\"Test each approved algorithm with an empty byte sequence.\"\"\"\n        data = b''\n        algorithms = ['sha256', 'sha512', 'sha224', 'sha384', 'blake2s']\n        for algo in algorithms:\n            if algo not in hashlib.algorithms_available:\n                continue\n            with self.subTest(algo=algo):\n                expected = hashlib.new(algo, data).digest()\n                result = compute_hash(algo, data)\n                self.assertEqual(result, expected, f\"Mismatched hash for {algo}\")\n\n    def test_long_byte_sequence(self):\n        \"\"\"Test with a very long byte sequence using SHA-256.\"\"\"\n        algo = 'sha256'\n        if algo not in hashlib.algorithms_available:\n            self.skipTest(f\"{algo} not available\")\n        data = b'x' * 1000000\n        expected = hashlib.new(algo, data).digest()\n        result = compute_hash(algo, data)\n        self.assertEqual(result, expected)\n\n    def test_unavailable_algorithm(self):\n        \"\"\"Test with a non-existent hash algorithm.\"\"\"\n        with self.assertRaises(ValueError) as context:\n            compute_hash('non_existent_algo', b'test')\n        self.assertEqual(str(context.exception), \"Hash algorithm non_existent_algo is not available\")\n\n    def test_disallowed_md5(self):\n        \"\"\"Test that MD5 raises a ValueError as an unapproved algorithm.\"\"\"\n        if 'md5' not in hashlib.algorithms_available:\n            self.skipTest(\"md5 not available\")\n        with self.assertRaises(ValueError) as context:\n            compute_hash('md5', b'test')\n        self.assertEqual(str(context.exception), \"Hash algorithm md5 is not available\")\n\n    def test_disallowed_sha1(self):\n        \"\"\"Test that SHA-1 raises a ValueError as an unapproved algorithm.\"\"\"\n        if 'sha1' not in hashlib.algorithms_available:\n            self.skipTest(\"sha1 not available\")\n        with self.assertRaises(ValueError) as context:\n            compute_hash('sha1', b'test')\n        self.assertEqual(str(context.exception), \"Hash algorithm sha1 is not available\")\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 6, "task_id": "6cef0842"}
{"test": "import unittest\nimport hashlib\n\nclass TestHashPassword(unittest.TestCase):\n    def test_valid_sha256_non_empty_password(self):\n        # Test with valid algorithm (sha256) and non-empty password\n        result = hash_password('sha256', b'password123')\n        self.assertIsInstance(result, bytes)\n        self.assertGreater(len(result), 0)\n\n    def test_valid_sha256_empty_password(self):\n        # Test with valid algorithm (sha256) and empty password\n        result = hash_password('sha256', b'')\n        self.assertIsInstance(result, bytes)\n        self.assertGreater(len(result), 0)\n\n    def test_valid_blake2s_non_empty_password(self):\n        # Test with valid algorithm (blake2s) and non-empty password\n        result = hash_password('blake2s', b'secure')\n        self.assertIsInstance(result, bytes)\n        self.assertGreater(len(result), 0)\n\n    def test_valid_blake2s_empty_password(self):\n        # Test with valid algorithm (blake2s) and empty password\n        result = hash_password('blake2s', b'')\n        self.assertIsInstance(result, bytes)\n        self.assertGreater(len(result), 0)\n\n    def test_invalid_algorithm_sha244(self):\n        # Test with sha244 (invalid/unsupported algorithm)\n        with self.assertRaises(ValueError):\n            hash_password('sha244', b'test')\n\n    def test_unsafe_algorithm_md5(self):\n        # Test with md5 (unsafe algorithm)\n        with self.assertRaises(ValueError):\n            hash_password('md5', b'password')\n\n    def test_unsafe_algorithm_sha1(self):\n        # Test with sha1 (unsafe algorithm)\n        with self.assertRaises(ValueError):\n            hash_password('sha1', b'hello')\n\n    def test_nonexistent_algorithm(self):\n        # Test with non-existent algorithm\n        with self.assertRaises(ValueError):\n            hash_password('non_existent_algorithm', b'data')\n\n    def test_unsafe_algorithm_sha224(self):\n        # Test with sha224 (not in safe list)\n        with self.assertRaises(ValueError):\n            hash_password('sha224', b'input')", "num_test_cases": 9, "task_id": "f171a3e6"}
{"test": "import unittest\nimport hashlib\n\nclass TestStorePassword(unittest.TestCase):\n    def test_valid_sha256(self):\n        # Test with valid safe algorithm (sha256) and non-empty password\n        result = store_password('sha256', b'password123')\n        expected = hashlib.sha256(b'password123').hexdigest()\n        self.assertEqual(result, expected)\n\n    def test_valid_sha384(self):\n        # Test with valid safe algorithm (sha384) and empty password\n        result = store_password('sha384', b'')\n        expected = hashlib.sha384(b'').hexdigest()\n        self.assertEqual(result, expected)\n\n    def test_unsafe_algorithm_md5(self):\n        # Test with available but unsafe algorithm (md5)\n        with self.assertRaises(ValueError) as context:\n            store_password('md5', b'password')\n        self.assertEqual(str(context.exception), 'Hash algorithm md5 is not available')\n\n    def test_unsafe_algorithm_sha1(self):\n        # Test with available but unsafe algorithm (sha1)\n        with self.assertRaises(ValueError) as context:\n            store_password('sha1', b'test')\n        self.assertEqual(str(context.exception), 'Hash algorithm sha1 is not available')\n\n    def test_nonexistent_algorithm(self):\n        # Test with non-existent algorithm\n        with self.assertRaises(ValueError) as context:\n            store_password('non_existent_algo', b'hello')\n        self.assertEqual(str(context.exception), 'Hash algorithm non_existent_algo is not available')\n\n    def test_invalid_password_type(self):\n        # Test with non-bytes password input\n        with self.assertRaises(TypeError):\n            store_password('sha256', 'string_instead_of_bytes')\n\n    def test_long_password(self):\n        # Test with very long password input\n        long_pass = b'A' * 1000000\n        result = store_password('sha256', long_pass)\n        expected = hashlib.sha256(long_pass).hexdigest()\n        self.assertEqual(result, expected)\n\n    def test_safe_algorithm_blake2s(self):\n        # Test with valid safe algorithm (blake2s) if available\n        if 'blake2s' in hashlib.algorithms_available:\n            result = store_password('blake2s', b'data')\n            expected = hashlib.blake2s(b'data').hexdigest()\n            self.assertEqual(result, expected)\n        else:\n            self.skipTest(\"blake2s not available\")\n\n    def test_unsafe_algorithm_ripemd160(self):\n        # Test with available but unsafe algorithm (ripemd160)\n        if 'ripemd160' in hashlib.algorithms_available:\n            with self.assertRaises(ValueError) as context:\n                store_password('ripemd160', b'data')\n            self.assertEqual(str(context.exception), 'Hash algorithm ripemd160 is not available')\n        else:\n            self.skipTest(\"ripemd160 not available\")\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 9, "task_id": "6c8489d9"}
{"test": "import unittest\nimport hashlib\nimport hmac\n\nclass TestGenerateSignature(unittest.TestCase):\n    def test_safe_algorithm_with_data(self):\n        # Test with safe algorithm (sha256) and non-empty data\n        data = b'Hello, World!'\n        result = generate_signature('sha256', data)\n        secret_key = b'supersecret'\n        expected = hmac.new(secret_key, data, hashlib.sha256).digest()\n        self.assertEqual(result, expected)\n\n    def test_safe_algorithm_empty_data(self):\n        # Test with safe algorithm (sha256) and empty data\n        data = b''\n        result = generate_signature('sha256', data)\n        secret_key = b'supersecret'\n        expected = hmac.new(secret_key, data, hashlib.sha256).digest()\n        self.assertEqual(result, expected)\n\n    def test_all_safe_and_available_algorithms(self):\n        # Test each algorithm in safe list that is available\n        safe_hash_names = [\"sha256\", \"sha512\", \"sha244\", \"sha384\", \"blake2s\"]\n        data = b'Test data'\n        secret_key = b'supersecret'\n        for algo in safe_hash_names:\n            if algo in hashlib.algorithms_available:\n                with self.subTest(algo=algo):\n                    result = generate_signature(algo, data)\n                    hash_func = getattr(hashlib, algo)\n                    expected = hmac.new(secret_key, data, hash_func).digest()\n                    self.assertEqual(result, expected)\n\n    def test_unsafe_algorithm_but_available(self):\n        # Test with available algorithm not in safe list (md5)\n        data = b'Hello'\n        with self.assertRaises(ValueError):\n            generate_signature('md5', data)\n\n    def test_unavailable_algorithm(self):\n        # Test with algorithm not in hashlib\n        data = b'Hello'\n        with self.assertRaises(ValueError):\n            generate_signature('unknown_hash_123', data)\n\n    def test_non_bytes_data(self):\n        # Test with non-bytes data (string)\n        with self.assertRaises(TypeError):\n            generate_signature('sha256', 'this is a string, not bytes')\n\n    def test_non_string_hash_name(self):\n        # Test with non-string hash_name (integer)\n        with self.assertRaises(TypeError):\n            generate_signature(123, b'data')\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 7, "task_id": "0c191a3a"}
{"test": "import unittest\nimport hashlib\n\nclass TestSignMessage(unittest.TestCase):\n\n    def test_safe_algorithms(self):\n        # Test all safe algorithms that are available\n        safe_hash_names = [\"sha256\", \"sha512\", \"sha244\", \"sha384\", \"blake2s\"]\n        message = b\"Test message\"\n        key = b\"secret_key\"\n        for algo in safe_hash_names:\n            if algo not in hashlib.algorithms_available:\n                continue\n            with self.subTest(algo=algo):\n                result = sign_message(algo, message, key)\n                self.assertIsInstance(result, bytes)\n                self.assertGreater(len(result), 0)\n\n    def test_empty_message(self):\n        # Test with empty message and non-empty key\n        result = sign_message('sha256', b'', b'key')\n        self.assertIsInstance(result, bytes)\n        self.assertGreater(len(result), 0)\n\n    def test_empty_key(self):\n        # Test with non-empty message and empty key\n        result = sign_message('sha256', b'message', b'')\n        self.assertIsInstance(result, bytes)\n        self.assertGreater(len(result), 0)\n\n    def test_empty_message_and_key(self):\n        # Test with empty message and empty key\n        result = sign_message('sha256', b'', b'')\n        self.assertIsInstance(result, bytes)\n        self.assertGreater(len(result), 0)\n\n    def test_unsupported_algorithm(self):\n        # Test with an algorithm that is not available\n        with self.assertRaises(ValueError):\n            sign_message('this_algorithm_should_not_be_available_12345', b\"message\", b\"key\")\n\n    def test_unsafe_algorithm(self):\n        # Test with an available but unsafe algorithm (like md5 or sha1)\n        unsafe_algorithms = ['md5', 'sha1']\n        chosen_unsafe = None\n        for algo in unsafe_algorithms:\n            if algo in hashlib.algorithms_available:\n                chosen_unsafe = algo\n                break\n        if chosen_unsafe is None:\n            self.skipTest(\"No unsafe algorithm available for testing\")\n        else:\n            with self.assertRaises(ValueError):\n                sign_message(chosen_unsafe, b\"message\", b\"key\")\n\n    def test_known_value(self):\n        # Test with a known test vector for SHA256\n        key = b'key'\n        message = b'The quick brown fox jumps over the lazy dog'\n        expected = bytes.fromhex('f7bc83f430538424b13298e6aa6fb143ef4d59a14946175997479dbc2d1a3cd8')\n        result = sign_message('sha256', message, key)\n        self.assertEqual(result, expected)\n\n    def test_integrity(self):\n        # Test that changing the message or key changes the digest\n        key = b'key'\n        message = b'The quick brown fox jumps over the lazy dog'\n        result1 = sign_message('sha256', message, key)\n        result2 = sign_message('sha256', message + b'.', key)\n        self.assertNotEqual(result1, result2)\n        result3 = sign_message('sha256', message, key + b'.')\n        self.assertNotEqual(result1, result3)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 8, "task_id": "00f42e0d"}
{"test": "import unittest\nfrom unittest.mock import patch\nimport hashlib\n\nclass TestCalcHash(unittest.TestCase):\n\n    def test_sha256(self):\n        # Test with safe algorithm (sha256) and non-empty data\n        data = b'hello world'\n        expected = hashlib.new('sha256', data).digest()\n        result = calc_hash('sha256', data)\n        self.assertEqual(result, expected)\n\n    def test_sha256_empty_data(self):\n        # Test with safe algorithm (sha256) and empty data\n        data = b''\n        expected = hashlib.new('sha256', data).digest()\n        result = calc_hash('sha256', data)\n        self.assertEqual(result, expected)\n\n    def test_sha512(self):\n        # Test with safe algorithm (sha512) and non-empty data\n        data = b'data to hash'\n        expected = hashlib.new('sha512', data).digest()\n        result = calc_hash('sha512', data)\n        self.assertEqual(result, expected)\n\n    def test_sha384(self):\n        # Test with safe algorithm (sha384) and non-empty data\n        data = b'test data'\n        expected = hashlib.new('sha384', data).digest()\n        result = calc_hash('sha384', data)\n        self.assertEqual(result, expected)\n\n    def test_blake2s(self):\n        # Test with safe algorithm (blake2s) and non-empty data\n        data = b'foo bar baz'\n        expected = hashlib.new('blake2s', data).digest()\n        result = calc_hash('blake2s', data)\n        self.assertEqual(result, expected)\n\n    def test_md5_unsafe(self):\n        # Test with available but unsafe algorithm (md5)\n        data = b'password'\n        with self.assertRaises(ValueError) as context:\n            calc_hash('md5', data)\n        self.assertEqual(str(context.exception), 'Hash algorithm md5 is not available')\n\n    def test_sha1_unsafe(self):\n        # Test with available but unsafe algorithm (sha1)\n        data = b'secret'\n        with self.assertRaises(ValueError) as context:\n            calc_hash('sha1', data)\n        self.assertEqual(str(context.exception), 'Hash algorithm sha1 is not available')\n\n    def test_sha224_unsafe(self):\n        # Test with available algorithm not in safe list (sha224)\n        data = b'value'\n        with self.assertRaises(ValueError) as context:\n            calc_hash('sha224', data)\n        self.assertEqual(str(context.exception), 'Hash algorithm sha224 is not available')\n\n    def test_nonexistent_algorithm(self):\n        # Test with completely unavailable algorithm\n        data = b'input'\n        with self.assertRaises(ValueError) as context:\n            calc_hash('non_existent_hash', data)\n        self.assertEqual(str(context.exception), 'Hash algorithm non_existent_hash is not available')\n\n    def test_sha244_in_safe_but_unavailable(self):\n        # Test with algorithm in safe list but unavailable in hashlib\n        data = b'test'\n        with patch('hashlib.algorithms_available', new={'sha256', 'sha512', 'sha384', 'blake2s'}):\n            with self.assertRaises(ValueError) as context:\n                calc_hash('sha244', data)\n            self.assertEqual(str(context.exception), 'Hash algorithm sha244 is not available')\n\n    def test_large_input(self):\n        # Test with very large data input\n        data = b'A' * 1000000  # 1MB\n        result = calc_hash('sha256', data)\n        expected = hashlib.new('sha256', data).digest()\n        self.assertEqual(result, expected)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 11, "task_id": "ca0d7e31"}
{"test": "import unittest\\nimport string\\n\\nclass TestCreateResetKey(unittest.TestCase):\\n    def test_valid_size(self):\\n        # Test typical size: 10\\n        result = create_reset_key(10)\\n        self.assertEqual(len(result), 10)\\n        for char in result:\\n            self.assertIn(char, string.ascii_letters + string.digits)\\n\\n    def test_size_zero(self):\\n        # Test edge case: size 0\\n        result = create_reset_key(0)\\n        self.assertEqual(result, '')\\n\\n    def test_size_one(self):\\n        # Test edge case: size 1\\n        result = create_reset_key(1)\\n        self.assertEqual(len(result), 1)\\n        self.assertIn(result, string.ascii_letters + string.digits)\\n\\n    def test_large_size(self):\\n        # Test large size: 1000\\n        result = create_reset_key(1000)\\n        self.assertEqual(len(result), 1000)\\n        for char in result:\\n            self.assertIn(char, string.ascii_letters + string.digits)\\n\\n    def test_negative_size(self):\\n        # Test negative size: -10\\n        result = create_reset_key(-10)\\n        self.assertEqual(result, '')\\n\\n    def test_float_size(self):\\n        # Test invalid type: float\\n        with self.assertRaises(TypeError):\\n            create_reset_key(10.5)\\n\\n    def test_string_size(self):\\n        # Test invalid type: string\\n        with self.assertRaises(TypeError):\\n            create_reset_key('10')\\n\\n    def test_none_size(self):\\n        # Test invalid type: None\\n        with self.assertRaises(TypeError):\\n            create_reset_key(None)\\n\\n    def test_randomness(self):\\n        # Test randomness: two calls produce different results\\n        size = 10\\n        result1 = create_reset_key(size)\\n        result2 = create_reset_key(size)\\n        self.assertNotEqual(result1, result2)\\n", "num_test_cases": 9, "task_id": "376a3425"}
{"test": "import unittest\nimport string\n\nclass TestCases(unittest.TestCase):\n    def test_case_1(self):\n        # Test typical positive count (length 10)\n        count = 10\n        result = generate_token_code(count)\n        self.assertEqual(len(result), count)\n        allowed_chars = string.ascii_letters + string.digits\n        for char in result:\n            self.assertIn(char, allowed_chars)\n    \n    def test_case_2(self):\n        # Test zero count (empty string)\n        count = 0\n        result = generate_token_code(count)\n        self.assertEqual(result, '')\n        self.assertEqual(len(result), count)\n    \n    def test_case_3(self):\n        # Test negative count (returns empty string)\n        count = -5\n        result = generate_token_code(count)\n        self.assertEqual(result, '')\n        self.assertEqual(len(result), 0)\n    \n    def test_case_4(self):\n        # Test minimum positive count (length 1)\n        count = 1\n        result = generate_token_code(count)\n        self.assertEqual(len(result), count)\n        allowed_chars = string.ascii_letters + string.digits\n        self.assertIn(result, allowed_chars)\n    \n    def test_case_5(self):\n        # Test large count (length 1000)\n        count = 1000\n        result = generate_token_code(count)\n        self.assertEqual(len(result), count)\n        allowed_chars = string.ascii_letters + string.digits\n        for char in result:\n            self.assertIn(char, allowed_chars)", "num_test_cases": 5, "task_id": "09f38a88"}
{"test": "import unittest\nimport string\n\nclass TestCreateVerificationCode(unittest.TestCase):\n\n    def test_positive_length(self):\n        # Test with a standard positive integer\n        result = create_verification_code(8)\n        self.assertEqual(len(result), 8)\n        for char in result:\n            self.assertIn(char, string.ascii_letters + string.digits)\n\n    def test_zero_length(self):\n        # Test with zero length\n        result = create_verification_code(0)\n        self.assertEqual(result, '')\n\n    def test_negative_length(self):\n        # Test with negative length\n        result = create_verification_code(-5)\n        self.assertEqual(result, '')\n\n    def test_large_length(self):\n        # Test with a very large positive length\n        result = create_verification_code(10000)\n        self.assertEqual(len(result), 10000)\n        for char in result:\n            self.assertIn(char, string.ascii_letters + string.digits)\n\n    def test_length_one(self):\n        # Test with minimum positive length\n        result = create_verification_code(1)\n        self.assertEqual(len(result), 1)\n        self.assertIn(result, string.ascii_letters + string.digits)\n\n    def test_float_input(self):\n        # Test with non-integer (float)\n        with self.assertRaises(TypeError):\n            create_verification_code(8.0)\n\n    def test_string_input(self):\n        # Test with non-integer (string)\n        with self.assertRaises(TypeError):\n            create_verification_code('8')", "num_test_cases": 7, "task_id": "052e0eaf"}
{"test": "import unittest\nimport string\n\nclass TestCreateResetKey(unittest.TestCase):\n    \n    def test_case_1(self):\n        # Test typical positive size: length 10, all chars in expected alphabet.\n        result = create_reset_key(10)\n        self.assertIsInstance(result, str)\n        self.assertEqual(len(result), 10)\n        for char in result:\n            self.assertIn(char, string.ascii_letters + string.digits)\n            \n    def test_case_2(self):\n        # Test size 0 returns empty string.\n        result = create_reset_key(0)\n        self.assertEqual(result, '')\n        self.assertEqual(len(result), 0)\n        \n    def test_case_3(self):\n        # Test size 1: single character in expected alphabet.\n        result = create_reset_key(1)\n        self.assertIsInstance(result, str)\n        self.assertEqual(len(result), 1)\n        self.assertIn(result, string.ascii_letters + string.digits)\n        \n    def test_case_4(self):\n        # Test large size (1000): length and character validation.\n        result = create_reset_key(1000)\n        self.assertIsInstance(result, str)\n        self.assertEqual(len(result), 1000)\n        for char in result:\n            self.assertIn(char, string.ascii_letters + string.digits)\n            \n    def test_case_5(self):\n        # Test negative size returns empty string.\n        result = create_reset_key(-5)\n        self.assertEqual(result, '')\n        self.assertEqual(len(result), 0)\n        \n    def test_case_6(self):\n        # Test non-integer (string) input raises TypeError.\n        with self.assertRaises(TypeError):\n            create_reset_key('10')\n            \n    def test_case_7(self):\n        # Test non-integer (float) input raises TypeError.\n        with self.assertRaises(TypeError):\n            create_reset_key(5.5)\n            \n    def test_case_8(self):\n        # Test non-integer (None) input raises TypeError.\n        with self.assertRaises(TypeError):\n            create_reset_key(None)", "num_test_cases": 8, "task_id": "51dd5f2b"}
{"test": "import unittest\nimport string\n\nclass TestCases(unittest.TestCase):\n    def test_case_1(self):\n        # Test typical case with valid positive size\n        key = generate_temp_key(10)\n        self.assertEqual(len(key), 10)\n        for char in key:\n            self.assertIn(char, string.ascii_letters + string.digits)\n            \n    def test_case_2(self):\n        # Test with zero length\n        key = generate_temp_key(0)\n        self.assertEqual(key, '')\n        \n    def test_case_3(self):\n        # Test minimal non-zero length\n        key = generate_temp_key(1)\n        self.assertEqual(len(key), 1)\n        self.assertIn(key, string.ascii_letters + string.digits)\n        \n    def test_case_4(self):\n        # Test large length\n        key = generate_temp_key(1000)\n        self.assertEqual(len(key), 1000)\n        for char in key:\n            self.assertIn(char, string.ascii_letters + string.digits)\n        \n    def test_case_5(self):\n        # Test negative length (returns empty string)\n        key = generate_temp_key(-5)\n        self.assertEqual(key, '')\n        \n    def test_case_6(self):\n        # Test generated keys are unique across calls\n        key1 = generate_temp_key(10)\n        key2 = generate_temp_key(10)\n        self.assertNotEqual(key1, key2)\n        \n    def test_case_7(self):\n        # Test very large length\n        key = generate_temp_key(10000)\n        self.assertEqual(len(key), 10000)\n        for char in key:\n            self.assertIn(char, string.ascii_letters + string.digits)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 7, "task_id": "321792be"}
{"test": "import unittest\nimport string\n\nclass TestCreatePasswordToken(unittest.TestCase):\n    def test_valid_token_size(self):\n        # Test typical token size (10)\n        token = create_password_token(10)\n        self.assertEqual(len(token), 10)\n        for char in token:\n            self.assertIn(char, string.ascii_letters + string.digits)\n\n    def test_zero_token_size(self):\n        # Test token_size=0 (should return empty string)\n        token = create_password_token(0)\n        self.assertEqual(token, '')\n        self.assertEqual(len(token), 0)\n\n    def test_smallest_token_size(self):\n        # Test minimum token_size=1\n        token = create_password_token(1)\n        self.assertEqual(len(token), 1)\n        self.assertIn(token, string.ascii_letters + string.digits)\n\n    def test_large_token_size(self):\n        # Test large token_size=1000\n        token = create_password_token(1000)\n        self.assertEqual(len(token), 1000)\n        for char in token:\n            self.assertIn(char, string.ascii_letters + string.digits)\n\n    def test_negative_token_size(self):\n        # Test negative token_size (should return empty string)\n        token = create_password_token(-10)\n        self.assertEqual(token, '')\n        self.assertEqual(len(token), 0)\n\n    def test_float_token_size(self):\n        # Test float token_size (should raise TypeError)\n        with self.assertRaises(TypeError):\n            create_password_token(5.5)\n\n    def test_string_token_size(self):\n        # Test string token_size (should raise TypeError)\n        with self.assertRaises(TypeError):\n            create_password_token(\"abc\")\n\n    def test_digit_string_token_size(self):\n        # Test digit string token_size (should raise TypeError)\n        with self.assertRaises(TypeError):\n            create_password_token(\"10\")\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 8, "task_id": "79a6d265"}
{"test": "import unittest\nimport string\n\nclass TestCreateRecoveryToken(unittest.TestCase):\n\n    def test_positive_size(self):\n        # Typical case: positive integer size (10)\n        size = 10\n        token = create_recovery_token(size)\n        self.assertIsInstance(token, str)\n        self.assertEqual(len(token), size)\n        for char in token:\n            self.assertIn(char, string.ascii_letters + string.digits)\n\n    def test_zero_size(self):\n        # Edge case: size 0\n        size = 0\n        token = create_recovery_token(size)\n        self.assertEqual(token, '')\n        self.assertEqual(len(token), 0)\n\n    def test_size_one(self):\n        # Edge case: size 1\n        size = 1\n        token = create_recovery_token(size)\n        self.assertEqual(len(token), 1)\n        self.assertIn(token, string.ascii_letters + string.digits)\n\n    def test_large_size(self):\n        # Edge case: large size (1000)\n        size = 1000\n        token = create_recovery_token(size)\n        self.assertEqual(len(token), size)\n        for char in token:\n            self.assertIn(char, string.ascii_letters + string.digits)\n\n    def test_negative_size(self):\n        # Edge case: negative size\n        size = -5\n        token = create_recovery_token(size)\n        self.assertEqual(token, '')\n        self.assertEqual(len(token), 0)\n\n    def test_non_integer_string(self):\n        # Error: non-integer (string)\n        with self.assertRaises(TypeError):\n            create_recovery_token('10')\n\n    def test_non_integer_float(self):\n        # Error: non-integer (float)\n        with self.assertRaises(TypeError):\n            create_recovery_token(10.0)\n\n    def test_non_integer_none(self):\n        # Error: non-integer (None)\n        with self.assertRaises(TypeError):\n            create_recovery_token(None)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 8, "task_id": "ef9a1b2d"}
{"test": "import unittest\nimport string\n\nclass TestGeneratePasswordToken(unittest.TestCase):\n    def test_normal_length(self):\n        \"\"\"Test typical token length with valid input.\"\"\"\n        token = generate_password_token(8)\n        self.assertEqual(len(token), 8)\n        for char in token:\n            self.assertIn(char, string.ascii_letters + string.digits)\n\n    def test_zero_length(self):\n        \"\"\"Test token_length=0 returns empty string.\"\"\"\n        token = generate_password_token(0)\n        self.assertEqual(token, '')\n        self.assertEqual(len(token), 0)\n\n    def test_single_character(self):\n        \"\"\"Test token_length=1 returns one valid character.\"\"\"\n        token = generate_password_token(1)\n        self.assertEqual(len(token), 1)\n        self.assertIn(token, string.ascii_letters + string.digits)\n\n    def test_large_length(self):\n        \"\"\"Test large token_length (1000) returns correct length and valid characters.\"\"\"\n        token = generate_password_token(1000)\n        self.assertEqual(len(token), 1000)\n        for char in token:\n            self.assertIn(char, string.ascii_letters + string.digits)\n\n    def test_very_large_length(self):\n        \"\"\"Test very large token_length (10000) returns correct length and valid characters.\"\"\"\n        token = generate_password_token(10000)\n        self.assertEqual(len(token), 10000)\n        for char in token:\n            self.assertIn(char, string.ascii_letters + string.digits)\n\n    def test_negative_length(self):\n        \"\"\"Test negative token_length returns empty string.\"\"\"\n        token = generate_password_token(-5)\n        self.assertEqual(token, '')\n        self.assertEqual(len(token), 0)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 6, "task_id": "49b765ba"}
{"test": "import unittest\nimport string\n\nclass TestCreateVerificationCode(unittest.TestCase):\n\n    def test_basic_functionality(self):\n        # Test typical case: code_length=8\n        code = create_verification_code(8)\n        self.assertIsInstance(code, str)\n        self.assertEqual(len(code), 8)\n        for char in code:\n            self.assertIn(char, string.ascii_letters + string.digits)\n\n    def test_zero_length(self):\n        # Test edge case: code_length=0\n        code = create_verification_code(0)\n        self.assertEqual(code, '')\n\n    def test_length_one(self):\n        # Test edge case: code_length=1\n        code = create_verification_code(1)\n        self.assertEqual(len(code), 1)\n        self.assertIn(code, string.ascii_letters + string.digits)\n\n    def test_large_length(self):\n        # Test large code_length (1000)\n        code = create_verification_code(1000)\n        self.assertEqual(len(code), 1000)\n        for char in code:\n            self.assertIn(char, string.ascii_letters + string.digits)\n\n    def test_negative_length(self):\n        # Test negative code_length\n        code = create_verification_code(-5)\n        self.assertEqual(code, '')\n\n    def test_non_integer_string(self):\n        # Test non-integer input (string)\n        with self.assertRaises(TypeError):\n            create_verification_code('8')\n\n    def test_non_integer_float(self):\n        # Test non-integer input (float)\n        with self.assertRaises(TypeError):\n            create_verification_code(8.0)\n\n    def test_non_integer_none(self):\n        # Test non-integer input (None)\n        with self.assertRaises(TypeError):\n            create_verification_code(None)\n\n    def test_character_set(self):\n        # Test generated characters are in the expected alphabet\n        code = create_verification_code(50)\n        for char in code:\n            self.assertIn(char, string.ascii_letters + string.digits)", "num_test_cases": 9, "task_id": "ccec7d50"}
{"test": "import unittest\nimport string\n\nclass TestGenerateAccessToken(unittest.TestCase):\n    \n    def test_typical_length(self):\n        # Test with typical valid length (16)\n        token = generate_access_token(16)\n        self.assertIsInstance(token, str)\n        self.assertEqual(len(token), 16)\n        allowed_chars = string.ascii_letters + string.digits + string.punctuation\n        for char in token:\n            self.assertIn(char, allowed_chars)\n    \n    def test_zero_length(self):\n        # Test with zero length\n        token = generate_access_token(0)\n        self.assertEqual(token, '')\n        self.assertEqual(len(token), 0)\n    \n    def test_negative_length(self):\n        # Test with negative length\n        token = generate_access_token(-5)\n        self.assertEqual(token, '')\n        self.assertEqual(len(token), 0)\n    \n    def test_minimum_positive_length(self):\n        # Test with minimum positive length (1)\n        token = generate_access_token(1)\n        self.assertEqual(len(token), 1)\n        allowed_chars = string.ascii_letters + string.digits + string.punctuation\n        self.assertIn(token, allowed_chars)\n    \n    def test_large_length(self):\n        # Test with very large length\n        token = generate_access_token(10000)\n        self.assertEqual(len(token), 10000)\n        allowed_chars = string.ascii_letters + string.digits + string.punctuation\n        for char in token[:1000] + token[-1000:]:  # Check sample of characters\n            self.assertIn(char, allowed_chars)\n    \n    def test_string_input(self):\n        # Test with string input (non-integer)\n        with self.assertRaises(TypeError):\n            generate_access_token('16')\n    \n    def test_float_input(self):\n        # Test with float input\n        with self.assertRaises(TypeError):\n            generate_access_token(16.0)\n    \n    def test_none_input(self):\n        # Test with None input\n        with self.assertRaises(TypeError):\n            generate_access_token(None)\n    \n    def test_character_set_coverage(self):\n        # Test generated token contains all character types\n        token = generate_access_token(100)\n        has_letter = any(char in string.ascii_letters for char in token)\n        has_digit = any(char in string.digits for char in token)\n        has_punct = any(char in string.punctuation for char in token)\n        self.assertTrue(has_letter or has_digit or has_punct, \"Token should contain letters, digits, or punctuation\")\n    \n    def test_uniqueness(self):\n        # Test generated tokens are unique\n        tokens = [generate_access_token(16) for _ in range(5)]\n        self.assertEqual(len(tokens), len(set(tokens)), \"Generated tokens should be unique\")", "num_test_cases": 10, "task_id": "07706a98"}
{"test": "import unittest\nimport string\n\nclass TestGenerateSecurityToken(unittest.TestCase):\n    def test_typical_key_size(self):\n        # Test with typical key size (16)\n        key_size = 16\n        token = generate_security_token(key_size)\n        self.assertEqual(len(token), key_size)\n        for char in token:\n            self.assertIn(char, string.ascii_letters + string.digits + string.punctuation)\n\n    def test_single_character(self):\n        # Test with key_size=1\n        key_size = 1\n        token = generate_security_token(key_size)\n        self.assertEqual(len(token), key_size)\n        for char in token:\n            self.assertIn(char, string.ascii_letters + string.digits + string.punctuation)\n\n    def test_zero_key_size(self):\n        # Test with key_size=0 -> empty string\n        key_size = 0\n        token = generate_security_token(key_size)\n        self.assertEqual(token, \"\")\n        self.assertEqual(len(token), 0)\n\n    def test_negative_key_size(self):\n        # Test with negative key_size -> empty string\n        key_size = -10\n        token = generate_security_token(key_size)\n        self.assertEqual(token, \"\")\n        self.assertEqual(len(token), 0)\n\n    def test_large_key_size(self):\n        # Test with large key_size (100)\n        key_size = 100\n        token = generate_security_token(key_size)\n        self.assertEqual(len(token), key_size)\n        for char in token:\n            self.assertIn(char, string.ascii_letters + string.digits + string.punctuation)\n\n    def test_randomness(self):\n        # Test that consecutive tokens are different\n        key_size = 16\n        token1 = generate_security_token(key_size)\n        token2 = generate_security_token(key_size)\n        self.assertNotEqual(token1, token2)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 6, "task_id": "10c83acb"}
{"test": "import unittest\nimport string\n\nclass TestGenerateSessionToken(unittest.TestCase):\n\n    def test_typical_length(self):\n        \"\"\"Test generation with typical token length (32).\"\"\"\n        token = generate_session_token(32)\n        self.assertEqual(len(token), 32)\n        allowed_chars = string.ascii_letters + string.digits + string.punctuation\n        for char in token:\n            self.assertIn(char, allowed_chars)\n\n    def test_zero_length(self):\n        \"\"\"Test edge case: token_len=0 returns empty string.\"\"\"\n        token = generate_session_token(0)\n        self.assertEqual(token, '')\n\n    def test_negative_length(self):\n        \"\"\"Test edge case: negative token_len returns empty string.\"\"\"\n        token = generate_session_token(-10)\n        self.assertEqual(token, '')\n\n    def test_single_character(self):\n        \"\"\"Test minimum non-zero length (1).\"\"\"\n        token = generate_session_token(1)\n        self.assertEqual(len(token), 1)\n        allowed_chars = string.ascii_letters + string.digits + string.punctuation\n        self.assertIn(token, allowed_chars)\n\n    def test_large_length(self):\n        \"\"\"Test large token length (1000).\"\"\"\n        token = generate_session_token(1000)\n        self.assertEqual(len(token), 1000)\n        allowed_chars = string.ascii_letters + string.digits + string.punctuation\n        for char in token:\n            self.assertIn(char, allowed_chars)\n\n    def test_token_uniqueness(self):\n        \"\"\"Test generated tokens are unique.\"\"\"\n        tokens = {generate_session_token(16) for _ in range(10)}\n        self.assertEqual(len(tokens), 10)\n\n    def test_character_distribution(self):\n        \"\"\"Test all character types appear in a sufficiently long token.\"\"\"\n        token = generate_session_token(1000)\n        self.assertTrue(any(char in string.ascii_letters for char in token))\n        self.assertTrue(any(char in string.digits for char in token))\n        self.assertTrue(any(char in string.punctuation for char in token))", "num_test_cases": 7, "task_id": "a80237c7"}
{"test": "import unittest\nimport string\n\nclass TestGenerateSecureToken(unittest.TestCase):\n\n    def test_typical_token(self):\n        \"\"\"Test typical token generation with valid size.\"\"\"\n        token = generate_secure_token(16)\n        self.assertEqual(len(token), 16)\n        allowed_chars = string.ascii_letters + string.digits + string.punctuation\n        for char in token:\n            self.assertIn(char, allowed_chars)\n\n    def test_zero_token_size(self):\n        \"\"\"Test token generation with size 0 returns empty string.\"\"\"\n        token = generate_secure_token(0)\n        self.assertEqual(token, '')\n        self.assertEqual(len(token), 0)\n\n    def test_negative_token_size(self):\n        \"\"\"Test negative token size returns empty string.\"\"\"\n        token = generate_secure_token(-10)\n        self.assertEqual(token, '')\n        self.assertEqual(len(token), 0)\n\n    def test_large_token_size(self):\n        \"\"\"Test very large token size (1024) generates correct length and valid characters.\"\"\"\n        token_size = 1024\n        token = generate_secure_token(token_size)\n        self.assertEqual(len(token), token_size)\n        allowed_chars = string.ascii_letters + string.digits + string.punctuation\n        for char in token:\n            self.assertIn(char, allowed_chars)\n\n    def test_single_character_token(self):\n        \"\"\"Test token size 1 returns single valid character.\"\"\"\n        token = generate_secure_token(1)\n        self.assertEqual(len(token), 1)\n        allowed_chars = string.ascii_letters + string.digits + string.punctuation\n        self.assertIn(token, allowed_chars)\n\n    def test_non_integer_token_size(self):\n        \"\"\"Test non-integer token size raises TypeError.\"\"\"\n        with self.assertRaises(TypeError):\n            generate_secure_token('abc')\n\n    def test_float_token_size(self):\n        \"\"\"Test float token size raises TypeError.\"\"\"\n        with self.assertRaises(TypeError):\n            generate_secure_token(16.5)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 7, "task_id": "a96e2162"}
{"test": "import unittest\nimport string\n\nclass TestBuildSecureToken(unittest.TestCase):\n    def test_positive_length(self):\n        \"\"\"Test typical positive length token generation.\"\"\"\n        length = 16\n        token = build_secure_token(length)\n        self.assertEqual(len(token), length)\n        allowed_chars = string.ascii_letters + string.digits + string.punctuation\n        for char in token:\n            self.assertIn(char, allowed_chars)\n            \n    def test_zero_length(self):\n        \"\"\"Test token generation with zero length.\"\"\"\n        token = build_secure_token(0)\n        self.assertEqual(token, '')\n        self.assertEqual(len(token), 0)\n        \n    def test_negative_length(self):\n        \"\"\"Test token generation with negative length (should return empty string).\"\"\"\n        token = build_secure_token(-10)\n        self.assertEqual(token, '')\n        self.assertEqual(len(token), 0)\n        \n    def test_non_integer_input_string(self):\n        \"\"\"Test with string input (should raise TypeError).\"\"\"\n        with self.assertRaises(TypeError):\n            build_secure_token('16')\n            \n    def test_float_input_non_integer(self):\n        \"\"\"Test with non-integer float input (should raise TypeError).\"\"\"\n        with self.assertRaises(TypeError):\n            build_secure_token(10.5)\n            \n    def test_float_input_integer(self):\n        \"\"\"Test with integer float input (should raise TypeError).\"\"\"\n        with self.assertRaises(TypeError):\n            build_secure_token(10.0)\n            \n    def test_very_large_length(self):\n        \"\"\"Test token generation with very large length.\"\"\"\n        length = 10000\n        token = build_secure_token(length)\n        self.assertEqual(len(token), length)\n        allowed_chars = string.ascii_letters + string.digits + string.punctuation\n        for char in token:\n            self.assertIn(char, allowed_chars)", "num_test_cases": 7, "task_id": "2e31a3f9"}
{"test": "import unittest\nimport string\n\n# Import the function from the module where it is defined\nfrom solution import generate_auth_token\n\nclass TestGenerateAuthToken(unittest.TestCase):\n    \n    def assert_valid_token(self, token):\n        \"\"\"Helper method to validate the token against the allowed character set.\"\"\"\n        allowed_chars = string.ascii_letters + string.digits + string.punctuation\n        allowed_set = set(allowed_chars)\n        invalid_chars = set(token) - allowed_set\n        self.assertFalse(invalid_chars, f\"Token contains invalid characters: {invalid_chars}\")\n\n    def test_case_1(self):\n        # Typical case: token_length=16\n        token_length = 16\n        token = generate_auth_token(token_length)\n        self.assertEqual(len(token), token_length)\n        self.assert_valid_token(token)\n\n    def test_case_2(self):\n        # Minimum non-zero token_length=1\n        token_length = 1\n        token = generate_auth_token(token_length)\n        self.assertEqual(len(token), token_length)\n        self.assert_valid_token(token)\n\n    def test_case_3(self):\n        # Token_length=0 -> empty string\n        token_length = 0\n        token = generate_auth_token(token_length)\n        self.assertEqual(token, \"\")\n        self.assert_valid_token(token)  # Validates empty string is handled\n\n    def test_case_4(self):\n        # Large token_length=1000\n        token_length = 1000\n        token = generate_auth_token(token_length)\n        self.assertEqual(len(token), token_length)\n        self.assert_valid_token(token)\n\n    def test_case_5(self):\n        # Negative token_length -> returns empty string\n        token_length = -5\n        token = generate_auth_token(token_length)\n        self.assertEqual(token, \"\")\n\n    def test_case_6(self):\n        # Non-integer token_length: string\n        with self.assertRaises(TypeError):\n            generate_auth_token(\"10\")\n\n    def test_case_7(self):\n        # Non-integer token_length: float\n        with self.assertRaises(TypeError):\n            generate_auth_token(10.5)\n\n    def test_case_8(self):\n        # Non-integer token_length: None\n        with self.assertRaises(TypeError):\n            generate_auth_token(None)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 8, "task_id": "12994a50"}
{"test": "import unittest\nimport string\n\nclass TestGenerateAuthToken(unittest.TestCase):\n    def setUp(self):\n        self.allowed_chars = string.ascii_letters + string.digits + string.punctuation\n        self.allowed_set = set(self.allowed_chars)\n\n    def test_size_1(self):\n        # Test with size 1: check length and character set.\n        token = generate_auth_token(1)\n        self.assertIsInstance(token, str)\n        self.assertEqual(len(token), 1)\n        self.assertTrue(set(token).issubset(self.allowed_set), f'Token contains invalid characters: {set(token) - self.allowed_set}')\n\n    def test_size_16(self):\n        # Test with size 16: check length and character set.\n        token = generate_auth_token(16)\n        self.assertIsInstance(token, str)\n        self.assertEqual(len(token), 16)\n        self.assertTrue(set(token).issubset(self.allowed_set), f'Token contains invalid characters: {set(token) - self.allowed_set}')\n\n    def test_size_0(self):\n        # Test with size 0: returns empty string.\n        token = generate_auth_token(0)\n        self.assertEqual(token, '')\n        self.assertEqual(len(token), 0)\n\n    def test_negative_size(self):\n        # Test with negative size: returns empty string.\n        token = generate_auth_token(-5)\n        self.assertEqual(token, '')\n        self.assertEqual(len(token), 0)\n\n    def test_non_integer_inputs(self):\n        # Test with non-integer inputs (string, float, None): raise TypeError.\n        inputs = ['10', 10.5, None]\n        for inp in inputs:\n            with self.subTest(input=inp):\n                with self.assertRaises(TypeError):\n                    generate_auth_token(inp)\n\n    def test_large_size(self):\n        # Test with very large size (1000): check length and character set.\n        token = generate_auth_token(1000)\n        self.assertIsInstance(token, str)\n        self.assertEqual(len(token), 1000)\n        self.assertTrue(set(token).issubset(self.allowed_set), f'Token contains invalid characters: {set(token) - self.allowed_set}')\n\n    def test_randomness(self):\n        # Test randomness: two tokens of size 10 are not equal.\n        token1 = generate_auth_token(10)\n        token2 = generate_auth_token(10)\n        self.assertNotEqual(token1, token2)\n", "num_test_cases": 7, "task_id": "5fc16759"}
{"test": "import unittest\nimport string\n\nclass TestGenerateSecureKey(unittest.TestCase):\n    def test_typical_lengths(self):\n        \"\"\"Test generation with typical key lengths (16, 32, 64).\"\"\"\n        for length in [16, 32, 64]:\n            key = generate_secure_key(length)\n            self.assertIsInstance(key, str)\n            self.assertEqual(len(key), length)\n            for char in key:\n                self.assertIn(char, string.ascii_letters + string.digits + string.punctuation)\n    \n    def test_zero_length(self):\n        \"\"\"Test key generation with length 0 returns empty string.\"\"\"\n        key = generate_secure_key(0)\n        self.assertEqual(key, '')\n    \n    def test_single_character(self):\n        \"\"\"Test key generation with length 1.\"\"\"\n        key = generate_secure_key(1)\n        self.assertEqual(len(key), 1)\n        self.assertIn(key, string.ascii_letters + string.digits + string.punctuation)\n    \n    def test_large_length(self):\n        \"\"\"Test generation of a large key (length=1000).\"\"\"\n        key = generate_secure_key(1000)\n        self.assertEqual(len(key), 1000)\n        for char in key:\n            self.assertIn(char, string.ascii_letters + string.digits + string.punctuation)\n    \n    def test_negative_length(self):\n        \"\"\"Test negative length returns empty string.\"\"\"\n        key = generate_secure_key(-5)\n        self.assertEqual(key, '')\n    \n    def test_non_integer_string(self):\n        \"\"\"Test non-integer input (string) raises TypeError.\"\"\"\n        with self.assertRaises(TypeError):\n            generate_secure_key('16')\n    \n    def test_non_integer_float(self):\n        \"\"\"Test non-integer input (float) raises TypeError.\"\"\"\n        with self.assertRaises(TypeError):\n            generate_secure_key(16.0)\n    \n    def test_randomness(self):\n        \"\"\"Test generated keys are different (probabilistic).\"\"\"\n        key1 = generate_secure_key(32)\n        key2 = generate_secure_key(32)\n        self.assertNotEqual(key1, key2)", "num_test_cases": 8, "task_id": "2ebf2ef6"}
{"test": "import unittest\nimport string\n\nclass TestGenerateApiToken(unittest.TestCase):\n    def test_case_1(self):\n        # Test key_size = 0 (empty token)\n        token = generate_api_token(0)\n        self.assertEqual(token, \"\")\n        self.assertEqual(len(token), 0)\n\n    def test_case_2(self):\n        # Test key_size = 1 (single character token)\n        token = generate_api_token(1)\n        self.assertEqual(len(token), 1)\n        allowed_chars = string.ascii_letters + string.digits + string.punctuation\n        self.assertIn(token, allowed_chars)\n\n    def test_case_3(self):\n        # Test key_size = 10 (typical token)\n        key_size = 10\n        token = generate_api_token(key_size)\n        self.assertEqual(len(token), key_size)\n        allowed_chars = string.ascii_letters + string.digits + string.punctuation\n        for char in token:\n            self.assertIn(char, allowed_chars)\n\n    def test_case_4(self):\n        # Test key_size = -1 (negative input)\n        token = generate_api_token(-1)\n        self.assertEqual(token, \"\")\n        self.assertEqual(len(token), 0)\n\n    def test_case_5(self):\n        # Test key_size = 100 (large token)\n        key_size = 100\n        token = generate_api_token(key_size)\n        self.assertEqual(len(token), key_size)\n        allowed_chars = string.ascii_letters + string.digits + string.punctuation\n        for char in token:\n            self.assertIn(char, allowed_chars)\n\n    def test_case_6(self):\n        # Test two tokens of length 32 are different (randomness)\n        key_size = 32\n        token1 = generate_api_token(key_size)\n        token2 = generate_api_token(key_size)\n        self.assertEqual(len(token1), key_size)\n        self.assertEqual(len(token2), key_size)\n        self.assertNotEqual(token1, token2)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 6, "task_id": "76c72800"}
{"test": "import unittest\n\nclass TestCreateAESKey(unittest.TestCase):\n    def test_valid_128_bit(self):\n        # Test valid 128-bit key\n        key = create_aes_key(128)\n        self.assertIsInstance(key, str)\n        self.assertEqual(len(key), 32)\n\n    def test_valid_192_bit(self):\n        # Test valid 192-bit key\n        key = create_aes_key(192)\n        self.assertIsInstance(key, str)\n        self.assertEqual(len(key), 48)\n\n    def test_valid_256_bit(self):\n        # Test valid 256-bit key\n        key = create_aes_key(256)\n        self.assertIsInstance(key, str)\n        self.assertEqual(len(key), 64)\n\n    def test_invalid_negative(self):\n        # Test negative integer input\n        with self.assertRaises(ValueError):\n            create_aes_key(-128)\n\n    def test_invalid_zero(self):\n        # Test zero input\n        with self.assertRaises(ValueError):\n            create_aes_key(0)\n\n    def test_invalid_100(self):\n        # Test invalid positive integer (100)\n        with self.assertRaises(ValueError):\n            create_aes_key(100)\n\n    def test_invalid_200(self):\n        # Test invalid positive integer (200)\n        with self.assertRaises(ValueError):\n            create_aes_key(200)\n\n    def test_invalid_300(self):\n        # Test invalid positive integer (300)\n        with self.assertRaises(ValueError):\n            create_aes_key(300)\n\n    def test_float_128(self):\n        # Test float input of valid value (128.0) - invalid type\n        with self.assertRaises(TypeError):\n            create_aes_key(128.0)\n\n    def test_float_192(self):\n        # Test float input of valid value (192.0) - invalid type\n        with self.assertRaises(TypeError):\n            create_aes_key(192.0)\n\n    def test_float_256(self):\n        # Test float input of valid value (256.0) - invalid type\n        with self.assertRaises(TypeError):\n            create_aes_key(256.0)\n\n    def test_float_129(self):\n        # Test float input of invalid value (129.0)\n        with self.assertRaises(ValueError):\n            create_aes_key(129.0)\n\n    def test_string_128(self):\n        # Test string input of valid number ('128')\n        with self.assertRaises(ValueError):\n            create_aes_key('128')\n\n    def test_string_abc(self):\n        # Test non-numeric string input ('abc')\n        with self.assertRaises(ValueError):\n            create_aes_key('abc')\n\n    def test_none_input(self):\n        # Test None input\n        with self.assertRaises(ValueError):\n            create_aes_key(None)\n\n    def test_list_input(self):\n        # Test list input\n        with self.assertRaises(ValueError):\n            create_aes_key([128])\n\n    def test_boolean_input(self):\n        # Test boolean input\n        with self.assertRaises(ValueError):\n            create_aes_key(True)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 18, "task_id": "d4bdff5f"}
{"test": "import unittest\n\nclass TestCases(unittest.TestCase):\n    def test_valid_128(self):\n        # Test with valid 128-bit key: verify length and hex format\n        key = generate_secure_key(128)\n        self.assertEqual(len(key), 32)\n        self.assertRegex(key, r'^[0-9a-f]{32}$')\n\n    def test_valid_192(self):\n        # Test with valid 192-bit key: verify length and hex format\n        key = generate_secure_key(192)\n        self.assertEqual(len(key), 48)\n        self.assertRegex(key, r'^[0-9a-f]{48}$')\n\n    def test_valid_256(self):\n        # Test with valid 256-bit key: verify length and hex format\n        key = generate_secure_key(256)\n        self.assertEqual(len(key), 64)\n        self.assertRegex(key, r'^[0-9a-f]{64}$')\n\n    def test_invalid_zero(self):\n        # Test with 0 bits: invalid bit length\n        with self.assertRaises(ValueError):\n            generate_secure_key(0)\n\n    def test_invalid_64(self):\n        # Test with 64 bits: invalid bit length\n        with self.assertRaises(ValueError):\n            generate_secure_key(64)\n\n    def test_invalid_512(self):\n        # Test with 512 bits: invalid bit length\n        with self.assertRaises(ValueError):\n            generate_secure_key(512)\n\n    def test_negative_bits(self):\n        # Test with negative bits: invalid bit length\n        with self.assertRaises(ValueError):\n            generate_secure_key(-128)\n\n    def test_float_acceptable_value(self):\n        # Test with float 128.0: numerically valid but wrong type\n        with self.assertRaises(TypeError):\n            generate_secure_key(128.0)\n\n    def test_float_unacceptable_value(self):\n        # Test with float 128.5: invalid bit length and wrong type\n        with self.assertRaises(ValueError):\n            generate_secure_key(128.5)\n\n    def test_string_input(self):\n        # Test with string input: invalid type\n        with self.assertRaises(ValueError):\n            generate_secure_key('128')\n\n    def test_none_input(self):\n        # Test with None input: invalid type\n        with self.assertRaises(ValueError):\n            generate_secure_key(None)\n\n    def test_list_input(self):\n        # Test with list input: invalid type\n        with self.assertRaises(ValueError):\n            generate_secure_key([128])\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 12, "task_id": "33f886ab"}
{"test": "import unittest\n\nclass TestGenerateCryptographicKey(unittest.TestCase):\n    def test_valid_128(self):\n        # Test with valid bit length 128\n        key = generate_cryptographic_key(128)\n        self.assertIsInstance(key, str)\n        self.assertEqual(len(key), 32)\n        self.assertRegex(key, r'^[0-9a-f]{32}$')\n    \n    def test_valid_192(self):\n        # Test with valid bit length 192\n        key = generate_cryptographic_key(192)\n        self.assertIsInstance(key, str)\n        self.assertEqual(len(key), 48)\n        self.assertRegex(key, r'^[0-9a-f]{48}$')\n    \n    def test_valid_256(self):\n        # Test with valid bit length 256\n        key = generate_cryptographic_key(256)\n        self.assertIsInstance(key, str)\n        self.assertEqual(len(key), 64)\n        self.assertRegex(key, r'^[0-9a-f]{64}$')\n    \n    def test_invalid_0(self):\n        # Test with invalid bit length 0\n        with self.assertRaises(ValueError):\n            generate_cryptographic_key(0)\n    \n    def test_invalid_100(self):\n        # Test with invalid bit length 100\n        with self.assertRaises(ValueError):\n            generate_cryptographic_key(100)\n    \n    def test_invalid_200(self):\n        # Test with invalid bit length 200\n        with self.assertRaises(ValueError):\n            generate_cryptographic_key(200)\n    \n    def test_invalid_512(self):\n        # Test with invalid bit length 512\n        with self.assertRaises(ValueError):\n            generate_cryptographic_key(512)\n    \n    def test_invalid_negative(self):\n        # Test with negative bit length\n        with self.assertRaises(ValueError):\n            generate_cryptographic_key(-128)\n    \n    def test_float_128(self):\n        # Test with float 128.0 (acceptable numerically) -> causes TypeError\n        with self.assertRaises(TypeError):\n            generate_cryptographic_key(128.0)\n    \n    def test_float_100(self):\n        # Test with float 100.0 (unacceptable) -> ValueError\n        with self.assertRaises(ValueError):\n            generate_cryptographic_key(100.0)\n    \n    def test_string_128(self):\n        # Test with string '128' -> not an integer\n        with self.assertRaises(ValueError):\n            generate_cryptographic_key('128')\n    \n    def test_string_abc(self):\n        # Test with invalid string 'abc'\n        with self.assertRaises(ValueError):\n            generate_cryptographic_key('abc')\n    \n    def test_none(self):\n        # Test with None input\n        with self.assertRaises(ValueError):\n            generate_cryptographic_key(None)", "num_test_cases": 13, "task_id": "b3e99b3c"}
{"test": "import unittest\n\nclass TestCreateAESKey(unittest.TestCase):\n    def test_valid_128(self):\n        # Test valid key size 128: correct length and hex format.\n        key = create_aes_key(128)\n        self.assertIsInstance(key, str)\n        self.assertEqual(len(key), 32)  # 16 bytes * 2 hex digits\n        try:\n            bytes.fromhex(key)\n        except ValueError:\n            self.fail(\"Key is not a valid hexadecimal string\")\n    \n    def test_valid_192(self):\n        # Test valid key size 192: correct length and hex format.\n        key = create_aes_key(192)\n        self.assertIsInstance(key, str)\n        self.assertEqual(len(key), 48)  # 24 bytes * 2 hex digits\n        try:\n            bytes.fromhex(key)\n        except ValueError:\n            self.fail(\"Key is not a valid hexadecimal string\")\n    \n    def test_valid_256(self):\n        # Test valid key size 256: correct length and hex format.\n        key = create_aes_key(256)\n        self.assertIsInstance(key, str)\n        self.assertEqual(len(key), 64)  # 32 bytes * 2 hex digits\n        try:\n            bytes.fromhex(key)\n        except ValueError:\n            self.fail(\"Key is not a valid hexadecimal string\")\n    \n    def test_invalid_64(self):\n        # Test invalid key size 64: not in {128, 192, 256}.\n        with self.assertRaises(ValueError):\n            create_aes_key(64)\n    \n    def test_invalid_0(self):\n        # Test invalid key size 0: not in valid sizes.\n        with self.assertRaises(ValueError):\n            create_aes_key(0)\n    \n    def test_invalid_negative(self):\n        # Test invalid negative key size: -128.\n        with self.assertRaises(ValueError):\n            create_aes_key(-128)\n    \n    def test_invalid_100(self):\n        # Test invalid key size 100: not in valid sizes.\n        with self.assertRaises(ValueError):\n            create_aes_key(100)\n    \n    def test_invalid_512(self):\n        # Test invalid key size 512: not in valid sizes.\n        with self.assertRaises(ValueError):\n            create_aes_key(512)\n    \n    def test_uniqueness(self):\n        # Test two generated keys (size=128) are unique.\n        key1 = create_aes_key(128)\n        key2 = create_aes_key(128)\n        self.assertNotEqual(key1, key2)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 9, "task_id": "4aa88472"}
{"test": "import unittest\n\nclass TestCreateSecureKey(unittest.TestCase):\n    def check_key_format(self, key_str, bit_length):\n        expected_length = bit_length // 4\n        self.assertIsInstance(key_str, str)\n        self.assertEqual(len(key_str), expected_length, f'Key string length is {len(key_str)} but expected {expected_length} for {bit_length} bits')\n        valid_chars = '0123456789abcdef'\n        for char in key_str:\n            self.assertIn(char, valid_chars, 'Invalid character \\\\'{}\\\\' in key string'.format(char))\n    \n    def test_valid_128(self):\n        # Test that a 128-bit key is generated correctly.\n        key = create_secure_key(128)\n        self.check_key_format(key, 128)\n    \n    def test_valid_192(self):\n        # Test that a 192-bit key is generated correctly.\n        key = create_secure_key(192)\n        self.check_key_format(key, 192)\n    \n    def test_valid_256(self):\n        # Test that a 256-bit key is generated correctly.\n        key = create_secure_key(256)\n        self.check_key_format(key, 256)\n    \n    def test_randomness_128(self):\n        # Test that two 128-bit keys are different and have correct format.\n        key1 = create_secure_key(128)\n        key2 = create_secure_key(128)\n        self.check_key_format(key1, 128)\n        self.check_key_format(key2, 128)\n        self.assertNotEqual(key1, key2, 'Two generated keys are the same - randomness failure')\n    \n    def test_invalid_0(self):\n        # Test that key_bit_length=0 raises ValueError.\n        with self.assertRaises(ValueError):\n            create_secure_key(0)\n    \n    def test_invalid_64(self):\n        # Test that key_bit_length=64 raises ValueError.\n        with self.assertRaises(ValueError):\n            create_secure_key(64)\n    \n    def test_invalid_100(self):\n        # Test that key_bit_length=100 raises ValueError.\n        with self.assertRaises(ValueError):\n            create_secure_key(100)\n    \n    def test_invalid_512(self):\n        # Test that key_bit_length=512 raises ValueError.\n        with self.assertRaises(ValueError):\n            create_secure_key(512)\n    \n    def test_invalid_negative(self):\n        # Test that a negative key_bit_length raises ValueError.\n        with self.assertRaises(ValueError):\n            create_secure_key(-128)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 9, "task_id": "7d400f18"}
{"test": "import unittest\n\nclass TestGenerateSecureAESKey(unittest.TestCase):\n    def test_valid_128(self):\n        \"\"\"Test valid 128-bit key generation.\"\"\"\n        key = generate_secure_aes_key(128)\n        self.assertIsInstance(key, str)\n        self.assertEqual(len(key), 32)  # 16 bytes * 2 hex digits\n        self.assertTrue(all(c in '0123456789abcdef' for c in key), \"Output is not a valid hex string\")\n    \n    def test_valid_192(self):\n        \"\"\"Test valid 192-bit key generation.\"\"\"\n        key = generate_secure_aes_key(192)\n        self.assertIsInstance(key, str)\n        self.assertEqual(len(key), 48)  # 24 bytes * 2 hex digits\n        self.assertTrue(all(c in '0123456789abcdef' for c in key), \"Output is not a valid hex string\")\n    \n    def test_valid_256(self):\n        \"\"\"Test valid 256-bit key generation.\"\"\"\n        key = generate_secure_aes_key(256)\n        self.assertIsInstance(key, str)\n        self.assertEqual(len(key), 64)  # 32 bytes * 2 hex digits\n        self.assertTrue(all(c in '0123456789abcdef' for c in key), \"Output is not a valid hex string\")\n    \n    def test_invalid_0(self):\n        \"\"\"Test invalid key length 0.\"\"\"\n        with self.assertRaises(ValueError):\n            generate_secure_aes_key(0)\n    \n    def test_invalid_64(self):\n        \"\"\"Test invalid key length 64.\"\"\"\n        with self.assertRaises(ValueError):\n            generate_secure_aes_key(64)\n    \n    def test_invalid_255(self):\n        \"\"\"Test invalid key length 255.\"\"\"\n        with self.assertRaises(ValueError):\n            generate_secure_aes_key(255)\n    \n    def test_invalid_512(self):\n        \"\"\"Test invalid key length 512.\"\"\"\n        with self.assertRaises(ValueError):\n            generate_secure_aes_key(512)\n    \n    def test_negative(self):\n        \"\"\"Test negative key length.\"\"\"\n        with self.assertRaises(ValueError):\n            generate_secure_aes_key(-128)\n    \n    def test_float_integer(self):\n        \"\"\"Test float input that is integer (128.0).\"\"\"\n        with self.assertRaises(TypeError):\n            generate_secure_aes_key(128.0)\n    \n    def test_float_non_integer(self):\n        \"\"\"Test float input that is not integer (128.5).\"\"\"\n        with self.assertRaises(ValueError):\n            generate_secure_aes_key(128.5)\n    \n    def test_string_input(self):\n        \"\"\"Test string input ('128').\"\"\"\n        with self.assertRaises(ValueError):\n            generate_secure_aes_key('128')\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 11, "task_id": "8a56e004"}
{"test": "import unittest\n\nclass TestCreateCryptoKey(unittest.TestCase):\n\n    def test_valid_128(self):\n        \"\"\"Test valid key size 128 bits.\"\"\"\n        key = create_crypto_key(128)\n        self.assertIsInstance(key, str)\n        self.assertEqual(len(key), 32)\n        self.assertRegex(key, r'^[0-9a-f]{32}$')\n\n    def test_valid_192(self):\n        \"\"\"Test valid key size 192 bits.\"\"\"\n        key = create_crypto_key(192)\n        self.assertIsInstance(key, str)\n        self.assertEqual(len(key), 48)\n        self.assertRegex(key, r'^[0-9a-f]{48}$')\n\n    def test_valid_256(self):\n        \"\"\"Test valid key size 256 bits.\"\"\"\n        key = create_crypto_key(256)\n        self.assertIsInstance(key, str)\n        self.assertEqual(len(key), 64)\n        self.assertRegex(key, r'^[0-9a-f]{64}$')\n\n    def test_invalid_zero(self):\n        \"\"\"Test invalid key size 0 bits.\"\"\"\n        with self.assertRaises(ValueError):\n            create_crypto_key(0)\n\n    def test_invalid_negative(self):\n        \"\"\"Test negative key size.\"\"\"\n        with self.assertRaises(ValueError):\n            create_crypto_key(-128)\n\n    def test_invalid_64(self):\n        \"\"\"Test invalid key size 64 bits.\"\"\"\n        with self.assertRaises(ValueError):\n            create_crypto_key(64)\n\n    def test_invalid_512(self):\n        \"\"\"Test invalid key size 512 bits.\"\"\"\n        with self.assertRaises(ValueError):\n            create_crypto_key(512)\n\n    def test_randomness(self):\n        \"\"\"Test that two generated keys are different.\"\"\"\n        key1 = create_crypto_key(128)\n        key2 = create_crypto_key(128)\n        self.assertNotEqual(key1, key2)\n\n    def test_invalid_type_string(self):\n        \"\"\"Test invalid type: string input.\"\"\"\n        with self.assertRaises(TypeError):\n            create_crypto_key('128')\n\n    def test_invalid_type_float(self):\n        \"\"\"Test invalid type: float input.\"\"\"\n        with self.assertRaises(TypeError):\n            create_crypto_key(128.0)\n\n    def test_invalid_type_none(self):\n        \"\"\"Test invalid type: None input.\"\"\"\n        with self.assertRaises(TypeError):\n            create_crypto_key(None)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 11, "task_id": "4b441b71"}
{"test": "import unittest\nfrom solution import build_secure_key\n\nclass TestBuildSecureKey(unittest.TestCase):\n    def test_valid_key_128(self):\n        # Test valid 128-bit key: correct length and valid hex format\n        key = build_secure_key(128)\n        self.assertIsInstance(key, str)\n        self.assertEqual(len(key), 32)  # 16 bytes * 2 hex digits\n        # Validate hex format\n        try:\n            bytes.fromhex(key)\n        except ValueError:\n            self.fail(\"Key is not a valid hexadecimal string\")\n    \n    def test_valid_key_192(self):\n        # Test valid 192-bit key: correct length\n        key = build_secure_key(192)\n        self.assertIsInstance(key, str)\n        self.assertEqual(len(key), 48)  # 24 bytes * 2 hex digits\n    \n    def test_valid_key_256(self):\n        # Test valid 256-bit key: correct length\n        key = build_secure_key(256)\n        self.assertIsInstance(key, str)\n        self.assertEqual(len(key), 64)  # 32 bytes * 2 hex digits\n    \n    def test_invalid_key_sizes(self):\n        # Test invalid integer sizes (non-128/192/256) raise ValueError\n        invalid_sizes = [64, 100, 512, -128]\n        for size in invalid_sizes:\n            with self.subTest(size=size):\n                with self.assertRaises(ValueError):\n                    build_secure_key(size)\n    \n    def test_non_integer_inputs(self):\n        # Test non-integer inputs raise appropriate exceptions\n        test_cases = [\n            ('128', ValueError),   # String\n            (128.0, TypeError),    # Float\n            (None, ValueError)     # None\n        ]\n        for value, expected_exception in test_cases:\n            with self.subTest(value=value):\n                with self.assertRaises(expected_exception):\n                    build_secure_key(value)\n    \n    def test_randomness(self):\n        # Test generated keys are random and unique\n        key1 = build_secure_key(128)\n        key2 = build_secure_key(128)\n        self.assertNotEqual(key1, key2, \"Keys should be randomly generated and unique\")\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 6, "task_id": "a1d1cd5b"}
{"test": "import unittest\n\nclass TestProduceKey(unittest.TestCase):\n    def test_valid_key_sizes(self):\n        \"\"\"Test valid key sizes: 128, 192, 256 bits.\"\"\"\n        valid_sizes = [128, 192, 256]\n        for size in valid_sizes:\n            with self.subTest(size=size):\n                key1 = produce_key(size)\n                self.assertIsInstance(key1, str)\n                expected_length = (size // 8) * 2\n                self.assertEqual(len(key1), expected_length)\n                self.assertTrue(all(c in '0123456789abcdef' for c in key1))\n                key2 = produce_key(size)\n                self.assertIsInstance(key2, str)\n                self.assertEqual(len(key2), expected_length)\n                self.assertTrue(all(c in '0123456789abcdef' for c in key2))\n                self.assertNotEqual(key1, key2)\n\n    def test_invalid_key_sizes(self):\n        \"\"\"Test invalid integer key sizes.\"\"\"\n        invalid_sizes = [0, 64, 100, 512]\n        for size in invalid_sizes:\n            with self.subTest(size=size):\n                with self.assertRaises(ValueError) as context:\n                    produce_key(size)\n                self.assertEqual(str(context.exception), 'Invalid key size provided. Use 128, 192, or 256 bits.')\n\n    def test_non_integer_not_in_set(self):\n        \"\"\"Test non-integer inputs that are not in the valid set.\"\"\"\n        cases = [None, '128', 128.5, -128, []]\n        for value in cases:\n            with self.subTest(value=value):\n                with self.assertRaises(ValueError) as context:\n                    produce_key(value)\n                self.assertEqual(str(context.exception), 'Invalid key size provided. Use 128, 192, or 256 bits.')\n\n    def test_non_integer_in_set(self):\n        \"\"\"Test non-integer inputs that are numerically in the valid set (like 128.0).\"\"\"\n        cases = [128.0, 192.0, 256.0]\n        for value in cases:\n            with self.subTest(value=value):\n                with self.assertRaises(TypeError):\n                    produce_key(value)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 4, "task_id": "842be21f"}
{"test": "import unittest\nimport string\n\nclass TestCreatePassword(unittest.TestCase):\n\n    def test_valid_minimum_length(self):\n        # Test valid minimum size (8)\n        pwd = create_password(8)\n        self.assertIsInstance(pwd, str)\n        self.assertEqual(len(pwd), 8)\n        allowed_chars = string.ascii_letters + string.digits + string.punctuation\n        for char in pwd:\n            self.assertIn(char, allowed_chars)\n\n    def test_valid_medium_length(self):\n        # Test valid medium size (12)\n        pwd = create_password(12)\n        self.assertIsInstance(pwd, str)\n        self.assertEqual(len(pwd), 12)\n        allowed_chars = string.ascii_letters + string.digits + string.punctuation\n        for char in pwd:\n            self.assertIn(char, allowed_chars)\n\n    def test_valid_large_length(self):\n        # Test valid large size (100)\n        pwd = create_password(100)\n        self.assertIsInstance(pwd, str)\n        self.assertEqual(len(pwd), 100)\n        allowed_chars = string.ascii_letters + string.digits + string.punctuation\n        for char in pwd:\n            self.assertIn(char, allowed_chars)\n\n    def test_size_zero(self):\n        # Test size 0 (invalid)\n        with self.assertRaises(ValueError):\n            create_password(0)\n\n    def test_size_seven(self):\n        # Test size 7 (invalid)\n        with self.assertRaises(ValueError):\n            create_password(7)\n\n    def test_negative_size(self):\n        # Test negative size (invalid)\n        with self.assertRaises(ValueError):\n            create_password(-5)\n\n    def test_non_integer_string(self):\n        # Test non-integer input (string)\n        with self.assertRaises(TypeError):\n            create_password(\"8\")\n\n    def test_non_integer_float(self):\n        # Test non-integer input (float)\n        with self.assertRaises(TypeError):\n            create_password(12.5)\n\n    def test_randomness(self):\n        # Test two generated passwords are different (randomness)\n        pwd1 = create_password(12)\n        pwd2 = create_password(12)\n        self.assertNotEqual(pwd1, pwd2)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 10, "task_id": "05b1020c"}
{"test": "import unittest\nimport string\n\nclass TestCases(unittest.TestCase):\n\n    def test_valid_length_typical(self):\n        \"\"\"Test with typical valid password length (12)\"\"\"\n        password = generate_secure_password(12)\n        self.assertEqual(len(password), 12)\n        allowed_chars = string.ascii_letters + string.digits + string.punctuation\n        for char in password:\n            self.assertIn(char, allowed_chars)\n\n    def test_valid_minimum_length(self):\n        \"\"\"Test with minimum allowed password length (8)\"\"\"\n        password = generate_secure_password(8)\n        self.assertEqual(len(password), 8)\n        allowed_chars = string.ascii_letters + string.digits + string.punctuation\n        for char in password:\n            self.assertIn(char, allowed_chars)\n\n    def test_valid_large_length(self):\n        \"\"\"Test with large password length (100)\"\"\"\n        password = generate_secure_password(100)\n        self.assertEqual(len(password), 100)\n        allowed_chars = string.ascii_letters + string.digits + string.punctuation\n        for char in password:\n            self.assertIn(char, allowed_chars)\n\n    def test_invalid_negative_length(self):\n        \"\"\"Test with negative password length\"\"\"\n        with self.assertRaises(ValueError) as context:\n            generate_secure_password(-5)\n        self.assertEqual(str(context.exception), \"Password length must be at least 8 characters.\")\n\n    def test_invalid_zero_length(self):\n        \"\"\"Test with zero password length\"\"\"\n        with self.assertRaises(ValueError) as context:\n            generate_secure_password(0)\n        self.assertEqual(str(context.exception), \"Password length must be at least 8 characters.\")\n\n    def test_invalid_short_length(self):\n        \"\"\"Test with length below minimum (7)\"\"\"\n        with self.assertRaises(ValueError) as context:\n            generate_secure_password(7)\n        self.assertEqual(str(context.exception), \"Password length must be at least 8 characters.\")", "num_test_cases": 6, "task_id": "b523b10e"}
{"test": "import unittest\nimport string\n\nclass TestCreateSecureToken(unittest.TestCase):\n\n    def test_valid_length_8(self):\n        # Test token of length 8: correct length and all characters in allowed set.\n        token = create_secure_token(8)\n        self.assertEqual(len(token), 8)\n        allowed_chars = string.ascii_letters + string.digits + string.punctuation\n        for char in token:\n            self.assertIn(char, allowed_chars)\n\n    def test_valid_length_16(self):\n        # Test token of length 16: correct length and all characters in allowed set.\n        token = create_secure_token(16)\n        self.assertEqual(len(token), 16)\n        allowed_chars = string.ascii_letters + string.digits + string.punctuation\n        for char in token:\n            self.assertIn(char, allowed_chars)\n\n    def test_valid_length_100(self):\n        # Test token of length 100: correct length and all characters in allowed set.\n        token = create_secure_token(100)\n        self.assertEqual(len(token), 100)\n        allowed_chars = string.ascii_letters + string.digits + string.punctuation\n        for char in token:\n            self.assertIn(char, allowed_chars)\n\n    def test_valid_length_1000(self):\n        # Test token of length 1000: correct length and all characters in allowed set.\n        token = create_secure_token(1000)\n        self.assertEqual(len(token), 1000)\n        allowed_chars = string.ascii_letters + string.digits + string.punctuation\n        for char in token:\n            self.assertIn(char, allowed_chars)\n\n    def test_length_0_raises_value_error(self):\n        # Test that token_length=0 raises ValueError.\n        with self.assertRaises(ValueError):\n            create_secure_token(0)\n\n    def test_length_negative_raises_value_error(self):\n        # Test that negative token_length raises ValueError.\n        with self.assertRaises(ValueError):\n            create_secure_token(-1)\n\n    def test_length_1_raises_value_error(self):\n        # Test that token_length=1 raises ValueError.\n        with self.assertRaises(ValueError):\n            create_secure_token(1)\n\n    def test_length_7_raises_value_error(self):\n        # Test that token_length=7 raises ValueError.\n        with self.assertRaises(ValueError):\n            create_secure_token(7)\n\n    def test_randomness(self):\n        # Test that two generated tokens of the same length are different.\n        token1 = create_secure_token(16)\n        token2 = create_secure_token(16)\n        self.assertNotEqual(token1, token2)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 9, "task_id": "590190c9"}
{"test": "import unittest\nimport string\n\nclass TestCases(unittest.TestCase):\n    def test_typical_size(self):\n        \"\"\"Test with typical size (10).\"\"\"\n        password = create_secure_password(10)\n        self.assertIsInstance(password, str)\n        self.assertEqual(len(password), 10)\n        for char in password:\n            self.assertIn(char, string.ascii_letters + string.digits + string.punctuation)\n\n    def test_minimum_size(self):\n        \"\"\"Test with minimum allowed size (8).\"\"\"\n        password = create_secure_password(8)\n        self.assertEqual(len(password), 8)\n        for char in password:\n            self.assertIn(char, string.ascii_letters + string.digits + string.punctuation)\n\n    def test_large_size(self):\n        \"\"\"Test with a large size (100).\"\"\"\n        password = create_secure_password(100)\n        self.assertEqual(len(password), 100)\n        for char in password:\n            self.assertIn(char, string.ascii_letters + string.digits + string.punctuation)\n\n    def test_size_zero(self):\n        \"\"\"Test with size=0 (too small).\"\"\"\n        with self.assertRaises(ValueError) as context:\n            create_secure_password(0)\n        self.assertEqual(str(context.exception), \"Password length must be at least 8 characters.\")\n\n    def test_size_seven(self):\n        \"\"\"Test with size=7 (too small).\"\"\"\n        with self.assertRaises(ValueError) as context:\n            create_secure_password(7)\n        self.assertEqual(str(context.exception), \"Password length must be at least 8 characters.\")\n\n    def test_negative_size(self):\n        \"\"\"Test with negative size.\"\"\"\n        with self.assertRaises(ValueError) as context:\n            create_secure_password(-5)\n        self.assertEqual(str(context.exception), \"Password length must be at least 8 characters.\")\n\n    def test_non_integer_size_string(self):\n        \"\"\"Test with non-integer type (string).\"\"\"\n        with self.assertRaises(TypeError):\n            create_secure_password(\"10\")\n\n    def test_non_integer_size_none(self):\n        \"\"\"Test with non-integer type (None).\"\"\"\n        with self.assertRaises(TypeError):\n            create_secure_password(None)\n\n    def test_password_uniqueness(self):\n        \"\"\"Test two generated passwords are unique.\"\"\"\n        password1 = create_secure_password(10)\n        password2 = create_secure_password(10)\n        self.assertNotEqual(password1, password2)", "num_test_cases": 9, "task_id": "2d50603b"}
{"test": "import unittest\nimport string\n\nclass TestRandomPasswordGenerator(unittest.TestCase):\n    ALLOWED_CHARS = string.ascii_letters + string.digits + string.punctuation\n\n    def test_normal_case(self):\n        # Test with a typical password length\n        length = 12\n        result = random_password_generator(length)\n        self.assertIsInstance(result, str)\n        self.assertEqual(len(result), length)\n        for char in result:\n            self.assertIn(char, self.ALLOWED_CHARS)\n\n    def test_minimum_length(self):\n        # Test with the minimum allowed password length (8)\n        length = 8\n        result = random_password_generator(length)\n        self.assertIsInstance(result, str)\n        self.assertEqual(len(result), length)\n        for char in result:\n            self.assertIn(char, self.ALLOWED_CHARS)\n\n    def test_large_length(self):\n        # Test with a very large password length (1000)\n        length = 1000\n        result = random_password_generator(length)\n        self.assertIsInstance(result, str)\n        self.assertEqual(len(result), length)\n        for char in result:\n            self.assertIn(char, self.ALLOWED_CHARS)\n\n    def test_negative_length(self):\n        # Test that a negative length raises a ValueError\n        with self.assertRaises(ValueError):\n            random_password_generator(-1)\n\n    def test_zero_length(self):\n        # Test that a zero length raises a ValueError\n        with self.assertRaises(ValueError):\n            random_password_generator(0)\n\n    def test_length_seven(self):\n        # Test that a length of 7 (below minimum) raises a ValueError\n        with self.assertRaises(ValueError):\n            random_password_generator(7)\n\n    def test_randomness(self):\n        # Test that two generated passwords (of same length) are different\n        length = 8\n        result1 = random_password_generator(length)\n        result2 = random_password_generator(length)\n        self.assertNotEqual(result1, result2)", "num_test_cases": 7, "task_id": "13a2e6f5"}
{"test": "import unittest\nimport string\n\nclass TestRandomPasswordBuilder(unittest.TestCase):\n    \n    def test_case_1(self):\n        # Test minimum valid password length (8)\n        pwd = random_password_builder(8)\n        self.assertEqual(len(pwd), 8)\n        for char in pwd:\n            self.assertIn(char, string.ascii_letters + string.digits + string.punctuation)\n    \n    def test_case_2(self):\n        # Test typical password length (12)\n        pwd = random_password_builder(12)\n        self.assertEqual(len(pwd), 12)\n        for char in pwd:\n            self.assertIn(char, string.ascii_letters + string.digits + string.punctuation)\n    \n    def test_case_3(self):\n        # Test longer password length (16)\n        pwd = random_password_builder(16)\n        self.assertEqual(len(pwd), 16)\n        for char in pwd:\n            self.assertIn(char, string.ascii_letters + string.digits + string.punctuation)\n    \n    def test_case_4(self):\n        # Test large password length (100)\n        pwd = random_password_builder(100)\n        self.assertEqual(len(pwd), 100)\n        for char in pwd:\n            self.assertIn(char, string.ascii_letters + string.digits + string.punctuation)\n    \n    def test_case_5(self):\n        # Test length below minimum (7)\n        with self.assertRaises(ValueError) as context:\n            random_password_builder(7)\n        self.assertEqual(str(context.exception), \"Password length must be at least 8 characters.\")\n    \n    def test_case_6(self):\n        # Test zero length\n        with self.assertRaises(ValueError) as context:\n            random_password_builder(0)\n        self.assertEqual(str(context.exception), \"Password length must be at least 8 characters.\")\n    \n    def test_case_7(self):\n        # Test negative length\n        with self.assertRaises(ValueError) as context:\n            random_password_builder(-5)\n        self.assertEqual(str(context.exception), \"Password length must be at least 8 characters.\")\n", "num_test_cases": 7, "task_id": "c7e3678b"}
{"test": "import unittest\nimport string\n\nclass TestCreatePassword(unittest.TestCase):\n\n    def _check_password(self, password, expected_length):\n        \"\"\"Helper to check password length and character validity.\"\"\"\n        self.assertIsInstance(password, str)\n        self.assertEqual(len(password), expected_length)\n        allowed_chars = string.ascii_letters + string.digits + string.punctuation\n        for char in password:\n            self.assertIn(char, allowed_chars)\n\n    def test_case_1(self):\n        # Test minimum valid length (8)\n        password = create_password(8)\n        self._check_password(password, 8)\n\n    def test_case_2(self):\n        # Test medium valid length (12)\n        password = create_password(12)\n        self._check_password(password, 12)\n\n    def test_case_3(self):\n        # Test large valid length (100)\n        password = create_password(100)\n        self._check_password(password, 100)\n\n    def test_case_4(self):\n        # Test invalid size (7) - below minimum\n        with self.assertRaises(ValueError) as context:\n            create_password(7)\n        self.assertEqual(str(context.exception), 'Password size must be at least 8 characters.')\n\n    def test_case_5(self):\n        # Test invalid size (0) - zero length\n        with self.assertRaises(ValueError) as context:\n            create_password(0)\n        self.assertEqual(str(context.exception), 'Password size must be at least 8 characters.')\n\n    def test_case_6(self):\n        # Test invalid size (-5) - negative length\n        with self.assertRaises(ValueError) as context:\n            create_password(-5)\n        self.assertEqual(str(context.exception), 'Password size must be at least 8 characters.')\n\n    def test_case_7(self):\n        # Test randomness - two generated passwords differ\n        password1 = create_password(10)\n        password2 = create_password(10)\n        self._check_password(password1, 10)\n        self._check_password(password2, 10)\n        self.assertNotEqual(password1, password2)", "num_test_cases": 7, "task_id": "54935485"}
{"test": "import unittest\nimport string\n\nclass TestCreateKey(unittest.TestCase):\n    def assert_valid_password(self, password, expected_length):\n        \"\"\"Helper method to validate password length and character set.\"\"\"\n        self.assertEqual(len(password), expected_length)\n        allowed_chars = string.ascii_letters + string.digits + string.punctuation\n        for char in password:\n            self.assertIn(char, allowed_chars)\n\n    def test_min_length(self):\n        # Test minimum valid length (8) - validates length and character set\n        self.assert_valid_password(create_key(8), 8)\n\n    def test_typical_length(self):\n        # Test typical password length (12)\n        self.assert_valid_password(create_key(12), 12)\n\n    def test_long_length(self):\n        # Test long password (100)\n        self.assert_valid_password(create_key(100), 100)\n\n    def test_very_long_length(self):\n        # Test very long password (1000)\n        self.assert_valid_password(create_key(1000), 1000)\n\n    def test_randomness(self):\n        # Test password randomness - two generated passwords should differ\n        password1 = create_key(16)\n        password2 = create_key(16)\n        self.assert_valid_password(password1, 16)\n        self.assert_valid_password(password2, 16)\n        self.assertNotEqual(password1, password2)\n\n    def test_invalid_length_7(self):\n        # Test length below minimum (7)\n        with self.assertRaises(ValueError):\n            create_key(7)\n\n    def test_invalid_length_0(self):\n        # Test zero length\n        with self.assertRaises(ValueError):\n            create_key(0)\n\n    def test_invalid_negative(self):\n        # Test negative length\n        with self.assertRaises(ValueError):\n            create_key(-1)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 8, "task_id": "20f54e1a"}
{"test": "import unittest\nimport string\n\nclass TestCases(unittest.TestCase):\n    allowed_chars = string.ascii_letters + string.digits + string.punctuation\n\n    def test_case_1(self):\n        # Test with minimum allowed length (8)\n        length = 8\n        result = make_password(length)\n        self.assertEqual(len(result), length)\n        for char in result:\n            self.assertIn(char, self.allowed_chars)\n\n    def test_case_2(self):\n        # Test with a typical password length\n        length = 12\n        result = make_password(length)\n        self.assertEqual(len(result), length)\n        for char in result:\n            self.assertIn(char, self.allowed_chars)\n\n    def test_case_3(self):\n        # Test with a longer password\n        length = 20\n        result = make_password(length)\n        self.assertEqual(len(result), length)\n        for char in result:\n            self.assertIn(char, self.allowed_chars)\n\n    def test_case_4(self):\n        # Test with a very long password\n        length = 100\n        result = make_password(length)\n        self.assertEqual(len(result), length)\n        for char in result:\n            self.assertIn(char, self.allowed_chars)\n\n    def test_case_5(self):\n        # Test with maximum practical length\n        length = 1000\n        result = make_password(length)\n        self.assertEqual(len(result), length)\n        for char in result:\n            self.assertIn(char, self.allowed_chars)\n\n    def test_case_6(self):\n        # Test with length below minimum (7)\n        with self.assertRaises(ValueError) as context:\n            make_password(7)\n        self.assertEqual(str(context.exception), 'Password length must be at least 8 characters.')\n\n    def test_case_7(self):\n        # Test with zero length\n        with self.assertRaises(ValueError) as context:\n            make_password(0)\n        self.assertEqual(str(context.exception), 'Password length must be at least 8 characters.')\n\n    def test_case_8(self):\n        # Test with negative length\n        with self.assertRaises(ValueError) as context:\n            make_password(-10)\n        self.assertEqual(str(context.exception), 'Password length must be at least 8 characters.')", "num_test_cases": 8, "task_id": "1da7d82c"}
{"test": "import unittest\nimport string\n\nclass TestCreateDistinctId(unittest.TestCase):\n\n    def test_case_1(self):\n        # Test basic functionality: size=10 -> correct length, character set, and two calls are different.\n        size = 10\n        result = create_distinct_id(size)\n        self.assertIsInstance(result, str)\n        self.assertEqual(len(result), size)\n        allowed_chars = string.ascii_letters + string.digits\n        for char in result:\n            self.assertIn(char, allowed_chars)\n        result2 = create_distinct_id(size)\n        self.assertEqual(len(result2), size)\n        self.assertNotEqual(result, result2)\n\n    def test_case_2(self):\n        # Test size=0: returns empty string.\n        result = create_distinct_id(0)\n        self.assertEqual(result, '')\n        self.assertEqual(len(result), 0)\n\n    def test_case_3(self):\n        # Test size=1: one character and in allowed set.\n        size = 1\n        result = create_distinct_id(size)\n        self.assertEqual(len(result), size)\n        allowed_chars = string.ascii_letters + string.digits\n        self.assertIn(result, allowed_chars)\n\n    def test_case_4(self):\n        # Test negative size: should return empty string.\n        result = create_distinct_id(-5)\n        self.assertEqual(result, '')\n        self.assertEqual(len(result), 0)\n\n    def test_case_5(self):\n        # Test large size (1000): check length and characters.\n        size = 1000\n        result = create_distinct_id(size)\n        self.assertEqual(len(result), size)\n        allowed_chars = string.ascii_letters + string.digits\n        for char in result:\n            self.assertIn(char, allowed_chars)\n\n    def test_case_6(self):\n        # Test non-integer string input: should raise TypeError.\n        with self.assertRaises(TypeError):\n            create_distinct_id('10')\n\n    def test_case_7(self):\n        # Test non-integer float input: should raise TypeError.\n        with self.assertRaises(TypeError):\n            create_distinct_id(5.5)\n\n    def test_case_8(self):\n        # Test float that is an integer: should still raise TypeError.\n        with self.assertRaises(TypeError):\n            create_distinct_id(10.0)\n\n    def test_case_9(self):\n        # Test None input: should raise TypeError.\n        with self.assertRaises(TypeError):\n            create_distinct_id(None)\n", "num_test_cases": 9, "task_id": "9750abfd"}
{"test": "import unittest\nimport string\n\nclass TestBuildUniqueToken(unittest.TestCase):\n    def test_positive_length(self):\n        \"\"\"Test typical token generation with a positive length.\"\"\"\n        token_length = 10\n        token = build_unique_token(token_length)\n        self.assertEqual(len(token), token_length)\n        allowed_set = set(string.ascii_letters + string.digits)\n        for char in token:\n            self.assertIn(char, allowed_set)\n\n    def test_zero_length(self):\n        \"\"\"Test token generation with zero length returns empty string.\"\"\"\n        token = build_unique_token(0)\n        self.assertEqual(token, '')\n        self.assertEqual(len(token), 0)\n\n    def test_single_character(self):\n        \"\"\"Test token generation for a single character token.\"\"\"\n        token = build_unique_token(1)\n        self.assertEqual(len(token), 1)\n        allowed_set = set(string.ascii_letters + string.digits)\n        self.assertIn(token, allowed_set)\n\n    def test_negative_length(self):\n        \"\"\"Test negative token length returns empty string.\"\"\"\n        token = build_unique_token(-5)\n        self.assertEqual(token, '')\n        self.assertEqual(len(token), 0)\n\n    def test_large_length(self):\n        \"\"\"Test token generation with a very large length.\"\"\"\n        token_length = 10000\n        token = build_unique_token(token_length)\n        self.assertEqual(len(token), token_length)\n        allowed_set = set(string.ascii_letters + string.digits)\n        for char in token:\n            self.assertIn(char, allowed_set)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 5, "task_id": "c3994376"}
{"test": "import unittest\n\n# Define the allowed alphanumeric characters explicitly\nallowed_chars = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\"\n\nclass TestProduceUniqueKey(unittest.TestCase):\n    def test_case_1(self):\n        \"\"\"Test typical case with key_length=10\"\"\"\n        key = produce_unique_key(10)\n        self.assertEqual(len(key), 10)\n        for char in key:\n            self.assertIn(char, allowed_chars)\n\n    def test_case_2(self):\n        \"\"\"Test key_length=0 (empty string)\"\"\"\n        key = produce_unique_key(0)\n        self.assertEqual(key, '')\n\n    def test_case_3(self):\n        \"\"\"Test key_length=1 (single character)\"\"\"\n        key = produce_unique_key(1)\n        self.assertEqual(len(key), 1)\n        self.assertIn(key, allowed_chars)\n\n    def test_case_4(self):\n        \"\"\"Test large key_length (100)\"\"\"\n        key = produce_unique_key(100)\n        self.assertEqual(len(key), 100)\n        for char in key:\n            self.assertIn(char, allowed_chars)\n\n    def test_case_5(self):\n        \"\"\"Test negative key_length (returns empty string)\"\"\"\n        key = produce_unique_key(-5)\n        self.assertEqual(key, '')\n\n    def test_case_6(self):\n        \"\"\"Test float input (TypeError)\"\"\"\n        with self.assertRaises(TypeError):\n            produce_unique_key(10.0)\n\n    def test_case_7(self):\n        \"\"\"Test non-integer input (TypeError)\"\"\"\n        with self.assertRaises(TypeError):\n            produce_unique_key('10')\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 7, "task_id": "1e89bdc2"}
{"test": "import unittest\nimport string\n\nclass TestCreateSecureToken(unittest.TestCase):\n\n    def test_case_1(self):\n        # Test typical valid size (10)\n        size = 10\n        token = create_secure_token(size)\n        self.assertEqual(len(token), size)\n        for char in token:\n            self.assertIn(char, string.ascii_letters + string.digits)\n\n    def test_case_2(self):\n        # Test size 0 (empty string)\n        size = 0\n        token = create_secure_token(size)\n        self.assertEqual(token, '')\n        self.assertEqual(len(token), size)\n\n    def test_case_3(self):\n        # Test minimum non-zero size (1)\n        size = 1\n        token = create_secure_token(size)\n        self.assertEqual(len(token), size)\n        self.assertIn(token, string.ascii_letters + string.digits)\n\n    def test_case_4(self):\n        # Test large size (1000)\n        size = 1000\n        token = create_secure_token(size)\n        self.assertEqual(len(token), size)\n        for char in token:\n            self.assertIn(char, string.ascii_letters + string.digits)\n\n    def test_case_5(self):\n        # Test negative size (should return empty string)\n        size = -5\n        token = create_secure_token(size)\n        self.assertEqual(token, '')\n        self.assertEqual(len(token), 0)\n\n    def test_case_6(self):\n        # Test invalid float input\n        with self.assertRaises(TypeError):\n            create_secure_token(10.5)\n\n    def test_case_7(self):\n        # Test invalid string input\n        with self.assertRaises(TypeError):\n            create_secure_token('10')\n\n    def test_case_8(self):\n        # Test invalid None input\n        with self.assertRaises(TypeError):\n            create_secure_token(None)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 8, "task_id": "1f6a14fe"}
{"test": "import unittest\nimport string\n\nclass TestProduceSecureId(unittest.TestCase):\n\n    def test_zero_length(self):\n        # Test input_len=0 returns empty string\n        result = produce_secure_id(0)\n        self.assertIsInstance(result, str)\n        self.assertEqual(len(result), 0)\n\n    def test_single_char(self):\n        # Test input_len=1 returns valid single character\n        result = produce_secure_id(1)\n        self.assertIsInstance(result, str)\n        self.assertEqual(len(result), 1)\n        self.assertIn(result, string.ascii_letters + string.digits)\n\n    def test_medium_length(self):\n        # Test input_len=10 returns valid alphanumeric string\n        input_len = 10\n        result = produce_secure_id(input_len)\n        self.assertIsInstance(result, str)\n        self.assertEqual(len(result), input_len)\n        allowed_chars = string.ascii_letters + string.digits\n        for char in result:\n            self.assertIn(char, allowed_chars)\n\n    def test_large_length(self):\n        # Test large input_len=1000 returns valid string\n        input_len = 1000\n        result = produce_secure_id(input_len)\n        self.assertIsInstance(result, str)\n        self.assertEqual(len(result), input_len)\n        allowed_chars = string.ascii_letters + string.digits\n        for char in result:\n            self.assertIn(char, allowed_chars)\n\n    def test_negative_length(self):\n        # Test negative input_len returns empty string\n        result = produce_secure_id(-5)\n        self.assertIsInstance(result, str)\n        self.assertEqual(len(result), 0)\n\n    def test_float_input(self):\n        # Test float input raises TypeError\n        with self.assertRaises(TypeError):\n            produce_secure_id(5.5)\n\n    def test_string_input(self):\n        # Test string input raises TypeError\n        with self.assertRaises(TypeError):\n            produce_secure_id('10')\n\n    def test_none_input(self):\n        # Test None input raises TypeError\n        with self.assertRaises(TypeError):\n            produce_secure_id(None)\n", "num_test_cases": 8, "task_id": "ce5c2796"}
{"test": "import unittest\nimport string\n\nclass TestCreateUniqueId(unittest.TestCase):\n    \n    def test_basic_length(self):\n        # Test with id_length=8: should return 8-character string of alphanumeric\n        result = create_unique_id(8)\n        self.assertEqual(len(result), 8)\n        for char in result:\n            self.assertIn(char, string.ascii_letters + string.digits)\n    \n    def test_zero_length(self):\n        # Test with id_length=0: should return empty string\n        result = create_unique_id(0)\n        self.assertEqual(result, \"\")\n    \n    def test_one_length(self):\n        # Test with id_length=1: should return one alphanumeric character\n        result = create_unique_id(1)\n        self.assertEqual(len(result), 1)\n        self.assertIn(result, string.ascii_letters + string.digits)\n    \n    def test_large_length(self):\n        # Test with a large id_length (1000): should return a string of length 1000, all alphanumeric\n        length = 1000\n        result = create_unique_id(length)\n        self.assertEqual(len(result), length)\n        for char in result:\n            self.assertIn(char, string.ascii_letters + string.digits)\n    \n    def test_negative_length(self):\n        # Test with negative id_length (-1): should return empty string\n        result = create_unique_id(-1)\n        self.assertEqual(result, \"\")\n    \n    def test_float_input(self):\n        # Test with non-integer (float) input: should raise TypeError\n        with self.assertRaises(TypeError):\n            create_unique_id(8.0)\n    \n    def test_string_input(self):\n        # Test with non-integer (string) input: should raise TypeError\n        with self.assertRaises(TypeError):\n            create_unique_id(\"8\")\n    \n    def test_none_input(self):\n        # Test with None input: should raise TypeError\n        with self.assertRaises(TypeError):\n            create_unique_id(None)\n    \n    def test_randomness(self):\n        # Test that two generated IDs of length 10 are different (to ensure randomness)\n        id1 = create_unique_id(10)\n        id2 = create_unique_id(10)\n        self.assertNotEqual(id1, id2)", "num_test_cases": 9, "task_id": "951e2c20"}
{"test": "import unittest\nimport string\n\nclass TestCreateUniqueId(unittest.TestCase):\n    \n    def test_typical_size(self):\n        # Test with a typical positive size (10)\n        size = 10\n        result = create_unique_id(size)\n        self.assertIsInstance(result, str)\n        self.assertEqual(len(result), size)\n        self.assertTrue(all(c in string.ascii_letters + string.digits for c in result))\n    \n    def test_size_zero(self):\n        # Test with size 0 (returns empty string)\n        size = 0\n        result = create_unique_id(size)\n        self.assertEqual(result, '')\n        self.assertEqual(len(result), 0)\n    \n    def test_large_size(self):\n        # Test with a large size (1000)\n        size = 1000\n        result = create_unique_id(size)\n        self.assertEqual(len(result), size)\n        self.assertTrue(all(c in string.ascii_letters + string.digits for c in result))\n    \n    def test_negative_size(self):\n        # Test with a negative size (returns empty string)\n        size = -5\n        result = create_unique_id(size)\n        self.assertEqual(result, '')\n        self.assertEqual(len(result), 0)\n    \n    def test_non_integer_string(self):\n        # Test with non-integer input (string)\n        with self.assertRaises(TypeError):\n            create_unique_id('10')\n    \n    def test_non_integer_float(self):\n        # Test with non-integer input (float)\n        with self.assertRaises(TypeError):\n            create_unique_id(10.5)\n    \n    def test_non_integer_none(self):\n        # Test with non-integer input (None)\n        with self.assertRaises(TypeError):\n            create_unique_id(None)\n", "num_test_cases": 7, "task_id": "6a16ca52"}
{"test": "import unittest\nimport string\n\nclass TestBuildSecureId(unittest.TestCase):\n    def test_positive_length(self):\n        # Test with a typical positive integer\n        result = build_secure_id(10)\n        self.assertEqual(len(result), 10)\n        for char in result:\n            self.assertIn(char, string.ascii_letters + string.digits)\n\n    def test_zero_length(self):\n        # Test with char_count=0 (edge case)\n        result = build_secure_id(0)\n        self.assertEqual(result, \"\")\n\n    def test_length_one(self):\n        # Test minimal positive length\n        result = build_secure_id(1)\n        self.assertEqual(len(result), 1)\n        self.assertIn(result, string.ascii_letters + string.digits)\n\n    def test_large_length(self):\n        # Test with a large char_count value\n        result = build_secure_id(100)\n        self.assertEqual(len(result), 100)\n        for char in result:\n            self.assertIn(char, string.ascii_letters + string.digits)\n\n    def test_negative_length(self):\n        # Test with negative char_count (edge case)\n        result = build_secure_id(-5)\n        self.assertEqual(result, \"\")\n\n    def test_non_integer_string(self):\n        # Test with string input (invalid type)\n        with self.assertRaises(TypeError):\n            build_secure_id(\"10\")\n\n    def test_non_integer_float(self):\n        # Test with float input (invalid type)\n        with self.assertRaises(TypeError):\n            build_secure_id(5.5)\n\n    def test_non_integer_float_whole(self):\n        # Test with float that is whole number (still invalid)\n        with self.assertRaises(TypeError):\n            build_secure_id(10.0)\n\n    def test_non_integer_none(self):\n        # Test with None input (invalid type)\n        with self.assertRaises(TypeError):\n            build_secure_id(None)", "num_test_cases": 9, "task_id": "88243fb8"}
{"test": "import unittest\nimport string\n\nclass TestCases(unittest.TestCase):\n\n    def test_case_1(self):\n        # Test with positive key_length (10) - happy path\n        result = obtain_distinct_key(10)\n        self.assertEqual(len(result), 10)\n        allowed_chars = string.ascii_letters + string.digits\n        for char in result:\n            self.assertIn(char, allowed_chars)\n\n    def test_case_2(self):\n        # Test with key_length=0 - edge case\n        result = obtain_distinct_key(0)\n        self.assertEqual(result, '')\n        self.assertEqual(len(result), 0)\n\n    def test_case_3(self):\n        # Test with key_length=1 - edge case\n        result = obtain_distinct_key(1)\n        self.assertEqual(len(result), 1)\n        allowed_chars = string.ascii_letters + string.digits\n        self.assertIn(result, allowed_chars)\n\n    def test_case_4(self):\n        # Test with large key_length (10000) - edge case\n        length = 10000\n        result = obtain_distinct_key(length)\n        self.assertEqual(len(result), length)\n        allowed_chars = string.ascii_letters + string.digits\n        for char in result:\n            self.assertIn(char, allowed_chars)\n\n    def test_case_5(self):\n        # Test with negative key_length (-5) - edge case\n        result = obtain_distinct_key(-5)\n        self.assertEqual(result, '')\n\n    def test_case_6(self):\n        # Test with non-integer input (float) - error handling\n        with self.assertRaises(TypeError):\n            obtain_distinct_key(10.5)\n\n    def test_case_7(self):\n        # Test with non-integer input (string) - error handling\n        with self.assertRaises(TypeError):\n            obtain_distinct_key('invalid')\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 7, "task_id": "9ea9d126"}
{"test": "import unittest\nimport string\n\nclass TestGenerateResetCode(unittest.TestCase):\n    def test_positive_length(self):\n        # Test typical positive length (6)\n        code = generate_reset_code(6)\n        self.assertIsInstance(code, str)\n        self.assertEqual(len(code), 6)\n    \n    def test_zero_length(self):\n        # Test zero length input\n        code = generate_reset_code(0)\n        self.assertEqual(code, '')\n        self.assertEqual(len(code), 0)\n    \n    def test_negative_length(self):\n        # Test negative length input\n        code = generate_reset_code(-5)\n        self.assertEqual(code, '')\n        self.assertEqual(len(code), 0)\n    \n    def test_large_length(self):\n        # Test very large length input\n        code = generate_reset_code(10000)\n        self.assertEqual(len(code), 10000)\n    \n    def test_composition(self):\n        # Test code contains only allowed characters (ASCII letters and digits)\n        code = generate_reset_code(100)\n        alphabet = string.ascii_letters + string.digits\n        for char in code:\n            self.assertIn(char, alphabet)\n    \n    def test_single_character(self):\n        # Test length 1 with character validation\n        code = generate_reset_code(1)\n        self.assertEqual(len(code), 1)\n        alphabet = string.ascii_letters + string.digits\n        self.assertIn(code, alphabet)", "num_test_cases": 6, "task_id": "06e78122"}
{"test": "import unittest\nimport string\n\nclass TestCreateAPIKey(unittest.TestCase):\n\n    def test_positive_length(self):\n        # Test typical positive length (16)\n        key = create_api_key(16)\n        self.assertEqual(len(key), 16)\n\n    def test_zero_length(self):\n        # Test zero length (returns empty string)\n        key = create_api_key(0)\n        self.assertEqual(key, '')\n        self.assertEqual(len(key), 0)\n\n    def test_negative_length(self):\n        # Test negative length (returns empty string)\n        key = create_api_key(-5)\n        self.assertEqual(key, '')\n        self.assertEqual(len(key), 0)\n\n    def test_large_length(self):\n        # Test very large length (1000)\n        key = create_api_key(1000)\n        self.assertEqual(len(key), 1000)\n\n    def test_non_integer_length(self):\n        # Test invalid types (string, float, None)\n        with self.assertRaises(TypeError):\n            create_api_key('16')\n        with self.assertRaises(TypeError):\n            create_api_key(16.0)\n        with self.assertRaises(TypeError):\n            create_api_key(None)\n\n    def test_character_set(self):\n        # Test all characters are in allowed set\n        allowed_chars = string.ascii_letters + string.digits + string.punctuation\n        key = create_api_key(100)\n        for char in key:\n            self.assertIn(char, allowed_chars)\n\n    def test_randomness(self):\n        # Test two generated keys are different\n        key1 = create_api_key(32)\n        key2 = create_api_key(32)\n        self.assertNotEqual(key1, key2)", "num_test_cases": 7, "task_id": "f696f5f8"}
{"test": "import unittest\n\nclass TestGenerateEncryptionKey(unittest.TestCase):\n    def test_valid_key_size_128(self):\n        # Test valid 128-bit key: correct length and hex format\n        key = generate_encryption_key(128)\n        self.assertIsInstance(key, str)\n        self.assertEqual(len(key), 32)  # 16 bytes * 2 hex digits\n        self.assertTrue(all(c in '0123456789abcdef' for c in key))\n\n    def test_valid_key_size_192(self):\n        # Test valid 192-bit key: correct length and hex format\n        key = generate_encryption_key(192)\n        self.assertIsInstance(key, str)\n        self.assertEqual(len(key), 48)  # 24 bytes * 2 hex digits\n        self.assertTrue(all(c in '0123456789abcdef' for c in key))\n\n    def test_valid_key_size_256(self):\n        # Test valid 256-bit key: correct length and hex format\n        key = generate_encryption_key(256)\n        self.assertIsInstance(key, str)\n        self.assertEqual(len(key), 64)  # 32 bytes * 2 hex digits\n        self.assertTrue(all(c in '0123456789abcdef' for c in key))\n\n    def test_invalid_key_size_0(self):\n        # Test key_size=0 raises ValueError with correct message\n        with self.assertRaises(ValueError) as cm:\n            generate_encryption_key(0)\n        self.assertEqual(str(cm.exception), 'Invalid key size provided. Use 128, 192, or 256 bits.')\n\n    def test_invalid_key_size_negative(self):\n        # Test negative key_size raises ValueError with correct message\n        with self.assertRaises(ValueError) as cm:\n            generate_encryption_key(-128)\n        self.assertEqual(str(cm.exception), 'Invalid key size provided. Use 128, 192, or 256 bits.')\n\n    def test_invalid_key_size_100(self):\n        # Test invalid key_size (100) raises ValueError with correct message\n        with self.assertRaises(ValueError) as cm:\n            generate_encryption_key(100)\n        self.assertEqual(str(cm.exception), 'Invalid key size provided. Use 128, 192, or 256 bits.')\n\n    def test_invalid_key_size_200(self):\n        # Test invalid key_size (200) raises ValueError with correct message\n        with self.assertRaises(ValueError) as cm:\n            generate_encryption_key(200)\n        self.assertEqual(str(cm.exception), 'Invalid key size provided. Use 128, 192, or 256 bits.')\n\n    def test_invalid_key_size_300(self):\n        # Test invalid key_size (300) raises ValueError with correct message\n        with self.assertRaises(ValueError) as cm:\n            generate_encryption_key(300)\n        self.assertEqual(str(cm.exception), 'Invalid key size provided. Use 128, 192, or 256 bits.')\n\n    def test_key_randomness(self):\n        # Test consecutive keys for same size are different\n        key1 = generate_encryption_key(256)\n        key2 = generate_encryption_key(256)\n        self.assertNotEqual(key1, key2)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 9, "task_id": "38f63c0b"}
{"test": "import unittest\nimport string\n\nclass TestGeneratePassword(unittest.TestCase):\n\n    def test_valid_length_8(self):\n        # Test minimum valid length (8)\n        password = generate_password(8)\n        self.assertIsInstance(password, str)\n        self.assertEqual(len(password), 8)\n        allowed_chars = string.ascii_letters + string.digits + string.punctuation\n        for char in password:\n            self.assertIn(char, allowed_chars)\n\n    def test_valid_length_12(self):\n        # Test typical valid length (12)\n        password = generate_password(12)\n        self.assertIsInstance(password, str)\n        self.assertEqual(len(password), 12)\n        allowed_chars = string.ascii_letters + string.digits + string.punctuation\n        for char in password:\n            self.assertIn(char, allowed_chars)\n\n    def test_valid_large_length(self):\n        # Test very large valid length (1000)\n        password = generate_password(1000)\n        self.assertIsInstance(password, str)\n        self.assertEqual(len(password), 1000)\n        allowed_chars = string.ascii_letters + string.digits + string.punctuation\n        for char in password:\n            self.assertIn(char, allowed_chars)\n\n    def test_length_0(self):\n        # Test with zero length (invalid)\n        with self.assertRaises(ValueError) as context:\n            generate_password(0)\n        self.assertEqual(str(context.exception), \"Password length must be at least 8 characters.\")\n\n    def test_negative_length(self):\n        # Test negative length\n        with self.assertRaises(ValueError) as context:\n            generate_password(-5)\n        self.assertEqual(str(context.exception), \"Password length must be at least 8 characters.\")\n\n    def test_insufficient_length_7(self):\n        # Test length below minimum (7)\n        with self.assertRaises(ValueError) as context:\n            generate_password(7)\n        self.assertEqual(str(context.exception), \"Password length must be at least 8 characters.\")\n\n    def test_none_input(self):\n        # Test None input\n        with self.assertRaises(TypeError):\n            generate_password(None)\n\n    def test_float_input(self):\n        # Test float input\n        with self.assertRaises(TypeError):\n            generate_password(8.0)\n\n    def test_string_input(self):\n        # Test empty string input\n        with self.assertRaises(TypeError):\n            generate_password('')", "num_test_cases": 9, "task_id": "fecc3ff6"}
{"test": "import unittest\n\nclass TestGenerateUniqueIdentifier(unittest.TestCase):\n    def test_positive_length(self):\n        # Test with positive length: should raise NameError due to missing 'string' module in function\n        with self.assertRaises(NameError):\n            generate_unique_identifier(10)\n            \n    def test_zero_length(self):\n        # Test with zero length: should raise NameError\n        with self.assertRaises(NameError):\n            generate_unique_identifier(0)\n            \n    def test_negative_length(self):\n        # Test with negative length: should raise NameError\n        with self.assertRaises(NameError):\n            generate_unique_identifier(-5)\n            \n    def test_large_length(self):\n        # Test with large length: should raise NameError\n        with self.assertRaises(NameError):\n            generate_unique_identifier(1000)\n            \n    def test_length_one(self):\n        # Test with length=1: should raise NameError\n        with self.assertRaises(NameError):\n            generate_unique_identifier(1)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 5, "task_id": "e0ee2a18"}
{"test": "import unittest\nimport string\n\nclass TestGenerateSecureToken(unittest.TestCase):\n\n    def test_zero_length(self):\n        # Test token generation with zero length.\n        token = generate_secure_token(0)\n        self.assertEqual(token, '')\n        self.assertEqual(len(token), 0)\n\n    def test_negative_length(self):\n        # Test token generation with negative length.\n        token = generate_secure_token(-10)\n        self.assertEqual(token, '')\n        self.assertEqual(len(token), 0)\n\n    def test_length_one(self):\n        # Test token generation with length 1.\n        token = generate_secure_token(1)\n        self.assertEqual(len(token), 1)\n        self.assertIn(token, string.ascii_letters + string.digits)\n\n    def test_typical_length(self):\n        # Test token generation with a typical length (10).\n        token = generate_secure_token(10)\n        self.assertEqual(len(token), 10)\n        for char in token:\n            self.assertIn(char, string.ascii_letters + string.digits)\n\n    def test_large_length(self):\n        # Test token generation with a large length (1000).\n        token = generate_secure_token(1000)\n        self.assertEqual(len(token), 1000)\n        for char in token:\n            self.assertIn(char, string.ascii_letters + string.digits)\n\n    def test_uniqueness(self):\n        # Test that two generated tokens of length 16 are unique.\n        token1 = generate_secure_token(16)\n        token2 = generate_secure_token(16)\n        self.assertEqual(len(token1), 16)\n        self.assertEqual(len(token2), 16)\n        self.assertNotEqual(token1, token2)\n\n    def test_invalid_types(self):\n        # Test token generation with invalid types (non-integer) raises TypeError.\n        invalid_inputs = ['10', None, 10.0, [10], {10}]\n        for inp in invalid_inputs:\n            with self.subTest(inp=inp):\n                with self.assertRaises(TypeError):\n                    generate_secure_token(inp)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 7, "task_id": "8909704f"}
{"test": "import unittest\n\n# Global dictionary for the tests to manipulate\nVALID_API_MESSAGES = {}\n\n# Define the function to test\ndef validate_message(msg_id: str, sig: str):\n    try:\n        if msg_id in VALID_API_MESSAGES and VALID_API_MESSAGES[msg_id] == sig:\n            return True\n        else:\n            return False\n    except KeyError:\n        return False\n\nclass TestValidateMessage(unittest.TestCase):\n    def setUp(self):\n        \"\"\"Reset the global dictionary before each test.\"\"\"\n        global VALID_API_MESSAGES\n        VALID_API_MESSAGES = {\n            'existing_id_1': 'signature_1',\n            'existing_id_2': 'signature_2',\n            'id_empty_sig': '',\n            'id_none_sig': None,\n            'id_long': 'x' * 1000\n        }\n        VALID_API_MESSAGES[''] = 'empty_id_sig'\n        VALID_API_MESSAGES[123] = 456  # Non-string key for testing\n\n    def test_existing_id_matching_signature(self):\n        \"\"\"Test with existing msg_id and matching signature.\"\"\"\n        result = validate_message('existing_id_1', 'signature_1')\n        self.assertTrue(result)\n\n    def test_existing_id_non_matching_signature(self):\n        \"\"\"Test with existing msg_id but non-matching signature.\"\"\"\n        result = validate_message('existing_id_1', 'wrong_signature')\n        self.assertFalse(result)\n\n    def test_non_existing_id(self):\n        \"\"\"Test with non-existing msg_id.\"\"\"\n        result = validate_message('non_existing_id', 'any_signature')\n        self.assertFalse(result)\n\n    def test_empty_global_dict(self):\n        \"\"\"Test when global dictionary is empty.\"\"\"\n        global VALID_API_MESSAGES\n        VALID_API_MESSAGES = {}\n        result = validate_message('existing_id_1', 'signature_1')\n        self.assertFalse(result)\n\n    def test_long_inputs(self):\n        \"\"\"Test with very long msg_id and signature.\"\"\"\n        long_sig = 'y' * 1000\n        result = validate_message('id_long', long_sig)\n        self.assertTrue(result)\n\n    def test_empty_signature(self):\n        \"\"\"Test with empty string signature.\"\"\"\n        result = validate_message('id_empty_sig', '')\n        self.assertTrue(result)\n        result = validate_message('id_empty_sig', 'non_empty')\n        self.assertFalse(result)\n\n    def test_empty_msg_id(self):\n        \"\"\"Test with empty string msg_id.\"\"\"\n        result = validate_message('', 'empty_id_sig')\n        self.assertTrue(result)\n        result = validate_message('', 'wrong')\n        self.assertFalse(result)\n\n    def test_none_msg_id(self):\n        \"\"\"Test with None as msg_id.\"\"\"\n        result = validate_message(None, 'any_signature')\n        self.assertFalse(result)\n\n    def test_none_signature(self):\n        \"\"\"Test with None as signature.\"\"\"\n        result = validate_message('id_none_sig', None)\n        self.assertTrue(result)\n        result = validate_message('id_none_sig', 'non_none')\n        self.assertFalse(result)\n\n    def test_non_string_inputs(self):\n        \"\"\"Test with non-string msg_id and signature.\"\"\"\n        # Existing non-string key\n        result = validate_message(123, 456)\n        self.assertTrue(result)\n        # Non-existing non-string key\n        result = validate_message(456, 456)\n        self.assertFalse(result)\n        # Non-string signature for string key\n        result = validate_message('existing_id_1', 123)\n        self.assertFalse(result)\n        # Type mismatch: string vs non-string\n        result = validate_message('123', 456)\n        self.assertFalse(result)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 11, "task_id": "a235f9fa"}
{"test": "import unittest\nfrom solution import verify_message\nimport solution\n\nclass TestCases(unittest.TestCase):\n    def setUp(self):\n        solution.VALID_API_MESSAGES = {\n            'key1': 'signature1',\n            'key2': 'signature2',\n            '': 'empty_signature'\n        }\n\n    def test_case_1(self):\n        # Test existing key and correct signature\n        self.assertTrue(verify_message('key1', 'signature1'))\n\n    def test_case_2(self):\n        # Test existing key and incorrect signature\n        self.assertFalse(verify_message('key1', 'wrong'))\n\n    def test_case_3(self):\n        # Test non-existing key\n        self.assertFalse(verify_message('non_existent', 'signature1'))\n\n    def test_case_4(self):\n        # Test empty string key and correct signature\n        self.assertTrue(verify_message('', 'empty_signature'))\n\n    def test_case_5(self):\n        # Test empty string key and incorrect signature\n        self.assertFalse(verify_message('', 'wrong'))\n\n    def test_case_6(self):\n        # Test None as msg_identifier\n        self.assertFalse(verify_message(None, 'anything'))\n\n    def test_case_7(self):\n        # Test None as sign\n        self.assertFalse(verify_message('key1', None))\n\n    def test_case_8(self):\n        # Test integer as msg_identifier\n        self.assertFalse(verify_message(123, 'signature1'))\n\n    def test_case_9(self):\n        # Test integer as sign\n        self.assertFalse(verify_message('key1', 123))\n\n    def test_case_10(self):\n        # Test with empty dictionary\n        solution.VALID_API_MESSAGES = {}\n        self.assertFalse(verify_message('key1', 'signature1'))\n\n    def test_case_11(self):\n        # Test long string key with correct signature\n        long_str = 'a' * 10000\n        solution.VALID_API_MESSAGES = {long_str: 'long_signature'}\n        self.assertTrue(verify_message(long_str, 'long_signature'))\n\n    def test_case_12(self):\n        # Test long string key with incorrect signature\n        long_str = 'a' * 10000\n        solution.VALID_API_MESSAGES = {long_str: 'long_signature'}\n        self.assertFalse(verify_message(long_str, 'wrong'))\n\n    def test_case_13(self):\n        # Test non-existing empty string (dictionary without empty string key)\n        solution.VALID_API_MESSAGES = {'key1': 'signature1', 'key2': 'signature2'}\n        self.assertFalse(verify_message('', 'anything'))\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 13, "task_id": "fab4ca1c"}
{"test": "import unittest\n\nclass TestCheckMessageIntegrity(unittest.TestCase):\n    def setUp(self):\n        # Backup and set up the global VALID_API_MESSAGES for testing\n        global VALID_API_MESSAGES\n        self.original_dict = globals().get('VALID_API_MESSAGES', None)\n        globals()['VALID_API_MESSAGES'] = {\n            'msg1': 'sign1',\n            'msg2': 'sign2',\n            '': 'empty_signature',\n            'long_msg': 'a' * 1000\n        }\n    \n    def tearDown(self):\n        # Restore the original VALID_API_MESSAGES\n        global VALID_API_MESSAGES\n        if self.original_dict is not None:\n            globals()['VALID_API_MESSAGES'] = self.original_dict\n        else:\n            if 'VALID_API_MESSAGES' in globals():\n                del globals()['VALID_API_MESSAGES']\n    \n    def test_case_1(self):\n        # Test existing message with correct signature returns True\n        result = check_message_integrity('msg1', 'sign1')\n        self.assertTrue(result)\n    \n    def test_case_2(self):\n        # Test existing message with incorrect signature returns False\n        result = check_message_integrity('msg1', 'wrong_sign')\n        self.assertFalse(result)\n    \n    def test_case_3(self):\n        # Test non-existing message returns False\n        result = check_message_integrity('msg3', 'any_sign')\n        self.assertFalse(result)\n    \n    def test_case_4(self):\n        # Test existing empty message with correct signature returns True\n        result = check_message_integrity('', 'empty_signature')\n        self.assertTrue(result)\n    \n    def test_case_5(self):\n        # Test existing empty message with incorrect signature returns False\n        result = check_message_integrity('', 'wrong_sign')\n        self.assertFalse(result)\n    \n    def test_case_6(self):\n        # Test non-string msg_code (integer) returns False\n        result = check_message_integrity(123, 'sign1')\n        self.assertFalse(result)\n    \n    def test_case_7(self):\n        # Test non-string crypto_sign (integer) for existing message returns False\n        result = check_message_integrity('msg1', 123)\n        self.assertFalse(result)\n    \n    def test_case_8(self):\n        # Test long existing message with correct signature returns True\n        result = check_message_integrity('long_msg', 'a' * 1000)\n        self.assertTrue(result)\n    \n    def test_case_9(self):\n        # Test long existing message with incorrect signature returns False\n        result = check_message_integrity('long_msg', 'b' * 1000)\n        self.assertFalse(result)\n    \n    def test_case_10(self):\n        # Test long non-existing message returns False\n        result = check_message_integrity('nonexistent_long_msg', 'a' * 1000)\n        self.assertFalse(result)\n    \n    def test_case_11(self):\n        # Test None for msg_code returns False\n        result = check_message_integrity(None, 'sign1')\n        self.assertFalse(result)\n    \n    def test_case_12(self):\n        # Test None for crypto_sign for existing message returns False\n        result = check_message_integrity('msg1', None)\n        self.assertFalse(result)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 12, "task_id": "2de38d38"}
{"test": "import unittest\nimport sys\nfrom unittest.mock import patch\n\nclass TestVerifyApiMessage(unittest.TestCase):\n    def test_happy_path_match(self):\n        # Test valid message ID and matching signature\n        current_module = sys.modules[__name__]\n        test_dict = {'msg1': 'sig1'}\n        with patch.object(current_module, 'VALID_API_MESSAGES', test_dict):\n            result = verify_api_message('msg1', 'sig1')\n            self.assertTrue(result)\n    \n    def test_happy_path_mismatch(self):\n        # Test valid message ID but non-matching signature\n        current_module = sys.modules[__name__]\n        test_dict = {'msg1': 'sig1'}\n        with patch.object(current_module, 'VALID_API_MESSAGES', test_dict):\n            result = verify_api_message('msg1', 'wrong_sig')\n            self.assertFalse(result)\n    \n    def test_msg_id_not_found(self):\n        # Test non-existent message ID\n        current_module = sys.modules[__name__]\n        test_dict = {'msg1': 'sig1'}\n        with patch.object(current_module, 'VALID_API_MESSAGES', test_dict):\n            result = verify_api_message('msg2', 'any_sig')\n            self.assertFalse(result)\n    \n    def test_empty_dict(self):\n        # Test when VALID_API_MESSAGES is empty\n        current_module = sys.modules[__name__]\n        test_dict = {}\n        with patch.object(current_module, 'VALID_API_MESSAGES', test_dict):\n            result = verify_api_message('msg1', 'sig1')\n            self.assertFalse(result)\n    \n    def test_empty_signature_match(self):\n        # Test matching empty string signature\n        current_module = sys.modules[__name__]\n        test_dict = {'msg1': ''}\n        with patch.object(current_module, 'VALID_API_MESSAGES', test_dict):\n            result = verify_api_message('msg1', '')\n            self.assertTrue(result)\n    \n    def test_empty_signature_mismatch(self):\n        # Test non-matching empty string signature\n        current_module = sys.modules[__name__]\n        test_dict = {'msg1': ''}\n        with patch.object(current_module, 'VALID_API_MESSAGES', test_dict):\n            result = verify_api_message('msg1', 'non_empty')\n            self.assertFalse(result)\n    \n    def test_empty_msg_id_found(self):\n        # Test empty string message ID found\n        current_module = sys.modules[__name__]\n        test_dict = {'': 'sig1'}\n        with patch.object(current_module, 'VALID_API_MESSAGES', test_dict):\n            result = verify_api_message('', 'sig1')\n            self.assertTrue(result)\n    \n    def test_empty_msg_id_not_found(self):\n        # Test empty string message ID not found\n        current_module = sys.modules[__name__]\n        test_dict = {'msg1': 'sig1'}\n        with patch.object(current_module, 'VALID_API_MESSAGES', test_dict):\n            result = verify_api_message('', 'any_sig')\n            self.assertFalse(result)\n    \n    def test_msg_id_none_found(self):\n        # Test None message ID found\n        current_module = sys.modules[__name__]\n        test_dict = {None: 'sig1'}\n        with patch.object(current_module, 'VALID_API_MESSAGES', test_dict):\n            result = verify_api_message(None, 'sig1')\n            self.assertTrue(result)\n    \n    def test_msg_id_none_not_found(self):\n        # Test None message ID not found\n        current_module = sys.modules[__name__]\n        test_dict = {'msg1': 'sig1'}\n        with patch.object(current_module, 'VALID_API_MESSAGES', test_dict):\n            result = verify_api_message(None, 'any_sig')\n            self.assertFalse(result)\n    \n    def test_non_string_msg_id_found(self):\n        # Test non-string message ID found\n        current_module = sys.modules[__name__]\n        test_dict = {123: 'sig1'}\n        with patch.object(current_module, 'VALID_API_MESSAGES', test_dict):\n            result = verify_api_message(123, 'sig1')\n            self.assertTrue(result)\n    \n    def test_non_string_msg_id_not_found(self):\n        # Test non-string message ID not found\n        current_module = sys.modules[__name__]\n        test_dict = {'msg1': 'sig1'}\n        with patch.object(current_module, 'VALID_API_MESSAGES', test_dict):\n            result = verify_api_message(123, 'any_sig')\n            self.assertFalse(result)\n    \n    def test_non_string_signature_match(self):\n        # Test non-string signature match\n        current_module = sys.modules[__name__]\n        test_dict = {'msg1': 123}\n        with patch.object(current_module, 'VALID_API_MESSAGES', test_dict):\n            result = verify_api_message('msg1', 123)\n            self.assertTrue(result)\n    \n    def test_non_string_signature_mismatch(self):\n        # Test non-string signature mismatch\n        current_module = sys.modules[__name__]\n        test_dict = {'msg1': 123}\n        with patch.object(current_module, 'VALID_API_MESSAGES', test_dict):\n            result = verify_api_message('msg1', 456)\n            self.assertFalse(result)\n    \n    def test_different_types_signature(self):\n        # Test different signature types (string vs integer)\n        current_module = sys.modules[__name__]\n        test_dict = {'msg1': 123}\n        with patch.object(current_module, 'VALID_API_MESSAGES', test_dict):\n            result = verify_api_message('msg1', '123')\n            self.assertFalse(result)\n    \n    def test_long_signature(self):\n        # Test long string signature\n        current_module = sys.modules[__name__]\n        long_sig = 'a' * 10000\n        test_dict = {'msg1': long_sig}\n        with patch.object(current_module, 'VALID_API_MESSAGES', test_dict):\n            result = verify_api_message('msg1', long_sig)\n            self.assertTrue(result)\n            result = verify_api_message('msg1', long_sig + 'a')\n            self.assertFalse(result)\n    \n    def test_long_msg_id(self):\n        # Test long string message ID\n        current_module = sys.modules[__name__]\n        long_id = 'a' * 10000\n        test_dict = {long_id: 'sig1'}\n        with patch.object(current_module, 'VALID_API_MESSAGES', test_dict):\n            result = verify_api_message(long_id, 'sig1')\n            self.assertTrue(result)\n            result = verify_api_message(long_id, 'wrong_sig')\n            self.assertFalse(result)\n    \n    def test_concurrent_key_removal_handling(self):\n        # Test KeyError handling during dictionary access\n        class KeyErrorDict:\n            def __init__(self, d):\n                self.d = d\n            def __contains__(self, key):\n                return True\n            def __getitem__(self, key):\n                raise KeyError(key)\n        current_module = sys.modules[__name__]\n        test_dict = KeyErrorDict({'msg1': 'sig1'})\n        with patch.object(current_module, 'VALID_API_MESSAGES', test_dict):\n            result = verify_api_message('msg1', 'sig1')\n            self.assertFalse(result)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 19, "task_id": "5c05abbc"}
{"test": "import unittest\nfrom unittest.mock import patch\n\n# Import the function\nfrom solution import validate_api_message\n\n# Define a flaky dictionary for testing KeyError handling\nclass FlakyDict:\n    def __contains__(self, key):\n        return True\n    def __getitem__(self, key):\n        raise KeyError(key)\n\nclass TestCases(unittest.TestCase):\n    def test_valid_matching(self):\n        \"\"\"Test valid id and matching signature returns True\"\"\"\n        with patch('solution.VALID_API_MESSAGES', {'id1': 'sig1'}):\n            result = validate_api_message('id1', 'sig1')\n            self.assertTrue(result)\n\n    def test_valid_but_mismatch(self):\n        \"\"\"Test valid id but mismatched signature returns False\"\"\"\n        with patch('solution.VALID_API_MESSAGES', {'id1': 'sig1'}):\n            result = validate_api_message('id1', 'wrong_sig')\n            self.assertFalse(result)\n\n    def test_invalid_id(self):\n        \"\"\"Test invalid id returns False\"\"\"\n        with patch('solution.VALID_API_MESSAGES', {'id1': 'sig1'}):\n            result = validate_api_message('id2', 'sig1')\n            self.assertFalse(result)\n\n    def test_empty_id_exists(self):\n        \"\"\"Test empty id with matching signature returns True\"\"\"\n        with patch('solution.VALID_API_MESSAGES', {'': 'empty_sig'}):\n            result = validate_api_message('', 'empty_sig')\n            self.assertTrue(result)\n\n    def test_empty_id_not_exists(self):\n        \"\"\"Test empty id that doesn't exist returns False\"\"\"\n        with patch('solution.VALID_API_MESSAGES', {'id1': 'sig1'}):\n            result = validate_api_message('', 'any_sig')\n            self.assertFalse(result)\n\n    def test_empty_signature_match(self):\n        \"\"\"Test existing id with empty stored and passed signature returns True\"\"\"\n        with patch('solution.VALID_API_MESSAGES', {'id1': ''}):\n            result = validate_api_message('id1', '')\n            self.assertTrue(result)\n\n    def test_empty_signature_mismatch(self):\n        \"\"\"Test existing id with non-empty stored signature and empty passed signature returns False\"\"\"\n        with patch('solution.VALID_API_MESSAGES', {'id1': 'non_empty'}):\n            result = validate_api_message('id1', '')\n            self.assertFalse(result)\n\n    def test_long_strings_match(self):\n        \"\"\"Test long id and signature match returns True\"\"\"\n        long_id = 'a' * 1000\n        long_sig = 'b' * 1000\n        with patch('solution.VALID_API_MESSAGES', {long_id: long_sig}):\n            result = validate_api_message(long_id, long_sig)\n            self.assertTrue(result)\n\n    def test_long_strings_mismatch(self):\n        \"\"\"Test long id with mismatched long signature returns False\"\"\"\n        long_id = 'a' * 1000\n        long_sig = 'b' * 1000\n        with patch('solution.VALID_API_MESSAGES', {long_id: long_sig}):\n            result = validate_api_message(long_id, long_sig[:-1] + 'c')\n            self.assertFalse(result)\n\n    def test_flaky_dict_raises_keyerror(self):\n        \"\"\"Test KeyError during dictionary access returns False\"\"\"\n        flaky_dict = FlakyDict()\n        with patch('solution.VALID_API_MESSAGES', flaky_dict):\n            result = validate_api_message('any_id', 'any_signature')\n            self.assertFalse(result)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 10, "task_id": "c18f69d5"}
{"test": "import unittest\n\n# Define the global dictionary and the function as per the provided code\nVALID_API_MESSAGES = {}\n\ndef check_message_authenticity(msg_identifier: str, crypto_sign: str):\n    try:\n        if msg_identifier in VALID_API_MESSAGES and VALID_API_MESSAGES[msg_identifier] == crypto_sign:\n            return True\n        else:\n            return False\n    except KeyError:\n        return False\n\nclass TestCases(unittest.TestCase):\n    def setUp(self):\n        # Reset and initialize the global dictionary before each test\n        global VALID_API_MESSAGES\n        VALID_API_MESSAGES = {\n            'msg1': 'signature1',\n            'msg2': 'signature2',\n            'msg3': 'signature3'\n        }\n    \n    def test_valid_matching(self):\n        # Test valid identifier with matching signature returns True\n        result = check_message_authenticity('msg1', 'signature1')\n        self.assertTrue(result)\n    \n    def test_valid_non_matching(self):\n        # Test valid identifier with non-matching signature returns False\n        result = check_message_authenticity('msg1', 'wrong_signature')\n        self.assertFalse(result)\n    \n    def test_key_not_found(self):\n        # Test non-existent identifier returns False\n        result = check_message_authenticity('msg4', 'signature1')\n        self.assertFalse(result)\n    \n    def test_empty_string_not_present(self):\n        # Test empty string identifier not in dictionary returns False\n        result = check_message_authenticity('', 'any_signature')\n        self.assertFalse(result)\n    \n    def test_empty_string_present(self):\n        # Test empty string identifier in dictionary with matching signature returns True\n        global VALID_API_MESSAGES\n        VALID_API_MESSAGES[''] = 'empty_sig'\n        result = check_message_authenticity('', 'empty_sig')\n        self.assertTrue(result)\n    \n    def test_none_not_present(self):\n        # Test None identifier not in dictionary returns False\n        result = check_message_authenticity(None, 'any_signature')\n        self.assertFalse(result)\n    \n    def test_none_present(self):\n        # Test None identifier in dictionary with matching signature returns True\n        global VALID_API_MESSAGES\n        VALID_API_MESSAGES[None] = 'none_sig'\n        result = check_message_authenticity(None, 'none_sig')\n        self.assertTrue(result)\n    \n    def test_long_string_matching(self):\n        # Test very long identifier in dictionary with matching signature returns True\n        global VALID_API_MESSAGES\n        long_id = 'A' * 10000\n        VALID_API_MESSAGES[long_id] = 'long_sig'\n        result = check_message_authenticity(long_id, 'long_sig')\n        self.assertTrue(result)\n    \n    def test_long_string_non_matching(self):\n        # Test very long identifier in dictionary with non-matching signature returns False\n        global VALID_API_MESSAGES\n        long_id = 'A' * 10000\n        VALID_API_MESSAGES[long_id] = 'long_sig'\n        result = check_message_authenticity(long_id, 'wrong_signature')\n        self.assertFalse(result)\n    \n    def test_flaky_key_error_handling(self):\n        # Test handling of KeyError during dictionary access returns False\n        class FlakyDict(dict):\n            def __getitem__(self, key):\n                if key == 'flaky_key':\n                    raise KeyError(\"Simulated access error\")\n                return super().__getitem__(key)\n        \n        global VALID_API_MESSAGES\n        VALID_API_MESSAGES = FlakyDict({'flaky_key': 'some_sig'})\n        result = check_message_authenticity('flaky_key', 'some_sig')\n        self.assertFalse(result)\n    \n    def test_integer_key_present(self):\n        # Test non-string (integer) identifier in dictionary with matching signature returns True\n        global VALID_API_MESSAGES\n        VALID_API_MESSAGES[123] = 'int_sig'\n        result = check_message_authenticity(123, 'int_sig')\n        self.assertTrue(result)\n    \n    def test_integer_key_not_present(self):\n        # Test non-string (integer) identifier not in dictionary returns False\n        result = check_message_authenticity(456, 'int_sig')\n        self.assertFalse(result)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 12, "task_id": "a00eb92e"}
{"test": "import unittest\nfrom unittest.mock import patch\n\nclass TestVerifyMessage(unittest.TestCase):\n    def setUp(self):\n        self.base_valid = {\n            'msg1': 'sig1',\n            'msg2': 'sig2',\n            '': 'empty_sig'\n        }\n        \n    def test_case_1(self):\n        \"\"\"Test with valid api_message_id and matching crypto_signature.\"\"\"\n        with patch('__main__.VALID_API_MESSAGES', self.base_valid):\n            result = verify_message('msg1', 'sig1')\n            self.assertTrue(result)\n            \n    def test_case_2(self):\n        \"\"\"Test with valid api_message_id but non-matching crypto_signature.\"\"\"\n        with patch('__main__.VALID_API_MESSAGES', self.base_valid):\n            result = verify_message('msg1', 'wrong_sig')\n            self.assertFalse(result)\n            \n    def test_case_3(self):\n        \"\"\"Test with invalid api_message_id (not in VALID_API_MESSAGES).\"\"\"\n        with patch('__main__.VALID_API_MESSAGES', self.base_valid):\n            result = verify_message('invalid_id', 'any_sig')\n            self.assertFalse(result)\n            \n    def test_case_4(self):\n        \"\"\"Test with empty string api_message_id that exists in VALID_API_MESSAGES and matching signature.\"\"\"\n        with patch('__main__.VALID_API_MESSAGES', self.base_valid):\n            result = verify_message('', 'empty_sig')\n            self.assertTrue(result)\n            \n    def test_case_5(self):\n        \"\"\"Test with empty string api_message_id that does not exist in VALID_API_MESSAGES.\"\"\"\n        with patch('__main__.VALID_API_MESSAGES', self.base_valid):\n            result = verify_message(' ', 'any_sig')  # Space is not in the dictionary\n            self.assertFalse(result)\n            \n    def test_case_6(self):\n        \"\"\"Test with None as api_message_id.\"\"\"\n        with patch('__main__.VALID_API_MESSAGES', self.base_valid):\n            result = verify_message(None, 'any_sig')\n            self.assertFalse(result)\n            \n    def test_case_7(self):\n        \"\"\"Test with integer api_message_id (non-string).\"\"\"\n        with patch('__main__.VALID_API_MESSAGES', self.base_valid):\n            result = verify_message(123, 'any_sig')\n            self.assertFalse(result)\n            \n    def test_case_8(self):\n        \"\"\"Test with valid api_message_id but None as crypto_signature.\"\"\"\n        with patch('__main__.VALID_API_MESSAGES', self.base_valid):\n            result = verify_message('msg1', None)\n            self.assertFalse(result)\n            \n    def test_case_9(self):\n        \"\"\"Test with very long api_message_id and crypto_signature strings.\"\"\"\n        long_id = 'A' * 10000\n        long_sig = 'B' * 10000\n        valid_dict = {long_id: long_sig}\n        with patch('__main__.VALID_API_MESSAGES', valid_dict):\n            result = verify_message(long_id, long_sig)\n            self.assertTrue(result)\n            \n    def test_case_10(self):\n        \"\"\"Test when VALID_API_MESSAGES is empty.\"\"\"\n        with patch('__main__.VALID_API_MESSAGES', {}):\n            result = verify_message('msg1', 'sig1')\n            self.assertFalse(result)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 10, "task_id": "991f7747"}
{"test": "import unittest\n\n# Global dictionary to be used by the function\nVALID_API_MESSAGES = {}\n\nclass TestValidateApiMessage(unittest.TestCase):\n    def setUp(self):\n        \"\"\"Set up the global VALID_API_MESSAGES for each test.\"\"\"\n        global VALID_API_MESSAGES\n        self.original_valid_api_messages = VALID_API_MESSAGES\n        VALID_API_MESSAGES = {\n            \"msg1\": \"signature1\",\n            \"msg2\": \"signature2\",\n            \"\": \"empty_signature\",\n            \"long_id\" * 100: \"long_signature\" * 100\n        }\n    \n    def tearDown(self):\n        \"\"\"Reset the global VALID_API_MESSAGES after each test.\"\"\"\n        global VALID_API_MESSAGES\n        VALID_API_MESSAGES = self.original_valid_api_messages\n    \n    def test_valid_identifier_and_signature(self):\n        \"\"\"Test with a valid identifier and matching signature.\"\"\"\n        result = validate_api_message(\"msg1\", \"signature1\")\n        self.assertTrue(result)\n    \n    def test_valid_identifier_but_invalid_signature(self):\n        \"\"\"Test with a valid identifier but non-matching signature.\"\"\"\n        result = validate_api_message(\"msg1\", \"wrong_signature\")\n        self.assertFalse(result)\n    \n    def test_invalid_identifier(self):\n        \"\"\"Test with an identifier not in the dictionary.\"\"\"\n        result = validate_api_message(\"non_existent\", \"any_signature\")\n        self.assertFalse(result)\n    \n    def test_empty_string_identifier_valid_signature(self):\n        \"\"\"Test with empty string identifier and matching signature.\"\"\"\n        result = validate_api_message(\"\", \"empty_signature\")\n        self.assertTrue(result)\n    \n    def test_empty_string_identifier_invalid_signature(self):\n        \"\"\"Test with empty string identifier and non-matching signature.\"\"\"\n        result = validate_api_message(\"\", \"wrong_signature\")\n        self.assertFalse(result)\n    \n    def test_none_identifier(self):\n        \"\"\"Test with None as identifier.\"\"\"\n        result = validate_api_message(None, \"any_signature\")\n        self.assertFalse(result)\n    \n    def test_integer_identifier(self):\n        \"\"\"Test with an integer identifier not in the dictionary.\"\"\"\n        result = validate_api_message(123, \"any_signature\")\n        self.assertFalse(result)\n    \n    def test_non_hashable_identifier(self):\n        \"\"\"Test with a non-hashable identifier (list) which should raise TypeError.\"\"\"\n        with self.assertRaises(TypeError):\n            validate_api_message([\"list_key\"], \"any_signature\")\n    \n    def test_non_string_signature(self):\n        \"\"\"Test with a non-string signature (integer) for an existing identifier.\"\"\"\n        result = validate_api_message(\"msg1\", 123)\n        self.assertFalse(result)\n    \n    def test_flaky_dict_raises_keyerror(self):\n        \"\"\"Test scenario where dictionary access raises KeyError.\"\"\"\n        class FlakyDict(dict):\n            def __getitem__(self, key):\n                if key == \"flaky_key\":\n                    raise KeyError(key)\n                return super().__getitem__(key)\n                \n        global VALID_API_MESSAGES\n        original_dict = VALID_API_MESSAGES\n        try:\n            VALID_API_MESSAGES = FlakyDict({\"flaky_key\": \"signature\"})\n            result = validate_api_message(\"flaky_key\", \"signature\")\n            self.assertFalse(result)\n        finally:\n            VALID_API_MESSAGES = original_dict\n    \n    def test_long_strings_valid(self):\n        \"\"\"Test with very long identifier and matching signature.\"\"\"\n        long_id = \"long_id\" * 100\n        long_sig = \"long_signature\" * 100\n        result = validate_api_message(long_id, long_sig)\n        self.assertTrue(result)\n    \n    def test_long_strings_invalid_signature(self):\n        \"\"\"Test with very long identifier and non-matching signature.\"\"\"\n        long_id = \"long_id\" * 100\n        result = validate_api_message(long_id, \"wrong_signature\")\n        self.assertFalse(result)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 12, "task_id": "281ae350"}
{"test": "import unittest\nfrom unittest.mock import patch\n\nclass TestCases(unittest.TestCase):\n    \n    def test_valid_signature(self):\n        \"\"\"Test valid message and matching signature returns True.\"\"\"\n        with patch('__main__.VALID_API_MESSAGES', {'test_message': 'valid_signature'}):\n            result = check_api_signature('test_message', 'valid_signature')\n            self.assertTrue(result)\n    \n    def test_invalid_signature(self):\n        \"\"\"Test valid message with non-matching signature returns False.\"\"\"\n        with patch('__main__.VALID_API_MESSAGES', {'test_message': 'valid_signature'}):\n            result = check_api_signature('test_message', 'invalid_signature')\n            self.assertFalse(result)\n    \n    def test_message_not_in_dictionary(self):\n        \"\"\"Test message not in VALID_API_MESSAGES returns False.\"\"\"\n        with patch('__main__.VALID_API_MESSAGES', {'other_message': 'signature'}):\n            result = check_api_signature('test_message', 'any_signature')\n            self.assertFalse(result)\n    \n    def test_empty_message_valid(self):\n        \"\"\"Test empty message in dictionary with matching signature returns True.\"\"\"\n        with patch('__main__.VALID_API_MESSAGES', {'': 'empty_signature'}):\n            result = check_api_signature('', 'empty_signature')\n            self.assertTrue(result)\n    \n    def test_empty_message_invalid(self):\n        \"\"\"Test empty message in dictionary with non-matching signature returns False.\"\"\"\n        with patch('__main__.VALID_API_MESSAGES', {'': 'empty_signature'}):\n            result = check_api_signature('', 'wrong_signature')\n            self.assertFalse(result)\n    \n    def test_empty_message_not_in_dictionary(self):\n        \"\"\"Test empty message not in dictionary returns False.\"\"\"\n        with patch('__main__.VALID_API_MESSAGES', {'non_empty': 'signature'}):\n            result = check_api_signature('', 'any_signature')\n            self.assertFalse(result)\n    \n    def test_none_message_not_in_dictionary(self):\n        \"\"\"Test None as message not in dictionary returns False.\"\"\"\n        with patch('__main__.VALID_API_MESSAGES', {'test_message': 'signature'}):\n            result = check_api_signature(None, 'any_signature')\n            self.assertFalse(result)\n    \n    def test_none_message_in_dictionary(self):\n        \"\"\"Test None as message in dictionary with matching signature returns True.\"\"\"\n        with patch('__main__.VALID_API_MESSAGES', {None: 'none_signature'}):\n            result = check_api_signature(None, 'none_signature')\n            self.assertTrue(result)\n    \n    def test_none_signature(self):\n        \"\"\"Test valid message with None as signature returns False.\"\"\"\n        with patch('__main__.VALID_API_MESSAGES', {'test_message': 'valid_signature'}):\n            result = check_api_signature('test_message', None)\n            self.assertFalse(result)\n    \n    def test_flaky_dictionary_keyerror_handling(self):\n        \"\"\"Test that KeyError during dictionary access is caught and returns False.\"\"\"\n        class FlakyDict:\n            def __contains__(self, key):\n                return True\n            def __getitem__(self, key):\n                raise KeyError(key)\n        \n        with patch('__main__.VALID_API_MESSAGES', FlakyDict()):\n            result = check_api_signature('any_message', 'any_signature')\n            self.assertFalse(result)\n", "num_test_cases": 10, "task_id": "3ac08383"}
{"test": "import unittest\nfrom unittest.mock import patch, MagicMock\n\n# Import the function from the solution module\nfrom solution import process_data_packet\n\nclass TestProcessDataPacket(unittest.TestCase):\n\n    def test_case_1(self):\n        # Happy path: trusted device, correct signature -> returns packet\n        with patch('solution.TRUSTED_DEVICE_SIGNATURES', {'dev1': 'sig1'}):\n            with patch('solution.get_data_packet') as mock_get:\n                mock_get.return_value = {'temperature': 25.5}\n                result = process_data_packet('dev1', 'sig1', {'key': 'value'})\n                self.assertEqual(result, {'temperature': 25.5})\n                mock_get.assert_called_once_with('dev1')\n\n    def test_case_2(self):\n        # Trusted device, wrong signature -> returns None\n        with patch('solution.TRUSTED_DEVICE_SIGNATURES', {'dev1': 'sig1'}):\n            result = process_data_packet('dev1', 'wrong_sig', {'key': 'value'})\n            self.assertIsNone(result)\n\n    def test_case_3(self):\n        # Untrusted device -> returns None\n        with patch('solution.TRUSTED_DEVICE_SIGNATURES', {'dev1': 'sig1'}):\n            result = process_data_packet('dev2', 'any_sig', {'key': 'value'})\n            self.assertIsNone(result)\n\n    def test_case_4(self):\n        # ConnectionError in get_data_packet -> returns None\n        with patch('solution.TRUSTED_DEVICE_SIGNATURES', {'dev1': 'sig1'}):\n            with patch('solution.get_data_packet') as mock_get:\n                mock_get.side_effect = ConnectionError\n                result = process_data_packet('dev1', 'sig1', {'key': 'value'})\n                self.assertIsNone(result)\n                mock_get.assert_called_once_with('dev1')\n\n    def test_case_5(self):\n        # Empty payload (function ignores payload)\n        with patch('solution.TRUSTED_DEVICE_SIGNATURES', {'dev1': 'sig1'}):\n            with patch('solution.get_data_packet') as mock_get:\n                mock_get.return_value = {'status': 'ok'}\n                result = process_data_packet('dev1', 'sig1', {})\n                self.assertEqual(result, {'status': 'ok'})\n                mock_get.assert_called_once_with('dev1')\n\n    def test_case_6(self):\n        # Empty dev_id not in trusted -> returns None\n        with patch('solution.TRUSTED_DEVICE_SIGNATURES', {'dev1': 'sig1'}):\n            result = process_data_packet('', 'any_sig', {'key': 'value'})\n            self.assertIsNone(result)\n\n    def test_case_7(self):\n        # Empty dev_id in trusted, correct signature -> returns packet\n        with patch('solution.TRUSTED_DEVICE_SIGNATURES', {'': 'empty_sig'}):\n            with patch('solution.get_data_packet') as mock_get:\n                mock_get.return_value = {'id': 'empty'}\n                result = process_data_packet('', 'empty_sig', {'key': 'value'})\n                self.assertEqual(result, {'id': 'empty'})\n                mock_get.assert_called_once_with('')\n\n    def test_case_8(self):\n        # Empty dev_id in trusted, wrong signature -> returns None\n        with patch('solution.TRUSTED_DEVICE_SIGNATURES', {'': 'empty_sig'}):\n            result = process_data_packet('', 'wrong_sig', {'key': 'value'})\n            self.assertIsNone(result)\n\n    def test_case_9(self):\n        # Empty signature, trusted non-empty -> returns None\n        with patch('solution.TRUSTED_DEVICE_SIGNATURES', {'dev1': 'non_empty'}):\n            result = process_data_packet('dev1', '', {'key': 'value'})\n            self.assertIsNone(result)\n\n    def test_case_10(self):\n        # Empty signature, trusted empty -> returns packet\n        with patch('solution.TRUSTED_DEVICE_SIGNATURES', {'dev1': ''}):\n            with patch('solution.get_data_packet') as mock_get:\n                mock_get.return_value = {'sig': 'empty'}\n                result = process_data_packet('dev1', '', {'key': 'value'})\n                self.assertEqual(result, {'sig': 'empty'})\n                mock_get.assert_called_once_with('dev1')\n\n    def test_case_11(self):\n        # Long strings (1000 chars) for dev_id and signature -> returns packet\n        long_id = 'A' * 1000\n        long_sig = 'B' * 1000\n        with patch('solution.TRUSTED_DEVICE_SIGNATURES', {long_id: long_sig}):\n            with patch('solution.get_data_packet') as mock_get:\n                mock_get.return_value = {'data': 'long'}\n                result = process_data_packet(long_id, long_sig, {'key': 'value'})\n                self.assertEqual(result, {'data': 'long'})\n                mock_get.assert_called_once_with(long_id)\n\n    def test_case_12(self):\n        # dev_id is None -> returns None\n        with patch('solution.TRUSTED_DEVICE_SIGNATURES', {'dev1': 'sig1'}):\n            result = process_data_packet(None, 'any_sig', {'key': 'value'})\n            self.assertIsNone(result)\n\n    def test_case_13(self):\n        # sign is None -> returns None\n        with patch('solution.TRUSTED_DEVICE_SIGNATURES', {'dev1': 'sig1'}):\n            result = process_data_packet('dev1', None, {'key': 'value'})\n            self.assertIsNone(result)\n\n    def test_case_14(self):\n        # Trusted signature is None and sign is None -> returns packet\n        with patch('solution.TRUSTED_DEVICE_SIGNATURES', {'dev1': None}):\n            with patch('solution.get_data_packet') as mock_get:\n                mock_get.return_value = {'data': 'none'}\n                result = process_data_packet('dev1', None, {'key': 'value'})\n                self.assertEqual(result, {'data': 'none'})\n                mock_get.assert_called_once_with('dev1')\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 14, "task_id": "80665371"}
{"test": "import unittest\nfrom unittest.mock import patch\n\nclass TestCases(unittest.TestCase):\n    \n    def test_happy_path(self):\n        \"\"\"Test with trusted device and matching signature.\"\"\"\n        with patch('__main__.TRUSTED_DEVICE_SIGNATURES', {'dev1': 'sig1'}):\n            with patch('__main__.get_packet_data') as mock_get:\n                mock_get.return_value = {'data': 'test'}\n                result = verify_data_packet('dev1', 'sig1', {})\n                self.assertEqual(result, {'data': 'test'})\n                mock_get.assert_called_once_with('dev1')\n    \n    def test_device_not_trusted(self):\n        \"\"\"Test with device not in trusted list.\"\"\"\n        with patch('__main__.TRUSTED_DEVICE_SIGNATURES', {'dev1': 'sig1'}):\n            with patch('__main__.get_packet_data') as mock_get:\n                result = verify_data_packet('dev2', 'any_sig', {})\n                self.assertIsNone(result)\n                mock_get.assert_not_called()\n    \n    def test_signature_mismatch(self):\n        \"\"\"Test with trusted device but signature mismatch.\"\"\"\n        with patch('__main__.TRUSTED_DEVICE_SIGNATURES', {'dev1': 'sig1'}):\n            with patch('__main__.get_packet_data') as mock_get:\n                result = verify_data_packet('dev1', 'wrong_sig', {})\n                self.assertIsNone(result)\n                mock_get.assert_not_called()\n    \n    def test_connection_error(self):\n        \"\"\"Test ConnectionError during get_packet_data.\"\"\"\n        with patch('__main__.TRUSTED_DEVICE_SIGNATURES', {'dev1': 'sig1'}):\n            with patch('__main__.get_packet_data') as mock_get:\n                mock_get.side_effect = ConnectionError\n                result = verify_data_packet('dev1', 'sig1', {})\n                self.assertIsNone(result)\n                mock_get.assert_called_once_with('dev1')\n    \n    def test_empty_device_id(self):\n        \"\"\"Test with empty device id.\"\"\"\n        with patch('__main__.TRUSTED_DEVICE_SIGNATURES', {'dev1': 'sig1'}):\n            result = verify_data_packet('', 'any_sig', {})\n            self.assertIsNone(result)\n    \n    def test_empty_signature_match(self):\n        \"\"\"Test with empty signature matching trusted empty signature.\"\"\"\n        with patch('__main__.TRUSTED_DEVICE_SIGNATURES', {'dev1': ''}):\n            with patch('__main__.get_packet_data') as mock_get:\n                mock_get.return_value = {'data': 'test'}\n                result = verify_data_packet('dev1', '', {})\n                self.assertEqual(result, {'data': 'test'})\n                mock_get.assert_called_once_with('dev1')\n    \n    def test_empty_signature_mismatch(self):\n        \"\"\"Test with empty signature against non-empty trusted signature.\"\"\"\n        with patch('__main__.TRUSTED_DEVICE_SIGNATURES', {'dev1': 'non_empty'}):\n            with patch('__main__.get_packet_data') as mock_get:\n                result = verify_data_packet('dev1', '', {})\n                self.assertIsNone(result)\n                mock_get.assert_not_called()\n    \n    def test_none_signature_match(self):\n        \"\"\"Test with None signature matching trusted None signature.\"\"\"\n        with patch('__main__.TRUSTED_DEVICE_SIGNATURES', {'dev1': None}):\n            with patch('__main__.get_packet_data') as mock_get:\n                mock_get.return_value = {'data': 'test'}\n                result = verify_data_packet('dev1', None, {})\n                self.assertEqual(result, {'data': 'test'})\n                mock_get.assert_called_once_with('dev1')\n    \n    def test_none_signature_mismatch(self):\n        \"\"\"Test with None signature against non-None trusted signature.\"\"\"\n        with patch('__main__.TRUSTED_DEVICE_SIGNATURES', {'dev1': 'non_empty'}):\n            with patch('__main__.get_packet_data') as mock_get:\n                result = verify_data_packet('dev1', None, {})\n                self.assertIsNone(result)\n                mock_get.assert_not_called()\n    \n    def test_device_none(self):\n        \"\"\"Test with None device id.\"\"\"\n        with patch('__main__.TRUSTED_DEVICE_SIGNATURES', {'dev1': 'sig1'}):\n            result = verify_data_packet(None, 'any_sig', {})\n            self.assertIsNone(result)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 10, "task_id": "c6e9e41c"}
{"test": "import unittest\nfrom unittest.mock import patch\n\nclass TestManageDataPacket(unittest.TestCase):\n\n    @patch('__main__.TRUSTED_DEVICE_SIGNATURES', {'device1': 'valid_sig', '': 'empty_sig'})\n    @patch('__main__.receive_packet_data')\n    def test_valid_device_and_signature(self, mock_receive):\n        # Test with valid device ID and matching signature\n        mock_receive.return_value = {'temp': 25.0}\n        result = manage_data_packet('device1', 'valid_sig', {})\n        self.assertEqual(result, {'temp': 25.0})\n        mock_receive.assert_called_once_with('device1')\n\n    @patch('__main__.TRUSTED_DEVICE_SIGNATURES', {'device1': 'valid_sig'})\n    @patch('__main__.receive_packet_data')\n    def test_valid_device_invalid_signature(self, mock_receive):\n        # Test with valid device ID but incorrect signature\n        result = manage_data_packet('device1', 'invalid_sig', {})\n        self.assertIsNone(result)\n        mock_receive.assert_not_called()\n\n    @patch('__main__.TRUSTED_DEVICE_SIGNATURES', {'device1': 'valid_sig'})\n    @patch('__main__.receive_packet_data')\n    def test_device_not_trusted(self, mock_receive):\n        # Test with device ID not in trusted devices\n        result = manage_data_packet('unknown_device', 'any_sig', {})\n        self.assertIsNone(result)\n        mock_receive.assert_not_called()\n\n    @patch('__main__.TRUSTED_DEVICE_SIGNATURES', {'device1': 'valid_sig'})\n    @patch('__main__.receive_packet_data')\n    def test_receive_raises_connection_error(self, mock_receive):\n        # Test ConnectionError during packet reception\n        mock_receive.side_effect = ConnectionError\n        result = manage_data_packet('device1', 'valid_sig', {})\n        self.assertIsNone(result)\n        mock_receive.assert_called_once_with('device1')\n\n    @patch('__main__.TRUSTED_DEVICE_SIGNATURES', {'device1': 'valid_sig'})\n    @patch('__main__.receive_packet_data')\n    def test_empty_device_id_not_trusted(self, mock_receive):\n        # Test empty device ID not in trusted devices\n        result = manage_data_packet('', 'any_sig', {})\n        self.assertIsNone(result)\n        mock_receive.assert_not_called()\n\n    @patch('__main__.TRUSTED_DEVICE_SIGNATURES', {'': 'empty_sig'})\n    @patch('__main__.receive_packet_data')\n    def test_empty_device_id_invalid_signature(self, mock_receive):\n        # Test empty device ID with incorrect signature\n        result = manage_data_packet('', 'wrong_sig', {})\n        self.assertIsNone(result)\n        mock_receive.assert_not_called()\n\n    @patch('__main__.TRUSTED_DEVICE_SIGNATURES', {'': 'empty_sig'})\n    @patch('__main__.receive_packet_data')\n    def test_empty_device_id_valid_signature(self, mock_receive):\n        # Test empty device ID with valid signature\n        mock_receive.return_value = {'status': 'ok'}\n        result = manage_data_packet('', 'empty_sig', {})\n        self.assertEqual(result, {'status': 'ok'})\n        mock_receive.assert_called_once_with('')\n\n    @patch('__main__.TRUSTED_DEVICE_SIGNATURES', {})\n    @patch('__main__.receive_packet_data')\n    def test_empty_trusted_device_list(self, mock_receive):\n        # Test when TRUSTED_DEVICE_SIGNATURES is empty\n        result = manage_data_packet('any_device', 'any_sig', {})\n        self.assertIsNone(result)\n        mock_receive.assert_not_called()\n\n    @patch('__main__.TRUSTED_DEVICE_SIGNATURES', {'device1': 'valid_sig'})\n    @patch('__main__.receive_packet_data')\n    def test_none_device_id(self, mock_receive):\n        # Test None as device ID\n        result = manage_data_packet(None, 'valid_sig', {})\n        self.assertIsNone(result)\n        mock_receive.assert_not_called()\n\n    @patch('__main__.TRUSTED_DEVICE_SIGNATURES', {'device1': 'valid_sig'})\n    @patch('__main__.receive_packet_data')\n    def test_none_signature(self, mock_receive):\n        # Test None as signature\n        result = manage_data_packet('device1', None, {})\n        self.assertIsNone(result)\n        mock_receive.assert_not_called()\n\n    @patch('__main__.TRUSTED_DEVICE_SIGNATURES', {'device1': 'valid_sig'})\n    @patch('__main__.receive_packet_data')\n    def test_non_dict_packet_data(self, mock_receive):\n        # Test non-dictionary packet_data (function doesn't use it, but still valid call)\n        mock_receive.return_value = {'data': 'test'}\n        result = manage_data_packet('device1', 'valid_sig', 'not_a_dict')\n        self.assertEqual(result, {'data': 'test'})\n        mock_receive.assert_called_once_with('device1')\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 11, "task_id": "c872e8c2"}
{"test": "import unittest\nfrom unittest.mock import patch\n\nclass TestProcessPacket(unittest.TestCase):\n\n    def test_happy_path_valid_signature(self):\n        \"\"\"Test with trusted device and matching signature returns processed data.\"\"\"\n        with patch('__main__.TRUSTED_DEVICE_SIGNATURES', {'device1': 'valid_sig'}), \\\n             patch('__main__.receive_data_packet') as mock_receive:\n            mock_receive.return_value = {'status': 'success'}\n            result = process_packet('device1', 'valid_sig', {'temp': 25})\n            self.assertEqual(result, {'status': 'success'})\n\n    def test_device_not_trusted(self):\n        \"\"\"Test device not in trusted devices returns None.\"\"\"\n        with patch('__main__.TRUSTED_DEVICE_SIGNATURES', {'device1': 'valid_sig'}):\n            result = process_packet('unknown_device', 'any_sig', {'temp': 25})\n            self.assertIsNone(result)\n\n    def test_signature_mismatch(self):\n        \"\"\"Test trusted device with incorrect signature returns None.\"\"\"\n        with patch('__main__.TRUSTED_DEVICE_SIGNATURES', {'device1': 'valid_sig'}):\n            result = process_packet('device1', 'invalid_sig', {'temp': 25})\n            self.assertIsNone(result)\n\n    def test_connection_error_returns_none(self):\n        \"\"\"Test ConnectionError during receive returns None.\"\"\"\n        with patch('__main__.TRUSTED_DEVICE_SIGNATURES', {'device1': 'valid_sig'}), \\\n             patch('__main__.receive_data_packet') as mock_receive:\n            mock_receive.side_effect = ConnectionError\n            result = process_packet('device1', 'valid_sig', {'temp': 25})\n            self.assertIsNone(result)\n\n    def test_empty_strings_valid(self):\n        \"\"\"Test empty device and signature strings when trusted returns data.\"\"\"\n        with patch('__main__.TRUSTED_DEVICE_SIGNATURES', {'': ''}), \\\n             patch('__main__.receive_data_packet') as mock_receive:\n            mock_receive.return_value = {'empty': True}\n            result = process_packet('', '', {})\n            self.assertEqual(result, {'empty': True})\n\n    def test_non_string_hashable_device(self):\n        \"\"\"Test non-string device ID (hashable) not in trusted devices returns None.\"\"\"\n        with patch('__main__.TRUSTED_DEVICE_SIGNATURES', {'device1': 'valid_sig'}):\n            result = process_packet(123, 'any_sig', {'temp': 25})\n            self.assertIsNone(result)\n\n    def test_unhashable_device_raises_error(self):\n        \"\"\"Test unhashable device ID raises TypeError.\"\"\"\n        with patch('__main__.TRUSTED_DEVICE_SIGNATURES', {}):\n            with self.assertRaises(TypeError):\n                process_packet([1,2,3], 'signature', {'temp': 25})\n\n    def test_non_string_signature_returns_none(self):\n        \"\"\"Test non-string signature with trusted device returns None.\"\"\"\n        with patch('__main__.TRUSTED_DEVICE_SIGNATURES', {'device1': 'valid_sig'}):\n            result = process_packet('device1', 123, {'temp': 25})\n            self.assertIsNone(result)\n\n    def test_large_data_packet_handling(self):\n        \"\"\"Test with large data packet returns processed data when signature valid.\"\"\"\n        large_data = {'data': 'x' * 10000}\n        with patch('__main__.TRUSTED_DEVICE_SIGNATURES', {'device1': 'valid_sig'}), \\\n             patch('__main__.receive_data_packet') as mock_receive:\n            mock_receive.return_value = large_data\n            result = process_packet('device1', 'valid_sig', large_data)\n            self.assertEqual(result, large_data)\n\n    def test_none_device_returns_none(self):\n        \"\"\"Test None device ID returns None.\"\"\"\n        with patch('__main__.TRUSTED_DEVICE_SIGNATURES', {'device1': 'valid_sig'}):\n            result = process_packet(None, 'signature', {'temp': 25})\n            self.assertIsNone(result)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 10, "task_id": "8f7b9fd5"}
{"test": "import unittest\nfrom unittest.mock import patch, MagicMock\nfrom solution import process_iot_packet\n\nclass TestProcessIoTPacket(unittest.TestCase):\n\n    @patch('solution.TRUSTED_DEVICE_SIGNATURES', {'device1': 'valid_sig'})\n    @patch('solution.receive_data_packet')\n    def test_valid_signature_and_receive_success(self, mock_receive):\n        # Test valid device_id and crypt_sig, receive returns dict\n        mock_receive.return_value = {'temperature': 25.0}\n        result = process_iot_packet('device1', 'valid_sig', {'humidity': 50})\n        self.assertEqual(result, {'temperature': 25.0})\n        mock_receive.assert_called_once_with('device1')\n\n    @patch('solution.TRUSTED_DEVICE_SIGNATURES', {'device1': 'valid_sig'})\n    @patch('solution.receive_data_packet')\n    def test_valid_signature_connection_error(self, mock_receive):\n        # Test valid device_id and crypt_sig but ConnectionError in receive\n        mock_receive.side_effect = ConnectionError\n        result = process_iot_packet('device1', 'valid_sig', {'humidity': 50})\n        self.assertIsNone(result)\n        mock_receive.assert_called_once_with('device1')\n\n    @patch('solution.TRUSTED_DEVICE_SIGNATURES', {'device1': 'valid_sig'})\n    @patch('solution.receive_data_packet')\n    def test_valid_device_invalid_signature(self, mock_receive):\n        # Test valid device_id but invalid crypt_sig\n        result = process_iot_packet('device1', 'invalid_sig', {'humidity': 50})\n        self.assertIsNone(result)\n        mock_receive.assert_not_called()\n\n    @patch('solution.TRUSTED_DEVICE_SIGNATURES', {'device1': 'valid_sig'})\n    @patch('solution.receive_data_packet')\n    def test_invalid_device_id(self, mock_receive):\n        # Test device_id not in trusted devices\n        result = process_iot_packet('unknown_device', 'valid_sig', {'humidity': 50})\n        self.assertIsNone(result)\n        mock_receive.assert_not_called()\n\n    @patch('solution.TRUSTED_DEVICE_SIGNATURES', {'device1': 'valid_sig'})\n    @patch('solution.receive_data_packet')\n    def test_valid_signature_receive_returns_none(self, mock_receive):\n        # Test valid device_id and crypt_sig but receive returns None\n        mock_receive.return_value = None\n        result = process_iot_packet('device1', 'valid_sig', {'humidity': 50})\n        self.assertIsNone(result)\n\n    @patch('solution.TRUSTED_DEVICE_SIGNATURES', {'device1': 'valid_sig'})\n    @patch('solution.receive_data_packet')\n    def test_valid_signature_receive_returns_non_dict(self, mock_receive):\n        # Test valid device_id and crypt_sig but receive returns non-dict\n        mock_receive.return_value = 123\n        result = process_iot_packet('device1', 'valid_sig', {'humidity': 50})\n        self.assertEqual(result, 123)\n\n    @patch('solution.TRUSTED_DEVICE_SIGNATURES', {'device1': 'valid_sig'})\n    @patch('solution.receive_data_packet')\n    def test_empty_device_id(self, mock_receive):\n        # Test empty device_id not in trusted devices\n        result = process_iot_packet('', 'any_sig', {'humidity': 50})\n        self.assertIsNone(result)\n        mock_receive.assert_not_called()\n\n    @patch('solution.TRUSTED_DEVICE_SIGNATURES', {'device1': 'valid_sig'})\n    @patch('solution.receive_data_packet')\n    def test_device_id_none(self, mock_receive):\n        # Test None device_id not in trusted devices\n        result = process_iot_packet(None, 'valid_sig', {'humidity': 50})\n        self.assertIsNone(result)\n        mock_receive.assert_not_called()\n\n    @patch('solution.TRUSTED_DEVICE_SIGNATURES', {'device1': ''})\n    @patch('solution.receive_data_packet')\n    def test_empty_signature_valid(self, mock_receive):\n        # Test empty crypt_sig matches trusted empty signature\n        mock_receive.return_value = {'status': 'ok'}\n        result = process_iot_packet('device1', '', {'humidity': 50})\n        self.assertEqual(result, {'status': 'ok'})\n\n    @patch('solution.TRUSTED_DEVICE_SIGNATURES', {'device1': 'non_empty_sig'})\n    @patch('solution.receive_data_packet')\n    def test_empty_signature_invalid(self, mock_receive):\n        # Test empty crypt_sig doesn't match non-empty trusted signature\n        result = process_iot_packet('device1', '', {'humidity': 50})\n        self.assertIsNone(result)\n        mock_receive.assert_not_called()\n\n    @patch('solution.TRUSTED_DEVICE_SIGNATURES')\n    @patch('solution.receive_data_packet')\n    def test_long_strings_valid(self, mock_receive, mock_trusted):\n        # Test very long device_id and crypt_sig that are valid\n        long_id = 'A' * 10000\n        long_sig = 'B' * 10000\n        mock_trusted.return_value = {long_id: long_sig}\n        mock_receive.return_value = {'data': 'long'}\n        result = process_iot_packet(long_id, long_sig, {'humidity': 50})\n        self.assertEqual(result, {'data': 'long'})\n\n    @patch('solution.TRUSTED_DEVICE_SIGNATURES', {})\n    @patch('solution.receive_data_packet')\n    def test_long_strings_invalid_device(self, mock_receive):\n        # Test very long device_id not in trusted devices\n        long_id = 'A' * 10000\n        long_sig = 'B' * 10000\n        result = process_iot_packet(long_id, long_sig, {'humidity': 50})\n        self.assertIsNone(result)\n        mock_receive.assert_not_called()\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 12, "task_id": "b00372d8"}
{"test": "import unittest\nfrom unittest.mock import patch\n\nclass TestValidateDevicePacket(unittest.TestCase):\n    def setUp(self):\n        self.trusted_patcher = patch.dict('__main__.TRUSTED_DEVICE_SIGNATURES', {}, clear=True)\n        self.trusted_dict = self.trusted_patcher.start()\n        self.receive_patcher = patch('__main__.receive_data_packet')\n        self.mock_receive = self.receive_patcher.start()\n        self.mock_receive.return_value = {'data': 'default'}\n\n    def tearDown(self):\n        self.trusted_patcher.stop()\n        self.receive_patcher.stop()\n\n    def test_happy_path(self):\n        \"\"\"Test trusted device with matching signature returns processed data.\"\"\"\n        TRUSTED_DEVICE_SIGNATURES['device1'] = 'signature1'\n        self.mock_receive.return_value = {'data': 'test1'}\n        result = validate_device_packet('device1', 'signature1', {})\n        self.mock_receive.assert_called_once_with('device1')\n        self.assertEqual(result, {'data': 'test1'})\n\n    def test_trusted_device_wrong_signature(self):\n        \"\"\"Test trusted device with incorrect signature returns None.\"\"\"\n        TRUSTED_DEVICE_SIGNATURES['device1'] = 'signature1'\n        result = validate_device_packet('device1', 'wrong_signature', {})\n        self.mock_receive.assert_not_called()\n        self.assertIsNone(result)\n\n    def test_untrusted_device(self):\n        \"\"\"Test untrusted device returns None.\"\"\"\n        result = validate_device_packet('unknown_device', 'any_signature', {})\n        self.mock_receive.assert_not_called()\n        self.assertIsNone(result)\n\n    def test_empty_device_id_trusted(self):\n        \"\"\"Test empty device ID when trusted returns processed data.\"\"\"\n        TRUSTED_DEVICE_SIGNATURES[''] = 'empty_sig'\n        self.mock_receive.return_value = {'data': 'empty'}\n        result = validate_device_packet('', 'empty_sig', {})\n        self.mock_receive.assert_called_once_with('')\n        self.assertEqual(result, {'data': 'empty'})\n\n    def test_empty_device_id_untrusted(self):\n        \"\"\"Test empty device ID when not trusted returns None.\"\"\"\n        result = validate_device_packet('', 'any_signature', {})\n        self.mock_receive.assert_not_called()\n        self.assertIsNone(result)\n\n    def test_empty_signature_match(self):\n        \"\"\"Test trusted device with matching empty signature returns data.\"\"\"\n        TRUSTED_DEVICE_SIGNATURES['device1'] = ''\n        self.mock_receive.return_value = {'data': 'empty_sig'}\n        result = validate_device_packet('device1', '', {})\n        self.mock_receive.assert_called_once_with('device1')\n        self.assertEqual(result, {'data': 'empty_sig'})\n\n    def test_empty_signature_mismatch(self):\n        \"\"\"Test trusted device with non-empty stored signature and empty input signature returns None.\"\"\"\n        TRUSTED_DEVICE_SIGNATURES['device1'] = 'non_empty'\n        result = validate_device_packet('device1', '', {})\n        self.mock_receive.assert_not_called()\n        self.assertIsNone(result)\n\n    def test_connection_error(self):\n        \"\"\"Test ConnectionError during packet reception returns None.\"\"\"\n        TRUSTED_DEVICE_SIGNATURES['device1'] = 'signature1'\n        self.mock_receive.side_effect = ConnectionError\n        result = validate_device_packet('device1', 'signature1', {})\n        self.mock_receive.assert_called_once_with('device1')\n        self.assertIsNone(result)\n\n    def test_non_string_device_id(self):\n        \"\"\"Test non-string device ID raises TypeError.\"\"\"\n        with self.assertRaises(TypeError):\n            validate_device_packet(['device1'], 'signature', {})\n\n    def test_none_device_id_trusted(self):\n        \"\"\"Test None device ID when trusted returns processed data.\"\"\"\n        TRUSTED_DEVICE_SIGNATURES[None] = 'none_sig'\n        self.mock_receive.return_value = {'data': 'none'}\n        result = validate_device_packet(None, 'none_sig', {})\n        self.mock_receive.assert_called_once_with(None)\n        self.assertEqual(result, {'data': 'none'})\n\n    def test_none_device_id_untrusted(self):\n        \"\"\"Test None device ID when not trusted returns None.\"\"\"\n        result = validate_device_packet(None, 'any_signature', {})\n        self.mock_receive.assert_not_called()\n        self.assertIsNone(result)", "num_test_cases": 11, "task_id": "6b69f373"}
{"test": "import unittest\nfrom unittest.mock import patch\n\nclass TestProcessPacketData(unittest.TestCase):\n\n    def test_valid_signature(self):\n        # Test with valid device ID and matching signature\n        trusted = {\"device1\": \"valid_sig\"}\n        with patch('__main__.TRUSTED_DEVICE_SIGNATURES', trusted), \\\n             patch('__main__.receive_data_packet') as mock_receive:\n            mock_receive.return_value = {\"temp\": 25}\n            result = process_packet_data(\"device1\", \"valid_sig\", {\"key\": \"value\"})\n            self.assertEqual(result, {\"temp\": 25})\n            mock_receive.assert_called_once_with(\"device1\")\n\n    def test_invalid_signature(self):\n        # Test valid device ID but invalid signature\n        trusted = {\"device1\": \"valid_sig\"}\n        with patch('__main__.TRUSTED_DEVICE_SIGNATURES', trusted), \\\n             patch('__main__.receive_data_packet') as mock_receive:\n            result = process_packet_data(\"device1\", \"invalid_sig\", {\"key\": \"value\"})\n            self.assertIsNone(result)\n            mock_receive.assert_not_called()\n\n    def test_device_not_trusted(self):\n        # Test device ID not in trusted devices\n        trusted = {\"device2\": \"valid_sig\"}\n        with patch('__main__.TRUSTED_DEVICE_SIGNATURES', trusted), \\\n             patch('__main__.receive_data_packet') as mock_receive:\n            result = process_packet_data(\"device1\", \"any_sig\", {\"key\": \"value\"})\n            self.assertIsNone(result)\n            mock_receive.assert_not_called()\n\n    def test_connection_error(self):\n        # Test ConnectionError during data reception\n        trusted = {\"device1\": \"valid_sig\"}\n        with patch('__main__.TRUSTED_DEVICE_SIGNATURES', trusted), \\\n             patch('__main__.receive_data_packet') as mock_receive:\n            mock_receive.side_effect = ConnectionError\n            result = process_packet_data(\"device1\", \"valid_sig\", {\"key\": \"value\"})\n            self.assertIsNone(result)\n\n    def test_empty_device_id(self):\n        # Test empty device ID (not in trusted devices)\n        trusted = {\"\": \"empty_sig\"}\n        with patch('__main__.TRUSTED_DEVICE_SIGNATURES', trusted), \\\n             patch('__main__.receive_data_packet') as mock_receive:\n            result = process_packet_data(\"\", \"empty_sig\", {\"key\": \"value\"})\n            self.assertIsNone(result)\n            mock_receive.assert_not_called()\n\n    def test_none_device_id(self):\n        # Test None device ID (not in trusted devices)\n        trusted = {\"device1\": \"valid_sig\"}\n        with patch('__main__.TRUSTED_DEVICE_SIGNATURES', trusted), \\\n             patch('__main__.receive_data_packet') as mock_receive:\n            result = process_packet_data(None, \"any_sig\", {\"key\": \"value\"})\n            self.assertIsNone(result)\n            mock_receive.assert_not_called()\n\n    def test_none_signature(self):\n        # Test None signature (invalid comparison)\n        trusted = {\"device1\": \"valid_sig\"}\n        with patch('__main__.TRUSTED_DEVICE_SIGNATURES', trusted), \\\n             patch('__main__.receive_data_packet') as mock_receive:\n            result = process_packet_data(\"device1\", None, {\"key\": \"value\"})\n            self.assertIsNone(result)\n            mock_receive.assert_not_called()\n\n    def test_empty_signature_valid(self):\n        # Test valid empty signature\n        trusted = {\"device1\": \"\"}\n        with patch('__main__.TRUSTED_DEVICE_SIGNATURES', trusted), \\\n             patch('__main__.receive_data_packet') as mock_receive:\n            mock_receive.return_value = {\"status\": \"ok\"}\n            result = process_packet_data(\"device1\", \"\", {\"key\": \"value\"})\n            self.assertEqual(result, {\"status\": \"ok\"})\n            mock_receive.assert_called_once_with(\"device1\")\n\n    def test_non_string_device_id(self):\n        # Test non-string device ID (integer)\n        trusted = {\"123\": \"valid_sig\"}\n        with patch('__main__.TRUSTED_DEVICE_SIGNATURES', trusted), \\\n             patch('__main__.receive_data_packet') as mock_receive:\n            result = process_packet_data(123, \"valid_sig\", {\"key\": \"value\"})\n            self.assertIsNone(result)\n            mock_receive.assert_not_called()\n\n    def test_non_string_signature(self):\n        # Test non-string signature (integer)\n        trusted = {\"device1\": \"123\"}\n        with patch('__main__.TRUSTED_DEVICE_SIGNATURES', trusted), \\\n             patch('__main__.receive_data_packet') as mock_receive:\n            result = process_packet_data(\"device1\", 123, {\"key\": \"value\"})\n            self.assertIsNone(result)\n            mock_receive.assert_not_called()\n\n    def test_large_packet_data(self):\n        # Test with very large packet data\n        trusted = {\"device1\": \"valid_sig\"}\n        large_data = {\"key\": \"x\" * 10000}\n        with patch('__main__.TRUSTED_DEVICE_SIGNATURES', trusted), \\\n             patch('__main__.receive_data_packet') as mock_receive:\n            mock_receive.return_value = large_data\n            result = process_packet_data(\"device1\", \"valid_sig\", large_data)\n            self.assertEqual(result, large_data)\n            mock_receive.assert_called_once_with(\"device1\")\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 11, "task_id": "9c5733f0"}
{"test": "import unittest\nfrom unittest.mock import patch\n\nclass TestProcessIotPacket(unittest.TestCase):\n\n    def test_valid_signature_and_device(self):\n        # Test with valid device id and signature, and receive_data_packet returns a dict.\n        trusted_signatures = {'device1': 'signature1'}\n        expected_packet = {'temperature': 25.0}\n        with patch('__main__.TRUSTED_DEVICE_SIGNATURES', trusted_signatures), \\\n             patch('__main__.receive_data_packet', return_value=expected_packet) as mock_receive:\n            result = process_iot_packet('device1', 'signature1', {})\n            mock_receive.assert_called_once_with('device1')\n            self.assertEqual(result, expected_packet)\n\n    def test_valid_signature_but_connection_error(self):\n        # Test with valid device id and signature, but receive_data_packet raises ConnectionError.\n        trusted_signatures = {'device1': 'signature1'}\n        with patch('__main__.TRUSTED_DEVICE_SIGNATURES', trusted_signatures), \\\n             patch('__main__.receive_data_packet', side_effect=ConnectionError) as mock_receive:\n            result = process_iot_packet('device1', 'signature1', {})\n            mock_receive.assert_called_once_with('device1')\n            self.assertIsNone(result)\n\n    def test_invalid_signature(self):\n        # Test with valid device id but invalid signature.\n        trusted_signatures = {'device1': 'signature1'}\n        with patch('__main__.TRUSTED_DEVICE_SIGNATURES', trusted_signatures), \\\n             patch('__main__.receive_data_packet') as mock_receive:\n            result = process_iot_packet('device1', 'wrong_signature', {})\n            mock_receive.assert_not_called()\n            self.assertIsNone(result)\n\n    def test_untrusted_device(self):\n        # Test with untrusted device id.\n        trusted_signatures = {'device1': 'signature1'}\n        with patch('__main__.TRUSTED_DEVICE_SIGNATURES', trusted_signatures), \\\n             patch('__main__.receive_data_packet') as mock_receive:\n            result = process_iot_packet('device2', 'signature1', {})\n            mock_receive.assert_not_called()\n            self.assertIsNone(result)\n\n    def test_empty_device_id_valid(self):\n        # Test with empty device id and valid signature.\n        trusted_signatures = {'': 'empty_signature'}\n        expected_packet = {'data': 'empty'}\n        with patch('__main__.TRUSTED_DEVICE_SIGNATURES', trusted_signatures), \\\n             patch('__main__.receive_data_packet', return_value=expected_packet) as mock_receive:\n            result = process_iot_packet('', 'empty_signature', {})\n            mock_receive.assert_called_once_with('')\n            self.assertEqual(result, expected_packet)\n\n    def test_empty_device_id_invalid(self):\n        # Test with empty device id and invalid signature.\n        trusted_signatures = {'': 'empty_signature'}\n        with patch('__main__.TRUSTED_DEVICE_SIGNATURES', trusted_signatures), \\\n             patch('__main__.receive_data_packet') as mock_receive:\n            result = process_iot_packet('', 'wrong', {})\n            mock_receive.assert_not_called()\n            self.assertIsNone(result)\n\n    def test_empty_signature_valid(self):\n        # Test with valid device id and empty signature that matches trusted.\n        trusted_signatures = {'device1': ''}\n        expected_packet = {'data': 'empty_sig'}\n        with patch('__main__.TRUSTED_DEVICE_SIGNATURES', trusted_signatures), \\\n             patch('__main__.receive_data_packet', return_value=expected_packet) as mock_receive:\n            result = process_iot_packet('device1', '', {})\n            mock_receive.assert_called_once_with('device1')\n            self.assertEqual(result, expected_packet)\n\n    def test_packet_content_ignored(self):\n        # Test that the packet_content argument is ignored.\n        trusted_signatures = {'device1': 'signature1'}\n        expected_packet = {'data': 'test'}\n        with patch('__main__.TRUSTED_DEVICE_SIGNATURES', trusted_signatures), \\\n             patch('__main__.receive_data_packet', return_value=expected_packet) as mock_receive:\n            result = process_iot_packet('device1', 'signature1', {'should': 'be ignored'})\n            mock_receive.assert_called_once_with('device1')\n            self.assertEqual(result, expected_packet)\n\n    def test_receive_data_packet_returns_none(self):\n        # Test when receive_data_packet returns None.\n        trusted_signatures = {'device1': 'signature1'}\n        with patch('__main__.TRUSTED_DEVICE_SIGNATURES', trusted_signatures), \\\n             patch('__main__.receive_data_packet', return_value=None) as mock_receive:\n            result = process_iot_packet('device1', 'signature1', {})\n            mock_receive.assert_called_once_with('device1')\n            self.assertIsNone(result)\n\n    def test_receive_data_packet_raises_other_exception(self):\n        # Test when receive_data_packet raises an exception other than ConnectionError.\n        trusted_signatures = {'device1': 'signature1'}\n        with patch('__main__.TRUSTED_DEVICE_SIGNATURES', trusted_signatures), \\\n             patch('__main__.receive_data_packet', side_effect=ValueError('Unexpected')) as mock_receive:\n            with self.assertRaises(ValueError):\n                process_iot_packet('device1', 'signature1', {})\n            mock_receive.assert_called_once_with('device1')\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 10, "task_id": "71c78001"}
{"test": "import unittest\nfrom unittest.mock import patch\n\nclass TestVerifyIoTSignature(unittest.TestCase):\n\n    def test_valid_signature(self):\n        # Happy path with valid device ID and matching signature\n        with patch('__main__.TRUSTED_DEVICE_SIGNATURES', {'dev1': 'valid_sig'}), \\\n             patch('__main__.receive_data_packet') as mock_receive:\n            mock_receive.return_value = {'temperature': 25}\n            result = verify_iot_signature('dev1', 'valid_sig', {})\n            self.assertEqual(result, {'temperature': 25})\n\n    def test_invalid_device_id(self):\n        # Device ID not in trusted devices\n        with patch('__main__.TRUSTED_DEVICE_SIGNATURES', {'dev1': 'valid_sig'}), \\\n             patch('__main__.receive_data_packet') as mock_receive:\n            result = verify_iot_signature('unknown_dev', 'valid_sig', {})\n            self.assertIsNone(result)\n            mock_receive.assert_not_called()\n\n    def test_signature_mismatch(self):\n        # Valid device ID but signature doesn't match\n        with patch('__main__.TRUSTED_DEVICE_SIGNATURES', {'dev1': 'valid_sig'}), \\\n             patch('__main__.receive_data_packet') as mock_receive:\n            result = verify_iot_signature('dev1', 'invalid_sig', {})\n            self.assertIsNone(result)\n            mock_receive.assert_not_called()\n\n    def test_connection_error_handling(self):\n        # ConnectionError during data reception returns None\n        with patch('__main__.TRUSTED_DEVICE_SIGNATURES', {'dev1': 'valid_sig'}), \\\n             patch('__main__.receive_data_packet') as mock_receive:\n            mock_receive.side_effect = ConnectionError\n            result = verify_iot_signature('dev1', 'valid_sig', {})\n            self.assertIsNone(result)\n\n    def test_empty_signature_valid(self):\n        # Empty signature matching trusted value\n        with patch('__main__.TRUSTED_DEVICE_SIGNATURES', {'dev1': ''}), \\\n             patch('__main__.receive_data_packet') as mock_receive:\n            mock_receive.return_value = {'status': 'ok'}\n            result = verify_iot_signature('dev1', '', {})\n            self.assertEqual(result, {'status': 'ok'})\n\n    def test_empty_signature_invalid(self):\n        # Empty signature doesn't match non-empty trusted value\n        with patch('__main__.TRUSTED_DEVICE_SIGNATURES', {'dev1': 'non_empty'}), \\\n             patch('__main__.receive_data_packet') as mock_receive:\n            result = verify_iot_signature('dev1', '', {})\n            self.assertIsNone(result)\n            mock_receive.assert_not_called()\n\n    def test_none_device_id(self):\n        # None device ID not in trusted devices\n        with patch('__main__.TRUSTED_DEVICE_SIGNATURES', {'dev1': 'sig'}), \\\n             patch('__main__.receive_data_packet') as mock_receive:\n            result = verify_iot_signature(None, 'sig', {})\n            self.assertIsNone(result)\n            mock_receive.assert_not_called()\n\n    def test_none_signature(self):\n        # None signature doesn't match string trusted value\n        with patch('__main__.TRUSTED_DEVICE_SIGNATURES', {'dev1': 'valid_sig'}), \\\n             patch('__main__.receive_data_packet') as mock_receive:\n            result = verify_iot_signature('dev1', None, {})\n            self.assertIsNone(result)\n            mock_receive.assert_not_called()\n\n    def test_none_in_trusted(self):\n        # None device ID and signature in trusted devices\n        with patch('__main__.TRUSTED_DEVICE_SIGNATURES', {None: None}), \\\n             patch('__main__.receive_data_packet') as mock_receive:\n            mock_receive.return_value = {'data': 'null'}\n            result = verify_iot_signature(None, None, {})\n            self.assertEqual(result, {'data': 'null'})\n\n    def test_integer_device_id(self):\n        # Integer device ID in trusted devices\n        with patch('__main__.TRUSTED_DEVICE_SIGNATURES', {123: 'num_sig'}), \\\n             patch('__main__.receive_data_packet') as mock_receive:\n            mock_receive.return_value = {'id': 123}\n            result = verify_iot_signature(123, 'num_sig', {})\n            self.assertEqual(result, {'id': 123})\n\n    def test_integer_signature(self):\n        # Integer signature matching trusted value\n        with patch('__main__.TRUSTED_DEVICE_SIGNATURES', {'dev1': 123}), \\\n             patch('__main__.receive_data_packet') as mock_receive:\n            mock_receive.return_value = {'value': 123}\n            result = verify_iot_signature('dev1', 123, {})\n            self.assertEqual(result, {'value': 123})\n\n    def test_large_device_id(self):\n        # Very long device ID\n        long_id = 'D' * 10**6\n        with patch('__main__.TRUSTED_DEVICE_SIGNATURES', {long_id: 'long_sig'}), \\\n             patch('__main__.receive_data_packet') as mock_receive:\n            mock_receive.return_value = {'data': 'large'}\n            result = verify_iot_signature(long_id, 'long_sig', {})\n            self.assertEqual(result, {'data': 'large'})\n\n    def test_large_signature(self):\n        # Very long signature\n        long_sig = 'S' * 10**6\n        with patch('__main__.TRUSTED_DEVICE_SIGNATURES', {'dev1': long_sig}), \\\n             patch('__main__.receive_data_packet') as mock_receive:\n            mock_receive.return_value = {'data': 'huge_sig'}\n            result = verify_iot_signature('dev1', long_sig, {})\n            self.assertEqual(result, {'data': 'huge_sig'})\n\n    def test_empty_packet_info(self):\n        # Empty packet_info dictionary\n        with patch('__main__.TRUSTED_DEVICE_SIGNATURES', {'dev1': 'sig'}), \\\n             patch('__main__.receive_data_packet') as mock_receive:\n            mock_receive.return_value = {}\n            result = verify_iot_signature('dev1', 'sig', {})\n            self.assertEqual(result, {})\n\n    def test_connection_error_priority(self):\n        # Valid credentials but ConnectionError returns None\n        with patch('__main__.TRUSTED_DEVICE_SIGNATURES', {'dev1': 'sig'}), \\\n             patch('__main__.receive_data_packet') as mock_receive:\n            mock_receive.side_effect = ConnectionError\n            result = verify_iot_signature('dev1', 'sig', {})\n            self.assertIsNone(result)", "num_test_cases": 15, "task_id": "3aeaba65"}
{"test": "import unittest\nfrom unittest.mock import patch, MagicMock\n\n# Import the function from its module; adjust the import if necessary\n# For the purpose of this test, we assume the function is in 'config_utils'\n# Change 'config_utils' to the actual module name in your project\nfrom config_utils import handle_config_data\n\nclass TestHandleConfigData(unittest.TestCase):\n\n    def test_valid_signature_and_file_exists(self):\n        \"\"\"Test with valid file name, matching signature, and existing file.\"\"\"\n        with patch('config_utils.TRUSTED_CONFIG_SIGNATURES', {'config.txt': 'valid_sig'}), \\\n             patch('config_utils.fetch_config_data') as mock_fetch:\n            mock_fetch.return_value = {'setting': 'value'}\n            result = handle_config_data('config.txt', 'valid_sig')\n            self.assertEqual(result, {'setting': 'value'})\n\n    def test_valid_signature_but_file_does_not_exist(self):\n        \"\"\"Test with valid signature but file does not exist (IOError).\"\"\"\n        with patch('config_utils.TRUSTED_CONFIG_SIGNATURES', {'config.txt': 'valid_sig'}), \\\n             patch('config_utils.fetch_config_data') as mock_fetch:\n            mock_fetch.side_effect = IOError\n            result = handle_config_data('config.txt', 'valid_sig')\n            self.assertIsNone(result)\n\n    def test_invalid_signature(self):\n        \"\"\"Test with valid file name but invalid signature.\"\"\"\n        with patch('config_utils.TRUSTED_CONFIG_SIGNATURES', {'config.txt': 'valid_sig'}):\n            result = handle_config_data('config.txt', 'invalid_sig')\n            self.assertIsNone(result)\n\n    def test_file_not_in_trusted_list(self):\n        \"\"\"Test with file name not in trusted list.\"\"\"\n        with patch('config_utils.TRUSTED_CONFIG_SIGNATURES', {'config.txt': 'valid_sig'}):\n            result = handle_config_data('unknown.txt', 'any_sig')\n            self.assertIsNone(result)\n\n    def test_file_signature_none(self):\n        \"\"\"Test with None as file signature (invalid type).\"\"\"\n        with patch('config_utils.TRUSTED_CONFIG_SIGNATURES', {'config.txt': 'valid_sig'}):\n            result = handle_config_data('config.txt', None)\n            self.assertIsNone(result)\n\n    def test_file_signature_integer(self):\n        \"\"\"Test with integer as file signature (invalid type).\"\"\"\n        with patch('config_utils.TRUSTED_CONFIG_SIGNATURES', {'config.txt': 'valid_sig'}):\n            result = handle_config_data('config.txt', 123)\n            self.assertIsNone(result)\n\n    def test_file_name_list(self):\n        \"\"\"Test with unhashable type (list) for file name.\"\"\"\n        with self.assertRaises(TypeError):\n            handle_config_data(['config.txt'], 'valid_sig')\n\n    def test_file_name_none(self):\n        \"\"\"Test with None as file name.\"\"\"\n        with patch('config_utils.TRUSTED_CONFIG_SIGNATURES', {'config.txt': 'valid_sig'}):\n            result = handle_config_data(None, 'valid_sig')\n            self.assertIsNone(result)\n\n    def test_trusted_signature_none_and_provided_none(self):\n        \"\"\"Test when trusted signature is None and provided signature is None.\"\"\"\n        with patch('config_utils.TRUSTED_CONFIG_SIGNATURES', {'config.txt': None}), \\\n             patch('config_utils.fetch_config_data') as mock_fetch:\n            mock_fetch.return_value = {'setting': 'value'}\n            result = handle_config_data('config.txt', None)\n            self.assertEqual(result, {'setting': 'value'})\n\n    def test_trusted_signature_none_and_provided_string(self):\n        \"\"\"Test when trusted signature is None and provided signature is string.\"\"\"\n        with patch('config_utils.TRUSTED_CONFIG_SIGNATURES', {'config.txt': None}):\n            result = handle_config_data('config.txt', 'some_sig')\n            self.assertIsNone(result)\n\n    def test_file_name_dict_unhashable(self):\n        \"\"\"Test with unhashable type (dict) for file name.\"\"\"\n        with self.assertRaises(TypeError):\n            handle_config_data({'file': 'config.txt'}, 'valid_sig')\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 11, "task_id": "9f3a5b87"}
{"test": "import unittest\nfrom unittest.mock import patch\n\nfrom solution import validate_config_file\n\nclass TestValidateConfigFile(unittest.TestCase):\n    def test_valid_signature(self):\n        # Test typical valid filename and signature returns config data\n        with patch('solution.TRUSTED_CONFIG_SIGNATURES', {'config.txt': 'valid_sig'}), \\\n             patch('solution.fetch_config_file') as mock_fetch:\n            mock_fetch.return_value = {'key': 'value'}\n            result = validate_config_file('config.txt', 'valid_sig')\n            self.assertEqual(result, {'key': 'value'})\n            mock_fetch.assert_called_once_with('config.txt')\n\n    def test_filename_not_in_trusted(self):\n        # Test filename not in TRUSTED_CONFIG_SIGNATURES returns None\n        with patch('solution.TRUSTED_CONFIG_SIGNATURES', {'config.txt': 'valid_sig'}), \\\n             patch('solution.fetch_config_file') as mock_fetch:\n            result = validate_config_file('unknown.txt', 'valid_sig')\n            self.assertIsNone(result)\n            mock_fetch.assert_not_called()\n\n    def test_signature_mismatch(self):\n        # Test valid filename but incorrect signature returns None\n        with patch('solution.TRUSTED_CONFIG_SIGNATURES', {'config.txt': 'valid_sig'}), \\\n             patch('solution.fetch_config_file') as mock_fetch:\n            result = validate_config_file('config.txt', 'invalid_sig')\n            self.assertIsNone(result)\n            mock_fetch.assert_not_called()\n\n    def test_fetch_file_ioerror(self):\n        # Test valid signature but fetch_config_file raises IOError returns None\n        with patch('solution.TRUSTED_CONFIG_SIGNATURES', {'config.txt': 'valid_sig'}), \\\n             patch('solution.fetch_config_file') as mock_fetch:\n            mock_fetch.side_effect = IOError(\"File not found\")\n            result = validate_config_file('config.txt', 'valid_sig')\n            self.assertIsNone(result)\n            mock_fetch.assert_called_once_with('config.txt')\n\n    def test_non_string_filename(self):\n        # Test non-string filename raises TypeError\n        with patch('solution.TRUSTED_CONFIG_SIGNATURES', {'config.txt': 'valid_sig'}), \\\n             patch('solution.fetch_config_file'):\n            with self.assertRaises(TypeError):\n                validate_config_file(123, 'valid_sig')\n\n    def test_non_string_signature(self):\n        # Test non-string cryptographic_signature raises TypeError\n        with patch('solution.TRUSTED_CONFIG_SIGNATURES', {'config.txt': 'valid_sig'}), \\\n             patch('solution.fetch_config_file'):\n            with self.assertRaises(TypeError):\n                validate_config_file('config.txt', 123)\n\n    def test_empty_filename_not_trusted(self):\n        # Test empty filename not in TRUSTED_CONFIG_SIGNATURES returns None\n        with patch('solution.TRUSTED_CONFIG_SIGNATURES', {'config.txt': 'valid_sig'}), \\\n             patch('solution.fetch_config_file') as mock_fetch:\n            result = validate_config_file('', 'valid_sig')\n            self.assertIsNone(result)\n            mock_fetch.assert_not_called()\n\n    def test_empty_filename_wrong_signature(self):\n        # Test empty filename in trusted but wrong signature returns None\n        with patch('solution.TRUSTED_CONFIG_SIGNATURES', {'': 'empty_sig'}), \\\n             patch('solution.fetch_config_file') as mock_fetch:\n            result = validate_config_file('', 'wrong_sig')\n            self.assertIsNone(result)\n            mock_fetch.assert_not_called()\n\n    def test_empty_filename_valid_signature(self):\n        # Test empty filename with valid signature returns config data\n        with patch('solution.TRUSTED_CONFIG_SIGNATURES', {'': 'empty_sig'}), \\\n             patch('solution.fetch_config_file') as mock_fetch:\n            mock_fetch.return_value = {'empty': True}\n            result = validate_config_file('', 'empty_sig')\n            self.assertEqual(result, {'empty': True})\n            mock_fetch.assert_called_once_with('')\n\n    def test_empty_trusted_signature_valid(self):\n        # Test non-empty filename with empty trusted signature and empty provided signature (valid)\n        with patch('solution.TRUSTED_CONFIG_SIGNATURES', {'config.txt': ''}), \\\n             patch('solution.fetch_config_file') as mock_fetch:\n            mock_fetch.return_value = {'key': 'value'}\n            result = validate_config_file('config.txt', '')\n            self.assertEqual(result, {'key': 'value'})\n            mock_fetch.assert_called_once_with('config.txt')\n\n    def test_empty_trusted_signature_invalid(self):\n        # Test non-empty filename with empty trusted signature but non-empty provided signature (invalid)\n        with patch('solution.TRUSTED_CONFIG_SIGNATURES', {'config.txt': ''}), \\\n             patch('solution.fetch_config_file') as mock_fetch:\n            result = validate_config_file('config.txt', 'non_empty')\n            self.assertIsNone(result)\n            mock_fetch.assert_not_called()", "num_test_cases": 11, "task_id": "944ba9c4"}
{"test": "import unittest\nfrom unittest.mock import patch, MagicMock\n\nclass TestRetrieveConfigData(unittest.TestCase):\n    \n    def setUp(self):\n        \"\"\"Set up the global TRUSTED_CONFIG_SIGNATURES for each test.\"\"\"\n        global TRUSTED_CONFIG_SIGNATURES\n        TRUSTED_CONFIG_SIGNATURES = {\n            'valid_config.txt': 'valid_signature',\n            'empty_config.txt': 'empty_signature',\n            'nonexistent_config.txt': 'nonexistent_signature'\n        }\n    \n    @patch('__main__.load_config_data', return_value={'key': 'value'})\n    def test_valid_signature_and_file_exists(self, mock_load):\n        \"\"\"Test with valid config_filename and matching crypt_signature.\"\"\"\n        result = retrieve_config_data('valid_config.txt', 'valid_signature')\n        self.assertEqual(result, {'key': 'value'})\n        mock_load.assert_called_once_with('valid_config.txt')\n    \n    @patch('__main__.load_config_data', side_effect=IOError('File not found'))\n    def test_valid_signature_but_file_not_found(self, mock_load):\n        \"\"\"Test valid signature but config file does not exist.\"\"\"\n        result = retrieve_config_data('nonexistent_config.txt', 'nonexistent_signature')\n        self.assertIsNone(result)\n        mock_load.assert_called_once_with('nonexistent_config.txt')\n    \n    @patch('__main__.load_config_data')\n    def test_invalid_signature(self, mock_load):\n        \"\"\"Test config_filename in TRUSTED but crypt_signature does not match.\"\"\"\n        result = retrieve_config_data('valid_config.txt', 'invalid_signature')\n        self.assertIsNone(result)\n        mock_load.assert_not_called()\n    \n    @patch('__main__.load_config_data')\n    def test_filename_not_in_trusted(self, mock_load):\n        \"\"\"Test config_filename not present in TRUSTED_CONFIG_SIGNATURES.\"\"\"\n        result = retrieve_config_data('unknown_config.txt', 'any_signature')\n        self.assertIsNone(result)\n        mock_load.assert_not_called()\n    \n    @patch('__main__.load_config_data', return_value={})\n    def test_valid_signature_returns_empty_dict(self, mock_load):\n        \"\"\"Test valid signature and file exists but returns empty dictionary.\"\"\"\n        result = retrieve_config_data('empty_config.txt', 'empty_signature')\n        self.assertEqual(result, {})\n        mock_load.assert_called_once_with('empty_config.txt')\n    \n    @patch('__main__.load_config_data')\n    def test_empty_config_filename(self, mock_load):\n        \"\"\"Test with empty config_filename string.\"\"\"\n        result = retrieve_config_data('', 'any_signature')\n        self.assertIsNone(result)\n        mock_load.assert_not_called()\n    \n    @patch('__main__.load_config_data')\n    def test_empty_crypt_signature(self, mock_load):\n        \"\"\"Test with empty crypt_signature string.\"\"\"\n        result = retrieve_config_data('valid_config.txt', '')\n        self.assertIsNone(result)\n        mock_load.assert_not_called()\n    \n    @patch('__main__.load_config_data')\n    def test_global_trusted_empty(self, mock_load):\n        \"\"\"Test when TRUSTED_CONFIG_SIGNATURES is empty.\"\"\"\n        global TRUSTED_CONFIG_SIGNATURES\n        TRUSTED_CONFIG_SIGNATURES = {}\n        result = retrieve_config_data('valid_config.txt', 'valid_signature')\n        self.assertIsNone(result)\n        mock_load.assert_not_called()\n    \n    @patch('__main__.load_config_data')\n    def test_none_config_filename(self, mock_load):\n        \"\"\"Test config_filename is None.\"\"\"\n        result = retrieve_config_data(None, 'any_signature')\n        self.assertIsNone(result)\n        mock_load.assert_not_called()\n    \n    @patch('__main__.load_config_data')\n    def test_none_crypt_signature(self, mock_load):\n        \"\"\"Test crypt_signature is None.\"\"\"\n        result = retrieve_config_data('valid_config.txt', None)\n        self.assertIsNone(result)\n        mock_load.assert_not_called()\n    \n    @patch('__main__.load_config_data')\n    def test_non_string_config_filename(self, mock_load):\n        \"\"\"Test config_filename is not a string (integer).\"\"\"\n        result = retrieve_config_data(123, 'valid_signature')\n        self.assertIsNone(result)\n        mock_load.assert_not_called()\n    \n    @patch('__main__.load_config_data')\n    def test_non_string_crypt_signature(self, mock_load):\n        \"\"\"Test crypt_signature is not a string (integer).\"\"\"\n        result = retrieve_config_data('valid_config.txt', 123)\n        self.assertIsNone(result)\n        mock_load.assert_not_called()\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 12, "task_id": "c41de366"}
{"test": "import unittest\nfrom unittest.mock import patch, MagicMock\n\nclass TestHandleConfigFile(unittest.TestCase):\n\n    @patch('__main__.TRUSTED_CONFIG_SIGNATURES', {'valid.txt': 'correct_signature'})\n    @patch('__main__.fetch_config_data')\n    def test_valid_signature(self, mock_fetch):\n        \"\"\"Test with valid file name and matching signature.\"\"\"\n        mock_fetch.return_value = {'key': 'value'}\n        result = handle_config_file('valid.txt', 'correct_signature')\n        self.assertEqual(result, {'key': 'value'})\n\n    @patch('__main__.TRUSTED_CONFIG_SIGNATURES', {'valid.txt': 'correct_signature'})\n    @patch('__main__.fetch_config_data')\n    def test_invalid_signature(self, mock_fetch):\n        \"\"\"Test with valid file name but incorrect signature.\"\"\"\n        result = handle_config_file('valid.txt', 'wrong_signature')\n        self.assertIsNone(result)\n        mock_fetch.assert_not_called()\n\n    @patch('__main__.TRUSTED_CONFIG_SIGNATURES', {'valid.txt': 'correct_signature'})\n    @patch('__main__.fetch_config_data')\n    def test_file_not_in_trusted(self, mock_fetch):\n        \"\"\"Test with file name not present in trusted signatures.\"\"\"\n        result = handle_config_file('unknown.txt', 'correct_signature')\n        self.assertIsNone(result)\n        mock_fetch.assert_not_called()\n\n    @patch('__main__.TRUSTED_CONFIG_SIGNATURES', {'valid.txt': 'correct_signature'})\n    @patch('__main__.fetch_config_data')\n    def test_empty_file_name(self, mock_fetch):\n        \"\"\"Test with empty file name.\"\"\"\n        result = handle_config_file('', 'correct_signature')\n        self.assertIsNone(result)\n        mock_fetch.assert_not_called()\n\n    @patch('__main__.TRUSTED_CONFIG_SIGNATURES', {'valid.txt': ''})\n    @patch('__main__.fetch_config_data')\n    def test_empty_signature_valid(self, mock_fetch):\n        \"\"\"Test when both provided and trusted signatures are empty.\"\"\"\n        mock_fetch.return_value = {'key': 'value'}\n        result = handle_config_file('valid.txt', '')\n        self.assertEqual(result, {'key': 'value'})\n\n    @patch('__main__.TRUSTED_CONFIG_SIGNATURES', {'valid.txt': 'non_empty'})\n    @patch('__main__.fetch_config_data')\n    def test_empty_signature_invalid(self, mock_fetch):\n        \"\"\"Test with empty signature when trusted signature is non-empty.\"\"\"\n        result = handle_config_file('valid.txt', '')\n        self.assertIsNone(result)\n        mock_fetch.assert_not_called()\n\n    @patch('__main__.TRUSTED_CONFIG_SIGNATURES', {'valid.txt': 'correct_signature'})\n    @patch('__main__.fetch_config_data')\n    def test_fetch_io_error(self, mock_fetch):\n        \"\"\"Test when fetch_config_data raises an IOError.\"\"\"\n        mock_fetch.side_effect = IOError(\"File not found\")\n        result = handle_config_file('valid.txt', 'correct_signature')\n        self.assertIsNone(result)\n\n    @patch('__main__.TRUSTED_CONFIG_SIGNATURES', {})\n    @patch('__main__.fetch_config_data')\n    def test_empty_trusted_signatures(self, mock_fetch):\n        \"\"\"Test when TRUSTED_CONFIG_SIGNATURES is empty.\"\"\"\n        result = handle_config_file('valid.txt', 'correct_signature')\n        self.assertIsNone(result)\n        mock_fetch.assert_not_called()\n\n    @patch('__main__.TRUSTED_CONFIG_SIGNATURES', {'valid.txt': 'correct_signature'})\n    @patch('__main__.fetch_config_data')\n    def test_non_string_file_name(self, mock_fetch):\n        \"\"\"Test with non-string file name.\"\"\"\n        with self.assertRaises(AttributeError):\n            handle_config_file(123, 'correct_signature')\n\n    @patch('__main__.TRUSTED_CONFIG_SIGNATURES', {'valid.txt': 'correct_signature'})\n    @patch('__main__.fetch_config_data')\n    def test_non_string_signature(self, mock_fetch):\n        \"\"\"Test with non-string signature.\"\"\"\n        with self.assertRaises(TypeError):\n            handle_config_file('valid.txt', 456)", "num_test_cases": 10, "task_id": "defc4661"}
{"test": "import unittest\nfrom unittest.mock import patch\n\nclass TestVerifyConfigurationFile(unittest.TestCase):\n    def test_valid_configuration_and_signature(self):\n        # Test valid config name and matching signature\n        with patch('__main__.TRUSTED_CONFIG_SIGNATURES', {'config1': 'valid_sig'}):\n            with patch('__main__.fetch_config_data') as mock_fetch:\n                mock_fetch.return_value = {'key': 'value'}\n                result = verify_configuration_file('config1', 'valid_sig')\n                self.assertEqual(result, {'key': 'value'})\n\n    def test_invalid_signature(self):\n        # Test valid config name but incorrect signature\n        with patch('__main__.TRUSTED_CONFIG_SIGNATURES', {'config1': 'valid_sig'}):\n            result = verify_configuration_file('config1', 'invalid_sig')\n            self.assertIsNone(result)\n\n    def test_missing_config_in_trusted(self):\n        # Test config name not in trusted signatures\n        with patch('__main__.TRUSTED_CONFIG_SIGNATURES', {'config1': 'valid_sig'}):\n            result = verify_configuration_file('unknown_config', 'any_sig')\n            self.assertIsNone(result)\n\n    def test_ioerror_handling(self):\n        # Test file read error when signature is valid\n        with patch('__main__.TRUSTED_CONFIG_SIGNATURES', {'config1': 'valid_sig'}):\n            with patch('__main__.fetch_config_data') as mock_fetch:\n                mock_fetch.side_effect = IOError\n                result = verify_configuration_file('config1', 'valid_sig')\n                self.assertIsNone(result)\n\n    def test_empty_signature_mismatch(self):\n        # Test empty signature when trusted has non-empty\n        with patch('__main__.TRUSTED_CONFIG_SIGNATURES', {'config1': 'valid_sig'}):\n            result = verify_configuration_file('config1', '')\n            self.assertIsNone(result)\n\n    def test_empty_signature_match(self):\n        # Test empty signature matches trusted empty signature\n        with patch('__main__.TRUSTED_CONFIG_SIGNATURES', {'config1': ''}):\n            with patch('__main__.fetch_config_data') as mock_fetch:\n                mock_fetch.return_value = {'key': 'value'}\n                result = verify_configuration_file('config1', '')\n                self.assertEqual(result, {'key': 'value'})\n\n    def test_empty_config_name_valid(self):\n        # Test empty config name with matching signature\n        with patch('__main__.TRUSTED_CONFIG_SIGNATURES', {'': 'valid_sig'}):\n            with patch('__main__.fetch_config_data') as mock_fetch:\n                mock_fetch.return_value = {'key': 'value'}\n                result = verify_configuration_file('', 'valid_sig')\n                self.assertEqual(result, {'key': 'value'})\n\n    def test_empty_config_name_invalid(self):\n        # Test empty config name not in trusted\n        with patch('__main__.TRUSTED_CONFIG_SIGNATURES', {'config1': 'valid_sig'}):\n            result = verify_configuration_file('', 'any_sig')\n            self.assertIsNone(result)\n\n    def test_none_config_name(self):\n        # Test None config name\n        with patch('__main__.TRUSTED_CONFIG_SIGNATURES', {'config1': 'valid_sig'}):\n            result = verify_configuration_file(None, 'any_sig')\n            self.assertIsNone(result)\n\n    def test_none_signature(self):\n        # Test None signature\n        with patch('__main__.TRUSTED_CONFIG_SIGNATURES', {'config1': 'valid_sig'}):\n            result = verify_configuration_file('config1', None)\n            self.assertIsNone(result)\n\n    def test_very_long_config_name(self):\n        # Test very long config name\n        long_name = 'a' * 1000\n        with patch('__main__.TRUSTED_CONFIG_SIGNATURES', {long_name: 'valid_sig'}):\n            with patch('__main__.fetch_config_data') as mock_fetch:\n                mock_fetch.return_value = {'key': 'value'}\n                result = verify_configuration_file(long_name, 'valid_sig')\n                self.assertEqual(result, {'key': 'value'})\n\n    def test_special_characters_signature(self):\n        # Test special characters in signature\n        special_sig = \"!@#$%^&*()_+-=[]{}|;:'\\\",.<>/?\"\n        with patch('__main__.TRUSTED_CONFIG_SIGNATURES', {'config1': special_sig}):\n            with patch('__main__.fetch_config_data') as mock_fetch:\n                mock_fetch.return_value = {'key': 'value'}\n                result = verify_configuration_file('config1', special_sig)\n                self.assertEqual(result, {'key': 'value'})\n\n    def test_non_string_config_name(self):\n        # Test non-string config name (integer)\n        with patch('__main__.TRUSTED_CONFIG_SIGNATURES', {'123': 'valid_sig'}):\n            result = verify_configuration_file(123, 'valid_sig')\n            self.assertIsNone(result)\n\n    def test_non_string_signature(self):\n        # Test non-string signature (integer)\n        with patch('__main__.TRUSTED_CONFIG_SIGNATURES', {'config1': 'valid_sig'}):\n            result = verify_configuration_file('config1', 123)\n            self.assertIsNone(result)\n", "num_test_cases": 14, "task_id": "abe88359"}
{"test": "import unittest\nfrom unittest.mock import patch\n\nclass TestApplyConfigData(unittest.TestCase):\n\n    def test_valid_config_and_signature(self):\n        # Test with valid configuration name and matching signature\n        with patch('__main__.TRUSTED_CONFIG_SIGNATURES', {'config1': 'valid_sig'}):\n            with patch('__main__.fetch_config_data') as mock_fetch:\n                mock_fetch.return_value = {'key': 'value'}\n                result = apply_config_data('config1', 'valid_sig')\n                self.assertEqual(result, {'key': 'value'})\n                mock_fetch.assert_called_once_with('config1')\n\n    def test_invalid_signature(self):\n        # Test with valid configuration name but invalid signature\n        with patch('__main__.TRUSTED_CONFIG_SIGNATURES', {'config1': 'valid_sig'}):\n            with patch('__main__.fetch_config_data') as mock_fetch:\n                result = apply_config_data('config1', 'invalid_sig')\n                self.assertIsNone(result)\n                mock_fetch.assert_not_called()\n\n    def test_config_not_in_trusted(self):\n        # Test with configuration name not in trusted dictionary\n        with patch('__main__.TRUSTED_CONFIG_SIGNATURES', {'config1': 'valid_sig'}):\n            with patch('__main__.fetch_config_data') as mock_fetch:\n                result = apply_config_data('unknown_config', 'any_sig')\n                self.assertIsNone(result)\n                mock_fetch.assert_not_called()\n\n    def test_io_error(self):\n        # Test when fetch_config_data raises an IOError\n        with patch('__main__.TRUSTED_CONFIG_SIGNATURES', {'config1': 'valid_sig'}):\n            with patch('__main__.fetch_config_data') as mock_fetch:\n                mock_fetch.side_effect = IOError\n                result = apply_config_data('config1', 'valid_sig')\n                self.assertIsNone(result)\n                mock_fetch.assert_called_once_with('config1')\n\n    def test_non_string_config_name(self):\n        # Test with non-string configuration name (integer)\n        with patch('__main__.TRUSTED_CONFIG_SIGNATURES', {'config1': 'valid_sig'}):\n            with patch('__main__.fetch_config_data') as mock_fetch:\n                result = apply_config_data(123, 'valid_sig')\n                self.assertIsNone(result)\n                mock_fetch.assert_not_called()\n\n    def test_non_string_signature(self):\n        # Test with non-string config_signature (integer)\n        with patch('__main__.TRUSTED_CONFIG_SIGNATURES', {'config1': 'valid_sig'}):\n            with patch('__main__.fetch_config_data') as mock_fetch:\n                result = apply_config_data('config1', 123)\n                self.assertIsNone(result)\n                mock_fetch.assert_not_called()\n\n    def test_empty_config_name_valid(self):\n        # Test with empty string configuration name that is trusted and signature matches\n        with patch('__main__.TRUSTED_CONFIG_SIGNATURES', {'': 'valid_sig'}):\n            with patch('__main__.fetch_config_data') as mock_fetch:\n                mock_fetch.return_value = {'empty': True}\n                result = apply_config_data('', 'valid_sig')\n                self.assertEqual(result, {'empty': True})\n                mock_fetch.assert_called_once_with('')\n\n    def test_empty_config_name_invalid(self):\n        # Test with empty string configuration name that is trusted but signature does not match\n        with patch('__main__.TRUSTED_CONFIG_SIGNATURES', {'': 'valid_sig'}):\n            with patch('__main__.fetch_config_data') as mock_fetch:\n                result = apply_config_data('', 'invalid_sig')\n                self.assertIsNone(result)\n                mock_fetch.assert_not_called()\n\n    def test_none_config_name(self):\n        # Test with None configuration name\n        with patch('__main__.TRUSTED_CONFIG_SIGNATURES', {'config1': 'valid_sig'}):\n            with patch('__main__.fetch_config_data') as mock_fetch:\n                result = apply_config_data(None, 'valid_sig')\n                self.assertIsNone(result)\n                mock_fetch.assert_not_called()\n\n    def test_none_signature(self):\n        # Test with None config_signature\n        with patch('__main__.TRUSTED_CONFIG_SIGNATURES', {'config1': 'valid_sig'}):\n            with patch('__main__.fetch_config_data') as mock_fetch:\n                result = apply_config_data('config1', None)\n                self.assertIsNone(result)\n                mock_fetch.assert_not_called()\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 10, "task_id": "0dd288f6"}
{"test": "import unittest\nfrom unittest.mock import patch\n\nclass TestVerifyConfigData(unittest.TestCase):\n\n    def test_case_1(self):\n        # Happy path: valid config_file and signature, fetch_config_data returns data.\n        with patch('config_utils.TRUSTED_CONFIG_SIGNATURES', {'valid_config': 'valid_sig'}):\n            with patch('config_utils.fetch_config_data', return_value={'key': 'value'}) as mock_fetch:\n                result = verify_config_data('valid_config', 'valid_sig')\n                self.assertEqual(result, {'key': 'value'})\n                mock_fetch.assert_called_once_with('valid_config')\n\n    def test_case_2(self):\n        # Valid signature but fetch_config_data raises IOError -> returns None.\n        with patch('config_utils.TRUSTED_CONFIG_SIGNATURES', {'valid_config': 'valid_sig'}):\n            with patch('config_utils.fetch_config_data', side_effect=IOError('File not found')) as mock_fetch:\n                result = verify_config_data('valid_config', 'valid_sig')\n                self.assertIsNone(result)\n                mock_fetch.assert_called_once_with('valid_config')\n\n    def test_case_3(self):\n        # Config_file exists but signature does not match -> returns None.\n        with patch('config_utils.TRUSTED_CONFIG_SIGNATURES', {'valid_config': 'valid_sig'}):\n            result = verify_config_data('valid_config', 'invalid_sig')\n            self.assertIsNone(result)\n\n    def test_case_4(self):\n        # Config_file not in TRUSTED_CONFIG_SIGNATURES -> returns None.\n        with patch('config_utils.TRUSTED_CONFIG_SIGNATURES', {'valid_config': 'valid_sig'}):\n            result = verify_config_data('unknown_config', 'any_sig')\n            self.assertIsNone(result)\n\n    def test_case_5(self):\n        # Empty config_file (not in TRUSTED) -> returns None.\n        with patch('config_utils.TRUSTED_CONFIG_SIGNATURES', {'valid_config': 'valid_sig'}):\n            result = verify_config_data('', 'any_sig')\n            self.assertIsNone(result)\n\n    def test_case_6(self):\n        # None config_file -> returns None.\n        with patch('config_utils.TRUSTED_CONFIG_SIGNATURES', {'valid_config': 'valid_sig'}):\n            result = verify_config_data(None, 'any_sig')\n            self.assertIsNone(result)\n\n    def test_case_7(self):\n        # Empty signature when trusted signature is also empty -> returns data.\n        with patch('config_utils.TRUSTED_CONFIG_SIGNATURES', {'empty_sig_config': ''}):\n            with patch('config_utils.fetch_config_data', return_value={'data': 123}) as mock_fetch:\n                result = verify_config_data('empty_sig_config', '')\n                self.assertEqual(result, {'data': 123})\n                mock_fetch.assert_called_once_with('empty_sig_config')\n\n    def test_case_8(self):\n        # Empty signature when trusted signature is non-empty -> returns None.\n        with patch('config_utils.TRUSTED_CONFIG_SIGNATURES', {'valid_config': 'valid_sig'}):\n            result = verify_config_data('valid_config', '')\n            self.assertIsNone(result)\n\n    def test_case_9(self):\n        # Non-string config_file (integer) -> returns None.\n        with patch('config_utils.TRUSTED_CONFIG_SIGNATURES', {'123': 'valid_sig'}):\n            result = verify_config_data(123, 'valid_sig')\n            self.assertIsNone(result)\n\n    def test_case_10(self):\n        # Non-string provided_signature (integer) -> returns None (even if digits match).\n        with patch('config_utils.TRUSTED_CONFIG_SIGNATURES', {'valid_config': '123'}):\n            result = verify_config_data('valid_config', 123)\n            self.assertIsNone(result)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 10, "task_id": "18045be2"}
{"test": "import unittest\nfrom unittest.mock import patch\n\nclass TestHandleConfigFile(unittest.TestCase):\n\n    def test_valid_filename_and_signature(self):\n        # Test with valid filename and matching signature\n        with patch('config_utils.TRUSTED_CONFIG_SIGNATURES', {'file1': 'valid_sig'}):\n            with patch('config_utils.fetch_config_data') as mock_fetch:\n                mock_fetch.return_value = {'key': 'value'}\n                result = handle_config_file('file1', 'valid_sig')\n                self.assertEqual(result, {'key': 'value'})\n                mock_fetch.assert_called_once_with('file1')\n\n    def test_valid_filename_invalid_signature(self):\n        # Test with valid filename but non-matching signature\n        with patch('config_utils.TRUSTED_CONFIG_SIGNATURES', {'file1': 'valid_sig'}):\n            with patch('config_utils.fetch_config_data') as mock_fetch:\n                result = handle_config_file('file1', 'invalid_sig')\n                self.assertIsNone(result)\n                mock_fetch.assert_not_called()\n\n    def test_invalid_filename(self):\n        # Test with a filename not in TRUSTED_CONFIG_SIGNATURES\n        with patch('config_utils.TRUSTED_CONFIG_SIGNATURES', {'file1': 'valid_sig'}):\n            with patch('config_utils.fetch_config_data') as mock_fetch:\n                result = handle_config_file('file2', 'any_sig')\n                self.assertIsNone(result)\n                mock_fetch.assert_not_called()\n\n    def test_fetch_raises_ioerror(self):\n        # Test when fetch_config_data raises IOError (file not available)\n        with patch('config_utils.TRUSTED_CONFIG_SIGNATURES', {'file1': 'valid_sig'}):\n            with patch('config_utils.fetch_config_data') as mock_fetch:\n                mock_fetch.side_effect = IOError('File not found')\n                result = handle_config_file('file1', 'valid_sig')\n                self.assertIsNone(result)\n                mock_fetch.assert_called_once_with('file1')\n\n    def test_fetch_called_with_correct_filename(self):\n        # Test that fetch_config_data is called with correct filename on valid signature\n        with patch('config_utils.TRUSTED_CONFIG_SIGNATURES', {'file1': 'valid_sig'}):\n            with patch('config_utils.fetch_config_data') as mock_fetch:\n                mock_fetch.return_value = {'key': 'value'}\n                handle_config_file('file1', 'valid_sig')\n                mock_fetch.assert_called_once_with('file1')\n\n    def test_none_filename(self):\n        # Test with None as filename\n        with patch('config_utils.TRUSTED_CONFIG_SIGNATURES', {'file1': 'valid_sig'}):\n            with patch('config_utils.fetch_config_data') as mock_fetch:\n                result = handle_config_file(None, 'any_sig')\n                self.assertIsNone(result)\n                mock_fetch.assert_not_called()\n\n    def test_none_signature(self):\n        # Test with None as signature\n        with patch('config_utils.TRUSTED_CONFIG_SIGNATURES', {'file1': 'valid_sig'}):\n            with patch('config_utils.fetch_config_data') as mock_fetch:\n                result = handle_config_file('file1', None)\n                self.assertIsNone(result)\n                mock_fetch.assert_not_called()\n\n    def test_empty_filename(self):\n        # Test with empty string filename\n        with patch('config_utils.TRUSTED_CONFIG_SIGNATURES', {'file1': 'valid_sig'}):\n            with patch('config_utils.fetch_config_data') as mock_fetch:\n                result = handle_config_file('', 'any_sig')\n                self.assertIsNone(result)\n                mock_fetch.assert_not_called()\n\n    def test_empty_signature(self):\n        # Test with empty string signature\n        with patch('config_utils.TRUSTED_CONFIG_SIGNATURES', {'file1': 'valid_sig'}):\n            with patch('config_utils.fetch_config_data') as mock_fetch:\n                result = handle_config_file('file1', '')\n                self.assertIsNone(result)\n                mock_fetch.assert_not_called()\n\n    def test_large_filename(self):\n        # Test with a very long filename\n        long_filename = 'x' * 1000\n        with patch('config_utils.TRUSTED_CONFIG_SIGNATURES', {long_filename: 'valid_sig'}):\n            with patch('config_utils.fetch_config_data') as mock_fetch:\n                mock_fetch.return_value = {'key': 'value'}\n                result = handle_config_file(long_filename, 'valid_sig')\n                self.assertEqual(result, {'key': 'value'})\n                mock_fetch.assert_called_once_with(long_filename)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 10, "task_id": "057cad17"}
{"test": "import unittest\nfrom unittest.mock import patch, MagicMock\nimport solution\n\nclass TestEvaluateConfigFile(unittest.TestCase):\n\n    def test_valid_config_and_signature(self):\n        # Test with valid config filename and matching signature\n        with patch('solution.TRUSTED_CONFIG_SIGNATURES', {'valid_config.txt': 'correct_sig'}), \\\n             patch('solution.fetch_config_data', MagicMock(return_value={'key': 'value'})) as mock_fetch:\n            result = solution.evaluate_config_file('valid_config.txt', 'correct_sig')\n            self.assertEqual(result, {'key': 'value'})\n            mock_fetch.assert_called_once_with('valid_config.txt')\n\n    def test_valid_config_invalid_signature(self):\n        # Test with valid config filename but incorrect signature\n        with patch('solution.TRUSTED_CONFIG_SIGNATURES', {'valid_config.txt': 'correct_sig'}), \\\n             patch('solution.fetch_config_data') as mock_fetch:\n            result = solution.evaluate_config_file('valid_config.txt', 'wrong_sig')\n            self.assertIsNone(result)\n            mock_fetch.assert_not_called()\n\n    def test_invalid_config_filename(self):\n        # Test with config filename not in trusted signatures\n        with patch('solution.TRUSTED_CONFIG_SIGNATURES', {'valid_config.txt': 'correct_sig'}), \\\n             patch('solution.fetch_config_data') as mock_fetch:\n            result = solution.evaluate_config_file('unknown_config.txt', 'any_sig')\n            self.assertIsNone(result)\n            mock_fetch.assert_not_called()\n\n    def test_valid_config_ioerror(self):\n        # Test valid config and signature but fetch raises IOError\n        with patch('solution.TRUSTED_CONFIG_SIGNATURES', {'valid_config.txt': 'correct_sig'}), \\\n             patch('solution.fetch_config_data', MagicMock(side_effect=IOError)) as mock_fetch:\n            result = solution.evaluate_config_file('valid_config.txt', 'correct_sig')\n            self.assertIsNone(result)\n            mock_fetch.assert_called_once_with('valid_config.txt')\n\n    def test_empty_filename_not_trusted(self):\n        # Test empty config filename not in trusted signatures\n        with patch('solution.TRUSTED_CONFIG_SIGNATURES', {'config.txt': 'sig'}), \\\n             patch('solution.fetch_config_data') as mock_fetch:\n            result = solution.evaluate_config_file('', 'any_sig')\n            self.assertIsNone(result)\n            mock_fetch.assert_not_called()\n\n    def test_empty_filename_trusted_wrong_sig(self):\n        # Test empty config filename in trusted but wrong signature\n        with patch('solution.TRUSTED_CONFIG_SIGNATURES', {'': 'correct_sig'}), \\\n             patch('solution.fetch_config_data') as mock_fetch:\n            result = solution.evaluate_config_file('', 'wrong_sig')\n            self.assertIsNone(result)\n            mock_fetch.assert_not_called()\n\n    def test_empty_filename_trusted_correct_sig(self):\n        # Test empty config filename in trusted with correct signature\n        with patch('solution.TRUSTED_CONFIG_SIGNATURES', {'': 'correct_sig'}), \\\n             patch('solution.fetch_config_data', MagicMock(return_value={'empty': 'config'})) as mock_fetch:\n            result = solution.evaluate_config_file('', 'correct_sig')\n            self.assertEqual(result, {'empty': 'config'})\n            mock_fetch.assert_called_once_with('')\n\n    def test_none_filename(self):\n        # Test None as config filename\n        with patch('solution.TRUSTED_CONFIG_SIGNATURES', {'config.txt': 'sig'}), \\\n             patch('solution.fetch_config_data') as mock_fetch:\n            result = solution.evaluate_config_file(None, 'any_sig')\n            self.assertIsNone(result)\n            mock_fetch.assert_not_called()\n\n    def test_non_string_filename(self):\n        # Test non-string config filename (integer)\n        with patch('solution.TRUSTED_CONFIG_SIGNATURES', {'123': 'sig'}), \\\n             patch('solution.fetch_config_data') as mock_fetch:\n            result = solution.evaluate_config_file(123, 'any_sig')\n            self.assertIsNone(result)\n            mock_fetch.assert_not_called()\n\n    def test_none_signature(self):\n        # Test None as provided signature\n        with patch('solution.TRUSTED_CONFIG_SIGNATURES', {'config.txt': 'correct_sig'}), \\\n             patch('solution.fetch_config_data') as mock_fetch:\n            result = solution.evaluate_config_file('config.txt', None)\n            self.assertIsNone(result)\n            mock_fetch.assert_not_called()\n", "num_test_cases": 10, "task_id": "08143d8a"}
{"test": "import unittest\nfrom unittest.mock import patch, MagicMock\nfrom __main__ import validate_document\n\nclass TestValidateDocument(unittest.TestCase):\n\n    @patch('__main__.DOC_SIGNATURES', {'http://valid.com': 'valid_sign'})\n    @patch('__main__.fetch_document_content')\n    def test_valid_signature_and_fetch_succeeds(self, mock_fetch):\n        # Test with valid file_url and signature, and fetch succeeds.\n        mock_fetch.return_value = 'content'\n        result = validate_document('http://valid.com', 'valid_sign')\n        self.assertTrue(result)\n        mock_fetch.assert_called_once_with('http://valid.com')\n\n    @patch('__main__.DOC_SIGNATURES', {'http://valid.com': 'valid_sign'})\n    @patch('__main__.fetch_document_content')\n    def test_valid_signature_but_fetch_fails(self, mock_fetch):\n        # Test with valid file_url and signature, but fetch raises IOError.\n        mock_fetch.side_effect = IOError('Could not fetch')\n        result = validate_document('http://valid.com', 'valid_sign')\n        self.assertFalse(result)\n        mock_fetch.assert_called_once_with('http://valid.com')\n\n    @patch('__main__.DOC_SIGNATURES', {'http://valid.com': 'valid_sign'})\n    @patch('__main__.fetch_document_content')\n    def test_url_not_in_doc_signatures(self, mock_fetch):\n        # Test with a file_url not present in DOC_SIGNATURES.\n        result = validate_document('http://invalid.com', 'valid_sign')\n        self.assertFalse(result)\n        mock_fetch.assert_not_called()\n\n    @patch('__main__.DOC_SIGNATURES', {'http://valid.com': 'valid_sign'})\n    @patch('__main__.fetch_document_content')\n    def test_url_in_doc_signatures_but_signature_mismatch(self, mock_fetch):\n        # Test with a file_url in DOC_SIGNATURES but the signature does not match.\n        result = validate_document('http://valid.com', 'invalid_sign')\n        self.assertFalse(result)\n        mock_fetch.assert_not_called()\n\n    @patch('__main__.DOC_SIGNATURES', {'': 'empty_sign'})\n    @patch('__main__.fetch_document_content')\n    def test_empty_url_found_and_signature_match(self, mock_fetch):\n        # Test with empty file_url that is found and signature matches.\n        mock_fetch.return_value = 'content'\n        result = validate_document('', 'empty_sign')\n        self.assertTrue(result)\n        mock_fetch.assert_called_once_with('')\n\n    @patch('__main__.DOC_SIGNATURES', {'': 'empty_sign'})\n    @patch('__main__.fetch_document_content')\n    def test_empty_url_found_but_signature_mismatch(self, mock_fetch):\n        # Test with empty file_url that is found but signature does not match.\n        result = validate_document('', 'wrong_sign')\n        self.assertFalse(result)\n        mock_fetch.assert_not_called()\n\n    @patch('__main__.DOC_SIGNATURES', {'http://valid.com': 'valid_sign'})\n    @patch('__main__.fetch_document_content')\n    def test_empty_url_not_found(self, mock_fetch):\n        # Test with empty file_url that is not found in DOC_SIGNATURES.\n        result = validate_document('', 'valid_sign')\n        self.assertFalse(result)\n        mock_fetch.assert_not_called()\n\n    @patch('__main__.DOC_SIGNATURES', {'http://valid.com': ''})\n    @patch('__main__.fetch_document_content')\n    def test_empty_signature_match(self, mock_fetch):\n        # Test with empty signature that matches the expected signature.\n        mock_fetch.return_value = 'content'\n        result = validate_document('http://valid.com', '')\n        self.assertTrue(result)\n        mock_fetch.assert_called_once_with('http://valid.com')\n\n    @patch('__main__.DOC_SIGNATURES', {'http://valid.com': 'non_empty'})\n    @patch('__main__.fetch_document_content')\n    def test_empty_signature_mismatch(self, mock_fetch):\n        # Test with empty signature that does not match the expected signature.\n        result = validate_document('http://valid.com', '')\n        self.assertFalse(result)\n        mock_fetch.assert_not_called()\n\n    @patch('__main__.DOC_SIGNATURES', {None: 'null_sign'})\n    @patch('__main__.fetch_document_content')\n    def test_none_url_found_and_signature_match(self, mock_fetch):\n        # Test with None file_url that is found and signature matches.\n        mock_fetch.return_value = 'content'\n        result = validate_document(None, 'null_sign')\n        self.assertTrue(result)\n        mock_fetch.assert_called_once_with(None)\n\n    @patch('__main__.DOC_SIGNATURES', {None: 'null_sign'})\n    @patch('__main__.fetch_document_content')\n    def test_none_url_found_but_signature_mismatch(self, mock_fetch):\n        # Test with None file_url that is found but signature does not match.\n        result = validate_document(None, 'wrong_sign')\n        self.assertFalse(result)\n        mock_fetch.assert_not_called()\n\n    @patch('__main__.DOC_SIGNATURES', {'http://valid.com': 'valid_sign'})\n    @patch('__main__.fetch_document_content')\n    def test_none_url_not_found(self, mock_fetch):\n        # Test with None file_url that is not found in DOC_SIGNATURES.\n        result = validate_document(None, 'valid_sign')\n        self.assertFalse(result)\n        mock_fetch.assert_not_called()\n\n    @patch('__main__.DOC_SIGNATURES', {123: 'int_sign'})\n    @patch('__main__.fetch_document_content')\n    def test_non_string_url_that_is_found(self, mock_fetch):\n        # Test with non-string (integer) file_url that is found and signature matches.\n        mock_fetch.return_value = 'content'\n        result = validate_document(123, 'int_sign')\n        self.assertTrue(result)\n        mock_fetch.assert_called_once_with(123)\n\n    @patch('__main__.DOC_SIGNATURES', {123: 'int_sign'})\n    @patch('__main__.fetch_document_content')\n    def test_non_string_url_that_is_not_found(self, mock_fetch):\n        # Test with non-string (integer) file_url that is not found.\n        result = validate_document(456, 'int_sign')\n        self.assertFalse(result)\n        mock_fetch.assert_not_called()\n\n    @patch('__main__.DOC_SIGNATURES', {})\n    @patch('__main__.fetch_document_content')\n    def test_non_hashable_url(self, mock_fetch):\n        # Test with a non-hashable file_url (like a list) which should raise a TypeError.\n        with self.assertRaises(TypeError):\n            validate_document([1,2,3], 'signature')\n        mock_fetch.assert_not_called()\n\n    @patch('__main__.fetch_document_content')\n    def test_long_strings(self, mock_fetch):\n        # Test with very long file_url and signature.\n        long_url = 'x' * 10000\n        long_sign = 'y' * 10000\n        with patch('__main__.DOC_SIGNATURES', {long_url: long_sign}):\n            mock_fetch.return_value = 'content'\n            result = validate_document(long_url, long_sign)\n            self.assertTrue(result)\n            mock_fetch.assert_called_once_with(long_url)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 16, "task_id": "4dd3b18d"}
{"test": "import unittest\nfrom unittest.mock import patch, MagicMock\n\nclass TestCheckDocument(unittest.TestCase):\n\n    @patch('__main__.DOC_SIGS', {'https://example.com/doc1': 'abc123'})\n    @patch('__main__.retrieve_document')\n    def test_valid_url_and_signature(self, mock_retrieve):\n        # Test valid URL with matching signature and successful retrieval\n        mock_retrieve.return_value = \"Document content\"\n        result = check_document('https://example.com/doc1', 'abc123')\n        self.assertTrue(result)\n        mock_retrieve.assert_called_once_with('https://example.com/doc1')\n\n    @patch('__main__.DOC_SIGS', {'https://example.com/doc1': 'abc123'})\n    @patch('__main__.retrieve_document')\n    def test_valid_url_retrieve_ioerror(self, mock_retrieve):\n        # Test valid URL with matching signature but retrieval IOError\n        mock_retrieve.side_effect = IOError(\"Connection failed\")\n        result = check_document('https://example.com/doc1', 'abc123')\n        self.assertFalse(result)\n\n    @patch('__main__.DOC_SIGS', {'https://example.com/doc1': 'abc123'})\n    @patch('__main__.retrieve_document')\n    def test_url_not_in_doc_sigs(self, mock_retrieve):\n        # Test URL not present in DOC_SIGS\n        result = check_document('https://example.com/invalid', 'abc123')\n        self.assertFalse(result)\n        mock_retrieve.assert_not_called()\n\n    @patch('__main__.DOC_SIGS', {'https://example.com/doc1': 'abc123'})\n    @patch('__main__.retrieve_document')\n    def test_signature_mismatch(self, mock_retrieve):\n        # Test valid URL but non-matching signature\n        result = check_document('https://example.com/doc1', 'wrong_hash')\n        self.assertFalse(result)\n        mock_retrieve.assert_not_called()\n\n    @patch('__main__.DOC_SIGS', {'': 'empty_signature'})\n    @patch('__main__.retrieve_document')\n    def test_empty_url_valid_signature(self, mock_retrieve):\n        # Test empty URL with matching signature\n        mock_retrieve.return_value = \"Content\"\n        result = check_document('', 'empty_signature')\n        self.assertTrue(result)\n        mock_retrieve.assert_called_once_with('')\n\n    @patch('__main__.DOC_SIGS', {'': 'empty_signature'})\n    @patch('__main__.retrieve_document')\n    def test_empty_url_invalid_signature(self, mock_retrieve):\n        # Test empty URL with non-matching signature\n        result = check_document('', 'invalid')\n        self.assertFalse(result)\n        mock_retrieve.assert_not_called()\n\n    @patch('__main__.DOC_SIGS', {'https://example.com/doc1': ''})\n    @patch('__main__.retrieve_document')\n    def test_empty_signature_valid(self, mock_retrieve):\n        # Test empty signature matching expected\n        mock_retrieve.return_value = \"Content\"\n        result = check_document('https://example.com/doc1', '')\n        self.assertTrue(result)\n\n    @patch('__main__.DOC_SIGS', {'https://example.com/doc1': ''})\n    @patch('__main__.retrieve_document')\n    def test_empty_signature_invalid(self, mock_retrieve):\n        # Test non-empty signature against expected empty\n        result = check_document('https://example.com/doc1', 'non_empty')\n        self.assertFalse(result)\n\n    @patch('__main__.DOC_SIGS', {'long'*1000: 'long'*1000})\n    @patch('__main__.retrieve_document')\n    def test_long_values(self, mock_retrieve):\n        # Test very long URL and signature\n        long_url = 'long'*1000\n        long_hash = 'long'*1000\n        mock_retrieve.return_value = \"Content\"\n        result = check_document(long_url, long_hash)\n        self.assertTrue(result)\n        mock_retrieve.assert_called_once_with(long_url)\n\n    @patch('__main__.DOC_SIGS', {'https://example.com/doc1': 'abc123'})\n    @patch('__main__.retrieve_document')\n    def test_retrieve_ioerror_with_mismatch(self, mock_retrieve):\n        # Test signature mismatch prevents retrieval attempt\n        result = check_document('https://example.com/doc1', 'mismatch')\n        self.assertFalse(result)\n        mock_retrieve.assert_not_called()", "num_test_cases": 10, "task_id": "ba432c80"}
{"test": "import unittest\nfrom unittest.mock import patch, MagicMock\n\nclass TestAuthenticateDocument(unittest.TestCase):\n    def test_happy_path_valid_signature(self):\n        # Test with valid URL, matching signature, and successful resource fetch\n        with patch('__main__.DOC_HASHES', {'https://example.com': 'valid_sig'}):\n            mock_fetch = MagicMock()\n            with patch('__main__.fetch_resource', mock_fetch):\n                result = authenticate_document('https://example.com', 'valid_sig')\n                self.assertTrue(result)\n                mock_fetch.assert_called_once_with('https://example.com')\n\n    def test_signature_match_but_fetch_failure(self):\n        # Test with valid URL and matching signature but fetch raises IOError\n        with patch('__main__.DOC_HASHES', {'https://example.com': 'valid_sig'}):\n            mock_fetch = MagicMock()\n            mock_fetch.side_effect = IOError(\"Connection error\")\n            with patch('__main__.fetch_resource', mock_fetch):\n                result = authenticate_document('https://example.com', 'valid_sig')\n                self.assertFalse(result)\n                mock_fetch.assert_called_once_with('https://example.com')\n\n    def test_valid_url_signature_mismatch(self):\n        # Test with valid URL but incorrect signature\n        with patch('__main__.DOC_HASHES', {'https://example.com': 'valid_sig'}):\n            mock_fetch = MagicMock()\n            with patch('__main__.fetch_resource', mock_fetch):\n                result = authenticate_document('https://example.com', 'invalid_sig')\n                self.assertFalse(result)\n                mock_fetch.assert_not_called()\n\n    def test_url_not_in_doc_hashes(self):\n        # Test with URL not present in DOC_HASHES\n        with patch('__main__.DOC_HASHES', {'https://example.com': 'valid_sig'}):\n            mock_fetch = MagicMock()\n            with patch('__main__.fetch_resource', mock_fetch):\n                result = authenticate_document('https://unknown.com', 'any_sig')\n                self.assertFalse(result)\n                mock_fetch.assert_not_called()\n\n    def test_empty_url_valid_signature(self):\n        # Test empty URL present in DOC_HASHES with matching signature\n        with patch('__main__.DOC_HASHES', {'': 'empty_sig'}):\n            mock_fetch = MagicMock()\n            with patch('__main__.fetch_resource', mock_fetch):\n                result = authenticate_document('', 'empty_sig')\n                self.assertTrue(result)\n                mock_fetch.assert_called_once_with('')\n\n    def test_empty_url_invalid_signature(self):\n        # Test empty URL present in DOC_HASHES with mismatched signature\n        with patch('__main__.DOC_HASHES', {'': 'empty_sig'}):\n            mock_fetch = MagicMock()\n            with patch('__main__.fetch_resource', mock_fetch):\n                result = authenticate_document('', 'wrong_sig')\n                self.assertFalse(result)\n                mock_fetch.assert_not_called()\n\n    def test_empty_url_not_in_doc_hashes(self):\n        # Test empty URL not present in DOC_HASHES\n        with patch('__main__.DOC_HASHES', {'https://example.com': 'valid_sig'}):\n            mock_fetch = MagicMock()\n            with patch('__main__.fetch_resource', mock_fetch):\n                result = authenticate_document('', 'any_sig')\n                self.assertFalse(result)\n                mock_fetch.assert_not_called()\n\n    def test_empty_url_fetch_failure(self):\n        # Test empty URL with matching signature but fetch raises IOError\n        with patch('__main__.DOC_HASHES', {'': 'empty_sig'}):\n            mock_fetch = MagicMock()\n            mock_fetch.side_effect = IOError(\"Resource not found\")\n            with patch('__main__.fetch_resource', mock_fetch):\n                result = authenticate_document('', 'empty_sig')\n                self.assertFalse(result)\n                mock_fetch.assert_called_once_with('')\n\n    def test_empty_signature_match(self):\n        # Test with empty crypto_signature matching DOC_HASHES\n        with patch('__main__.DOC_HASHES', {'https://example.com': ''}):\n            mock_fetch = MagicMock()\n            with patch('__main__.fetch_resource', mock_fetch):\n                result = authenticate_document('https://example.com', '')\n                self.assertTrue(result)\n                mock_fetch.assert_called_once_with('https://example.com')\n\n    def test_empty_signature_mismatch(self):\n        # Test with empty crypto_signature not matching DOC_HASHES\n        with patch('__main__.DOC_HASHES', {'https://example.com': 'non_empty'}):\n            mock_fetch = MagicMock()\n            with patch('__main__.fetch_resource', mock_fetch):\n                result = authenticate_document('https://example.com', '')\n                self.assertFalse(result)\n                mock_fetch.assert_not_called()\n\n    def test_long_url_signature_match(self):\n        # Test with very long URL and matching signature\n        long_url = 'https://' + 'a' * 1000 + '.com'\n        long_sig = 'sig_' + 'b' * 1000\n        with patch('__main__.DOC_HASHES', {long_url: long_sig}):\n            mock_fetch = MagicMock()\n            with patch('__main__.fetch_resource', mock_fetch):\n                result = authenticate_document(long_url, long_sig)\n                self.assertTrue(result)\n                mock_fetch.assert_called_once_with(long_url)\n\n    def test_long_url_signature_mismatch(self):\n        # Test with very long URL and mismatched signature\n        long_url = 'https://' + 'a' * 1000 + '.com'\n        with patch('__main__.DOC_HASHES', {long_url: 'expected_long_sig'}):\n            mock_fetch = MagicMock()\n            with patch('__main__.fetch_resource', mock_fetch):\n                result = authenticate_document(long_url, 'wrong_sig')\n                self.assertFalse(result)\n                mock_fetch.assert_not_called()\n\n    def test_non_ascii_url_signature_match(self):\n        # Test with non-ASCII URL and matching signature\n        url = 'https://例子.com/路径'\n        signature = '签名'\n        with patch('__main__.DOC_HASHES', {url: signature}):\n            mock_fetch = MagicMock()\n            with patch('__main__.fetch_resource', mock_fetch):\n                result = authenticate_document(url, signature)\n                self.assertTrue(result)\n                mock_fetch.assert_called_once_with(url)\n\n    def test_non_ascii_url_signature_mismatch(self):\n        # Test with non-ASCII URL and mismatched signature\n        url = 'https://例子.com/路径'\n        with patch('__main__.DOC_HASHES', {url: 'correct_签名'}):\n            mock_fetch = MagicMock()\n            with patch('__main__.fetch_resource', mock_fetch):\n                result = authenticate_document(url, 'wrong_签名')\n                self.assertFalse(result)\n                mock_fetch.assert_not_called()\n\n    def test_non_string_signature_type_error(self):\n        # Test with non-string crypto_signature (int) when URL in DOC_HASHES\n        with patch('__main__.DOC_HASHES', {'https://example.com': 'valid_sig'}):\n            with self.assertRaises(TypeError):\n                authenticate_document('https://example.com', 12345)\n\n    def test_unhashable_url_type_error(self):\n        # Test with unhashable URL type (list)\n        with self.assertRaises(TypeError):\n            authenticate_document(['https://example.com'], 'any_sig')\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 16, "task_id": "769188b9"}
{"test": "import unittest\nfrom unittest.mock import patch\nfrom solution import validate_file\n\nclass TestCases(unittest.TestCase):\n    @patch('solution.DOCUMENT_SIGNATURES', {'http://example.com': 'correct_sig'})\n    @patch('solution.fetch_data')\n    def test_case_1(self, mock_fetch):\n        # Test valid signature and successful document retrieval\n        mock_fetch.return_value = None\n        result = validate_file('http://example.com', 'correct_sig')\n        self.assertTrue(result)\n\n    @patch('solution.DOCUMENT_SIGNATURES', {'http://example.com': 'correct_sig'})\n    @patch('solution.fetch_data')\n    def test_case_2(self, mock_fetch):\n        # Test valid signature but document retrieval raises IOError\n        mock_fetch.side_effect = IOError('Network error')\n        result = validate_file('http://example.com', 'correct_sig')\n        self.assertFalse(result)\n\n    @patch('solution.DOCUMENT_SIGNATURES', {'http://example.com': 'correct_sig'})\n    def test_case_3(self):\n        # Test invalid signature with existing URL\n        result = validate_file('http://example.com', 'wrong_sig')\n        self.assertFalse(result)\n\n    @patch('solution.DOCUMENT_SIGNATURES', {'http://example.com': 'correct_sig'})\n    def test_case_4(self):\n        # Test URL not present in DOCUMENT_SIGNATURES\n        result = validate_file('http://unknown.com', 'correct_sig')\n        self.assertFalse(result)\n\n    @patch('solution.DOCUMENT_SIGNATURES', {'': 'empty_sig'})\n    @patch('solution.fetch_data')\n    def test_case_5(self, mock_fetch):\n        # Test empty URL with valid signature\n        mock_fetch.return_value = None\n        result = validate_file('', 'empty_sig')\n        self.assertTrue(result)\n\n    @patch('solution.DOCUMENT_SIGNATURES', {'': 'empty_sig'})\n    def test_case_6(self):\n        # Test empty URL with invalid signature\n        result = validate_file('', 'wrong_sig')\n        self.assertFalse(result)\n\n    @patch('solution.DOCUMENT_SIGNATURES', {'a'*1000: 'b'*1000})\n    @patch('solution.fetch_data')\n    def test_case_7(self, mock_fetch):\n        # Test long URL and signature values\n        mock_fetch.return_value = None\n        long_url = 'a'*1000\n        long_sig = 'b'*1000\n        result = validate_file(long_url, long_sig)\n        self.assertTrue(result)\n\n    @patch('solution.DOCUMENT_SIGNATURES', {})\n    def test_case_8(self):\n        # Test when DOCUMENT_SIGNATURES is empty\n        result = validate_file('http://example.com', 'any_sig')\n        self.assertFalse(result)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 8, "task_id": "fc741831"}
{"test": "import unittest\nfrom unittest.mock import patch\n\nclass TestCheckFile(unittest.TestCase):\n\n    def test_case_1(self):\n        # Happy path: valid document_location and crypto_sign, and retrieve_content succeeds.\n        my_dict = {'http://example.com/document1': 'signature1'}\n        with patch('__main__.retrieve_content') as mock_retrieve:\n            mock_retrieve.return_value = 'content'\n            with patch('__main__.DOCUMENT_SIGNATURES', my_dict):\n                result = check_file('http://example.com/document1', 'signature1')\n                self.assertTrue(result)\n\n    def test_case_2(self):\n        # Valid document_location and crypto_sign, but retrieve_content raises IOError.\n        my_dict = {'http://example.com/document1': 'signature1'}\n        with patch('__main__.retrieve_content') as mock_retrieve:\n            mock_retrieve.side_effect = IOError\n            with patch('__main__.DOCUMENT_SIGNATURES', my_dict):\n                result = check_file('http://example.com/document1', 'signature1')\n                self.assertFalse(result)\n\n    def test_case_3(self):\n        # document_location in DOCUMENT_SIGNATURES but crypto_sign does not match.\n        my_dict = {'http://example.com/document1': 'signature1'}\n        with patch('__main__.retrieve_content') as mock_retrieve:\n            with patch('__main__.DOCUMENT_SIGNATURES', my_dict):\n                result = check_file('http://example.com/document1', 'wrong_signature')\n                self.assertFalse(result)\n                mock_retrieve.assert_not_called()\n\n    def test_case_4(self):\n        # document_location not in DOCUMENT_SIGNATURES.\n        my_dict = {}\n        with patch('__main__.retrieve_content') as mock_retrieve:\n            with patch('__main__.DOCUMENT_SIGNATURES', my_dict):\n                result = check_file('http://example.com/document1', 'signature1')\n                self.assertFalse(result)\n                mock_retrieve.assert_not_called()\n\n    def test_case_5(self):\n        # Empty document_location not in DOCUMENT_SIGNATURES.\n        my_dict = {'non_empty': 'signature'}\n        with patch('__main__.retrieve_content') as mock_retrieve:\n            with patch('__main__.DOCUMENT_SIGNATURES', my_dict):\n                result = check_file('', 'signature1')\n                self.assertFalse(result)\n                mock_retrieve.assert_not_called()\n\n    def test_case_6(self):\n        # Empty document_location in DOCUMENT_SIGNATURES but crypto_sign does not match.\n        my_dict = {'': 'correct_signature'}\n        with patch('__main__.retrieve_content') as mock_retrieve:\n            with patch('__main__.DOCUMENT_SIGNATURES', my_dict):\n                result = check_file('', 'wrong_signature')\n                self.assertFalse(result)\n                mock_retrieve.assert_not_called()\n\n    def test_case_7(self):\n        # Empty document_location in DOCUMENT_SIGNATURES, matching crypto_sign, and retrieval succeeds.\n        my_dict = {'': 'correct_signature'}\n        with patch('__main__.retrieve_content') as mock_retrieve:\n            mock_retrieve.return_value = 'content'\n            with patch('__main__.DOCUMENT_SIGNATURES', my_dict):\n                result = check_file('', 'correct_signature')\n                self.assertTrue(result)\n\n    def test_case_8(self):\n        # Empty document_location in DOCUMENT_SIGNATURES, matching crypto_sign, but retrieval fails.\n        my_dict = {'': 'correct_signature'}\n        with patch('__main__.retrieve_content') as mock_retrieve:\n            mock_retrieve.side_effect = IOError\n            with patch('__main__.DOCUMENT_SIGNATURES', my_dict):\n                result = check_file('', 'correct_signature')\n                self.assertFalse(result)\n\n    def test_case_9(self):\n        # Non-hashable document_location (list) should raise TypeError.\n        with patch('__main__.retrieve_content') as mock_retrieve:\n            with patch('__main__.DOCUMENT_SIGNATURES', {}):\n                with self.assertRaises(TypeError):\n                    check_file([], 'signature')\n\n    def test_case_10(self):\n        # Long document_location and long crypto_sign, matching, and retrieval succeeds.\n        long_url = 'http://example.com/' + 'a' * 1000\n        long_signature = 'a' * 1000\n        my_dict = {long_url: long_signature}\n        with patch('__main__.retrieve_content') as mock_retrieve:\n            mock_retrieve.return_value = 'content'\n            with patch('__main__.DOCUMENT_SIGNATURES', my_dict):\n                result = check_file(long_url, long_signature)\n                self.assertTrue(result)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 10, "task_id": "d6b53b01"}
{"test": "import unittest\nfrom unittest.mock import patch, MagicMock\nimport __main__\n\nclass TestAuthenticateFile(unittest.TestCase):\n    def setUp(self):\n        # Save original DOCUMENT_SIGNATURES and set up test data\n        self.original_doc_signatures = getattr(__main__, 'DOCUMENT_SIGNATURES', None)\n        __main__.DOCUMENT_SIGNATURES = {\n            'https://valid.url': 'correct_signature',\n            'https://empty.url': '',\n            'https://none.url': None,\n            'https://long.url': 'signature_abc' * 1000,\n            None: 'none_signature',\n            '': 'empty_signature'\n        }\n\n    def tearDown(self):\n        # Restore original DOCUMENT_SIGNATURES\n        if self.original_doc_signatures is not None:\n            __main__.DOCUMENT_SIGNATURES = self.original_doc_signatures\n        else:\n            if hasattr(__main__, 'DOCUMENT_SIGNATURES'):\n                del __main__.DOCUMENT_SIGNATURES\n\n    @patch('__main__.download_content')\n    def test_valid_location_and_signature(self, mock_download):\n        # Test valid URL with matching signature\n        mock_download.return_value = 'content'\n        result = authenticate_file('https://valid.url', 'correct_signature')\n        self.assertTrue(result)\n\n    @patch('__main__.download_content')\n    def test_valid_location_invalid_signature(self, mock_download):\n        # Test valid URL with incorrect signature\n        result = authenticate_file('https://valid.url', 'incorrect_signature')\n        self.assertFalse(result)\n\n    @patch('__main__.download_content')\n    def test_location_not_in_database(self, mock_download):\n        # Test URL not present in DOCUMENT_SIGNATURES\n        result = authenticate_file('https://unknown.url', 'any_signature')\n        self.assertFalse(result)\n\n    @patch('__main__.download_content')\n    def test_download_failure_valid_signature(self, mock_download):\n        # Test valid signature but download raises IOError\n        mock_download.side_effect = IOError('Download failed')\n        result = authenticate_file('https://valid.url', 'correct_signature')\n        self.assertFalse(result)\n\n    @patch('__main__.download_content')\n    def test_empty_location_in_database_valid_signature(self, mock_download):\n        # Test empty string location with valid signature\n        mock_download.return_value = 'content'\n        result = authenticate_file('', 'empty_signature')\n        self.assertTrue(result)\n\n    @patch('__main__.download_content')\n    def test_none_location_in_database_valid_signature(self, mock_download):\n        # Test None location with valid signature\n        mock_download.return_value = 'content'\n        result = authenticate_file(None, 'none_signature')\n        self.assertTrue(result)\n\n    @patch('__main__.download_content')\n    def test_none_location_not_in_database(self, mock_download):\n        # Test None location not in DOCUMENT_SIGNATURES\n        result = authenticate_file(None, 'any_signature')\n        self.assertFalse(result)\n\n    @patch('__main__.download_content')\n    def test_empty_signature(self, mock_download):\n        # Test empty string signature\n        result = authenticate_file('https://valid.url', '')\n        self.assertFalse(result)\n\n    @patch('__main__.download_content')\n    def test_none_signature(self, mock_download):\n        # Test None signature\n        result = authenticate_file('https://valid.url', None)\n        self.assertFalse(result)\n\n    @patch('__main__.download_content')\n    def test_none_signature_with_stored_none(self, mock_download):\n        # Test None signature matching stored None\n        mock_download.return_value = 'content'\n        result = authenticate_file('https://none.url', None)\n        self.assertTrue(result)\n\n    @patch('__main__.download_content')\n    def test_long_url(self, mock_download):\n        # Test very long URL\n        long_url = 'https://' + 'a' * 10000\n        __main__.DOCUMENT_SIGNATURES[long_url] = 'long_signature'\n        mock_download.return_value = 'content'\n        result = authenticate_file(long_url, 'long_signature')\n        self.assertTrue(result)\n\n    @patch('__main__.download_content')\n    def test_long_signature(self, mock_download):\n        # Test very long signature\n        long_signature = 'a' * 10000\n        __main__.DOCUMENT_SIGNATURES['https://valid.url'] = long_signature\n        mock_download.return_value = 'content'\n        result = authenticate_file('https://valid.url', long_signature)\n        self.assertTrue(result)\n\n    @patch('__main__.download_content')\n    def test_integer_location(self, mock_download):\n        # Test integer location not in database\n        result = authenticate_file(12345, 'any_signature')\n        self.assertFalse(result)\n\n    @patch('__main__.download_content')\n    def test_integer_location_in_database(self, mock_download):\n        # Test integer location in database\n        __main__.DOCUMENT_SIGNATURES[123] = 'int_signature'\n        mock_download.return_value = 'content'\n        result = authenticate_file(123, 'int_signature')\n        self.assertTrue(result)\n\n    @patch('__main__.download_content')\n    def test_integer_signature(self, mock_download):\n        # Test integer signature\n        __main__.DOCUMENT_SIGNATURES['https://valid.url'] = 'correct_signature'\n        result = authenticate_file('https://valid.url', 123)\n        self.assertFalse(result)\n\n    @patch('__main__.download_content')\n    def test_integer_signature_match(self, mock_download):\n        # Test integer signature matching stored integer\n        __main__.DOCUMENT_SIGNATURES['https://valid.url'] = 123\n        mock_download.return_value = 'content'\n        result = authenticate_file('https://valid.url', 123)\n        self.assertTrue(result)\n\n    @patch('__main__.download_content')\n    def test_download_content_called_on_valid(self, mock_download):\n        # Test download_content is called when signature matches\n        mock_download.return_value = 'content'\n        authenticate_file('https://valid.url', 'correct_signature')\n        mock_download.assert_called_once_with('https://valid.url')\n\n    @patch('__main__.download_content')\n    def test_download_content_not_called_on_invalid_signature(self, mock_download):\n        # Test download_content not called on invalid signature\n        authenticate_file('https://valid.url', 'incorrect_signature')\n        mock_download.assert_not_called()\n\n    @patch('__main__.download_content')\n    def test_download_content_not_called_on_missing_url(self, mock_download):\n        # Test download_content not called when URL not in database\n        authenticate_file('https://missing.url', 'any_signature')\n        mock_download.assert_not_called()\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 20, "task_id": "5d8c6e4a"}
{"test": "import unittest\nfrom unittest.mock import patch\n\nclass TestDocumentAuthentication(unittest.TestCase):\n    @patch('document_utils.fetch_document_content')\n    @patch('document_utils.DOCUMENT_SIGNATURES', new_callable=dict)\n    def test_valid_signature_and_fetch_succeeds(self, mock_sigs, mock_fetch):\n        # Test valid url and signature with successful content fetch\n        mock_sigs['valid_url'] = 'valid_sig'\n        mock_fetch.return_value = \"dummy content\"\n        result = authenticate_document('valid_url', 'valid_sig')\n        self.assertTrue(result)\n\n    @patch('document_utils.fetch_document_content')\n    @patch('document_utils.DOCUMENT_SIGNATURES', new_callable=dict)\n    def test_valid_signature_but_fetch_fails(self, mock_sigs, mock_fetch):\n        # Test valid url and signature but document fetch fails\n        mock_sigs['valid_url'] = 'valid_sig'\n        mock_fetch.side_effect = IOError(\"Document not found\")\n        result = authenticate_document('valid_url', 'valid_sig')\n        self.assertFalse(result)\n\n    @patch('document_utils.fetch_document_content')\n    @patch('document_utils.DOCUMENT_SIGNATURES', new_callable=dict)\n    def test_invalid_signature(self, mock_sigs, mock_fetch):\n        # Test valid url but invalid signature\n        mock_sigs['valid_url'] = 'valid_sig'\n        result = authenticate_document('valid_url', 'invalid_sig')\n        self.assertFalse(result)\n        mock_fetch.assert_not_called()\n\n    @patch('document_utils.fetch_document_content')\n    @patch('document_utils.DOCUMENT_SIGNATURES', new_callable=dict)\n    def test_url_not_in_dictionary(self, mock_sigs, mock_fetch):\n        # Test url not present in DOCUMENT_SIGNATURES\n        result = authenticate_document('invalid_url', 'any_sig')\n        self.assertFalse(result)\n        mock_fetch.assert_not_called()\n\n    @patch('document_utils.fetch_document_content')\n    @patch('document_utils.DOCUMENT_SIGNATURES', new_callable=dict)\n    def test_empty_url_not_in_dictionary(self, mock_sigs, mock_fetch):\n        # Test empty url not in DOCUMENT_SIGNATURES\n        result = authenticate_document('', 'any_sig')\n        self.assertFalse(result)\n        mock_fetch.assert_not_called()\n\n    @patch('document_utils.fetch_document_content')\n    @patch('document_utils.DOCUMENT_SIGNATURES', new_callable=dict)\n    def test_empty_url_valid_signature_and_fetch_succeeds(self, mock_sigs, mock_fetch):\n        # Test empty url with valid signature and successful fetch\n        mock_sigs[''] = 'valid_sig'\n        mock_fetch.return_value = \"dummy content\"\n        result = authenticate_document('', 'valid_sig')\n        self.assertTrue(result)\n\n    @patch('document_utils.fetch_document_content')\n    @patch('document_utils.DOCUMENT_SIGNATURES', new_callable=dict)\n    def test_empty_url_valid_signature_but_fetch_fails(self, mock_sigs, mock_fetch):\n        # Test empty url with valid signature but fetch fails\n        mock_sigs[''] = 'valid_sig'\n        mock_fetch.side_effect = IOError(\"Document not found\")\n        result = authenticate_document('', 'valid_sig')\n        self.assertFalse(result)\n\n    @patch('document_utils.fetch_document_content')\n    @patch('document_utils.DOCUMENT_SIGNATURES', new_callable=dict)\n    def test_non_string_url(self, mock_sigs, mock_fetch):\n        # Test non-string url (integer)\n        result = authenticate_document(123, 'any_sig')\n        self.assertFalse(result)\n        mock_fetch.assert_not_called()\n\n    @patch('document_utils.fetch_document_content')\n    @patch('document_utils.DOCUMENT_SIGNATURES', new_callable=dict)\n    def test_non_string_signature_matching(self, mock_sigs, mock_fetch):\n        # Test non-string signature (integer) matching stored signature\n        mock_sigs['valid_url'] = 123\n        mock_fetch.return_value = \"dummy\"\n        result = authenticate_document('valid_url', 123)\n        self.assertTrue(result)\n\n    @patch('document_utils.fetch_document_content')\n    @patch('document_utils.DOCUMENT_SIGNATURES', new_callable=dict)\n    def test_non_string_signature_not_matching(self, mock_sigs, mock_fetch):\n        # Test non-string signature (integer) not matching stored signature\n        mock_sigs['valid_url'] = 123\n        result = authenticate_document('valid_url', 456)\n        self.assertFalse(result)\n\n    @patch('document_utils.fetch_document_content')\n    @patch('document_utils.DOCUMENT_SIGNATURES', new_callable=dict)\n    def test_url_none_not_in_dictionary(self, mock_sigs, mock_fetch):\n        # Test None url not in DOCUMENT_SIGNATURES\n        result = authenticate_document(None, 'any_sig')\n        self.assertFalse(result)\n        mock_fetch.assert_not_called()\n\n    @patch('document_utils.fetch_document_content')\n    @patch('document_utils.DOCUMENT_SIGNATURES', new_callable=dict)\n    def test_url_none_in_dictionary_signature_matches_fetch_succeeds(self, mock_sigs, mock_fetch):\n        # Test None url in DOCUMENT_SIGNATURES with None signature and successful fetch\n        mock_sigs[None] = None\n        mock_fetch.return_value = \"dummy\"\n        result = authenticate_document(None, None)\n        self.assertTrue(result)\n\n    @patch('document_utils.fetch_document_content')\n    @patch('document_utils.DOCUMENT_SIGNATURES', new_callable=dict)\n    def test_url_none_in_dictionary_signature_matches_fetch_fails(self, mock_sigs, mock_fetch):\n        # Test None url in DOCUMENT_SIGNATURES with None signature but fetch fails\n        mock_sigs[None] = None\n        mock_fetch.side_effect = IOError(\"Document not found\")\n        result = authenticate_document(None, None)\n        self.assertFalse(result)\n\n    @patch('document_utils.fetch_document_content')\n    @patch('document_utils.DOCUMENT_SIGNATURES', new_callable=dict)\n    def test_url_none_in_dictionary_signature_mismatch(self, mock_sigs, mock_fetch):\n        # Test None url in DOCUMENT_SIGNATURES with signature mismatch (None vs string)\n        mock_sigs[None] = 'some_sig'\n        result = authenticate_document(None, None)\n        self.assertFalse(result)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 14, "task_id": "12f6cb9a"}
{"test": "import unittest\nfrom unittest.mock import patch\n\nclass TestValidateDocument(unittest.TestCase):\n    @patch('__main__.retrieve_document_content')\n    @patch('__main__.DOCUMENT_SIGNATURES', new_callable=dict)\n    def test_happy_path(self, mock_signatures, mock_retrieve):\n        # Test with matching URL and signature, and successful document retrieval.\n        mock_signatures['valid_url'] = 'valid_signature'\n        mock_retrieve.return_value = 'document_content'\n        result = validate_document('valid_url', 'valid_signature')\n        self.assertTrue(result)\n        mock_retrieve.assert_called_once_with('valid_url')\n\n    @patch('__main__.retrieve_document_content')\n    @patch('__main__.DOCUMENT_SIGNATURES', new_callable=dict)\n    def test_signature_mismatch(self, mock_signatures, mock_retrieve):\n        # Test with matching URL but incorrect signature.\n        mock_signatures['valid_url'] = 'valid_signature'\n        result = validate_document('valid_url', 'invalid_signature')\n        self.assertFalse(result)\n        mock_retrieve.assert_not_called()\n\n    @patch('__main__.retrieve_document_content')\n    @patch('__main__.DOCUMENT_SIGNATURES', new_callable=dict)\n    def test_url_not_found(self, mock_signatures, mock_retrieve):\n        # Test with URL not present in DOCUMENT_SIGNATURES.\n        mock_signatures['valid_url'] = 'valid_signature'\n        result = validate_document('unknown_url', 'any_signature')\n        self.assertFalse(result)\n        mock_retrieve.assert_not_called()\n\n    @patch('__main__.retrieve_document_content')\n    @patch('__main__.DOCUMENT_SIGNATURES', new_callable=dict)\n    def test_retrieve_fails(self, mock_signatures, mock_retrieve):\n        # Test with matching URL and signature but document retrieval fails.\n        mock_signatures['valid_url'] = 'valid_signature'\n        mock_retrieve.side_effect = IOError('Document not found')\n        result = validate_document('valid_url', 'valid_signature')\n        self.assertFalse(result)\n        mock_retrieve.assert_called_once_with('valid_url')\n\n    @patch('__main__.retrieve_document_content')\n    @patch('__main__.DOCUMENT_SIGNATURES', new_callable=dict)\n    def test_empty_url_happy(self, mock_signatures, mock_retrieve):\n        # Test with empty URL and signature that match, and successful retrieval.\n        mock_signatures[''] = 'empty_signature'\n        mock_retrieve.return_value = 'content'\n        result = validate_document('', 'empty_signature')\n        self.assertTrue(result)\n        mock_retrieve.assert_called_once_with('')\n\n    @patch('__main__.retrieve_document_content')\n    @patch('__main__.DOCUMENT_SIGNATURES', new_callable=dict)\n    def test_empty_url_retrieve_fails(self, mock_signatures, mock_retrieve):\n        # Test with empty URL and matching signature but retrieval fails.\n        mock_signatures[''] = 'empty_signature'\n        mock_retrieve.side_effect = IOError('Document not found')\n        result = validate_document('', 'empty_signature')\n        self.assertFalse(result)\n        mock_retrieve.assert_called_once_with('')\n\n    @patch('__main__.retrieve_document_content')\n    @patch('__main__.DOCUMENT_SIGNATURES', new_callable=dict)\n    def test_empty_url_not_found(self, mock_signatures, mock_retrieve):\n        # Test with empty URL not in DOCUMENT_SIGNATURES.\n        mock_signatures['valid_url'] = 'valid_signature'\n        result = validate_document('', 'any_signature')\n        self.assertFalse(result)\n        mock_retrieve.assert_not_called()\n\n    @patch('__main__.retrieve_document_content')\n    @patch('__main__.DOCUMENT_SIGNATURES', new_callable=dict)\n    def test_non_empty_url_empty_signature(self, mock_signatures, mock_retrieve):\n        # Test with URL in DOCUMENT_SIGNATURES but provided signature is empty.\n        mock_signatures['valid_url'] = 'non_empty_signature'\n        result = validate_document('valid_url', '')\n        self.assertFalse(result)\n        mock_retrieve.assert_not_called()\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 8, "task_id": "51e3ae49"}
{"test": "import unittest\nfrom unittest.mock import patch\n\nclass TestCheckDocument(unittest.TestCase):\n    def setUp(self):\n        # Initialize mock DOCUMENT_SIGNATURES and retrieve_doc_content\n        self.doc_signatures_patcher = patch('__main__.DOCUMENT_SIGNATURES', {'valid_link': 'valid_sig', 'empty_link': ''})\n        self.mock_doc_signatures = self.doc_signatures_patcher.start()\n        self.retrieve_patcher = patch('__main__.retrieve_doc_content')\n        self.mock_retrieve = self.retrieve_patcher.start()\n        self.mock_retrieve.return_value = \"Some content\"\n\n    def tearDown(self):\n        # Stop all patchers\n        self.doc_signatures_patcher.stop()\n        self.retrieve_patcher.stop()\n\n    def test_valid_doc_and_sig(self):\n        # Valid document link and matching signature\n        self.assertTrue(check_document('valid_link', 'valid_sig'))\n        self.mock_retrieve.assert_called_once_with('valid_link')\n\n    def test_valid_doc_invalid_sig(self):\n        # Valid document link but non-matching signature\n        self.assertFalse(check_document('valid_link', 'invalid_sig'))\n        self.mock_retrieve.assert_not_called()\n\n    def test_doc_not_in_signatures(self):\n        # Document link not present in DOCUMENT_SIGNATURES\n        self.assertFalse(check_document('non_existent_link', 'any_sig'))\n        self.mock_retrieve.assert_not_called()\n\n    def test_ioerror_retrieval(self):\n        # IOError raised during document retrieval (signature matches)\n        self.mock_retrieve.side_effect = IOError\n        self.assertFalse(check_document('valid_link', 'valid_sig'))\n        self.mock_retrieve.assert_called_once_with('valid_link')\n\n    def test_empty_doc_link_not_in_signatures(self):\n        # Empty document link not in DOCUMENT_SIGNATURES\n        self.assertFalse(check_document('', 'any_sig'))\n        self.mock_retrieve.assert_not_called()\n\n    def test_empty_doc_link_in_signatures_valid_sig(self):\n        # Empty document link in DOCUMENT_SIGNATURES with matching empty signature\n        self.assertTrue(check_document('empty_link', ''))\n        self.mock_retrieve.assert_called_once_with('empty_link')\n\n    def test_empty_doc_link_in_signatures_invalid_sig(self):\n        # Empty document link in DOCUMENT_SIGNATURES but non-matching signature\n        self.assertFalse(check_document('empty_link', 'non_empty'))\n        self.mock_retrieve.assert_not_called()\n\n    def test_none_doc_link(self):\n        # None as document link\n        self.assertFalse(check_document(None, 'any_sig'))\n        self.mock_retrieve.assert_not_called()\n\n    def test_none_signature(self):\n        # None as signature\n        self.assertFalse(check_document('valid_link', None))\n        self.mock_retrieve.assert_not_called()\n\n    def test_non_string_doc_link(self):\n        # Non-string document link (integer)\n        self.assertFalse(check_document(123, 'valid_sig'))\n        self.mock_retrieve.assert_not_called()\n\n    def test_non_string_signature(self):\n        # Non-string signature (integer)\n        self.assertFalse(check_document('valid_link', 123))\n        self.mock_retrieve.assert_not_called()\n\n    def test_very_long_doc_link(self):\n        # Very long document link in DOCUMENT_SIGNATURES with matching signature\n        long_link = 'a' * 10000\n        self.mock_doc_signatures[long_link] = 'long_sig'\n        self.assertTrue(check_document(long_link, 'long_sig'))\n        self.mock_retrieve.assert_called_once_with(long_link)\n\n    def test_very_long_signature(self):\n        # Very long signature matching DOCUMENT_SIGNATURES\n        long_sig = 'a' * 10000\n        self.mock_doc_signatures['long_sig_doc'] = long_sig\n        self.assertTrue(check_document('long_sig_doc', long_sig))\n        self.mock_retrieve.assert_called_once_with('long_sig_doc')\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 14, "task_id": "65a0938e"}
{"test": "import unittest\nfrom unittest.mock import patch\n\nclass TestRetrieveUserData(unittest.TestCase):\n\n    def test_happy_path(self):\n        \"\"\"\n        Test with valid uid and matching signature, expecting profile data return.\n        \"\"\"\n        with patch('user_service.TRUSTED_USER_PROFILES', {'user1': 'valid_sig'}), \\\n             patch('user_service.get_profile_from_service') as mock_get_profile:\n            mock_get_profile.return_value = {'name': 'John'}\n            result = retrieve_user_data('user1', 'valid_sig')\n            self.assertEqual(result, {'name': 'John'})\n            mock_get_profile.assert_called_once_with('user1')\n\n    def test_invalid_signature(self):\n        \"\"\"\n        Test with valid uid but mismatched signature, expecting None.\n        \"\"\"\n        with patch('user_service.TRUSTED_USER_PROFILES', {'user1': 'valid_sig'}), \\\n             patch('user_service.get_profile_from_service') as mock_get_profile:\n            result = retrieve_user_data('user1', 'invalid_sig')\n            self.assertIsNone(result)\n            mock_get_profile.assert_not_called()\n\n    def test_uid_not_found(self):\n        \"\"\"\n        Test with uid not in TRUSTED_USER_PROFILES, expecting None.\n        \"\"\"\n        with patch('user_service.TRUSTED_USER_PROFILES', {'user1': 'valid_sig'}), \\\n             patch('user_service.get_profile_from_service') as mock_get_profile:\n            result = retrieve_user_data('unknown_user', 'any_sig')\n            self.assertIsNone(result)\n            mock_get_profile.assert_not_called()\n\n    def test_connection_error(self):\n        \"\"\"\n        Test valid credentials but service raises ConnectionError, expecting None.\n        \"\"\"\n        with patch('user_service.TRUSTED_USER_PROFILES', {'user1': 'valid_sig'}), \\\n             patch('user_service.get_profile_from_service') as mock_get_profile:\n            mock_get_profile.side_effect = ConnectionError\n            result = retrieve_user_data('user1', 'valid_sig')\n            self.assertIsNone(result)\n            mock_get_profile.assert_called_once_with('user1')\n\n    def test_empty_profile_data(self):\n        \"\"\"\n        Test valid credentials but empty profile data returned from service.\n        \"\"\"\n        with patch('user_service.TRUSTED_USER_PROFILES', {'user1': 'valid_sig'}), \\\n             patch('user_service.get_profile_from_service') as mock_get_profile:\n            mock_get_profile.return_value = ''\n            result = retrieve_user_data('user1', 'valid_sig')\n            self.assertEqual(result, '')\n            mock_get_profile.assert_called_once_with('user1')\n\n    def test_empty_uid_valid(self):\n        \"\"\"\n        Test empty string uid with matching signature, expecting profile data.\n        \"\"\"\n        with patch('user_service.TRUSTED_USER_PROFILES', {'': 'empty_sig'}), \\\n             patch('user_service.get_profile_from_service') as mock_get_profile:\n            mock_get_profile.return_value = 'empty_profile'\n            result = retrieve_user_data('', 'empty_sig')\n            self.assertEqual(result, 'empty_profile')\n            mock_get_profile.assert_called_once_with('')\n\n    def test_empty_uid_not_found(self):\n        \"\"\"\n        Test empty string uid not in TRUSTED_USER_PROFILES, expecting None.\n        \"\"\"\n        with patch('user_service.TRUSTED_USER_PROFILES', {'user1': 'sig1'}), \\\n             patch('user_service.get_profile_from_service') as mock_get_profile:\n            result = retrieve_user_data('', 'any_sig')\n            self.assertIsNone(result)\n            mock_get_profile.assert_not_called()\n\n    def test_empty_signature_mismatch(self):\n        \"\"\"\n        Test empty signature against non-empty trusted signature, expecting None.\n        \"\"\"\n        with patch('user_service.TRUSTED_USER_PROFILES', {'user1': 'non_empty_sig'}), \\\n             patch('user_service.get_profile_from_service') as mock_get_profile:\n            result = retrieve_user_data('user1', '')\n            self.assertIsNone(result)\n            mock_get_profile.assert_not_called()\n\n    def test_empty_signature_match(self):\n        \"\"\"\n        Test empty signature against empty trusted signature, expecting profile data.\n        \"\"\"\n        with patch('user_service.TRUSTED_USER_PROFILES', {'user1': ''}), \\\n             patch('user_service.get_profile_from_service') as mock_get_profile:\n            mock_get_profile.return_value = 'profile_data'\n            result = retrieve_user_data('user1', '')\n            self.assertEqual(result, 'profile_data')\n            mock_get_profile.assert_called_once_with('user1')\n\n    def test_uid_none(self):\n        \"\"\"\n        Test None uid, expecting None.\n        \"\"\"\n        with patch('user_service.TRUSTED_USER_PROFILES', {'user1': 'sig1'}), \\\n             patch('user_service.get_profile_from_service') as mock_get_profile:\n            result = retrieve_user_data(None, 'any_sig')\n            self.assertIsNone(result)\n            mock_get_profile.assert_not_called()\n\n    def test_sig_none(self):\n        \"\"\"\n        Test None signature, expecting None.\n        \"\"\"\n        with patch('user_service.TRUSTED_USER_PROFILES', {'user1': 'sig1'}), \\\n             patch('user_service.get_profile_from_service') as mock_get_profile:\n            result = retrieve_user_data('user1', None)\n            self.assertIsNone(result)\n            mock_get_profile.assert_not_called()\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 11, "task_id": "064282e6"}
{"test": "import unittest\nfrom unittest.mock import patch, MagicMock\n\nclass TestCollectUserData(unittest.TestCase):\n    \n    @patch('user_profile.TRUSTED_USER_PROFILES', {'valid_user': 'valid_sig'})\n    @patch('user_profile.get_profile_from_service')\n    def test_valid_user_and_signature(self, mock_get_profile):\n        \"\"\"Test with valid user identifier and matching signature.\"\"\"\n        mock_get_profile.return_value = {'name': 'John Doe'}\n        result = collect_user_data('valid_user', 'valid_sig')\n        mock_get_profile.assert_called_once_with('valid_user')\n        self.assertEqual(result, {'name': 'John Doe'})\n    \n    @patch('user_profile.TRUSTED_USER_PROFILES', {'valid_user': 'valid_sig'})\n    @patch('user_profile.get_profile_from_service')\n    def test_valid_user_invalid_signature(self, mock_get_profile):\n        \"\"\"Test with valid user identifier but non-matching signature.\"\"\"\n        result = collect_user_data('valid_user', 'invalid_sig')\n        mock_get_profile.assert_not_called()\n        self.assertIsNone(result)\n    \n    @patch('user_profile.TRUSTED_USER_PROFILES', {'valid_user': 'valid_sig'})\n    @patch('user_profile.get_profile_from_service')\n    def test_user_not_in_trusted(self, mock_get_profile):\n        \"\"\"Test with user identifier not present in trusted profiles.\"\"\"\n        result = collect_user_data('unknown_user', 'any_sig')\n        mock_get_profile.assert_not_called()\n        self.assertIsNone(result)\n    \n    @patch('user_profile.TRUSTED_USER_PROFILES', {'valid_user': 'valid_sig'})\n    @patch('user_profile.get_profile_from_service')\n    def test_connection_error(self, mock_get_profile):\n        \"\"\"Test when service call raises ConnectionError.\"\"\"\n        mock_get_profile.side_effect = ConnectionError\n        result = collect_user_data('valid_user', 'valid_sig')\n        self.assertIsNone(result)\n    \n    @patch('user_profile.TRUSTED_USER_PROFILES', {'': 'empty_sig'})\n    @patch('user_profile.get_profile_from_service')\n    def test_empty_user_valid_signature(self, mock_get_profile):\n        \"\"\"Test with empty user identifier and valid signature.\"\"\"\n        mock_get_profile.return_value = {'name': 'Empty User'}\n        result = collect_user_data('', 'empty_sig')\n        mock_get_profile.assert_called_once_with('')\n        self.assertEqual(result, {'name': 'Empty User'})\n    \n    @patch('user_profile.TRUSTED_USER_PROFILES', {'valid_user': 'valid_sig'})\n    @patch('user_profile.get_profile_from_service')\n    def test_empty_user_invalid_signature(self, mock_get_profile):\n        \"\"\"Test with empty user identifier and invalid signature.\"\"\"\n        result = collect_user_data('', 'invalid_sig')\n        mock_get_profile.assert_not_called()\n        self.assertIsNone(result)\n    \n    @patch('user_profile.TRUSTED_USER_PROFILES', {'valid_user': 'valid_sig'})\n    @patch('user_profile.get_profile_from_service')\n    def test_empty_signature(self, mock_get_profile):\n        \"\"\"Test with valid user identifier and empty signature.\"\"\"\n        result = collect_user_data('valid_user', '')\n        mock_get_profile.assert_not_called()\n        self.assertIsNone(result)\n    \n    @patch('user_profile.TRUSTED_USER_PROFILES', {'long_user' * 100: 'long_sig' * 100})\n    @patch('user_profile.get_profile_from_service')\n    def test_long_inputs_valid(self, mock_get_profile):\n        \"\"\"Test with very long user identifier and matching signature.\"\"\"\n        long_user = 'long_user' * 100\n        long_sig = 'long_sig' * 100\n        mock_get_profile.return_value = {'name': 'Long User'}\n        result = collect_user_data(long_user, long_sig)\n        mock_get_profile.assert_called_once_with(long_user)\n        self.assertEqual(result, {'name': 'Long User'})\n    \n    @patch('user_profile.TRUSTED_USER_PROFILES', {'long_user' * 100: 'long_sig' * 100})\n    @patch('user_profile.get_profile_from_service')\n    def test_long_inputs_invalid(self, mock_get_profile):\n        \"\"\"Test with very long user identifier and invalid signature.\"\"\"\n        long_user = 'long_user' * 100\n        result = collect_user_data(long_user, 'invalid_sig')\n        mock_get_profile.assert_not_called()\n        self.assertIsNone(result)\n    \n    @patch('user_profile.TRUSTED_USER_PROFILES', {'123': 'signature123'})\n    @patch('user_profile.get_profile_from_service')\n    def test_non_string_user_identifier(self, mock_get_profile):\n        \"\"\"Test with non-string user identifier.\"\"\"\n        result = collect_user_data(123, 'signature123')\n        mock_get_profile.assert_not_called()\n        self.assertIsNone(result)\n    \n    @patch('user_profile.TRUSTED_USER_PROFILES', {'valid_user': '123'})\n    @patch('user_profile.get_profile_from_service')\n    def test_non_string_user_signature(self, mock_get_profile):\n        \"\"\"Test with non-string user signature.\"\"\"\n        result = collect_user_data('valid_user', 123)\n        mock_get_profile.assert_not_called()\n        self.assertIsNone(result)\n    \n    @patch('user_profile.TRUSTED_USER_PROFILES', {'valid_user': 'valid_sig'})\n    @patch('user_profile.get_profile_from_service')\n    def test_none_user_identifier(self, mock_get_profile):\n        \"\"\"Test with None as user identifier.\"\"\"\n        result = collect_user_data(None, 'valid_sig')\n        mock_get_profile.assert_not_called()\n        self.assertIsNone(result)\n    \n    @patch('user_profile.TRUSTED_USER_PROFILES', {'valid_user': 'valid_sig'})\n    @patch('user_profile.get_profile_from_service')\n    def test_none_user_signature(self, mock_get_profile):\n        \"\"\"Test with None as user signature.\"\"\"\n        result = collect_user_data('valid_user', None)\n        mock_get_profile.assert_not_called()\n        self.assertIsNone(result)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 14, "task_id": "40930348"}
{"test": "import unittest\nfrom unittest.mock import patch\n\nclass TestGetUserInfo(unittest.TestCase):\n\n    def test_happy_path(self):\n        \"\"\"Test with valid profile_id and matching signature.\"\"\"\n        with patch('__main__.TRUSTED_USER_PROFILES', {'user1': 'sig1'}):\n            with patch('__main__.get_profile_from_service') as mock_get:\n                mock_get.return_value = {'name': 'John Doe'}\n                result = get_user_info('user1', 'sig1')\n                self.assertEqual(result, {'name': 'John Doe'})\n                mock_get.assert_called_once_with('user1')\n\n    def test_mismatch_signature(self):\n        \"\"\"Test with valid profile_id but incorrect signature.\"\"\"\n        with patch('__main__.TRUSTED_USER_PROFILES', {'user1': 'sig1'}):\n            result = get_user_info('user1', 'wrong_sig')\n            self.assertIsNone(result)\n\n    def test_profile_id_not_found(self):\n        \"\"\"Test with profile_id not in TRUSTED_USER_PROFILES.\"\"\"\n        with patch('__main__.TRUSTED_USER_PROFILES', {'user1': 'sig1'}):\n            result = get_user_info('user2', 'any_sig')\n            self.assertIsNone(result)\n\n    def test_connection_error(self):\n        \"\"\"Test valid input but get_profile_from_service raises ConnectionError.\"\"\"\n        with patch('__main__.TRUSTED_USER_PROFILES', {'user1': 'sig1'}):\n            with patch('__main__.get_profile_from_service') as mock_get:\n                mock_get.side_effect = ConnectionError\n                result = get_user_info('user1', 'sig1')\n                self.assertIsNone(result)\n\n    def test_empty_profile_id_matching(self):\n        \"\"\"Test empty profile_id with matching signature in TRUSTED_USER_PROFILES.\"\"\"\n        with patch('__main__.TRUSTED_USER_PROFILES', {'': 'empty_sig'}):\n            with patch('__main__.get_profile_from_service') as mock_get:\n                mock_get.return_value = {'name': 'Empty User'}\n                result = get_user_info('', 'empty_sig')\n                self.assertEqual(result, {'name': 'Empty User'})\n\n    def test_empty_profile_id_mismatch(self):\n        \"\"\"Test empty profile_id with non-matching signature.\"\"\"\n        with patch('__main__.TRUSTED_USER_PROFILES', {'': 'empty_sig'}):\n            result = get_user_info('', 'wrong_sig')\n            self.assertIsNone(result)\n\n    def test_empty_profile_id_not_found(self):\n        \"\"\"Test empty profile_id not present in TRUSTED_USER_PROFILES.\"\"\"\n        with patch('__main__.TRUSTED_USER_PROFILES', {'user1': 'sig1'}):\n            result = get_user_info('', 'any_sig')\n            self.assertIsNone(result)\n\n    def test_non_string_profile_id(self):\n        \"\"\"Test non-string profile_id (integer) with matching signature value.\"\"\"\n        with patch('__main__.TRUSTED_USER_PROFILES', {'123': 'sig123'}):\n            result = get_user_info(123, 'sig123')\n            self.assertIsNone(result)\n\n    def test_non_string_profile_sig(self):\n        \"\"\"Test non-string profile_sig (integer) with matching signature key.\"\"\"\n        with patch('__main__.TRUSTED_USER_PROFILES', {'user1': '123'}):\n            result = get_user_info('user1', 123)\n            self.assertIsNone(result)\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 9, "task_id": "d19efd16"}
{"test": "import unittest\nfrom unittest.mock import patch\n\nclass TestRetrieveUserInfo(unittest.TestCase):\n    \n    def test_valid_uid_and_sig(self):\n        # Test with valid uid and matching signature returns profile data\n        with patch('__main__.TRUSTED_USER_PROFILES', {'user1': 'valid_sig'}):\n            with patch('__main__.get_profile_from_service') as mock_get_profile:\n                mock_get_profile.return_value = {'name': 'John Doe'}\n                result = retrieve_user_info('user1', 'valid_sig')\n                self.assertEqual(result, {'name': 'John Doe'})\n                mock_get_profile.assert_called_once_with('user1')\n    \n    def test_invalid_sig(self):\n        # Test valid uid but invalid signature returns None\n        with patch('__main__.TRUSTED_USER_PROFILES', {'user1': 'valid_sig'}):\n            with patch('__main__.get_profile_from_service') as mock_get_profile:\n                result = retrieve_user_info('user1', 'invalid_sig')\n                self.assertIsNone(result)\n                mock_get_profile.assert_not_called()\n    \n    def test_uid_not_found(self):\n        # Test uid not in TRUSTED_USER_PROFILES returns None\n        with patch('__main__.TRUSTED_USER_PROFILES', {'user1': 'valid_sig'}):\n            with patch('__main__.get_profile_from_service') as mock_get_profile:\n                result = retrieve_user_info('unknown_user', 'any_sig')\n                self.assertIsNone(result)\n                mock_get_profile.assert_not_called()\n    \n    def test_connection_error(self):\n        # Test valid credentials but ConnectionError during fetch returns None\n        with patch('__main__.TRUSTED_USER_PROFILES', {'user1': 'valid_sig'}):\n            with patch('__main__.get_profile_from_service') as mock_get_profile:\n                mock_get_profile.side_effect = ConnectionError\n                result = retrieve_user_info('user1', 'valid_sig')\n                self.assertIsNone(result)\n    \n    def test_empty_uid_valid_sig(self):\n        # Test empty uid with matching signature returns profile\n        with patch('__main__.TRUSTED_USER_PROFILES', {'': 'empty_sig'}):\n            with patch('__main__.get_profile_from_service') as mock_get_profile:\n                mock_get_profile.return_value = {'name': 'Empty User'}\n                result = retrieve_user_info('', 'empty_sig')\n                self.assertEqual(result, {'name': 'Empty User'})\n                mock_get_profile.assert_called_once_with('')\n    \n    def test_empty_uid_invalid_sig(self):\n        # Test empty uid with non-matching signature returns None\n        with patch('__main__.TRUSTED_USER_PROFILES', {'': 'empty_sig'}):\n            with patch('__main__.get_profile_from_service') as mock_get_profile:\n                result = retrieve_user_info('', 'wrong_sig')\n                self.assertIsNone(result)\n                mock_get_profile.assert_not_called()\n    \n    def test_long_strings(self):\n        # Test very long uid and sig strings work correctly\n        long_uid = 'u' * 1000\n        long_sig = 's' * 1000\n        with patch('__main__.TRUSTED_USER_PROFILES', {long_uid: long_sig}):\n            with patch('__main__.get_profile_from_service') as mock_get_profile:\n                mock_get_profile.return_value = {'name': 'Long User'}\n                result = retrieve_user_info(long_uid, long_sig)\n                self.assertEqual(result, {'name': 'Long User'})\n                mock_get_profile.assert_called_once_with(long_uid)\n    \n    def test_non_string_uid(self):\n        # Test non-string uid (integer) returns None\n        with patch('__main__.TRUSTED_USER_PROFILES', {'123': 'sig123'}):\n            with patch('__main__.get_profile_from_service') as mock_get_profile:\n                result = retrieve_user_info(123, 'sig123')\n                self.assertIsNone(result)\n                mock_get_profile.assert_not_called()\n    \n    def test_non_string_sig(self):\n        # Test non-string sig (integer) returns None\n        with patch('__main__.TRUSTED_USER_PROFILES', {'user1': 'valid_sig'}):\n            with patch('__main__.get_profile_from_service') as mock_get_profile:\n                result = retrieve_user_info('user1', 12345)\n                self.assertIsNone(result)\n                mock_get_profile.assert_not_called()\n\nif __name__ == '__main__':\n    unittest.main()", "num_test_cases": 9, "task_id": "f606edb4"}
